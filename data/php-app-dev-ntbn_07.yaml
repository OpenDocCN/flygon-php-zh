- en: Chapter 7. Building User Registration, Login, and Logout
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。构建用户注册，登录和注销
- en: Always plan ahead. It wasn't raining when Noah built the ark - Richard C. Cushing.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 提前规划。当诺亚建造方舟时，天空并没有下雨 - 理查德C.库欣。
- en: From this chapter onwards, we will get our hands dirty with professional PHP
    projects. We will design and develop a web applicaton where users can register
    themselves, and after registraton they can login to the applicaton, view, and
    update their own profle, and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将亲自动手进行专业的PHP项目。我们将设计和开发一个Web应用程序，用户可以在其中注册自己，注册后可以登录到应用程序，查看和更新自己的配置文件等。
- en: 'In this chapter, we will work out the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解决以下主题：
- en: Application architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序架构
- en: Designing the API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计API
- en: User registration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户注册
- en: User login and logout
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户登录和注销
- en: User profile view and update
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户配置文件查看和更新
- en: Planning the project
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划项目
- en: Project planning is always signified as planning for the future, which means
    that a project should be planned, as it can be extended easily or can be reusable,
    more modular, and even scalable. For this project, we will design the application
    architecture in a realistic manner, so the user registration, login, and logout
    application can also be easily used in our future projects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 项目规划总是被视为对未来的规划，这意味着项目应该被规划，因为它可以很容易地扩展或可重用，更模块化，甚至可扩展。对于这个项目，我们将以现实的方式设计应用程序架构，以便用户注册，登录和注销应用程序也可以在我们未来的项目中轻松使用。
- en: We will design the **Application Programming Interface** (**API**) and build
    the application using that API. The API will facilitate the application for any
    sort of user signup or signin related tasks, so that the core of the project is
    the API. Once we have the API ready, we can easily build a number of applications
    using that API.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计**应用程序编程接口**（**API**）并使用该API构建应用程序。该API将为任何类型的用户注册或登录相关任务提供便利，因此项目的核心是API。一旦API准备就绪，我们就可以轻松地使用该API构建多个应用程序。
- en: First of all, let's think about the API design. Remember that we will use some
    architectural pattern, that is the **Data Access Object** (**DAO**) pattern for
    our projects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑API设计。记住，我们将使用一些架构模式，即**数据访问对象**（**DAO**）模式用于我们的项目。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is strongly recommended for this project to have prior knowledge of **Object
    Oriented Programming** (**OOP**) concepts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议在此项目中具有**面向对象编程**（**OOP**）概念的先验知识。
- en: Understanding the application architecture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解应用程序架构
- en: 'The architecture needs to be built up in layers in data storage, data access,
    application services, and the application. This is depicted in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 架构需要在数据存储，数据访问，应用服务和应用程序中构建层。这在以下截图中有所体现：
- en: '![Understanding the application architecture](graphics/5801_07_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![理解应用程序架构](graphics/5801_07_01.jpg)'
- en: Each layer can be designated as a group of analogous logical tasks, as the data
    storage layer acts as a data source, such as a relational database, a filesystem,
    or any other data source. The **data access layer** communicates with the data
    source to get or store data from the **storage layer**, and provides a nice abstraction
    in the data source to be delivered to the **service layer**. The service layer
    is a medium of data persistence with the **application layer**, and also offers
    other services, such as a validation service. The **data access objects** reside
    in the data access layer, and the **business objects** reside in the **service
    layer**. Finally, the **applications** reside in the application layer, which
    directly deals with end users. So, the service layer could be the surface tier
    for our API, in such a layered design.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个层都可以被指定为一组类似的逻辑任务，因为数据存储层充当数据源，如关系数据库，文件系统或任何其他数据源。**数据访问层**与数据源通信，从**存储层**获取或存储数据，并在数据源中提供良好的抽象以交付给**服务层**。服务层是与**应用层**进行数据持久化的媒介，并提供其他服务，如验证服务。**数据访问对象**位于数据访问层，**业务对象**位于**服务层**。最后，**应用程序**位于应用层，直接与最终用户打交道。因此，在这样的分层设计中，服务层可以成为我们API的表面层。
- en: 'Now, let''s consider particular functionalities, such as registration, login,
    validation, and data abstraction into each unit or module. So, each layer will
    have compulsory units, as shown in the following diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑特定的功能，比如注册，登录，验证和数据抽象到每个单元或模块中。因此，每个层都将有强制单元，如下图所示：
- en: '![Understanding the application architecture](graphics/5801_07_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![理解应用程序架构](graphics/5801_07_02.jpg)'
- en: We can easily understand that each layer contains its appropriate modules. For
    example, the DAO module resides in the data access layer, the service layer has
    its service units such as Validation, and the user service module and application
    layer contain user login, user registration, user profile, and admin modules.
    For our project to grasp the architectural concepts quickly, we will try to keep
    each module as a simple PHP class with associated codes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地理解每个层都包含其适当的模块。例如，DAO模块位于数据访问层，服务层具有其服务单元，如验证和用户服务模块，应用层包含用户登录，用户注册，用户配置文件和管理员模块。为了快速掌握架构概念，我们将尝试将每个模块保持为一个简单的PHP类，并附带代码。
- en: So, let's have a quick look at what we will be building finally.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们快速看一下最终我们将要构建的内容。
- en: 'The following screenshot represents the **User Registration** screen with **Name,
    Email, Password**, and **Phone** fields:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图代表了**用户注册**屏幕，包括**姓名，电子邮件，密码**和**电话**字段：
- en: '![Understanding the application architecture](graphics/5801_07_03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![理解应用程序架构](graphics/5801_07_03.jpg)'
- en: 'The following screenshot represents the **User Login** screen with the **Remember
    me next time** option:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图代表了**用户登录**屏幕，包括**下次记住我**选项：
- en: '![Understanding the application architecture](graphics/5801_07_04.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![理解应用程序架构](graphics/5801_07_04.jpg)'
- en: 'The following screenshot represents the **User Profile** view with the **Logout**
    and **Edit Account** menus at the top:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图代表了**用户配置文件**视图，顶部有**注销**和**编辑帐户**菜单：
- en: '![Understanding the application architecture](graphics/5801_07_05.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![理解应用程序架构](graphics/5801_07_05.jpg)'
- en: Understanding the DAO pattern
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解DAO模式
- en: The DAO is used to abstract and encapsulate all access to the data source. The
    DAO manages the connection with the data source, to obtain and store the data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: DAO用于抽象和封装对数据源的所有访问。DAO管理与数据源的连接，以获取和存储数据。
- en: '"The DAO implements the access mechanism required to work with the data source.
    The data source could be a persistent store like an RDBMS, an external service
    like a B2B exchange, a repository like an LDAP database, or a business service
    or low-level sockets. The business component that relies on the DAO uses the simpler
    interface exposed by the DAO for its clients.'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “DAO实现了与数据源一起工作所需的访问机制。数据源可以是像RDBMS这样的持久存储，像B2B交换这样的外部服务，像LDAP数据库这样的存储库，或者像业务服务或低级套接字这样的业务服务。依赖DAO的业务组件使用DAO为其客户端提供的更简单的接口。
- en: The DAO completely hides the data source implementation details from its clients
    (data client). Because the interface exposed by the DAO to clients does not change
    when the underlying data source implementation changes, this pattern allows the
    DAO to adapt to different storage schemes without affecting its clients or business
    components. Essentially, the DAO acts as an adapter between the component and
    the data source. The pattern originates from the core J2EE pattern."
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: DAO完全隐藏了数据源的实现细节，使其客户端（数据客户端）无法看到。因为DAO向客户端公开的接口在基础数据源实现更改时不会改变，所以该模式允许DAO适应不同的存储方案，而不会影响其客户端或业务组件。基本上，DAO充当组件与数据源之间的适配器。该模式源自核心J2EE模式。”
- en: '[http://java.sun.com/blueprints/corej2eepatterns/Patterns/DataAccessObject.html](http://java.sun.com/blueprints/corej2eepatterns/Patterns/DataAccessObject.html).'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://java.sun.com/blueprints/corej2eepatterns/Patterns/DataAccessObject.html](http://java.sun.com/blueprints/corej2eepatterns/Patterns/DataAccessObject.html)。'
- en: 'The purpose of using DAO is relatively simple, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DAO的目的相对简单，如下所示：
- en: It can be used in a large percentage of applications, wherever data storage
    is required
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在大部分应用程序中使用，无论何时需要数据存储
- en: It hides all the details of the data storage from the rest of the application
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将所有数据存储的细节隐藏在应用程序的其余部分之外
- en: It acts as an intermediary between your application and the database
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它充当您的应用程序与数据库之间的中介
- en: It allows ripple effects from the possible changes to the persistence mechanism
    to be confined to a specific area
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许将可能的持久性机制更改的连锁效应限制在特定区域
- en: Reviewing OOP issues
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查面向对象编程问题
- en: 'Let''s have a look at a few object-oriented programming keywords for access
    modifiers or properties:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下一些面向对象编程关键字，用于访问修饰符或属性：
- en: '`Public:` This property or method can be used from anywhere in the script.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共：此属性或方法可以在脚本的任何地方使用。
- en: '`Private:` This property or method can be used only by the class or object
    it is part of; it cannot be accessed elsewhere.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有：此属性或方法只能被其所属的类或对象使用；它不能在其他地方被访问。
- en: '`Protected:` This property or method can be used only by code in the class
    it is part of, or by children of that class.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`受保护：`此属性或方法只能由其所属的类中的代码或该类的子类使用。'
- en: '`Final:` This method, or class, cannot be overridden in subclasses.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终：此方法或类不能在子类中被覆盖。
- en: '`Abstract:` This method or class cannot be used directly, and you have to subclass
    this; it cannot be instantiated.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摘要：这种方法或类不能直接使用，你必须对其进行子类化；它不能被实例化。
- en: '`Static:` This property or method belongs to the class itself and not to any
    instance of it. You can also think of static properties as global variables that
    sit inside a class, but are accessible from anywhere via the class. Static members
    can be accessed using the `::` operator after the class name.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`静态：`此属性或方法属于类本身，而不属于其任何实例。您也可以将静态属性视为全局变量，它们位于类内部，但可以通过类从任何地方访问。可以使用`::`运算符在类名之后访问静态成员。'
- en: Namespace
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: '"A namespace (sometimes also called a name scope) is an abstract container
    or environment created to hold a logical grouping of unique identifiers or symbols
    (i.e., names). An identifier defined in a namespace is associated only with that
    namespace. The same identifier can be independently defined in multiple namespaces."'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “命名空间（有时也称为名称范围）是一个抽象的容器或环境，用于保存一组唯一标识符或符号（即名称）。在命名空间中定义的标识符仅与该命名空间相关联。相同的标识符可以在多个命名空间中独立定义。”
- en: '- Wikipedia'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- 维基百科'
- en: '**Namespaces** were introduced into PHP from version 5.3 onwards. In PHP, a
    namespace is defined using a namespace block.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名空间**从PHP 5.3版本开始引入。在PHP中，命名空间是使用命名空间块定义的。'
- en: 'In the PHP world, namespaces are designed to solve two problems, which authors
    of libraries and applications encounter when creating reusable code elements,
    such as classes or functions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP世界中，命名空间旨在解决两个问题，即库和应用程序的作者在创建可重用的代码元素（如类或函数）时遇到的问题：
- en: Ability to avoid name collisions between the code you create, and internal PHP
    classes/functions/constants or third-party classes/functions/constants
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够避免您创建的代码与内部PHP类/函数/常量或第三方类/函数/常量之间的名称冲突
- en: Ability to alias (or shorten) extra-long names designed to alleviate the first
    problem, improving the readability of the source code
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够别名（或缩短）设计用于缓解第一个问题的超长名称，提高源代码的可读性
- en: 'PHP namespaces provide a way to group related classes, interfaces, functions,
    and constants. Here is an example of a namespace''s usage in PHP:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: PHP命名空间提供了一种将相关类、接口、函数和常量分组的方法。以下是PHP中命名空间使用的示例：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can use classes of the same name and reference with the PHP namespace, in
    the following way:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同名称的类，并通过PHP命名空间引用，如下所示：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We will use `My` as a common root namespace for the whole application, `My\Dao`
    for our data access layer classes, and `My\Service` for our Service layer classes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`My`作为整个应用程序的常见根命名空间，`My\Dao`用于我们的数据访问层类，`My\Service`用于我们的服务层类。
- en: The API
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API
- en: In object-oriented languages, an API usually includes a description of a set
    of class definitions, with a set of behaviors associated with those classes. A
    behavior is a set of rules for how an object, derived from that class, will act
    in a given circumstance. This abstract concept is associated with the real functionalities
    exposed or made available by the classes, which are implemented in terms of class
    methods (or more generally, by all its public components, hence all public methods,
    but also possibly including any internal entity made public, such as fields, constants,
    and nested objects).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的语言中，API通常包括一组类定义的描述，以及与这些类相关联的一组行为。行为是指对象从该类派生后在特定情况下的行为规则。这个抽象概念与类方法（或更一般地说，与所有公共组件，因此所有公共方法，但也可能包括任何公开的内部实体，如字段、常量和嵌套对象）实现的真实功能相关联。
- en: For instance, a class representing a stack can simply expose two methods publicly—`push()`
    (to add a new item to the stack), and `pop()` (to extract the last item, ideally
    placed on top of the stack).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，表示堆栈的类可以简单地公开两个方法-`push()`（向堆栈添加新项）和`pop()`（提取最后一项，理想情况下放在堆栈顶部）。
- en: In this case, the API can be interpreted as two methods—`pop()` and `push()`.
    More generally, the idea is, one can use methods of the `Stack` class that implements
    the behavior of a stack (pile exposing its top to add/remove elements).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，API可以解释为两种方法-`pop()`和`push()`。更一般地说，这个想法是，可以使用实现堆栈行为的`Stack`类的方法（堆栈暴露其顶部以添加/删除元素）。
- en: So far, so good. We have the concepts about our project, and we know NetBeans
    features very well. Now, let's get down to the development...
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好。我们对项目的概念有了了解，并且我们对NetBeans的功能非常了解。现在，让我们开始开发...
- en: Designing the database
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计数据库
- en: In this section, we will design our MySQL database. Since we learned how to
    create a database connection, new database, new table, and how to run a MySQL
    query inside NetBeans in [Chapter 3](ch03.html "Chapter 3. Building a Facebook-like
    Status Poster using NetBeans"), *Building a Facebook-like Status Poster Using
    NetBeans*, we won't discuss them again, but we'll have a look at the database
    schema definition.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设计我们的MySQL数据库。由于我们已经学会了如何在NetBeans中创建数据库连接、新数据库、新表，以及如何运行MySQL查询，我们不会再讨论它们，但我们会看一下数据库模式定义。
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we have `id` (auto incremented with each entry) as the primary
    key and `useremail` as the unique key in the `users` table. We have a `password`
    field to store the user's password to up to 32 characters; `userhash` of 32 characters
    will store the user's login session identifier; `userlevel` to define the user's
    access level, for example, a normal user as `1`, an admin user as `9`, and so
    on; a `username` field to support maximum 100 characters; a `phone` field to store
    a user's contact number; and a `timestamp` field to keep track of a user's registration
    time. The database engine chosen is **InnoDB**, as it supports transactions and
    foreign keys over the **MyISAM** engine, to avoid table locking during `insert`
    and `update` operations by any user.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在`users`表中有`id`（每个条目自动递增）作为主键，`useremail`作为唯一键。我们有一个`password`字段，用于存储用户的密码，最多32个字符；`userhash`有32个字符，用于存储用户的登录会话标识符；`userlevel`用于定义用户的访问级别，例如，普通用户为`1`，管理员用户为`9`，等等；一个`username`字段，支持最多100个字符；一个`phone`字段，用于存储用户的联系电话；以及一个`timestamp`字段，用于跟踪用户的注册时间。所选择的数据库引擎是**InnoDB**，因为它支持事务和外键，而**MyISAM**引擎不支持在任何用户进行`insert`和`update`操作时避免表锁定。
- en: So, all you need to do is to create a new database named `user`, just type in
    the MySQL query inside the NetBeans query editor, and run the query to have your
    table ready in the `user` database.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您只需要创建一个名为`user`的新数据库，只需在NetBeans查询编辑器中键入MySQL查询，然后运行查询，即可在`user`数据库中准备好您的表。
- en: Now, create a NetBeans PHP project and start the User API development along
    with the subsequent sections.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个NetBeans PHP项目，并开始用户API开发以及后续部分。
- en: Creating the data access layer
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据访问层
- en: The data access layer will consist of a User DAO class to provide database abstraction
    and an abstract Base DAO class to provide abstract methods, which is required
    for the User DAO class to be implemented. Also, we will create the abstract class
    to provide abstract methods for DAO classes to be created in our future projects.
    Note that we will use PHP namespace, `My\Dao`, for the data access layer classes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 数据访问层将包括一个User DAO类，用于提供数据库抽象，以及一个抽象的Base DAO类，用于提供抽象方法，这是User DAO类需要实现的。此外，我们将创建抽象类，以提供DAO类在我们未来项目中创建的抽象方法。请注意，我们将使用PHP命名空间`My\Dao`用于数据访问层类。
- en: Creating the BaseDao abstract class
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建BaseDao抽象类
- en: The abstract class will be used to provide a basic framework for subclasses
    to implement methods. Simply, the basic database operations are `CRUD` or `create,
    read, update`, and `delete`. So, the abstract class will provide these types of
    abstract methods along with methods that will be required in every subclass. The
    `BaseDao` abstract class will contain the `final` method for database connectivity,
    so the subclasses don't need to write it again. To understand this better, we
    will keep our DAO classes in a separate directory named `Dao` as well.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个抽象类将用于为子类实现方法提供基本框架。简单地说，基本的数据库操作是`CRUD`或`create, read, update`和`delete`。因此，抽象类将提供这些类型的抽象方法，以及每个子类都需要的方法。`BaseDao`抽象类将包含用于数据库连接的`final`方法，因此子类不需要再次编写它。为了更好地理解这一点，我们将把我们的DAO类放在一个名为`Dao`的单独目录中。
- en: Time for action — creating the BaseDao class
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建BaseDao类
- en: 'To use with a database connection, we will keep the database access credentials
    as their own class constants. Also, we will use PDO for all sorts of database
    operations. To create the `Base` class, go through the following steps:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与数据库连接一起使用，我们将保留数据库访问凭据作为它们自己的类常量。此外，我们将使用PDO进行各种数据库操作。要创建`Base`类，请按照以下步骤进行：
- en: 'Create a new PHP file inside the `Dao` directory named `BaseDao.php`, and type
    in the following class:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Dao`目录中创建一个名为`BaseDao.php`的新PHP文件，并键入以下类：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can see that this class `uses namespace My\Dao;`, and there is also an `abstract`
    keyword before the class name, which defines the class as abstract. This means
    that the class cannot be instantiated or has at least a single abstract method
    inside. Also, you can see the added class constants, which contain the database
    information and a private class variable `$db` to hold the database connection.
    You may modify those constants as per your requirements.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到这个类`使用命名空间My\Dao;`，并且在类名之前还有一个`abstract`关键字，这将类定义为抽象类。这意味着该类不能被实例化，或者至少在内部有一个抽象方法。此外，您可以看到添加的类常量，其中包含数据库信息和一个私有类变量`$db`来保存数据库连接。您可以根据需要修改这些常量。
- en: 'Now, add the following `getDb()` method in the class:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在类中添加以下`getDb()`方法：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `protected final function getDb()` function connects with the MySQL database
    using PDO. The private variable of the class stores the PDO instance that can
    be used for database connectivity. Moreover, the `getDb()` method is `final` and
    `protected`, so the subclasses inherit this method and unable to override it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected final function getDb()`函数使用PDO连接到MySQL数据库。类的私有变量存储了可以用于数据库连接的PDO实例。此外，`getDb()`方法是`final`和`protected`的，因此子类继承此方法并且无法覆盖它。'
- en: 'The `$dsn` variable contains the **Data Source Name (DSN)**, which contains
    the information required to connect to the database. The following line creates
    a PDO instance to represent a connection to the requested database and returns
    a PDO object on its success:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`$dsn`变量包含**数据源名称（DSN）**，其中包含连接到数据库所需的信息。以下行创建一个PDO实例，表示与请求的数据库的连接，并在成功时返回一个PDO对象：'
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the DSN throws a `PDOException` exception, if the attempt to connect
    to the requested database fails. We prefixed PDO with the backslash \, so PHP
    knows it's in the global namespace.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果尝试连接到请求的数据库失败，DSN会抛出`PDOException`异常。我们在PDO前面加上反斜杠\，这样PHP就知道它在全局命名空间中。
- en: 'Add the following `abstract` methods to the class:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加以下`abstract`方法：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can see that the methods to be implemented by the subclasses are denoted
    as `abstract protected,` and the `get()` method will be used to select a single
    entry from the table based on a unique table key, `insert()` will insert a row
    into the table, `update()` will be used to update a row in the table, and `delete()`
    will be used to delete an entry. So, all these methods have been kept abstract
    (without the method body), as they will be implemented by using the subclasses.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到子类要实现的方法被标记为`abstract protected`，`get()`方法将用于根据唯一表键从表中选择单个条目，`insert()`将在表中插入一行，`update()`将用于更新表中的一行，`delete()`将用于删除一个条目。因此，所有这些方法都被保留为抽象方法（没有方法体），因为它们将通过子类来实现。
- en: What just happened?
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We have the `BaseDao` abstract class ready to be inherited by the DAO classes.
    The PDO instance is created and returned from the method, so all the subclasses
    will have the `getDb()` method, and can have this returned instance to perform
    some sort of database tasks using PDO. Finally, subclasses will implement the
    `abstract` methods as per their demand. For example, in the next tutorial, the
    User DAO class will implement the `get()` method to select and return a single
    user registration information matching the user's e-mail address from the `users`
    table, or the Product DAO class will implement the `get()` method to select and
    return single product information from the `products` table matching the product
    ID. Hence, the intention to practice such an abstract class is to deliver the
    basic framework for the Dao classes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好继承DAO类的`BaseDao`抽象类。从该方法中创建并返回PDO实例，因此所有子类都将具有`getDb()`方法，并且可以使用此返回的实例来执行某种数据库任务。最后，子类将根据需要实现`abstract`方法。例如，在下一个教程中，User
    DAO类将实现`get()`方法，以选择并返回与用户的电子邮件地址匹配的单个用户注册信息，或者Product DAO类将实现`get()`方法，以选择并返回与产品ID匹配的单个产品信息。因此，使用这样的抽象类的意图是为Dao类提供基本框架。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: One of the biggest advantages of using PDO is that if we want to migrate into
    other SQL solutions, all we need is to adjust the DSN parameter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PDO的最大优势之一是，如果我们想迁移到其他SQL解决方案，我们只需要调整DSN参数。
- en: Creating the User DAO class
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建User DAO类
- en: In this tutorial, we will create the User DAO class, which will provide all
    sorts of database tasks inside it. This class will keep the database hidden from
    the consecutive layers, that is the Service layer class. So, all the consecutive
    layer classes will call methods from this class and have all the necessary database
    work done by this class, while the data storage details are completely hidden
    to them. So, this class will act as an intermediary between the database and the
    application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将创建User DAO类，该类将在其中提供各种数据库任务。这个类将隐藏数据库，不让连续的层次访问到它，也就是服务层类。因此，所有连续的层次类将调用这个类的方法，并且由这个类完成所有必要的数据库工作，而数据存储细节对它们完全隐藏。因此，这个类将充当数据库和应用程序之间的中介。
- en: Time for action — creating the User Dao class
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——创建User Dao类
- en: 'We will keep the relevant user constants as class constants. We will write
    the implementation of the methods from the `BaseDao` abstract class in this class.
    Simply, we will add the body of those abstract methods and our own methods required
    into the class. So, follow the steps listed here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留相关的用户常量作为类常量。我们将在这个类中编写`BaseDao`抽象类中方法的实现。简单地说，我们将把这些抽象方法的主体和我们自己所需的方法添加到类中。因此，请按照以下步骤进行操作：
- en: 'Create a new PHP file inside the `Dao` directory named `UserDao.php`, and type
    in the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Dao`目录中创建一个名为`UserDao.php`的新PHP文件，并键入以下代码：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the class is under the `My\Dao` namespace and extends to the
    `BaseDao` class, so the class will have methods inherited from the parent. The
    Dao class has its own private `$db`, which stores the PDO instance returned by
    the inherited `getDb()` method; as you can see, this `$db` variable is assigned
    to the class constructor.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，该类位于`My\Dao`命名空间下，并扩展到`BaseDao`类，因此该类将具有从父类继承的方法。Dao类有自己的私有`$db`，它存储了从继承的`getDb()`方法返回的PDO实例；正如您所看到的，这个`$db`变量被分配给了类构造函数。
- en: Also, you might have noticed that the `UserDao` class has been instantiated
    at the bottom.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，您可能已经注意到`UserDao`类已在底部实例化。
- en: 'Type in the implementation of the `get()` method (add the method to the class),
    so that it looks similar to the following:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入`get()`方法的实现（将该方法添加到类中），使其看起来类似于以下内容：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see that the `prepare()` method prepares the SQL statement to be executed
    by the `PDOStatement::execute()` method. As you can see, the following statement
    query is used to select all the columns of a row from the `users` table, while
    the given e-mail address in `:useremail` (parameter bound with `bindParam()`)
    matches the `useremail` column.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，`prepare()`方法准备了要由`PDOStatement::execute()`方法执行的SQL语句。正如您所看到的，以下语句查询用于从`users`表中选择一行的所有列，而`：useremail`中的给定电子邮件地址（与`bindParam()`绑定的参数）匹配`useremail`列。
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, if a matching row is found, fetch the array containing the user details
    and return.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果找到匹配的行，则获取包含用户详细信息的数组并返回。
- en: 'Type in the implementation of the `insert()` method, so that it looks similar
    to the following:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入`insert()`方法的实现，使其看起来类似于以下内容：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The method takes the user info passed in an array, prepares the MySQL `insert`
    query for the `users` table, and executes the query. Note that we have kept the
    field names in the `$fields` array and field values in the `$vals` array extracted
    from the keys and values of passed arrays respectively. We have used ? in place
    of all the given values for the prepared statement, which will be replaced with
    the corresponding value bound with the `PDOStatement::bindValue()` method. `bindValue()`
    binds a value to a parameter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受传入的用户信息数组，准备`users`表的MySQL `insert`查询，并执行该查询。请注意，我们已经将字段名称保留在`$fields`数组中，并将字段值保留在`$vals`数组中，这些值分别从传递的数组的键和值中提取。我们在准备的语句中使用？代替所有给定值，这些值将被绑定到`PDOStatement::bindValue()`方法中。`bindValue()`将一个值绑定到一个参数。
- en: 'Type in the implementation of the `update()` method, so that it looks similar
    to the following:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update()`方法的实现中键入代码，使其看起来类似于以下内容：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It prepares the MySQL `UPDATE` query statement in the same way as *step 3*,
    and executes the query to update the corresponding column values in the row with
    the given ID.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 它以与*步骤3*相同的方式准备了MySQL `UPDATE`查询语句，并执行了该查询以更新具有给定ID的行中的相应列值。
- en: 'You may leave the other implementation as an empty enclosing body, as follows,
    or you can add your own code, as required:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以将其他实现留空，如下所示，或根据需要添加自己的代码：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we may implement the method to delete a user in future, we have left the
    `delete()` method's body empty.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能会在将来实现删除用户的方法，因此我们留空了`delete()`方法的主体。
- en: 'Now, we need some additional methods to be written in the class. While registering
    a user with any e-mail address, we can check our database to see if the e-mail
    address already exists in the table or not. Type in the following method:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在类中编写一些额外的方法。在注册用户时，我们可以检查我们的数据库，看看表中是否已经存在该电子邮件地址。键入以下方法：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `useremailTaken()` method takes an e-mail address as the parameter to check
    whether that e-mail ID exists or not. It does the task by running a `SELECT` query
    with the given e-mail address in the `WHERE` clause. If any row is found, then
    it means that the e-mail address already exists, and hence the method returns
    `true`, or otherwise `false`. With this method, we can ensure that one e-mail
    address can be used only once in the system, and duplicate e-mail addresses are
    not allowed as this is a unique field.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`useremailTaken()`方法接受一个电子邮件地址作为参数，以检查该电子邮件ID是否存在。它通过在`WHERE`子句中使用给定的电子邮件地址运行`SELECT`查询来执行该任务。如果找到任何行，则意味着该电子邮件地址已经存在，因此该方法返回`true`，否则返回`false`。通过这种方法，我们可以确保系统中一个电子邮件地址只能使用一次，并且不允许重复的电子邮件地址，因为这是一个唯一的字段。'
- en: 'To confirm the user''s password during login, type in the following `checkPassConfirmation()`
    method:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在登录时确认用户的密码，请键入以下`checkPassConfirmation()`方法：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The method takes `$useremail` and `$password` as the parameter, and selects
    the `password` column for matching the user's e-mail. Now, if no row is found
    matching the criteria, then it means that the user's e-mail does not exist in
    the table, and `false 1` is returned; and if a matching row is found, then the
    array is fetched from the result to obtain the password. Finally, the fetched
    password from the database is compared with the given password in the second parameter.
    If they match, then `true` is returned. So, we can use this method to confirm
    the password for the given corresponding user's e-mail, while the user attempts
    to log in with them and can easily track the status with returned Boolean values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法以`$useremail`和`$password`作为参数，并选择`password`列以匹配用户的电子邮件。现在，如果找不到匹配条件的行，则意味着用户的电子邮件在表中不存在，并返回`false
    1`；如果找到匹配的行，则从结果中获取数组以获得密码。最后，将从数据库中获取的密码与第二个参数中给定的密码进行比较。如果它们匹配，则返回`true`。因此，我们可以使用这个方法来确认给定对应用户的电子邮件的密码，当用户尝试使用它们登录时，可以轻松跟踪返回的布尔值的状态。
- en: 'Also, we have already added a field in the `users` table named `userhash`.
    The field stores a hash value (random alphanumeric string) for each login session,
    so we want to confirm that `userhash`, in order to verify if the user is currently
    logged in. Type in the following method:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们已经在`users`表中添加了一个名为`userhash`的字段。该字段存储每个登录会话的哈希值（随机的字母数字字符串），因此我们希望确认`userhash`，以验证用户当前是否已登录。输入以下方法：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `checkHashConfirmation()` method is the same as the previous method in *step
    7* and takes `$useremail` and `$useremail` as parameters, fetches `useremail`
    for the given e-mail address, and compares itself with the given `useremail`.
    So, the method that can be used to compare the `useremail` is the same for both
    the session and the database. If it is the same, it means that the user is currently
    logged in, because each new login updates the corresponding `useremail` in the
    table.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkHashConfirmation()`方法与*步骤7*中的先前方法相同，以`$useremail`和`$useremail`作为参数，为给定的电子邮件地址获取`useremail`，并将其与给定的`useremail`进行比较。因此，可以用来比较`useremail`的方法对于会话和数据库都是相同的。如果相同，则意味着用户当前已登录，因为每次新登录都会更新表中对应的`useremail`。'
- en: What just happened?
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: Calling `PDO::prepare()` and `PDOStatement::execute()` for statements, which
    will be issued multiple times with different parameter values, optimizes the performance
    of your application, by allowing the driver to negotiate the client and/or server-side
    caching of the query plan and meta information, and helps to prevent SQL injection
    attacks, by eliminating the need to manually quote the parameters.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多次使用不同参数值发出的语句，调用`PDO::prepare()`和`PDOStatement::execute()`可以优化应用程序的性能，通过允许驱动程序协商查询计划和元信息的客户端和/或服务器端缓存，并帮助防止SQL注入攻击，通过消除手动引用参数的需要。
- en: We now have the User DAO class ready, and the DAO layer is also complete inside
    the `Dao` directory in our NetBeans project. So, the User DAO class is ready to
    provide the required sort of database operations. The database operations can
    be dealt with in a way such as we have done, so that other subsequent classes
    don't need to access or rewrite database functionalities, and hence abstraction
    around the database has been achieved. We can add any sort of database-related
    methods in this class, to make them available for the Service classes. Now, the
    instantiated object will serve as a data access object, which means this object
    has access to the data in the data source, and anyone can read or write data via
    this object.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了User DAO类，并且DAO层也在我们NetBeans项目的`Dao`目录中完成。因此，User DAO类已准备好提供所需的数据库操作。可以以我们所做的方式处理数据库操作，以便其他后续类不需要访问或重写数据库功能，因此已实现对数据库的抽象。我们可以在这个类中添加任何类型的与数据库相关的方法，以便让它们可用于Service类。现在，实例化的对象将作为数据访问对象，这意味着该对象可以访问数据源中的数据，任何人都可以通过该对象读取或写入数据。
- en: Pop quiz — reviewing PDO
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验-回顾PDO
- en: Which one is correct for the `bindValue()` and `bindParam()` methods of PDO?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bindValue()`和`bindParam()`方法的哪一个是正确的？'
- en: You can only pass variables, not values using `bindParam`, and you can pass
    both with `bindValue`
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您只能使用`bindParam`传递变量，使用`bindValue`可以同时传递值和变量
- en: You can only pass values using `bindParam`, and you can pass only variables
    with `bindValue`
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您只能使用`bindParam`传递值，只能使用`bindValue`传递变量
- en: You can pass variables using `bindParam`, and you can pass values with `bindValue`
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`bindParam`传递变量，使用`bindValue`可以传递值
- en: Both are the same
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两者是相同的
- en: Now, let's create the Service layer for our API.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的API创建Service层。
- en: Creating the Service layer
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Service层
- en: The Service layer contains classes to serve applications, or simply provides
    a framework for the application. The application layer will communicate with this
    layer to have all sorts of application services, such as user authentication,
    user information registration, login session validation, and form validation.
    For a better understanding, we will keep our service classes inside a separate
    directory named `Service` and use the namespace `My\Service`, for the classes
    of this layer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Service层包含用于为应用程序提供服务的类，或者简单地为应用程序提供框架。应用程序层将与该层通信，以获得各种应用程序服务，例如用户身份验证、用户信息注册、登录会话验证和表单验证。为了更好地理解，我们将把我们的服务类放在一个名为`Service`的单独目录中，并为该层的类使用命名空间`My\Service`。
- en: Creating the ValidatorService class
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建ValidatorService类
- en: This class will perform validation tasks, such as form validation and login
    information validation, and also save to deliver form error messages and field
    values.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该类将执行验证任务，例如表单验证和登录信息验证，并保存以提供表单错误消息和字段值。
- en: Time for action — creating the ValidatorService class
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建ValidatorService类
- en: 'We will keep some validation constants in the class itself, and the class will
    use `My\Service` as its namespace. Follow these steps to create the `ValidatorService`
    class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在类本身中保留一些验证常量，并且该类将使用`My\Service`作为其命名空间。按照以下步骤创建`ValidatorService`类：
- en: Create a new directory named `Service` under your project directory. The Service
    classes will be inside this directory.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目目录下创建一个名为`Service`的新目录。Service类将位于此目录中。
- en: 'Create a new PHP file inside the `Service` directory named `ValidatorService.php`,
    and type in the following class:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Service`目录中创建一个名为`ValidatorService.php`的新PHP文件，并输入以下类：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the class is under the `My\Service` namespace and imports the `My\Dao\UserDao`
    class.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该类位于`My\Service`命名空间下，并导入`My\Dao\UserDao`类。
- en: You can see the class variable `$values`, which holds the submitted form values;
    `$errors`, which holds the submitted form error messages; `$statusMsg`, which
    holds the submitted status message that is success or temporary information; and
    `$num_errors,` which holds the number of errors in submitted form.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到类变量`$values`，它保存了提交的表单数值；`$errors`，它保存了提交的表单错误消息；`$statusMsg`，它保存了提交的状态消息，可以是成功或临时信息；以及`$num_errors`，它保存了提交表单中的错误数量。
- en: We also added class constants for validation purposes. We keep the username
    length within 5 and 100 characters and the `password` field length between 8 and
    32 characters.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为验证目的添加了类常量。我们将用户名长度保持在5到100个字符之间，将`password`字段长度保持在8到32个字符之间。
- en: As the class is dependent on the UserDao class, we injected the `$userDao` object
    inside, using a `setter` method `setUserDao()`; the `$userDao` object passed is
    stored in a class variable, so that the DAO can be used in other methods as well.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该类依赖于UserDao类，我们使用`setter`方法`setUserDao()`将`$userDao`对象注入其中；传递的`$userDao`对象存储在一个类变量中，以便DAO也可以在其他方法中使用。
- en: 'Now, fill in the class constructor, so that it looks similar to the following:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，填写类构造函数，使其看起来类似于以下内容：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can see that both `$_SESSION[''value_array'']` and `$_SESSION[''error_array'']`
    have been checked initially. If they have some value set, then assign them to
    the corresponding class variables, as shown in the following example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，`$_SESSION['value_array']`和`$_SESSION['error_array']`都已经被最初检查。如果它们有一些值设置，那么将它们分配给相应的类变量，如下例所示：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Also, `num_errors` has been adjusted with the count of the `errors` array. Note
    that values in `$_SESSION['value_array']` and `$_SESSION['error_array']` will
    be set by the application class from where this service API will be used. These
    session variables have been unset immediately after grabbing their values to make
    them prepare for the next form submission. If these variables haven't been set,
    `num_errors` should be `0` (zero).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 还调整了`num_errors`与`errors`数组的计数。请注意，`$_SESSION['value_array']`和`$_SESSION['error_array']`中的值将由应用程序类设置，该类将使用此服务API。立即在抓取其值后取消设置这些会话变量，以便为下一个表单提交做好准备。如果这些变量尚未设置，则`num_errors`应为`0`（零）。
- en: It also checks the `$_SESSION['statusMsg']` variable. If any status message
    has been set, grab the message into appropriate class variables and unset it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 它还检查`$_SESSION['statusMsg']`变量。如果已设置任何状态消息，请将消息抓取到相应的类变量中并取消设置。
- en: 'Now, type in the form and error handler methods into the class, as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照以下方式在类中输入表单和错误处理方法：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In these class methods, you can see that `setValue($field, $value)` and `getValue($field)`
    methods are used to set and get the value of a single corresponding field, respectively.
    Similarly, `setError($field, $errmsg)` and `getError($field)` set and get the
    error message for a corresponding form field value while validating, while at
    the same time, setError increases the `num_errors` value. Finally, `getErrorArray()`
    returns the complete error messages array.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些类方法中，您可以看到`setValue($field, $value)`和`getValue($field)`方法分别用于设置和获取单个相应字段的值。同样，`setError($field,
    $errmsg)`和`getError($field)`在验证时设置和获取相应表单字段值的错误消息，同时setError增加`num_errors`的值。最后，`getErrorArray()`返回完整的错误消息数组。
- en: 'Now, type in the value validation methods of the form field as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照以下方式输入表单字段的值验证方法：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The validation methods can be described as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 验证方法可以描述如下：
- en: '`validate($field, $value)` is the entry function for validation. Methods for
    input validation, such as empty string checking, correct input format, or input
    size range, can be called from this method, and it also returns `true` if the
    validation passes, or `false` otherwise.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validate($field, $value)`是验证的入口函数。可以从该方法调用输入验证的方法，例如空字符串检查、正确的输入格式或输入大小范围，并且如果验证通过，则返回`true`，否则返回`false`。'
- en: '`isEmpty($field, $value)` checks whether the string is empty or not, then sets
    the error message for that field and returns `false` or `true` otherwise.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEmpty($field, $value)`检查字符串是否为空，然后为该字段设置错误消息并返回`false`或`true`。'
- en: '`checkFormat($field, $value)` tests fields'' values against appropriate regular
    expressions written for each field format, sets an error (if any), and returns
    `false`, or otherwise `true`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkFormat($field, $value)`测试字段的值是否符合为每个字段格式编写的适当正则表达式，设置错误（如果有），并返回`false`，否则返回`true`。'
- en: '`checkSize($field, $value, $minLength, $maxLength)` checks whether the input
    is within the given minimum size and maximum size.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkSize($field, $value, $minLength, $maxLength)`检查输入是否在给定的最小大小和最大大小之间。'
- en: 'We want to validate the login credentials to check whether the user e-mail
    exists or whether the password belongs to the user matching that user e-mail.
    So, add the `validateCredentials()method` as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望验证登录凭据，以检查用户电子邮件是否存在，或者密码是否属于与该用户电子邮件匹配的用户。因此，按照以下方式添加`validateCredentials()方法`：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The method takes `$useremail` and `$password` for login credentials validation.
    You can see that the following line uses `user Dao` for confirming the password
    associated with the `useremail`. The Dao `checkPassConfirmation()` method returns
    `true` as the confirmation and `false` for either e-mail address or password is
    incorrect.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受`$useremail`和`$password`作为登录凭据验证。您可以看到以下行使用`user Dao`来确认与`useremail`关联的密码。Dao的`checkPassConfirmation()`方法返回`true`表示确认，返回`false`表示电子邮件地址或密码不正确。
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When a user wants to register into our application, we can validate the e-mail
    address for its pre-existence. If the e-mail is not already registered in the
    database, then the user is free to register with that e-mail. So, type in the
    following method:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户想要注册到我们的应用程序时，我们可以验证电子邮件地址是否已经存在。如果电子邮件地址在数据库中尚未注册，则用户可以自由注册该电子邮件。因此，输入以下方法：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can see that the method uses `userDao` in `$this->userDao->useremailTaken($useremail);`
    to check whether the user e-mail is already taken or not. If it's taken, set the
    error, and return `true` as the e-mail exists.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到该方法在`$this->userDao->useremailTaken($useremail);`中使用`userDao`来检查用户电子邮件是否已被使用。如果已被使用，则设置错误，并返回`true`表示该电子邮件已存在。
- en: 'Password confirmation is again required when the user wants to update the current
    password. So, let''s add another method for validating the current password:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户想要更新当前密码时，再次需要密码确认。因此，让我们添加另一个方法来验证当前密码：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What just happened?
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We have the validator service class ready for supporting the form, login credentials,
    and password validations, or even communicating with the database via `userDao`.
    Also, the validator service allows the application to retrieve temporary status
    messages for the guest or the user, and error messages for form input fields as
    well. So, it deals with all sorts of validation tasks, and the validator methods
    set errors if found, and return `true` on success or `false` on failure, respectively.
    Such error messages can be viewed, besides the corresponding form fields, as well
    as field values. Hence, it also helps to create the data persistence form.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好支持表单、登录凭据和密码验证，甚至通过`userDao`与数据库通信的验证器服务类。此外，验证器服务允许应用程序检索用于访客或用户的临时状态消息，以及表单输入字段的错误消息。因此，它处理各种验证任务，并且如果发现错误，则验证方法设置错误，并在成功时返回`true`，在失败时返回`false`。这样的错误消息可以在相应的表单字段旁边查看，以及字段值。因此，它还有助于创建数据持久性表单。
- en: Have a go hero — adding multibyte encoding support
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄-添加多字节编码支持
- en: Right now, our validator service doesn't have the ability to support multibyte
    character encoding. To enable the application with different character encodings
    such as UTF-8, you can implement the multibyte support in validation methods,
    such as set internal encoding, regular expression match for a multibyte string,
    and the use of `mb_strlen()` instead of `strlen()`. Multibyte string functions
    can be found at [http://php.net/manual/en/ref.mbstring.php](http://php.net/manual/en/ref.mbstring.php).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的验证器服务无法支持多字节字符编码。为了使应用程序能够支持不同的字符编码，如UTF-8，您可以在验证方法中实现多字节支持，例如设置内部编码、多字节字符串的正则表达式匹配，以及使用`mb_strlen()`而不是`strlen()`。多字节字符串函数可以在[http://php.net/manual/en/ref.mbstring.php](http://php.net/manual/en/ref.mbstring.php)找到。
- en: Creating the UserService class
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建UserService类
- en: The `UserService` class supports all the application tasks, such as login, register,
    or updating user details. It corresponds with the `UserDao` class for any sort
    of data-related functions and with the `ValidatorService` service class for any
    sort of validation functions. Asked by the application for tasks, such as login
    or register, it first calls for validation and then performs the task, while it
    may use DAO as required. Finally, it returns with `true` if the task has been
    accomplished, or `false` for any failure, such as a validation fail or any other
    ambiguity. Simply, applications will call the methods from the `UserService` class
    to login, register, and so on, and can know the status of the operation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserService`类支持所有应用程序任务，如登录、注册或更新用户详细信息。它与`UserDao`类对应于任何类型的数据相关函数，并与`ValidatorService`服务类对应于任何类型的验证函数。应用程序要求任务，如登录或注册，首先调用验证，然后执行任务，同时可能根据需要使用DAO。最后，如果任务已完成，则返回`true`，如果失败，则返回`false`，例如验证失败或其他任何模糊性。简单地说，应用程序将从`UserService`类调用方法来登录、注册等，并可以了解操作的状态。'
- en: Time for action — creating the UserService class
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建UserService类
- en: We will use `My\Service` as the namespace for this class, and keep any constants
    in the class. The `UserService` class attributes will contain the user information,
    such as the user e-mail, user ID, username, or phone, and the constructor checks
    for logged in user and class variables loaded with the user details from the session.
    Also, the class will make use of PHP cookies to store the user's login data. The
    class will act as the login session manager. So initially, the class will check
    for the login data in sessions or in cookies that the user is logged into.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`My\Service`作为该类的命名空间，并将任何常量保留在类中。`UserService`类属性将包含用户信息，如用户电子邮件、用户ID、用户名或电话，并且构造函数将检查已登录用户和从会话加载的类变量中的用户详细信息。此外，该类将利用PHP
    cookie来存储用户的登录数据。该类将充当登录会话管理器。因此，最初，该类将检查会话中或cookie中的登录数据，以确定用户是否已登录。
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is recommended that you are familiar with PHP sessions and cookies for this
    tutorial.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您熟悉PHP会话和cookie。
- en: 'So let''s go through the following steps, in order to create the `UserService`
    class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们按照以下步骤创建`UserService`类：
- en: 'Create a new PHP file inside the `Service` directory named `UserService.php`,
    and type in the following class:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Service`目录中创建一个名为`UserService.php`的新PHP文件，并输入以下类：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can see that the class uses `namespace My\Service;`, and the Service User
    class may be accessed using `\My\Service\UserService.`
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到该类使用`namespace My\Service;`，并且可以使用`\My\Service\UserService`来访问Service User类。
- en: Check out the class variable, which stores the user data. `$logged_in` is `true`
    if the user is logged in.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 检查存储用户数据的类变量，如果用户已登录，则 `$logged_in` 为 `true`。
- en: To distinguish among users, the user-related constants have been added. Update
    `ADMIN_EMAIL` with your own; the administrator among the users will be defined
    by `ADMIN_EMAIL` and `ADMIN_LEVEL` equal to `9`. The general registered users
    will be defined as `USER_LEVEL` equal to 1, and non-registered users will be defined
    as `GUEST_LEVEL` equal to `0` or `GUEST_NAME` as Guest. So, the user who registers
    with an e-mail address as `<[admin@mysite.com](mailto:admin@mysite.com)>` will
    have admin access when we implement admin features.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分用户，已添加了与用户相关的常量。用你自己的邮箱更新 `ADMIN_EMAIL`；用户中的管理员将由 `ADMIN_EMAIL` 和 `ADMIN_LEVEL`
    等于 `9` 来定义。一般注册用户将被定义为 `USER_LEVEL` 等于 1，非注册用户将被定义为 `GUEST_LEVEL` 等于 `0` 或 `GUEST_NAME`
    为 Guest。因此，使用邮箱地址 `<[admin@mysite.com](mailto:admin@mysite.com)>` 注册的用户在我们实现管理员功能时将具有管理员访问权限。
- en: At the cookie constant's section, `COOKIE_EXPIRE` has the cookie expiration
    time set to `100` days (8640000 seconds) by default, and `COOKIE_PATH` says that
    the cookie will be available for the whole application domain.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 cookie 常量部分，`COOKIE_EXPIRE` 默认将 cookie 过期时间设置为 `100` 天（8640000 秒），`COOKIE_PATH`
    表示 cookie 将在整个应用程序域中可用。
- en: The cookie (a text file on the user's computer) will be used to store `useremail`
    as `cookname` and `userhash` as `cookid`. These cookies will be set in the case
    of a user-enabled option `Remember Me`. So, we will initially check to see if
    cookies are found on the user's local computer that match with the database, and
    if so, we will consider the user as a logged-in user.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: cookie（用户计算机上的文本文件）将用于将 `useremail` 存储为 `cookname`，将 `userhash` 存储为 `cookid`。这些
    cookie 将在用户启用“记住我”选项的情况下设置。因此，我们将首先检查用户本地计算机上是否存在与数据库匹配的 cookie，如果是，则将用户视为已登录用户。
- en: Note that the constructor is injected with the `UserDao` and `ValidatorService`
    objects, so the class can use these dependencies inside it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，构造函数注入了 `UserDao` 和 `ValidatorService` 对象，因此类可以在内部使用这些依赖项。
- en: Now, with the line `$this->logged_in = $this->isLogin();` the constructor checks
    whether the user is logged in or not. The `private` method `isLogin()` checks
    for login data and if found then returns as `true`, or `false` otherwise. Actually,
    `isLogin()` checks the session and cookies for a user's login data, and if the
    data is available, it loads the class variables.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过 `$this->logged_in = $this->isLogin();` 这一行，构造函数检查用户是否已登录。`private` 方法
    `isLogin()` 检查登录数据，如果找到则返回 true，否则返回 false。实际上，`isLogin()` 检查会话和 cookie 是否有用户的登录数据，如果有，则加载类变量。
- en: Non-logged-in users will be guest users, so `useremail` and `userlevel` are
    set to `Guest` and `Guest Level 0`, respectively.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 未登录用户将是访客用户，因此 `useremail` 和 `userlevel` 分别设置为 `Guest` 和 `Guest Level 0`。
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s create the `isLogin()` method, so that it looks as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建 `isLogin()` 方法，如下所示：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If `$_SESSION` has `useremail, userhash,` and `useremail` not as guest, then
    it means that the user has already logged in to the data. If so, we want to confirm
    `userhash` and the associated `useremail` for security with the `checkHashConfirmation()`
    method of `UserDao`. If not confirmed, then unset the `$_SESSION` variable, and
    consider it as not logged in, by returning it as `false.`
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `$_SESSION` 具有 `useremail, userhash,` 和 `useremail` 不是 guest，则意味着用户已经登录到数据中。如果是这样，我们希望使用
    `UserDao` 的 `checkHashConfirmation()` 方法来确认 `userhash` 和关联的 `useremail` 的安全性。如果未确认，则取消设置
    `$_SESSION` 变量，并将其视为未登录，返回 false。
- en: Finally, if all is well, load the logged-in user's details using `Dao` at `$userinfo
    = $this->userDao->get($_SESSION['useremail']);;` load the class and session variables,
    and return it as true.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果一切顺利，使用 `Dao` 加载已登录用户的详细信息，`$userinfo = $this->userDao->get($_SESSION['useremail']);`
    加载类和会话变量，并将其返回为 true。
- en: Again, if `$_SESSION` doesn't have the logged-in data, then we'll choose to
    check into cookies also, as the user may have enabled the `Remember Me` option.
    These cookies are set if the user is asked to remember him when he logs in. So,
    if the necessary data is found in cookie variables, then the class and session
    variables are loaded from there.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果 `$_SESSION` 没有已登录的数据，那么我们将选择检查 cookie，因为用户可能已启用“记住我”选项。如果在 cookie 变量中找到必要的数据，则从中加载类和会话变量。
- en: 'Now, create the login service for the applications as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为应用程序创建登录服务如下：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This method takes login details, such as `useremail, password,` and `rememberme`,
    and passes them in the `$values` array from the application. It calls for validation
    of the given input, returns as false if an error is found, and validates the association
    of access credentials afterwards. If all the cases have passed the validation,
    it will load the user information from the Dao. Note that in the following line,
    `md5(microtime())` creates a random string of alphanumeric characters and is assigned
    to the class variables.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受登录详情，比如 `useremail, password,` 和 `rememberme`，并将它们传递到应用程序的 `$values` 数组中。它调用给定输入的验证，如果发现错误则返回
    false，并在之后验证访问凭证的关联。如果所有情况都通过了验证，它将从 Dao 中加载用户信息。请注意，在下一行中，`md5(microtime())`
    创建一个随机的包含字母数字字符的字符串，并分配给类变量。
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Finally, for new login sessions to be initiated, update the corresponding user's
    `userhash` in the table that will be the identifier for the current session.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了启动新的登录会话，更新表中对应用户的 `userhash`，这将是当前会话的标识符。
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So, `$_SESSION userhash` and database `userhash` should be the same for an active,
    logged-in session.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`$_SESSION userhash` 和数据库 `userhash` 应该对于一个活跃的、已登录的会话是相同的。
- en: Also, you can see, if `$rememberme` is `true`, then the cookie is set using
    PHP's `setcookie()` method, and the cookie is set with a name, value, and its
    expiration time.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以看到，如果 `$rememberme` 为 `true`，则使用 PHP 的 `setcookie()` 方法设置 cookie，并设置名称、值和过期时间。
- en: 'Now, add the user registration service method as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加用户注册服务方法如下：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This method takes the user details for registration, passes them in the `$values`
    array, and validates them. If validation gets passed, it packages the user registration
    details into an array, and saves them to the database using the `insert()` method
    of User Dao.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受用户注册的详细信息，将它们传递到`$values`数组中，并对其进行验证。如果验证通过，它将用户注册详细信息打包到一个数组中，并使用User
    Dao的`insert()`方法将其保存到数据库中。
- en: Note that the user level is determined by comparing a registrant's e-mail address
    with `ADMIN_EMAIL.`
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，用户级别是通过将注册者的电子邮件地址与`ADMIN_EMAIL`进行比较来确定的。
- en: 'Add the `getUser()` method as follows, to provide user information matching
    a given `useremail` parameter:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`getUser()`方法如下，以提供与给定的`useremail`参数匹配的用户信息：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that `useremail` is validated before delivering user information. So, the
    application will use this method whenever any user information is required.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在提供用户信息之前，`useremail`已经过验证。因此，每当需要用户信息时，应用程序将使用此方法。
- en: Now, add the `update()` method for the user's details modification.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加`update()`方法来修改用户的详细信息。
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that the method validates the given information (if any) first. If it passes
    the validation criteria, the corresponding column(s) value changes into the database
    table via User Dao.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该方法首先验证给定的信息（如果有）。如果它通过了验证标准，相应的列值将通过User Dao更改到数据库表中。
- en: 'The `logout()` method can be added as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`logout()`方法可以添加如下：'
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `logout` method unsets all the cookies and session variables, sets `$this->logged_in`
    to `false`, and the user becomes a guest user again.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`logout`方法取消所有cookie和会话变量，将`$this->logged_in`设置为`false`，用户再次成为访客用户。'
- en: What just happened?
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We can now check if a user is logged in or not and whether the user is asked
    to remember the login details, so the user doesn't want to log in with the `Remember
    Me` option again. The class serves for login, logout, user registration, and update
    or retrieval of the user information to the application layer. It uses the validator
    service before proceeding with the Dao layer. So, the class ensures the data security
    as well, which makes the `UserService` class ready at the service layer.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以检查用户是否已登录，以及用户是否被要求记住登录详细信息，这样用户就不需要再次使用`记住我`选项登录。该类用于登录、注销、用户注册以及更新或检索用户信息到应用程序层。它在进行Dao层之前使用验证器服务。因此，该类还确保了数据安全性，使得`UserService`类在服务层准备就绪。
- en: Finally, we have our API ready to work, and by using this API, we can build
    an application for user registration, user profile update, login, and logout.
    We have our data access layer and the service layer operational. Now, let's have
    a look at our NetBeans project directory.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的API已经准备好工作，通过使用这个API，我们可以构建一个用户注册、用户资料更新、登录和注销的应用程序。我们有我们的数据访问层和服务层正在运行。现在，让我们来看看我们的NetBeans项目目录。
- en: '![What just happened?](graphics/5801_07_06.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](graphics/5801_07_06.jpg)'
- en: For a better understanding, we have used a separate directory and a separate
    namespace for each layer. Now, we will include the API in our application file,
    and by using the User Service object, we will be achieving our application's goals.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，我们为每个层使用了一个单独的目录和一个单独的命名空间。现在，我们将在我们的应用程序文件中包含API，并通过使用User Service对象，我们将实现我们应用程序的目标。
- en: Pop quiz — using namespaces
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速测验——使用命名空间
- en: Which features does the PHP namespace support?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PHP命名空间支持哪些特性？
- en: Aliasing a class name
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给类名取别名
- en: Aliasing an interface name
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给接口名称取别名
- en: Aliasing a namespace name
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给命名空间名称取别名
- en: Importing a function or constant
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入函数或常量
- en: Which one will import a global class named `foo?`
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪一个将导入名为`foo`的全局类？
- en: namespace foo;
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名空间foo;
- en: use foo;
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用foo;
- en: import foo;
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入foo;
- en: None of the above
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: Building the application
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建应用程序
- en: In this tutorial, we will build the application that is capable of dealing with
    the user registration tasks, such as registration form handling, saving user data
    via API, or displaying error messages, and user login and logout tasks. In our
    next section, we will build the PHP application, and then add the application
    user interfaces.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将构建一个能够处理用户注册任务的应用程序，例如处理注册表单、通过API保存用户数据或显示错误消息，以及用户登录和注销任务。在下一节中，我们将构建PHP应用程序，然后添加应用程序用户界面。
- en: Before proceeding, keep in mind that all we have is the service layer classes.
    We'll choose to build the application in such a way that our application stands
    on top of the service layer. For this section, we don't need to think about the
    underlying database or Dao, rather we need to think from the application developer's
    perspective.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请记住我们只有服务层类。我们将选择以这样的方式构建应用程序，使我们的应用程序建立在服务层之上。对于本节，我们不需要考虑底层数据库或Dao，而是需要从应用程序开发人员的角度思考。
- en: Time for action — creating the user application
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——创建用户应用程序
- en: 'We will integrate the API into our user application file, which will be the
    main application file; there might be interfaces or view files for each application
    purpose. Let''s go through the following steps:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把API集成到我们的用户应用程序文件中，这将是主要的应用程序文件；每个应用程序目的可能会有接口或视图文件。让我们按照以下步骤进行：
- en: 'Create a new PHP file inside the project directory named `UserApplication.php`,
    and type in the following `UserApplication` class:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目目录中创建一个名为`UserApplication.php`的新PHP文件，并输入以下`UserApplication`类：
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: At the top of the file, you can see that after the constructor declarations,
    the PHP session started with `session_start()`. The API files have been included,
    and the class constructor has been injected with the `User` and `Validator Service`
    objects, so these objects become available throughout the application.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部，您可以看到在构造函数声明之后，PHP会话以`session_start()`开始。API文件已被包含，并且类构造函数已注入了`User`和`Validator
    Service`对象，因此这些对象在整个应用程序中都可用。
- en: 'You can see that appropriate methods are called from the constructor depending
    on the user''s request, such as `$this->login();` is called if `$_POST[''login'']`
    is set. So, all the methods are called from the constructor, and shall have the
    following functions:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，根据用户的请求，适当的方法是从构造函数中调用的，例如如果设置了`$_POST['login']`，则调用`$this->login();`。因此，所有方法都是从构造函数中调用的，并且应具有以下功能：
- en: '`login()`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login()`'
- en: '`register()`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register()`'
- en: '`update()`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update()`'
- en: '`logout()`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logout()`'
- en: At the bottom of the file, we have the line `$userApp = new \My\Application\UserApplication($userService,
    $validator);`, which instantiates the `UserApplication` class along with the dependency
    injection.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件底部，我们有一行`$userApp = new \My\Application\UserApplication($userService, $validator);`，它实例化了`UserApplication`类以及依赖注入。
- en: 'Type in the following `login()` method:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面键入以下`login()`方法：
- en: '[PRE36]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can see that the method calls the user service with the login credentials
    posted from the user interface in the following line:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，该方法调用用户服务，并使用用户界面发布的登录凭据在以下行中：
- en: '[PRE37]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the login attempt is successful, it sets the success status message in the
    `$_SESSION['statusMsg']` session variable, and if it fails, it sets the `$_POST`
    array posted by the user into `$_SESSION['value_array'],` with an error array
    obtained from the validator object into `$_SESSION['error_array']`. Finally, it
    is redirected to the `index.php` page.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果登录尝试成功，则在`$_SESSION['statusMsg']`会话变量中设置成功状态消息，如果失败，则将用户通过`$_POST`数组设置为`$_SESSION['value_array']`，并将从验证器对象中获取的错误数组设置为`$_SESSION['error_array']`。最后，它将重定向到`index.php`页面。
- en: 'Type in the following `register()` method:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面键入以下`register()`方法：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can see that if the registration attempt fails, it resets the corresponding
    session variables and is redirected to the `register.php` page, which is the user
    registration page.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，如果注册尝试失败，则会重置相应的会话变量，并重定向到`register.php`页面，这是用户注册页面。
- en: 'Type in the following `update()` method:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面键入以下`update()`方法：
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can see that if the user profile update attempt fails, then it resets the
    corresponding session variables and is redirected to the `profileedit.php` page,
    which is the profile edit page, or is redirected to `profile.php` on success.
    So, these pages will be our user profile view and update page.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，如果用户资料更新尝试失败，则会重置相应的会话变量，并重定向到`profileedit.php`页面，这是资料编辑页面，或者在成功时重定向到`profile.php`。因此，这些页面将是我们的用户资料查看和更新页面。
- en: 'Type in the following `logout()` method that simply calls the logout service:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面键入以下`logout()`方法，它只是调用注销服务：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What just happened?
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: Now our main application class is ready and the functionalities are as well.
    So we can register, log in, update, and log out a user using the application.
    Note that our application is just communicating via service objects, and you can
    feel that the application is not interested in the data sources; all it is doing
    is utilizing the service designed for it. In this fashion, we may write more interesting
    applications for the users, such as registered user list viewing; develop admin
    features, such as update any user or remove any user and even promote a user from
    normal to admin by just updating `userlevel`. It will be fun to add more features
    in terms of methods in different layers, to obtain a specific application.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的主应用程序类已经准备就绪，功能也已经准备就绪。因此，我们可以使用应用程序注册、登录、更新和注销用户。请注意，我们的应用程序只是通过服务对象进行通信，您可以感觉到应用程序对数据源不感兴趣；它所做的只是利用为其设计的服务。通过这种方式，我们可以为用户编写更有趣的应用程序，例如查看注册用户列表；开发管理员功能，例如更新任何用户或删除任何用户，甚至通过更新`userlevel`将用户从普通用户提升为管理员。通过在不同层中编写更多有趣的方法，我们可以获得特定的应用程序。
- en: In our next and final section, we will just add user interfaces or pages for
    a particular functionality.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个和最后一节中，我们将为特定功能添加用户界面或页面。
- en: Creating the user interface
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: We will create simple user interfaces and forms for user registration and login.
    Also, we will provide some user menus for viewing the user profile, updating the
    profile, and to log out. We shall integrate `UserApplication.php` at the very
    top of our interface files. Our interface files will consist of simple HTML with
    PHP code integrated inside.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为用户注册和登录创建简单的用户界面和表单。此外，我们还将为查看用户资料、更新资料和注销提供一些用户菜单。我们将在我们的界面文件的顶部集成`UserApplication.php`。我们的界面文件将包含简单的HTML，其中包含内部集成的PHP代码。
- en: Time for action — creating the user interface
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建用户界面
- en: 'We will integrate the user application file at the very beginning of each interface
    file. So, follow these steps to create various user interfaces:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在每个界面文件的开头集成用户应用程序文件。因此，请按照以下步骤创建各种用户界面：
- en: 'Open `index.php` and integrate the `UserApplication` class so that it looks
    as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`index.php`并集成`UserApplication`类，使其如下所示：
- en: '[PRE41]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: And all the interface codes can be inside the body tag.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 所有界面代码都可以在body标记内。
- en: 'Now, let''s create a logged-in user menu that shows the status message (if
    any), logged-in username, and menus at the top of each page. Create a new PHP
    file named `menu.php`, and type in the following code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个已登录用户菜单，显示状态消息（如果有），已登录用户名，并在每个页面顶部显示菜单。创建一个名为`menu.php`的新PHP文件，并键入以下代码：
- en: '[PRE42]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can see that if `$validator->statusMsg` is available, then we displayed
    it inside the colored `span` tag. Also, if the user is logged in, then it displays
    the user name inside the `<h2>` tag and displays `anchor` tags for profile view,
    edit profile, and logging out. Now, in our pages, we will include this menu inside
    the `<body>` tag as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，如果`$validator->statusMsg`可用，则我们将其显示在彩色的`span`标记内。此外，如果用户已登录，则它会在`<h2>`标记内显示用户名，并显示用于查看资料、编辑资料和注销的`anchor`标记。现在，在我们的页面中，我们将在`<body>`标记内包含此菜单，如下所示：
- en: '[PRE43]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let''s create the user registration page, `register.php`, and type in
    the following code:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建用户注册页面`register.php`，并键入以下代码：
- en: '[PRE44]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can see the user registration form displayed when the user is not logged
    in. `Number of errors` shows before the form with `$validator->num_errors`, if
    it has any errors.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，当用户未登录时，显示了用户注册表单。如果有任何错误，则在表单之前显示`错误数量`，使用`$validator->num_errors`。
- en: 'In the following line, you can see that the form will be posted to the UserApplication.php
    file:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行中，您可以看到表单将被发布到UserApplication.php文件：
- en: '[PRE45]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The form consists of four input boxes for name, e-mail, password, and phone
    number, and a submit button for form submission. The form comes with a hidden,
    input field that has a preloaded value. This hidden field value will be used to
    identify the login task by the `UserApplication` class constructor, in order to
    call the appropriate method.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 该表单由四个输入框组成，用于姓名、电子邮件、密码和电话号码，以及一个提交按钮用于提交表单。表单带有一个隐藏的输入字段，其中包含预加载的值。这个隐藏字段的值将用于通过`UserApplication`类构造函数来识别登录任务，以便调用适当的方法。
- en: 'Now, let''s have a look into an input field as follows:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看一个输入字段，如下所示：
- en: '[PRE46]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can see that the field value has been dumped (if available using `$validator->getValue("name")`)
    at the `value` attribute. The field value can be found at the `validator` method
    using the field name during form validation. Also, by using `$validator->getError("name")`,
    any error associated with the `name` field will be displayed. So, the rest of
    the fields are designed to be alike.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到字段值已被转储（如果可用，则使用`$validator->getValue("name")`），并显示在`value`属性中。在表单验证期间，可以使用字段名称在`validator`方法中找到字段值。此外，通过使用`$validator->getError("name")`，可以显示与`name`字段相关的任何错误。因此，其余字段被设计为相似。
- en: To test form validation, point your browser with `register.php`; click on the
    **Register** button to submit the form without filling any field. The form looks
    similar to the following screenshot with an error indicated beside each field.![Time
    for action — creating the user interface](graphics/5801_07_07.jpg)
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试表单验证，请使用`register.php`指向您的浏览器；单击**注册**按钮以在不填写任何字段的情况下提交表单。表单看起来类似于以下屏幕截图，每个字段旁边都有一个错误指示。![操作时间-创建用户界面](graphics/5801_07_07.jpg)
- en: You can see that the form is displayed with errors for each field, and at the
    top of the form, the number of errors has been displayed. So, our validator and
    user services are working. Hence, you can test the registration form for written
    validation cases, and finally fill-in the form to register yourself and check
    the database table for your submitted information.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，表单显示了每个字段的错误，并在表单顶部显示了错误数量。因此，我们的验证器和用户服务正在工作。因此，您可以测试注册表单以进行书面验证，并最终填写表单以注册自己，并检查数据库表以获取您提交的信息。
- en: 'Now, let''s create the login form inside the `index.php` file, at the `<body>`
    tag with the `Remember me` option, so that the body tag contains the following
    code:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`index.php`文件中的`<body>`标记内创建登录表单，并选择`记住我`选项，以便`body`标记包含以下代码：
- en: '[PRE47]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Check out the login form; the fields have been organized in the same way as
    the registration form. The form contains a hidden field name `login` and `value`
    set to `1`. So when the form is posted, the application class can identify that
    the login form has been submitted, and hence the application login method has
    been called. The login form page looks similar to the following:![Time for action
    — creating the user interface](graphics/5801_07_08.jpg)
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看登录表单；字段已以与注册表单相同的方式组织。表单包含一个名为`login`的隐藏字段和值设置为`1`。因此，当表单被发布时，应用程序类可以确定已提交登录表单，因此调用了应用程序登录方法。登录表单页面看起来类似于以下内容：![操作时间-创建用户界面](graphics/5801_07_08.jpg)
- en: Test the login form with your registered data and log in. After a successful
    login, you will be redirected to the same page, as follows:![Time for action —
    creating the user interface](graphics/5801_07_09.jpg)
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您注册的数据测试登录表单并登录。成功登录后，您将被重定向到同一页，如下所示：![操作时间-创建用户界面](graphics/5801_07_09.jpg)
- en: You can see the green-colored, **Successful login** status at the top of the
    page, and as the user is logged in, the login form is no longer required.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到页面顶部显示了绿色的**成功登录**状态，并且用户已登录，因此不再需要登录表单。
- en: 'Now, create the `profile.php` profile page (you can create the file from any
    interface page by selecting **File | Save As...** from menu and modify it inside
    the body tag), as it is supposed to have the following code inside the `body`
    tag:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建`profile.php`个人资料页面（您可以通过选择**文件|另存为...**从菜单中的任何界面页面创建文件，并在`body`标记内进行修改），因为它应该在`body`标记内包含以下代码：
- en: '[PRE48]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In this code snippet, you can see that the logged-in user''s profile information
    is dumped, which looks similar to the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，您可以看到已转储已登录用户的个人资料信息，看起来类似于以下内容：
- en: '![Time for action — creating the user interface](graphics/5801_07_10.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![操作时间-创建用户界面](graphics/5801_07_10.jpg)'
- en: 'Now, create the profile edit page, `profileedit.php`, and type in the following
    code:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建个人资料编辑页面`profileedit.php`，并键入以下代码：
- en: '[PRE49]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This form contains the user profile update fields, such as name, password,
    and phone; note that if any field such as password remains blank, then the field
    won''t be updated. Finally, while testing, the form looks similar to the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 该表单包含用户个人资料更新字段，如姓名、密码和电话；请注意，如果任何字段（如密码）保持空白，则该字段将不会被更新。最后，在测试时，表单看起来类似于以下内容：
- en: '![Time for action — creating the user interface](graphics/5801_07_11.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![操作时间-创建用户界面](graphics/5801_07_11.jpg)'
- en: 'Now we can test the logout feature. Check out the menu file for the logout,
    `anchor` tag, as follows:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以测试注销功能。查看菜单文件以获取注销的`anchor`标签，如下所示：
- en: '[PRE50]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can see that it has directly anchored the `UserApplication.php` file with
    a `logout=1` URL segment, so the `UserApplication` constructor finds that logout
    has been called with `$_GET['logout'],` and calls the application logout. Logging
    out redirects you to the index page.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到它直接将`UserApplication.php`文件与`logout=1` URL段锚定，因此`UserApplication`构造函数发现已使用`$_GET['logout']`调用了注销，并调用应用程序注销。注销后将重定向到索引页面。
- en: What just happened?
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just created and tested our newly built user interfaces. The test was fun
    while registering the user, logging in, or updating the user profile. Keep in
    mind that we can use this login application in our upcoming projects, or can easily
    integrate new features with minimal cost. Our goal to create a layered architecture
    and build the application according to that design has been achieved.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建并测试了我们新建的用户界面。在注册用户、登录或更新用户资料时，测试非常有趣。请记住，我们可以在未来的项目中使用这个登录应用，或者可以以最小成本轻松集成新功能。我们的目标是创建分层架构，并根据该设计构建应用程序已经实现。
- en: Note
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The complete project source code for this chapter can be downloaded from the
    Packt Publishing website. Also you can fork an extended version of this project
    at GitHub: [https://github.com/mahtonu/login-script](http://https://github.com/mahtonu/login-script).'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整项目源代码可以从Packt Publishing网站下载。您还可以在GitHub上fork这个项目的扩展版本：[https://github.com/mahtonu/login-script](http://https://github.com/mahtonu/login-script)。
- en: Pop quiz — the application architecture
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验——应用架构
- en: How many layers do we have in our application architecture?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用架构中有多少层？
- en: '2'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5'
- en: Database abstraction is achieved in which layer?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库抽象是在哪一层实现的？
- en: Data storage layer
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据存储层
- en: Data access layer
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据访问层
- en: Abstraction layer
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象层
- en: All of the above
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上所有内容
- en: In our application, which method directly communicates with the database for
    e-mail address existence?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，哪个方法直接与数据库通信以检查电子邮件地址是否存在？
- en: '`useremailTaken()`'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useremailTaken()`'
- en: '`emailExists()`'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`emailExists()`'
- en: '`checkEmail()`'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`checkEmail()`'
- en: '`confirmEmail()`'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认电子邮件()
- en: Have a go hero — creating admin features
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下——创建管理员功能
- en: As you have already noticed, we have created a database table column to define
    the admin user. So, implement admin features in the user service, such as a method
    to determine whether a user is the admin or not; if he/she is the admin, then
    add the admin page/interface method to get all user lists from user Dao, and display
    these user details, and so on. Again, you can implement the admin feature to promote
    a general user to the admin user, by updating the `userlevel` column.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经注意到的，我们已经创建了一个数据库表列来定义管理员用户。因此，在用户服务中实现管理员功能，比如一个方法来确定用户是否是管理员；如果他/她是管理员，那么添加管理员页面/接口方法来从用户Dao获取所有用户列表，并显示这些用户详情，等等。同样，您可以实现管理员功能，将普通用户提升为管理员用户，通过更新`userlevel`列。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have developed the user registration, login, and logout
    application with a layered design. We are now confident with enterprise system
    architecture, and can easily add or remove features into or from the developed
    application.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用分层设计开发了用户注册、登录和注销应用。我们现在对企业系统架构有信心，并且可以轻松地向开发的应用程序中添加或删除功能。
- en: 'We have specially worked on:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别关注了：
- en: Designing application architecture
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计应用架构
- en: Understanding the DAO pattern
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解DAO模式
- en: Creating the DAO classes
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建DAO类
- en: Creating the service classes
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建服务类
- en: Creating the application for user registration, login, and logout
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户注册、登录和注销应用
- en: Developing the user interface
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发用户界面
- en: So, we have entered into professional PHP project development and practices
    of IDE features, which has helped us tremendously. We may use this project in
    our future web applications, where the user login facility is required; this is
    the advantage of "developing once, updating little, and using all the time".
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经进入了专业的PHP项目开发和IDE功能的实践，这帮助了我们很多。我们可以在未来的Web应用程序中使用这个项目，其中需要用户登录功能；这就是“开发一次，稍微更新，一直使用”的优势。
