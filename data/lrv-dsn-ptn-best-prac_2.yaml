- en: Chapter 2. Models in MVC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。MVC中的模型
- en: Throughout the chapter, we will be discussing what Model is in the MVC structure,
    what its purpose is, what its role is in the SOLID design pattern, how Laravel
    defines it, and the advantages of Laravel's Model layers and Eloquent ORM. We
    will also discuss Laravel's classes related to handling data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论MVC结构中的模型是什么，它的目的是什么，它在SOLID设计模式中的作用是什么，Laravel如何定义它，以及Laravel的模型层和Eloquent
    ORM的优势。我们还将讨论处理数据的Laravel类。
- en: 'The following is the list of topics that will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将涵盖的主题列表：
- en: The meaning of the Model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型的含义
- en: The roles of the Model in a solid MVC design pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在坚实的MVC设计模式中的模型角色
- en: The Model and Model Instances
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型和模型实例
- en: How Laravel defines the Model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Laravel如何定义模型
- en: The database-related classes of Laravel
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Laravel的与数据库相关的类
- en: What is a Model?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是模型？
- en: The Model is that part of the Model-View-Controller design pattern that we can
    simply describe as the layer of the design pattern that handles the management
    of the data, which is received from the corresponding layers and then sent back
    to those layers. One thing to note here is that the Model does not know where
    the data comes from and how it is received.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是模型-视图-控制器设计模式的一部分，我们可以简单地描述为处理从相应层接收的数据并将其发送回这些层的设计模式的层。这里需要注意的一点是，模型不知道数据来自何处以及如何接收数据。
- en: In simple words, we can say that the Model implements the business logic of
    the application. The Model is responsible for fetching the data and converting
    it into more meaningful data that can be managed by other layers of the application
    and sending it back to corresponding layers. The Model is another name for the
    domain layer or business layer of an application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们可以说模型实现了应用程序的业务逻辑。模型负责获取数据并将其转换为其他应用程序层可以管理的更有意义的数据，并将其发送回相应层。模型是应用程序的域层或业务层的另一个名称。
- en: '![What is a Model?](Image00004.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: ！[什么是模型？]（Image00004.jpg）
- en: Purposes of the Model
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型的目的
- en: The Model in an application manages all of the dynamic data (anything that's
    not hardcoded and comes from a database driver) and lets other related components
    of the application know about the changes. For example, let's say that there is
    a news article in your database. If you alter it from the database manually, when
    a route is called—and due to this request—the Controller requests for the data
    over the Model after the request from the Routing handler, and the Controller
    receives the updated data from the Model. As a result, it sends this updated data
    to the View, and the end user sees the changes from the response. All of these
    data-related interactions are the tasks of the Model. This "data" that the Model
    handles does not always have to be database related. In some implementations,
    the Model can also be used to handle some temporary session variables.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的模型管理所有动态数据（不是硬编码的并来自数据库驱动程序的任何数据），并让应用程序的其他相关组件了解更改。例如，假设您的数据库中有一篇新闻文章。如果您手动从数据库更改它，当调用路由时
    - 由于此请求 - 控制器在路由处理程序的请求后请求模型上的数据，并且控制器从模型接收更新后的数据。结果，它将此更新后的数据发送到视图，最终用户从响应中看到更改。所有这些与数据相关的交互都是模型的任务。模型处理的这个“数据”并不总是与数据库相关。在某些实现中，模型还可以用于处理一些临时会话变量。
- en: 'The basic purposes of the Model in a general MVC pattern are as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般MVC模式中，模型的基本目的如下：
- en: To fetch the data using a specified (database) driver
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指定（数据库）驱动程序获取数据
- en: To validate the data
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证数据
- en: To store the data
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储数据
- en: To update the data
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新数据
- en: To delete the data
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除数据
- en: To create conditional relations
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建条件关系
- en: To monitor the file I/O
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视文件I / O
- en: To interact with third-party web services
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与第三方网络服务交互
- en: To handle caches and sessions
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理缓存和会话
- en: As you can see, if you follow with an MVC pattern consistently, the Model covers
    a huge percentage of the application's logic. In modern frameworks, there is a
    common mistake about the Model that is made by users when learning design patterns.
    They usually confuse the Model with Model Instances. Although they are quite similar,
    they have different meanings.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果您始终遵循MVC模式，模型将涵盖应用程序逻辑的很大一部分。在现代框架中，有一个常见的错误是用户在学习设计模式时常犯的错误。他们通常会混淆模型与模型实例。尽管它们非常相似，但它们有不同的含义。
- en: Model instances
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型实例
- en: In your application, there will usually be more than one data structure to manage.
    For example, let's say you are running a blog. In a simple blog system, there
    are authors, blog posts, tags, and comments. Let's say you want to update a blog
    post; how do you define that the data you want to update is for the blog posts?
    This is where Model Instances come handy.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中，通常会有多个数据结构需要管理。例如，假设您正在运行一个博客。在一个简单的博客系统中，有作者、博客文章、标签和评论。假设您想要更新一篇博客文章；您如何定义要更新的数据是针对博客文章的？这就是模型实例派上用场的地方。
- en: Model Instances are simple classes that mostly extend from the Model layer of
    the application. These instances separate the data logic for each section of your
    application. In our example, we have four sections to handle (users, posts, tags,
    and comments). If we are going to handle these using the Model, we have to create
    at least four instances (we will cover why it is at least four and not exactly
    four in the *Relationships* section that is under *Eloquent ORM* in this chapter).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 模型实例是大多数情况下从应用程序的模型层扩展的简单类。这些实例将应用程序的每个部分的数据逻辑分离开来。在我们的示例中，我们有四个部分要处理（用户、帖子、标签和评论）。如果我们要使用模型来处理这些，我们至少要创建四个实例（我们将在本章的*
    Eloquent ORM *下的*关系*部分中解释为什么至少是四个而不是确切的四个）。
- en: '![Model instances](Image00005.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: ！[模型实例]（Image00005.jpg）
- en: As you can see from the diagram, the Controller interacts with the Model Instance
    to fetch data. Since Model Instances extend from the Model itself, instead of
    raw Model output, the Controller can customize it or add other layers (such as
    Validation) to the process.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中可以看出，控制器与模型实例交互以获取数据。由于模型实例是从模型本身扩展而来的，因此控制器可以自定义它或向过程添加其他层（如验证），而不是使用原始模型输出。
- en: Let's say you want to fetch the user who has the username `George` . If no Validation
    layer has been added from the Model Instance to the database, the `username` parameter
    will go to the database directly, which could be harmful. If you did add a validation
    layer on your Model Instance (which checks if the username parameter is a clean
    string), even if the parameter was SQL injection code, it would first be filtered
    by the validation layer instead of going to the database directly and then be
    detected as harmful code. Then, the Model Instance will return a message or an
    exception to the Controller that the parameter is invalid. Then, the Controller
    will send a corresponding message to the View, and from there, the message will
    be shown to the end user. In this process, optionally, the application might even
    fire an Event to log this attempt.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想获取用户名为`George`的用户。如果没有从模型实例到数据库添加验证层，则`username`参数将直接传递到数据库，这可能是有害的。如果您在模型实例上添加了验证层（检查`username`参数是否为干净的字符串），即使参数是SQL注入代码，它也将首先通过验证层进行过滤，而不是直接传递到数据库，然后被检测为有害代码。然后，模型实例将向控制器返回一个消息或异常，指出参数无效。然后，控制器将向视图发送相应的消息，然后消息将显示给最终用户。在此过程中，应用程序甚至可以触发事件以记录此尝试。
- en: The Model in Laravel
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Laravel中的模型
- en: If you recall, we mentioned earlier in this chapter that there are many important
    jobs that the Model needs to handle. Laravel 4 does not use the MVC pattern directly,
    but it extends the pattern further. For example, Validation—which is part of the
    Model in the solid MVC pattern—has its own class, but it's not part of the Model
    itself. The database connection layer has its own classes for each database driver,
    but they are not packed in the Model directly. This brings testability, modularity,
    and extensibility to the Models.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，我们在本章前面提到模型需要处理许多重要的工作。Laravel 4不直接使用MVC模式，而是进一步扩展了该模式。例如，验证——在坚实的MVC模式中是模型的一部分——有它自己的类，但它并不是模型本身的一部分。数据库连接层为每个数据库驱动程序都有自己的类，但它们并没有直接打包在模型中。这为模型带来了可测试性、模块化和可扩展性。
- en: The Laravel Model structure focuses more on the database processes directly,
    and it is separated from other purposes. The other purposes are categorized as
    Facades.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel模型结构更专注于直接处理数据库过程，并与其他目的分开。其他目的被归类为门面。
- en: To access the database, Laravel has two classes. The first one is Fluent Query
    Builder and the second one is Eloquent ORM.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数据库，Laravel有两个类。第一个是流畅的查询构建器，第二个是Eloquent ORM。
- en: Fluent Query Builder
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流畅的查询构建器
- en: Fluent is the query builder class of Laravel 4\. Fluent Query Builder handles
    base database query actions using PHP Data Objects in the backend, and it can
    be used with almost any database driver. Let's say that you need to change the
    database driver from SQLite to MySQL; if you've written your queries using Fluent,
    then you mostly don't need to rewrite or alter your code unless you've written
    raw queries using `DB::raw()` . Fluent handles this behind the scenes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 流畅是Laravel 4的查询构建器类。流畅的查询构建器使用后端的PHP数据对象处理基本的数据库查询操作，并且可以与几乎任何数据库驱动程序一起使用。假设您需要将数据库驱动程序从SQLite更改为MySQL；如果您使用流畅编写了查询，那么除非您使用了`DB::raw()`编写了原始查询，否则您大多数情况下不需要重写或更改代码。流畅在幕后处理这个。
- en: 'Let''s take a quick look at the Eloquent Model of Laravel 4 (which can be found
    in the `Vendor\Laravel\Framework\src\Illuminate\Database\Query` folder):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下Laravel 4的Eloquent模型（可以在`Vendor\Laravel\Framework\src\Illuminate\Database\Query`文件夹中找到）：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the Eloquent Model uses some classes, such as `Database` , `ConnectionInterface`
    , `Collection` , `Grammar` , and `Processor` . All of these are required to standardize
    database queries in the backend, cache the queries if required, and return the
    output as a collection object.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Eloquent模型使用一些类，如`Database`、`ConnectionInterface`、`Collection`、`Grammar`和`Processor`。所有这些都是为了在后端标准化数据库查询，如果需要，缓存查询，并将输出作为集合对象返回。
- en: 'The following are some basic examples that present how the queries look:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些基本示例，展示了查询的外观：
- en: 'To get all of the names and show them one by one from a `users` table, use
    the following code:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从`users`表中获取所有名称并逐个显示它们，使用以下代码：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `get()` method fetches all of the records from the table in the form of
    a collection. With a `foreach()` loop, the records are looped, and then we access
    each name column using `->name` (an object). If the column we want to access is
    an e-mail, then it'll look like `$user->email` .
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`方法以集合的形式从表中获取所有记录。通过`foreach()`循环，记录被循环，然后我们使用`->name`（一个对象）访问每个名称列。如果要访问的列是电子邮件，则会像`$user->email`一样。'
- en: 'To fetch the first user named `Arda` from the `users` table, use the following
    code:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从`users`表中获取名为`Arda`的第一个用户，使用以下代码：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `where()` method filters the query with given parameters. The `first()`
    method directly returns the collection object of a single item from the first
    matched element. If there were two users named `Arda` , only the first one would
    be caught and set to the `$user` variable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`where()`方法使用给定参数过滤查询。`first()`方法直接从第一个匹配的元素中返回单个项目的集合对象。如果有两个名为`Arda`的用户，则只会捕获第一个并将其设置为`$user`变量。'
- en: 'If you wanted to use `OR` statements in the `where` clauses, you could use
    the following code:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要在`where`子句中使用`OR`语句，可以使用以下代码：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To use operators in the `where` clauses, the following third parameter should
    be added between the column name and variable that is to be filtered:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在`where`子句中使用操作符，应在要过滤的列名和变量之间添加以下第三个参数：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you are using offsets and limits, execute the following query:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用偏移和限制，执行以下查询：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This produces `SELECT` `* FROM` users `LIMIT 10,5` in MySQL. The `skip($integer)`
    method will set an offset to the query, and `take($ integer)` will limit the output
    by the natural number that has been set as the parameter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这在MySQL中产生了`SELECT` `* FROM` users `LIMIT 10,5`。`skip($integer)`方法将为查询设置一个偏移量，`take($
    integer)`将限制输出为已设置为参数的自然数。
- en: 'You can also limit what is to be fetched using the `select()` method and use
    the following `join` statements easily in Fluent Query Builder:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以使用`select()`方法限制要获取的内容，并在Fluent Query Builder中轻松使用以下`join`语句：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These methods simply join the `users` table with contacts, then join orders
    with users, and then get the user ID, the phone column from the `contacts` table,
    and the price column from the `orders` table.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法简单地将`users`表与contacts连接，然后将orders与users连接，然后获取`contacts`表中的用户ID和电话列，以及`orders`表中的价格列。
- en: 'You can group queries by parameters easily, using closure functions. This will
    allow you to write more complicated queries with ease, as follows:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用闭包函数轻松地按参数分组查询。这将使您能够轻松编写更复杂的查询，如下所示：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will produce the following SQL query:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下SQL查询：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also use aggregations in the query builder (such as `count` , `max`
    , `min` , `avg` , and `sum` ) as follows:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以在查询构建器中使用聚合（如`count`、`max`、`min`、`avg`和`sum`）：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Sometimes, such builders might not be enough, or you might want to run raw
    queries. You can also wrap your raw queries inside of Fluent as follows:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，这样的构建器可能不够，或者你可能想要运行原始查询。你也可以将原始查询包装在Fluent中，如下所示：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To insert new data into the table, use the `insert()` method:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将新数据插入表中，请使用`insert()`方法：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To update a row(s) from a table, use the `update()` method:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从表中更新行，请使用`update()`方法：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To delete a row(s) from a table, use the `delete()` method:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从表中删除行，请使用`delete()`方法：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Benefiting of `CachingIterator` that''s used the `Collection` class, Fluent
    Query Builder can also cache results upon calling using the method `remember()`
    :'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用`CachingIterator`，它使用`Collection`类，Fluent Query Builder也可以在调用`remember()`方法时缓存结果：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After this query is called once, it's cached for 10 minutes; if this query is
    called again, instead of fetching from the database, it'll fetch directly from
    the cache instead, until 10 minutes have passed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用了这个查询，它就会被缓存10分钟；如果再次调用这个查询，它将直接从缓存中获取，而不是从数据库中获取，直到10分钟过去。
- en: Eloquent ORM
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eloquent ORM
- en: Eloquent ORM is the Active Record implementation in Laravel. It's simple, powerful,
    and easy to handle and manage.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent ORM是Laravel中的Active Record实现。它简单、强大，易于处理和管理。
- en: For each database table, you'll need a new Model Instance to benefit from Eloquent.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个数据库表，你都需要一个新的Model Instance来从Eloquent中受益。
- en: 'Let''s say you have a `posts` table, and you want to benefit from Eloquent;
    you need to navigate to `app/models` and save this file as `Post.php` (the singular
    form of the table name):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个`posts`表，并且你想要从Eloquent中受益；你需要导航到`app/models`，并将此文件保存为`Post.php`（表名的单数形式）：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And that's it! You're ready to benefit from Eloquent methods for your table.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！你已经准备好从Eloquent方法中受益了。
- en: Laravel allows you to assign any table to any Eloquent Model Instance. It's
    not necessary, but it's a good habit to name Model Instances with the singular
    name of the corresponding table. This name should be a singular form of the table
    name it represents. If you have to use a name that does not follow this general
    rule, you can do so by setting a protected `$table` variable inside of the Model
    Instance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel允许你将任何表分配给任何Eloquent Model Instance。这不是必需的，但以相应表的单数形式命名Model Instances是一个好习惯。这个名字应该是它所代表的表名的单数形式。如果你必须使用不遵循这个一般规则的名字，你可以通过在Model
    Instance内部设置受保护的`$table`变量来这样做。
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This way, you can assign a table to any desired Model Instance.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你可以将表分配给任何所需的Model Instance。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's not necessary to add the instance into the `models` folder in `app` . As
    long as you've set an `autoload` path in `composer.json` , you can get rid of
    this folder completely and add it wherever you like. This will bring flexibility
    to your architecture during programming.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要将实例添加到`app`中的`models`文件夹中。只要在`composer.json`中设置了`autoload`路径，你可以完全摆脱这个文件夹，并将其添加到任何你喜欢的地方。这将在编程过程中为你的架构带来灵活性。
- en: 'Let''s take a quick look at the following `Model` class of Laravel 4 that we
    just extended from (which is in the `Vendor\Laravel\Framework\src\Illuminate\Database\Eloquent`
    folder):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下Laravel 4的以下`Model`类，我们刚刚从中扩展出来的（位于`Vendor\Laravel\Framework\src\Illuminate\Database\Eloquent`文件夹中）：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Eloquent uses `Illuminate\Database\Query\Builder` , which is the Fluent Query
    Builder that we described earlier, and its methods are defined inside it. Thanks
    to this, all of the methods that can be defined in Fluent Query Builder can also
    be used in Eloquent ORM.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent使用`Illuminate\Database\Query\Builder`，这是我们之前描述的Fluent Query Builder，它的方法在其中定义。由于这一点，所有可以在Fluent
    Query Builder中定义的方法也可以在Eloquent ORM中使用。
- en: As you can see, all of the used classes are split according to their purpose.
    This brings a better **Abstraction** and **Reusability** to the architecture.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有使用的类都根据其目的进行了拆分。这为架构带来了更好的**抽象**和**可重用性**。
- en: Relationships
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关系
- en: 'Eloquent ORM has other benefits in addition to Fluent Query Builder. The major
    benefit is Model Instance Relations, which allows Fluent Query Builder to form
    a relationship with other Model Instances easily. Let''s say you have `users`
    and `posts` tables, and you want to get the posts made by a user with an ID of
    `5` . After the relationship is set, the collection of these posts can be fetched
    with this code easily:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent ORM除了Fluent Query Builder之外还有其他好处。主要好处是Model Instance Relations，它允许Fluent
    Query Builder轻松地与其他Model Instances建立关系。假设你有`users`和`posts`表，并且你想要获取ID为`5`的用户发布的帖子。关系建立后，可以轻松地使用以下代码获取这些帖子的集合：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This couldn''t be easier, could it? There are three major relationship types:
    one-to-one, one-to-many, and many-to-many. In addition to these, Laravel 4 also
    has the has-many-through and morph-to-many (many-to-many polymorphic) relationships:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这难道不是更容易了吗？有三种主要的关系类型：一对一，一对多和多对多。除了这些，Laravel 4还有has-many-through和morph-to-many（多对多多态）关系：
- en: '**One-to-one relationships** : These are used when both Models have only one
    element of each other. Let''s say you have a `User` Model, which should only have
    one element in your `Phone` Model. In this case, the relationship will be defined
    as follows:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一关系**：当两个模型彼此只有一个元素时使用。比如你有一个`User`模型，它应该只有一个元素在你的`Phone`模型中。在这种情况下，关系将被定义如下：'
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**One-to-many relationships** : These are used when a Model has more than one
    element of another. Let''s say you have a news system with categories. A category
    can have more than one item. In this case, the relationship will be defined as
    follows:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对多关系**：当一个模型有另一个模型的多个元素时使用。比如你有一个带有分类的新闻系统。一个分类可以有多个项目。在这种情况下，关系将被定义如下：'
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Many-to-many relationships** : These are used when two Models have more than
    one element of each other. Let''s say you have `Blog` and `Tag` Models. A blog
    post might have more than one tag, and a tag might be assigned to more than one
    blog post. For such instances, a pivot table is used along with Many to Many Relationships.
    The relationship can be defined as follows:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对多关系**：当两个模型彼此有多个元素时使用。比如你有`Blog`和`Tag`模型。一篇博客文章可能有多个标签，一个标签可能被分配给多篇博客文章。对于这种情况，需要使用一个中间表和多对多关系来定义关系：'
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Laravel 4 adds some flexibility and additional relationships to these known
    relationships. They are "has-many-through" and "polymorphic relationships".
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 4为这些已知的关系添加了一些灵活性和额外的关系。它们是“has-many-through”和“多态关系”。
- en: '**Has-many-through relationships** : These are more like shortcuts. Let''s
    say you have a `Country` Model, `User` Model, and `Post` Model. A country may
    have more than one user, and a user may have more than one post. If you want to
    access all of the posts created by the users of a specific country, you need to
    define the relationship as follows:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Has-many-through关系**：这更像是快捷方式。比如你有一个`Country`模型，`User`模型和`Post`模型。一个国家可能有多个用户，一个用户可能有多个帖子。如果你想访问特定国家的用户创建的所有帖子，你需要定义关系如下：'
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Polymorphic relationships** : These are featured in Laravel v4.1\. Let''s
    say you have a `News` Model, `Blog` Model, and `Photo` Model. This `Photo` Model
    holds images for both `News` and `Blog` , but how do you relate this or identify
    a specific photo that is either for blogs or posts? This can be done easily. It
    needs to be set as follows:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态关系**：这在Laravel v4.1中有。比如你有一个`News`模型，`Blog`模型和`Photo`模型。这个`Photo`模型为`News`和`Blog`都保存了图片，但是如何关联或识别特定的照片是为博客还是帖子？这可以很容易地完成。需要设置如下：'
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The keyword `imageable` , which will describe the owner of the image, is not
    a must; it could be anything, but you need to set it as a method name and put
    it as a second parameter into `morphMany` relationship definitions. This helps
    us understand how we''re going to access the owner of the photo. This way, we
    can call this easily from the `Photo` Model without needing to understand whether
    its owner is `Blog` or `News` :'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`imageable`，用来描述图片的所有者，不是必须的；它可以是任何东西，但你需要将它设置为一个方法名，并将它作为`morphMany`关系定义的第二个参数。这有助于我们理解我们将如何访问照片的所有者。这样，我们可以轻松地从`Photo`模型中调用它，而不需要了解它的所有者是`Blog`还是`News`：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, you'll need to add two additional columns to your `Photo` Model's
    table. These columns are `imageable_id` and `imageable_type` . The section `imageable`
    is the name of the morphing method, and the suffix's ID and type are the keys
    that will define the exact ID and type of the item that it will be morphed to.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你需要在`Photo`模型的表中添加两个额外的列。这些列是`imageable_id`和`imageable_type`。`imageable`部分是变形方法的名称，后缀的ID和类型是将定义它将变形为的项目的确切ID和类型的键。
- en: Mass assignment
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批量赋值
- en: 'When creating a new Model Instance (when inserting or updating data), we pass
    a variable that is set as an array with attribute names and values. These attributes
    are then assigned to the Model by mass assignment. If we blindly add all of the
    inputs into mass assignment, this will become a serious security issue. In addition
    to querying methods, Eloquent ORM also helps us with mass assignment. Let''s say
    you don''t want the column e-mail in your `User` Model (`Object` ) to be altered
    in any way (blacklist), or you just want the title and body columns to be altered
    in your `Post` Model (whitelist). This can be done by setting protected `$fillable`
    and `$guarded` variables in your Model:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新的模型实例（插入或更新数据时），我们传递一个变量，它被设置为一个带有属性名称和值的数组。然后这些属性通过批量赋值分配给模型。如果我们盲目地将所有输入添加到批量赋值中，这将成为一个严重的安全问题。除了查询方法，Eloquent
    ORM还帮助我们进行批量赋值。比如你不希望`User`模型（`Object`）中的电子邮件列被以任何方式更改（黑名单），或者你只希望`Post`模型中的标题和正文列被更改（白名单）。这可以通过在你的模型中设置受保护的`$fillable`和`$guarded`变量来完成：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Soft deleting
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软删除
- en: Let's say you have a `posts` table, and let's assume the data inside this table
    is important. Even if the `delete` command is run from the Model, you want to
    keep the deleted data inside your database just in case. In such cases, you can
    use soft deletes with Laravel.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个`posts`表，假设这个表中的数据很重要。即使从模型运行`delete`命令，你也希望保留已删除的数据在你的数据库中以防万一。在这种情况下，你可以使用Laravel的软删除。
- en: Soft deleting doesn't actually delete the row from the table; instead, it adds
    a key if the data is actually deleted. When a soft deletion is made, a new column
    called `deleted_at` is filled with a timestamp.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 软删除实际上并不从表中删除行；相反，它在数据实际删除时添加一个键。当进行软删除时，一个名为`deleted_at`的新列将填充一个时间戳。
- en: To enable the soft deletes, you need to first add a timestamp column called
    `deleted_at` to your table (you could do this by adding `$table->softDeletes()`
    to your migration), then set a variable called `$softDelete` to `true` in your
    Model Instance.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用软删除，您需要首先在表中添加一个名为`deleted_at`的时间戳列（您可以通过在迁移中添加`$table->softDeletes()`来完成），然后在您的模型实例中将一个名为`$softDelete`的变量设置为`true`。
- en: 'The following is an example Model Instance for soft deletes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是软删除的示例模型实例：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, when you run the `delete()` method in this model, instead of actually deleting
    the column, it will add a `deleted_at` timestamp to it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您在此模型中运行`delete()`方法时，它将不会实际删除该列，而是会向其添加一个`deleted_at`时间戳。
- en: Now, when you run the `all()` or `get()` method, the soft-deleted columns won't
    be listed, like they have actually been deleted.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您运行`all()`或`get()`方法时，软删除的列将不会被列出，就好像它们实际上已被删除一样。
- en: 'After such deletes, you might want to get results along with soft-deleted rows.
    To do this, use the `withTrashed()` method as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种删除后，您可能希望获取包括软删除行在内的结果。要做到这一点，请使用`withTrashed()`方法如下：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In some cases, you may want to fetch only soft-deleted rows. To do this, use
    the `onlyTrashed()` method as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能只想获取软删除的行。要做到这一点，使用`onlyTrashed()`方法如下：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To restore the soft-deleted rows, use the `restore()` method. To restore all
    soft-deleted posts, run a code like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复软删除的行，请使用`restore()`方法。要恢复所有软删除的帖子，请运行以下代码：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To hard delete (totally delete) the soft-deleted rows from a table, use the
    `forceDelete()` method as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要彻底删除表中的软删除行，请使用`forceDelete()`方法如下：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When fetching rows from a table (including soft deletes), you may want to check
    whether they have been soft deleted or not. This check is done by running the
    `trashed()` method on collection rows. This method will return a Boolean value.
    If true, it means the row has been soft deleted.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从表中获取行（包括软删除）时，您可能想要检查它们是否已被软删除。通过在集合行上运行`trashed()`方法来进行此检查。此方法将返回一个布尔值。如果为true，则表示该行已被软删除。
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Eager loading
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 急切加载
- en: 'Eloquent ORM also brings a neat solution to the N+1 query problem with **Eager
    Loading** . Let''s assume that you have a query and loop like the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent ORM还通过**急切加载**为N+1查询问题提供了一个简洁的解决方案。假设您有一个查询和循环，如下所示：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this case, to access the images, one more query is executed for each loop
    in the backend. This will exhaust the database drastically, so to prevent this,
    we will use the `with()` method on the query. This will fetch all of the blogs
    and images, relate them in the backend, and serve them as a collection directly.
    Refer to the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，为了访问这些图片，在后端的每个循环中执行一个查询。这将极大地耗尽数据库，为了防止这种情况，我们将在查询中使用`with()`方法。这将在后端获取所有的博客和图片，将它们关联起来，并直接作为一个集合提供。参考以下代码：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This way, the querying will be much faster, and fewer resources will be used.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，查询速度将会更快，使用的资源也会更少。
- en: Timestamps
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间戳
- en: The main benefits of Eloquent ORM are seen when you set `$timestamps` to `true`
    (which is the default); you will have two columns, the first is `created_at` and
    the second is `updated_at` . These two columns keep the creation and last update
    times of data as timestamps and update them automatically on the creation or update
    of each row.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent ORM的主要优势在于将`$timestamps`设置为`true`（这是默认值）；您将有两列，第一列是`created_at`，第二列是`updated_at`。这两列将数据的创建和最后更新时间作为时间戳，并在每行的创建或更新时自动更新它们。
- en: Query scopes
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询范围
- en: 'Let''s say that you repeat a `where` condition several times because it''s
    a commonly used clause in your application and this condition means something.
    Let''s say you want to get all of the blog posts that have more than 100 views
    (we''ll call it popular posts). Without using scopes, you''d get the posts in
    the following format:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您因为它是您的应用程序中常用的子句之一而多次重复一个`where`条件，并且这个条件有意义。假设您想要获取所有具有超过100次浏览的博客文章（我们将其称为热门帖子）。如果不使用范围，您将以以下格式获取帖子：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: However, in the example, you'll be repeating this through your application over
    and over again. So, why not set this as a scope? You can do this easily using
    Laravel's Query Scope feature.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个例子中，您将一遍又一遍地在应用程序中重复这个过程。那么，为什么不将其设置为一个范围呢？您可以使用Laravel的查询范围功能轻松实现这一点。
- en: 'Add the following code to your `Blog` model:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到您的`Blog`模型中：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After doing this, you can use your scope easily with the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，您可以使用以下代码轻松使用您的范围：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can also chain the post as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将帖子链接如下：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Accessors and mutators
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问器和修改器
- en: 'One of the features of Eloquent ORM is accessors and mutators. Let''s say you
    have a column called `name` on your table, and on calling this column, you want
    to pass PHP''s `ucfirst()` method to uppercase its name. This can be done by simply
    adding the following lines of code to the model:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent ORM的一个特性是访问器和修改器。假设您的表上有一个名为`name`的列，并且在调用这个列时，您想要传递PHP的`ucfirst()`方法来将其名称大写。只需将以下代码添加到模型中即可完成：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let''s consider the opposite. Each time you save or update the name column,
    you want to pass the PHP `strtolower()` function to the column (you want to mutate
    the input). This can be done by adding the following lines of code to the model:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑相反的情况。每次保存或更新名称列时，您都希望将PHP的`strtolower()`函数传递给该列（您希望修改输入）。只需将以下代码添加到模型中即可完成：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that the method name should be CamelCased even though the column name is
    `snake_cased` . If your column name is `first_name` , the getter method name should
    be `getFirstNameAttribute` .
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，方法名称应该是驼峰式命名，即使列名是`snake_cased`。如果您的列名是`first_name`，则getter方法名称应该是`getFirstNameAttribute`。
- en: Model events
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型事件
- en: Model events play an important part in the Laravel design pattern. Using Model
    events, you can call any method right after the event is fired.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 模型事件在Laravel设计模式中扮演着重要的角色。使用模型事件，您可以在事件触发后立即调用任何方法。
- en: Let's say that you have set a cache for your comments, and you want to flush
    the cache each time a comment is deleted. How can you catch the comment's deletion
    event and do something there? Should there be various places in the application
    that such comments can be deleted? Is there a way to catch exact the "deleting"
    or "deleted" event? In such case, the Model events come in handy.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您为评论设置了缓存，并且希望在每次删除评论时刷新缓存。您如何捕获评论的删除事件并在那里执行某些操作？应用程序中是否有多个地方可以删除此类评论？是否有一种方法可以精确捕获“删除”或“已删除”事件？在这种情况下，模型事件非常有用。
- en: 'Models hold the following methods: `creating` , `created` , `updating` , `updated`
    , `saving` , `saved` , `deleting` , `deleted` , `restoring` , and `restored` .'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 模型包含以下方法：`creating`、`created`、`updating`、`updated`、`saving`、`saved`、`deleting`、`deleted`、`restoring`
    和 `restored`。
- en: Whenever a new item is being saved for the first time, the creating and created
    events will fire. If you are updating a current item on the Model, the `updating`
    /`updated` events will fire. Whether you are creating a new item or updating a
    current one, the `saving` /`saved` events will fire.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每当第一次保存新项目时，将触发创建和已创建事件。如果您正在更新模型上的当前项目，则将触发 `updating` / `updated` 事件。无论您是创建新项目还是更新当前项目，都将触发
    `saving` / `saved` 事件。
- en: If `false` is returned from the `creating` , `updating` , `saving` , or `deleting`
    event, the action will be canceled.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从 `creating`、`updating`、`saving` 或 `deleting` 事件中返回 `false`，则操作将被取消。
- en: 'For example, let''s check whether a user has been created. If its first name
    is `Hybrid` , we''ll cancel the creation. To add this condition, include the following
    lines of code in your `User` Model:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们检查用户是否已创建。如果其名字是 `Hybrid`，我们将取消创建。要添加此条件，请在您的 `User` 模型中包含以下代码行：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Model observers
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型观察者
- en: 'Model observers are quite similar to Model Events, but the approach is a little
    bit different. Instead of defining all events (`creating` , `created` , `updating`
    , `updated` , `saving` , `saved` , `deleting` , `deleted` , `restoring` , and
    `restored` ) inside of the Model, it "abstracts" the logic of the events to a
    different class and "observes" it with the `observe()` method. Let''s assume we
    have a Model event like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 模型观察者与模型事件非常相似，但方法略有不同。它不是在模型内部定义所有事件（`creating`、`created`、`updating`、`updated`、`saving`、`saved`、`deleting`、`deleted`、`restoring`
    和 `restored`），而是将事件的逻辑“抽象”到不同的类中，并使用 `observe()` 方法“观察”它。假设我们有一个如下所示的模型事件：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To keep the abstraction, it will be much better to wrap all of these events
    and separate their logic from the Model. In an observer, these events will look
    like the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持抽象，最好将所有这些事件封装起来，并将它们的逻辑与模型分开。在观察者中，这些事件将如下所示：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can imagine, you can put this class anywhere in your application. You
    can even group all of these events in a separate folder for a better architectural
    pattern.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以想象，您可以将这个类放在应用程序的任何位置。您甚至可以将所有这些事件分组在一个单独的文件夹中，以获得更好的架构模式。
- en: 'Now, you need to register this event `Observer` class to a Model. This can
    be done with the following simple command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要将此事件 `Observer` 类注册到模型。可以使用以下简单命令完成：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The main advantage of this approach is that you can use observers in more than
    one Model and register more than one observer to a Model this way.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要优势是您可以在多个模型中使用观察者，并以这种方式向一个模型注册多个观察者。
- en: Migrations
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移
- en: Migrations are easy tools to version control your database. Let's say there
    is a place where you need to add a new column to the table or roll back to the
    previous state because you did something wrong or the link to your application
    broke. Without migrations, these are tedious tasks to handle, but with migrations,
    your life will be much easier.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移是管理数据库版本控制的简单工具。假设有一个地方需要向表中添加新列，或者回滚到以前的状态，因为您做错了事情或应用程序的链接断开了。没有迁移，这些都是繁琐的任务，但有了迁移，您的生活将变得更加轻松。
- en: 'There are various reasons to use migrations; some of these are as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用迁移的各种原因如下：
- en: You'll benefit from this versioning system. If you made a mistake or need to
    roll back to a previous state, you can do so with only a single command using
    migrations.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将受益于这种版本控制系统。如果出现错误或需要回滚到以前的状态，您只需使用迁移的一个命令即可完成。
- en: The use of migrations for alteration will bring about flexibility. The migrations
    that are written will work on all supported database drivers, so you won't need
    to rewrite database code again and again for different drivers. Laravel will handle
    this in the background.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迁移进行更改将带来灵活性。编写的迁移将适用于所有支持的数据库驱动程序，因此您无需为不同的驱动程序重写数据库代码。Laravel 将在后台处理这一切。
- en: They are quite easy to generate. Using the migration commands of the Laravel
    `php` client, which is called `artisan` , you can manage all of your application's
    migrations.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们非常容易生成。使用 Laravel `php` 客户端的迁移命令，称为 `artisan`，您可以管理应用程序的所有迁移。
- en: 'The following is what a migration file looks like:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是迁移文件的样子：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `up()` method runs when the migration is run forward (a new migration).
    The `down()` method runs when the migration is run backward, meaning it reverses
    or resets (reverses and reruns) the migration.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`up()` 方法在向前运行迁移时运行（新迁移）。`down()` 方法在向后运行迁移时运行，意味着它会反转或重置（反转并重新运行）迁移。'
- en: After these methods are triggered via the `artisan` command, it runs the method
    up or down, corresponding the parameters of the `artisan` command, and returns
    the status of the message.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `artisan` 命令触发这些方法后，它会运行 `up` 或 `down` 方法，与 `artisan` 命令的参数相对应，并返回消息的状态。
- en: Database seeders
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库种子数据填充器
- en: Let's say you've programmed a blog application. You need to show what it's capable
    of, but there are no example blog posts to show the awesome blog you've programmed.
    This is where seeders come in handy.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您编写了一个博客应用程序。您需要展示它的功能，但没有示例博客文章来展示您编写的出色博客。这就是种子数据填充器派上用场的地方。
- en: 'Database seeders are some simple classes that fill random data in a specified
    table. The seeder class has a simple method called `run()` to make this seeding(s).
    The following is what a seeder looks like:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库seeder是一些简单的类，它们在指定的表中填充随机数据。seeder类有一个简单的方法叫做`run()`来进行这种填充。以下是seeder的样子：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When you call this class from a terminal using the `artisan` command, it connects
    to the database and fills it with the given data. After this attempt, it returns
    a command message to the user over the terminal about the status of the seeding.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`artisan`命令从终端调用这个类时，它会连接到数据库并用给定的数据填充它。尝试完成后，它会通过终端向用户返回有关填充状态的命令消息。
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com) . If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，直接将文件发送到您的电子邮件。
- en: 读累了记得休息一会哦~
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned about the role of the Model in the MVC pattern
    and how Laravel 4 "defines" the Model by extending its roles to various classes.
    We've also seen what the Model components of Laravel 4 are capable of with examples.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了MVC模式中模型的作用，以及Laravel 4如何通过扩展其角色到各种类来“定义”模型。我们还通过示例看到了Laravel 4的模型组件的功能。
- en: In the next chapter, we'll learn about the role of the View and how it interacts
    with end users and other aspects of the application using the MVC pattern on Laravel
    4.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习视图的作用，以及它如何在Laravel 4中使用MVC模式与最终用户和应用程序的其他方面进行交互。
