- en: Error Handling and Logging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理和日志记录
- en: Effective error handling and logging are essential parts of an application.
    Early versions of PHP lacked the support for exceptions and only used errors to
    flag faulty application states. The PHP 5 version brought forth the OOP features
    to the language and, with it, the exception model. This empowered PHP with the `try...catch`
    blocks like other programming languages. Later, the PHP 5.5 version brought support
    for the `finally` block, which always executed after the `try...catch` blocks, regardless
    of whether an exception was thrown or not.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的错误处理和日志记录是应用程序的重要部分。早期版本的PHP缺乏对异常的支持，只使用错误来标记有缺陷的应用程序状态。PHP 5版本为语言带来了面向对象的特性，以及异常模型。这使PHP具有了像其他编程语言一样的`try...catch`块。后来，PHP
    5.5版本增加了对`finally`块的支持，无论是否抛出异常，它始终在`try...catch`块之后执行。
- en: Nowadays, the PHP language differentiates errors and exceptions as faulty states
    of an application. Both are raised as unexpected to our application logic. There
    are numerous types of errors, such as `E_ERROR`, `E_WARNING`, `E_NOTICE`, and
    others. When speaking of errors, we default to the `E_ERROR` type that tends to
    signal the end of our application, an unexpected state that an application should
    not try to catch and continue executing. This might be due to a lack of memory,
    IO errors, TCP/IP errors, null reference errors and many others. Exceptions, on
    the other hand, indicate an unexpected state that an application might want to
    catch and still carry on executing. This might be due to the inability to save
    an entry in a database at a given time, an unexpected e-mail sending failure,
    and many others. This helps to think of an exception as an OO concept of an error.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，PHP语言将错误和异常区分为应用程序的故障状态。两者都被视为应用程序逻辑的意外情况。有许多类型的错误，比如`E_ERROR`、`E_WARNING`、`E_NOTICE`等。当谈到错误时，我们默认为`E_ERROR`类型，它往往表示应用程序的结束，这是一个意外的状态，应用程序不应该尝试捕获并继续执行。这可能是由于内存不足、IO错误、TCP/IP错误、空引用错误等。另一方面，异常表示应用程序可能希望捕获并继续执行的意外状态。这可能是由于在给定时间无法保存数据库中的条目，意外的电子邮件发送失败等。这有助于将异常视为错误的面向对象概念。
- en: PHP has its own mechanisms that allow interaction with some of the error types
    and exceptions. Using `set_error_handler`, we can define the custom error handler
    to possibly log or display an appropriate message to the user. Using the `try...catch...finally`
    blocks, we can safely catch possible exceptions and continue executing the application.
    The exceptions we don't catch automatically turn into a standard error and break
    our application execution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: PHP有自己的机制，允许与一些错误类型和异常进行交互。使用`set_error_handler`，我们可以定义自定义错误处理程序，可能记录或向用户显示适当的消息。使用`try...catch...finally`块，我们可以安全地捕获可能的异常并继续执行应用程序。我们没有自动捕获的异常会自动转换为标准错误，并中断应用程序的执行。
- en: Handling errors would not really be complete without proper logging mechanism.
    While PHP itself provides an interesting and useful `error_log()` function, there
    are far more robust logging solutions available in the form of free community
    libraries, such as Mongo.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误如果没有适当的日志记录机制，就不会真正完整。虽然PHP本身提供了一个有趣和有用的`error_log()`函数，但在社区库中还有更强大的日志记录解决方案，比如Mongo。
- en: 'Moving forward, we will take a detailed look into the following areas of error
    handling and logging:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将详细研究以下错误处理和日志记录领域：
- en: Error handling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Error
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: '`ArithmeticError`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术错误
- en: '`DivisionByZeroError`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DivisionByZeroError`'
- en: '`AssertionError`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AssertionError`'
- en: '`ParseError`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParseError`'
- en: '`TypeError`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypeError`'
- en: Exception
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常
- en: Logging
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录
- en: Native logging
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本机日志记录
- en: Logging with Monolog
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Monolog进行日志记录
- en: NASA lost a $125 million Mars orbiter on September 1999 because engineers failed
    to convert units from English to metric. While the system had nothing to do with
    PHP or the fatal runtime errors as such, it goes to say how great the impact a
    faulty software might have in real life.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: NASA在1999年9月丢失了一枚价值1.25亿美元的火星轨道器，因为工程师未能将单位从英制转换为公制。虽然这个系统与PHP或致命的运行时错误无关，但它表明了一个有缺陷的软件可能在现实生活中产生多大的影响。
- en: Error handling
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'Having errors and exceptions as two different error handling system introduces
    a certain level of confusion among developers. The older versions of PHP made
    it difficult to reason with `E_ERROR` as they could not be caught with custom
    error handlers. The PHP 7 version tried to address this confusion by introducing
    the `Throwable` interface, which is summarized as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将错误和异常作为两种不同的错误处理系统引入了一定程度的混乱。早期版本的PHP使得很难理解`E_ERROR`，因为它们无法被自定义错误处理程序捕获。PHP
    7版本试图通过引入`Throwable`接口来解决这种混乱，总结如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Throwable` interface is now the base interface for `Error`, `Exception`,
    and any other object that can be thrown via a `throw` statement. The methods defined
    in this interface are nearly identical to those of `Exception`. The PHP classes
    themselves cannot implement the `Throwable` interface directly or extend from
    `Error`; they can only extend `Exception`, as shown in the following example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Throwable`接口现在是`Error`、`Exception`和通过`throw`语句抛出的任何其他对象的基本接口。该接口中定义的方法几乎与`Exception`的方法相同。PHP类本身不能直接实现`Throwable`接口或扩展自`Error`；它们只能扩展`Exception`，如下例所示：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code will result in the following output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将产生以下输出：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What''s happening here is that the `Glitch` class is trying to extend the `Error` class,
    which is not allowed and results in a `Fatal error` that does not get caught by
    our `try...catch` block here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是`Glitch`类试图扩展`Error`类，这是不允许的，导致了一个致命错误，我们的`try...catch`块无法捕获到：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding example is a valid use of PHP `Throwable`, whereas, our custom
    `Flaw` class extends the `Exception` class. The `catch` block is triggered, resulting
    in the following output message:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子是PHP `Throwable`的有效用法，而我们的自定义`Flaw`类扩展了`Exception`类。触发`catch`块，导致以下输出消息：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The new exception hierarchy in PHP 7 is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7中的新异常层次结构如下：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The obvious benefit of the new `Throwable` interface is that we can now easily
    catch both `Exception` and `Error` objects in a single `try...catch` block, as
    per the following example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`Throwable`接口的明显好处是我们现在可以在单个`try...catch`块中轻松捕获`Exception`和`Error`对象，如下例所示：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`AssertionError` extends `Error`, which in turn implements the `Throwable`
     interface. The signature of the preceding `catch` block targets the `Throwable`
    interface, so the thrown `ArithmeticError` would be caught and the output of `Missing
    numbers!` shown.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssertionError`扩展了`Error`，而`Error`又实现了`Throwable`接口。上面的`catch`块的签名针对`Throwable`接口，因此抛出的`ArithmeticError`将被捕获，并显示`Missing
    numbers!`的输出。'
- en: 'Though our classes cannot implement the `Throwable` interface, we can define
    the interface that extends it. Such an interface can then only be implemented
    by a class extending either `Exception` or `Error`, as per the following example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的类不能实现`Throwable`接口，但我们可以定义扩展它的接口。这样的接口只能由扩展`Exception`或`Error`的类来实现，如下例所示：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While it might not be a common practice, such an approach might be useful with package-specific
    interfaces.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能不是常见的做法，但这种方法可能对特定于包的接口有用。
- en: Error
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误
- en: The `Error` class is the base class for internal PHP errors in PHP 7. Nearly
    all fatal and recoverable fatal errors in PHP 5.x now throw instances of the `Error`
    object, making themselves catchable via the `try...catch` blocks.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error`类是PHP 7中内部PHP错误的基类。现在，PHP 5.x中几乎所有致命和可恢复的致命错误都会抛出`Error`对象的实例，从而可以通过`try...catch`块捕获。'
- en: 'The `Error` class implements the `Throwable` interface, as per the following
    class synopsis:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error`类根据以下类概要实现了`Throwable`接口：'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following example demonstrates the use of the `Error` instance in the `catch`
    block:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了在`catch`块中使用`Error`实例：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, there are still cases where some errors are not catchable:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然有一些情况下一些错误是无法捕获的：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding example triggers the `PHP Fatal error: Allowed memory size of
    2097152 bytes exhausted...` error.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '上面的例子触发了`PHP Fatal error: Allowed memory size of 2097152 bytes exhausted...`错误。'
- en: 'Furthermore, even warnings get passed by, as shown in the following example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使警告也会被忽略，如下例所示：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding example triggers the `PHP Warning:  str_pad(): Padding length
    is too long...` error.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '上面的例子触发了`PHP Warning:  str_pad(): Padding length is too long...`错误。'
- en: 'It goes to say that we should be careful with our expectations towards catching
    core language errors, as some might slip through. Those that get caught are usually
    of the base `Error` class. However, some errors will throw a more specific subclass
    of `Error`: `ArithmeticError`, `DivisionByZeroError`, `AssertionError`, `ParseError`,
    and `TypeError`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，我们应该谨慎对待捕获核心语言错误的期望，因为有些错误可能会漏掉。那些被捕获的通常是基类`Error`。然而，一些错误会抛出更具体的`Error`子类：`ArithmeticError`、`DivisionByZeroError`、`AssertionError`、`ParseError`和`TypeError`。
- en: ArithmeticError
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ArithmeticError
- en: The `ArithmeticError` class addresses the possibly faulty outcomes of performing
    mathematical operations. PHP uses it for two situations--bit shifting by a negative
    number or calling `intdiv()` with a dividend of `PHP_INT_MIN` and a divisor of
    `-1`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArithmeticError`类解决了执行数学运算可能出现错误结果的情况。PHP将其用于两种情况——通过负数进行位移或者使用`intdiv()`时被除数为`PHP_INT_MIN`，除数为`-1`。'
- en: 'The `ArithmeticError` class has no methods of its own; they are all inherited
    from the parent `Error` class, as per the following class synopsis:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArithmeticError`类没有自己的方法，它们都是从父类`Error`类继承而来，如下类概要所示：'
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following example demonstrates the `try...catch` block with `ArithmeticError`
    being thrown for bit shifting by a negative number:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了使用负数进行位移时抛出`ArithmeticError`的`try...catch`块：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The resulting output is as follows :'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出如下：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following example demonstrates the `try...catch` block with `ArithmeticError`
    being thrown for calling `intdiv()` with a dividend of `PHP_INT_MIN` and divisor
    of `-1`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了使用`intdiv()`调用时抛出`ArithmeticError`的`try...catch`块，被除数为`PHP_INT_MIN`，除数为`-1`：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The resulting output is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出如下：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: DivisionByZeroError
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DivisionByZeroError
- en: Division by zero is an undefined mathematical expression, at least in elementary
    arithmetic; hence, PHP needed a way to respond to such cases. `DivisionByZeroError`
    is thrown when we try to divide a number by zero.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本算术中，除以零是一个未定义的数学表达式；因此，PHP需要一种方式来应对这种情况。当我们尝试除以零时，将抛出`DivisionByZeroError`。
- en: 'The `DivisionByZeroError` class has no methods of its own, they are all inherited
    from the parent `ArithmeticError` class, as per the following class synopsis:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`DivisionByZeroError`类没有自己的方法，它们都是从父类`ArithmeticError`继承而来，如下类概要所示：'
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We need to be careful what expression we are using for division. Simply dividing dividend
    number with `0` divisor number using the `/` operator will not yield the same
    result as using the `intdiv()` function. Consider the following code snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注意我们使用什么表达式进行除法。仅使用`/`运算符将被除数数字除以`0`除数数字将不会产生与使用`intdiv()`函数相同的结果。考虑以下代码片段：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding example will not trigger the `DivisionByZeroError` catch block.
    Instead, the following warning is raised.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子不会触发`DivisionByZeroError`的catch块。相反，会引发以下警告。
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using the `intdiv()` function instead of the `/` operator will trigger the `catch`
    block as shown in the following code snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`intdiv()`函数而不是`/`运算符将触发`catch`块，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `intdiv()` function throws the `DivisionByZeroError` exception if the divisor
    is `0`. If the dividend is `PHP_INT_MIN` and the divisor is `-1`, then an `ArithmeticError`
    exception is thrown, as shown in the preceding section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果除数为`0`，`intdiv()`函数会抛出`DivisionByZeroError`异常。如果被除数是`PHP_INT_MIN`，除数是`-1`，那么会抛出`ArithmeticError`异常，如前面的部分所示。
- en: AssertionError
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AssertionError
- en: Assertions are runtime checks used as a debugging feature. Using the PHP 7 `assert()` language
    construct, we can confirm whether certain PHP expressions are true or false. Whenever
    the assertion fails, `AssertionError` is thrown.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是作为调试功能使用的运行时检查。使用PHP 7的`assert()`语言结构，我们可以确认某些PHP表达式是真还是假。每当断言失败时，就会抛出`AssertionError`。
- en: 'The `AssertionError` class has no methods of its own, they are all inherited
    from the parent `Error` class, as per the following class synopsis:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssertionError`类没有自己的方法，它们都是从父类`Error`继承而来，如下类概要所示：'
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'PHP 7 provides two configuration directives to control the behavior of `assert()`--`zend.assertions`
    and `assert.exception`. The `assert()` function will only get executed and possibly
    throw `AssertionError` if `zend.assertions = 1` and `assert.exception = 1`, as
    per the following example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7提供了两个配置指令来控制`assert()`的行为--`zend.assertions`和`assert.exception`。只有当`zend.assertions
    = 1`和`assert.exception = 1`时，`assert()`函数才会被执行并可能抛出`AssertionError`，如下例所示：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Assuming the configuration directives are all set, the preceding code will
    output the `Caught: assert(''developer'' === ''programmer'')` message. If only `zend.assertions
    = 1` but `assert.exception = 0`, then the `catch` block will have no effect and
    the following warning is raised: `Warning: assert(): assert(''developer'' ===
    ''programmer'') failed`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '假设配置指令都已设置，上述代码将输出`Caught: assert(''developer'' === ''programmer'')`消息。如果只有`zend.assertions
    = 1`但`assert.exception = 0`，那么`catch`块将没有效果，并且会引发以下警告：`Warning: assert(): assert(''developer''
    === ''programmer'') failed`。'
- en: The `zend.assertions` derivative may be completely enabled or disabled only
    in the `php.ini` file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`zend.assertions`派生可能在`php.ini`文件中完全启用或禁用。'
- en: ParseError
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ParseError
- en: The `eval()` language construct enables us to execute any arbitrary PHP code.
    The only requirement is that the code must not be wrapped in opening and closing
    PHP tags. Apart from that, the passed code itself must be a valid PHP code. If
    it happens that the passed code is invalid, then `ParseError` is thrown.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval()`语言结构使我们能够执行任意的PHP代码。唯一的要求是代码不能包含在开头和结尾的PHP标记中。除此之外，传递的代码本身必须是有效的PHP代码。如果传递的代码无效，那么就会抛出`ParseError`。'
- en: 'The `ParseError` class has no methods of its own, they are all inherited from
    the parent `Error` class, as per the following class synopsis:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParseError`类没有自己的方法，它们都是从父类`Error`继承而来，如下类概要所示：'
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following code snippet demonstrates the valid `eval()` expression:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了有效的`eval()`表达式：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code block demonstrates a parse error in the evaluated code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块演示了在评估代码中的解析错误：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Seeming nearly identical as a working example, you can notice the lack of the
    opening and closing (`''`) character around the date function parameter. This
    breaks the eval function, triggering the `ParseError` catch block with the following
    output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎与一个正常工作的例子相同，你会注意到在日期函数参数周围缺少开头和结尾的(`'`)字符。这会破坏eval函数，触发`ParseError` catch块，并输出以下内容：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s take a look at the following code snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下以下代码片段：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we are not using the `eval()` expression, but have intentionally broken
    the code. The resulting output triggers the parse error, but this time not through
    reacting to the `catch` block, which is sort of expected. It is highly unlikely
    that this specific case would even happen in the modern IDE environments, such
    as PhpStorm, Netbeans, and alike, as they automatically alert us on broken syntax.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们没有使用`eval()`表达式，而是故意破坏了代码。结果输出触发了解析错误，但这次不是通过对`catch`块的反应，这有点意料之中。在现代IDE环境中，如PhpStorm、Netbeans等，这种特定情况几乎不太可能发生，因为它们会自动警告我们有损坏的语法。
- en: TypeError
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeError
- en: PHP 7 brought forth the *function type parameters* and *function return types*. This,
    in turn, implied the need to properly handle errors around their misuse. `TypeError`
    was introduced to target these errors.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7引入了*函数类型参数*和*函数返回类型*。这反过来意味着需要正确处理它们的误用错误。`TypeError`被引入来解决这些错误。
- en: 'The `TypeError` class has no methods of its own, they are all inherited from
    the parent `Error` class, as per the following class synopsis:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypeError`类没有自己的方法，它们都是从父类`Error`继承而来，如下类概要所示：'
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are at least three possible error scenarios that throw `TypeError`, which
    are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有至少三种可能的错误场景会引发`TypeError`，如下所示：
- en: The type of argument passed to a function does not match the declared type
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给函数的参数类型与声明的类型不匹配
- en: The function return value does not match the declared function return type
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数返回值与声明的函数返回类型不匹配
- en: An invalid number of arguments is being passed to a built-in PHP function
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给内置PHP函数的参数数量无效
- en: 'The following code demonstrates the wrong function argument type:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了错误的函数参数类型：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we defined the `hello()` function that expects to receive a single string
    argument. However, the function is passed to the integer value. The  `declare(strict_types
    = 1);` expression is required if we want the `catch` block to actually catch `TypeError`.
    The preceding example results in the following output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了`hello()`函数，它期望接收一个字符串参数。然而，函数被传递了整数值。如果我们希望`catch`块实际上捕获`TypeError`，则需要`declare(strict_types
    = 1);`表达式。上述例子的结果如下输出：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following code demonstrates the wrong function return type:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了错误的函数返回类型：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, the defined `hello()` function has no specific argument types defined,
    but it does have a function return type defined. To simulate the faulty scenario,
    we changed the body of the function to return the integer value rather than the
    string. Same as with the previous example, the `strict_types = 1` declaration
    was needed to trigger `TypeError`, resulting in the following output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，定义的`hello()`函数没有定义特定的参数类型，但确实定义了函数返回类型。为了模拟错误的情况，我们将函数体改为返回整数值而不是字符串。与前面的例子一样，需要声明`strict_types
    = 1`来触发`TypeError`，结果如下输出：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following code demonstrates the invalid number of arguments that are passed
    to a built-in PHP function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了传递给内置PHP函数的无效参数数量：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we are calling the `strlen()` function with two parameters. Though this core
    PHP function itself is defined such that it accepts only one parameter, the `strict_types
    = 1` declaration turns the standard warning into `TypeError`, thus triggering
    the `catch` block.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用两个参数调用`strlen()`函数。虽然这个核心PHP函数本身是定义为只接受一个参数，但`strict_types = 1`声明将标准警告转换为`TypeError`，从而触发`catch`块。
- en: Uncaught error handler
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未捕获的错误处理程序
- en: 'While a great deal of `Error` can now be caught via `try...catch`, there is
    also an extra mechanism to handle errors. PHP provides a mechanism in the form
    of a `set_error_handler()` function that allows us to define a custom handler
    function for all uncaught errors. The `set_error_handler()` function accepts two parameters,
    as per the following description:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然现在可以通过`try...catch`捕获大量的`Error`，但也有一种额外的机制来处理错误。PHP提供了一种机制，即`set_error_handler()`函数，允许我们为所有未捕获的错误定义一个自定义处理程序函数。`set_error_handler()`函数接受两个参数，如下面的描述所示：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `$error_handler` function is either a handler function name passed as string,
    or entire anonymous handler function, whereas `$error_types` is one or more (separated
    by `|`) masks specifying the type of error. The handler function itself also accepts
    several parameters, as per the following description:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`$error_handler`函数可以是作为字符串传递的处理程序函数名称，也可以是整个匿名处理程序函数，而`$error_types`是一个或多个（用`|`分隔）指定错误类型的掩码。处理程序函数本身也接受几个参数，如下面的描述所示：'
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s take a look at the following two examples:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下两个例子：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: These examples are nearly identical. The first one is using a separately defined
    handler function, which is then passed as a string argument to `set_error_handler()`.
    The second example uses the anonymous function with the same definition. Both
    examples use the `trigger_error()` function, one triggering `E_USER_ERROR` and
    the other  `E_USER_WARNING`. When executed, both outputs will contain the `end`
    string.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子几乎是相同的。第一个例子使用了一个单独定义的处理程序函数，然后将其作为字符串参数传递给`set_error_handler()`。第二个例子使用了相同定义的匿名函数。这两个例子都使用`trigger_error()`函数，一个触发`E_USER_ERROR`，另一个触发`E_USER_WARNING`。执行时，两个输出都将包含`end`字符串。
- en: 'While the custom handler function enables us to handle all sorts of runtime
    errors, there are some errors we cannot handle. The following error types cannot
    be handled with a user-defined function: `E_ERROR`, `E_PARSE`, `E_CORE_ERROR`,
    `E_CORE_WARNING`, `E_COMPILE_ERROR`, `E_COMPILE_WARNING`, and most of `E_STRICT`
    raised in the file where `set_error_handler()` is called.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自定义处理程序函数使我们能够处理各种运行时错误，但有一些错误是我们无法处理的。以下错误类型无法使用用户定义的函数处理：`E_ERROR`、`E_PARSE`、`E_CORE_ERROR`、`E_CORE_WARNING`、`E_COMPILE_ERROR`、`E_COMPILE_WARNING`，以及在调用`set_error_handler()`的文件中引发的大多数`E_STRICT`。
- en: Triggering errors
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发错误
- en: The PHP `trigger_error()` function provides a way to trigger a user-level error/warning/notice
    message. It can be used in conjunction with the built-in error handler, or with
    a user-defined error handler, as we saw in the previous section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的`trigger_error()`函数提供了一种触发用户级错误/警告/通知消息的方法。它可以与内置错误处理程序一起使用，也可以与用户定义的错误处理程序一起使用，就像我们在前一节中看到的那样。
- en: 'The `trigger_error()` function accepts two parameters, as per the following
    description:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`trigger_error()`函数接受两个参数，如下面的描述所示：'
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `$error_msg` parameter has a limitation of 1024 bytes, whereas `$error_type`
    is limited to the `E_USER_ERROR`, `E_USER_WARNING`, `E_USER_NOTICE`, and `E_USER_DEPRECATED` constants.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`$error_msg`参数的限制为1024字节，而`$error_type`限制为`E_USER_ERROR`、`E_USER_WARNING`、`E_USER_NOTICE`和`E_USER_DEPRECATED`常量。'
- en: 'Let''s take a look at the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下例子：
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we have four different `trigger_error()` function calls, each accepting
    different error types. The custom error handler kicks in for all four errors,
    and our code continues executing all the way to show `end` as the output.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有四个不同的`trigger_error()`函数调用，每个函数接受不同的错误类型。自定义错误处理程序对所有四个错误都起作用，我们的代码继续执行，最终输出`end`。
- en: There are certain conceptual similarities between **error model** (`set_error_handler`
    and `trigger_error`) on one side and **throwable model** (`try...catch` and `throw
    new ...`) on the other. Seemingly, both can catch and trigger errors. The main
    difference is that the throwable model is a more modern, object-oriented way.
    That being said, we should limit our use of `trigger_error()` to when it's absolutely
    needed for some contextual reasons.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误模型**（`set_error_handler`和`trigger_error`）和**可抛出模型**（`try...catch`和`throw
    new ...`）之间存在某些概念上的相似之处。看起来，两者都可以捕获和触发错误。主要区别在于可抛出模型是一种更现代、面向对象的方式。也就是说，我们应该限制使用`trigger_error()`，只在绝对需要时才使用。'
- en: Exception
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: Exceptions were originally introduced in PHP 5, which brought forth the OOP
    model as well. They remain pretty much unchanged throughout the time. Among significant
    changes was the one added by PHP 5.5, which added the `finally` block, and PHP
    7, which added the possibility to use the `|` operator in order to catch multiple
    exception types via a single `catch` block.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 异常最初是在PHP 5中引入的，它也带来了面向对象的模型。它们在整个时间内基本保持不变。PHP 5.5添加了`finally`块，PHP 7添加了使用`|`运算符以便通过单个`catch`块捕获多个异常类型的可能性，这是其中的重大变化。
- en: '`Exception` is the base class for all user exceptions in PHP 7\. Same as `Error`,
    `Exception` implements the `Throwable` interface, as per the following class synopsis:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exception`是PHP 7中所有用户异常的基类。与`Error`一样，`Exception`实现了`Throwable`接口，如下面的类概要所示：'
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Exceptions remain the backbone of OO error handling. The simplicity of extending,
    throwing, and catching exceptions makes them easy to work with.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 异常仍然是面向对象错误处理的支柱。扩展、抛出和捕获异常的简单性使它们易于处理。
- en: Creating a custom exception handler
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义异常处理程序
- en: 'By extending the built-in `Exception` class, PHP lets us throw any object as
    if it were an exception. Let''s take a look at the following example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展内置的`Exception`类，PHP让我们可以像抛出异常一样抛出任何对象。让我们看下面的例子：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we defined two custom exceptions, `UsernameException` and `PasswordException`.
    They merely extended the built-in `Exception`, not really introducing any new
    methods or functionality. We then defined two variables, `$username` and `$password`.
    The `$password` variable was set to be an empty string. Finally, we set the `try...catch...finally`
    blocks, with three different `catch` blocks. The first two `catch` blocks are
    targeted to our custom exceptions, and the third targets the built-in `Exception`.
    Due to an empty password, the preceding example would throw `new PasswordException`,
    and, therefore, output the `Caught PasswordException. Finally.` string.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个自定义异常，`UsernameException`和`PasswordException`。它们只是扩展了内置的`Exception`，并没有真正引入任何新的方法或功能。然后，我们定义了两个变量，`$username`和`$password`。`$password`变量被设置为空字符串。最后，我们设置了`try...catch...finally`块，其中包含三个不同的`catch`块。前两个`catch`块针对我们的自定义异常，第三个针对内置的`Exception`。由于密码为空，前面的例子将抛出`new
    PasswordException`，因此输出`Caught PasswordException. Finally.`字符串。
- en: Rethrowing exceptions
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新抛出异常
- en: Rethrowing exceptions is a relatively common practice in development. Sometimes,
    we wish to catch an exception, look into it, do a bit of an extra logic, and then
    rethrow the exception back so that the parent `catch` block might handle it further.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重新抛出异常在开发中是一种相对常见的做法。有时，我们希望捕获异常，查看一下，进行一些额外的逻辑，然后重新抛出异常，以便父`catch`块可以进一步处理它。
- en: 'Let''s take a look at the following example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, we defined three simple exceptions--`FileNotExistException`, `FileReadException`,
    and `FileEmptyException`. These correspond to three different faulty outcomes
    we might expect when dealing with our file. We then added some logic around the
    `file_get_contents` function call, trying to wrap it in the `try...catch` blocks.
    The `file_get_contents` function results in Boolean `false` if the file cannot
    be read. Knowing that, and knowing that `empty` function call results in `false`
    if the file is found empty, we can easily check if the file is alright or not in
    a single `if (!$content)` statement. There are several possible scenarios once
    the general `Exception` is thrown. The first and the most obvious one is the missing
    file. Surprisingly, even with the `try...catch` blocks in place, if the file is
    missing, PHP would output the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了三个简单的异常--`FileNotExistException`，`FileReadException`和`FileEmptyException`。这对应于我们在处理文件时可能遇到的三种不同的故障结果。然后，我们在`file_get_contents`函数调用周围添加了一些逻辑，尝试将其包装在`try...catch`块中。如果文件无法读取，`file_get_contents`函数的结果是布尔值`false`。知道这一点，并且知道`empty`函数调用在文件为空时结果为`false`，我们可以很容易地通过单个`if
    (!$content)`语句来检查文件是否正常。一旦抛出一般的`Exception`，就会有几种可能的情况。最明显的是缺少文件。令人惊讶的是，即使有`try...catch`块，如果文件丢失，PHP也会输出以下内容：
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can clearly see that the core PHP language `Warning` has been raised, along
    with triggering the proper `catch` and `finally` block. Ideally, we would like
    to get away with the warning output. One possible way is to use the error control
    operator--the at sign (`@`). It suppresses both errors and warnings. This is quite
    dangerous and should be used with the utmost care. Generally speaking, errors
    and warnings are triggered to be handled, not to be suppressed. However, in this
    case, we might just call it justified, as we are wrapping everything in `try...catch`
    blocks. The last general `catch` block is merely there to catch an unexpected
    faulty state that is not covered by our three custom exceptions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到，核心PHP语言引发了`Warning`，并触发了适当的`catch`和`finally`块。理想情况下，我们希望摆脱警告输出。一种可能的方法是使用错误控制运算符--at符号（`@`）。它可以抑制错误和警告。这是非常危险的，应该非常小心使用。一般来说，错误和警告是触发处理的，而不是被抑制的。然而，在这种情况下，我们可能认为是合理的，因为我们将所有内容都包裹在`try...catch`块中。最后一个一般的`catch`块只是用来捕获未预料到的故障状态，这些状态不被我们的三个自定义异常所覆盖。
- en: Uncaught Exception handler
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未捕获异常处理程序
- en: PHP provides a mechanism in the form of a `set_exception_handler` function that
    allows us to define a custom handler function for all uncaught throwables, including
    exceptions. The `set_exception_handler` function accepts a single callable parameter--either
    a *function name passed as string*, or an entire *anonymous function*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: PHP提供了一种机制，即`set_exception_handler`函数，允许我们为所有未捕获的可抛出对象（包括异常）定义自定义处理程序函数。`set_exception_handler`函数接受一个可调用参数--可以是*作为字符串传递的函数名*，也可以是*整个匿名函数*。
- en: 'Let''s take a look at the following *function name passed as string* example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的*作为字符串传递的函数名*示例：
- en: '[PRE44]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s take a look at the following *anonymous function* example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的*匿名函数*示例：
- en: '[PRE45]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Both of these code examples do the same thing, there is no difference to them.
    Other than the second example being more ascetically pleasing, as there is no
    need to define a separate function like `throwableHandler()` that will only get
    used in one place. The important thing to note here is that unlike the `try...catch`
    blocks, the call to the handler function is the last thing that our application
    executes, which, in this case, means that we will never see the `end` string on
    screen.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个代码示例做的事情是一样的，它们之间没有区别。除了第二个示例更美观外，因为不需要定义一个单独的函数，比如`throwableHandler()`，它只会在一个地方使用。这里需要注意的重要一点是，与`try...catch`块不同，对处理程序函数的调用是我们的应用程序执行的最后一件事情，这意味着在这种情况下，我们永远不会在屏幕上看到`end`字符串。
- en: Logging
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: Logging is an important aspect of every application. Knowing how to catch errors does
    not necessarily mean we are handling the faulty situation as best as we should.
    If we are not logging the right details, and passing them on to the right consumer,
    then we are not really handling the situation right.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是每个应用程序的重要方面。知道如何捕获错误并不一定意味着我们处理故障情况的方式是最好的。如果我们没有记录正确的细节，并将它们传递给正确的消费者，那么我们实际上并没有正确处理这种情况。
- en: 'Let''s consider the following catch and generate user message example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下捕获和生成用户消息的示例：
- en: '[PRE46]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s consider the following example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例：
- en: '[PRE47]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Both examples react to the exception by storing the message into a `$messages`
    variable, which is later shown on screen to the current user. This is great as
    the application does not crash, the user is shown what happened, and the application
    is allowed to execute. However, is it great? The examples are nearly identical,
    aside from one minor detail. The first example merely responds to the error and
    reacts to it in the moment. The second example uses the `$this->logger->critical($e);`
    expression to log the error, presumably, but necessarily, to a file. By logging
    the error, we make it possible for the consumer to review it later. The consumer
    is most likely a developer who might take a look into log files every now and
    then. Notice how the `$messages` array is not passed directly to the `$e` variable,
    rather, a custom message that fits the user situation. This is because the user
    should never be shown the level of detail we might pass onto our logs. The more
    details we pass to our log, the easier it gets to troubleshoot our application.
    By logging an entire exception instance object, in this case, we pretty much provide
    all the details the developer needs to know to try and prevent an error in the
    future.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例都通过将消息存储到`$messages`变量中来响应异常，稍后将其显示给当前用户。这很好，因为应用程序不会崩溃，用户会看到发生了什么，并且应用程序被允许执行。但是，这真的很好吗？这两个示例几乎完全相同，除了一个细微的细节。第一个示例仅在错误发生时做出响应并立即做出反应。第二个示例使用`$this->logger->critical($e);`表达式来记录错误，可能是，但不一定是，记录到文件中。通过记录错误，我们使得消费者有可能稍后进行审查。消费者很可能是开发人员，他们可能会不时地查看日志文件。请注意，`$messages`数组并未直接传递给`$e`变量，而是适合用户情况的自定义消息。这是因为用户不应该看到我们可能传递给日志的详细级别。我们传递给日志的细节越多，就越容易排除应用程序的故障。通过记录整个异常实例对象，在这种情况下，我们基本上提供了开发人员需要了解的所有细节，以便尝试并防止将来的错误。
- en: Thoughtfully used, logging can provide quality analytics insight upon which
    we might periodically reiterate over our codebase and prevent issues that might
    not be visible during initial development. Aside from logging errors, we could
    easily log other analytical, or otherwise important bits.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 经过深思熟虑的使用，日志记录可以提供质量分析洞察，我们可以定期重复我们的代码库，并防止在初始开发过程中可能看不到的问题。除了记录错误，我们还可以轻松记录其他分析或其他重要的部分。
- en: The open source Elastic stack, available at [https://www.elastic.co](https://www.elastic.co),
    enables us to reliably and securely take data from any source, in any format,
    and search, analyse, and visualize it in real time. The Kibana product, available
    at [https://www.elastic.co/products/kibana](https://www.elastic.co/products/kibana),
    gives shape to our data through its interactive visualizations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 开源的Elastic stack，可在[https://www.elastic.co](https://www.elastic.co)上获得，使我们能够可靠且安全地从任何来源以任何格式获取数据，并实时搜索、分析和可视化数据。Kibana产品，可在[https://www.elastic.co/products/kibana](https://www.elastic.co/products/kibana)上获得，通过其交互式可视化为我们的数据赋予形状。
- en: Native logging
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地记录
- en: PHP has a built-in `error_log()` function that sends an error message to the
    defined error handling routines; thus, providing an out-of-the-box solution for
    simple logging.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: PHP具有内置的`error_log()`函数，它将错误消息发送到定义的错误处理程序；因此，为简单的记录提供了开箱即用的解决方案。
- en: 'The following code snippet describes the `error_log()` function definition:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段描述了`error_log()`函数的定义：
- en: '[PRE48]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The parameters are defined as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 参数定义如下：
- en: '`$message`: This is a string type value, and a message we want to log'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$message`：这是一个字符串类型的值，是我们想要记录的消息'
- en: '`$message_type`: This is an integer type value; it has one of four possible
    values, which are as follows:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$message_type`：这是一个整数类型的值；它有四个可能的值，如下所示：'
- en: '`0`: This is an operating system logging mechanism'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：这是一个操作系统日志记录机制'
- en: '`1`: This is sent by e-mail to the address in the destination parameter'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：这通过电子邮件发送到目标参数中的地址'
- en: '`2`: This is no longer an option'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：这不再是一个选项'
- en: '`3`: This message is appended to the file destination'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`：此消息附加到文件目的地'
- en: '`4`: This is sent directly to the SAPI logging handler'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`：这直接发送到SAPI日志处理程序'
- en: '`$destination`: This string type value kicks in only for `$message_type = 1` and
    denotes an e-mail address'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$destination`：这是一个字符串类型的值，仅在`$message_type = 1`时起作用，并表示电子邮件地址'
- en: '`$extra_headers`: This string type value kicks in only for `$message_type =
    1` and denotes e-mail headers'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$extra_headers`：这是一个字符串类型的值，仅在`$message_type = 1`时起作用，并表示电子邮件头'
- en: 'The `error_log()` function works closely with the `log_errors` and `error_log` configuration
    options defined in `php.ini`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`error_log()`函数与`php.ini`中定义的`log_errors`和`error_log`配置选项密切相关：'
- en: '`log_errors`: This is a boolean type configuration option. It tells if error
    messages should be logged to the server error log or `error_log`. To log to a file
    specified with the `error_log` configuration option, set this to `1`.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log_errors`：这是一个布尔类型的配置选项。它告诉我们是否应该将错误消息记录到服务器错误日志或`error_log`。要记录到使用`error_log`配置选项指定的文件，请将其设置为`1`。'
- en: '`error_log`: This is a string type configuration option. It specifies the name
    of the file where errors should be logged. If `syslog` is used, errors are logged
    to the system logger. If no value is set, errors are sent to the SAPI error logger,
    which is most likely an error log in Apache or stderr in CLI.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error_log`：这是一个字符串类型的配置选项。它指定应将错误记录到的文件的名称。如果使用`syslog`，则将错误记录到系统记录器。如果未设置任何值，则将错误发送到SAPI错误记录器，这很可能是Apache中的错误日志或CLI中的stderr。'
- en: 'The following example demonstrates logging to a file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了记录到文件中：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `log_errors` and `error_log` options might be defined in the `.php` file
    itself; however, it is recommended to do so in `php.ini`, otherwise, logging won''t log
    any errors if the script has parse errors or cannot be run at all. The resulting
    output of the preceding example would be an `app-error.log` file, located in the
    same directory as the executing script itself with the following content:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`log_errors`和`error_log`选项可以在`.php`文件中定义；然而，建议在`php.ini`中这样做，否则，如果脚本有解析错误或根本无法运行，日志将不会记录任何错误。上面示例的结果输出将是一个`app-error.log`文件，位于执行脚本本身相同的目录中，内容如下：'
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following example demonstrates logging to an e-mail:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何记录日志到电子邮件：
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we are first building the raw `$headers` string, which we then pass to
    the `error_log()` function, along with the destination e-mail address. This is
    an obvious downside of the `error_log()` function, as we are required to be familiar
    with e-mail message headers standards.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先构建原始的`$headers`字符串，然后将其传递给`error_log()`函数，以及目标电子邮件地址。这是`error_log()`函数的一个明显缺点，因为我们需要熟悉电子邮件消息头的标准。
- en: 'The `error_log()` function is not binary-safe, which means the `$message` argument
    should not contain a null character, otherwise, it will be truncated. To bypass
    this limitation, we can use one of the conversion/escape functions, such as `base64_encode()`,
    `rawurlencode()`, or `addslashes()` before calling `error_log()`. The following
    RFCs might be useful for dealing with e-mail message headers: RFC 1896, RFC 2045,
    RFC 2046, RFC 2047, RFC 2048, RFC 2049, and RFC 2822.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`error_log()`函数不是二进制安全的，这意味着`$message`参数不应包含空字符，否则它将被截断。为了避开这个限制，我们可以在调用`error_log()`之前使用一个转换/转义函数，比如`base64_encode()`、`rawurlencode()`或`addslashes()`。以下RFC可能对处理电子邮件消息头很有用：RFC
    1896、RFC 2045、RFC 2046、RFC 2047、RFC 2048、RFC 2049和RFC 2822。'
- en: 'Understanding the `error_log()` function, we can easily wrap it into a custom
    function of ours, let''s say `app_error_log()`, thus abstracting the entire e-mails''
    boilerplate, such as the address and headers. We can also make our `app_error_log()`
    function log into file and e-mail at once, thus making for a simple, one-line
    logging expression such as the following, possibly across our application:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 了解`error_log()`函数后，我们可以很容易地将其封装成我们自己的自定义函数，比如`app_error_log()`，从而抽象出整个电子邮件的样板，比如地址和头部。我们还可以使我们的`app_error_log()`函数同时记录到文件和电子邮件，从而实现一个简单的、一行的日志记录表达式，比如下面的例子，可能在我们的应用程序中使用：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Writing simple loggers such as these is quite easy. However, simplicity in development
    usually comes with the cost of reduced modularity. Luckily, there are third-party
    libraries out there that are quite robust when it comes to logging features. Best
    of all, they comply to a certain logging standard, as we will see in the next
    section.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这样简单的日志记录器非常容易。然而，开发中的简单通常伴随着降低模块化的成本。幸运的是，有一些第三方库在日志记录功能方面非常强大。最重要的是，它们符合某种日志记录标准，我们将在下一节中看到。
- en: Logging with Monolog
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Monolog进行日志记录
- en: The PHP community provides several logging libraries for us to choose, such
    as Monolog, Analog, KLogger, Log4PHP, and others. Choosing the right library can
    be a daunting task. More so because we might decide to change the logging mechanism
    later on, which might leave us with a substantial amount of code to change. This
    is where the PSR-3 logging standard helps. Choosing a library that is standards-compliant
    makes it easier to reason with.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: PHP社区为我们提供了几个日志记录库可供选择，比如Monolog、Analog、KLogger、Log4PHP等。选择合适的库可能是一项艰巨的任务。尤其是因为我们可能决定以后更改日志记录机制，这可能会导致我们需要改变大量的代码。这就是PSR-3日志记录标准的作用。选择一个符合标准的库可以更容易地进行推理。
- en: Monolog is one of the most popular PHP logging libraries. It is a free, MIT-licensed
    library that implements the PSR-3 logging standard. It allows us to easily sends
    our logs to files, sockets, inboxes, databases, and various web services.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Monolog是最受欢迎的PHP日志记录库之一。它是一个免费的、MIT许可的库，实现了PSR-3日志记录标准。它允许我们轻松地将日志发送到文件、套接字、收件箱、数据库和各种网络服务。
- en: 'We can easily install the Monolog library as a `composer` package by running
    the following console command within our projects folder:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在项目文件夹中运行以下控制台命令轻松安装Monolog库作为`composer`包：
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If `composer` is not an option, we can download Monolog from the GitHub at [https://github.com/Seldaek/monolog](https://github.com/Seldaek/monolog).
    Those using leading PHP frameworks, such as Symfony or Laravel, get the Monolog
    out-of-the-box.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`composer`不是一个选择，我们可以从GitHub上下载Monolog，网址为[https://github.com/Seldaek/monolog](https://github.com/Seldaek/monolog)。那些使用主要PHP框架，比如Symfony或Laravel的人，可以直接使用Monolog。
- en: 'The compliance to the PSR-3 logging standard also means that Monolog supports
    the logging levels described by RFC 5424, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 符合PSR-3日志记录标准也意味着Monolog支持RFC 5424描述的日志级别，如下所示：
- en: '`DEBUG (100)`: Debug-level messages'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEBUG (100)`: 调试级别消息'
- en: '`INFO (200)`: Informational messages'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INFO (200)`: 信息消息'
- en: '`NOTICE (250)`: Normal but significant condition'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOTICE (250)`: 正常但重要的条件'
- en: '`WARNING (300)`: Warning conditions'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WARNING (300)`: 警告条件'
- en: '`ERROR (400)`: Error conditions'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERROR (400)`: 错误条件'
- en: '`CRITICAL (500)`: Critical conditions'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CRITICAL (500)`: 临界条件'
- en: '`ALERT (550)`: Action must be taken immediately'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALERT (550)`: 必须立即采取行动'
- en: '`EMERGENCY (600)`: System is unusable'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMERGENCY (600)`: 系统不可用'
- en: These constants are defined as part of the `vendor/monolog/monolog/src/Monolog/Logger.php`
    file, alongside a practical use case example for most of them.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常量定义在`vendor/monolog/monolog/src/Monolog/Logger.php`文件中，大部分都有一个实际的用例示例。
- en: The core concept behind every Monolog logger instance is that the instance itself has
    a channel (name) and a stack of handlers. We can instantiate multiple loggers,
    each defining a certain channel (db, request, router, and alike). Each channel can
    combine various handlers. The handlers themselves can be shared across channels.
    The channel is reflected in the logs and allows us to easily see or filter records.
    Finally, each handler also has a formatter. The formatter normalizes and formats
    incoming records so that they can be used by the handlers to output useful information.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Monolog 记录器实例的核心概念是实例本身具有一个通道（名称）和一组处理程序。我们可以实例化多个记录器，每个定义一个特定的通道（db，request，router
    等）。每个通道可以组合各种处理程序。处理程序本身可以在通道之间共享。通道反映在日志中，并允许我们轻松查看或过滤记录。最后，每个处理程序还有一个格式化器。格式化器对传入的记录进行规范化和格式化，以便处理程序输出有用的信息。
- en: 'The following diagram visualizes this logger-channel-formatter structure:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了这个记录器-通道-格式化器的结构：
- en: '![](assets/097c18e6-815f-427d-8fe3-96e011f9a995.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/097c18e6-815f-427d-8fe3-96e011f9a995.png)'
- en: Monolog provides quite an extensive list of loggers and formatters.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Monolog 提供了相当丰富的记录器和格式化器列表。
- en: 'Loggers:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录器：
- en: Log to files and syslog (`StreamHandler`, `RotatingFileHandler`, `SyslogHandler`,
    ...)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录到文件和系统日志（`StreamHandler`，`RotatingFileHandler`，`SyslogHandler`，...）
- en: Send alerts and e-mails (`SwiftMailerHandler`, `SlackbotHandler`, `SendGridHandler`,
    ...)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送警报和电子邮件（`SwiftMailerHandler`，`SlackbotHandler`，`SendGridHandler`，...）
- en: Log-specific servers and networked logging (`SocketHandler`, `CubeHandler`,
    `NewRelicHandler`, ...)
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定于日志的服务器和网络日志（`SocketHandler`，`CubeHandler`，`NewRelicHandler`，...）
- en: Logging in development (`FirePHPHandler`, `ChromePHPHandler`, `BrowserConsoleHandler`,
    ...)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发中的日志记录（`FirePHPHandler`，`ChromePHPHandler`，`BrowserConsoleHandler`，...）
- en: Log to databases (`RedisHandler`, `MongoDBHandler`, `ElasticSearchHandler`,
    ...)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录到数据库（`RedisHandler`，`MongoDBHandler`，`ElasticSearchHandler`，...）
- en: 'Formatters:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化器：
- en: '`LineFormatter`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LineFormatter`'
- en: '`HtmlFormatter`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HtmlFormatter`'
- en: '`JsonFormatter`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JsonFormatter`'
- en: '...'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '...'
- en: A full list of Monolog loggers and formatters can be obtained through the official
    Monolog project page at [https://github.com/Seldaek/monolog](https://github.com/Seldaek/monolog).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过官方的 Monolog 项目页面获取完整的 Monolog 记录器和格式化器列表 [https://github.com/Seldaek/monolog](https://github.com/Seldaek/monolog)。
- en: 'Let''s take a look at the following simple example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we are creating an instance of `Logger` and naming it `foggyline`.  We
    then use the `pushHandler` method to push inline instantiated instances of two
    different handlers.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个 `Logger` 实例，并将其命名为 `foggyline`。然后我们使用 `pushHandler` 方法推送内联实例化的两个不同处理程序的实例。
- en: The `RotatingFileHandler`  logs records to a file and creates one log file per
    day. It also deletes files older than the `$maxFiles` argument, which, in our
    example, is set to `7`. Regardless of the log file name being set to `foggyline.log`,
    the actual log file created by `RotatingFileHandler` contains the timestamp in
    it, resulting in a name such as `foggyline-2016-12-26.log`. When we think about
    it, the role of this handler is remarkable. Aside from just creating new log entries,
    it also takes care of deleting old logs.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`RotatingFileHandler` 将记录日志到文件，并每天创建一个日志文件。它还会删除早于 `$maxFiles` 参数的文件，而在我们的示例中，该参数设置为
    `7`。不管日志文件名是否设置为 `foggyline.log`，由 `RotatingFileHandler` 创建的实际日志文件中包含了时间戳，因此会得到一个名为
    `foggyline-2016-12-26.log` 的文件。当我们考虑这一点时，这个处理程序的作用是非常显著的。除了创建新的日志条目之外，它还负责删除旧的日志。'
- en: 'The following is an output of our `foggyline-2016-12-26.log` file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的 `foggyline-2016-12-26.log` 文件的输出：
- en: '[PRE55]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The second handler we pushed to stack, `BrowserConsoleHandler`, sends logs
    to the browser''s JavaScript console with no browser extension required. This
    works on most modern browsers that support the console API. The resulting output
    of this handler is shown in the following screenshot:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推送到堆栈的第二个处理程序 `BrowserConsoleHandler`，将日志发送到浏览器的 JavaScript 控制台，无需浏览器扩展。这适用于大多数支持控制台
    API 的现代浏览器。该处理程序的输出如下截图所示：
- en: '![](assets/464af28d-9107-4de6-9c85-dae25805202e.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/464af28d-9107-4de6-9c85-dae25805202e.png)'
- en: With these few simple lines of code, we have added quite an impressive set of
    logging capabilities to our application. `RotatingFileHandler` seems perfect for
    a later state analysis of a production running application, while `BrowserConsoleHandler` might
    serve as a convenient way to speed up ongoing development. Goes to say that logs
    serve a wider purpose of just logging for errors. Logging various pieces of information
    at various log levels, we can easily use the Monolog library as sort of an analytics
    bridge. All it takes is to push proper handlers to the stack, which in turn push
    logs to various destinations, such as Elasticsearch and alike.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这几行简单的代码，我们为我们的应用程序添加了相当令人印象深刻的日志功能。`RotatingFileHandler` 似乎非常适合用于生产运行应用程序的后续状态分析，而
    `BrowserConsoleHandler` 可能作为加快持续开发的便捷方式。可以说，日志的作用远不止于记录错误。通过在各种日志级别记录各种信息，我们可以轻松地将
    Monolog 库用作一种分析桥梁。只需将适当的处理程序推送到堆栈，然后将日志推送到各种目的地，例如 Elasticsearch 等。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Throughout this chapter, we took a detailed look through the PHP error handling
    mechanism. PHP 7 made quite a cleanup of its error handling model by wrapping
    most of it under the `Throwable` interface. This makes it possible to catch core
    errors via `try...catch` blocks that were, prior to PHP 7, reserved for `Exception`
    only. This leaves a bit of a terminology fuzz to digest now, as we come across `Throwable`,
    `Error`, `Exception`, system-errors, user-errors, notices, warnings and alike.
    Speaking high level, we might say that any faulty state is error. More specifically,
    we now have throwables on one side and errors on the other. Throwables encompass
    thrown and catchable instances of `Error` and `Exception`, whereas, errors encompass basically
    anything not catchable as `Throwable`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细研究了PHP的错误处理机制。PHP 7通过将大部分错误处理模型包装在`Throwable`接口下，对其进行了相当大的清理。这使得可以通过`try...catch`块捕获核心错误，而在PHP
    7之前，这些错误只能保留给`Exception`。现在，当我们遇到`Throwable`、`Error`、`Exception`、系统错误、用户错误、通知、警告等术语时，可能会有一些术语上的混淆需要消化。从高层次来说，我们可以说任何错误状态都是错误。更具体地说，现在我们有可抛出的错误，另一方面有错误。可抛出的错误包括`Error`和`Exception`的抛出和可捕获的实例，而错误基本上包括任何不可捕获为`Throwable`的东西。
- en: Handling faulty states would not really be complete without proper logging. While
    the built-in `error_log()` function provides enough to get us started, more robust
    solutions are available in the form of various third-party libraries. The Monolog
    library is among the most popular ones and is used across dozens of community
    projects.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误状态如果没有适当的日志记录就不会真正完整。虽然内置的`error_log()`函数提供了足够的功能让我们开始，但更健壮的解决方案可以通过各种第三方库来实现。Monolog库是最受欢迎的库之一，被用于数十个社区项目中。
- en: Moving forward, we will look into the magic methods and the enormous power they
    bring to the PHP language.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在向前迈进时，我们将深入研究魔术方法及其为PHP语言带来的巨大力量。
