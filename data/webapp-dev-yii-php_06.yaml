- en: Chapter 6. User Management and Authentication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。用户管理和身份验证
- en: We have made a lot of progress in a very short amount of time. The basic foundation
    of our TrackStar application has been laid. We now have the ability to manage
    projects and issues within projects, which is the primary purpose of this application.
    Of course, there is still a lot left to do.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在很短的时间内取得了很大的进展。我们已经奠定了TrackStar应用程序的基本基础。现在我们可以管理项目和项目内的问题，这是该应用程序的主要目的。当然，还有很多工作要做。
- en: Back in [Chapter 3](ch03.html "Chapter 3. The TrackStar Application"), *The
    TrackStar Application*, when we were introducing this application, we described
    it as a user-based application that provides the ability to create user accounts
    and grants access to the application features once a user has been authenticated
    and authorized. In order for this application to be useful to more than one person
    we need to add the ability to manage users within projects. This is going to be
    the focus of the next two chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第3章](ch03.html "第3章。TrackStar应用程序") *TrackStar应用程序*，当我们介绍这个应用程序时，我们将其描述为一个基于用户的应用程序，它提供了创建用户帐户并在用户经过身份验证和授权后授予对应用程序功能的能力。为了使这个应用程序对不止一个人有用，我们需要添加在项目内管理用户的能力。这将是接下来两章的重点。
- en: Feature planning
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能规划
- en: When we used the `yiic` command-line tool to initially create our TrackStar
    application, we noticed that basic login functionality was automatically created
    for us. The login page allows for two username/password credential combinations,
    `demo/demo` and `admin/admin`. You may recall that we had to log in to the application
    in order to perform some of our CRUD operations on our project and issue entities
    in the previous two chapters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`yiic`命令行工具最初创建TrackStar应用程序时，我们注意到基本的登录功能已经为我们自动创建。登录页面允许两个用户名/密码凭据组合，`demo/demo`和`admin/admin`。您可能还记得我们必须登录到应用程序中，以便在前两章中对项目和问题实体执行一些CRUD操作。
- en: This basic authentication skeleton code provides a great start, but we need
    to make a few changes in order to support any number of users. We also need to
    add user CRUD functionality to the application to allow us to manage these multiple
    users. This chapter is going to focus on extending the authentication model to
    use the `tbl_user` database table and add the needed functionality to allow for
    basic user data management.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本的身份验证骨架代码提供了一个很好的开始，但我们需要做一些改变，以支持任意数量的用户。我们还需要向应用程序添加用户CRUD功能，以便我们可以管理这些多个用户。本章将重点介绍扩展身份验证模型以使用`tbl_user`数据库表，并添加所需功能以允许基本用户数据管理。
- en: 'In order to achieve the above outlined goals, we will need to work on the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现上述目标，我们需要处理以下事项：
- en: 'Create the controller classes that will house the functionality to allow us
    to:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建将包含允许我们执行以下功能的控制器类：
- en: Create new users
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新用户
- en: Retrieve a list of existing users from the database
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库中检索现有用户的列表
- en: Update/edit existing users
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新/编辑现有用户
- en: Delete existing users
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除现有用户
- en: 'Create the view files and presentation tier logic that will:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建视图文件和表示层逻辑，将：
- en: Display the form to allow for new user creation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示表单以允许创建新用户
- en: Display a listing of all the existing users
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所有现有用户的列表
- en: Display the form to allow the editing of an existing user
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示表单以允许编辑现有用户
- en: Add a delete button so we can delete users
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加删除按钮，以便我们可以删除用户
- en: Make adjustments to the create new user form so that it can be used by external
    users as a self-registration process
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整创建新用户表单，以便外部用户可以使用自注册流程
- en: Alter the authentication process to use the database to validate the login credentials
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改身份验证过程，以使用数据库验证登录凭据。
- en: User CRUD
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户CRUD
- en: As we are building a user-based web application, we must have a way to add and
    manage users. We added a `tbl_user` table to our database in [Chapter 5](ch05.html
    "Chapter 5. Managing Issues"), *Managing Issues*. You may recall that we left
    it as an exercise to the reader to create the associated AR model class. If you
    are following along and did not create the necessary user model class, you will
    need to do so now.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在构建一个基于用户的Web应用程序，我们必须有一种方法来添加和管理用户。我们在[第5章](ch05.html "第5章。管理问题") *管理问题*中向数据库添加了`tbl_user`表。您可能还记得我们留给读者的练习是创建相关的AR模型类。如果您正在跟着做，并且没有创建必要的用户模型类，现在需要这样做。
- en: 'The following is a brief reminder on using the Gii code creation tool to create
    the model class:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Gii代码创建工具创建模型类的简要提醒：
- en: Navigate to the Gii tool via `http://localhost/trackstar/index.php?r=gii` and
    select the **Model Generator** link.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`http://localhost/trackstar/index.php?r=gii`导航到Gii工具，并选择**Model Generator**链接。
- en: Leave the table prefix as `tbl_`. Fill in the **Table Name** field as `tbl_user`,
    which will autopopulate the **Model Class** name field as **User**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将表前缀保留为`tbl_`。在**Table Name**字段中填写`tbl_user`，这将自动填充**Model Class**名称字段为**User**。
- en: Once the form is filled out, click on the **Preview** button to get a link to
    a pop up that will show you all of the code about to be generated.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写表单后，单击**Preview**按钮，获取一个链接到弹出窗口，显示即将生成的所有代码。
- en: Finally, click on the **Generate** button to actually create the new `User.php`
    model class file in the `/protected/models/ directory`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，单击**Generate**按钮，实际创建新的`User.php`模型类文件在`/protected/models/`目录中。
- en: 'With the `User` AR class in place, creating the CRUD scaffolding is a snap.
    We have done this before, using the Gii tool. As a reminder, the following are
    the necessary steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`User` AR类，创建CRUD脚手架就变得很简单。我们以前使用过Gii工具做过这个。提醒一下，以下是必要的步骤：
- en: Navigate to the tool via `http://localhost/trackstar/index.php?r=gii`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`http://localhost/trackstar/index.php?r=gii`导航到工具。
- en: Click on the **Crud Generator** link from the list of available generators.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用生成器列表中单击**Crud Generator**链接。
- en: Type in `User` for the **Model Class** name field. The corresponding **Controller
    ID** will autopopulate with **User**.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Model Class**名称字段中键入`User`。相应的**Controller ID**将自动填充为**User**。
- en: You will then be presented with options to preview each file prior to generating.
    Click on the **Generate** button, which will generate all of the associated CRUD
    files in their proper locations.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您将看到在生成之前预览每个文件的选项。单击**生成**按钮，它将在适当的位置生成所有相关的CRUD文件。
- en: 'With this in place, we can view our user listing page at `http://localhost/trackstar/index.php?r=user/index`.
    In the previous chapter, we manually created a couple of users in our system so
    that we could properly handle the relationships between projects, issues, and
    users. This is why we see a couple of users listed on this page. The following
    screenshot shows how this page is displayed for us:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以在`http://localhost/trackstar/index.php?r=user/index`查看我们的用户列表页面。在上一章中，我们手动创建了一些用户，以便我们可以正确处理项目、问题和用户之间的关系。这就是为什么我们在这个页面上看到了一些用户。以下截图显示了我们如何显示这个页面：
- en: '![User CRUD](graphics/8727_06_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![用户CRUD](graphics/8727_06_01.jpg)'
- en: We can also view the new **Create User** form by visiting `http://localhost/trackstar/index.php?r=user/create`.
    If you are not currently logged in, you will be first routed to the login page
    before being able to view the form. So you might have to log in using `demo/demo`
    or `admin/admin` to view this form.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过访问`http://localhost/trackstar/index.php?r=user/create`来查看新的**创建用户**表单。如果您当前未登录，您将首先被路由到登录页面，然后才能查看表单。因此，您可能需要使用`demo/demo`或`admin/admin`登录以查看此表单。
- en: Having created and used our CRUD operation functionality first on our project
    entity, and then again with issues, we are very familiar at this point with how
    these features are initially implemented by the Gii code generation tool. The
    generated code for creating and updating is a great start, but needs some adjusting
    to meet the specific application requirements. The form we just generated for
    creating a new user is no exception. It has an input form field for every single
    column that has been defined in the `tbl_user` table. We don't want to expose
    all of these fields for user input. The columns for last login time, creation
    time and user, and update time and user should all be set programmatically after
    the form is submitted.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们首先在项目实体上，然后再次在问题上创建和使用CRUD操作功能后，我们现在非常熟悉这些功能最初是如何由Gii代码生成工具实现的。用于创建和更新的生成代码是一个很好的开始，但需要一些调整以满足特定的应用程序要求。我们刚刚为创建新用户生成的表单也不例外。它为在`tbl_user`表中定义的每个列都有一个输入表单字段。我们不希望将所有这些字段都暴露给用户输入。最后登录时间、创建时间和用户以及更新时间和用户的列应在提交表单后以编程方式设置。
- en: Updating our common audit history columns
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新我们的常见审计历史列
- en: Back in the previous chapters, when we introduced our **Project** and **Issue**
    CRUD functionality, we also noticed that our forms had more input fields than
    they should. Since we have defined all of our database tables to have the same
    creation and update time and user columns, every one of our autocreated input
    forms has these fields exposed. We completely ignored these fields when dealing
    with the project creation form back in [Chapter 4](ch04.html "Chapter 4. Project
    CRUD"), *Project CRUD*. Then, with the new issue creation form in [Chapter 5](ch05.html
    "Chapter 5. Managing Issues"), *Managing Issues*, we took the step to remove the
    fields from displaying in the form, but we never added in the logic to properly
    set these values when a new row is added.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 回到之前的章节，当我们介绍我们的**项目**和**问题**CRUD功能时，我们还注意到我们的表单有比应该更多的输入字段。由于我们已经定义了所有的数据库表都有相同的创建和更新时间和用户列，我们的每个自动生成的输入表单都暴露了这些字段。在[第4章](ch04.html
    "第4章。项目CRUD")中处理项目创建表单时，我们完全忽略了这些字段，*项目CRUD*。然后，在[第5章](ch05.html "第5章。管理问题")中，*管理问题*，我们采取了一步措施，从表单中删除了这些字段的显示，但我们从未添加逻辑来在添加新行时正确设置这些值。
- en: Let's take a minute to add in this needed logic. Since all of our entity tables,
    `tbl_project`, `tbl_issue`, and `tbl_user`, have the same columns defined, we
    could add our logic to a common base class and then have each of the individual
    AR classes extend from this new base class. This is a common approach to applying
    the same functionality to entities of the same type. However, Yii components—that
    is any instance of `CComponent` or a derived class of `CComponent`, which are
    typically the majority of your classes in a Yii application—offer you another
    and arguably more flexible alternative.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一点时间添加这个所需的逻辑。由于我们的实体表`tbl_project`、`tbl_issue`和`tbl_user`都定义了相同的列，我们可以将我们的逻辑添加到一个公共基类中，然后让每个单独的AR类从这个新的基类扩展。这是将相同功能应用于相同类型实体的常见方法。然而，Yii组件——即`CComponent`的任何实例或`CComponent`的派生类，这通常是Yii应用程序中大多数类的情况——为您提供了另一种，可能更灵活的选择。
- en: Component behavior
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件行为
- en: Behaviors in Yii are classes implementing the `IBehavior` interface, and whose
    methods can be used to extend the functionality of components by being attached
    to the component, rather than the component explicitly extending the class. Behaviors
    can be attached to multiple components and components can attach multiple behaviors.
    This re-use of behaviors across components makes them very flexible, and by being
    able to attach multiple behaviors to the same component, we are able to achieve
    a kind of *multiple inheritance* for our Yii component classes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Yii中的行为是实现`IBehavior`接口的类，其方法可以通过附加到组件而不是显式扩展类来扩展组件的功能。行为可以附加到多个组件，组件可以附加多个行为。跨组件重用行为使它们非常灵活，通过能够将多个行为附加到同一个组件，我们能够为我们的Yii组件类实现一种*多重继承*。
- en: We are going to use this approach to add the needed functionality to our model
    classes. The reason we are taking this approach, rather than just adding the logic
    directly to our `User` model class, is because our other model classes, `Issue`
    and `Project`, also need this same logic. Rather than duplicate the code in every
    AR model class, placing the functionality in behaviors, and then attaching the
    behaviors to the model classes, will allow us to properly set these fields for
    every AR model class in just one place.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这种方法为我们的模型类添加所需的功能。我们采取这种方法的原因是，我们的其他模型类，`Issue`和`Project`，也需要相同的逻辑。与其在每个AR模型类中重复代码，将功能放在行为中，然后将行为附加到模型类中，将允许我们在一个地方为每个AR模型类正确设置这些字段。
- en: 'In order for a component to use the methods of a behavior, the behavior has
    to be attached to the component. This is as simple as calling the `attachBehavior()`
    method on a component:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让组件使用行为的方法，行为必须附加到组件上。这只需要在组件上调用`attachBehavior()`方法就可以了：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the previous code, `$name` is a unique identifier for the behavior within
    the component. Once attached, the component can call the methods defined in the
    behavior class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，`$name`是组件内行为的唯一标识符。一旦附加，组件就可以调用行为类中定义的方法：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previous code, `myBehaviorMethod()` is defined in the `$behavior` class,
    but can be called as if it was defined in the `$component` class.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，`myBehaviorMethod()`在`$behavior`类中被定义，但可以像在`$component`类中定义一样调用。
- en: For model classes, we can add our desired behaviors to the `behaviors()` method,
    which is the approach we will take for these model classes. Now we just need to
    create a behavior to attach.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模型类，我们可以在`behaviors()`方法中添加我们想要的行为，这是我们将采取的方法。现在我们只需要创建一个要附加的行为。
- en: In fact, the Zii extension library, which is packaged with the Yii framework,
    already has a ready-made behavior that will update our date-time columns, `create_time`
    and `update_time`, which we have on each of our underlying tables. This behavior
    is called `CTimestampBehavior`. So, let's put this behavior to use.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Yii框架打包的Zii扩展库已经有一个现成的行为，可以更新我们每个基础表上的日期时间列`create_time`和`update_time`。这个行为叫做`CTimestampBehavior`。所以，让我们开始使用这个行为。
- en: 'Let''s start with our `User` model class. Add the following method to `protected/models/User.php`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的`User`模型类开始。将以下方法添加到`protected/models/User.php`中：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we are attaching the Zii extension library's `CTimestampBehavior` to our
    `User` model class. We have specified the create time and update time attributes
    and have also configured the behavior to set the update time when a new record
    is created. With this in place, we can try it out. Create a new user, and you'll
    see the `create_time` and `update_time` records being automatically inserted for
    us. Pretty cool, right?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将Zii扩展库的`CTimestampBehavior`附加到我们的`User`模型类上。我们已经指定了创建时间和更新时间属性，并且还配置了行为，在创建新记录时设置更新时间。有了这个设置，我们可以试一下。创建一个新用户，你会看到`create_time`和`update_time`记录被自动插入。很酷，对吧？
- en: '![Component behavior](graphics/8727_06_07.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![组件行为](graphics/8727_06_07.jpg)'
- en: This is great, but we need to repeat this in our other model classes. We could
    duplicate the `behaviors()` method in each one, and continue to do so as we add
    more model classes. Alternatively, we could put this in a common base class and
    have each of our model classes extend this new base class. This way, we would
    only need to define the `behaviors()` method once.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，但我们需要在其他模型类中重复这个过程。我们可以在每个模型类中复制`behaviors()`方法，并且在添加更多模型类时继续这样做。或者，我们可以将其放在一个通用的基类中，并让我们的每个模型类扩展这个新的基类。这样，我们只需要定义一次`behaviors()`方法。
- en: We need to insert our `create_user_id` and `update_user_id` columns as well
    when we save and update a record. We could handle this in a number of ways. Since
    multiple behaviors can be attached to a component, we could create a new behavior,
    that is similar to `CTimestampBehavior`, which updates the create and update user
    ID columns. Or, we could simply extend `CTimestampBehavior`, and add the extra
    functionality to this child class. Or we could tap into the model `beforeSave`
    event directly and set our necessary fields there. Extending the existing behavior
    to add this extra functionality would probably make the most sense in a real-world
    application; however, to demonstrate another approach, let's tap into the active
    record `beforeSave` event, and do this in a common base class from which all of
    our AR model classes can extend. This way, you'll have exposure to a couple of
    different approaches and have more options to choose from when building your own
    Yii applications.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存和更新记录时，我们还需要插入我们的`create_user_id`和`update_user_id`列。我们可以以多种方式处理这个问题。由于一个组件可以附加多个行为，我们可以创建一个类似于`CTimestampBehavior`的新行为，用于更新创建和更新用户ID列。或者，我们可以简单地扩展`CTimestampBehavior`，并在这个子类中添加额外的功能。或者我们可以直接利用模型的`beforeSave`事件，并在那里设置我们需要的字段。在现实世界的应用中，扩展现有的行为以添加这个额外的功能可能是最合理的方法；然而，为了演示另一种方法，让我们直接利用活动记录的`beforeSave`事件，并在一个通用的基类中进行这个操作，所有我们的AR模型类都可以扩展这个基类。这样，当构建自己的Yii应用程序时，你将有机会接触到几种不同的方法，并有更多的选择。
- en: 'So, we need to create a new base class for our AR model classes. We''ll also
    make this new class `abstract` since it should not be instantiated directly. First,
    go ahead and remove the `behaviors()` method from the `User` AR class, as we''ll
    put this in our base class. Then create a new file, `protected/models/TrackStarActiveRecord.php`,
    and add the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们需要为我们的AR模型类创建一个新的基类。我们还将使这个新类成为`abstract`，因为它不应该直接实例化。首先，去掉`User` AR类中的`behaviors()`方法，因为我们将把这个方法放在我们的基类中。然后创建一个新文件，`protected/models/TrackStarActiveRecord.php`，并添加以下代码：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, as discussed, we are overriding the `CActiveRecord::beforeSave()` method.
    This is one of the many events that `CActiveRecord` exposes to allow customization
    of its process workflow. There are two methods exposed that allow us to tap into
    the record saving workflow and perform any necessary logic either right before
    or right after the active record is saved: `beforeSave()` and `afterSave()`. In
    this case, we have decided to explicitly set our create and update user fields
    just prior to saving the active record, that is just before it is written to the
    database.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，正如讨论的那样，我们正在重写`CActiveRecord::beforeSave()`方法。这是`CActiveRecord`公开的许多事件之一，允许定制其流程工作流。有两种方法可以让我们进入记录保存工作流程，并在活动记录保存之前或之后执行任何必要的逻辑：`beforeSave()`和`afterSave()`。在这种情况下，我们决定在保存活动记录之前明确设置我们的创建和更新用户字段，即在写入数据库之前。
- en: We determine whether or not we are dealing with a new record (that is an insert)
    or an existing record (that is an update) by using the property `$this->isNewRecord`,
    and set our fields appropriately. We then make sure to invoke the parent implementation
    by returning `parent::beforeSave()` to ensure it has a chance to do everything
    it needs to do. We are performing a `NULL` check on `Yii::app()->user` to handle
    instances where we may be using this model class outside of a web application
    context, for example in a Yii console application (covered in a later chapter).
    If we don't have a valid user, we are simply defaulting to the first user, `id
    = 1`, which we could set up to be a super user.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用属性`$this->isNewRecord`来确定我们是在处理新记录（即插入）还是现有记录（即更新），并相应地设置我们的字段。然后，我们确保调用父实现，通过返回`parent::beforeSave()`来确保它有机会做所有需要做的事情。我们对`Yii::app()->user`进行了`NULL`检查，以处理可能在Web应用程序上下文之外使用这个模型类的情况，例如在Yii控制台应用程序中（在后面的章节中介绍）。如果我们没有有效的用户，我们只是默认使用第一个用户，`id
    = 1`，我们可以设置为超级用户。
- en: Also, as discussed, we have moved our `behaviors()` method to this base class
    so that all AR model classes that extend it will have this behavior attached.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，正如讨论的那样，我们已经将`behaviors()`方法移到了这个基类中，这样所有扩展它的AR模型类都将具有这个行为附加。
- en: 'To try this out, we now need to alter each of the three existing AR classes
    `Project.php`, `User.php`, and `Issue.php` to extend from our new abstract class
    rather than directly from `CActiveRecord`. So, for example, rather than the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试这个，我们现在需要修改现有的三个AR类`Project.php`，`User.php`和`Issue.php`，使其扩展自我们的新抽象类，而不是直接扩展自`CActiveRecord`。因此，例如，而不是以下内容：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to have:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要有：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We need to make similar changes for our other model classes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对我们的其他模型类进行类似的更改。
- en: Now if we add another new user, we should see all four of our audit history
    columns populated with timestamps and user IDs respectively.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们添加另一个新用户，我们应该看到我们的所有四个审计历史列都填充了时间戳和用户ID。
- en: 'With these changes now in place, we should remove these fields from each of
    the forms for creating new projects, issues, and users (we already removed them
    from the issues form in the previous chapter). The HTML for these form fields
    is in the `protected/views/project/_form.php`, `protected/views/issue/_form.php`,
    and `protected/views/user/_form.php` files. The lines we need to remove from each
    of these files are as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些更改已经就位，我们应该从创建新项目、问题和用户的每个表单中删除这些字段（我们已经在上一章中从问题表单中删除了它们）。这些表单字段的HTML位于`protected/views/project/_form.php`，`protected/views/issue/_form.php`和`protected/views/user/_form.php`文件中。我们需要从这些文件中删除的行如下所示：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And from the user creation form, `protected/views/user/_form.php`, we can also
    remove the last login time field:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 并且从用户创建表单`protected/views/user/_form.php`中，我们也可以删除最后登录时间字段：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since we are removing these from being form inputs, we should also remove the
    validation rules defined for these fields in the associated rules method. These
    validation rules are defined to ensure the data submitted by the user is valid
    and correctly formatted. Removing the rules also prevents them from being able
    to be a part of the bulk assignment of properties that occurs when we take all
    of the submitted querystring or post variables and assign their values to our
    AR model properties. For example, we see lines like the following in our create
    and update controller actions for AR models:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在从表单输入中删除这些字段，我们还应该删除相关规则方法中为这些字段定义的验证规则。这些验证规则旨在确保用户提交的数据有效且格式正确。删除规则还可以防止它们成为当我们获取所有提交的查询字符串或POST变量并将它们的值分配给我们的AR模型属性时的批量分配的一部分。例如，在AR模型的创建和更新控制器操作中，我们看到以下行：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is doing a mass assignment of all of the model attributes from the posted
    form fields. As an added security measure, this only works for attributes that
    have validation rules assigned for them. You can use the `CSafeValidator` as a
    way to mark model attributes that don't otherwise have any validation rules as
    being safe for this mass assignment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对从提交的表单字段中的所有模型属性进行批量分配。作为一项额外的安全措施，这仅适用于为其分配了验证规则的属性。您可以使用`CSafeValidator`来标记模型属性，以便将其作为这种批量分配的安全属性。
- en: Since these fields are not going to be filled in by the user, and we don't need
    them to be massively assigned, we can remove the rules.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些字段不会由用户填写，并且我们不需要它们被大规模分配，我们可以删除这些规则。
- en: 'Okay, so let''s remove them. Open up `protected/models/User.php` and in the
    `rules()` method, remove the following two rules:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们把它们删除。打开`protected/models/User.php`，在`rules()`方法中删除以下两条规则：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The project and issue AR classes have similar rules defined, but not identical.
    When removing those rules, be sure to leave in the rules that do still apply to
    the user input fields.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 项目和问题AR类定义了类似的规则，但并非完全相同。在删除这些规则时，请确保保留仍适用于用户输入字段的规则。
- en: The removal of the rule for the `last_login_time` attribute above was intentional.
    We should remove this from being exposed as a user input field as well. This field
    needs to be updated automatically upon a successful login. Since we had the view
    file open and were removing the other fields, we decided to remove this one now
    as well. However, we will wait to add the necessary application logic until after
    we make a few other changes and cover a few other topics.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上面删除`last_login_time`属性的规则是有意的。我们也应该将其从用户输入字段中删除。这个字段需要在成功登录后自动更新。由于我们已经打开了视图文件并删除了其他字段，我们决定现在也删除这个字段。但是，在我们进行其他一些更改并涵盖其他一些主题之后，我们将等待添加必要的应用程序逻辑。
- en: 'Actually, while we still have our hands in this validation rules method for
    the `User` class, we should make another change. We want to ensure that the e-mail
    as well as the username for every user is unique. We should validate this requirement
    when the form is submitted. Also, we should validate that the data submitted for
    the e-mail conforms to a standard e-mail format. You may recall from back in [Chapter
    4](ch04.html "Chapter 4. Project CRUD"), *Project CRUD* that we introduced Yii''s
    built-in validators, and two of these are perfect for our needs. We''ll use the
    `CEmailValidator` and `CUniqueValidator` classes to achieve our validation needs.
    We can quickly add these rules by adding the following two lines of code to this
    `rules()` method:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当我们还在`User`类的验证规则方法中时，我们应该做出另一个改变。我们希望确保每个用户的电子邮件和用户名都是唯一的。我们应该在提交表单时验证这一要求。此外，我们还应该验证提交的电子邮件数据是否符合标准的电子邮件格式。您可能还记得在[第4章](ch04.html
    "第4章。项目CRUD")中，我们介绍了Yii的内置验证器，其中有两个非常适合我们的需求。我们将使用`CEmailValidator`和`CUniqueValidator`类来满足我们的验证需求。我们可以通过在`rules()`方法中添加以下两行代码来快速添加这些规则：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The entire `User::rules()` method should now look like the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 整个`User::rules()`方法现在应该如下所示：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The *unique* declaration in the above rule is an alias that refers to Yii's
    built-in validator, `CUniqueValidator`. This validates the uniqueness of the model
    class attribute against the underlying database table. With the addition of this
    validation rule, we will receive an error when attempting to enter either an e-mail
    and/or username that already exists in the database. Also, with the addition of
    the e-mail validation, we will receive an error when the value in the e-mail form
    field is not of a correct e-mail format.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上面规则中的*unique*声明是一个别名，指的是Yii的内置验证器`CUniqueValidator`。这验证了模型类属性在底层数据库表中的唯一性。通过添加这个验证规则，当尝试输入已经存在于数据库中的电子邮件和/或用户名时，我们将收到一个错误。此外，通过添加电子邮件验证，当电子邮件表单字段中的值不是正确的电子邮件格式时，我们将收到一个错误。
- en: 'When we first created our `tbl_user` table in the previous chapter, we added
    two test users so we would have some data to play with. The first of these two
    users has an e-mail address of `test1@notanaddress.com`. Try to add another user
    using this same e-mail. The following screenshot shows the error message received
    and the highlighting of the field in error after such an attempt:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中创建`tbl_user`表时，我们添加了两个测试用户，以便我们有一些数据可以使用。这两个用户中的第一个用户的电子邮件地址是`test1@notanaddress.com`。尝试使用相同的电子邮件添加另一个用户。以下截图显示了尝试后收到的错误消息以及错误字段的高亮显示：
- en: '![Component behavior](graphics/8727_06_02.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![组件行为](graphics/8727_06_02.jpg)'
- en: Submitting a value that is not in a valid e-mail format will also produce an
    error message.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 提交一个不符合有效电子邮件格式的值也会产生错误消息。
- en: Adding a password confirmation field
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加密码确认字段
- en: In addition to the changes we just made, we should add a new field to force
    the user to confirm the password they entered. This is a standard practice on
    user registration forms and helps the user not to make a mistake when entering
    this important piece of information. Fortunately, Yii comes with another built-in
    validator, `CCompareValidator`, which does exactly what you think it might do.
    It compares the values of two attributes, and returns an error if they are not
    equal.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了刚刚做的更改之外，我们还应该添加一个新字段，强制用户确认他们输入的密码。这是用户注册表单上的标准做法，有助于用户在输入这一重要信息时不出错。幸运的是，Yii还带有另一个内置的验证器`CCompareValidator`，它正是你所想的那样。它比较两个属性的值，如果它们不相等，则返回错误。
- en: 'In order to take advantage of this built-in validation, we need to add a new
    attribute to our model class. Add the following attribute to the top of the `User`
    model AR class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这个内置的验证，我们需要在我们的模型类中添加一个新的属性。在`User`模型AR类的顶部添加以下属性：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We named this attribute by appending `_repeat` to the name of the attribute
    we want to compare against. The compare validator will allow you to specify any
    two attributes to compare, or compare an attribute to a constant value. If no
    comparison attribute or value is specified when declaring the compare rule, it
    will default to looking for an attribute beginning with the same name as the one
    being compared, with the addition of `_repeat` appended to the end. This is why
    we named the attribute in this manner. Now we can add a simple validation rule
    to the `User::rules()` method as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在要比较的属性名称后附加`_repeat`来命名此属性。比较验证器允许您指定任意两个属性进行比较，或将属性与常量值进行比较。如果在声明比较规则时未指定比较属性或值，它将默认查找以与要比较的属性相同的名称开头的属性，并在末尾附加`_repeat`。这就是我们以这种方式命名属性的原因。现在我们可以在`User::rules()`方法中添加一个简单的验证规则，如下所示：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If not using the `_repeat` convention, you would need to specify the attribute
    with which you want the comparison performed. For example, if we wanted to compare
    the `$password` attribute to an attribute named `$confirmPassword`, we could use:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用`_repeat`约定，您需要指定要执行比较的属性。例如，如果我们想要将`$password`属性与名为`$confirmPassword`的属性进行比较，我们可以使用：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since we have explicitly added the `$password_repeat` attribute to the user
    AR class, and there is no validation rule defined for it, we need to also tell
    the model class to allow this field to be set in a bulk manner when the `setAttributes()`
    method is called. As previously mentioned, we do this by explicitly adding our
    new attribute to the *safe* attributes list for our `User` model class. To do
    this, add the following to the `User::rules()` array:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经明确将`$password_repeat`属性添加到用户AR类中，并且没有为其定义验证规则，因此当调用`setAttributes()`方法时，我们还需要告诉模型类允许以批量方式设置此字段。如前所述，我们通过将新属性明确添加到`User`模型类的*safe*属性列表中来实现这一点。要做到这一点，请将以下内容添加到`User::rules()`数组中：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s make one more change to our validation rules. All of the fields we currently
    have on the user form should be required. Currently, our required rule is only
    being applied to the `email` field. While we are making changes to this `User::rules()`
    method, let''s add username and password to this list as well:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对验证规则做出一次更改。我们当前在用户表单上拥有的所有字段都应该是必填的。目前，我们的必填规则只适用于`email`字段。在我们对`User::rules()`方法进行更改时，让我们也将用户名和密码添加到此列表中：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on validation rules, see: [http://www.yiiframework.com/doc/guide/1.1/en/form.model#declaring-validation-rules](http://www.yiiframework.com/doc/guide/1.1/en/form.model#declaring-validation-rules)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有关验证规则的更多信息，请参见：[http://www.yiiframework.com/doc/guide/1.1/en/form.model#declaring-validation-rules](http://www.yiiframework.com/doc/guide/1.1/en/form.model#declaring-validation-rules)
- en: Okay, now all of our rules are set. However, we still need to add the password
    confirmation field to the form. Let's do that now.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们所有的规则都已设置。但是，我们仍然需要向表单添加密码确认字段。现在让我们来做这件事。
- en: 'To add this field, open up `protected/views/user/_form.php`, and add the following
    code block below the password field:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加此字段，请打开`protected/views/user/_form.php`，并在密码字段下方添加以下代码块：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With all of these form changes in place, the **Create User** form should look
    as depicted in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些表单更改就位后，**创建用户**表单应如下截图所示：
- en: '![Adding a password confirmation field](graphics/8727_06_03.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![添加密码确认字段](graphics/8727_06_03.jpg)'
- en: 'And now, if we attempt to submit the form with different values in the **Password**
    and **Password Repeat** fields, we will be met with an error as shown in the following
    screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试使用**密码**和**密码重复**字段中的不同值提交表单，我们将会收到如下截图所示的错误：
- en: '![Adding a password confirmation field](graphics/8727_06_04.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![添加密码确认字段](graphics/8727_06_04.jpg)'
- en: Hash the password
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对密码进行哈希处理
- en: One last change we should make before we leave the new user creation process
    is to create a hashed version of the user's password before we store it in our
    database. It is a very common practice to apply a one-way hashing algorithm on
    sensitive user information before adding it to persistent storage.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开新用户创建过程之前，我们应该做的最后一个更改是在将用户的密码存储到数据库之前创建其哈希版本。在将敏感用户信息添加到持久存储之前应用单向哈希算法是一种非常常见的做法。
- en: We will add this logic to the `User.php` AR class by taking advantage of another
    method of `CActiveRecord` that allows us to customize the default active record
    workflow. This time we'll override the `afterValidate()` method and apply a basic
    one-way hash to the password after we validate all the input fields, but before
    we save the record.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用`CActiveRecord`的另一种方法来将此逻辑添加到`User.php` AR类中，该方法允许我们自定义默认的活动记录工作流程。这次我们将重写`afterValidate()`方法，并在验证所有输入字段但在保存记录之前对密码应用基本的单向哈希。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Similar to our use of the `CActiveRecord::beforeSave()` method when setting
    our create and update timestamps, here we are overriding the `CActiveRecord::beforeValidate()`
    method. This is one of the many events that `CActiveRecord` exposes to allow customization
    of its process workflow. As a quick reminder, if you do not explicitly send `false`
    as a parameter when calling the `save()` method on an AR class, the validation
    process will be triggered. This process performs the validations as specified
    in the `rules()` method within the AR class. There are two methods exposed that
    allow us to tap into the validation workflow and perform any necessary logic either
    right before or right after the validation is performed, that is, `beforeValidate()`
    and `afterValidate()`. In this case, we have decided to hash the password just
    after performing the validation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在设置创建和更新时间戳时使用`CActiveRecord::beforeSave()`方法类似，这里我们正在重写`CActiveRecord::beforeValidate()`方法。这是`CActiveRecord`公开的许多事件之一，允许自定义其流程工作流程。快速提醒一下，如果在调用AR类的`save()`方法时没有显式发送`false`作为参数，验证过程将被触发。该过程执行AR类中`rules()`方法中指定的验证。有两种公开的方法允许我们进入验证工作流程并在验证执行之前或之后执行任何必要的逻辑，即`beforeValidate()`和`afterValidate()`。在这种情况下，我们决定在执行验证后立即对密码进行哈希处理。
- en: 'Open up the `User` AR class and add the following to the bottom of the class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`User` AR类，并在类底部添加以下内容：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We mentioned this in the previous chapter, but it is worth mentioning again.
    We are using the one-way MD5 hashing algorithm here because of its ease of use
    and that it is widely available on 5.x Versions of MySQL and PHP. However, it
    is now known that MD5 is "broken" as a one-way hashing algorithm with regard to
    security and it is not suggested that you use this hashing algorithm in a production
    environment. Please consider using Bcrypt for your real, production applications.
    The following are some URLs providing more information on Bcrypt:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中提到过这一点，但值得再次提及。我们在这里使用单向MD5哈希算法是因为它易于使用，并且在MySQL和PHP的5.x版本中广泛可用。然而，现在已经知道MD5在安全方面作为单向哈希算法是“破解”的，因此不建议在生产环境中使用此哈希算法。请考虑在真正的生产应用程序中使用Bcrypt。以下是一些提供有关Bcrypt更多信息的网址：
- en: '[http://en.wikipedia.org/wiki/Bcrypt](http://en.wikipedia.org/wiki/Bcrypt)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/Bcrypt](http://en.wikipedia.org/wiki/Bcrypt)'
- en: '[http://php.net/manual/en/function.crypt.php](http://php.net/manual/en/function.crypt.php)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://php.net/manual/en/function.crypt.php](http://php.net/manual/en/function.crypt.php)'
- en: '[http://www.openwall.com/phpass/](http://www.openwall.com/phpass/)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.openwall.com/phpass/](http://www.openwall.com/phpass/)'
- en: With this in place, it will hash the password just after all of the other attribute
    validations have successfully passed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，它将在所有其他属性验证成功通过之后对密码进行哈希处理。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This approach works fine for brand new records, but for updates, if the user
    is not updating his/her password information, it runs the risk of hashing an already
    hashed value. We could handle this in a number of ways, but to keep things simple
    for now, we will need to ensure we ask the user to supply a valid password every
    time they desire to update their user data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于全新的记录来说效果很好，但是对于更新来说，如果用户没有更新他/她的密码信息，就有可能对已经进行过哈希处理的值再次进行哈希处理。我们可以用多种方式来处理这个问题，但是为了简单起见，我们需要确保每次用户想要更新他们的用户数据时，我们都要求他们提供有效的密码。
- en: We now have the ability to add new users to our application. Since we initially
    created this form using the Gii tool's **Crud Generator** link, we also have read,
    update, and delete functionality for users. Try it out by adding some new users,
    viewing a list of them, update some of the information, and then delete a few
    of the entries to ensure everything is working as expected. (Remember that you
    will need to be logged in as `admin`, as opposed to `demo`, in order to perform
    the deletes.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有能力向我们的应用程序添加新用户。由于我们最初使用Gii工具的**Crud Generator**链接创建了这个表单，我们还为用户拥有了读取、更新和删除功能。通过添加一些新用户，查看他们的列表，更新一些信息，然后删除一些条目来测试一下，确保一切都按预期工作。（请记住，您需要以`admin`身份登录，而不是`demo`，才能执行删除操作。）
- en: Authenticating users using the database
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库对用户进行认证
- en: As we know, a basic login form and user authentication process was created for
    us simply by using the `yiic` command to create our new application. This authentication
    scheme is very simple. It interrogates the input form's username/password values,
    and if they are either `demo/demo` or `admin/admin`, it passes, otherwise it fails.
    This is obviously not intended to be a permanent solution, but rather a foundation
    on which to build. We are going to build upon this by altering the authentication
    process to use our `tbl_user` database table that we already have as part of our
    model. But before we start changing the default implementation, let's take a closer
    look at how Yii implements an authentication model.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，通过使用`yiic`命令创建我们的新应用程序，为我们创建了一个基本的登录表单和用户认证过程。这种认证方案非常简单。它会检查输入表单的用户名/密码值，如果它们是`demo/demo`或`admin/admin`，就会通过，否则就会失败。显然，这并不是一个永久的解决方案，而是一个构建的基础。我们将通过改变认证过程来使用我们已经作为模型的一部分拥有的`tbl_user`数据库表来构建。但在我们开始改变默认实现之前，让我们更仔细地看一下Yii是如何实现认证模型的。
- en: Introducing the Yii authentication model
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Yii认证模型
- en: 'Central to the Yii authentication framework is an application component called
    **user**, which, in the most general case, is an object implementing the `IWebUser`
    interface. The specific class used by our default implementation is the framework
    class, `CWebUser`. This user component encapsulates all the identity information
    for the current user of the application. This component was configured for us
    as part of the autogenerated application code when we initially created our application
    using the `yiic` tool. The configuration can be seen in the `protected/config/main.php`
    file, under the `components` array element:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Yii认证框架的核心是一个名为**user**的应用组件，通常情况下，它是一个实现了`IWebUser`接口的对象。我们默认实现所使用的具体类是框架类`CWebUser`。这个用户组件封装了应用程序当前用户的所有身份信息。这个组件在我们使用`yiic`工具创建应用程序时，作为自动生成的应用程序代码的一部分为我们配置好了。配置可以在`protected/config/main.php`文件的`components`数组元素下看到：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since it is configured as an application component, with the name `'user'`,
    we can access it at any place throughout our application using `Yii::app()->user`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它被配置为一个应用程序组件，名称为`'user'`，我们可以在整个应用程序中的任何地方使用`Yii::app()->user`来访问它。
- en: We also notice that the class property, `allowAutoLogin`, is being set here
    as well. This property is `false` by default, but setting it to `true` enables
    user information to be stored in persistent browser cookies. This data is then
    used to automatically authenticate the user upon subsequent visits. This is what
    will allow us to have a **Remember Me** checkbox on the login form so that, if
    the user chooses, they can be automatically logged into the application upon subsequent
    visits to the site.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到类属性`allowAutoLogin`也在这里设置了。这个属性默认值为`false`，但将其设置为`true`可以使用户信息存储在持久性浏览器cookie中。然后这些数据将用于在后续访问时自动对用户进行身份验证。这将允许我们在登录表单上有一个**记住我**复选框，这样用户可以选择的话，在后续访问网站时可以自动登录应用程序。
- en: The Yii authentication framework defines a separate entity to house the actual
    authentication logic. This is called an **identity class**, and in general can
    be any class that implements the `IUserIdentity` interface. One of the primary
    roles of this class is to encapsulate the authentication logic to easily allow
    for different implementations. Depending on the application requirements, we may
    need to validate a username and password against values stored in a database,
    or allow users to log in with their OpenID credentials, or integrate with an existing
    LDAP approach. Separating the logic that is specific to the authentication approach
    from the rest of the application login process allows us to easily switch between
    such implementations. The identity class provides this separation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Yii认证框架定义了一个单独的实体来容纳实际的认证逻辑。这被称为**身份类**，通常可以是任何实现了`IUserIdentity`接口的类。这个类的主要作用之一是封装认证逻辑，以便轻松地允许不同的实现。根据应用程序的要求，我们可能需要验证用户名和密码与存储在数据库中的值匹配，或者允许用户使用他们的OpenID凭据登录，或者集成现有的LDAP方法。将特定于认证方法的逻辑与应用程序登录过程的其余部分分离，使我们能够轻松地在这些实现之间切换。身份类提供了这种分离。
- en: 'When we initially created our application, a user identity class file, namely
    `protected/components/UserIdentity.php`, was generated for us. It extends the
    Yii framework class, `CUserIdentity`, which is a base class for authentication
    implementations that uses a username and password. Let''s take a closer look at
    the code that was generated for this class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最初创建应用程序时，一个用户身份类文件，即 `protected/components/UserIdentity.php`，是为我们生成的。它扩展了
    Yii 框架类 `CUserIdentity`，这是一个使用用户名和密码的身份验证实现的基类。让我们更仔细地看一下为这个类生成的代码：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The bulk of the work in defining an identity class is the implementation of
    the `authenticate()` method. This is where we place the code that is specific
    to the authentication approach. This implementation simply uses the hardcoded
    username/password values of `demo/demo` and `admin/admin`. It checks these values
    against the username and password class properties (properties defined in the
    parent class, `CUserIdentity`) and if they don't match, it will set and return
    an appropriate error code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 定义身份类的大部分工作是实现 `authenticate()` 方法。这是我们放置特定于身份验证方法的代码的地方。这个实现简单地使用硬编码的用户名/密码值
    `demo/demo` 和 `admin/admin`。它检查这些值是否与用户名和密码类属性（在父类 `CUserIdentity` 中定义的属性）匹配，如果不匹配，它将设置并返回适当的错误代码。
- en: In order to better understand how these pieces fit into the entire end-to-end
    authentication process, let's walk through the logic starting with the login form.
    If we navigate to the login page, `http://localhost/trackstar/index.php?r=site/login`,
    we see a simple form allowing the input of a username, a password, and an optional
    checkbox for the **Remember Me Next Time** functionality that we discussed before.
    Submitting this form invokes the logic contained in the `SiteController::actionLogin()`
    method. The following sequence diagram depicts the class interaction that occurs
    during a successful login from the time the form is submitted.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些部分如何适应整个端到端的身份验证过程，让我们从登录表单开始逐步解释逻辑。如果我们导航到登录页面，`http://localhost/trackstar/index.php?r=site/login`，我们会看到一个简单的表单，允许输入用户名、密码，以及我们之前讨论过的**记住我下次**功能的可选复选框。提交这个表单会调用
    `SiteController::actionLogin()` 方法中包含的逻辑。以下序列图描述了在成功登录时从提交表单开始发生的类交互。
- en: '![Introducing the Yii authentication model](graphics/8727_06_05.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![引入 Yii 身份验证模型](graphics/8727_06_05.jpg)'
- en: 'The process starts with setting the class attributes on the form model class,
    `LoginForm`, to the form values submitted. The `LoginForm->validate()` method
    is then called, which validates these attribute values based on the rules defined
    in the `rules()` method. This method is defined as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程从将表单模型类 `LoginForm` 上的类属性设置为提交的表单值开始。然后调用 `LoginForm->validate()` 方法，根据
    `rules()` 方法中定义的规则验证这些属性值。这个方法定义如下：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The last of these rules stipulates that the password attribute be validated
    using the custom method `authenticate()`, which is also defined in the `LoginForm`
    class as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个规则规定，密码属性要使用自定义方法 `authenticate()` 进行验证，这个方法也在 `LoginForm` 类中定义如下：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Continuing to follow the sequence diagram, the password validation within `LoginForm`
    calls the `authenticate()` method within the same class. This method creates a
    new instance of the authentication identity class being used, in this case it
    is `/protected/components/UserIdentity.php`, and then calls its `authenticate()`
    method. This method, `UserIdentity::authenticate()` is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 继续按照序列图的顺序，`LoginForm` 中的密码验证调用了同一类中的 `authenticate()` 方法。该方法创建了一个正在使用的身份验证身份类的新实例，本例中是
    `/protected/components/UserIdentity.php`，然后调用它的 `authenticate()` 方法。这个方法，`UserIdentity::authenticate()`
    如下：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is implemented to use the username and password to perform its authentication.
    In this implementation, as long as the username/password combination is either
    `demo/demo` or `admin/admin`, this method will return `true`. Since we are walking
    through a successful log in, the authentication succeeds and then the `SiteController`
    calls the `LoginForm::login()` method, which looks as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了使用用户名和密码进行身份验证。在这个实现中，只要用户名/密码组合是 `demo/demo` 或 `admin/admin`，这个方法就会返回 `true`。由于我们正在进行成功的登录，身份验证成功，然后
    `SiteController` 调用 `LoginForm::login()` 方法，如下所示：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And we can see that this in turn calls `Yii::app()->user->login` (that is `CWebUser::login()`),
    passing in the `CUserIdentity` class instance as well as a duration to which to
    set the cookie for autologin.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这反过来调用了 `Yii::app()->user->login`（即 `CWebUser::login()`），传入 `CUserIdentity`
    类实例以及要设置自动登录的 cookie 的持续时间。
- en: By default, the web application is configured to use the Yii framework class,
    `CWebuser` as the user application component. Its `login()` method takes in an
    identity class and an optional duration parameter used to set the time to live
    on the browser cookie. In the previous code, we see that this is set to `30 days`
    if the **Remember Me** checkbox was checked when the form was submitted. If you
    do not pass in a duration, it is set to zero. A value of zero will result in no
    cookie being created at all.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Web 应用程序配置为使用 Yii 框架类 `CWebuser` 作为用户应用组件。它的 `login()` 方法接受一个身份类和一个可选的持续时间参数，用于设置浏览器
    cookie 的生存时间。在前面的代码中，我们看到如果在提交表单时选中了**记住我**复选框，这个时间被设置为 `30 天`。如果你不传入一个持续时间，它会被设置为零。零值将导致根本不创建任何
    cookie。
- en: The `CWebUser::login()` method takes the information contained in the identity
    class and saves it in persistent storage for the duration of the user session.
    By default, this storage is the PHP session storage.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`CWebUser::login()` 方法获取身份类中包含的信息，并将其保存在持久存储中，以供用户会话期间使用。默认情况下，这个存储是 PHP 会话存储。'
- en: After all of this is completed, the `login()` method on `LoginForm` that was
    initially called by our controller class returns `true`, which indicates a successful
    log in. The controller class then redirects to the URL value in `Yii::app()->user->returnUrl`.
    You can set this on certain pages throughout the application if you want to ensure
    that the user be redirected back to their previous page, that is wherever they
    were in the application before they decided (or were forced) to log in. This value
    defaults to the application entry URL.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，由我们的控制器类最初调用的`LoginForm`上的`login()`方法返回`true`，表示成功登录。然后，控制器类将重定向到`Yii::app()->user->returnUrl`中的URL值。如果您希望确保用户被重定向回其先前的页面，即在他们决定（或被迫）登录之前在应用程序中的任何位置，可以在应用程序的某些页面上设置此值。此值默认为应用程序入口URL。
- en: Changing the authenticate implementation
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改身份验证实现
- en: 'Now that we understand the entire authentication process, we can easily see
    where we need to make the change to use our `tbl_user` table to validate the username
    and password credentials submitted via the login form. We can simply alter the
    `authenticate()` method in the user identity class to verify the existence of
    a matching row with the supplied username and password values. Since, at the moment,
    there is nothing else in our `UserIdentity.php` class except the authenticate
    method, let''s completely replace the contents of this file with the following
    code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了整个身份验证过程，我们可以很容易地看到我们需要在哪里进行更改，以使用我们的`tbl_user`表来验证通过登录表单提交的用户名和密码凭据。我们可以简单地修改用户身份类中的`authenticate()`方法，以验证是否存在与提供的用户名和密码值匹配的行。由于目前在我们的`UserIdentity.php`类中除了authenticate方法之外没有其他内容，让我们完全用以下代码替换此文件的内容：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And since we are going to have our `User` model class do the actual password
    validation, we also need to add the following method to our `User` model class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，由于我们将让我们的`User`模型类执行实际的密码验证，我们还需要向我们的`User`模型类添加以下方法：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There are a few things going on with this new code that should be pointed out.
    First, it is now attempting to retrieve a row from the `tbl_user` table, by way
    of creating a new `User` model AR class instance, where the username is the same
    as the `UserIdentity` class's attribute value (remember that this is set to be
    the value from the login form). Since we enforced the uniqueness of the username
    when creating a new user, this should find at most one matching row. If it does
    not find a matching row, an error message is set to indicate the username is incorrect.
    If a matching row is found, it compares the passwords by calling our new `User::validatePassword()`
    method. If the password fails the validation, it sets an error message to indicate
    an incorrect password.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新代码有一些需要指出的地方。首先，它现在尝试通过创建一个新的`User`模型AR类实例来从`tbl_user`表中检索一行，其中用户名与`UserIdentity`类的属性值相同（请记住，这是设置为登录表单的值）。由于在创建新用户时我们强制用户名的唯一性，这应该最多找到一个匹配的行。如果找不到匹配的行，将设置错误消息以指示用户名不正确。如果找到匹配的行，它通过调用我们的新`User::validatePassword()`方法来比较密码。如果密码未通过验证，将设置错误消息以指示密码不正确。
- en: If the authentication is successful, a couple of other things happen before
    the method returns. First, we have set a new attribute on the `UserIdentity` class
    for the user ID. The default implementation in the parent class is to return the
    username for the ID. Since we are using a database, and have a numeric primary
    key as our unique user identifier, we want to make sure this is what is set and
    returned throughout the application when the user ID is requested. For example,
    when the code `Yii::app()->user->id` is executed, we want to make sure that the
    unique ID from the database is returned, not the username.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果身份验证成功，在方法返回之前还会发生一些其他事情。首先，我们在`UserIdentity`类上设置了一个新的属性，用于用户ID。父类中的默认实现是返回ID的用户名。由于我们使用数据库，并且将数字主键作为我们唯一的用户标识符，我们希望确保在请求用户ID时设置和返回此值。例如，当执行代码`Yii::app()->user->id`时，我们希望确保从数据库返回唯一ID，而不是用户名。
- en: Extending user attributes
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展用户属性
- en: 'The second thing happening here is the setting of an attribute on the user
    identity to be the last login time returned from the database, and then also updating
    the `last_login_time` field in the database to be the current time. The specific
    code from the previous snippet doing this is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的第二件事是在用户身份上设置一个属性，该属性是从数据库返回的最后登录时间，然后还更新数据库中的`last_login_time`字段为当前时间。执行此操作的特定代码如下：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The user application component, `CWebUser`, derives its user attributes from
    the explicit ID and name attributes defined in the identity class, and then from
    `name=>value` pairs set in an array called the `identity states`. These are the
    extra user values that can be persisted throughout a user''s session. As an example
    of this, we are setting the attribute named `lastLogin` to be the value of the
    `last_login_time` field in the database. This way, at any place throughout the
    application, this attribute can be accessed via:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应用组件`CWebUser`从身份类中定义的显式ID和名称属性派生其用户属性，然后从称为`identity states`的数组中设置的`name=>value`对中派生。这些是可以在用户会话期间持久存在的额外用户值。作为这一点的例子，我们将名为`lastLogin`的属性设置为数据库中`last_login_time`字段的值。这样，在应用程序的任何地方，都可以通过以下方式访问此属性：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The reason we take a different approach when storing the last login time versus
    the ID is that *ID* just happens to be an explicitly defined property on the `CUserIdentity`
    class. So, other than *name* and *ID*, all other user attributes that need to
    be persisted throughout the session can be set in a similar manner.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在存储最后登录时间与ID时采取不同的方法的原因是*ID*恰好是`CUserIdentity`类上明确定义的属性。因此，除了*name*和*ID*之外，所有需要在会话期间持久存在的其他用户属性都可以以类似的方式设置。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When cookie-based authentication is enabled (by setting `CWebUser::allowAutoLogin`
    to be `true`), the persistent information will be stored in the cookie. Therefore,
    you should *not* store sensitive information (for example, your password) in the
    same manner as we have stored the user's last login time.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用基于cookie的身份验证（通过将`CWebUser::allowAutoLogin`设置为`true`）时，持久信息将存储在cookie中。因此，您*不应*以与我们存储用户最后登录时间相同的方式存储敏感信息（例如您的密码）。
- en: 'With these changes in place, you will now need to provide a correct username
    and password combination for a user defined in the `tbl_user` table in the database.
    Using `demo/demo` or `admin/admin` will, of course, no longer work. Give it a
    try. You should be able to login as any one of the users you created earlier in
    this chapter. If you followed along and have the same user data as we do, the
    credentials Username: `User One`, Password: `test1` should work.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些更改，现在您需要为数据库中`tbl_user`表中定义的用户提供正确的用户名和密码组合。当然，使用`demo/demo`或`admin/admin`将不再起作用。试一试。您应该能够以本章早些时候创建的任何一个用户的身份登录。如果您跟着做，并且拥有与我们相同的用户数据，那么用户名：`User
    One`，密码：`test1`应该可以登录。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Now that we have altered the login process to authenticate against the database,
    we won't be able to access the delete functionality for any of our project, issue,
    or user entities. The reason for this is that there are authorization checks in
    place to ensure that the user is an admin prior to allowing access. Currently,
    none of our database users have been configured to be authorized administrators.
    Don't worry, authorization is the focus of the next chapter, so we will be able
    to access that functionality again very soon.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修改了登录流程，以便对数据库进行身份验证，我们将无法访问项目、问题或用户实体的删除功能。原因是已经设置了授权检查，以确保用户是管理员才能访问。目前，我们的数据库用户都没有配置为授权管理员。不用担心，授权是下一章的重点，所以我们很快就能再次访问该功能。
- en: Displaying the last login time on the home page
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在主页上显示最后登录时间
- en: Now that we are updating the last login time in the database, and saving it
    to persistent session storage when logging in, let's go ahead and display this
    time on our welcome screen that a user will see after a successful log in. This
    will also help make us feel better that all of this is working as expected.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在更新数据库中的最后登录时间，并在登录时将其保存到持久会话存储中，让我们继续在成功登录后的欢迎屏幕上显示这个时间。这也将帮助我们确信一切都按预期工作。
- en: 'Open up the default view file that is responsible for displaying our home page
    `protected/views/site/index.php`. Add the following highlighted lines of code
    just below the welcome statement:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 打开负责显示主页的默认视图文件`protected/views/site/index.php`。在欢迎语句下面添加以下突出显示的代码行：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And since we are in there, let''s go ahead and remove all of the other autogenerated
    help text, which is everything else below the lines we just added. Once you save
    and log in again, you should see something similar to the following screenshot,
    which displays the welcome message followed by a formatted time indicating your
    last successful log in:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经在这里，让我们继续删除所有其他自动生成的帮助文本，即我们刚刚添加的代码行下面的所有内容。保存并再次登录后，您应该看到类似以下截图的内容，显示欢迎消息，然后是格式化的时间，指示您上次成功登录的时间：
- en: '![Displaying the last login time on the home page](graphics/8727_06_06.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: 在主页上显示最后登录时间
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was the first of two where we focus on user management, authentication,
    and authorization. We created the ability to manage CRUD operations for application
    users, making many adjustments to the new user creation process along the way.
    We added a new base class for all of our active record classes so that we can
    easily manage our audit history table columns that are present on all of our tables.
    We also updated our code to properly manage the user's last login time that we
    are storing in the database. In doing so, we learned about tapping into the `CActiveRecord`
    validation workflow to allow for prevalidation/postvalidation and presaving/postsaving
    processing.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是我们专注于用户管理、身份验证和授权的两章中的第一章。我们创建了管理应用程序用户的CRUD操作的能力，并在此过程中对新用户创建流程进行了许多调整。我们为所有活动记录类添加了一个新的基类，以便轻松管理存在于所有表上的审计历史表列。我们还更新了代码，以正确管理我们在数据库中存储的用户最后登录时间。在这样做的过程中，我们学习了如何利用`CActiveRecord`验证工作流来允许预验证/后验证和预保存/后保存处理。
- en: We then focused on understanding the Yii authentication model in order to enhance
    it to meet our application requirements so that the user credentials are validated
    against the values stored in the database.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们专注于理解Yii身份验证模型，以便增强它以满足我们应用程序的要求，以便用户凭据被验证为存储在数据库中的值。
- en: Now that we have covered authentication, we can turn our focus to the second
    part of Yii's auth-and-auth framework, *authorization*. This is the focus of the
    next chapter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了身份验证，我们可以将重点转向Yii身份验证和授权框架的第二部分，*授权*。这是下一章的重点。
