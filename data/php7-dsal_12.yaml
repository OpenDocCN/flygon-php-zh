- en: PHP Built-In Support for Data Structures and Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP内置对数据结构和算法的支持
- en: PHP is a language with an enriched library of predefined functions, along with
    super support from the community. Whether it is an algorithm or data structure,
    PHP already has solid built-in support for developers. In this chapter, we will
    explore some of the built-in functions and features that we can use in our data
    structure and algorithm implementations. Let's now explore those features in PHP.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PHP是一种具有丰富预定义函数库的语言，同时也得到了社区的大力支持。无论是算法还是数据结构，PHP已经为开发人员提供了坚实的内置支持。在本章中，我们将探讨一些内置函数和功能，我们可以在数据结构和算法实现中使用。现在让我们在PHP中探索这些功能。
- en: Built-in PHP features for data structure
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP内置数据结构的功能
- en: PHP has a rich collection of built-in data structures in Standard PHP Library
    SPL. After the release of PHP 7, it is believed that SPL data structure implementation
    is not very "performant" as compared to the old PHP version. So, we will discuss
    a new PECL extension just designed for data structures. We also have a very strong
    support for PHP array, which can be used as a set, vector, map, hash table, stack,
    queue, collection, dictionary, and so on. SPL is fairly new compared to the array
    and still managed to capture the limelight with the diverse implementation of
    core data structures as a built-in feature. Since PHP 5.0, SPL is shipped with
    core PHP so that no extra extension or build is required. We have already explored
    the dynamic nature of PHP array in [Chapter 2](text00045.html) , *Understanding
    PHP Arrays* . In this chapter, we will name few of the other useful functions
    available to PHP to operate on data structures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: PHP在标准PHP库SPL中拥有丰富的内置数据结构。在发布PHP 7之后，人们认为SPL数据结构的实现与旧版PHP相比并不是非常“高效”。因此，我们将讨论一个专门设计用于数据结构的新PECL扩展。我们还对PHP数组有很强的支持，可以用作集合、向量、映射、哈希表、堆栈、队列、集合、字典等等。与数组相比，SPL相对较新，但仍然以内置功能的多样实现夺得了风头。自PHP
    5.0以来，SPL已经与核心PHP一起发布，因此不需要额外的扩展或构建。我们已经在[第2章](text00045.html)中探讨了PHP数组的动态特性，*理解PHP数组*。在本章中，我们将列举一些其他可用于PHP操作数据结构的有用函数。
- en: Using PHP array
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP数组
- en: 'PHP array has a wider set of predefined functions that make PHP array one of
    the most used features of PHP. We will not discuss all the available PHP array
    functions. We will discuss few of the functions that can be very useful for us
    in our data structure operations. Here are the PHP array functions:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: PHP数组具有更广泛的预定义函数集，使PHP数组成为PHP最常用的功能之一。我们不会讨论所有可用的PHP数组函数。我们将讨论一些对我们在数据结构操作中非常有用的函数。以下是PHP数组函数：
- en: '**array_pop** : This pops the last element of the array similar to stack pop
    operation. The array is passed as reference to the function. It only takes one
    argument, that is, the name of the array.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: array_pop：这将弹出数组的最后一个元素，类似于堆栈弹出操作。数组作为引用传递给函数。它只接受一个参数，即数组的名称。
- en: '**array_push** : This pushes one or more elements at the end of the array,
    just like a stack push operation. We have seen that we can push one element at
    a time using push. In PHP array, we can push multiple values at the end of the
    current array. The array is passed as a reference in the function as shown:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: array_push：这将一个或多个元素推送到数组的末尾，就像堆栈推送操作一样。我们已经看到我们可以使用push一次推送一个元素。在PHP数组中，我们可以将多个值推送到当前数组的末尾。数组作为引用传递给函数，如下所示：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**current** : Each array has an internal pointer to identify where it is at
    the moment. Initially, it starts from the first element of the array. The current
    function returns the current pointer of the array and returns the value of the
    element in the current position. If we consider the array to be a list, these
    internal pointer functionalities will be required.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: current：每个数组都有一个内部指针来标识它当前所在的位置。最初，它从数组的第一个元素开始。current函数返回数组的当前指针，并返回当前位置的元素的值。如果我们将数组视为列表，这些内部指针功能将是必需的。
- en: '**prev** : The `prev` function moves the internal pointer one step backward.
    The PHP array can work as a doubly linked list, and `prev` is used to go the previous
    pointer.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: prev：`prev`函数将内部指针向后移动一步。PHP数组可以作为双向链表工作，`prev`用于转到前一个指针。
- en: '**next** : The `next` function moves the internal pointer to the next element.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: next：`next`函数将内部指针移动到下一个元素。
- en: '**end** : The `end` function moves the internal array pointer to the end of
    the array.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: end：`end`函数将内部数组指针移动到数组的末尾。
- en: '**reset** : The `reset` function moves the internal array to the beginning
    of the array.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: reset：`reset`函数将内部数组移动到数组的开头。
- en: '**array_search** : This is a very useful function for searching an element
    in the array. If the element is found in the array, it returns the corresponding
    index where it was found. If nothing is found, it will return false. If multiple
    elements are there with the same search key, it will return the first occurrence
    index. We have to be careful as this function might also return 0 if the element
    is found in the first index. So, we have to check the boolean false with strict
    type checking during comparison. The `array_search` function takes two mandatory
    arguments, needle, and haystack. Needle is the element we are looking for, and
    haystack is the array where we are looking for the element. For example, if we
    are looking for a word in a dictionary, then we can consider the search word such
    as "needle" and "dictionary" as the haystack. There is an optional third parameter
    that enables strict type checking for the element. So, if it is set true, it searches
    the element not only by value, but also by type:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: array_search：这是一个非常有用的函数，用于在数组中搜索元素。如果在数组中找到元素，则返回找到它的相应索引。如果找不到任何内容，它将返回false。如果有多个具有相同搜索键的元素，则返回第一个出现的索引。我们必须小心，因为此函数在比较过程中也可能返回0，如果元素在第一个索引中找到。因此，在比较过程中，我们必须使用严格的类型检查来检查布尔值false。`array_search`函数接受两个必需的参数，needle和haystack。needle是我们要查找的元素，haystack是我们要查找元素的数组。例如，如果我们在字典中查找一个单词，那么我们可以将搜索词视为"needle"，"dictionary"视为haystack。还有一个可选的第三个参数，它可以为元素启用严格的类型检查。因此，如果设置为true，则它不仅按值搜索元素，还按类型搜索：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will produce the following output:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we had != inside the `if` condition check, then it would have shown `Not
    found` in the result.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`if`条件检查中使用!=，那么结果将显示`Not found`。
- en: '**array_sum** : This is another handy PHP built-in function to get the sum
    of a given array. It will return a single numeric value, which is the sum of all
    elements in the array. It can be an integer or float.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: array_sum：这是另一个方便的PHP内置函数，用于获取给定数组的总和。它将返回一个单个的数值，即数组中所有元素的总和。它可以是整数或浮点数。
- en: '**array_map** : This is a very useful function if we want to change the elements
    of the array with a certain type of properties. For example, we want to make all
    text of the array to be in upper case or lower case. Instead of running a loop,
    we can use this function to do that. The `array_map` function takes two arguments.
    The first one is the callable function, and the second one is the array itself.
    The function returns the modified array, as shown here:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: array_map：如果我们想要改变数组的元素具有某种类型的属性，这是一个非常有用的函数。例如，我们想要将数组中的所有文本都变成大写或小写。我们可以使用这个函数来做到这一点，而不是运行一个循环。`array_map`函数接受两个参数。第一个是可调用的函数，第二个是数组本身。该函数返回修改后的数组，如下所示：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, we can write it simply like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以简单地这样写：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code applies an `array_map` function to capitalize each word
    in a given array. Both codes will produce the following output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码对给定数组中的每个单词应用了`array_map`函数。这两个代码将产生以下输出：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**array_rand** : If we need to pick one or more items randomly from a given
    array, this function can be very useful. The default value is 1 for the number
    of items to return, but we can always increase it.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: array_rand：如果我们需要从给定数组中随机选择一个或多个项目，这个函数非常有用。返回项目数量的默认值为1，但我们可以随时增加它。
- en: '**array_shift** : This function shifts an element from the beginning of the
    array, which is very much similar to our dequeue operation in a queue data structure.
    The removed element is returned from the function:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: array_shift：此函数从数组的开头移除一个元素，这与队列数据结构中的出队操作非常相似。从函数中返回移除的元素：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will show the output `bangladesh` in the command line. The `$countries`
    array will have only `nepal` and `bhutan` in it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在命令行中显示输出`bangladesh`。`$countries`数组中将只有`nepal`和`bhutan`。
- en: '**array_unshift** : This function adds one or more items at the beginning of
    the array and unshift existing items.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: array_unshift：此函数在数组的开头添加一个或多个项目，并将现有项目向后移动。
- en: '**shuffle** : If we need to shuffle an array for any reason, we can use this
    function. This function can be very handy to randomize the whole array.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: shuffle：如果我们需要出于任何原因对数组进行洗牌，我们可以使用这个函数。这个函数对于随机化整个数组非常有用。
- en: '**array_intersect** : This function takes two or more arrays as arguments and
    returns the common items from the first array and finds out the existence in other
    arrays. This function also preserves the keys.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: array_intersect：此函数将两个或多个数组作为参数，并返回第一个数组中的公共项，并查找其他数组中的存在。此函数还保留键。
- en: '**array_diff** : This function calculates the difference between an array and
    other given arrays. Like the `array_intersect` function, this function also takes
    multiple arrays as arguments, where the first argument is the base array and,
    others are compared for differentiating with it.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: array_diff：此函数计算数组与其他给定数组之间的差异。与`array_intersect`函数一样，此函数还接受多个数组作为参数，其中第一个参数是基本数组，其他参数用于与其进行区分。
- en: There are many useful array functions in PHP, and they are solving many existing
    data structure and algorithm problems. We can find a list of built-in array functions
    in PHP documentation. For the purpose of this book, we will explore a few more
    array functions for sorting in the upcoming sections. For other functions, PHP
    .NET is recommended for further reading.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中有许多有用的数组函数，它们解决了许多现有的数据结构和算法问题。我们可以在PHP文档中找到内置数组函数的列表。对于本书的目的，我们将在接下来的章节中探讨一些用于排序的数组函数。对于其他函数，建议进一步阅读PHP
    .NET。
- en: SPL classes
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SPL类
- en: 'Undoubtedly, SPL tries to solve common data structure implementation issues
    for PHP programmers. Many of us are either afraid or reluctant to implement proper
    data structure while programming. SPL comes with implementation of all basic data
    structure and, hence, makes life easier for developers by using built-in classes
    and methods. Since SPL comes as a bundle with PHP, we do not need to install it
    separately or enable any extension for it. In this section, we will discuss some
    of the common SPL classes in brief:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，SPL试图解决PHP程序员常见的数据结构实现问题。我们中的许多人在编程时要么害怕要么不愿意实现适当的数据结构。SPL包含了所有基本数据结构的实现，因此，通过使用内置的类和方法，它使开发人员的生活变得更加轻松。由于SPL与PHP捆绑在一起，我们不需要单独安装它或为其启用任何扩展。在本节中，我们将简要讨论一些常见的SPL类：
- en: '**SplDoublyLinkedList** : This class gives us the option to implement a doubly
    linked list without writing a big chunk of code. Though it says doubly linked
    list, we can utilize this class to implement stack and queue as well, by setting
    the iteration mode in the `setIteratorMode` method.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SplDoublyLinkedList：这个类为我们提供了在不编写大量代码的情况下实现双向链表的选项。尽管它说是双向链表，但我们也可以利用这个类来实现堆栈和队列，方法是在`setIteratorMode`方法中设置迭代模式。
- en: '**SplStack** :`SplStack` class is an extended version of the `SplDoublyLinkedList`
    class where the standard stack functions are available, which are actually from
    the doubly linked list class.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SplStack：`SplStack`类是`SplDoublyLinkedList`类的扩展版本，其中包括标准堆栈函数，实际上来自双向链表类。
- en: '**SplQueue** : `SplQueue` class is an extended version of the `SplDoublyLinkedList`
    class where the standard queue functions such as `enqueue` , `dequeue` are available.
    However, these functions are actually from the doubly linked list class.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SplQueue：`SplQueue`类是`SplDoublyLinkedList`类的扩展版本，其中包括标准队列函数，如`enqueue`，`dequeue`。但是，这些函数实际上来自双向链表类。
- en: '**SplHeap** : This is a generic heap implementation for PHP. `SplMaxHeap` and
    `SplMinHeap` are two implementations from the generic heap class.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SplHeap：这是PHP的通用堆实现。`SplMaxHeap`和`SplMinHeap`是通用堆类的两种实现。
- en: '**SplPriorityQueue** : `SplPriorityQueue` is implemented using `SplMaxHeap`
    and provides basic functionalities of a priority queue.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SplPriorityQueue：`SplPriorityQueue`是使用`SplMaxHeap`实现的，并提供了优先级队列的基本功能。
- en: '**SplFixedArray** : As we have seen in [Chapter 2](text00045.html) , *Understanding
    PHP Arrays* , `SplFixedArray` can be very handy to resolve memory and performance
    issues. `SplFixedArray` takes integer as index, and hence, it has faster read
    and write operations compared to generic PHP array.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SplFixedArray：正如我们在[第2章](text00045.html)中所看到的，*了解PHP数组*，`SplFixedArray`可以非常方便地解决内存和性能问题。`SplFixedArray`以整数作为索引，因此，与通用PHP数组相比，它具有更快的读写操作。
- en: '**SplObjectStorage** : Usually, we store anything in array either using integer
    or string key. This SPL class provides us with a way to store a value against
    an object. In object storage, we can use the object directly as a key for mapping.
    Also, we can use this class to store object collection.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SplObjectStorage：通常，我们使用整数或字符串键在数组中存储任何内容。这个SPL类为我们提供了一种方法，可以根据对象存储值。在对象存储中，我们可以直接使用对象作为映射的键。此外，我们还可以使用这个类来存储对象集合。
- en: Built-in PHP algorithms
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置PHP算法
- en: 'Now, we will check some of the built-in functionalities of PHP that solves
    lots of our algorithmic implementation required for day-to-day operations. We
    can categorize these functions into mathematics, string, cryptography and hashing,
    sorting, searching, and so on. We will explore the base conversion algorithms
    now:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检查PHP的一些内置功能，这些功能解决了我们日常操作所需的许多算法实现。我们可以将这些函数分类为数学、字符串、加密和哈希、排序、搜索等。现在我们将探索基数转换算法：
- en: '**base_convert** : This function is used for base conversion of a number. The
    base range is restricted from 2 to 36\. Since the base number can be in any base
    and contains characters, the first parameter for the function is string. Here
    is an example of the function:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: base_convert：此函数用于对数字进行基数转换。基数范围限制为2到36。由于基数可以是任何基数并包含字符，因此函数的第一个参数是字符串。以下是该函数的示例：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will produce the following output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**bin2hex** : This converts a binary string to a hexadecimal string. It takes
    only the binary string as the parameter.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bin2hex：这将二进制字符串转换为十六进制字符串。它只接受二进制字符串作为参数。
- en: '**bindec** : This converts a binary string to a decimal number. It takes only
    the binary string as the parameter.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bindec：这将二进制字符串转换为十进制数。它只接受二进制字符串作为参数。
- en: '**decbin** : This converts a decimal number to a binary string. It takes only
    the decimal value as the parameter.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: decbin：这将十进制数转换为二进制字符串。它只接受十进制值作为参数。
- en: '**dechex** : This converts a decimal number to a hexadecimal string. It takes
    only a decimal value as the parameter.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dechex：这将十进制数转换为十六进制字符串。它只接受十进制值作为参数。
- en: '**decoct** : This converts a decimal number to an octal string. It takes only
    a decimal value as the parameter.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: decoct：这将十进制数转换为八进制字符串。它只接受十进制值作为参数。
- en: '**hex2bin** : This converts a hexadecimal string into a binary string. It takes
    only the hexadecimal string as the parameter.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: hex2bin：这将十六进制字符串转换为二进制字符串。它只接受十六进制字符串作为参数。
- en: '**hexdec** : This converts a hexadecimal string to a decimal number. It takes
    only the hexadecimal string as the parameter.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: hexdec：这将十六进制字符串转换为十进制数。它只接受十六进制字符串作为参数。
- en: '**octdec** : This converts an octal string to decimal number. It takes only
    an octal string as the parameter.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: octdec：这将八进制字符串转换为十进制数。它只接受八进制字符串作为参数。
- en: 'There are many other built-in functions for different purposes. One of the
    most important things to do is to encode and decode text strings while sending
    e-mail or transportation layers. Since we need to encode and have the option to
    decode, we do not use one-way encryption function. Also, there are many useful
    functions that can be used for different string operations. We will now explore
    such functions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他用于不同目的的内置函数。其中最重要的之一是在发送电子邮件或传输层时对文本字符串进行编码和解码。由于我们需要编码并具有解码选项，因此我们不使用单向加密函数。此外，还有许多有用的函数可用于不同的字符串操作。我们现在将探讨这些函数：
- en: '**base64_encode** : This function encodes data with base 64 mime types. Usually,
    the encoded string is larger than the actual string and takes 33 percent more
    space than the actual string. Sometimes, the generated strings have one or two
    equal symbols at the end, which indicates the output padding for the string.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: base64_encode：此函数使用base64 mime类型对数据进行编码。通常，编码后的字符串比实际字符串大，并且比实际字符串多占33%的空间。有时，生成的字符串末尾会有一个或两个等号符号，表示字符串的输出填充。
- en: '**base64_decode** : This function takes a base 64 encoded string and generates
    the actual string out of it. It is just opposite of the previous function we discussed.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: base64_decode：此函数接受一个base64编码的字符串，并生成其中的实际字符串。它是我们之前讨论的函数的相反操作。
- en: '**levenshtein** : One of the most common problems we face is to find similarity
    between two texts, for example, a user-typed name of a product that we do not
    have in the list. However, a quick inspection shows that there was a typo in the
    text. In order to show which is the closest matching string or the correct string
    based on minimal number of characters to add, edit, or delete them. We will call
    this edit distance. The `levenshtein` function or levenshtein distance is defined
    as the minimal number of characters we have to replace, insert, or delete to transform
    the first string to the second string. The complexity of the function is `O(m*n)`
    , and the limitation is each string has to be less than 255 characters. Here is
    an example:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: levenshtein：我们面临的最常见问题之一是找出两个文本之间的相似性，例如，用户输入的产品名称在列表中不存在。然而，快速检查显示文本中有拼写错误。为了显示哪个是最接近的匹配字符串或基于最小字符数添加、编辑或删除它们的正确字符串。我们将称之为编辑距离。`levenshtein`函数或levenshtein距离被定义为将第一个字符串转换为第二个字符串所需的最小字符数，包括替换、插入或删除。该函数的复杂度为`O(m*n)`，并且限制是每个字符串的长度必须小于255个字符。以下是一个例子：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will have the following output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Another variant of the function takes extra three parameters through which we
    can provide the cost of the insert, replace, and delete operations. This way,
    we can get the best possible result based on the cost function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的另一个变体通过额外的三个参数，我们可以提供插入、替换和删除操作的成本。这样，我们可以根据成本函数得到最佳结果。
- en: '**similar_text** : This function calculates the similarity between two strings.
    It has an option to return the similarity in a percentile manner. The function
    is case sensitive and returns the similarity score based on the matched characters.
    Here is one example:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: similar_text：此函数计算两个字符串之间的相似度。它有一个选项以百分比方式返回相似度。该函数区分大小写，并根据匹配的字符返回相似度分数。以下是一个例子：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code will produce the percentile match between Mango and Tango.
    The output is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生芒果和探戈之间的百分比匹配。输出如下：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**soundex** : This is an interesting function using which we can find the soundex
    key of a given string. This soundex key can be used to find similar sounding words
    from the collection or find whether two words sound similar or not. The soundex
    key is four characters in length, where the first character is a letter and the
    remaining three are digits. Here are some soundex keys for familiar words:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: soundex：这是一个有趣的函数，我们可以使用它找到给定字符串的soundex键。这个soundex键可以用来从集合中找到类似发音的单词，或者找出两个单词是否发音相似。soundex键的长度为四个字符，第一个字符是字母，其余三个是数字。以下是一些熟悉单词的soundex键：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code will have following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we can see from the preceding output, both `pray` and `prey` are different
    words, but they have similar soundex keys. Soundex can be very useful to find
    out similar sounding words from the database in different use cases.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看到，`pray`和`prey`是不同的单词，但它们具有相似的soundex键。在不同的用例中，Soundex可以非常有用地找出数据库中类似发音的单词。
- en: '**metaphone** : Metaphone is another function similar to soundex, which can
    help us find similar sounding words. The basic difference between the two is that,
    the metaphone is more accurate as it considers the basic english rules for pronunciation.
    The function generates metaphone keys, which are variable in length. We can also
    pass second arguments to limit the key generation length. Here is a similar example
    from soundex:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: metaphone：Metaphone是另一个类似于soundex的函数，可以帮助我们找到类似发音的单词。两者之间的基本区别在于，metaphone更准确，因为它考虑了基本的英语发音规则。该函数生成可变长度的metaphone键。我们还可以传递第二个参数来限制键的生成长度。以下是一个与soundex类似的例子：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is the output for the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Hashing
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希
- en: 'Hashing is one of the most important aspects of modern-day programming. In
    terms of data security and privacy, hashing plays a key role in computer cryptography.
    We do not feel comfortable to keep our data unsafe and open for all. PHP has several
    built-in hashing functions. Let''s quickly go through them:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是现代编程中最重要的方面之一。在数据安全和隐私方面，哈希在计算机密码学中起着关键作用。我们不愿意让我们的数据不安全并对所有人开放。PHP有几个内置的哈希函数。让我们快速浏览一下它们：
- en: '**md5** : This calculates the md5 hash of a given string. It will generate
    32 characters unique hash for each of the provided string. Hashing is one way,
    which means, there is no function to decrypt the hashed string to actual string.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: md5：这计算给定字符串的md5哈希。它将为每个提供的字符串生成32个字符的唯一哈希。哈希是单向的，这意味着没有函数可以将哈希字符串解密为实际字符串。
- en: '**sha1** : This function calculates the sha1 hash of a given string. The generated
    hash is 40 characters in length. Like md5, sha1 is also a one way hashing. If
    we set the second parameter to be true, then the function will produce 20-character
    raw output hash string. One thing to remember is sha1, sha256, and md5 are not
    secure enough to use for password hashing. As they are very fast and efficient,
    hackers tend to use them for brute force attacking and find the actual input from
    the generated hash.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sha1**：此函数计算给定字符串的sha1哈希。生成的哈希长度为40个字符。与md5一样，sha1也是一种单向哈希。如果将第二个参数设置为true，则函数将生成20个字符的原始输出哈希字符串。要记住的一件事是sha1、sha256和md5不足以用于密码哈希。由于它们非常快速和高效，黑客倾向于使用它们进行暴力攻击，并从生成的哈希中找到实际输入。'
- en: '**crypt** : This function generates a one way hashing key for a given string
    with optional salt string. If you are using PHP 7, then the function will produce
    an `E_NOTICE` for not providing any salt during the function call. For hashing,
    the function uses **UNIX DES** based algorithm or other algorithms available for
    hashing.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码：此函数为给定的字符串生成一个单向哈希键，可选的盐字符串。如果您使用的是PHP 7，则在函数调用期间未提供任何盐，该函数将产生一个`E_NOTICE`。对于哈希，该函数使用基于**UNIX
    DES**的算法或其他可用于哈希的算法。
- en: '**password_hash** : This is another useful function that generates hash for
    passwords. It takes two arguments, one which includes the actual string, and the
    second is the hashing algorithm. The default hashing algorithm uses bcrypt algorithm,
    and the alternate option is the blowfish algorithm.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**password_hash**：这是另一个有用的函数，用于为密码生成哈希。它需要两个参数，一个包括实际字符串，另一个是哈希算法。默认的哈希算法使用bcrypt算法，备选选项是blowfish算法。'
- en: '**password_verify** : We can use this function if we have generated the password
    using the `password_hash` function. The first parameter of the function is the
    entered password, and the second one is the hashed string. The function returns
    true or false based on the verification part.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**password_verify**：如果我们使用`password_hash`函数生成了密码，则可以使用此函数。函数的第一个参数是输入的密码，第二个参数是哈希字符串。该函数根据验证部分返回true或false。'
- en: '**hash_algos** : If we want to know the list of registered hashing algorithms
    in the system, we can use this function. This will list all the possible options
    for hashing algorithm in the current system.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hash_algos**：如果我们想知道系统中注册的哈希算法列表，可以使用此函数。这将列出当前系统中哈希算法的所有可能选项。'
- en: '**hash** : This function takes a mandatory hashing algorithm name along with
    a string to be hashed to generate a hashed key. There is an optional parameter
    to get the raw binary output for the hashing. The hash key length will vary based
    on the chosen algorithm.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hash**：此函数需要一个强制的哈希算法名称以及要进行哈希处理的字符串，以生成一个哈希键。还有一个可选参数，用于获取哈希的原始二进制输出。哈希键的长度将根据所选的算法而变化。'
- en: PHP has a rich collection of functions and libraries for hashing and cryptography.
    For further reading, you can consider the PHP.net documentation, along with some
    other sites mentioned in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: PHP具有丰富的哈希和加密函数和库的集合。有关更多信息，请参阅PHP.net文档，以及下一节中提到的其他一些网站。
- en: Built-in support through PECL
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过PECL内置支持
- en: Since PHP 7.0 release, a raising concern for developers is the performance issue
    of SPL classes. PHP 7.0 does not bring any improvement to early designed SPL classes,
    and many developers are now sceptical about using it further. Many developers
    have written custom libraries and extensions for PHP to improve the data structure
    efficiency. One of such extensions is PHP DS, a specialized extension for PHP
    7 data structures. The extension is written by Joe Watkins and Rudi Theunissen.
    The official documentation of PHP DS extension can be found in the PHP manual
    at [http://php.net/manual/en/book.ds.php](http://php.net/manual/en/book.ds.php)
    .
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 自PHP 7.0发布以来，开发人员关注的一个问题是SPL类的性能问题。PHP 7.0对早期设计的SPL类没有带来任何改进，许多开发人员现在对进一步使用它持怀疑态度。许多开发人员已经为PHP编写了自定义库和扩展，以提高数据结构的效率。其中一个扩展就是PHP
    DS，这是一个专门为PHP 7数据结构设计的扩展。该扩展由Joe Watkins和Rudi Theunissen编写。PHP DS扩展的官方文档可以在PHP手册的[http://php.net/manual/en/book.ds.php](http://php.net/manual/en/book.ds.php)中找到。
- en: The library works as an alternative to PHP array, which is a very flexible,
    dynamic, hybrid data structure. This extension comes up with lots of pre-built
    data structures such as set, map, sequence, collection, vector, stack, queue,
    priority queue, and so on. We will explore them in the next few sections.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该库可作为PHP数组的替代品，它是一种非常灵活、动态、混合的数据结构。此扩展提供了许多预构建的数据结构，如集合、映射、序列、集合、向量、堆栈、队列、优先队列等。我们将在接下来的几节中探讨它们。
- en: Installation
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'The library comes up with different options for installations. The easiest
    one is to get it from PECL (a repository for PHP Extensions):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该库提供了不同的安装选项。最简单的方法是从PECL（PHP扩展的存储库）获取它：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can also download the source code and compile the library if we want. In
    order to do that, we just need to get the code from the GitHub repository and
    follow the git commands:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们也可以下载源代码并编译库。为此，我们只需要从GitHub存储库获取代码并遵循git命令：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If there is any dependency issue, we have to install this package as well:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在任何依赖性问题，我们还必须安装此软件包：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For Windows, the DLL is available to download from PECL site. For Mac OS users,
    Homebrew has support to install this extension:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows，可以从PECL网站下载DLL。对于Mac OS用户，Homebrew支持安装此扩展：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the installation is done, we have to add the extension to our primary
    `php.ini` file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们必须将扩展添加到我们的主要`php.ini`文件中：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the extension is properly added, all pre-built classes will be available
    through `global \DS\ namespace` .
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果扩展正确添加，所有预构建的类将通过`global \DS\ namespace`可用。
- en: Now, let's get into details for pre-built DS classes from this extension. We
    will start with the base of all classes, the collection interface.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细了解此扩展中预构建的DS类。我们将从所有类的基础，即集合接口开始。
- en: Interfaces
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: The collection interface is the base interface for all classes in this DS library.
    All data structure implementations implement the collection interface by default.
    The collection interface ensures that all classes are having similar behavior
    of traversable, countable, and JSON serializable. The collection interface has
    four abstract methods, and they are `clear` , `copy` , `isEmpty` , and `toArray`
    . All of the data structure implementations of DS class implement the interface,
    and we will see these methods at work during our exploration of those data structures.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 集合接口是DS库中所有类的基本接口。所有数据结构实现都默认实现了集合接口。集合接口确保所有类都具有类似的可遍历、可计数和JSON可序列化的行为。集合接口有四个抽象方法，它们是`clear`、`copy`、`isEmpty`和`toArray`。DS类的所有数据结构实现都实现了该接口，我们将在探索这些数据结构时看到这些方法的运作。
- en: Another important aspect of the data structure library is to use an object as
    a key. This can be achieved through the hashable interface of the library. There
    is another important interface that allows list functionalities to be implemented
    in data structure classes and also ensures better performance than the SPL equivalent
    of doubly linked list and fixed array.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构库的另一个重要方面是使用对象作为键。这可以通过库的可哈希接口来实现。还有另一个重要的接口，允许在数据结构类中实现列表功能，并且确保比SPL双向链表和固定数组的性能更好。
- en: Vector
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量
- en: 'A vector is a linear data structure where values are stored sequentially and
    also the size grows and shrinks automatically. Vector is one of the most efficient
    linear data structures as the value''s index is mapped directly with the index
    of the buffer and allows faster access. DS vector class allows us to use the PHP
    array syntax for operations, but internally, it has less memory consumption than
    PHP array. It has constant time operations for push, pop, get, and set. Here is
    an example of vector:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是一种线性数据结构，其中值按顺序存储，大小也会自动增长和缩小。向量是最有效的线性数据结构之一，因为值的索引直接映射到缓冲区的索引，并允许更快的访问。DS向量类允许我们使用PHP数组语法进行操作，但在内部，它的内存消耗比PHP数组少。它具有常数时间的push、pop、get和set操作。以下是向量的一个示例：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As we can see from the preceding code, we can define a vector using the PHP
    array syntax and also get or set values using array syntax. One difference is
    that we cannot add a new index using PHP array syntax. For that, we have to use
    the push method of the vector class. Trying to set or get an index that is not
    there will cause `OutofRangeException` to be thrown during runtime. Here is the
    output of the preceding code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的代码可以看出，我们可以使用PHP数组语法来定义一个向量，并且也可以使用数组语法来获取或设置值。一个区别是我们不能使用PHP数组语法来添加一个新的索引。为此，我们必须使用向量类的push方法。尝试设置或获取不存在的索引将导致在运行时抛出`OutofRangeException`。以下是上述代码的输出：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Map
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射
- en: 'A map is a sequential collection of key-value pairs. A map is similar to an
    array, and the key can be a string, integer, and so on, but the key has to be
    unique. In DS map class, the key can be of any type, including an object. It allows
    PHP array syntax for operations and also preserves the insertion order. The performance
    and memory efficiency is also similar to the PHP array. It also automatically
    frees memory when the size drops to low. If we consider the following performance
    chart, we can see that map implementation in DS library is much faster than PHP
    array when we are removing items from a big array:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是键值对的顺序集合。映射类似于数组，键可以是字符串、整数等，但键必须是唯一的。在DS映射类中，键可以是任何类型，包括对象。它允许PHP数组语法进行操作，同时保留插入顺序。性能和内存效率也类似于PHP数组。当大小降低时，它还会自动释放内存。如果我们考虑下面的性能图表，我们可以看到DS库中的映射实现在从大数组中移除项目时比PHP数组快得多：
- en: '![](Image00093.gif)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00093.gif)'
- en: Set
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: 'A set is also a sequence, but a set can only contain unique values. A set can
    store any value, including object, and also support array syntax. It preserves
    the insertion order and also automatically frees memory when the size drops to
    low. We can achieve add, remove, and contain operations in constant time. However,
    this set class does not support push, pop, shift, insert, and unshift functions.
    The set class has some very useful set operation functions built in, such as diff,
    intersect, union, and so on. Here is an example of the set operation:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 集合也是一个序列，但集合只能包含唯一的值。集合可以存储任何值，包括对象，并且支持数组语法。它保留插入顺序，并且在大小降低时也会自动释放内存。我们可以在常数时间内实现添加、删除和包含操作。然而，这个集合类不支持push、pop、shift、insert和unshift函数。集合类内置了一些非常有用的集合操作函数，如diff、intersect、union等。以下是集合操作的一个示例：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding example code, there will be only one entry of `1` as set cannot
    have duplicate values. Also, when we are getting the value of `1` , this indicates
    the value at index `1` . So, the output will be test for the preceding example.
    One question might arise here that why not we use `array_unique` here to build
    a set. The following comparison chart might be the answer we are looking for:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，`1`的条目只会有一个，因为集合不能有重复的值。另外，当我们获取`1`的值时，这表示在索引`1`处的值。因此，输出将是前面示例的测试。这里可能会有一个问题，为什么我们不在这里使用`array_unique`来构建一个集合。下面的比较图表可能是我们正在寻找的答案：
- en: '![](Image00094.gif)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00094.gif)'
- en: 'As we can see from the preceding chart, as the array size grows, array unique
    function will take more time to compute compared to our `set` class in the DS
    library. Also, the `set` class takes lesser memory compared to PHP array as the
    size grows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的图表可以看出，随着数组大小的增长，array_unique函数的计算时间将比我们在DS库中的`set`类更长。此外，随着大小的增长，`set`类所占用的内存也比PHP数组少：
- en: '![](Image00095.gif)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00095.gif)'
- en: Stack and queue
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈和队列
- en: 'The DS library also has implementations of stack and queue data structures.
    `DS\Stack` uses `DS\Vector` internally, and `DS\Queue` uses `DS\Deque` internally.
    Both stack and queue implementation have similar performance compared to SPL implementation
    of stack and queue. The following chart shows this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: DS库还实现了栈和队列数据结构。`DS\Stack` 内部使用 `DS\Vector`，`DS\Queue` 内部使用 `DS\Deque`。与SPL实现的栈和队列相比，这两种实现的性能相似。以下图表显示了这一点：
- en: '![](Image00096.gif)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00096.gif)'
- en: Deque
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双端队列
- en: 'The deque (pronounced as deck), or the double ended queue, is used for the
    `DS\Queue` implementation internally. The deque implementation in this package
    is very efficient in memory usage and also performs get, set, push, pop, shift,
    and unshift operations in constant time of `O(1)` . However, one of the disadvantages
    of `DS\Deque` is the insert or remove operation, which has `O(n)` complexity.
    Here is a performance comparison between `DS\Deque` and SPL doubly linked list:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 双端队列（发音为deck），或双端队列，用于`DS\Queue`内部实现。此软件包中的双端队列实现在内存使用上非常高效，并且在常数时间内执行get、set、push、pop、shift和unshift操作。然而，`DS\Deque`的一个缺点是插入或删除操作的复杂度为`O(n)`。以下是`DS\Deque`和SPL双向链表的性能比较：
- en: '![](Image00097.gif)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00097.gif)'
- en: Priority queue
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优先队列
- en: 'You have already learned that priority queues are important for many algorithms.
    Having an efficient priority queue is very important for us as well. So far, we
    have seen that we can implement from our own using heap or use the SPL priority
    queue for our solutions. However, the `DS\PriorityQueue` is more than twice as
    fast as `SplPriorityQueue` and uses only five percent of its memory. This makes
    `DS\PriorityQueue` 20 times more memory efficient compared to `SplPriorityQueue`
    . The following chart shows the comparison:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解到优先队列对于许多算法非常重要。拥有高效的优先队列对我们来说也非常重要。到目前为止，我们已经看到我们可以使用堆来实现自己的优先队列，或者使用SPL优先队列来解决问题。然而，`DS\PriorityQueue`比`SplPriorityQueue`快两倍以上，并且仅使用其内存的百分之五。这使得`DS\PriorityQueue`比`SplPriorityQueue`内存效率高20倍。以下图表显示了比较：
- en: '![](Image00098.gif)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00098.gif)'
- en: From our discussion in the last few sections, we can conclude that the DS extension
    is really efficient for data structures and far better compared to SPL for similar
    implementations. Though the benchmark can vary a little from platform to platform
    and internal configurations, it shows that the new DS extension is promising and
    might be very helpful for developers. One thing to remember is that the library
    does not have built-in heap or tree data structure yet, so we cannot have a built-in
    hierarchical data structure from this library.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们在最近几节的讨论中，我们可以得出结论，DS扩展对于数据结构来说非常高效，与SPL相比有着更好的性能。尽管基准测试可能会因平台和内部配置的不同而有所变化，但它表明新的DS扩展是有前途的，可能对开发人员非常有帮助。需要记住的一点是，该库尚未内置堆或树数据结构，因此我们无法从该库中获得内置的分层数据结构。
- en: 'For more information, you can check the following article as the comparison
    charts are taken from here: [https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd](https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请查看以下文章，比较图表来自这里：[https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd](https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd)
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: PHP has a rich collection of built-in functions, and the list is growing every
    day. In this chapter, we explored some of the defined functions that can be used
    in implementing data structures and algorithms. There are many other external
    libraries available as well. We can select any of the internal or external libraries
    as per our preferences. Also, there are plenty of online resources to get acquainted
    with the data structures and algorithm concepts. You also learned about the performance
    concerns for SPL classes in PHP 7 and got introduced to a new library for PHP
    7 data structures. We have to remember that data structures and algorithms are
    not language agnostic. We can have same data structures and algorithms implemented
    using different languages or different versions of the same language. In our next
    chapter, we will explore another area of programming, which is very popular at
    this moment, the functional programming. So, next, we will focus on functional
    data structure with PHP.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: PHP拥有丰富的内置函数集，而且这个列表每天都在增长。在本章中，我们探讨了一些可以用于实现数据结构和算法的定义函数。还有许多其他外部库可供使用。我们可以根据自己的喜好选择任何内部或外部库。此外，还有许多在线资源可以了解数据结构和算法的概念。您还了解了PHP
    7中SPL类的性能问题，并介绍了PHP 7数据结构的新库。我们必须记住，数据结构和算法并不是与语言无关的。我们可以使用不同的语言或同一语言的不同版本来实现相同的数据结构和算法。在下一章中，我们将探索编程的另一个领域，这在目前非常流行，即函数式编程。因此，接下来，我们将专注于PHP的函数式数据结构。
