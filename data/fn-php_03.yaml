- en: Chapter 3.  Functional Basis in PHP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。PHP中的功能基础
- en: After covering functions in PHP in the first chapter, followed by theoretical
    aspects of functional programming in the second, we will finally start to write
    real code. We will start with the available functions in PHP that allow us to
    write functional code. Once the basic techniques are well understood, we will
    move on to various libraries that will help us throughout the book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中介绍了PHP中的函数，接着是第二章中的函数式编程的理论方面，我们最终将开始编写真正的代码。我们将从PHP中可用的函数开始，这些函数允许我们编写功能性代码。一旦基本技术得到很好的理解，我们将转向各种库，这些库将在整本书中帮助我们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Mapping, folding, reducing, and zipping
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射、折叠、减少和压缩
- en: Recursion
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: Why exceptions break referential transparency
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么异常会破坏引用透明度
- en: A better way of handling errors using the Maybe and Either types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Maybe和Either类型更好地处理错误的方法
- en: Functional libraries available for PHP
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP中可用的功能性库
- en: General advice
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般建议
- en: In the previous chapters, we described the important properties a functional
    application must have. However, we never really discussed how it can be achieved.
    Besides the various techniques we will learn about later on, there are a few simple
    pieces of advice that could really help you right away.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们描述了功能应用程序必须具有的重要属性。然而，我们从未真正讨论过如何实现它。除了我们将在以后学习的各种技术之外，还有一些简单的建议可以立即帮助您。
- en: Making all inputs explicit
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使所有输入明确
- en: We discussed purity and hidden inputs, or side causes, a lot in the previous
    chapter. By now, it should be pretty clear that all the dependencies of your functions
    should be passed on as parameters. This advice, however, goes a bit further.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中大量讨论了纯度和隐藏输入，或者副作用。现在，应该很清楚，函数的所有依赖关系都应该作为参数传递。然而，这个建议还要进一步。
- en: 'Avoid passing objects or complex data structure to your functions. Try to limit
    your input to what is necessary only. Doing so will make the scope of your function
    easier to understand and it will ease determining how the function operates. It
    also has the following benefits:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 避免将对象或复杂数据结构传递给您的函数。尽量限制输入到必要的内容。这样做将使您的函数范围更容易理解，并且将有助于确定函数的操作方式。它还具有以下好处：
- en: It will be easier to call
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用将更容易
- en: Testing it will require stubbing less data
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试它将需要较少的数据存根
- en: Avoiding temporary variables
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免临时变量
- en: As you may have gotten to understand, state is evil-particularly global state.
    However, local variables are a kind of local state. As soon as you start peppering
    your code with them, you are slowly opening the can of worms. This is especially
    true in a language such as PHP, where all variables are mutable. What happens
    if the value changes along the way?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经了解的那样，状态是邪恶的，特别是全局状态。然而，局部变量是一种局部状态。一旦您开始在代码中频繁使用它们，您就慢慢地打开了潘多拉的魔盒。这在PHP这样的语言中尤其如此，因为所有变量都是可变的。如果值在途中发生变化会发生什么？
- en: Each time you declare a variable, you have to keep its value in mind if you
    are to understand how the remainder of the code works. This greatly increases
    the cognitive burden. Also, as PHP is dynamically typed, a variable can be reused
    with totally different data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每次声明一个变量，你都必须记住它的值，才能理解代码的其余部分是如何工作的。这大大增加了认知负担。此外，由于PHP是动态类型的，一个变量可以被完全不同的数据重复使用。
- en: When using a temporary variable, there is always the risk that it gets modified
    somehow or reused without it being evident, leading to bugs that are difficult
    to debug.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用临时变量时，总会存在某种方式修改或重复使用的风险，导致难以调试的错误。
- en: 'In nearly all cases, using a function is better than a temporary variable.
    Functions allow for the same benefits:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有情况下，使用函数比使用临时变量更好。函数允许获得相同的好处：
- en: Improving readability by naming intermediate results
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过命名中间结果来提高可读性
- en: Avoiding repeating yourself
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免重复自己
- en: Caching the result of a lengthy operation (this requires the use of memoization,
    which we will discuss in [Chapter 8](ch09.html "Chapter 9.  Performance Efficiency"),
    *Performance Efficiency*)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存冗长操作的结果（这需要使用备忘录，我们将在[第8章](ch09.html "第9章。性能效率")中讨论，*性能效率*）
- en: The added cost of calling a function is usually minimal enough to not tip the
    balance. Also, using functions instead of temporary variables means that you can
    then reuse those functions in other places. They could also make future refactoring
    easier and they improve the separation of concerns.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数的额外成本通常是微不足道的，不会打破平衡。此外，使用函数而不是临时变量意味着您可以在其他地方重用这些函数。它们还可以使未来的重构更容易，并且可以改善关注点的分离。
- en: As it can be expected with best practices, there are, however, some times when
    it's easier to use temporary variables. For example, if you need to store a return
    value that will be used just after in a short function so that you can keep the
    line length comfortable, don't hesitate to do so. The only thing that should be
    strictly forbidden is to use the same temporary variables to store various different
    bits of information.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如最佳实践所期望的那样，有时使用临时变量会更容易一些。例如，如果您需要在一个短函数中存储一个返回值，以便在之后立即使用，以便保持行长度舒适，请毫不犹豫地这样做。唯一严格禁止的是使用相同的临时变量来存储各种不同的信息。
- en: Smaller functions
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更小的函数
- en: We already mentioned that functions are like building blocks. Usually, you want
    your building blocks to be versatile and sturdy. Both those properties are better
    enforced if you write small functions that only focus on doing one thing well.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到函数就像积木一样。通常，您希望您的积木多才多艺且坚固。如果您编写只专注于做一件事情的小函数，那么这两个属性都会得到更好的强化。
- en: If your function does too much, it is difficult to reuse. We will look at composing
    functions in the next chapter and how you can leverage all your small utility
    functions to create new ones with bigger reaches.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的函数做得太多，很难重用。我们将在下一章中讨论如何组合函数，以及如何利用所有小型实用函数来创建具有更大影响力的新函数。
- en: Also, it is easier to read smaller pieces of code and reason about them. The
    implications are simpler to understand and there are usually fewer edge cases,
    making the function easier to test.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，阅读较小的代码片段并对其进行推理更容易。相关的影响更容易理解，通常情况下边界情况更少，使函数更容易测试。
- en: Parameter order matters
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数顺序很重要
- en: Choosing the order of parameters of your functions does not seems like much,
    but in fact it matters a lot. Higher-order functions are a core feature of functional
    programming; this means that you will be passing a lot of functions around.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 选择函数参数的顺序似乎并不重要，但实际上它很重要。高阶函数是函数式编程的核心特性；这意味着你将会传递很多函数。
- en: Those functions could be anonymous, in which case you might want to avoid having
    a function declaration as the middle parameter, for readability reasons. Optional
    parameters are also constrained to the end of the signature in PHP. As we will
    see, some functional constructs take functions that can have default values.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以是匿名的，这种情况下，出于可读性的考虑，你可能希望避免将函数声明作为中间参数。在PHP中，可选参数也受到签名末尾的限制。正如我们将看到的，一些函数构造可以接受具有默认值的函数。
- en: We will also dwell on this topic further in [Chapter 4](ch04.html "Chapter 4. Composing
    Functions"), *Compositing Functions*. When you chain multiple functions together,
    the first parameter of each is the return value of the previous one. This means
    you will have to take special care when choosing which parameters go first.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在[第4章](ch04.html "第4章。组合函数")*组合函数*中进一步讨论这个话题。当你将多个函数链接在一起时，每个函数的第一个参数是前一个函数的返回值。这意味着在选择哪些参数先传递时，你需要特别小心。
- en: The map function
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射函数
- en: 'The map, or `array_map` method in PHP, is a higher-order function that applies
    a given callback to all elements of a collection. The `return` value is a collection
    in the same order. A simple example is:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，map或`array_map`方法是一个高阶函数，它将给定的回调应用于集合的所有元素。`return`值是按顺序排列的集合。一个简单的例子是：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We create a function that computes the square of the given integer and then
    use the `array_map` function to compute all the square values of a given array.
    The first parameter of the `array_map` function is any form of callable and the
    second parameter has to be a *real array*. You cannot pass an Iterator or an instance
    of Traversable.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个计算给定整数的平方的函数，然后使用`array_map`函数来计算给定数组的所有平方值。`array_map`函数的第一个参数可以是任何形式的callable，第二个参数必须是一个*真实的数组*。你不能传递一个迭代器或一个Traversable的实例。
- en: 'You can also pass multiple arrays. Your callback will receive a value from
    each array:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以传递多个数组。你的回调将从每个数组中接收一个值：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code will display:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将显示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The longest array will determine the length of the result. Shorter arrays will
    be expanded with the null value so that they all have matching lengths.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最长的数组将决定结果的长度。较短的数组将用null值扩展，以使它们的长度相匹配。
- en: 'If you pass null as a function, PHP will merge the arrays:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将null作为函数传递，PHP将合并这些数组：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And the result:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you pass only one array, the keys will be preserved; but if you pass multiple
    arrays, they will be lost:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只传递一个数组，键将被保留；但如果你传递多个数组，它们将丢失：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And the result:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As a final note, it is sadly impossible to access the key of each item easily.
    Your callable can, however, be a closure so you are able to use any variable accessible
    from your context. Using this, you can map over the keys of your array and use
    a closure to retrieve the values like that:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的是，很遗憾，无法轻松访问每个项目的键。然而，你的回调可以是一个闭包，因此你可以使用来自你上下文的任何变量。利用这一点，你可以在数组的键上进行映射，并使用闭包来检索值：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The filter function
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤函数
- en: 'The filter, or `array_filter` method in PHP, is a higher-order function that
    keeps only certain elements of a collection, based on a Boolean predicate. The
    `return` value is a collection that will only contain elements returning true
    for the predicate function. A simple example is:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，filter或`array_filter`方法是一个高阶函数，它基于布尔谓词仅保留集合的某些元素。`return`值是仅包含谓词函数返回true的元素的集合。一个简单的例子是：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We first create a function that takes a value and returns a Boolean. This function
    will be our predicate. In our case, we check whether an integer is an odd number.
    As with the `array_map` method, the predicate can be anything that is a `callable`
    and the collection must be an array. Be aware, however, that the parameter order
    is reversed; the collection comes first.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个接受值并返回布尔值的函数。这个函数将是我们的谓词。在我们的例子中，我们检查一个整数是否是奇数。与`array_map`方法一样，谓词可以是任何`callable`，集合必须是一个数组。然而，请注意参数顺序是相反的；集合首先出现。
- en: 'The callback is optional; if you don''t give one, all elements which PHP will
    evaluate to false, like empty strings and arrays for example, will be filtered
    out:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是可选的；如果你不提供一个，PHP将过滤掉所有会被评估为false的元素，比如空字符串和数组：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also pass a third parameter that acts as a flag to determine whether
    you want to receive the key instead of the value, or both:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以传递第三个参数，作为一个标志，确定你想要接收键还是值，或者两者都要：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The fold or reduce function
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 折叠或减少函数
- en: Folding refers to a process where you reduce a collection to a return value
    using a combining function. Depending on the language, this operation can have
    multiple names like fold, reduce, accumulate, aggregate, or compress. As with
    other functions related to arrays, the PHP version is the `array_reduce` function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠是指使用组合函数将集合减少为返回值的过程。根据语言的不同，这个操作可能有多个名称，如fold、reduce、accumulate、aggregate或compress。与与数组相关的其他函数一样，在PHP中的版本是`array_reduce`函数。
- en: 'You may be familiar with the `array_sum` function, which calculates the sum
    of all the values in an array. This is, in fact, a fold and can be easily written
    using the `array_reduce` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉`array_sum`函数，它计算数组中所有值的总和。实际上，这是一种折叠操作，可以很容易地使用`array_reduce`函数来实现：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Like the `array_filter` method, the collection comes first; you then pass a
    callback and finally an optional initial value. In our case, we were forced to
    pass the initial value 0 because the default null is an invalid type for our function
    signature of int type.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 像`array_filter`方法一样，首先是集合；然后传递一个回调，最后是一个可选的初始值。在我们的情况下，我们被迫传递初始值0，因为默认的null对于我们的int类型函数签名是无效的类型。
- en: The callback function has two parameters. The first one is the current reduced
    value based on all previous items, sometimes called **carry** or **accumulator**.
    The second one is the array element currently being processed. On the first iteration,
    the carry is equal to the initial value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数有两个参数。第一个是基于所有先前项目的当前减少值，有时称为**carry**或**accumulator**。第二个是当前正在处理的数组元素。在第一次迭代中，carry等于初始值。
- en: 'You don''t necessarily need to use the elements themselves to produce a value.
    You could, for example, implement a naive replacement for `in_array` using fold:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您不一定需要使用元素本身来生成值。例如，您可以使用fold实现`in_array`的简单替代：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The reduce operation starts with the initial value false because we assume that
    the array does not contain our needle. This also allows us to nicely manage the
    case where we have an empty array.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: reduce操作从初始值false开始，因为我们假设数组不包含我们要找的项目。这也使我们能够很好地处理数组为空的情况。
- en: Upon each item, if the item is the one we are searching for, we return true,
    which will be the new value passed around. If it does not match, we simply return
    the current value of the accumulator, which will be either `true` if we found
    the item earlier, or `false` if we did not.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个项目，如果项目是我们正在搜索的项目，我们返回true，这将是新的传递值。如果不匹配，我们只需返回累加器的当前值，它将是`true`（如果我们之前找到了项目）或`false`（如果我们没有找到）。
- en: Our implementation will probably be a tad slower than the official one because,
    no matter what, we have to iterate over the entire array before returning a result
    instead of being able to exit the function as soon as we encounter the searched
    item.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现可能比官方的慢一点，因为无论如何，我们都必须在返回结果之前遍历整个数组，而不能在遇到搜索项目时立即退出函数。
- en: 'We could, however, implement an alternative to the max function where performances
    should be on par, because any implementation will have to iterate over all values:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以实现一个max函数的替代方案，性能应该是相当的，因为任何实现都必须遍历所有值：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The idea is the same as before, although using numbers instead of a Boolean
    value. We start with the initial `0`, our current maximum. If we encounter a bigger
    value, we return it so that it gets passed around. Otherwise, we keep returning
    our current accumulator, already containing the biggest value encountered so far.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法和之前一样，只是使用数字而不是布尔值。我们从初始值`0`开始，我们的当前最大值。如果我们遇到更大的值，我们返回它，以便传递。否则，我们继续返回我们当前的累加器，已经包含到目前为止遇到的最大值。
- en: 'As the max PHP functions works on both arrays and numbers, we could reuse it
    for our reducing. This would, however, bring nothing, as the original function
    can already operate directly on arrays:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于max PHP函数适用于数组和数字，我们可以重用它来进行减少。然而，这将带来没有意义，因为原始函数已经可以直接在数组上操作：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Just to be clear, I don't recommend using those in production. The functions
    already in the language are better. Those are just for educational purposes to
    demonstrate the various possibilities of folding.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了明确起见，我不建议在生产中使用这些。语言中已经有更好的函数。这些只是为了教育目的，以展示折叠的各种可能性。
- en: 'Also, I totally understand if those short examples do not seem better than
    a `foreach` loop, or any other more imperative approach, to implement those two
    functions. They have, however, a few advantages:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我完全理解，这些简短的示例可能不比`foreach`循环或其他更命令式的方法更好，来实现这两个函数。但是它们有一些优点：
- en: If you are using PHP 7 scalar type hinting, the types are enforced for each
    item, making your software more robust. You can verify that by putting a string
    in the array used for the `max2` method.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用PHP 7标量类型提示，每个项目的类型都会被强制执行，使您的软件更加健壮。您可以通过将字符串放入用于`max2`方法的数组来验证这一点。
- en: You can unit test the function that you are passing to the `array_reduce` method,
    or the `array_map` and `array_filter` functions for that matter, to ensure its
    correctness.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以对传递给`array_reduce`方法的函数进行单元测试，或者对`array_map`和`array_filter`函数进行测试，以确保其正确性。
- en: You could distribute the reducing of a big array between multiple threads or
    network nodes if you have such an architecture. This would be a lot harder with
    a `foreach` loop.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您有这样的架构，您可以在多个线程或网络节点之间分发大数组的减少。这在`foreach`循环中将会更加困难。
- en: As shown with the `max3` function, this approach allows you to reuse existing
    methods instead of writing custom loops to manipulate data.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如`max3`函数所示，这种方法允许您重用现有方法，而不是编写自定义循环来操作数据。
- en: The map and filter functions using fold
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用fold的map和filter函数
- en: 'For now, our `fold` only returned simple scalar values. But nothing prevents
    us from building more complex data structures. For example, we can implement the
    map and filter functions using `fold`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的`fold`只返回简单的标量值。但没有什么能阻止我们构建更复杂的数据结构。例如，我们可以使用`fold`来实现map和filter函数：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Again, those are mostly for the purposes of demonstrating that it is possible
    to return arrays with folding. The native functions are enough if you don't need
    to manipulate more complex collections.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些大部分是为了演示使用折叠返回数组是可能的。如果您不需要操作更复杂的集合，原生函数就足够了。
- en: As an exercise for the reader, try to implement the `map_filter` or the `filter_map`
    function if you prefer, and the `array_reverse` function. You can also try writing
    head and tail methods, which return the first, respectively last, element of an
    array and are often found in functional languages.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 作为读者的练习，尝试实现`map_filter`或`filter_map`函数，如果您愿意，还可以尝试编写head和tail方法，它们分别返回数组的第一个和最后一个元素，并且通常在函数式语言中找到。
- en: As you can see, folding is really powerful and the idea behind it is central
    to a lot of functional techniques. It is why I largely prefer to talk about fold
    rather than reduce, which I find a bit reductive, pun intended.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，折叠是非常强大的，其背后的思想对许多函数式技术至关重要。这就是为什么我更喜欢谈论折叠而不是缩减，我觉得这有点简化，双关语。
- en: Before going further, make sure you understand how fold works, as it will make
    everything else much easier.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保您了解折叠的工作原理，因为这将使其他所有事情都变得更容易。
- en: Folding left and right
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 左折叠和右折叠
- en: Functional languages often implement two versions of fold, `foldl` and `foldr`.
    The difference is that the first folds from the left and the second from the right.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式语言通常实现了两个版本的折叠，`foldl`和`foldr`。区别在于第一个从左边折叠，第二个从右边折叠。
- en: For example, if you have the array `[1, 2, 3, 4, 5]` and you want to compute
    its sum, you can have either `(((1 + 2) + 3) + 4) + 5` or `(((5 + 4) + 3) + 2)
    + 1`. If you have an initial value, it will always be the first value used in
    the computation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有数组`[1, 2, 3, 4, 5]`，你想计算它的总和，你可以有`(((1 + 2) + 3) + 4) + 5`或`(((5 + 4)
    + 3) + 2) + 1`。如果有一个初始值，它将始终是计算中使用的第一个值。
- en: If the operation you are applying to the values is commutative, both the left
    and right variants will produce the same results. The notion of commutative operation
    comes from mathematics and is explained in [Chapter 7](ch07.html "Chapter 7. Functional
    Techniques and Topics"), *Functional Techniques and Topics*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您应用于值的操作是可交换的，左右两个变体都将产生相同的结果。可交换操作的概念来自数学，在[第7章](ch07.html "Chapter 7. Functional
    Techniques and Topics") *Functional Techniques and Topics*中有解释。
- en: For languages allowing infinite lists, such as Haskell, depending on how the
    list is generated, one of the two folds could be able to compute a value and stop.
    Also, if the language implements tail call elimination, a topic that we will discuss
    in [Chapter 7](ch07.html "Chapter 7. Functional Techniques and Topics"), *Functional
    Techniques and Topics*, choosing the right side to start the fold might avoid
    a stack overflow and allow the operation to finish.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于允许无限列表的语言，比如Haskell，取决于列表是如何生成的，两种折叠中的一种可能能够计算一个值并停止。此外，如果语言实现了尾递归消除，一个正确的折叠起始点可能会避免堆栈溢出并允许操作完成。
- en: As neither infinite list or tail call elimination is performed by PHP, there
    is, in my opinion, no reason to bother with the distinction. If you are interested,
    the `array_reduce` function folds from the left and implementing a function that
    does the same from the right should not be too complicated.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PHP不执行无限列表或尾递归消除，我认为没有理由去区分。如果您感兴趣，`array_reduce`函数从左边折叠，实现一个从右边折叠的函数不应该太复杂。
- en: The MapReduce model
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MapReduce模型
- en: You may have already heard the name the **MapReduce** programming model. At
    first, it referred to a proprietary technology developed by Google but nowadays
    there are multiple implementations in a variety of languages.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经听说过**MapReduce**编程模型的名字。起初，它指的是Google开发的专有技术，但如今在各种语言中有多种实现。
- en: Although the ideas behind MapReduce are inspired by the map and reduce functions
    we just discussed, the concept is broader. It describes a whole model to process
    large datasets using parallel and distributed algorithms on a cluster.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管MapReduce背后的思想受到我们刚讨论的map和reduce函数的启发，但这个概念更广泛。它描述了使用并行和分布式算法在集群上处理大型数据集的整个模型。
- en: Every technique you learn in this book could help you when implementing a MapReduce
    to analyze data. However, the topic is out of scope, so if you want to learn more,
    you can start with the Wikipedia page by visiting [https://en.wikipedia.org/wiki/MapReduce](https://en.wikipedia.org/wiki/MapReduce).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中学到的每一种技术都可以帮助您实现MapReduce来分析数据。然而，这个话题超出了范围，所以如果您想了解更多，可以从维基百科页面开始访问[https://en.wikipedia.org/wiki/MapReduce](https://en.wikipedia.org/wiki/MapReduce)。
- en: Convolution or zip
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卷积或zip
- en: 'Convolution, or more often zip is the process of combining each nth element
    of all given arrays. In fact, this is exactly what we did by passing null value
    to the `array_map` function before:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 卷积，或更常见的zip是将所有给定数组的每个第n个元素组合在一起的过程。事实上，这正是我们之前通过向`array_map`函数传递null值所做的：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And the output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 输出为：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It is important to note that if the arrays are of different lengths, PHP will
    use null as the padding value:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，如果数组的长度不同，PHP将使用null作为填充值：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Be aware that in most programming languages, including Haskell, Scala, and Python,
    the zip operation will, however, stop at the shortest array without padding any
    values. You can try to implement a similar function in PHP using, for example,
    the `array_slice` function to reduce all arrays to the same size before calling
    the `array_merge` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在大多数编程语言中，包括Haskell、Scala和Python，在zip操作中，将停止在最短的数组处，而不会填充任何值。您可以尝试在PHP中实现类似的功能，例如使用`array_slice`函数将所有数组减少到相同的大小，然后调用`array_merge`函数。
- en: 'We can also perform the inverse operation by creating multiple arrays from
    an array of arrays. This process is sometimes called **unzip**. Here is a naive
    implementation which is missing a lot of checks to make it robust enough for production
    use:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过从数组中创建多个数组来执行反向操作。这个过程有时被称为**unzip**。这里是一个天真的实现，缺少了很多检查，使其足够健壮用于生产：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You could use it like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样使用它：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Recursion
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: In the academic sense, recursion is the idea of dividing a problem into smaller
    instances of the same problem. For example, if you need to scan a directory recursively,
    you first scan the starting directory and then scan its children and the children's
    children. Most programming languages support recursion by allowing a function
    to call itself. This idea is often what is described as recursion.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在学术意义上，递归是将问题分解为相同问题的较小实例的想法。例如，如果您需要递归扫描一个目录，您首先扫描起始目录，然后扫描其子目录和子目录的子目录。大多数编程语言通过允许函数调用自身来支持递归。这个想法通常被描述为递归。
- en: 'Let''s see how we can scan a directory by using recursion:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用递归扫描目录：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We start by using the `scandir` function to obtain all files and directories.
    Then, if we encounter a child directory, we call the function on it again. Otherwise,
    we simply add the file to the accumulator. This function is recursive because
    it calls itself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`scandir`函数获取所有文件和目录。然后，如果遇到子目录，我们再次调用该函数。否则，我们只需将文件添加到累加器中。这个函数是递归的，因为它调用自身。
- en: You could write this using control structures, but as you don't know in advance
    what the depth of your folder hierarchy is, the code will probably be a lot messier
    and harder to understand.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用控制结构来编写这个函数，但是由于您无法预先知道文件夹层次结构的深度，代码可能会变得更加混乱和难以理解。
- en: Some books and tutorials use the Fibonacci sequence, or computing a factorial
    as recursion examples but, to be fair, those are quite poor, as they are better
    implemented using a traditional `for` loop for the second, and compute terms in
    advance for the first.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有些书籍和教程使用斐波那契数列，或计算阶乘作为递归示例，但公平地说，这些示例相当差，因为最好使用传统的“for”循环来实现第二个示例，并且对于第一个示例，提前计算项更好。
- en: 'Instead, let''s wrap our heads around a more interesting challenge, the *Hanoi
    Towers*. For those unaware of this game, the traditional version features three
    rods with discs of different sizes stacked in top of one another, the smallest
    on the top. At the beginning of the game, all discs are on the leftmost rod and
    the goal is to bring them to the rightmost one. The game obeys the following rules:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们思考一个更有趣的挑战，*Hanoi Towers*。对于不了解这个游戏的人来说，传统版本的游戏包括三根杆，上面堆叠着不同大小的圆盘，最小的在顶部。在游戏开始时，所有圆盘都在最左边的杆上，目标是将它们移到最右边的杆上。游戏遵循以下规则：
- en: Only one disc can move at a time
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只能移动一个圆盘
- en: Only the topmost disc of a rod can be moved
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能移动杆的顶部圆盘
- en: A disc cannot be placed on top of a smaller disc
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能将一个圆盘放在较小的圆盘上方
- en: 'The setup for this game looks like the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏的设置如下：
- en: '![Recursion](graphics/image_03_001.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![递归](graphics/image_03_001.jpg)'
- en: 'If we want to solve the game, the larger disc must be placed first on the last
    rod. In order to do that, we need to move all other discs to the middle rod first.
    Following this line of reasoning, we can draw three big steps that we must achieve:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想解决这个游戏，较大的圆盘必须首先放在最后一个杆上。为了做到这一点，我们需要先将所有其他圆盘移到中间的杆上。沿着这种推理方式，我们可以得出我们必须实现的三个大步骤：
- en: Move all discs but the bigger one to the middle.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有的圆盘移动到中间，除了最大的一个。
- en: Move the large disc to the right.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将大圆盘移到右边。
- en: Move all discs on top of the large one.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有圆盘移动到最大的圆盘上方。
- en: '*Steps 1* and *3* are smaller versions of the initial problem. Each of those
    steps can, in turn, be reduced to a smaller version until we have only one disc
    to move-the perfect situation for a recursive function. Let''s try implementing
    that.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤1*和*3*是初始问题的较小版本。这些步骤中的每一个又可以被缩小为更小的版本，直到我们只有一个圆盘需要移动-递归函数的完美情况。让我们尝试实现这一点。'
- en: 'To avoid cluttering our function with variables related to the rods and discs,
    we will assume the computer will give orders to someone making the moves. In our
    code, we will also assume the largest disc is number 1, smaller discs having larger
    numbers:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在我们的函数中使用与杆和圆盘相关的变量，我们将假设计算机会向某人发出移动的命令。在我们的代码中，我们还将假设最大的圆盘是编号1，较小的圆盘编号较大：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'On using the `hanoi(3, ''left'', ''right'', ''middle'')` input for the three
    discs, we get the following output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`hanoi(3, 'left', 'right', 'middle')`输入进行三个圆盘的移动，我们得到以下输出：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It takes a while to think in terms of recursion instead of using a more traditional
    loop, and obviously recursion is not a silver bullet that is better for all problems
    you are trying to solve.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 想要以递归的方式思考而不是使用更传统的循环需要一段时间，显然递归并不是解决您尝试解决的所有问题的银弹。
- en: Some functional languages have no loop structures at all, forcing you to use
    recursion. This is not the case with PHP, so let's use the right tool for the
    job. If you can think of the problem as a combination of smaller similar issues,
    usually it will be easy to use recursion. For example, trying to find an iterative
    solution to the *Towers of Hanoi* requires a lot of careful thinking. Or you could
    try to rewrite the directory scanning function using only loops to convince yourself.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数式语言根本没有循环结构，强制您使用递归。PHP不是这种情况，所以让我们使用正确的工具来解决问题。如果您能将问题视为较小类似问题的组合，通常使用递归会很容易。例如，尝试找到*Towers
    of Hanoi*的迭代解决方案需要仔细思考。或者您可以尝试仅使用循环来重写目录扫描函数，以说服自己。
- en: 'Some other areas where recursion is useful are:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 递归有用的其他领域包括：
- en: Generating the data structure for a menu with multiple levels
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成具有多个级别的菜单的数据结构
- en: Traversing an XML document
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历XML文档
- en: Rendering a series of CMS components that could contain child components
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染一系列可能包含子组件的CMS组件
- en: A good rule of thumb is to try recursion when your data has a tree-like structure
    with a root node and children.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的经验法则是，当您的数据具有树状结构，具有根节点和子节点时，尝试使用递归。
- en: Although often easier to read, once you have gotten to grip with it, recursion
    comes with a memory cost. In most applications, you should not encounter any difficulties,
    but we will discuss the topic further in [Chapter 10](ch10.html "Chapter 10. PHP
    Frameworks and FP"), *PHP Frameworks and FP*, and present some methods to avoid
    those issues.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管阅读起来通常更容易，但一旦您掌握了它，递归就会带来内存成本。在大多数应用程序中，您不应遇到任何困难，但我们将在[第10章](ch10.html "第10章。PHP框架和FP")中进一步讨论这个话题，*PHP框架和FP*，并提出一些避免这些问题的方法。
- en: Recursion and loops
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归和循环
- en: Some functional languages, such as Haskell, do not have any loop structure.
    This means the only way to iterate over a data structure is to use recursion.
    Although it is discouraged in the functional world to use a for loop due to all
    issues that arise when you can modify the loop index, there are no real dangers
    to using a `foreach` loop, for example.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数式语言，如Haskell，没有任何循环结构。这意味着迭代数据结构的唯一方法是使用递归。虽然在函数世界中不鼓励使用for循环，因为当您可以修改循环索引时会出现所有问题，但使用`foreach`循环等并没有真正的危险。
- en: For the sake of completeness, here are some ways you can replace a loop with
    a recursive call if you want to try it or need to understand code written in another
    language without a loop construct.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，以下是一些替换循环为递归调用的方法，如果您想尝试或需要理解用另一种没有循环结构的语言编写的代码。
- en: 'Replace a `while` loop:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 替换`while`循环：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or a `for` loop:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 或者`for`循环：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, the trick is to use function parameters to pass the current
    state of the loop to the next recursion. In the case of a while loop, you pass
    the result of the condition and when you emulate a for loop, you pass the loop
    counter. Obviously, the current state of computation must also always be passed
    around.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，诀窍在于使用函数参数将循环的当前状态传递给下一个递归。在while循环的情况下，您传递条件的结果，当您模拟for循环时，您传递循环计数器。显然，计算的当前状态也必须始终传递。
- en: 'Usually, the recursion itself is done in a helper function to avoid cluttering
    the signature with optional parameters used to perform the loop. In order to keep
    the global namespace clean, this helper is declared inside the original function.
    Here is an example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，递归本身是在辅助函数中完成的，以避免在签名中使用可选参数来执行循环。为了保持全局命名空间的清洁，这个辅助函数在原始函数内声明。以下是一个示例：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice how you need to pass the variable containing the function by reference
    with the `use` keyword. This is due to a fact we already discussed. The variable
    passed to the closure is bound at the declaration time, but when the function
    is declared, the assignment has not happened yet and the variable is empty. However,
    if we pass the variable by reference, it will be updated once the assignment is
    complete and we will be able to use it as a callback inside the anonymous function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您需要使用`use`关键字通过引用传递包含函数的变量。这是由于我们已经讨论过的一个事实。传递给闭包的变量在声明时绑定，但当函数声明时，赋值尚未发生，变量为空。但是，如果我们通过引用传递变量，它将在赋值完成后更新，我们将能够在匿名函数内部使用它作为回调。
- en: Exceptions
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: Error management is one of the toughest problems you face when writing software.
    It is often difficult to decide which piece of code should treat the error. Do
    it in the low-level function and you might not have access to the facilities to
    display an error message or enough context to decide the best course of action.
    Do it higher up and this might cause havoc in your data or put the application
    into an unrecoverable state.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 错误管理是编写软件时面临的最棘手的问题之一。很难决定哪段代码应该处理错误。在低级函数中执行，您可能无法访问显示错误消息的设施或足够的上下文来决定最佳操作。在更高层次上执行可能会在数据中造成混乱或使应用程序陷入无法恢复的状态。
- en: The usual way to manage errors in OOP codebases is to use exceptions. You throw
    an exception in your library or utility code and you catch it whenever you are
    ready to manage it as you want.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程代码库中管理错误的常规方法是使用异常。您在库或实用程序代码中抛出异常，并在准备好按照您的意愿处理它时捕获它。
- en: 'Whether exception throwing and catching can be considered side effects or side
    causes is a matter for debate even among academics. There''s a variety of points
    of view. I don''t want to bore you with rhetorical arguments, so let''s stick
    to some points nearly everyone agrees upon:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常和捕获是否可以被视为副作用或副原因，甚至在学术界也是一个有争议的问题。有各种观点。我不想用修辞论证来使您感到厌烦，所以让我们坚持一些几乎每个人都同意的观点：
- en: An exception thrown by any **external source** (database access, filesystem
    errors, unavailable external resource, invalid user input, and so on) is inherently
    impure because accessing those sources is already a side cause.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由任何**外部来源**（数据库访问，文件系统错误，不可用的外部资源，无效的用户输入等）引发的异常本质上是不纯的，因为访问这些来源已经是一个副原因。
- en: An exception thrown due to a **logical error** (index out of bound, invalid
    types or data, and so on) is, usually, considered pure as it can be considered
    a valid `return` value for the function. The exception must, however, be clearly
    documented as a possible outcome.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于**逻辑错误**（索引超出范围，无效类型或数据等）引发的异常通常被认为是纯的，因为它可以被视为函数的有效`return`值。但是，异常必须清楚地记录为可能的结果。
- en: Catching an exception breaks referential transparency and thus makes any function
    with a catch block impure.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获异常会破坏引用透明性，因此任何带有catch块的函数都会变得不纯。
- en: 'The first two statements should be fairly easy to understand, but what about
    the third one? Let us start our demonstration with a short piece of code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个语句应该很容易理解，但第三个呢？让我们从一小段代码开始演示：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It''s easy to see that our call to the `some_function` function will result
    in an uncaught exception because the call to the `throw_exception` function is
    outside the `try ... catch` block. Now, if we apply the principles of referential
    transparency, we should be able to replace the `$y` parameter in the addition
    by its value. Let''s try that:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，我们对`some_function`函数的调用将导致未捕获的异常，因为对`throw_exception`函数的调用位于`try ... catch`块之外。现在，如果我们应用引用透明性的原则，我们应该能够用其值替换加法中的`$y`参数。让我们试试看：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What is the value of the `$z` parameter now and what will our function return?
    Contrary to before, we will now have a return value of `42`, clearly changing
    the outcome of calling our function. By simply trying to apply equation reasoning,
    we just proved that catching an exception can break referential transparency.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`$z`参数的值是多少，我们的函数将返回什么？与以前不同，我们现在将返回值为`42`，显然改变了调用我们的函数的结果。通过简单地尝试应用等式推理，我们刚刚证明了捕获异常可能会破坏引用透明性。
- en: What good are exceptions if you cannot catch them? Not much; this is why we
    will refrain from using them throughout the book. You could, however, consider
    them as a side effect and then apply the techniques we will see in [Chapter 6](ch06.html
    "Chapter 6.  Real-Life Monads"), *Real-Life Monads*, to manage them. Haskell,
    for example, allows throwing exceptions as long as they are caught using the IO
    Monad.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法捕获异常，那么异常有什么用呢？不多；这就是为什么在整本书中我们都会避免使用它们。然而，你可以将它们视为副作用，然后应用我们将在[第6章](ch06.html
    "第6章。真实的Monad")中看到的技术，*真实的Monad*，来管理它们。例如，Haskell允许抛出异常，只要它们使用IO Monad捕获。
- en: Another issue is cognitive burden. As soon as you use them, you cannot know
    for sure when they will be caught; they might even be displayed directly to the
    end user. This breaks the ability to reason about a piece of code on its own as
    you now have to think of what will happen higher up.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是认知负担。一旦你使用它们，你就无法确定它们何时会被捕获；它们甚至可能直接显示给最终用户。这破坏了对代码片段本身进行推理的能力，因为现在你必须考虑更高层发生的事情。
- en: This issue is usually why you hear advice such as *Use exceptions for errors
    only, not flow control*. This way, you can at least be sure that your exception
    will be used to display some kind of error instead of wondering in which state
    you put the application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是你听到诸如*仅将异常用于错误，而不是流程控制*之类的建议的原因。这样，你至少可以确定你的异常将被用来显示某种错误，而不是想知道你将应用程序置于哪种状态。
- en: PHP 7 and exceptions
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP 7和异常
- en: Even if we are discussing exceptions mostly in a negative light, let me take
    this opportunity to present the improvements that have been made in the new PHP
    version concerning the topic.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们大多数时候在负面情况下讨论异常，让我趁此机会介绍一下在新的PHP版本中关于这个主题所做的改进。
- en: Before, some type of errors would generate fatal errors or errors which would
    stop the execution of the script and display an error message. You were able to
    use the `set_error_handler` exception to define a custom handler for non-fatal
    errors and eventually continue execution.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，某些类型的错误会生成致命错误或错误，这些错误会停止脚本的执行并显示错误消息。你可以使用`set_error_handler`异常来定义一个自定义处理程序来处理非致命错误，并最终继续执行。
- en: PHP 7.0 introduces a `Throwable` interface, which is a new parent for the exception.
    The `Throwable` class also a new child called the `Error` class, which you can
    use to catch most of the errors that you weren't able to manage before. There
    are still some errors, such as parsing errors, which you can obviously not catch,
    as it means your whole PHP file is somehow invalid.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7.0引入了一个`Throwable`接口，它是异常的新父类。`Throwable`类还有一个新的子类叫做`Error`类，你可以用它来捕获以前无法处理的大多数错误。仍然有一些错误，比如解析错误，显然是无法捕获的，因为这意味着你的整个PHP文件在某种程度上是无效的。
- en: 'Let''s demonstrate this with a piece of code that tries to call a non-existing
    method on an object:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一段代码来演示这一点，试图在对象上调用一个不存在的方法：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you are using PHP 5.6 or lower, the message will say something along the
    lines of:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是PHP 5.6或更低版本，消息将会说类似于：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Using PHP 7.0, however, the message will be (emphasis is mine):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用PHP 7.0，消息将是（重点是我的）：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The difference being that PHP informs you that this is an uncaught error. This
    means you can now catch it using the usual `try ... catch` syntax. You can catch
    the `Error` class directly, or if you want to be broader and catch any possible
    exception, you can use the `Throwable` interface. However, I discourage this as
    you will lose the information about which error you have exactly:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于PHP通知你这是一个未捕获的错误。这意味着你现在可以使用通常的`try ... catch`语法来捕获它。你可以直接捕获`Error`类，或者如果你想更广泛地捕获任何可能的异常，你可以使用`Throwable`接口。然而，我不建议这样做，因为你将失去关于你究竟有哪种错误的信息：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Also interesting for us, the `TypeError` parameter is a child of the `Error`
    class which is raised when a function is called with parameters of the wrong type
    or the return type is wrong:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说也很有趣的是，`TypeError`参数是`Error`类的子类，当使用错误类型的参数调用函数或返回类型错误时会引发它：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For those wondering why a new interface was created alongside the new `Error`
    class, it is mostly for two reasons:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些想知道为什么在新的`Error`类旁边创建了一个新的接口，主要是出于两个原因：
- en: To clearly separate the `Exception` interface from what were internal engine
    errors before
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清楚地将`Exception`接口与以前的内部引擎错误分开
- en: To avoid breaking existing code catching the `Exception` interface, letting
    the developer choose whether they want to also start catching errors or not
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免破坏现有代码捕获`Exception`接口，让开发人员选择是否也要开始捕获错误
- en: Alternatives to exceptions
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常的替代方案
- en: 'As we just saw, we cannot use exceptions if we want to keep our code pure.
    What are our options for making sure we can signify an error to the caller of
    our function? We want our solution to have the following features:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，如果我们想保持代码的纯净，我们就不能使用异常。那么我们有哪些选择来确保我们可以向我们函数的调用者表示错误呢？我们希望我们的解决方案具有以下特点：
- en: Enforce error management so that no errors can bubble up to the end user
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制错误管理，以便没有错误会冒泡到最终用户
- en: Avoid boilerplate or complex code structure
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免样板或复杂的代码结构
- en: Advertised in the signature of our function
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们函数的签名中宣传
- en: Avoid any risk of mistaking the error for a correct result
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免任何将错误误认为是正确结果的风险
- en: Before presenting a solution possessing all those benefits in the next section
    of the chapter, let's have a look at various ways error management is done in
    imperative languages.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一节中，我们将介绍一个具有所有这些好处的解决方案，让我们先看看命令式语言中是如何进行错误管理的。
- en: 'In order to test the various ways, we will try to implement the `max` function
    we already used a bit earlier:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试各种方式，我们将尝试实现我们之前已经使用过的`max`函数：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Because we chose the initial value 0, if we call the function with an empty
    array, we will get the result 0\. Is 0 really the maximal value of an empty array?
    What happens if we call the version bundled with PHP, the `max([])` method?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们选择了初始值0，如果我们用一个空数组调用函数，我们将得到结果0。0真的是一个空数组的最大值吗？如果我们调用与PHP捆绑的版本，`max([])`方法会发生什么？
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Also, the value false is returned. Our version uses the value 0 as a default
    value, and we could consider false to be an error code. The PHP version also greets
    you with a warning.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还返回了false值。我们的版本使用值0作为默认值，我们可以将false视为错误代码。PHP版本还会显示警告。
- en: Now that we have a function we can improve, let us try the various options we
    have at our disposal. We will go from the worst to the best one.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有一个可以改进的函数，让我们尝试一下我们可以使用的各种选项。我们将从最差的选项到最好的选项。
- en: Logging/displaying error message
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录/显示错误消息
- en: As we just saw, PHP can display a warning message. We could also go with a message
    of level notice or error. This is probably the worst you could do because there
    is no way for the caller of your function to know something went wrong. Messages
    will only be displayed in the logs or on the screen once your application is run.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，PHP可以显示警告消息。我们也可以选择通知或错误级别的消息。这可能是您可以做的最糟糕的事情，因为调用您的函数的人无法知道发生了错误。消息只会在日志中或在应用程序运行时显示在屏幕上。
- en: Also, in some cases, an error is something you can recuperate from. Since you
    have no idea something happened, you cannot do that in this case.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在某些情况下，错误是可以恢复的。由于您不知道发生了什么，因此在这种情况下无法做到这一点。
- en: To make matters worse, PHP allows you to configure which error level gets displayed.
    In most cases, notices are just hidden, so no one will ever see that an error
    happened somewhere in the application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，PHP允许您配置显示哪个错误级别。在大多数情况下，通知只是隐藏的，所以没有人会看到应用程序中发生了错误。
- en: To be fair to PHP, there is a way to catch those warnings and notices at runtime
    using a custom error handler declared with the `set_error_handler` parameter.
    However, in order to manage errors correctly, you will have to find a way to determine
    inside the handler which is the function that generated the error and act accordingly.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，PHP有一种方法可以在运行时捕获这些警告和通知，即使用`set_error_handler`参数声明自定义错误处理程序。但是，为了正确管理错误，您必须找到一种方法在处理程序内部确定生成错误的函数，并相应地采取行动。
- en: If you have multiple functions using these kinds of messages to signal errors,
    you will soon have either a really big error handler, or a multitude of smaller
    ones, making the whole process error prone and really cumbersome.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个函数使用这些类型的消息来表示错误，您很快要么会有一个非常大的错误处理程序，要么会有很多较小的错误处理程序，这使整个过程容易出错且非常繁琐。
- en: Error codes
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误代码
- en: Error codes are a heritage from the C language, which does not have any concept
    of exception. The idea is that a function always returns a code to signify the
    status of the computation and some other way is found to pass the return value
    around. Usually, the code 0 means that all went well, and anything else is an
    error.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 错误代码是C语言的遗产，它没有任何异常的概念。这个想法是一个函数总是返回一个代码来表示计算的状态，并找到其他一些方法来传递返回值。通常，代码0表示一切顺利，其他任何代码都是错误。
- en: 'When it comes to numerical error codes, PHP has no function using them as return
    value as far as I can tell. The language has, however, a lot of functions returning
    the `false` value when an error occurred instead of the expected value. Only having
    one potential value to denote failure can lead to difficulties in transmitting
    information about what happened. For example, the documentation of the `move_uploaded_file`
    states that:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及数字错误代码时，PHP没有使用它们作为返回值的函数，据我所知。然而，该语言有很多函数在发生错误时返回`false`值，而不是预期的值。只有一个潜在值来表示失败可能会导致传递有关发生了什么的信息的困难。例如，`move_uploaded_file`的文档说明：
- en: '*Returns TRUE on success.*'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*成功返回TRUE。*'
- en: '>'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*If filename is not a valid upload file, then no action will occur, and move_uploaded_file()
    will return False.*'
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果文件名不是有效的上传文件，则不会发生任何操作，move_uploaded_file()将返回False。*'
- en: '>'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*If filename is a valid upload file, but cannot be moved for some reason, no
    action will occur, and move_uploaded_file() will return False. Additionally, a
    warning will be issued.*'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果文件名是有效的上传文件，但由于某种原因无法移动，则不会发生任何操作，move_uploaded_file()将返回False。此外，将发出警告。*'
- en: This means you will be informed when you have an error, but you are unable to
    know which category of error it is without resorting to reading the error message.
    And even then, you will lack important information, such as why the uploaded file
    is invalid, for example.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当您发生错误时会收到通知，但是除非阅读错误消息，否则您无法知道它属于哪个错误类别。即使这样，您也会缺少重要信息，例如为什么上传的文件无效。
- en: 'If we wanted to better mimic the `max` function of PHP, we could do it like
    this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想更好地模仿PHP的`max`函数，我们可以这样做：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Since now our function needs to return the false value in case of error, we've
    had to remove the type hint for the return value, thus making our signature a
    bit less self-documenting.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在我们的函数需要在发生错误时返回false值，我们不得不删除返回值的类型提示，从而使我们的签名不太自我说明。
- en: Other functions, usually those that wrap an external library, also return the
    `false` value, in case of error but have companion functions in the form `X_errno`
    and `X_error` that return more information about the error of the last function
    that was executed. A few examples would be the `curl_exec`, `curl_errno`, and
    `curl_error` functions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 其他函数，通常是包装外部库的函数，也会在发生错误时返回`false`值，但是在形式上具有`X_errno`和`X_error`的伴随函数，它们返回有关上次执行的函数的错误的更多信息。一些示例包括`curl_exec`、`curl_errno`和`curl_error`函数。
- en: 'Such helpers allow for more fine-grained error handling but come with the cognitive
    cost that you must think about them. Error management is not enforced. To further
    my point, let us note that even the example for the `curl_exec` function in the
    official documentation does not set the best practice of checking the return value:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些辅助程序允许更精细的错误处理，但代价是您必须考虑它们。错误管理不是强制的。为了进一步证明我的观点，让我们注意一下官方文档中`curl_exec`函数的示例甚至没有设置检查返回值的最佳实践：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Using the `false` value as a marker for failure also has another consequence
    in a language performing loose type casting like PHP. As stated in the aforementioned
    documentation, if you don''t perform strict equality comparison, you risk considering
    a valid return value that evaluates as false as an error:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在像PHP这样执行松散类型转换的语言中，将`false`值用作失败的标记也会产生另一个后果。正如前面的文档中所述，如果您不执行严格的相等比较，您可能会将一个作为false的有效返回值误认为是错误：
- en: '*Warning: This function may return Boolean FALSE, but may also return a non-Boolean
    value which evaluates to False. Please read the section on Boolean values for
    more information. Use the === operator for testing the return value of this function.*'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*警告：此函数可能返回布尔值FALSE，但也可能返回一个非布尔值，该值会被视为假。请阅读布尔值部分以获取更多信息。使用===运算符来测试此函数的返回值。*'
- en: PHP uses the false error code only in the case of errors but does not return
    `true`or `0` as is usually the case in C. You don't have to find a way to transmit
    the return value to the user.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: PHP仅在出现错误时使用false错误代码，但不像C语言通常情况下会返回`true`或`0`。您不必找到一种方法将返回值传递给用户。
- en: 'But if you want to implement your own function using a numerical error code
    to have the possibility of categorizing the error, you have to find a way to return
    both the code and the value. Usually, you can use one of two options:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您想要使用数字错误代码来实现自己的函数，以便有可能对错误进行分类，您必须找到一种方法来同时返回代码和值。通常，您可以使用以下两种选项之一：
- en: Using a parameter passed by reference which will hold the result; the `preg_match`
    parameter does that, for example, even if it is for different reasons. This is
    not strictly against function purity as long as the parameter is clearly identified
    as a return value.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通过引用传递的参数来保存结果；例如，`preg_match`参数就是这样做的，即使出于不同的原因。只要参数明确标识为返回值，这并不严格违背函数的纯度。
- en: Returning an array or some other data structure that can hold two or more values.
    This idea is the beginning of what we will present as our functional solution
    in the next section.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个数组或其他可以容纳两个或更多值的数据结构。这个想法是我们将在下一节中作为我们的函数解决方案的开端。
- en: Default value/null
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认值/空值
- en: A tad better than error codes when it comes to cognitive burden is the default
    value. If your function has only a reduced set of input that could result in an
    error, or if the error reason is not important, you could imagine returning a
    default value instead of specifying the error reason via an error code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在认知负担方面，与错误代码相比，默认值要好一点。如果您的函数只有一组可能导致错误的输入，或者如果错误原因不重要，您可以考虑返回一个默认值，而不是通过错误代码指定错误原因。
- en: This will, however, open a new can of worms. It is not always easy to determine
    what a good default value is and, in some cases, your default value will also
    be a valid value, making it impossible to determine whether there was an error
    or not. For example, if you get 0 as a result when calling our `max2` function,
    you cannot know whether the array is empty or contains only the value 0 and negative
    numbers.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将引发新的问题。确定一个好的默认值并不总是容易的，在某些情况下，您的默认值也将是一个有效值，这将使确定是否存在错误变得不可能。例如，如果在调用我们的`max2`函数时得到0作为结果，您无法知道数组是空的还是只包含值为0和负数。
- en: The default value could also depend on the context, in which case you will have
    to add a parameter to your function so that you can also specify the default value
    when calling it. Besides making the function signature bigger, this also defeats
    some performance optimization we will learn later on and, although being totally
    pure and referentially transparent, increases the cognitive burden.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值也可能取决于上下文，这种情况下，您将不得不向函数添加一个参数，以便在调用时也可以指定默认值。除了使函数签名变得更大之外，这也会破坏我们稍后将学习的一些性能优化，并且，尽管完全纯净和引用透明，但会增加认知负担。
- en: 'Let''s add a default value parameter to our `max` function:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的`max`函数添加一个默认值参数：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As we enforce the type of the default, we are able to restore the type hint
    for the return value. If you would like to pass anything as a default value, you
    will also have to remove the type hint.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们强制默认值的类型，我们能够恢复返回值的类型提示。如果您想将任何东西作为默认值传递，您还必须删除类型提示。
- en: To avoid some of the discussed issues, the value null is sometimes used as a
    default return value. Although not really a value, null is not categorized in
    the *error code* category as it is a perfectly valid value in some cases. Say
    you are searching for an item in a collection, what do you return if you find
    nothing?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免讨论的一些问题，有时会使用null值作为默认返回值。尽管null并不是一个真正的值，但在某些情况下，它并不属于*错误代码*类别，因为在某些情况下它是一个完全有效的值。比如说，如果你在一个集合中搜索一个项目，如果什么都没找到，你会返回什么？
- en: 'Using the null value as a possible return value has, however, two issues:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用null值作为可能的返回值有两个问题：
- en: You cannot use a return type hint as null will not be considered of the correct
    type. Also, if you plan to use the value as a parameter, it also cannot be type
    hinted or it must be optional with the value null as a default value. This forces
    you to either remove your type hints or make your parameters optional.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能将返回类型提示为null，因为null不会被视为正确类型。此外，如果您计划将该值用作参数，它也不能被类型提示，或者必须是带有null值作为默认值的可选参数。这将迫使您要么删除类型提示，要么将参数设为可选的。
- en: If your function usually returns objects, you will have to check the value for
    null, otherwise you risk what Tony Hoare called *The Billion Dollar Mistake*,
    a null pointer reference. Or, as it is reported in PHP, *Call to a member function
    XXX() on null*.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的函数通常返回对象，您将不得不检查null值，否则您将面临托尼·霍尔所说的*十亿美元错误*，即空指针引用。或者，如PHP中所述，*在null上调用成员函数XXX()*。
- en: For the anecdote, Tony Hoare is the one that introduced null value to the world
    back in 1965, because it was so easy to implement. Later on, he strongly regretted
    this decision and decided it was his billion dollar mistake. If you want to learn
    more about the reasons, I invite you to watch this talk he gave at [https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，Tony Hoare是在1965年引入空值的人，因为它很容易实现。后来，他非常后悔这个决定，并决定这是他的十亿美元错误。如果你想了解更多原因，我邀请你观看他在[https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare)上的演讲。
- en: Error handler
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理程序
- en: The last method is used a lot in the JavaScript world, where callbacks are everywhere.
    The idea is to pass an error callback each time the function is called. It can
    be even more powerful if you allow the caller to pass multiple callbacks, one
    for each kind of error that can arise.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法在JavaScript世界中被广泛使用，因为回调函数随处可见。这个想法是每次调用函数时传递一个错误回调。如果允许调用者传递多个回调，每种错误都可以有一个回调，那么它甚至可以更加强大。
- en: Although it alleviates some of the issues that the default value has, such as
    the possibility to mix up a valid value with the default one, you still need to
    pass different callbacks depending on the context, making this solution only marginally
    better.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它缓解了默认值的一些问题，比如可能将有效值与默认值混淆，但你仍然需要根据上下文传递不同的回调，使得这种解决方案只能略微好一些。
- en: 'How will this approach look for our function? Consider the following implementation:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对我们的函数会是什么样子呢？考虑以下实现：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Again, we kept the return type hint because the contract we have with our caller
    is to return an integer value. As stated in the comment, in this particular case,
    the default value as parameter will probably suffice, but in more complex situations,
    this approach provides more power.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们保留了返回类型提示，因为我们与调用者的契约是返回一个整数值。正如评论中所述，在这种特殊情况下，参数的默认值可能就足够了，但在更复杂的情况下，这种方法提供了更多的功能。
- en: 'We could also imagine passing the initial parameters to the callback along
    with information about the failure so that the error handler can act accordingly.
    In a way, this approach is a bit like the combination of everything we''ve seen
    earlier, as it allows you to:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以想象将初始参数传递给回调，同时传递有关失败的信息，以便错误处理程序可以相应地采取行动。在某种程度上，这种方法有点像我们之前看到的所有东西的组合，因为它允许你：
- en: Specify a default return value of your choice
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定你选择的默认返回值
- en: Display or log any kind of error message you want
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示或记录任何你想要的错误消息
- en: Return a more complex data structure with an error code if you so wish
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你愿意，可以返回一个更复杂的数据结构和错误代码
- en: The Option/Maybe and Either types
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Option/Maybe和Either类型
- en: As hinted before, our solution is to use a return type that contains the wanted
    value or something else in case of error. Those kinds of data structures are called
    **union types**. A union can contain values of different types, but only one at
    a time.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的解决方案是使用一个包含所需值或在出现错误时包含其他内容的返回类型。这种数据结构称为**联合类型**。联合可以包含不同类型的值，但一次只能包含一个。
- en: 'Let''s start with the easiest of both union types we will see in this chapter.
    As always, naming is a difficult thing in computer science and people came up
    with different names to designate mostly the same structure:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从本章中将要看到的两种联合类型中最简单的开始。一如既往，命名在计算机科学中是一件困难的事情，人们提出了不同的名称来指代基本上相同的结构：
- en: Haskell calls it the Maybe type, as does **Idris**
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haskell称之为Maybe类型，**Idris**也是如此
- en: Scala calls it the Option type, as does **OCaml**, **Rust**, and **ML**
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala称之为Option类型，**OCaml**、**Rust**和**ML**也是如此
- en: Since version 8, Java has an Optional type, as does Swift and the next specification
    of C++
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自Java 8以来，Java就有了Optional类型，Swift和下一个C++规范也是如此
- en: Personally, I prefer the denomination Maybe as I consider an option to be something
    else. The remainder of the book will thus use this, except when a specific library
    has a type called **Option**.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我更喜欢称之为Maybe，因为我认为选项是另一回事。因此，本书的其余部分将使用这个术语，除非特定的库有一个名为**Option**的类型。
- en: The Maybe type is special in the sense that it can either hold a value of a
    particular type or the equivalent of *nothing*, or if you prefer, the null value.
    In Haskell, those two possible values are called `Just` and `Nothing`. In Scala,
    it is `Some` and `None` because `Nothing` is already used to designate the type
    equivalent of the value null.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Maybe类型在某种意义上是特殊的，它可以保存特定类型的值，也可以是*nothing*的等价物，或者如果你愿意的话，是空值。在Haskell中，这两种可能的值被称为`Just`和`Nothing`。在Scala中，它是`Some`和`None`，因为`Nothing`已经被用来指定值null的类型等价物。
- en: Libraries implementing only a Maybe or Option type exist for PHP, and some of
    the libraries presented later in this chapter also ship with such types. But for
    the sake of correctly understanding how they work and their power, we will implement
    our own.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 只实现了Maybe或Option类型的库存在于PHP中，本章后面介绍的一些库也带有这些类型。但为了正确理解它们的工作原理和功能，我们将实现自己的类型。
- en: 'Let us reiterate our goals first:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先重申我们的目标：
- en: Enforce error management so that no errors can bubble up to the end user
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制错误管理，以便没有错误会冒泡到最终用户
- en: Avoid boilerplate or complex code structure
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免样板代码或复杂的代码结构
- en: Advertised in the signature of our function
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们函数的签名中进行广告
- en: Avoid any risk of mistaking the error for a correct result
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免任何错误被误认为是正确的结果
- en: 'If you type hint your function return value using the type that we will create
    in a few moments, you are taking care of our third goal. The presence of two distinct
    possibilities, the `Just` and `Nothing` values, ensure that you cannot mistake
    a valid result for an error. To make sure we don''t end up with an erroneous value
    somewhere along the line, we must ensure that we cannot get a value from our new
    type without specifying a default if it is the `Nothing` value. And, concerning
    our second goal, we will see if we can write something nice:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用我们将在接下来创建的类型对函数返回值进行类型提示，那么您已经照顾到了我们的第三个目标。`Just`和`Nothing`值的存在确保您不会将有效结果误认为错误。为了确保我们不会在某个地方得到错误的值，我们必须确保在没有指定默认值的情况下，不能从我们的新类型中获取值。关于我们的第二个目标，我们将看到我们是否可以写出一些好东西：
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Our class has two static helper methods to create two instances of our soon-to-come
    child classes representing our two possible states. The Nothing value will be
    implemented as a singleton for performance reasons; since it will never hold any
    values, it is safe to do it this way.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类有两个静态辅助方法，用于创建我们即将到来的子类的两个实例，代表我们的两种可能状态。`Nothing`值将作为单例实现，出于性能原因；因为它永远不会持有任何值，这样做是安全的。
- en: 'The most important part of our class is an abstract `getOrElse` function, which
    will force anyone wanting to get a value to also pass a default that will get
    returned if we have none. This way, we can enforce that a valid value will be
    returned even in the case of error. Obviously, you could pass the value null as
    the default, since PHP has no mechanism to enforce something else, but this would be
    akin to shooting yourself in the foot:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类中最重要的部分是一个抽象的`getOrElse`函数，它将强制任何想要获取值的人也传递一个默认值，如果我们没有值则返回该默认值。这样，我们可以强制在错误的情况下返回一个有效的值。显然，您可以将null值作为默认值传递，因为PHP没有强制执行其他机制，但这就像是在自己的脚上开枪：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Our `Just` class is pretty simple; a constructor and a getter:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Just`类非常简单；一个构造函数和一个getter：
- en: '[PRE42]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you don't take the part about being a singleton into account, the `Nothing`class
    is even simpler because the `getOrElse` function will always return the default
    value no matter what. For those wondering, it is a deliberate choice to keep the
    constructor public. It has absolutely no consequences if someone wants to create
    a `Nothing` instance directly, so why bother?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不考虑成为单例的部分，`Nothing`类甚至更简单，因为`getOrElse`函数将始终返回默认值。对于那些好奇的人，保持构造函数公开是一个有意为之的选择。如果有人想直接创建`Nothing`实例，这绝对没有任何后果，那又何必费心呢？
- en: 'Let''s test our new `Maybe` type:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下我们的新的`Maybe`类型：
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Everything seems to be working great. The need for boilerplate can be improved
    though. At this point, every time you want to instantiate a new `Maybe` type,
    you need to check the value you have and choose between the `Some` and `Nothing`
    values.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一切似乎都运行得很顺利。尽管需要样板代码，但可以改进。在这一点上，每当您想要实例化一个新的`Maybe`类型时，您需要检查您拥有的值，并在`Some`和`Nothing`值之间进行选择。
- en: 'Also, it might happen that you need to apply some functions to the value before
    passing it further without knowing at this point what default value is best. As
    it would be cumbersome to get the value with some temporary default before creating
    a new `Maybe` type right behind, let''s try to fix this aspect as well:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 还可能会出现这样的情况，您需要在将值传递给下一个步骤之前对其应用一些函数，但在这一点上不知道最佳的默认值是什么。由于在创建新的`Maybe`类型之前，使用一些临时默认值获取值会很麻烦，让我们也尝试解决这个方面：
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In order to have a somewhat coherent naming for utility methods, we use the
    same name as for functions working with collections. In a way, you can consider
    a `Maybe` type like a list with either one or no value. Let''s add some other
    utility methods based on the same assumption:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使实用方法的命名有些连贯性，我们使用与处理集合的函数相同的名称。在某种程度上，您可以将`Maybe`类型视为一个只有一个或没有值的列表。让我们基于相同的假设添加一些其他实用方法：
- en: '[PRE45]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We have added three new methods to our implementation:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向我们的实现添加了三个新方法：
- en: The `orElse` method returns the current value if there is one, or the given
    value if it was `Nothing`. This allows us to easily get data from multiple possible
    sources.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElse`方法如果有值则返回当前值，如果是`Nothing`则返回给定值。这使我们能够轻松地从多个可能的来源获取数据。'
- en: The `flatMap` method applies a callable to our value but does not wrap it inside
    a Maybe class. It is the responsibility of the callable to return a Maybe class
    itself.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap`方法将一个可调用对象应用于我们的值，但不会将其包装在Maybe类中。可调用对象有责任自己返回一个Maybe类。'
- en: The `filter` method applies the given predicate to the value. If the predicate
    returns true value, we keep the value; otherwise, we return the value `Nothing`.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`方法将给定的断言应用于值。如果断言返回true值，我们保留该值；否则，我们返回`Nothing`值。'
- en: 'Now that we have implemented a working `Maybe` type, let''s see how we can
    use it to get rid of error and null management easily. Imagine we want to display
    information about the connected user in the upper-right corner of our application.
    Without a `Maybe` type, you do something like the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了一个可工作的`Maybe`类型，让我们看看如何使用它轻松摆脱错误和空值管理。假设我们想要在应用程序的右上角显示有关已连接用户的信息。如果没有`Maybe`类型，您可能会做以下操作：
- en: '[PRE46]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here, we only use the name, so we can limit ourselves to one null check. If
    we need more information from the user, the usual method is to use a pattern that
    is sometimes called the **Null object** pattern. In our case, our Null object
    will be an instance of `AnonymousUser` method:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只使用名称，因此我们可以限制自己只进行一次空值检查。如果我们需要从用户那里获取更多信息，通常的方法是使用一种有时被称为**空对象**模式的模式。在我们的情况下，我们的空对象将是`AnonymousUser`方法的一个实例：
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now let''s try to do the same with our `Maybe` type:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试使用我们的`Maybe`类型做同样的事情：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first version might not be much better, as we have had to create a new function
    to extract the name. But let's keep in mind that you could do any number of treatments
    on your object before needing to extract a final value. Also, most functional
    libraries we present later provide helper methods to get value from objects in
    a simpler way.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个版本可能不会好多少，因为我们不得不创建一个新的函数来提取名称。但让我们记住，在需要提取最终值之前，你可以对对象进行任意数量的处理。此外，我们稍后介绍的大多数函数库都提供了更简单地从对象中获取值的辅助方法。
- en: You can also easily call a chain of methods until one of them returns a value.
    Say you want to display a dashboard, but those can be redefined on a per-group
    and per-level basis. Let's compare how our two methods fare.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以轻松地调用一系列方法，直到其中一个返回一个值。比如你想显示一个仪表板，但这些可以根据每个组和每个级别重新定义。让我们比较一下我们的两种方法的表现。
- en: 'First, the null value check approach:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，空值检查方法：
- en: '[PRE49]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And now, using `Maybe` type:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`Maybe`类型：
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: I think the more readable one is easier to determine!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为更易读的那个更容易确定！
- en: 'Finally, let us demonstrate a little example on how we could chain multiple
    calls on a `Maybe` instance without having to check whether we currently have
    a value or not. The chosen example is probably a bit silly, but it shows what
    is possible:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们演示一个小例子，说明我们如何可以在`Maybe`实例上链式调用多个调用，而无需检查我们当前是否有值。所选择的例子可能有点愚蠢，但它展示了可能的情况：
- en: '[PRE51]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The power of our `Maybe` type is that we have never had to consider whether
    the instance contained a value. We were just able to apply functions to it until
    finally, extracting the final value with the `getOrElse` method.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Maybe`类型的强大之处在于，我们从未考虑过实例是否包含值。我们只能将函数应用于它，直到最后，使用`getOrElse`方法提取最终值。
- en: Lifting functions
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升函数
- en: We have seen the power of our new `Maybe` type. But the fact is, you either
    don't have time to rewrite all your existing functions to support it or you simply
    cannot because those are in an external third party.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了我们新的`Maybe`类型的强大之处。但事实是，你要么没有时间重写所有现有的函数来支持它，要么根本无法这样做，因为它们是外部第三方的。
- en: Fortunately, you can **lift** a function to create a new function that takes
    a `Maybe`type as a parameter, applies to the original function to its value, and
    returns the modified `Maybe` type.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以**提升**一个函数，创建一个新的函数，它以`Maybe`类型作为参数，将原始函数应用于其值，并返回修改后的`Maybe`类型。
- en: 'For this, we will need a new helper function. In order to keep things more
    or less simple, we will also assume that, if any of the parameters of the lifted
    function evaluate to the value `Nothing`, we will simply return nothing:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将需要一个新的辅助函数。为了保持事情相对简单，我们还将假设，如果提升函数的任何参数的值评估为`Nothing`，我们将简单地返回`Nothing`：
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s try it:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试：
- en: '[PRE53]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can now lift any function so that it can accept our new `Maybe` type. The
    only consideration to have is that it will not work if you want to rely on any
    optional parameter of your function.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以提升任何函数，以便它可以接受我们的新`Maybe`类型。唯一需要考虑的是，如果你想依赖函数的任何可选参数，它将不起作用。
- en: We could use reflection or other means to determine whether the function has
    an optional value or pass some default to the lifted functions, but this will
    only complicate things and make our function slower. If you need to use a function
    with optional parameters and `Maybe` types, you can rewrite it or make a custom
    wrapper for it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用反射或其他手段来确定函数是否具有可选值，或者将一些默认值传递给提升的函数，但这只会使事情变得更加复杂，并使我们的函数变得更慢。如果你需要使用带有可选参数和`Maybe`类型的函数，你可以重写它或为它制作一个自定义包装器。
- en: As a closing note, the process of lifting is not reserved to Maybe types. You
    can lift any function to accept any kind of container type. A better name for
    our helper will probably be **liftMaybe** or we could add it as a static method
    on our `Maybe` class to make things clearer.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，提升的过程并不局限于Maybe类型。你可以提升任何函数以接受任何类型的容器。我们的辅助程序更好的名称可能是**liftMaybe**，或者我们可以将其添加为`Maybe`类的静态方法，以使事情更清晰。
- en: The Either type
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Either类型
- en: The `Either` type is a generalization of our `Maybe` type. Instead of having
    a value and nothing, you have a left and right value. As it is also a union type,
    only one of these two possible values can be set at any given time.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either`类型是我们`Maybe`类型的泛化。与其有值和无值不同，你有左值和右值。由于它也是一个联合类型，这两种可能的值中只能有一个在任何给定时间被设置。'
- en: The `Maybe` type works well when there is only a few sources of errors or when
    the error in itself does not matter. With the `Either` type, we can provide any
    kind of information we want in case of error through the left value. The right
    value is used for success because of the obvious wordplay.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有少数错误来源或错误本身并不重要时，`Maybe`类型的工作效果很好。使用`Either`类型，我们可以通过左值提供任何我们想要的错误信息。右值用于成功，因为这是一个明显的双关语。
- en: 'Here is a simple implementation of `Either` type. Since the code in itself
    is pretty boring, only the base class is presented in the book. You can access
    both child classes on the Packt website:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Either`类型的一个简单实现。由于代码本身相当无聊，书中只介绍了基类。你可以在Packt网站上访问两个子类：
- en: '[PRE54]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The implementation proposes the same API as the one we have for `Maybe` class,
    assuming that the right value is the valid one. You should be able to use the
    `Either` class instead of the `Maybe` class, everywhere without having to change
    your logic. The only difference is the methods to check which case we are in,
    and change the method to the new `getRight` or `getLeft` method.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现提议与我们为`Maybe`类提供的API相同，假设右值是有效的。你应该能够在不改变逻辑的情况下，到处使用`Either`类而不是`Maybe`类。唯一的区别是检查我们处于哪种情况的方法，并将方法更改为新的`getRight`或`getLeft`方法。
- en: 'It is also possible to write lift for our new type:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以为我们的新类型编写提升：
- en: '[PRE55]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This function is, however, a bit less useful than a custom wrapper because you
    cannot specify an error message that is specific to the possible errors.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个函数比自定义包装器要少一些用处，因为你无法指定一个特定于可能的错误的错误消息。
- en: Libraries
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图书馆
- en: Now that we covered the basics of the functional techniques with the various
    functions already available in PHP, it's time to have a look at the various libraries
    that will allow us to concentrate on our business code, instead of writing helpers
    and utility functions, as we did with our new `Maybe` and `Either` types.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了PHP中已有的各种功能性技术的基础知识，是时候看看各种库了，这些库将使我们能够专注于我们的业务代码，而不是编写辅助函数和实用程序函数，就像我们使用新的`Maybe`和`Either`类型一样。
- en: The functional-php library
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能性PHP库
- en: The `functional-php` library is probably one of the oldest libraries related
    to functional programming for PHP, as its first release dates back to June 2011\.
    It evolved nicely with the newest PHP version and even switched to Composer last
    year for distribution.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`functional-php`库可能是与PHP相关的功能性编程中最古老的库之一，因为它的第一个版本可以追溯到2011年6月。它与最新的PHP版本良好地发展，并且甚至去年切换到了Composer进行分发。'
- en: 'The code is available on GitHub at [https://github.com/lstrojny/functional-php](https://github.com/lstrojny/functional-php).
    It should be fairly easy to install if you are accustomed to using Composer by
    writing the following command:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码可在GitHub上找到[https://github.com/lstrojny/functional-php](https://github.com/lstrojny/functional-php)。如果您习惯使用Composer，安装应该非常容易，只需写入以下命令：
- en: '[PRE56]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The library used to be implemented both in PHP and as part of a C extension
    for performance reasons. But recent improvements of the PHP core regarding speed
    and the burden of maintaining two codebases made the extension obsolete.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 该库曾经在PHP中实现，并作为C扩展的一部分出于性能原因。但是，由于PHP核心在速度方面的最新改进以及维护两个代码库的负担，该扩展已经过时。
- en: A lot of helper functions are implemented-we won't have enough space to go into
    the details of each of them right now. If you are interested, you can have a look
    at the documentation. We will, however, quickly present the important ones and
    the rest of the book will contain examples using more of them.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了许多辅助函数-我们现在没有足够的空间详细介绍每一个。如果您感兴趣，可以查看文档。但是，我们将快速介绍重要的函数，本书的其余部分将包含更多的示例。
- en: Also, we haven't yet discussed some concepts covered by the library-related
    functions will be presented as we tackle those topics.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还没有讨论库相关函数涵盖的一些概念，我们将在处理这些主题时进行介绍。
- en: How to use the functions
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何使用这些函数
- en: 'As already discussed in [Chapter 1](ch01.html "Chapter 1. Functions as First
    Class Citizens in PHP"), *Functions as First-Class Citizens in PHP*, since PHP
    5.6, you can import a function from a namespace. This is the easiest way to use
    the library. You can also import the whole namespace and prefix all functions
    when calling them:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第1章](ch01.html "第1章。PHP中的一等公民函数")中已经讨论的那样，自PHP 5.6以来，您可以从命名空间导入函数。这是使用该库的最简单方法。您还可以导入整个命名空间，并在调用函数时添加前缀：
- en: '[PRE57]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It is also important to note that most functions accept arrays and anything
    implementing the `Traversable` interface, such as iterators.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，大多数函数接受数组和实现`Traversable`接口的任何内容，例如迭代器。
- en: General helpers
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用辅助函数
- en: 'Those functions can help you in a variety of contexts, not only functional
    ones:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以帮助您在各种情境下，而不仅仅是在功能性方面：
- en: The `true` and `false` functions check whether all elements in a collection
    are either strictly True or strictly False.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true`和`false`函数检查集合中的所有元素是否严格为True或严格为False。'
- en: The `truthy` and `falsy` functions are same as before but the comparison is
    not strict.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`truthy`和`falsy`函数与以前相同，但比较不是严格的。'
- en: The `const_function` function returns a new function that will always return
    the given value. This could be used to simulate immutable data.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const_function`函数返回一个新函数，该函数将始终返回给定值。这可以用于模拟不可变数据。'
- en: Extending PHP functions
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展PHP函数
- en: 'PHP functions have a tendency to work only on *real* arrays. The following
    functions extend their behavior to anything that can be iterated over using a
    `foreach` loop. The order of parameters is also kept the same across all functions:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: PHP函数倾向于仅在*真实*数组上工作。以下函数将它们的行为扩展到任何可以使用`foreach`循环进行迭代的内容。所有函数的参数顺序也保持一致：
- en: The contains method checks whether the value is contained in the given collection.
    The third parameter controls whether the comparison should be strict or not.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains`方法检查给定集合中是否包含该值。第三个参数控制比较是否应该是严格的。'
- en: The `sort` method sorts a collection but returns a new array instead of sorting
    by reference. You can decide to preserve the keys or not.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort`方法对集合进行排序，但返回一个新数组，而不是通过引用进行排序。您可以决定是否保留键。'
- en: The `map` method extends the `array_map` method behavior to all collections.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`方法将`array_map`方法的行为扩展到所有集合。'
- en: The sum, maximum, and minimum methods perform the same job as their PHP counterparts
    but on any type of collection. Besides those, the library also contains product,
    ratio, difference, and average.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum`、`maximum`和`minimum`方法在任何类型的集合上执行与它们的PHP对应方法相同的工作。除此之外，该库还包含product、ratio、difference和average。'
- en: The zip method performs the same work as the `array_map` method when you don't
    pass it a function. You can, however, also pass a callback to determine how the
    various items should be merged.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您不传递函数时，`zip`方法执行与`array_map`方法相同的工作。但是，您也可以传递回调函数来确定如何合并各个项目。
- en: The `reduce_left` and `reduce_right` methods fold collections either from the
    left or the right.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce_left`和`reduce_right`方法从左侧或右侧折叠集合。'
- en: Working with predicates
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用谓词
- en: 'When working with collections, you often want to check whether some, all, or
    no elements verify a certain condition and act accordingly. In order to do so,
    you can use the following functions:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理集合时，通常希望检查某些、全部或没有元素是否满足某个条件，并相应地采取行动。为了做到这一点，您可以使用以下函数：
- en: The `every` function returns the true value if all elements of a collection
    are valid for the predicate
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`every`函数如果集合的所有元素都对谓词有效，则返回true值'
- en: The `some` function returns the value true if at least one element is valid
    for the predicate
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`some`函数如果至少有一个元素对谓词有效，则返回true值'
- en: The `none` function returns the value true if no elements at all are valid for
    the predicate
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`函数如果没有元素对于谓词有效，则返回true'
- en: 'Those functions won''t modify the collections. They are only to check whether
    the elements match a certain condition or not. If you need to filter some elements,
    you can use the following helpers:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数不会修改集合。它们只是检查元素是否符合某个条件。如果需要过滤一些元素，可以使用以下辅助函数：
- en: The `select` or `filter` functions return only the elements that are valid for
    the predicate.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select`或`filter`函数仅返回对于谓词有效的元素。'
- en: The `reject` function returns only the elements that are invalid for the predicate.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reject`函数仅返回对于谓词无效的元素。'
- en: The first or `head` function return the first element that is valid for the
    predicate.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`head`函数返回对于谓词有效的第一个元素。'
- en: The last function returns the last element that is valid for the predicate.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个函数返回对于谓词有效的最后一个元素。
- en: The `drop_first` function removes elements from the beginning of the collection
    until the given callback is `true`. As soon as the callback returns false, stop
    removing elements.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drop_first`函数从集合的开头删除元素，直到给定的回调为`true`。一旦回调返回false，停止删除元素。'
- en: The `drop_last` function is the same as the previous function, but starts at
    the end.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drop_last`函数与上一个函数相同，但是从末尾开始。'
- en: All those functions return a new array, leaving the original collection untouched.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都返回一个新的数组，原始集合保持不变。
- en: Invoking functions
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用函数
- en: 'It is cumbersome to declare an anonymous function as soon as you want to invoke
    a function in a callback. Those helpers will do exactly that for you with a simpler
    syntax:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想在回调中调用函数时，声明匿名函数是很麻烦的。这些辅助函数将为您提供更简单的语法：
- en: The `invoke` helper invokes a method on all objects in a collection and returns
    a new collection with the result
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invoke`辅助函数在集合中的所有对象上调用方法，并返回具有结果的新集合'
- en: The `invoke_first` and `invoke_last` helpers invoke a method on the first and
    last object of a collection, respectively
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invoke_first`和`invoke_last`辅助函数分别在集合的第一个和最后一个对象上调用方法'
- en: The `invoke_if` helper invokes the given method on the first parameter if it
    is a valid object. You can pass the method parameters and a default value.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invoke_if`辅助函数如果第一个参数是有效对象，则调用给定的方法。您可以传递方法参数和默认值。'
- en: The `invoker` helper returns a new callable that invokes the given method with
    the given parameters to its parameter.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invoker`辅助函数返回一个新的可调用对象，它使用给定的参数调用给定的方法。'
- en: 'You might also want to call a function until you obtain a value or some threshold
    is reached. The library''s got you covered:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还希望调用函数，直到获得一个值或达到某个阈值。该库已经为您做好了准备：
- en: The `retry` library calls a function until it stops returning an exception or
    the number of tries is reached
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retry`库调用函数，直到它停止返回异常或达到尝试次数'
- en: The `poll` library calls the function until it returns the truthy value or a
    given timeout is reached
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poll`库调用函数，直到它返回真值或达到给定的超时时间'
- en: Manipulating data
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作数据
- en: 'The previous functions group was about invoking functions with helpers; this
    one is about getting and manipulating data without having to resort to an anonymous
    function each time:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的函数组是关于使用辅助函数调用函数；这个函数组是关于获取和操作数据，而不必每次都求助于匿名函数：
- en: The `pluck` function fetches a property from all objects in a given collection
    and returns a new collection with the values.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pluck`函数从给定集合中的所有对象中提取属性，并返回具有这些值的新集合。'
- en: The `pick` function selects an element from an array based on the given key.
    You can provide a default value if the element does not exist.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pick`函数根据给定的键从数组中选择一个元素。如果元素不存在，可以提供默认值。'
- en: The `first_index_of` and `last_index_of` functions return the first, respectively
    last, index of an element matching the given value.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first_index_of`和`last_index_of`函数分别返回匹配给定值的元素的第一个和最后一个索引。'
- en: The `indexes_of` function returns all indexes matching the given value.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexes_of`函数返回所有匹配给定值的索引。'
- en: The `flatten` function reduces the depth of nested collection to a single flat
    collection.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatten`函数将嵌套集合的深度减少为单个平面集合。'
- en: 'Sometimes, you also want to separate a collection into multiple parts, either
    given a predicate or some grouping value:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您也希望根据谓词或某个分组值将集合分成多个部分：
- en: The `partition` method accepts a list of predicates-each item of the collection
    is put in a given group based on the first predicate for which it is valid
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partition`方法接受一组谓词-根据第一个谓词的有效性，将集合的每个项目放入给定的组中。'
- en: The `group` method creates multiple groups based on each different value returned
    by the callback for each element
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group`方法根据每个元素的回调返回的每个不同值创建多个组'
- en: Wrapping up
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: As you can see, the `functional-php` library offers a lot of different helpers
    and utility functions. It might not be obvious how you can get the most of all
    of them right now, but I hope the remainder of the book will give you a glimpse
    of what you can achieve.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`functional-php`库提供了许多不同的辅助函数和实用函数。现在可能不明显您如何充分利用它们，但我希望本书的剩余部分能让您一窥您可以实现的内容。
- en: Also, do not forget that we didn't present all functions as some of them need
    a bit of theoretical explanation first. All in due time.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，不要忘记我们没有介绍所有的函数，因为其中一些需要一点理论解释。一切都在适当的时间。
- en: The php-option library
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: php-option库
- en: 'We created our own version of the `Maybe` type earlier. This library proposes
    a more complete implementation. The naming used by Scala was chosen, however.
    The source code is on GitHub at [https://github.com/schmittjoh/php-option](https://github.com/schmittjoh/php-option).
    The easiest way to install is to by writing the following command using Composer:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建了自己版本的`Maybe`类型。这个库提出了一个更完整的实现。选择了Scala使用的命名，然而。源代码在GitHub上[https://github.com/schmittjoh/php-option](https://github.com/schmittjoh/php-option)。最简单的安装方法是使用Composer写入以下命令：
- en: '[PRE58]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: An interesting addition is the `LazyOption` method, which takes a callback instead
    of a value. The callback will be executed only when a value is needed. This is
    particularly interesting when you use the `orElse` method to give alternatives
    in case the previous one is an invalid value. By using the `LazyOption` method
    in this case, you avoid doing unnecessary computation as soon as one value is
    valid.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的补充是`LazyOption`方法，它接受一个回调而不是一个值。只有在需要值时才会执行回调。当您使用`orElse`方法为前一个无效值提供替代时，这是特别有趣的。在这种情况下使用`LazyOption`方法，可以避免在一个值有效时进行不必要的计算。
- en: You also have various helpers to help you call methods only if the value is
    valid, for example, and there are multiple instantiation possibilities offered.
    The library also provides an API even more akin to the one you are accustomed
    to for a collection.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用各种辅助程序来帮助您仅在值有效时调用方法，例如，还提供了多种实例化可能性。该库还提供了一个API，更类似于您习惯于集合的API。
- en: Laravel collections
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Laravel集合
- en: As already mentioned in the first chapter, Laravel offers a great library to
    manage collections. It declares a class called `Collection` which is used internally
    by their ORM, **Eloquent**, and most of the other parts relying on collections.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如第一章所述，Laravel提供了一个很好的库来管理集合。它声明了一个名为`Collection`的类，该类在其ORM **Eloquent**和大多数其他依赖于集合的部分内部使用。
- en: Internally, a simple array is used, but it is wrapped in a way that promotes
    immutability of the data and a functional approach manipulating data. To achieve
    this goal, between 60 and 70 methods are proposed to the developer.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，使用了一个简单的数组，但以一种促进数据的不可变性和功能性方法来包装它。为了实现这个目标，为开发人员提供了60到70种方法。
- en: If you are already using Laravel, you are probably already familiar with the
    possibilities offered by this support class. If you are using any other framework,
    you can still benefit from it by getting the extracted part from [https://github.com/tightenco/collect](https://github.com/tightenco/collect).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在使用Laravel，您可能已经熟悉此支持类提供的可能性。如果您正在使用其他任何框架，仍然可以从中受益，方法是从[https://github.com/tightenco/collect](https://github.com/tightenco/collect)获取提取的部分。
- en: The documentation is available on Laravel's official website at [https://laravel.com/docs/collections](https://laravel.com/docs/collections).
    We won't describe each method in detail as there are a lot of them. If you are
    using Laravel and want to learn more about all the possibilities offered by its
    collections, you can head over to [https://adamwathan.me/refactoring-to-collections/](https://adamwathan.me/refactoring-to-collections/).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可在Laravel官方网站[https://laravel.com/docs/collections](https://laravel.com/docs/collections)上找到。我们不会详细描述每个方法，因为它们有很多。如果您正在使用Laravel并想了解其集合提供的所有可能性，可以前往[https://adamwathan.me/refactoring-to-collections/](https://adamwathan.me/refactoring-to-collections/)。
- en: Working with Laravel's Collections
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Laravel的集合
- en: 'The first step is to transform your array or `Traversable` interface to an
    instance of the `Collection` class using the collect utility function. You will
    then have access to all the various methods the class provides. Let''s make a
    quick list of those that we have already encountered in another form so far:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用collect实用程序函数将数组或`Traversable`接口转换为`Collection`类的实例。然后您将可以访问类提供的各种方法。让我们快速列出到目前为止我们已经以另一种形式遇到的那些方法：
- en: The `map` method applies a function to all elements and returns the new value
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`方法将函数应用于所有元素并返回新值'
- en: The `filter` method filters the collection using a predicate
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`方法使用谓词过滤集合'
- en: The `reduce` method folds the collection using the given callback
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce`方法使用给定的回调函数折叠集合'
- en: The `pluck` gets a given property from all elements
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pluck`方法从所有元素中获取给定的属性'
- en: The `groupBy` method partitions the collection using the given value from each
    element
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupBy`方法使用每个元素的给定值对集合进行分区'
- en: All those methods return a new instance of the `Collection` class, preserving
    the values of your original instance.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都返回`Collection`类的新实例，保留原始实例的值。
- en: Once you are done manipulating, you can get the current values as an array using
    all method.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 完成操作后，您可以使用all方法将当前值作为数组获取。
- en: The immutable-php library
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: immutable-php库
- en: This library proposing an immutable data structure is born due to various gripes
    with the `SplFixedArray` method from the **Standard PHP** Library, mostly with
    its hard-to-use API. At its core, the `immutable-php` library uses the aforementioned
    data structure, but with a nice set of methods to wrap it.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提出不可变数据结构的库是由于对**标准PHP**库中的`SplFixedArray`方法的各种抱怨，主要是其难以使用的API。在其核心，`immutable-php`库使用前面提到的数据结构，但使用一组很好的方法来包装它。
- en: The `SplFixedArray` method is a specific implementation of an array with a fixed
    size and which allows only numerical indexes. Those constraints allow for a really
    fast array structure.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`SplFixedArray`方法是一个具有固定大小并且只允许数字索引的数组的特定实现。这些约束允许实现一个非常快速的数组结构。'
- en: 'You can have a look on the GitHub project page at [https://github.com/jkoudys/immutable.php](https://github.com/jkoudys/immutable.php) 
    or install it by writing the following command using Composer:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub项目页面[https://github.com/jkoudys/immutable.php](https://github.com/jkoudys/immutable.php)上查看或通过使用Composer编写以下命令来安装它：
- en: '[PRE59]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Using immutable.php
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用immutable.php
- en: Creating a new instance is really easy using the dedicated static helpers `fromArray`
    or `fromItems` for any instance of the `Traversable` class. Your newly created
    `ImmArray` instance can be accessed like any array, iterated over using `foreach`
    loop, and counted using the `count` method. However, if you try to set a value,
    you will be rewarded with an exception.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 使用专用的静态助手`fromArray`或`fromItems`为`Traversable`类的任何实例创建新实例非常容易。您新创建的`ImmArray`实例可以像任何数组一样访问，使用`foreach`循环进行迭代，并使用`count`方法进行计数。但是，如果尝试设置一个值，将会收到异常。
- en: 'Once you have your immutable array, you can have various methods to apply the
    transformations you should now be accustomed to:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了不可变数组，你可以使用各种方法来应用你现在应该习惯的转换：
- en: The `map` method to apply a function to all items and return the new value
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map` 方法将函数应用于所有项目并返回新值'
- en: The `filter` method to create a new array with only items valid for the predicate
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter` 方法创建仅包含谓词有效项目的新数组'
- en: The `reduce` method to fold items using a callback
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce` 方法使用回调折叠项目'
- en: 'You also have other helpers:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有其他帮手：
- en: The `join` method concatenates a collection of strings
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join` 方法连接字符串集合'
- en: The `sort` method returns a collection sorted using the given callback
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort` 方法使用给定的回调返回排序后的集合'
- en: Your data can also easily be retrieved as a traditional array or encoded to
    a JSON format.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你的数据也可以很容易地以传统数组形式检索或编码为 JSON 格式。
- en: All in all, this library provides fewer methods than Laravel's Collection but
    you will have better performance and a much lower memory footprint.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这个库提供的方法比 Laravel 的 Collection 更少，但性能更好，内存占用更低。
- en: Other libraries
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他库
- en: Since PHP core is lacking a lot of utility functions and features to do proper
    functional programming, a lot of people started working on libraries that implement
    the missing pieces. This is the reason why you will find a lot of those if you
    start looking.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 PHP 核心缺乏很多实用函数和功能来进行适当的函数式编程，很多人开始致力于实现缺失部分的库。这就是为什么如果你开始寻找，你会发现很多这样的库。
- en: Here is an incomplete and unordered list of such libraries if those that were
    presented previously do not suit your needs.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一份不完整且无序的库列表，如果之前介绍的那些不符合你的需求。
- en: The Underscore.php library
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Underscore.php 库
- en: A variety of ports based on the API of the `Underscore.js` library exists for
    PHP. I am personally not a big fan of the `Underscore.js` libraries because the
    function parameters are often in the wrong order to perform efficient function
    composition. This point is well explained in this video at [https://www.youtube.com/watch?v=m3svKOdZijA](https://www.youtube.com/watch?v=m3svKOdZijA).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 `Underscore.js` 库的 API 存在多种用于 PHP 的端口。我个人不太喜欢 `Underscore.js` 库，因为函数参数经常顺序错误，无法有效地进行函数组合。这一点在这个视频中有很好的解释：[https://www.youtube.com/watch?v=m3svKOdZijA](https://www.youtube.com/watch?v=m3svKOdZijA)。
- en: 'However, if you are accustomed to using it, here is a short list of various
    ports:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你习惯使用它，这是一个各种端口的简短列表：
- en: '[https://github.com/brianhaveri/Underscore.php](https://github.com/brianhaveri/Underscore.php):
    The oldest port as far as I can tell. It has not seen any activity since 2012,
    but a lot of forks exist to improve compatibility with newer PHP versions and
    apply bug fixes.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/brianhaveri/Underscore.php](https://github.com/brianhaveri/Underscore.php)：据我所知，这是最古老的端口。自
    2012 年以来就没有任何活动，但存在很多分支来改进与新版本 PHP 的兼容性并修复错误。'
- en: '[https://github.com/wikiHow/Underscore.php](https://github.com/wikiHow/Underscore.php):
    One of the most maintained forks of the preceding library.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/wikiHow/Underscore.php](https://github.com/wikiHow/Underscore.php)：前述库中最受维护的分支之一。'
- en: '[https://github.com/Anahkiasen/underscore-php](https://github.com/Anahkiasen/underscore-php):
    Originally a port of its JS counterpart. It now contains some different features
    trying to respect the original philosophy.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/Anahkiasen/underscore-php](https://github.com/Anahkiasen/underscore-php)：最初是其
    JS 对应的一个端口。现在它包含一些不同的功能，试图尊重原始的哲学。'
- en: '[https://github.com/Im0rtality/Underscore](https://github.com/Im0rtality/Underscore):
    The more recent try to have something akin to the `Underscore.js` library. At
    the time of writing, the documentation is lacking some important topics and the
    library differs from the JavaScript version in quite a few places.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/Im0rtality/Underscore](https://github.com/Im0rtality/Underscore)：更近期的尝试，类似于
    `Underscore.js` 库。在撰写本文时，文档缺少一些重要主题，而且该库在很多地方与 JavaScript 版本不同。'
- en: Saber
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Saber
- en: '**Saber** is strictly following the latest PHP version as a requirement. It
    makes use of strong typing, immutable objects, and lazy evaluation. In order to
    use its various methods, you have to *box* your values inside classes supplied
    by the library. It can be cumbersome but it provides safety and reduces bugs.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**Saber** 严格遵循最新的 PHP 版本作为要求。它使用强类型、不可变对象和惰性求值。为了使用它的各种方法，你必须将你的值*装箱*到库提供的类中。这可能有些麻烦，但它提供了安全性并减少了错误。'
- en: It seems to be inspired by C# and, principally, F#, the latter being the functional
    language running on the .NET virtual machine, or **`CLR`** to call it by its real
    name. You can find the source code and documentation on GitHub at [https://github.com/bluesnowman/fphp-saber](https://github.com/bluesnowman/fphp-saber).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 它似乎受到 C# 和主要是 F# 的启发，后者是在 .NET 虚拟机上运行的函数语言，或者用其真实名称 **`CLR`** 来称呼它。你可以在 GitHub
    上找到源代码和文档：[https://github.com/bluesnowman/fphp-saber](https://github.com/bluesnowman/fphp-saber)。
- en: Rawr
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rawr
- en: '**Rawr** is not only a functional library. It tries to fix shortcomings of
    the PHP language in a more general manner. Like Saber, it provides a new class
    to box your scalar values; however, the types are used in a way that is closer
    to what Haskell does. You can also wrap your anonymous functions inside a class
    to have better typing safety around them.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rawr** 不仅仅是一个函数库。它试图以更一般的方式修复 PHP 语言的缺陷。与 Saber 一样，它提供了一个新类来装箱你的标量值；然而，类型的使用更接近
    Haskell。你还可以将你的匿名函数包装在一个类中，以在其周围获得更好的类型安全性。'
- en: The library also adds a more **Smalltalk** flavored object-orientation, Monads,
    and allows you to perform some kind of prototype-based programming as you can
    do with JavaScript.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 该库还添加了更多 **Smalltalk** 风格的面向对象、单子，并允许你执行一些类似 JavaScript 的基于原型的编程。
- en: Sadly, the library seems to be at a standstill and the documentation is not
    up to date with the source code. You can, however, find some inspiration there.
    You can find the code on GitHub at [https://github.com/haskellcamargo/rawr](https://github.com/haskellcamargo/rawr).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，该库似乎停滞不前，文档与源代码不同步。然而，您可以在那里找到一些灵感。您可以在GitHub上找到代码[https://github.com/haskellcamargo/rawr](https://github.com/haskellcamargo/rawr)。
- en: PHP Functional
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP功能性
- en: 'This library revolves mostly around the concept of Monads we will see in [Chapter
    5](ch06.html "Chapter 6.  Real-Life Monads"), *Real-life Monads*. The acknowledged
    inspiration is Haskell, from which the library implements:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库主要围绕我们将在[第5章](ch06.html "第6章。现实生活Monad")中看到的Monad的概念。承认的灵感来自Haskell，该库实现了：
- en: State Monad
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: State Monad
- en: IO Monad
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IO Monad
- en: Collection Monad
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合Monad
- en: Either Monad
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Either Monad
- en: Maybe Monad
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maybe Monad
- en: Through the `Collection` Monad, the library offers the various methods we expect
    the `map`, `reduce`, and `filter` methods.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Collection` Monad，该库提供了我们期望的各种方法`map`、`reduce`和`filter`方法。
- en: As it is inspired by Haskell, you might find it a bit more difficult to use
    in the beginning. However, it should prove more powerful in the end. You can find
    the code on GitHub at [https://github.com/widmogrod/php-functional](https://github.com/widmogrod/php-functional).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 由于受Haskell的启发，您可能会发现在开始时使用它有点困难。然而，最终它应该会更加强大。您可以在GitHub上找到代码[https://github.com/widmogrod/php-functional](https://github.com/widmogrod/php-functional)。
- en: Functional
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能性
- en: Originally created as a learning playground, this library has grown into something
    that could prove useful if you are looking for something relatively small. The
    main idea is to provide a framework so that you can remove all loops in your code.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 最初创建为一个学习游乐场，这个库已经发展成为一个相对小型但有用的东西。主要的想法是提供一个框架，以便您可以在代码中删除所有循环。
- en: The most interesting feature is that all functions can be partially applied
    without doing anything special. Partial application is really important for function
    composition. We will discover both topics in [Chapter 4](ch04.html "Chapter 4. Composing
    Functions"), *Compositing functions*.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的特点是所有函数都可以部分应用而无需进行任何特殊操作。部分应用对于函数组合非常重要。我们将在[第4章](ch04.html "第4章。组合函数")中发现这两个主题，*组合函数*。
- en: The library also has all the traditional contenders such as mapping and reducing.
    The code and documentation are available on GitHub at [https://github.com/sergiors/functional](https://github.com/sergiors/functional).
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 该库还具有所有传统的竞争者，如映射和减少。代码和文档可在GitHub上找到[https://github.com/sergiors/functional](https://github.com/sergiors/functional)。
- en: PHP functional programming Utils
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP函数式编程工具
- en: This library tries to walk the same path as the `functional-php` library, which
    we presented in the previous pages. As far as I can tell, it has, however, slightly
    fewer features as of now. It can be an interesting library for people wanting
    something a tad smaller and maybe easier to learn. The code is on GitHub at [https://github.com/daveross/functional-programming-utils](https://github.com/daveross/functional-programming-utils).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库试图走与我们在前几页中介绍的`functional-php`库相同的道路。据我所知，它目前的功能略少。对于想要更小、可能更容易学习的人来说，这可能是一个有趣的库。代码在GitHub上[https://github.com/daveross/functional-programming-utils](https://github.com/daveross/functional-programming-utils)。
- en: Non-standard PHP library
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非标准PHP库
- en: This library is not strictly a functional one. The idea is more to extend the
    standard library with various helpers and utility functions to make working with
    the collections easier.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库并不严格是一个功能性的库。这个想法更多的是通过各种辅助和实用函数来扩展标准库，以使处理集合更加容易。
- en: It contains useful features such as helpers to validate function parameters
    with ease, either with already defined constraints or custom ones. It also extends
    existing PHP functions so that they can work on anything that is `Traversable`
    interface and not just arrays.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含一些有用的功能，例如帮助轻松验证函数参数，无论是使用已定义的约束还是自定义的约束。它还扩展了现有的PHP函数，以便它们可以处理任何`Traversable`接口的内容，而不仅仅是数组。
- en: The library was created in 2014 but was nearly dead until work started going
    strong again at the end of 2015\. Now it is a possible replacement for any of
    the libraries we presented previously. If you are interested, grab the code on
    GitHub at [https://github.com/ihor/Nspl](https://github.com/ihor/Nspl).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 该库创建于2014年，但直到2015年底工作再次开始才几乎停滞不前。现在它可能是我们之前介绍的任何库的替代品。如果您感兴趣，请在GitHub上获取代码[https://github.com/ihor/Nspl](https://github.com/ihor/Nspl)。
- en: Summary
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this long chapter, we presented all the practical building blocks that we
    will use throughout the book. I hope the few examples didn't seem too dry. There
    was a lot to cover and only a limited set of pages. The following chapters will
    build on what we have learned with better examples.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一长章节中，我们介绍了我们将在整本书中使用的所有实用构建块。希望这些例子不会显得太枯燥。有很多内容要涵盖，而页面数量有限。接下来的章节将在我们学到的基础上进行更好的示例。
- en: You first read some general advice about programming in general that is especially
    important for a functional codebase. We then discovered basic functional techniques
    such as mapping, folding, filtering, and zipping, all of which are available directly
    within PHP.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先阅读了一些关于编程的一般建议，这对于功能代码库尤其重要。然后，我们发现了基本的功能技术，如映射、折叠、过滤和压缩，所有这些都可以直接在PHP中使用。
- en: The next part was a brief introduction to recursion, both a technique to solve
    a particular set of problems and to avoid using loops. In a book about a functional
    language, the topic might have deserved a whole chapter, but since PHP has various
    loop structures, it's a bit less important. Also, we will see more recursion examples
    in the following chapters.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是对递归的简要介绍，这是一种解决特定问题集的技术，也是避免使用循环的方法。在一本关于功能性语言的书中，这个主题可能值得一整章，但由于PHP有各种循环结构，它的重要性稍低一些。此外，我们将在接下来的章节中看到更多的递归示例。
- en: We also discussed exceptions and why they pose issues in a functional codebase,
    and we wrote implementations for the Maybe and Either types as a better way to
    manage errors after discussing the pros and cons of other methods.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了异常以及它们在功能代码库中引发的问题，并在讨论其他方法的利弊后，编写了Maybe和Either类型的实现，作为更好地管理错误的方法。
- en: Finally, we presented some libraries that provide functional constructs and
    helpers so that we don't have to write our own.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了一些提供功能构造和辅助功能的库，这样我们就不必自己编写了。
