- en: JavaScript and Danger-Driven Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript和危险驱动开发
- en: '*"In JavaScript, there is a beautiful, elegant, highly expressive language
    that is buried under a steaming pile of good intentions and blunders."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “在JavaScript中，有一种美丽、优雅、高度表达的语言，被一堆良好意图和失误所掩盖。”
- en: '–  Douglas Crockford, JavaScript: The Good Parts*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- Douglas Crockford，《JavaScript：精粹》'
- en: This quotation expresses essentially what optimizing JavaScript code is all
    about.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这段引语基本上表达了优化JavaScript代码的全部内容。
- en: Often fascinated by the latest shiny feature or by the need to deliberately
    or pretentiously display his own abilities, the developer's mind sometimes slips
    into a mysterious state of awaken sleep by which he is overcome by the need to
    show off overly complex code or by the desire to use the most recent features
    even though he knows, deep down, that this means that he will have to sacrifice
    long-term stability and the efficiency of his computer program. This way of building
    applications is what we might call "Danger-Driven Development". JavaScript has
    many very bad parts but has enough good parts to outweigh the bad ones. This being
    said, the problem with Danger-Driven Development is the fact that the developer
    listens to the sirens of JavaScript's awful parts at the expense of the end user’s
    satisfaction.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员常常被最新的闪亮功能所吸引，或者出于需要故意或假装展示自己的能力，他们的思维有时会陷入一种神秘的清醒睡眠状态，因此他们会被展示过于复杂的代码或者使用最新功能的欲望所克服，尽管他们心里清楚，这意味着他们将不得不牺牲长期稳定性和计算机程序的效率。这种构建应用程序的方式我们可以称之为“危险驱动开发”。JavaScript有很多非常糟糕的部分，但也有足够多的好部分来抵消坏部分。话虽如此，危险驱动开发的问题在于开发人员听从JavaScript糟糕部分的诱惑，而忽视了最终用户的满意度。
- en: In this chapter, we will cover a few of JavaScript’s best and worst parts, especially
    those that pertain to code efficiency and overall performance, and how a developer
    should always write safe, reliable and highly efficient JavaScript code even if
    doing so is not as enchanting as coding the latest shiny.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖一些JavaScript的最好和最坏的部分，特别是与代码效率和整体性能有关的部分，以及开发人员应该始终编写安全、可靠和高效的JavaScript代码，即使这样做并不像编写最新的闪亮代码那样迷人。
- en: 'Thus, we will cover the following points:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将涵盖以下几点：
- en: The global object and local variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局对象和局部变量
- en: Avoiding bad idioms and keeping an eye on the very bad parts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免不良习惯，并密切关注非常糟糕的部分
- en: Using the DOM efficiently
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效使用DOM
- en: Structuring and loading a JavaScript application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和加载JavaScript应用程序
- en: The global object and local variables
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局对象和局部变量
- en: 'JavaScript’s global object is the container of all global variables. Any top-level
    variable of any compilation unit will be stored in the global object. The global
    object is one of the worst parts of JavaScript when it is not used correctly,
    as it can easily become bloated with unneeded variables and can be unknowingly
    abused by developers when JavaScript default behavior is heavily relied upon.
    Here are two examples of such misuse:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的全局对象是所有全局变量的容器。任何编译单元的顶级变量都将存储在全局对象中。当全局对象未被正确使用时，全局对象是JavaScript中最糟糕的部分之一，因为它很容易因不需要的变量而膨胀，并且在JavaScript默认行为被大量依赖时，开发人员可能会无意中滥用它。以下是两个这种滥用的例子：
- en: When running a simple code such as `total = add(3, 4);`, you are, in fact, creating
    a property named `total` in the global object. This is not a good thing for performance
    as you might keep a lot of variables on the heap while most of them are only required
    at a certain moment of an application's execution.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当运行一个简单的代码，比如`total = add(3, 4);`，实际上是在全局对象中创建了一个名为`total`的属性。这对性能来说并不是一件好事，因为您可能会在堆上保留大量变量，而其中大部分只在应用程序执行的某个时刻需要。
- en: When neglecting to use the `new` keyword in order to create an object, JavaScript
    will execute an ordinary function call and will bind the `this` variable to the
    global object. This is a very bad thing, not only for security reasons, as it
    is possible to clobber other variables, but also for performance reasons as the
    developer might think that he is storing values in an object's properties while
    he is, in fact, storing these values in the global object directly, thus bloating
    the global object and storing these values in two different memory spaces if he
    already instantiated the desired object elsewhere in his code.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当忽略使用`new`关键字来创建对象时，JavaScript将执行普通的函数调用，并将`this`变量绑定到全局对象。这是一件非常糟糕的事情，不仅出于安全原因，因为可能会破坏其他变量，而且出于性能原因，因为开发人员可能会认为他正在将值存储在对象的属性中，而实际上，他正在直接将这些值存储在全局对象中，从而使全局对象膨胀，并在代码的其他地方已经实例化了所需的对象的情况下，在两个不同的内存空间中存储这些值。
- en: To use the global object efficiently, you should wrap all your variables in
    a single application object, apply functions to it as needed, enforce type verification
    within the functions that you are applying to the application object in order
    to make sure that it is instantiated correctly and access the global object by
    thinking of it as a sort of immutable object with a few side-effect functions
    that are the application objects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地使用全局对象，您应该将所有变量封装在一个单一的应用对象中，根据需要对其应用函数，在应用到应用对象的函数中强制执行类型验证，以确保它被正确实例化，并将全局对象视为一种不可变对象，并将其视为一种具有一些副作用函数的应用对象。
- en: Avoiding global variables
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免全局变量
- en: Global variables can be accessed for reading or writing in any scope of an application.
    They are a necessary evil. Indeed, any application needs to organize its code
    structure in order to process input values and return the appropriate response
    or output. Problems and bugs start occurring when the code is not well organized
    and when any part of the code can therefore modify the global state of the rest
    of the application and modify the program's overall expected behavior.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量可以在应用程序的任何作用域中进行读取或写入。它们是必要的恶。实际上，任何应用程序都需要组织其代码结构，以处理输入值并返回适当的响应或输出。当代码组织不良时，以及代码的任何部分因此可以修改应用程序的全局状态并修改程序的整体预期行为时，问题和错误开始出现。
- en: Firstly, poorly organized code means that the scripting engine, or interpreter,
    has more work to do when trying to look up a variable name, because it will have
    to go through many scopes until it finds it in the global scope.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，组织不良的代码意味着脚本引擎或解释器在尝试查找变量名时需要做更多的工作，因为它将不得不通过许多作用域直到在全局作用域中找到它。
- en: Secondly, poorly organized code means that the heap in memory will always be
    larger than needed to run the same functionality, since many superfluous variables
    will remain in memory until the end of the script's execution.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，组织不良的代码意味着内存中的堆总是比运行相同功能所需的堆要大，因为许多多余的变量将一直保留在内存中，直到脚本执行结束。
- en: The solution to this problem is to avoid using global variables as much as possible
    and to use namespaced variables almost all the time. Also, using locally scoped
    variables has the added advantage of making sure that variables are automatically
    unset when the local scope is lost.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是尽量避免使用全局变量，并几乎始终使用命名空间变量。此外，使用局部作用域变量的额外优势是确保在丢失局部作用域时变量会自动取消设置。
- en: 'The following example (`chap7_js_variables_1.html`) shows us how the use of
    global variables can be very problematic and ultimately very inefficient, especially
    in increasing complex applications:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例（`chap7_js_variables_1.html`）向我们展示了全局变量的使用可能非常问题，并且最终非常低效，特别是在复杂应用程序中：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The easy solution is to organize the code by using modules and namespaces.
    This is easily achieved by wrapping all variables and functions within a single
    application object in order to force a certain associated behavior when the variables
    are set or modified, and to preserve the application’s secrets from the global
    object. Closures can also be used to hide important values from the global scope.
    Let’s modify our previous script, keeping namespaces in mind this time:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的解决方案是通过使用模块和命名空间来组织代码。这可以通过将所有变量和函数包装在单个应用程序对象中来轻松实现，以强制在设置或修改变量时产生某种关联行为，并将应用程序的机密信息保留在全局对象中。闭包也可以用于隐藏全局作用域中的重要值。让我们在考虑命名空间的情况下修改我们之前的脚本：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By using the `let` keyword in this way, the developer would still obtain the
    correct value while avoiding to clobber a global variable and unintentionally
    modifying the global state of the entire application, even if he was to forget
    to use the `new` keyword. Furthermore, the global object remains lean and efficient
    by avoiding unnecessary bloat and by reducing time spent in namespace lookups
    in order to find a called function or a stored value.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式使用`let`关键字，开发人员仍然可以获得正确的值，同时避免破坏全局变量并无意中修改整个应用程序的全局状态，即使他忘记使用`new`关键字。此外，通过避免不必要的膨胀和减少在命名空间查找中花费的时间，全局对象保持精简和高效。
- en: Evaluating local variables
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估局部变量
- en: As we have seen in the previous example, omitting the `let` or `var` keyword
    in front of the declaration of a local variable makes it global. In all cases,
    functions and objects should not be able to create functional side effects by
    modifying the value of variables outside of their local scope. Thus, the `let`
    keyword should always be used when declaring variables inside the scope of a function
    or structure. For example, simply moving global variables to the local scope of
    a function that is using them within a local loop translates into almost a 30%
    increase in performance in most browsers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的示例中所看到的，省略局部变量声明前的`let`或`var`关键字会使其变成全局变量。在所有情况下，函数和对象都不应该能够通过修改其局部作用域外的变量的值来创建功能性副作用。因此，在函数或结构的作用域内声明变量时，应始终使用`let`关键字。例如，将全局变量简单地移动到在本地循环中使用它们的函数的局部作用域中，可以使大多数浏览器的性能提高近30%。
- en: Also, when declaring variables with the `let` keyword, you get to use block
    scope, which should be used as much as possible. Thus, a variable used within
    a `for` loop will not stay within scope once the loop is done. This allows for
    better variable encapsulation and isolation, more efficient garbage collection
    and better performance in general.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用`let`关键字声明变量时，可以使用块作用域，应尽可能使用。因此，在`for`循环中使用的变量在循环结束后不会保持在作用域内。这允许更好的变量封装和隔离，更有效的垃圾回收和更好的性能。
- en: One way to easily keep track of variable declarations is to use JavaScript’s
    strict mode. We will explain this ES5 feature in more detail in the next section
    of this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 轻松跟踪变量声明的一种方法是使用JavaScript的严格模式。我们将在本章的下一节中更详细地解释这个ES5特性。
- en: Avoiding bad idioms and keeping an eye on the very bad parts
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免坏习惯并注意非常糟糕的部分
- en: As with most C-based programming languages, it is best to avoid certain bad
    idioms that often cause code inefficiency and bugs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数基于C的编程语言一样，最好避免某些常见的坏习惯，这些习惯经常导致代码效率低下和错误。
- en: Bad idioms
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坏习惯
- en: 'Here are a few bad idioms that should be identified as problematic:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些应该被视为有问题的坏习惯：
- en: Declaring a variable at first use is a bad idea in JavaScript due to the fact
    that the developer will most likely give the variable global scope in order to
    access it later. It is better to organize the code from the start of the project
    and use intuitive and meaningful namespaces in order to organize the use of variables
    throughout the application.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaScript中，首次使用时声明变量是一个坏主意，因为开发人员很可能会给变量全局范围，以便以后访问它。最好从项目开始组织代码，并使用直观和有意义的命名空间，以便在整个应用程序中组织变量的使用。
- en: Using structures in a way that is not explicit or that was not originally intended
    should be avoided in all cases. For example, letting a `switch` statement fall
    through or assigning a value to a variable within the condition of a conditional
    statement are very bad idioms and should never be used.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何情况下都应该避免以不明确或原本不打算的方式使用结构。例如，让`switch`语句穿透或在条件语句的条件中给变量赋值都是非常糟糕的习惯，不应该使用。
- en: Relying on automatic semicolon insertion is a bad idea and can lead to code
    misinterpretation. It should always be avoided.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖自动分号插入是一个坏主意，可能导致代码被错误解释。应该始终避免。
- en: Trailing commas in arrays and objects is a bad idea since some browsers will
    not interpret them correctly.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和对象中的尾随逗号是一个坏主意，因为一些浏览器可能无法正确解释它们。
- en: When using a `block` statement with one single imperative line, omitting the
    curly braces should be avoided at all times.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用一个带有一个单一命令行的`block`语句时，应该始终避免省略花括号。
- en: Of course, the art of structuring code adequately relies foremost upon a good
    knowledge of the structures themselves. There are bad constructs in JavaScript
    that should be avoided at all times. Let’s take the time to look at a few.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，适当构造代码的艺术首先取决于对结构本身的良好了解。在JavaScript中有一些不好的结构应该在任何时候都避免。让我们花点时间来看看其中的一些。
- en: Bad constructs – the with statement
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不好的结构 - with语句
- en: 'One example of these bad constructs is the `with` statement. The original intention
    of the `with` statement was to help developers access object properties without
    having to type the whole namespace every time. It was intended to be a sort of
    `use` statement as we might encounter them in other languages like PHP. For example,
    you could use the `with` statement in the following way:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不好的结构之一是`with`语句。`with`语句的最初意图是帮助开发人员在不必每次键入整个命名空间的情况下访问对象属性。它旨在成为一种`use`语句，就像我们在其他语言（如PHP）中可能遇到的那样。例如，你可以以以下方式使用`with`语句：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The problem here is that, when we are looking at this code, we are not entirely
    sure that the engine is not clobbering global variables named `myVar` and `otherVar`.
    The best way to deal with long namespaces is to assign them to local variables
    and use them afterwards:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，当我们查看这段代码时，我们并不确定引擎是否会覆盖名为`myVar`和`otherVar`的全局变量。处理长命名空间的最佳方法是将它们分配给本地变量，然后在之后使用它们：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Bad constructs – the eval statement
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不好的结构 - eval语句
- en: 'Another bad one is the `eval()` statement. This statement is not only very
    inefficient, but it is, most of the time, useless. Indeed, it is often believed
    that using the `eval()` statement is the proper way to deal with a provided string.
    But this is not the case. You can simply use an array syntax to do the same thing.
    For example, we could use the `eval()` statement in the following way:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不好的例子是`eval()`语句。这个语句不仅非常低效，而且大多数时候是没有用的。事实上，人们经常认为使用`eval()`语句是处理提供的字符串的正确方式。但事实并非如此。你可以简单地使用数组语法来做同样的事情。例如，我们可以以以下方式使用`eval()`语句：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To get a substantial speed increase (from 80% to 95% faster), you could replace
    the previous code with the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得大幅度的速度提升（从80%到95%更快），你可以用以下代码替换前面的代码：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Bad constructs – the try-catch-finally construct
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不好的结构 - try-catch-finally结构
- en: It is important to note that one should avoid using the try-catch-finally construct
    inside performance-critical functions. The reason is related to the fact that
    this construct must create a runtime variable to catch the exception object. This
    runtime creation is a special case in JavaScript and not all browsers handle it
    with the same degree of efficiency, which means that this operation can cause
    trouble along the application's critical path, especially when performance is
    crucial. You can easily replace this construct with simple testing conditions
    and insert error messages in an object that would act as error registry for the
    application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，应该避免在性能关键的函数内部使用try-catch-finally结构。原因与这个结构必须创建一个运行时变量来捕获异常对象有关。这种运行时创建是JavaScript中的一个特殊情况，并非所有浏览器都以相同的效率处理它，这意味着这个操作可能会在应用程序的关键路径上造成麻烦，特别是在性能至关重要的情况下。你可以用简单的测试条件替换这个结构，并在一个对象中插入错误消息，这个对象将作为应用程序的错误注册表。
- en: Avoiding inefficient loops
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免低效的循环
- en: Nesting loops is the first thing to avoid when coding these types of structures
    in JavaScript.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套循环是在JavaScript中编写这些类型结构时要避免的第一件事。
- en: Also, most of the time, using `for-in` loops is not a good idea since the engine
    has to create a complete list of the enumerable properties, which is not very
    efficient. Most times, a `for` loop will do the job perfectly. This is particularly
    true of performance-critical functions that are found along the critical path
    of the application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，大多数情况下，使用`for-in`循环也不是一个好主意，因为引擎必须创建一个可枚举属性的完整列表，这并不是非常高效的。大多数情况下，`for`循环会完美地完成任务。这在应用程序的关键路径上找到的性能关键函数中尤其如此。
- en: 'Furthermore, beware of implicit object conversions when dealing with loops.
    Often, at first glance, it is difficult to see what is happening under the hood
    when repeatedly accessing a `length` property on an object for example. But there
    are cases where JavaScript will create an object on each iteration of a loop when
    the object is not specifically created beforehand. Please see the following code
    example (`chap7_js_loops_1.html`):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在处理循环时要注意隐式对象转换。通常，乍一看，很难看出在重复访问对象的`length`属性时发生了什么。但有些情况下，当对象没有事先被明确创建时，JavaScript会在循环的每次迭代中创建一个对象。请参阅以下代码示例（`chap7_js_loops_1.html`）：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When having a look at the console results in Google Chrome''s Developer tools,
    we get the following result:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看谷歌Chrome开发者工具中的控制台结果时，我们得到了以下结果：
- en: '![](assets/112011fe-7e2a-40e0-bd67-405ae2bd7eb2.png)Seven string objects were
    created in all, one on each iteration of the ''for'' loop'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/112011fe-7e2a-40e0-bd67-405ae2bd7eb2.png)总共创建了七个字符串对象，每次迭代都创建了一个'
- en: 'Under the hood, the JavaScript engine is actually creating a string object
    on each iteration of the loop. In order to avoid this problem, we will explicitly
    instantiate a string object before entering the loop (`chap7_js_loops_2.html`):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript引擎内部，实际上是在循环的每次迭代中创建了一个字符串对象。为了避免这个问题，我们将在进入循环之前显式实例化一个字符串对象（`chap7_js_loops_2.html`）：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The results of the new script are as shown:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 新脚本的结果如下所示：
- en: '![](assets/864545b7-6a45-4ee7-82b7-7119adb29950.png)Only one object is created
    and is shown seven times'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/864545b7-6a45-4ee7-82b7-7119adb29950.png)只创建了一个对象，并显示了七次'
- en: The console's log is now showing us the same object seven times. It is easy
    to understand how this could optimize the performance of a loop, especially when
    the loop could cause the engine to create tens, hundreds or even thousands of
    objects in order to complete its work.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台现在显示了同一个对象七次。很容易理解这如何可以优化循环的性能，特别是当循环可能导致引擎创建数十、数百甚至数千个对象以完成其工作时。
- en: Linters and strict mode
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检查工具和严格模式
- en: There are some other bad parts in JavaScript that could cause performance issues
    on some occasions. In order to keep an eye on all of these bad parts and replace
    them with JavaScript’s good parts, it is highly recommended that you use a tool
    that will allow you to find issues with a piece of code even before you run it
    for the first time. These tools are linters.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中还有一些其他不好的部分，可能会在某些情况下导致性能问题。为了密切关注所有这些不好的部分，并用JavaScript的好部分替换它们，强烈建议您使用一个工具，即使在第一次运行代码之前，也可以找到代码的问题。这些工具就是代码检查工具。
- en: '*JSLint*, *ESLint*, and *Prettier* are tools that can help you find sloppy
    code and fix it, even automatically in some cases. Some linters, such as *ESLint*,
    might even help you improve your code by reducing the number of statements, reducing
    the nesting of structures by replacing them with functions and Promises, identifying
    cyclomatic complexity—which is measuring the number of branches a single piece
    of structural code has—and maybe allowing you to replace those structural pieces
    of code with more functional ones, as we will see in the next chapter. You can
    find these tools at the following addresses:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*JSLint*、*ESLint*和*Prettier*是可以帮助您找到松散代码并修复它的工具，甚至在某些情况下可以自动修复。一些代码检查工具，如*ESLint*，甚至可以通过减少语句数量、通过函数和Promises替换结构的嵌套、识别圈复杂度（衡量单个结构代码的分支数量）来帮助您改进代码，也许还可以允许您用更功能性的代码替换这些结构性的代码，正如我们将在下一章中看到的那样。您可以在以下地址找到这些工具：'
- en: '[http://www.jslint.com/](http://www.jslint.com/)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.jslint.com/](http://www.jslint.com/)'
- en: '[https://eslint.org/](https://eslint.org/)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://eslint.org/](https://eslint.org/)'
- en: '[https://github.com/prettier/prettier](https://github.com/prettier/prettier)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/prettier/prettier](https://github.com/prettier/prettier)'
- en: An added benefit of using linters is the fact that they make JavaScript code
    compatible with ES5's strict mode. Whenever possible, strict mode should be used.
    It is as easy as adding a `use strict;` statement at the beginning of a script
    or a function in order to use it. Amongst the many benefits of using strict mode
    is a simplified mapping of variable names to variable definitions (optimized namespace
    lookups), prohibition of the `with` statement, prevention of unexpected introduction
    of variables into the current scope through the use of `eval` statements, protection
    against "boxing" (forced instantiation) of the `this` variable when it is not
    containing an object and it is passed to a function, which reduces performance
    cost considerably, and the removal of most performance preclusions, such as accessing
    the function caller’s variables and "walking" the JavaScript stack at runtime.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码检查工具的一个额外好处是它们使JavaScript代码与ES5的严格模式兼容。在可能的情况下，应该使用严格模式。只需在脚本或函数的开头添加一个`use
    strict;`语句即可使用它。使用严格模式的许多好处之一是简化变量名称与变量定义的映射（优化的命名空间查找）、禁止`with`语句、通过`eval`语句防止意外引入变量到当前作用域、保护`this`变量免受"装箱"（强制实例化）的影响，当它不包含对象并且传递给函数时，可以大大减少性能成本，并消除大多数性能限制，例如访问函数调用者的变量和在运行时"遍历"JavaScript堆栈。
- en: Many excellent books and videos on JavaScript performance have been published
    by Packt Publishing and I highly recommend that you read them in order to master
    all these fine tools.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Packt Publishing出版了许多关于JavaScript性能的优秀书籍和视频，我强烈建议您阅读它们，以掌握所有这些优秀的工具。
- en: Using the DOM efficiently
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效使用DOM
- en: '**Document Object Model** (**DOM**) manipulations remain amongst the costliest
    operations to do in JavaScript. Indeed, repaints or reflows should be kept to
    a bare minimum in order to avoid performance issues in general.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档对象模型**（**DOM**）操作仍然是JavaScript中成本最高的操作之一。事实上，应该尽量减少重绘或回流，以避免一般性能问题。'
- en: This being said though, there are other pitfalls that must be avoided in order
    to maintain the speed of a script when DOM operations are required and lead to
    repaints or reflows. These pitfalls concern how to modify the document tree, how
    to update an invisible element, how to make style changes, how to search for nodes,
    how to manage references from one document to another and what to do when inspecting
    a large number of nodes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，还有其他必须避免的陷阱，以保持脚本在需要DOM操作并导致重绘或回流时的速度。这些陷阱涉及如何修改文档树，如何更新不可见元素，如何进行样式更改，如何搜索节点，如何管理从一个文档到另一个文档的引用，以及在检查大量节点时该怎么做。
- en: Modifying the document tree
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改文档树
- en: It is important to know that making modifications while traversing the tree
    is very expensive. It is best to create a temporary collection to work on rather
    than modifying the tree directly while looping over all of its nodes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，在遍历树时进行修改是非常昂贵的。最好创建一个临时集合来处理，而不是在循环遍历所有节点时直接修改树。
- en: 'Indeed, the best approach is to use a non-displayed DOM tree fragment, to make
    all the changes at once and then, to display them all together. Here is a theoretical
    example of how this can be accomplished:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，最好的方法是使用非显示的DOM树片段，一次性进行所有更改，然后一起显示它们。以下是一个理论示例，说明如何实现这一点：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is also possible to clone an element in order to modify it completely before
    triggering a reflow of the page. The following code shows how this can be done:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以克隆一个元素，以便在触发页面回流之前完全修改它。以下代码显示了如何实现这一点：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By using these techniques, a developer would avoid some of the costliest operations
    in JavaScript in terms of performance.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些技术，开发人员可以避免JavaScript中一些性能方面最昂贵的操作。
- en: Updating an invisible element
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新不可见元素
- en: 'Another technique is to set an element''s display style to `none`. Thus, it
    will not need a repaint when its content is being changed. Here is a code example
    that shows how this can be done:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种技术是将元素的显示样式设置为`none`。因此，在更改其内容时，它不需要重绘。以下是一个显示如何实现这一点的代码示例：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is an easy and quick way to modify a node while avoiding multiple repaints
    or reflows.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种简单快速的方法，可以修改节点而避免多次重绘或回流。
- en: Making style changes
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行样式更改
- en: 'In the same way as when we mentioned how to modify many nodes at once when
    traversing the DOM tree, it is possible to make many style changes simultaneously
    on a document fragment in order to minimize the number of repaints or reflows.
    Take the following code snippet as an example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们提到如何在遍历DOM树时一次修改多个节点类似，也可以在文档片段上同时进行多个样式更改，以最小化重绘或回流的次数。以下代码片段是一个例子：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see, any number of style attributes could be modified in this way
    in order to trigger only one repaint or reflow.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，通过这种方式可以修改任意数量的样式属性，以便触发只有一个重绘或回流。
- en: Searching for nodes
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索节点
- en: 'When searching for nodes through the entire DOM, it best to use XPath to do
    so. Often, a `for` loop is used, as per the following example where `h2`, `h3`
    and `h4` elements are being searched for:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个DOM中搜索节点时，最好使用XPath来进行。通常会使用`for`循环，如下面的示例，其中正在搜索`h2`、`h3`和`h4`元素：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Instead of using this `for` loop, an XPath iterator object could be used to
    obtain the same result, only much more efficiently:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用XPath迭代器对象来获取相同的结果，只是效率更高：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using XPath with a DOM containing more than a thousand nodes will definitely
    make a difference performance-wise.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含超过一千个节点的DOM中使用XPath肯定会在性能上有所不同。
- en: Inspecting a large number of nodes
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查大量节点
- en: 'Another pitfall to avoid is trying to inspect a large number of nodes at once.
    It is much better to narrow down the search to a specific subset of nodes and
    then use built-in methods to find the desired nodes. For example, if we know that
    the node we are looking for can be found inside a specific `div` element, then
    we could use the following code example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要避免的陷阱是一次检查大量节点。更好的方法是将搜索范围缩小到特定的节点子集，然后使用内置方法找到所需的节点。例如，如果我们知道要查找的节点可以在特定的`div`元素内找到，那么我们可以使用以下代码示例：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Thus, this search will be much more efficient and return results much faster
    than if we had searched for it within a large number of nodes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这种搜索将比我们在大量节点中搜索它要高效得多，并且返回结果更快。
- en: Managing references from one document to another
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理从一个文档到另一个文档的引用
- en: When managing references to many documents within JavaScript, it is important
    to destroy these references when a document is no longer needed. For example,
    if a document was in a pop-up window, in a frame, in an inline frame or in an
    object, and the document was dismissed by the user, the document's nodes will
    remain in memory and will continue to bloat the DOM. Destroying these unused references
    can improve performance considerably.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中管理对许多文档的引用时，当不再需要文档时，销毁这些引用是很重要的。例如，如果一个文档在弹出窗口中，在框架中，在内联框架中或在对象中，并且用户关闭了文档，则文档的节点将保留在内存中，并将继续膨胀DOM。销毁这些未使用的引用可以显著提高性能。
- en: Caching DOM values
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存DOM值
- en: 'When accessing an object repeatedly, it is much more efficient to store it
    in a local variable in order to use it over and over again. For example, the following
    code makes a local copy of the grouped DOM values instead of accessing each value
    separately:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当重复访问对象时，将其存储在本地变量中以便反复使用会更有效。例如，以下代码将对分组的DOM值进行本地复制，而不是分别访问每个值：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Doing so will allow you to avoid the performance overhead associated with dynamic
    lookups.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做将使您避免与动态查找相关的性能开销。
- en: Structuring and loading a JavaScript application
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和加载JavaScript应用程序
- en: When thinking of how to structure and load a JavaScript application, it is important
    to remember certain important principles.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑如何构建和加载JavaScript应用程序时，重要的是要记住某些重要原则。
- en: Minimizing costly operations
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化昂贵的操作
- en: 'The costliest operations to do in JavaScript are:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中成本最高的操作是：
- en: Requesting a resource through network I/O
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过网络I/O请求资源
- en: Display repainting, also known as redrawing, of the web page due to dynamic
    content changes such as making an element visible
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重绘，也称为重新绘制，由于动态内容更改，例如使元素可见。
- en: Reflowing, which can be caused by a window resize
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重排，可能是由于窗口调整大小
- en: A DOM manipulation or dynamic change to the page’s styling
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOM操作或页面样式的动态更改
- en: Obviously, the bottom line is that all these operations should be kept to a
    bare minimum in order to preserve good performance in general. When working on
    a script that is executing too slowly, these are the most important elements to
    look for with Google Chrome's Timeline tool, which can be accessed through Chrome’s
    Developer tools, as mentioned in [Chapter 1](1e519ed0-2065-4d04-b589-e7af72645baa.xhtml), *Faster
    Web – Getting Started*, of this book.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，最重要的是要尽量减少所有这些操作，以保持良好的性能。在处理执行速度过慢的脚本时，这些都是要在Google Chrome的时间轴工具中查找的最重要元素，可以通过Chrome的开发者工具访问，如本书的[第1章](1e519ed0-2065-4d04-b589-e7af72645baa.xhtml) *更快的Web-入门*中所述。
- en: Cleaning up, minifying, and compressing resources
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理，缩小和压缩资源
- en: Of course, excluding unused exports from bundles, also known as tree shaking,
    minifying scripts by cleaning up dead code and then, compressing script files,
    is always a good thing when it comes to JavaScript performance, especially when
    dealing with network latency. Amongst the very good tools that will help you do
    this is *Webpack* ([https://webpack.js.org/](https://webpack.js.org/)), combined
    with the *UglifyJS* plugin ([https://github.com/webpack-contrib/uglifyjs-webpack-plugin](https://github.com/webpack-contrib/uglifyjs-webpack-plugin))
    and its compression plugin ([https://github.com/webpack-contrib/compression-webpack-plugin](https://github.com/webpack-contrib/compression-webpack-plugin)),
    which will tree-shake your code, minify your script by removing any unused or
    dead code, and compress the resulting files.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，从捆绑包中排除未使用的导出，也称为摇树，通过清理死代码来缩小脚本，然后压缩脚本文件，在处理JavaScript性能时总是一个好事，特别是在处理网络延迟时。在这方面，*Webpack*（[https://webpack.js.org/](https://webpack.js.org/)）是一个非常好的工具，结合*UglifyJS*插件（[https://github.com/webpack-contrib/uglifyjs-webpack-plugin](https://github.com/webpack-contrib/uglifyjs-webpack-plugin)）和其压缩插件（[https://github.com/webpack-contrib/compression-webpack-plugin](https://github.com/webpack-contrib/compression-webpack-plugin)），它将摇树您的代码，通过删除任何未使用或死代码来缩小您的脚本，并压缩生成的文件。
- en: 'The advantages of tree-shaking will be felt mostly when using tree shaking
    third-party dependencies. In order to better understand how to use these tools,
    it is highly recommended that you have a look at the following tutorials:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 摇树的优势主要体现在使用摇树的第三方依赖时。为了更好地理解如何使用这些工具，强烈建议您查看以下教程：
- en: '[http://2ality.com/2015/12/webpack-tree-shaking.html](http://2ality.com/2015/12/webpack-tree-shaking.html)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://2ality.com/2015/12/webpack-tree-shaking.html](http://2ality.com/2015/12/webpack-tree-shaking.html)'
- en: '[https://medium.com/@roman01la/dead-code-elimination-and-tree-shaking-in-javascript-build-systems-fb8512c86edf](https://medium.com/@roman01la/dead-code-elimination-and-tree-shaking-in-javascript-build-systems-fb8512c86edf)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://medium.com/@roman01la/dead-code-elimination-and-tree-shaking-in-javascript-build-systems-fb8512c86edf](https://medium.com/@roman01la/dead-code-elimination-and-tree-shaking-in-javascript-build-systems-fb8512c86edf)'
- en: 'Another great tool to optimize JavaScript code (tree-shake, minify, and compress) is
    Google’s *Closure*, even though it is built with Java. You will find this tool
    at the following address: [https://developers.google.com/closure/](https://developers.google.com/closure/).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优化JavaScript代码（摇树，缩小和压缩）的好工具是Google的*Closure*，尽管它是用Java构建的。您可以在以下地址找到这个工具：[https://developers.google.com/closure/](https://developers.google.com/closure/)。
- en: Loading page resources
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载页面资源
- en: It is important to avoid blocking a page's rendering when loading the script
    files in the head section of the HTML document. Scripts should always be loaded
    at the end of the body section in order to make sure that rendering will not depend
    on network latency that might occur when fetching the required JavaScript files.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML文档的头部加载脚本文件时，重要的是要避免阻塞页面的渲染。脚本应始终在body部分的末尾加载，以确保渲染不会依赖于在获取所需的JavaScript文件时可能发生的网络延迟。
- en: Also, it is important to know that it is best to place inline scripts before
    CSS stylesheets, as CSS will often prevent the scripts from running until they
    have finished downloading.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重要的是要知道最好将内联脚本放在CSS样式表之前，因为CSS通常会阻止脚本运行，直到它们完成下载。
- en: Also, splitting the script file payloads and downloading scripts asynchronously
    are all techniques that must be thought out when structuring a JavaScript application
    for performance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在为性能构建JavaScript应用程序时，拆分脚本文件负载和异步下载脚本都是必须考虑的技术。
- en: Furthermore, *Steve Souders* has written many great books and articles on boosting
    web page performance and you should read them to get more information on these
    very important techniques and principles ([https://stevesouders.com/](https://stevesouders.com/)).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，*Steve Souders*已经写了很多关于提升网页性能的优秀书籍和文章，您应该阅读这些书籍，以获取有关这些非常重要的技术和原则的更多信息（[https://stevesouders.com/](https://stevesouders.com/)）。
- en: Caching page resources
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存页面资源
- en: Another important thing to remember, as we will see in more detail in [Chapter
    9](0d522625-eba8-4884-a12e-42689458aa85.xhtml), *Boosting a Web Server's Performance*,
    is that caching techniques, both on the server side and on the client side, will
    help you significantly boost the performance of your web pages. Leveraging these
    techniques will allow you to reduce the number of requests needed to simply get
    the same JavaScript files over and over again.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件重要的事情要记住，正如我们将在[第9章](0d522625-eba8-4884-a12e-42689458aa85.xhtml) *提高Web服务器性能*中更详细地看到的，服务器端和客户端的缓存技术将帮助您显著提高网页的性能。利用这些技术将使您能够减少简单地一遍又一遍地获取相同的JavaScript文件所需的请求数量。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have covered a few of JavaScript’s best and worst parts,
    especially the pitfalls that can cause issues performance-wise. We have seen how
    coding safe, reliable and highly-efficient JavaScript code might not be as exciting
    as using the latest shiny feature or as tempting as lazy coding, but will certainly
    help any JavaScript application be a part of the Faster Web.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经涵盖了一些JavaScript的优点和缺点，特别是可能导致性能问题的陷阱。我们已经看到，编写安全、可靠和高效的JavaScript代码可能并不像使用最新的闪亮特性或懒惰编码那样令人兴奋，但肯定会帮助任何JavaScript应用程序成为更快速的Web的一部分。
- en: In the next chapter, we will see how JavaScript is increasingly becoming a functional
    language and how this programming paradigm will be a vector for performance in
    the near future. We will take a quick look at upcoming language features that
    will help improve the performance of JavaScript applications.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到JavaScript如何越来越成为一种函数式语言，以及这种编程范式将成为未来性能的一个向量。我们将快速了解即将推出的语言特性，这些特性将有助于改善JavaScript应用程序的性能。
