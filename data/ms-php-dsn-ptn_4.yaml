- en: Chapter 4. Structural Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 结构设计模式
- en: Structural design patterns provide different ways to create class structure;
    for example, this can be how we use encapsulation to create bigger objects from
    smaller ones. They exist to ease the design by allowing us to identify simple
    ways to realize these relationships between entities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 结构设计模式提供了创建类结构的不同方式；例如，这可以是我们如何使用封装来从较小的对象创建更大的对象。它们存在的目的是通过允许我们识别简单的方式来实现实体之间的关系，从而简化设计。
- en: In the last chapter, we covered how creational patterns can be used to determine
    how objects should be created; with structural patterns, we can determine the
    structure and relationship between classes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了创造模式如何用于确定如何创建对象；而结构模式可以确定类之间的结构和关系。
- en: 'After a brief note on Agile software architecture, in this chapter we will
    cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在简短介绍了敏捷软件架构之后，本章将涵盖以下主题：
- en: Decorator pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: Class Adapter pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类适配器模式
- en: Object Adapter pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象适配器模式
- en: Flyweight pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 享元模式
- en: Composite pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合模式
- en: Bridge pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接模式
- en: Proxy pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式
- en: Facade pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观模式
- en: Agile software architecture
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏捷软件架构
- en: Many organizations are leaning towards adopting an Agile form of project management.
    This bring about new concerns for the role of an architect; indeed, some view
    Agile and architecture to be in conflict. Two of the original signatories to the
    Agile manifesto, Martin Fowler and Robert Cecil Martin, have been vocally opposed
    to this idea. Indeed, Fowler is clear in clarifying the fact that while the Agile
    manifesto is hostile to large upfront design (such as the type you see in Prince2),
    Agile does not reject upfront design itself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织正在倾向于采用敏捷形式的项目管理。这给架构师的角色带来了新的关注；事实上，一些人认为敏捷和架构是相互冲突的。敏捷宣言的最初签署者之一Martin
    Fowler和Robert Cecil Martin对这一观点持有强烈反对意见。事实上，福勒明确澄清了敏捷宣言虽然对大量的事先设计（例如Prince2中看到的类型）持敌对态度，但并不排斥事先设计本身。
- en: The computer scientist, Allen Holub, has a similar view. Agile focuses on doing
    things that are important for delivering software that is useful to the user,
    ahead of software that is merely useful for the salesman. In order for software
    to be of use in the long term it must be adaptable, extendable, and maintainable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家Allen Holub也持有类似观点。敏捷侧重于做对用户有用的软件，而不是仅仅对销售人员有用的软件。为了使软件长期有用，它必须是可适应、可扩展和可维护的。
- en: Fowler also has a vision for an architect within software development teams.
    Citing the fact that irreversible software is likely to give the most headaches
    later, this is where architectural decisions must lie. Above this, he claims that
    the role of an architect should be to seek to make these decisions reversible,
    thus mitigating the issue altogether.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 福勒还对软件开发团队中的架构师有了一个愿景。他指出，不可逆转的软件很可能会在以后带来最大的麻烦，这就是架构决策必须存在的地方。此外，他声称架构师的角色应该是寻求使这些决策可逆转，从而完全减轻问题。
- en: During many large-scale software deployments, the phrase *we are at the point
    of no return* may be used. After the *point of no return*, it becomes unfeasible
    to revert the deployment to its original state. Software has its own *point of
    no return*, when it becomes the fact that software is harder to rewrite then it
    is to simply rebuild. While software may not reach the worst case of this *point
    of no return*, climbing up on the maintainability difficulty poses business difficulties.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多大规模软件部署中，可能会使用“我们已经到了无法回头的地步”的说法。在“无法回头”的地步之后，将部署恢复到原始状态变得不可行。软件有自己的“无法回头”的地步，当软件变得更难重写而不是简单重建时，就会成为事实。虽然软件可能不会达到这种“无法回头”的最坏情况，但随着可维护性困难的增加，会带来商业困难。
- en: Fowler also states that, in many cases, software architects do not even check
    that the software matches its original design. Through pair-programming with an
    architect, and indeed, the architect reviewing the code changes (that is, the
    pull requests), they can gain an understanding in order to provide feedback to
    the developer and also mitigate further technical debt.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 福勒还指出，在许多情况下，软件架构师甚至不检查软件是否符合其原始设计。通过与架构师进行配对编程，以及架构师审查代码更改（即拉取请求），他们可以获得理解，以便向开发人员提供反馈，并减轻进一步的技术债务。
- en: In this book you may notice the lack of UML; that's because here I don't see
    UML as necessary. I mean, we are all speaking in PHP, right? You might find UML
    useful in your teams, though.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，您可能会注意到缺少UML；这是因为我认为这里不需要UML。我的意思是，我们都在用PHP说话，对吧？不过你可能会发现UML在您的团队中很有用。
- en: The process of architecture usually results in a deliverable; we call that deliverable
    an *artifact*. In Agile teams, those artifacts may be developed in an evolutionary
    way, rather than being an upfront product, but nevertheless it is perfectly possible
    to do architecture in an Agile setting.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 架构过程通常会产生可交付物；我们称这个可交付物为“工件”。在敏捷团队中，这些工件可能以渐进式方式开发，而不是事先产品，但在敏捷环境中完全可以进行架构设计。
- en: Indeed, I would argue that architecture makes working in an Agile environment
    far easier. When programming to an interface or an abstract layer it is far easier
    to replace classes; in an Agile environment, requirements may change, meaning
    a class may need to be replaced. Software is only useful insofar as it is useful
    to the end client. Agile can help with this, but in order to be Agile, your code
    must be adaptive. Having great architecture is critical to this end.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我认为架构使在敏捷环境中工作变得更容易。当编程到接口或抽象层时，更容易替换类；在敏捷环境中，需求可能会发生变化，这意味着可能需要替换类。软件只有对最终客户有用时才有用。敏捷可以帮助实现这一点，但为了实现敏捷，您的代码必须是适应性的。拥有出色的架构对此至关重要。
- en: When we write code, we should write code defensively. The adversary, however,
    isn't an enemy, it is ourselves. One of the quickest ways to degrade reliable
    code is by editing it to be weak.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代码时，我们应该采取防御性的编码方式。然而，对手并不是敌人，而是我们自己。破坏可靠代码的最快方式之一是编辑它以使其变得脆弱。
- en: Decorator
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: A Decorator is simply what adds additional functionality to an individual class
    without affecting the behavior of other objects from the same class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器只是在不影响同一类的其他对象行为的情况下，为单个类添加额外功能的内容。
- en: The Single Responsibility Principle, simply put by Robert C. Martin (who I introduced
    at the start of this chapter), is that *a class should have only one reason to
    change*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 单一责任原则，由Robert C. Martin（我在本章开头介绍过）简单地表述为“一个类应该只有一个改变的原因”。
- en: 'The principle states that every module or class should have a single responsibility
    and that responsibility should be entirely encapsulated by that class. All services
    of the class should align with that responsibility. Martin summarized this by
    defining the responsibility as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该原则规定每个模块或类应该有一个单一的责任，并且该责任应该完全由该类封装。类的所有服务都应该与该责任保持一致。Martin通过以下方式总结了这一责任：
- en: '*"a charge assigned to a unique actor to signify its accountabilities concerning
    a unique business task".*'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “指定给唯一的参与者的责任，表示其对于唯一的业务任务的责任。”
- en: By using the Decorator design pattern, we are able to ensure that functionality
    is divided between classes with unique areas of concern, thus adhering to the
    Single Responsibility Principle.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用装饰器设计模式，我们能够确保功能在具有独特关注领域的类之间进行划分，从而遵守单一责任原则。
- en: 'Let''s start off by declaring our `Book` interface. This is what we expect
    our Books to be able to produce:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先声明我们的`Book`接口。这是我们期望我们的书能够产生的内容：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then we can declare our `EBook.php` class. This is the class we will be decorating
    with our `PrintBook` class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以声明我们的`EBook.php`类。这是我们将用`PrintBook`类装饰的类：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we can declare our `PrintBook` class. This is what we''re using to decorate
    the `EBook` class:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以声明我们的`PrintBook`类。这是我们用来装饰`EBook`类的内容：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So now let''s test all this with our `index.php` file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用我们的`index.php`文件来测试所有这些。
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Adapter
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器
- en: There are two types of Adapter pattern. I have a clear preference for Object
    Adapters over Class Adapters where possible; I will explain this in detail later.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式有两种类型。在可能的情况下，我更偏向于对象适配器而不是类适配器；我稍后会详细解释这一点。
- en: The Adapter pattern allows an existing class to be used with an interface that
    it doesn't match. It is often used to allow existing classes to work with others
    without needing to alter their source code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式允许现有的类与其不匹配的接口一起使用。它经常用于允许现有的类与其他类一起工作，而无需修改它们的源代码。
- en: This can be quite useful in a polymorphic setting where you are using third-party
    libraries, each with their own interface.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这在使用具有各自接口的第三方库的多态设置中可能非常有用。
- en: Fundamentally, an Adapter helps two incompatible interfaces work together. Otherwise
    incompatible classes can be made to work together by converting the interface
    of one class into an interface expected by the clients.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，适配器帮助两个不兼容的接口一起工作。通过将一个类的接口转换为客户端期望的接口，否则不兼容的类可以被使得一起工作。
- en: Class Adapter
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类适配器
- en: In a Class Adapter, we use inheritance to create an adapter. A class (the adapter)
    can inherit another (the adaptee); using standard inheritance we are able to add
    additional functionality to the adaptee.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在类适配器中，我们使用继承来创建一个适配器。一个类（适配器）可以继承另一个类（被适配者）；使用标准继承，我们能够为被适配者添加额外功能。
- en: 'Let''s suppose we have an `ATM` class, in our `ATM.php` file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`ATM`类，在我们的`ATM.php`文件中：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s create our `ATMWithPhoneTopUp.php` to form our adapter:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的`ATMWithPhoneTopUp.php`来形成我们的适配器：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s wrap this all together in an `index.php` file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将所有这些内容包装在一个`index.php`文件中：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have adapted our initial `ATM` class to yield top-up codes, we
    can now utilize this new top-up functionality. The output of all this is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将初始的`ATM`类调整为生成充值码，我们现在可以利用这个新的充值功能。所有这些的输出如下：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that if we wanted to adapt to multiple adaptees, this would be difficult
    in PHP.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们想要适应多个被适配者，这在PHP中将会很困难。
- en: In PHP, multiple inheritance isn't possible, unless you are working with Traits.
    In this case, we can only adapt one class to match the interface of another.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，多重继承是不可能的，除非你使用Traits。在这种情况下，我们只能使一个类适应另一个类的接口。
- en: The other key architectural reason for us not using this approach is that it
    is often good design to prefer composition over inheritance (as described by the
    Composite Reuse Principle).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用这种方法的另一个关键架构原因是，通常更倾向于优先使用组合而不是继承（正如复用组合原则所描述的）。
- en: In order to explore this principle in more detail, we need to take a look at
    Object Adapters.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更详细地探讨这一原则，我们需要看看对象适配器。
- en: Object Adapter
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象适配器
- en: The Composite Reuse Principle states that classes should achieve polymorphic
    behavior and code reuse by their composition.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 复用组合原则规定，类应该通过它们的组合实现多态行为和代码复用。
- en: By applying this principle, classes should contain instances of other classes
    when they want to implement a particular piece of functionality, as opposed to
    inheriting the functionality from a base or parent class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用这一原则，当类想要实现特定功能时，应该包含其他类的实例，而不是从基类或父类继承功能。
- en: 'For this reason, the Gang of Four stated the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，四人帮提出了以下观点：
- en: '*"Favor ''object composition'' over ''class inheritance''."*'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “更偏向于‘对象组合’而不是‘类继承’。”
- en: Why is this principle so vital? Consider our last example, where we used class
    inheritance; in such a case, there is no formal guarantee that our adapter would
    match the interface we want it to. What if the parent class exposed a function
    we didn't want the adapter to? Composition gives us more control.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个原则如此重要？考虑我们上一个例子，我们在那里使用了类继承；在这种情况下，我们无法保证我们的适配器是否符合我们想要的接口。如果父类暴露了我们不想要适配器的函数会怎么样？组合给了我们更多的控制。
- en: By using composition over inheritance, we are able to better support the polymorphic
    behavior that is so vital in object-oriented programming.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合而不是继承，我们能够更好地支持面向对象编程中如此重要的多态行为。
- en: 'Let''s suppose we have a class to generate an insurance premium. It provides
    a monthly premium and an annual premium depending on how the customer wants to
    pay their premium. By paying annually, the customer gets a saving equivalent to
    half a month:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个生成保险费的类。它根据客户希望如何支付保险费提供月度保费和年度保费。通过年度支付，客户可以节省相当于半个月的金额：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s suppose a market comparison tool polymorphically uses classes such as
    the one mentioned earlier to actually go ahead and calculate insurance quotes
    from multiple different vendors; they use this interface to do this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设市场比较工具多态地使用诸如前面提到的类来实际上计算来自多个不同供应商的保险报价；他们使用这个接口来做到这一点：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Accordingly, we can use this interface to build an Object Adapter to ensure
    our `Insurance` class, our premium generator, matches the interface that the market
    comparison tool is expecting:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用这个接口来构建一个对象适配器，以确保我们的`Insurance`类，我们的保费生成器，符合市场比较工具所期望的接口：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note how the class actually goes ahead and instantiates its own class for what
    it's trying to adapt.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意类实际上是如何实例化自己的类以适应它所尝试适配的内容。
- en: The adapter then stores this class in a `private` variable. We then use this
    object in the `private` variable to proxy requests.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后适配器将这个类存储在一个`private`变量中。然后我们使用这个对象在`private`变量中代理请求。
- en: An Adapter, both a Class Adapter and an Object Adapter, should act as glue code.
    What I mean by that is that adapters shouldn't perform any calculations or computation,
    they merely act as a proxy between incompatible interfaces.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器，无论是类适配器还是对象适配器，都应该充当粘合代码。我的意思是适配器不应执行任何计算或计算，它们只是在不兼容的接口之间充当代理。
- en: It is standard practice to keep logic out of our glue code and leave the logic
    down to the code that we are adapting. If, in doing this, we come up against the
    Single Responsibility Principle, we need to adapt another class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将逻辑保持在我们的粘合代码之外，并将逻辑留给我们正在适应的代码是标准做法。如果在这样做时，我们遇到单一责任原则，我们需要适应另一个类。
- en: As I mentioned earlier, adapting multiple classes isn't really possible in a
    Class Adapter, so you'd either have to wrap such logic in a Trait or we would
    need to use an Object Adapter, such as the one we're discussing here.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，在类适配器中适配多个类实际上是不可能的，所以你要么必须将这样的逻辑包装在一个Trait中，要么我们需要使用对象适配器，比如我们正在讨论的这个。
- en: 'Let''s try out this adapter. We''ll do so by writing the following `index.php`
    file to see if our new class matches the expected interface:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这个适配器。我们将通过编写以下`index.php`文件来看看我们的新类是否符合预期的接口：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output should look something like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The key drawback of this method, compared to the Class Adapter method, is that
    we must implement common methods, even if those methods are merely forwarding
    methods.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与类适配器方法相比，这种方法的主要缺点是，我们必须实现公共方法，即使这些方法只是转发方法。
- en: FlyWeight
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FlyWeight
- en: Like in real life, not all objects are easy to create, and some can take up
    excessive amounts of memory. The FlyWeight design pattern can help us minimize
    memory usage by sharing as much data as possible with similar objects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在现实生活中，不是所有的对象都容易创建，有些可能会占用过多的内存。FlyWeight设计模式可以通过尽可能与类似对象共享尽可能多的数据来帮助我们最小化内存使用。
- en: This design pattern has limited use in most PHP applications, but it is still
    worth knowing it for the odd situation where it is incredibly useful.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式在大多数PHP应用程序中的使用有限，但是了解它在极端有用的情况下仍然是值得的。
- en: 'Suppose we have a `Shape` interface with a `draw` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个带有`draw`方法的`Shape`接口：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's create a `Circle` class that implements this interface. When implementing
    this, we build the ability to set the location of a circle with X and Y co-ordinates.
    We also create the ability to set the circle's radius and draw it (print out this
    information). Note how the color characteristic is set outside the class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个实现这个接口的`Circle`类。在实现这个过程中，我们建立了设置圆的位置和半径以及绘制它（打印出这些信息）的能力。注意颜色特征是如何在类外设置的。
- en: There's a very important reason for this. In our example, the color is state-independent;
    it is an intrinsic part of the circle. The location and size of the circle are,
    however, state-dependent and are therefore extrinsic. The extrinsic state information
    is passed to the FlyWeight object when its functions are needed; the intrinsic
    options, however, are independent of each process of the FlyWeight. This will
    make more sense when we cover how this factory is made.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个非常重要的原因。在我们的例子中，颜色是与状态无关的；它是圆的固有部分。然而，圆的位置和大小是与状态相关的，因此是外部的。当需要时，外部状态信息被传递给FlyWeight对象；然而，固有选项与FlyWeight的每个过程无关。当我们讨论这个工厂是如何制作的时，这将更有意义。
- en: 'This is the important information:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是重要的信息：
- en: '**Extrinsic**: State belongs to the external context of the object and is input
    into the object when it''s used.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部**：状态属于对象的外部上下文，并在使用对象时输入。'
- en: '**Intrinsic**: State that naturally belongs to the object and therefore should
    be permanent, immutable (internal), or context-free.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内在**：自然属于对象的状态，因此应该是永久的、不可变的（内部）或与上下文无关的。'
- en: 'With this in mind, let''s put together an implementation of our `Shape` interface.
    Here''s our `Circle` class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们组合一个实现我们的`Shape`接口的实现。这是我们的`Circle`类：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With this, we can now build our `ShapeFactory`, which actually implements the
    FlyWeight pattern. An object with the color of our choice is instantiated when
    it''s needed, and is then stored for later use:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以构建我们的`ShapeFactory`，它实际上实现了FlyWeight模式。当需要时，会实例化一个具有我们选择的颜色的对象，然后将其存储以供以后使用：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's demonstrate how this works in our `index.php` file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`index.php`文件中演示这是如何工作的。
- en: 'In order for this to work, we create `100` objects with random colors, in a
    random location:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个工作，我们创建`100`个带有随机颜色的对象，放在随机位置：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s take a look at the output. You can see we''ve drawn 100 circles,
    but we have only needed to instantiate a handful of circles as we are caching
    objects of the same color for later use:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下输出。您可以看到我们画了100个圆，但我们只需要实例化少量圆，因为我们正在缓存相同颜色的对象以供以后使用：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You may have noticed something here. The way I'm storing the cache of the FlyWeight
    object that we are reusing is by concatenating the *Circle*_ and the color, for
    example *Circle_green*. Obviously, this works in this use case, but there is a
    better way of doing this; in PHP, it is actually possible to get a unique ID for
    a given object. We'll cover this in the next pattern.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到了一些事情。我们正在存储我们正在重用的FlyWeight对象的缓存的方式是通过连接*Circle*_和颜色，例如*Circle_green*。显然，在这种情况下这是有效的，但有更好的方法；在PHP中，实际上可以为给定的对象获取唯一ID。我们将在下一个模式中介绍这个。
- en: Composite
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: Imagine an audio system consisting of individual songs and also playlists of
    songs. Yes, playlists consist of songs, but we want both to be treated individually.
    Both are types of music, both can be played.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个由单独歌曲和歌曲播放列表组成的音频系统。是的，播放列表由歌曲组成，但我们希望两者都被单独对待。两者都是音乐类型，都可以播放。
- en: The Composite design pattern can help here; it allows us to ignore the differences
    between compositions of objects and individual objects. It allows us to treat
    both with identical or nearly-identical code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 组合设计模式可以帮助我们；它允许我们忽略对象组合和单个对象之间的差异。它允许我们用相同或几乎相同的代码来处理两者。
- en: Let's put together a little example; a song is our example of a *leaf*, with
    playlists being *composites*. `Music` is our abstraction of playlists and songs;
    therefore, we can call this our *component*. The *client* of all this is our `index.php`
    file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个小例子；一首歌是我们*叶子*的例子，而播放列表是*组合*。`Music`是我们对播放列表和歌曲的抽象；因此，我们可以称之为我们的*组件*。所有这些的*客户端*是我们的`index.php`文件。
- en: By not discriminating between leaf-nodes and branches, our code becomes less
    complex and therefore less error prone.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不区分叶节点和分支，我们的代码变得不那么复杂，因此也不那么容易出错。
- en: 'Let''s start by defining an interface for our `Music`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先为我们的`Music`定义一个接口：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now let''s put together some implementations, starting with our `Song` class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们组合一些实现，首先是我们的`Song`类：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now we can start to put together our `Playlist` class. In this example, you
    may notice I set the key in the songs array using a function called `spl_object_hash`.
    This function is an absolutely blessing when dealing with arrays of objects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始组合我们的`Playlist`类。在这个例子中，您可能注意到我使用一个名为`spl_object_hash`的函数在歌曲数组中设置键。当处理对象数组时，这个函数绝对是一个祝福。
- en: What this function does is return a unique hash for each object which remains
    consistent so long as the object is not destroyed, regardless of what properties
    of the class are changed. It provides a stable way of addressing arbitrary objects.
    Once the object is destroyed, the hash can then be reused for other objects.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的作用是为每个对象返回一个唯一的哈希值，只要对象没有被销毁，无论类的属性如何改变，它都保持一致。它提供了一种稳定的方式来寻址任意对象。一旦对象被销毁，哈希值就可以被重用于其他对象。
- en: The contents of the object are not hashed by this function; it merely acts to
    show the internal handle and the hander table pointer. This means that if you
    alter the properties of an object, the hash will not change. This said, it does
    not guarantee uniqueness. If an object is destroyed and one of the same class
    is immediately created afterwards you will get the same hash as PHP will reuse
    the same internal handle after the first class has been dereferenced and destroyed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不会对对象的内容进行哈希处理；它只是显示内部句柄和句柄表指针。这意味着如果您更改对象的属性，哈希值不会改变。也就是说，它并不保证唯一性。如果一个对象被销毁，然后立即创建一个相同类的对象，您将得到相同的哈希值，因为PHP将在第一个类被取消引用和销毁后重用相同的内部句柄。
- en: 'This will be true, as PHP can use the internal handle:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是真的，因为PHP可以使用内部句柄：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, this will be false, as PHP must create a new handler:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将是错误的，因为PHP必须创建一个新的句柄：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now let''s return to our `Playlist` class. Let''s implement our `Music` interface
    with it; so, here''s the class:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到我们的`Playlist`类。让我们用它实现我们的`Music`接口；所以，这是类：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now let's put this all together in our `index.php` file. What we're doing here
    is creating some song objects, some of which we will assign to a playlist using
    their `addSong` function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把这一切放在我们的`index.php`文件中。我们在这里所做的是创建一些歌曲对象，其中一些我们将使用它们的`addSong`函数分配给一个播放列表。
- en: Because playlists are implemented in the same way as songs, we can even use
    the `addSong` function with other playlists (in this case, it may be better for
    us to rename the `addSong` function `addMusic`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因为播放列表的实现方式与歌曲相同，我们甚至可以使用`addSong`函数与其他播放列表一起使用（在这种情况下，最好将`addSong`函数重命名为`addMusic`）。
- en: 'Then we play the parent playlist. This plays the child playlists and in turn
    plays all the songs in those playlists as well:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们播放父播放列表。这将播放子播放列表，然后播放这些播放列表中的所有歌曲：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we run this script, we can see the expected output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个脚本时，我们可以看到预期的输出：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Bridge
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接
- en: The Bridge pattern can be quite straightforward; it effectively allows us to
    decouple an abstraction from an implementation so the two can vary independently.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式可能非常简单；它有效地允许我们将抽象与实现解耦，以便两者可以独立变化。
- en: When classes vary frequently, bridging an interface and a concrete class allows
    developers to vary their classes with greater ease.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当类经常变化时，通过桥接接口和具体类，开发人员可以更轻松地变化他们的类。
- en: 'Let''s propose a generic messenger interface that has the ability to send some
    form of message, `Messenger.php`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提出一个通用的信使接口，具有发送某种形式消息的能力，`Messenger.php`：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'One specific implementation of this interface is an `InstantMessenger` application,
    `InstantMessenger.php`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口的一个具体实现是一个`InstantMessenger`应用程序，`InstantMessenger.php`：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Similarly, we can do the same with an `SMS` application, `SMS.php`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以用一个`SMS`应用程序`SMS.php`来做同样的事情：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can now create an interface for the physical device, the transmitter, if
    you will, `Transmitter.php`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以为物理设备，即发射器，创建一个接口，`Transmitter.php`：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can decouple a transmitter from the devices that implement its methods by
    using a `Device` class. The `Device` class bridges the `Transmitter` interface
    to the physical device, `Device.php`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`Device`类将实现其方法的设备与发射器解耦。`Device`类将`Transmitter`接口桥接到物理设备，`Device.php`：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So let''s put together a concrete class to represent a phone, `Phone.php`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们组合一个具体的类来表示手机，`Phone.php`：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And let''s do the same for a `Tablet`. `Tablet.php` is:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对`Tablet`做同样的事情。`Tablet.php`是：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, let''s wrap this all together in an `index.php` file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们把这一切都包装在一个`index.php`文件中：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output of this is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出如下：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Proxy pattern
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理模式
- en: Proxy is a class that is merely an interface to something else. It may be an
    interface to anything; from being a network connection, a file, a large object
    in memory, or any other resource that is too difficult to duplicate.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是一个仅仅是与其他东西接口的类。它可以是任何东西的接口；从网络连接、文件、内存中的大对象，或者其他太难复制的资源。
- en: In our example here, we will simply be creating a simple proxy to forward to
    one of two objects depending on how the proxy is instantiated.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将简单地创建一个简单的代理，根据代理的实例化方式转发到两个对象中的一个。
- en: Accessing a simple Proxy class allows the client to access both feeders for
    cats and dogs from one object, depending on whether it's been instantiated.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 访问一个简单的代理类允许客户端从一个对象中访问猫和狗的喂食器，具体取决于它是否已被实例化。
- en: 'Let''s start off by defining an interface for our `AnimalFeeder`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义一个`AnimalFeeder`的接口：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can then define two animal feeders for a cat and a dog:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以为猫和狗定义两个动物喂食器：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And here''s our dog `AnimalFeeder`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`AnimalFeeder`：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With this defined, we can now make our proxy class, a class that essentially
    uses the constructor to decipher what kind of class it needs to instantiate, then
    redirects all function calls to this class. In order to redirect function calls,
    the `__call magic` method is used.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个定义，我们现在可以创建我们的代理类，一个基本上使用构造函数来解密需要实例化的类，然后将所有函数调用重定向到这个类。为了重定向函数调用，使用`__call
    magic`方法。
- en: 'This looks something like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像这样：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You might have noticed that we have to manually create the class in the constructor
    with the namespace. We do this using the `__NAMESPACE__ magic` constant to find
    the current namespace, then concatenating it onto the specific sub-namespace where
    the classes are. Note that we have to escape the `\` using another `\` in order
    to allow us to specify the namespace without PHP interpreting `\` as an escape
    character.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们必须在构造函数中手动创建带有命名空间的类。我们使用`__NAMESPACE__ magic`常量来找到当前命名空间，然后将其连接到类所在的特定子命名空间。请注意，我们必须使用另一个`\`来转义`\`，以便允许我们指定命名空间，而不让PHP将`\`解释为转义字符。
- en: 'Let''s build our `index.php` file and utilize the proxy class to build objects:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的`index.php`文件，并利用代理类来构建对象：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: So how can you use this in reality? Suppose you got a record out of the database
    that contained an object that detailed the animal type and name; you could just
    pass this object to the constructor of the Proxy class and use that as a mechanism
    to create your classes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你如何在现实中使用它呢？假设你从数据库中得到了一个包含动物类型和名称的对象的记录；你可以将这个对象传递给代理类的构造函数，并将其作为创建你的类的机制。
- en: In practice, this has a great use case when it comes to supporting resource-hungry
    objects that you don't necessarily want to instantiate unless they are really
    required by the client; the same can be true of resource-hungry network connections
    and other types of resource.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，当支持资源密集型对象时，这是一个很好的用例，除非客户端真正需要它们，否则你不一定想要实例化它们；对于资源密集型网络连接和其他类型的资源也是如此。
- en: Facade
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观
- en: Facade (also known as *Façade*) design patterns are a curious thing; they essentially
    act as a simple interface to a complex system. A Facade design pattern works providing
    a single class that in itself instantiates other classes and provides a simple
    interface to use those functions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 外观（也称为*Façade*）设计模式是一件奇妙的事情；它们本质上是一个复杂系统的简单接口。外观设计模式通过提供一个单一的类来工作，这个类本身实例化其他类并提供一个简单的接口来使用这些函数。
- en: A warning when using such pattern is that, as classes are instantiated within
    the Facade, you are essentially tightly coupling the classes that it utilizes.
    There are cases where you want this, but there are cases where you do not. Where
    do you do not want this behavior, you are better suited to using dependency injection.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式时的一个警告是，由于类是在外观中实例化的，你本质上是将它所使用的类紧密耦合在一起。有些情况下你希望这样做，但也有些情况下你不希望。在你不希望这种行为的情况下，最好使用依赖注入。
- en: I have found this to be useful when wrapping a set of poor APIs into a single
    unified API. It reduces external dependencies, allowing complexity to be internalized;
    this process can make your code more readable.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现这在将一组糟糕的API封装成一个统一的API时非常有用。它减少了外部依赖，允许复杂性内部化；这个过程可以使你的代码更易读。
- en: I shall demonstrate this pattern in a crude example, but this will effectively
    make the mechanism obvious.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在一个粗糙的例子中演示这种模式，但这将使机制变得明显。
- en: Let me propose three classes for a toy factory.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我提议三个玩具工厂的类。
- en: 'Manufacturer (the factory building the toy) is a simple class that is instantiated
    with the capacity of how many toys to build at a time:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 制造商（制造玩具的工厂）是一个简单的类，它根据一次制造多少个玩具来实例化：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Post class (the shipping courier) is a simple function that dispatches the
    toy from the factory:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Post类（运输快递员）是一个简单的函数，用于从工厂发货玩具：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'An `SMS` class informs the client that their toy has been dispatched from the
    factory:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`SMS`类通知客户他们的玩具已经从工厂发货：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here is our `ToyFactory` class, which acts as a Facade to link together all
    these classes and allow operations to happen sequentially:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`ToyFactory`类，它充当一个外观，将所有这些类连接在一起，并允许操作按顺序发生：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And finally, we can wrap all this together in our `index.php` file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将所有这些内容包装在我们的`index.php`文件中：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once we run this code, we see the message from our `SMS` class showing the
    text message was sent:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行这段代码，我们会看到来自我们的`SMS`类的消息显示出短信已发送：
- en: '![Facade](graphics/image_04_001.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![Facade](graphics/image_04_001.jpg)'
- en: In other situations, where the various classes were loosely coupled together,
    we may find it better to use dependency injection. By injecting objects that perform
    various actions into the `ToyFactory` class we can benefit from making testing
    easier by being able to inject fake classes that the `ToyFactory` class can manipulate.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，当各种类之间耦合较松时，我们可能会发现最好使用依赖注入。通过将执行各种操作的对象注入到`ToyFactory`类中，我们可以通过能够注入`ToyFactory`类可以操作的假类来使测试变得更容易。
- en: Personally, I am a huge believer in making code as easily testable as possible;
    hence why I don't like this approach.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我非常相信尽可能使代码易于测试；这也是为什么我不喜欢这种方法的原因。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter extended the design patterns we started to learn in the previous
    chapter by introducing structural design patterns.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过引入结构设计模式扩展了我们在上一章开始学习的设计模式。
- en: 'To this end, we learned some critical patterns to ease the software design
    process; these patterns identify a simple way to realize the relationships between
    different entities:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们学会了一些关键的模式来简化软件设计过程；这些模式确定了实现不同实体之间关系的简单方式：
- en: We learned about the Decorator, how to wrap classes to add additional behavior
    to them, and critically, we learned how this can help us comply with the Single
    Responsibility Principle.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了装饰器，如何包装类以向它们添加额外的行为，并且关键是，我们学会了这如何帮助我们遵守单一职责原则。
- en: We learned about Class and Object Adapters, and the difference between them.
    The critical takeaway here is the arguments for why we may choose composition
    over inheritance.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了类和对象适配器，以及它们之间的区别。这里的关键是为什么我们可能会选择组合而不是继承的论点。
- en: We reviewed the FlyWeight design pattern, which can help us perform certain
    processes in a memory-efficient manner.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们复习了享元设计模式，它可以帮助我们以节省内存的方式执行某些过程。
- en: We learned how the Composite design pattern can help us treat compositions of
    objects the same as individual objects.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学会了组合设计模式如何帮助我们将对象的组合与单个对象一样对待。
- en: We covered the Bridge design pattern, which lets us decouple our abstraction
    from its implementation, allowing the two to vary independently.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了桥接设计模式，它让我们将抽象与实现解耦，使两者能够独立变化。
- en: We covered how the Proxy design pattern can function as an interface to another
    class and how we can use this as a forwarding agent.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了代理设计模式如何作为另一个类的接口，并且我们可以将其用作转发代理。
- en: Finally, we learned how the Facade design pattern can be used to provide a simple
    interface to a complex system.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们学会了外观设计模式如何用于为复杂系统提供简单的接口。
- en: In the next chapter, we will wrap up our design patterns section by talking
    about Behavioral patterns, ready to touch on Architectural patterns.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过讨论行为模式来结束我们的设计模式部分，准备涉及架构模式。
