- en: '*Chapter 5*: Discovering Potential OOP Backward-Compatibility Breaks'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：发现潜在的面向对象编程向后兼容性问题'
- en: 'This chapter marks the beginning of Part 2 of the book, *PHP 8 Tricks*. In
    this part, you''ll discover the dark corners of PHP 8: the place where **backward-compatibility
    breaks** exist. This part gives you insight into how to avoid problems before
    migrating an existing application to PHP 8\. You will learn what to look for in
    your existing code that could cause it to stop working after a PHP 8 upgrade.
    Once you master the topics presented in this part of the book, you will be well
    equipped to modify existing code in such a manner that it continues to function
    normally following a PHP 8 upgrade.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章标志着本书第2部分*PHP 8技巧*的开始。在这一部分，您将发现PHP 8的黑暗角落：**向后兼容性问题**存在的地方。本部分将让您了解如何在将现有应用程序迁移到PHP
    8之前避免问题。您将学会如何查找现有代码中可能导致其在PHP 8升级后停止工作的问题。一旦掌握了本书这一部分介绍的主题，您将能够很好地修改现有代码，使其在PHP
    8升级后继续正常运行。
- en: In this chapter, you will be introduced to new PHP 8 features specific to **object-oriented
    programming (OOP)**. The chapter provides you with plenty of short code examples
    that clearly illustrate the new features and concepts. This chapter is critical
    in helping you quickly take advantage of the power of PHP 8 as you adapt the code
    examples for your own practice. The focus of this chapter is on situations where
    object-oriented code might break after a PHP 8 migration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将介绍与**面向对象编程（OOP）**相关的新的PHP 8特性。本章提供了大量清晰说明新特性和概念的简短代码示例。本章对帮助您快速利用PHP
    8的强大功能至关重要，因为您可以将代码示例调整为自己的实践。本章的重点是在PHP 8迁移后，面向对象的代码可能会出现问题的情况。
- en: 'Topics covered in this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: Discovering core OOP coding differences
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现核心面向对象编程的差异
- en: Navigating changes in magic methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航魔术方法的更改
- en: Taking control of serialization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制序列化
- en: Understanding expanded PHP 8 variance support
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解扩展的PHP 8变异支持
- en: Handling **Standard PHP Library** (**SPL**) changes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理**标准PHP库**（**SPL**）的更改
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To examine and run the code examples provided in this chapter, the minimum
    recommended hardware is the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看和运行本章提供的代码示例，建议的最低硬件要求如下：
- en: x86_64 based desktop PC or laptop
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于x86_64的台式PC或笔记本电脑
- en: 1 gigabyte (GB) of free disk space
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1千兆字节(GB)的可用磁盘空间
- en: 4 GB of RAM
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4GB的RAM
- en: A 500 kilobits per second (Kbps) or faster internet connection
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每秒500千位(Kbps)或更快的互联网连接
- en: 'In addition, you will need to install the following software:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您需要安装以下软件：
- en: Docker
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Docker Compose
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Please refer to the *Technical requirements* section of [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013),
    *Introducing New PHP 8 OOP Features*, for more information on Docker and Docker
    Compose installation, as well as how to build the Docker container used to demonstrate
    code explained in this book. In this book, we refer to the directory in which
    you restored the sample code for this book as `/repo`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Docker和Docker Compose的安装以及如何构建用于演示本书中解释的代码的Docker容器的更多信息，请参阅[*第1章*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013)的*技术要求*部分，*介绍新的PHP
    8面向对象编程特性*。在本书中，我们将您为本书恢复的示例代码的目录称为`/repo`。
- en: 'The source code for this chapter is located here: https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于此处：https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices。
- en: We can now begin our discussion by examining core OOP coding differences.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始讨论核心面向对象编程的差异。
- en: Discovering core OOP coding differences
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现核心面向对象编程的差异
- en: There are a number of significant changes to how you are able to write OOP code
    in PHP 8\. In this section, we focus on three key areas that might present you
    with potential backward-compatibility breaks. The areas we address in this section
    are common bad practices associated with making static method calls, handling
    object properties, and PHP autoloading.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，您可以以不同的方式编写面向对象的代码。在本节中，我们重点关注可能会导致潜在向后兼容性问题的三个关键领域。本节我们将讨论与进行静态方法调用、处理对象属性和PHP自动加载相关的常见不良实践。
- en: After reading this section, and working your way through the examples, you are
    in in a better position to spot OOP bad practices and to learn how PHP 8 has placed
    restrictions on such usage. In this chapter, you learn good coding practices,
    which will ultimately make you a better programmer. You will also be able to address
    changes in PHP autoloading that can potentially cause failure in an application
    migrated to PHP 8.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本节并完成示例后，您将更好地发现面向对象的不良实践，并了解PHP 8如何对此类用法进行限制。在本章中，您将学习良好的编码实践，这将最终使您成为更好的程序员。您还将能够解决PHP自动加载中的更改，这可能会导致迁移到PHP
    8的应用程序失败。
- en: Let's first look at how PHP 8 has tightened up on making static calls.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看PHP 8如何加强静态调用。
- en: Handling static calls in PHP 8
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在PHP 8中处理静态调用
- en: Surprisingly, PHP versions 7 and below allowed developers to make a static call
    to a class method not declared `static`. At first glance, any future developer
    reviewing your code immediately assumes that the method has been defined as `static`.
    This can lead to unexpected behavior as the future developer, operating under
    a false assumption, starts to misuse your code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，PHP 7及以下版本允许开发人员对未声明为`static`的类方法进行静态调用。乍一看，任何未来审查您代码的开发人员立即会假设该方法已被定义为`static`。这可能会导致意外行为，因为未来的开发人员在错误的假设下开始误用您的代码。
- en: 'In this simple example, we define a `Test` class with a `nonStatic()` method.
    In the procedural code that follows the class definition, we echo the return value
    of this method, however, in doing so we make a static call:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们定义了一个带有`nonStatic()`方法的`Test`类。在类定义后的程序代码中，我们输出了这个方法的返回值，然而，在这样做时，我们进行了一个静态调用：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we run this code in PHP 7, here is the result:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在PHP 7中运行此代码时，结果如下：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see from the output, PHP 7 issues a deprecation notice, but allows
    the call to be made! In PHP 8, however, the result is a fatal `Error`, as shown
    here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，PHP 7会发出弃用通知，但允许调用！然而，在PHP 8中，结果是致命的`Error`，如下所示：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Calling a non-static method using static method call syntax is a bad practice
    in the sense that well-written code makes the intention of the code developer
    crystal clear. If you do not define a method as static, but later call it in a
    static sense, a developer assigned to maintain your code in the future might become
    confused and could make wrong assumptions about the original intent of the code.
    The end result will be even more bad code!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态方法调用非静态方法的语法是一种不良实践，因为良好编写的代码使代码开发人员的意图变得清晰明了。如果您没有将方法定义为静态，但后来以静态方式调用它，未来负责维护您代码的开发人员可能会感到困惑，并可能对代码的原始意图做出错误的假设。最终结果将是更糟糕的代码！
- en: In PHP 8, you can no longer call a non-static method using a static method call.
    Let's now have a look at another bad practice involving treating object properties
    as keys.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，您不能再使用静态方法调用非静态方法。现在让我们再看看另一个涉及将对象属性视为键的不良实践。
- en: Dealing with object property handling changes
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理对象属性处理的变化
- en: Arrays have been a central feature in PHP all the way back to the earliest versions.
    OOP, on the other hand, was not introduced until PHP 4\. In the early days of
    OOP, array functions were often expanded to accommodate object properties. This
    led to a blurring of the distinction between an object and an array, which in
    turn spawned a number of bad practices.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 数组一直是PHP的一个核心特性，一直延续到最早的版本。另一方面，面向对象编程直到PHP 4才被引入。在面向对象编程的早期，数组函数经常被扩展以适应对象属性。这导致对象和数组之间的区别变得模糊，从而产生了一些不良实践。
- en: 'In order to maintain a clear separation between array handling and object handling,
    PHP 8 now restricts the `array_key_exists()` function to only accept an array
    as an argument. To illustrate this, consider the following example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持数组处理和对象处理之间的清晰分离，PHP 8现在限制`array_key_exists()`函数只接受数组作为参数。为了说明这一点，考虑以下示例：
- en: 'First, we define a simple anonymous class with a single property:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个带有单个属性的简单匿名类：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We then run three tests that each check for the existence of `$var`, using
    `isset()`, `property_exists()`, and `array_key_exists()`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们运行三个测试，分别使用`isset()`、`property_exists()`和`array_key_exists()`来检查`$var`的存在：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we run this code in PHP 7, all tests succeed, as shown here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在PHP 7中运行这段代码时，所有测试都成功，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In PHP 8, however, a fatal `TypeError` occurs, as `array_key_exists()` now
    only accepts an array as an argument. The PHP 8 output is shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PHP 8中，会发生致命的`TypeError`，因为`array_key_exists()`现在只接受数组作为参数。PHP 8的输出如下所示：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The best practice is to use either `property_exists()` or `isset()`. We now
    turn our attention to changes in PHP autoloading.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是使用`property_exists()`或`isset()`。现在我们将注意力转向PHP自动加载的变化。
- en: Working with PHP 8 autoloading
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PHP 8自动加载
- en: The basic **autoloading** class mechanism first introduced in PHP 5.1 works
    the same in PHP 8\. The main difference is that the support for the global function
    `__autoload()`, deprecated in PHP 7.2, has been completely removed in PHP 8\.
    Starting with PHP 7.2, developers were encouraged to register their autoloading
    logic using `spl_autoload_register()`, available for that purpose since PHP 5.1\.
    Another major difference is how `spl_autoload_register()` reacts if unable to
    register an autoloader.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中首次引入的基本**自动加载**类机制与PHP 8中的工作方式相同。主要区别在于，全局函数`__autoload()`在PHP 7.2中已弃用，并在PHP
    8中已完全删除。从PHP 7.2开始，开发人员被鼓励使用`spl_autoload_register()`注册其自动加载逻辑，该函数自PHP 5.1起可用于此目的。另一个主要区别是如果无法注册自动加载程序，`spl_autoload_register()`的反应方式。
- en: An understanding of how the autoloading process works when using `spl_autoload_register()`
    is critical to your work as a developer. Failure to grasp how PHP automatically
    locates and loads classes will limit your ability to grow as a developer and could
    have a detrimental impact on your career path.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 了解使用`spl_autoload_register()`时自动加载过程的工作原理对于作为开发人员的工作至关重要。不理解PHP如何自动定位和加载类将限制您作为开发人员的能力，并可能对您的职业道路产生不利影响。
- en: Before getting into `spl_autoload_register()`, let's first have a look at the
    `__autoload()` function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究`spl_autoload_register()`之前，让我们先看一下`__autoload()`函数。
- en: Understanding the __autoload() function
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解__autoload()函数
- en: The `__autoload()` function was used by many developers as the primary source
    of autoloading logic. This function behaves much as a *magic method* does and
    that's why it's called automatically depending on the context. Circumstances that
    would trigger an automatic call to the `__autoload()` function include the moment
    when a new class instance is created, but where the class definition has not yet
    been loaded. Further, if the class extends another class, the autoload logic is
    also invoked in order to load the super class prior to the creation of the subclass
    that extends it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`__autoload()`函数被许多开发人员用作自动加载逻辑的主要来源。这个函数的行为方式类似于*魔术方法*，这就是为什么它根据上下文自动调用。会触发自动调用`__autoload()`函数的情况包括创建新类实例时，但类定义尚未加载的时刻。此外，如果类扩展另一个类，则还会调用自动加载逻辑，以便在创建扩展它的子类之前加载超类。'
- en: 'The advantage of using the `__autoload()` function was that it was quite easy
    to define, and was often defined in a website''s initial `index.php` file. The
    disadvantages included the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`__autoload()`函数的优点是它非常容易定义，并且通常在网站的初始`index.php`文件中定义。缺点包括以下内容：
- en: '`__autoload()` was a PHP procedural function; not defined nor controlled using
    OOP principles. This can become an issue when defining unit tests for an application,
    for example.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__autoload()`是一个PHP过程函数；不是使用面向对象编程原则定义或控制的。例如，在为应用程序定义单元测试时，这可能会成为一个问题。'
- en: If your application uses namespaces, the `__autoload()` function must be defined
    in the global namespace; otherwise, classes outside of the namespace in which
    the `__autoload()` function is defined will fail to load.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的应用程序使用命名空间，`__autoload()`函数必须在全局命名空间中定义；否则，在定义`__autoload()`函数的命名空间之外的类将无法加载。
- en: The `__autoload()` function doesn't work well with `spl_autoload_register()`.
    If you define autoloading logic using both the `__autoload()` function and `spl_autoload_register()`,
    the `__autoload()` function logic is entirely ignored.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__autoload()`函数与`spl_autoload_register()`不兼容。如果你同时使用`__autoload()`函数和`spl_autoload_register()`定义自动加载逻辑，`__autoload()`函数的逻辑将被完全忽略。'
- en: 'To illustrate potential problems, we''ll define an `OopBreakScan` class, discussed
    in more detail in [*Chapter 11*](B16992_11_Final_JC_ePub.xhtml#_idTextAnchor263)*,
    Migrating Existing PHP Apps to PHP 8*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明潜在的问题，我们将定义一个`OopBreakScan`类，更详细地讨论在[*第11章*](B16992_11_Final_JC_ePub.xhtml#_idTextAnchor263)*，将现有的PHP应用迁移到PHP
    8*中：
- en: 'First, we define and then add a method to the `OopBreakScan` class that scans
    the file contents for the `__autoload()` function. Note that the error message
    is a class constant defined in the `Base` class that simply warns of the presence
    of the `__autoload()` function:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义并添加一个方法到`OopBreakScan`类中，该方法扫描文件内容以查找`__autoload()`函数。请注意，错误消息是在`Base`类中定义的一个类常量，只是警告存在`__autoload()`函数：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This class extends a `Migration\Base` class (not shown). This is significant
    as any autoloading logic needs to find not only the subclass but its super class
    as well.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展了一个`Migration\Base`类（未显示）。这很重要，因为任何自动加载逻辑都需要找到子类和它的超类。
- en: 'Next, we define a calling program in which a magic `__autoload()` function
    is defined:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个调用程序，在其中定义了一个魔术`__autoload()`函数：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then make use of the class by having the calling program scan itself:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们通过让调用程序扫描自身来使用这个类：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is the output running in PHP 7:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PHP 7中运行的输出：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see from the output, the `Migration\OopBreakScan` class was autoloaded.
    We know this because the `scanMagicAutoloadFunction` method was invoked, and we
    have its results. Furthermore, we know that the `Migration\Base` class was also
    autoloaded. The reason we know this is because the error message that appears
    in the output is a constant of the super class.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看到，`Migration\OopBreakScan`类被自动加载了。我们知道这是因为`scanMagicAutoloadFunction`方法被调用了，我们有它的结果。此外，我们知道`Migration\Base`类也被自动加载了。我们知道这是因为输出中出现的错误消息是超类的常量。
- en: 'However, the same code running in PHP 8 produces this result:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PHP 8中运行相同的代码会产生这样的结果：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This result is not surprising as support for the magic `__autoload()` function
    was removed in PHP 8\. In PHP 8, you must use `spl_autoload_register()` instead.
    We now turn our attention to `spl_autoload_register()`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果并不奇怪，因为在PHP 8中移除了对魔术`__autoload()`函数的支持。在PHP 8中，你必须使用`spl_autoload_register()`。现在我们转向`spl_autoload_register()`。
- en: Learning to use spl_autoload_register()
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习使用spl_autoload_register()
- en: The primary advantage of the `spl_autoload_register()` function is that it allows
    you to register more than one autoloader. Although this might seem like overkill,
    imagine the nightmare scenario where you are using a number of different open
    source PHP libraries... and where they all have their *own autoloaders* defined!
    As long as all such libraries use `spl_autoload_register()`, having multiple autoloader
    callbacks poses no problem.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`spl_autoload_register()`函数的主要优点是它允许你注册多个自动加载器。虽然这可能看起来有些多余，但想象一下一个噩梦般的情景，你正在使用许多不同的开源PHP库...它们都定义了自己的*自动加载器*！只要所有这些库都使用`spl_autoload_register()`，拥有多个自动加载器回调就不会有问题。'
- en: 'Each autoloader registered using `spl_autoload_register()` must be callable.
    Any of the following are considered `callable`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`spl_autoload_register()`注册的每个自动加载器都必须是可调用的。以下任何一种都被认为是`可调用`：
- en: A PHP procedural function
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个PHP过程函数
- en: An anonymous function
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个匿名函数
- en: A class method that can be called in a static manner
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以以静态方式调用的类方法
- en: Any class instance that defines the `__invoke()` magic method
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了`__invoke()`魔术方法的任何类实例
- en: 'An array in this form: `[$instance, ''method'']`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个这样的数组：`[$instance, 'method']`
- en: Tip
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '*Composer* maintains its own autoloader, which in turn relies upon `spl_autoload_register()`.
    If you are using Composer to manage your open source PHP packages, you can simply
    include `/path/to/project/vendor/autoload.php` at the start of your application
    code to use the Composer autoloader. To have Composer autoload your application
    source code files, add one or more entries into the `composer.json` file under
    the `autoload : psr-4` key. For more information, see [https://getcomposer.org/doc/04-schema.md#psr-4](https://getcomposer.org/doc/04-schema.md#psr-4).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*Composer*维护着自己的自动加载器，它又依赖于`spl_autoload_register()`。如果你正在使用Composer来管理你的开源PHP包，你可以简单地在应用程序代码的开头包含`/path/to/project/vendor/autoload.php`来使用Composer的自动加载器。要让Composer自动加载你的应用程序源代码文件，可以在`composer.json`文件的`autoload
    : psr-4`键下添加一个或多个条目。更多信息，请参见[https://getcomposer.org/doc/04-schema.md#psr-4](https://getcomposer.org/doc/04-schema.md#psr-4)。'
- en: 'A quite typical autoloader class might appear as follows. Note that this is
    the class we use for many of the OOP examples shown in this book:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相当典型的自动加载器类可能如下所示。请注意，这是我们在本书中许多OOP示例中使用的类：
- en: 'In the `__construct()` method, we assign the source directory. Following that,
    we call `spl_auto_register()` using the array callable syntax noted above:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__construct()`方法中，我们分配了源目录。随后，我们使用上面提到的数组可调用语法调用`spl_auto_register()`：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The actual autoloading code is similar to that shown in our `__autoload()`
    function example above. Here is the method that does the actual autoloading:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的自动加载代码与我们上面`__autoload()`函数示例中显示的类似。以下是执行实际自动加载的方法：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that you have an idea of how to use the `spl_auto_register()` function,
    we must examine a potential code break when running PHP 8.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何使用`spl_auto_register()`函数，我们必须检查在运行PHP 8时可能出现的代码中断。
- en: A potential spl_auto_register() code break in PHP 8
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP 8中潜在的spl_auto_register()代码中断
- en: The second argument to the `spl_auto_register()` function is an optional Boolean
    value that defaults to `FALSE`. If the second argument is set to `TRUE`, the `spl_auto_register()`
    function throws an `Exception` in PHP 7 and below versions if an autoloader fails
    to register. In PHP 8, however, if the data type of the second argument is anything
    other than `callable`, a fatal `TypeError` is thrown instead, regardless of the
    value of the second argument!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`spl_auto_register()`函数的第二个参数是一个可选的布尔值，默认为`FALSE`。如果将第二个参数设置为`TRUE`，则在PHP 7及以下版本中，如果自动加载程序注册失败，`spl_auto_register()`函数会抛出一个`Exception`。然而，在PHP
    8中，如果第二个参数的数据类型不是`callable`，则无论第二个参数的值如何，都会抛出致命的`TypeError`！'
- en: 'The simple program example shown next illustrates this danger. In this example,
    we use the `spl_auto_register()` function to register a PHP function that does
    not exist. We set the second argument to `TRUE`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面显示的简单程序示例说明了这种危险。在这个例子中，我们使用`spl_auto_register()`函数注册一个不存在的PHP函数。我们将第二个参数设置为`TRUE`：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we then run this block of code in PHP 7, here is the result:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在PHP 7中运行这个代码块，这是结果：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can determine from the output, an `Exception` is thrown. The `catch`
    block is invoked, and the message **A program error has occurred** appears. When
    we run the same program in PHP 8, however, a fatal `Error` is thrown:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以确定，抛出了一个`Exception`。`catch`块被调用，出现了消息**发生了程序错误**。然而，当我们在PHP 8中运行相同的程序时，会抛出一个致命的`Error`：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Obviously, the `catch` block was bypassed as it was designed to catch an `Exception`,
    not an `Error`. The simple solution is to have the `catch` block catch `Throwable`
    instead of `Exception`. This allows the same code to run in either PHP 7 or PHP
    8.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，“catch”块被绕过，因为它设计用于捕获“Exception”，而不是“Error”。简单的解决方法是让“catch”块捕获“Throwable”而不是“Exception”。这允许相同的代码在PHP
    7或PHP 8中运行。
- en: 'Here is how the rewritten code might appear. The output is not shown as it''s
    identical to the same example running in PHP 7:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重写后的代码可能如下所示。输出没有显示，因为它与在PHP 7中运行相同的示例相同：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You now have a better understanding of PHP 8 autoloading, and how to spot and
    correct potential autoloading backward-compatibility breaks. Let's now have a
    look at changes in PHP 8 pertaining to magic methods.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对PHP 8自动加载有了更好的理解，以及如何发现和纠正潜在的自动加载向后兼容性问题。现在让我们来看看PHP 8中与魔术方法相关的变化。
- en: Navigating changes in magic methods
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航魔术方法的变化
- en: PHP **magic methods** are predefined hooks that interrupt the normal flow of
    an OOP application. Each magic method, if defined, alters the behavior of the
    application from the minute the object instance is created, up until the point
    where the instance goes **out of scope**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的**魔术方法**是预定义的钩子，它们中断了OOP应用程序的正常流程。每个魔术方法，如果定义了，都会改变应用程序的行为，从对象实例创建的那一刻开始，直到实例超出范围的那一刻。
- en: Important note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: An object instance goes *out of scope* when it's unset or overwritten. Object
    instances also go out of scope when defined in a function or class method, and
    the execution of that function or class method ends. Ultimately, if for no other
    reason, an object instance goes out of scope when the PHP program ends.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对象实例在被取消或被覆盖时会*超出范围*。当在函数或类方法中定义对象实例时，对象实例也会超出范围，并且该函数或类方法的执行结束。最终，如果没有其他原因，当PHP程序结束时，对象实例会超出范围。
- en: This section will give you a solid understanding of important changes to magic
    method usage and behavior introduced in PHP 8\. Once you understand the situations
    described in this section, you will be in a position to make the appropriate code
    modifications to prevent your application code from failing should you migrate
    to PHP 8.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将让您充分了解PHP 8中引入的魔术方法使用和行为的重要变化。一旦您了解了本节描述的情况，您就能够进行适当的代码修改，以防止您的应用程序代码在迁移到PHP
    8时失败。
- en: Let's first have a look at changes to the object construct method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下对象构造方法的变化。
- en: Dealing with constructor changes
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理构造函数的变化
- en: Ideally, the **class constructor** is a method that's called automatically when
    the object instance is created and is used to perform some sort of object initialization.
    This initialization most typically involves populating object properties with
    values supplied as arguments to this method. The initialization could also perform
    any necessary tasks such as opening file handles, establishing a database connection,
    and so forth.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，**类构造函数**是一个在对象实例创建时自动调用的方法，用于执行某种对象初始化。这种初始化通常涉及使用作为参数提供给该方法的值填充对象属性。初始化还可以执行任何必要的任务，如打开文件句柄、建立数据库连接等。
- en: In PHP 8, a number of changes in how the class constructor is invoked have been
    made. This means there's a potential for a backwards compatibility break when
    you migrate your application to PHP 8\. The first change we'll examine has to
    do with deprecated usage of a method with the same name as the class being used
    as the class constructor.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，类构造函数被调用的方式发生了一些变化。这意味着当您将应用程序迁移到PHP 8时，可能会出现向后兼容性问题。我们将首先检查的变化与使用与类相同名称的方法作为类构造函数的方法有关。
- en: Handling changes in a method and class of the same name
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理具有相同名称的方法和类的变化
- en: In the first PHP OOP implementation, introduced in PHP version 4, it was determined
    that a method with the same name as the class would assume the role of class constructor,
    and would be automatically called when a new object instance was created.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 4版本中引入的第一个PHP OOP实现中，确定了与类相同名称的方法将承担类构造函数的角色，并且在创建新对象实例时将自动调用该方法。
- en: It's a little known fact that, even in PHP 8, functions, methods, and even class
    names, are *case-insensitive*. Thus `$a = new ArrayObject();` is equivalent to
    `$b = new arrayobject();`. Variable names, on the other hand, are case-sensitive.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 鲜为人知的是，即使在PHP 8中，函数、方法甚至类名都是*不区分大小写*的。因此`$a = new ArrayObject();`等同于`$b = new
    arrayobject();`。另一方面，变量名是区分大小写的。
- en: Starting with PHP 5, along with a new and much more robust OOP implementation,
    magic methods were introduced. One of these methods is `__construct()`, specifically
    reserved for class construction, designed to replace the older usage. Using a
    method with the same name as the class as a constructor was supported through
    the remaining versions of PHP 5, and all the way through all versions of PHP 7
    as well.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从PHP 5开始，随着一个新的更加健壮的OOP实现，魔术方法被引入。其中之一是`__construct()`，专门用于类构造，旨在取代旧的用法。通过PHP
    5的剩余版本，一直到所有的PHP 7版本，都支持使用与类同名的方法作为构造函数。
- en: 'In PHP 8, support for a class constructor method with the same name as the
    class itself has been removed. If a `__construct()` method is also defined, you
    will have no problem: `__construct()` takes precedence as a class constructor.
    If there is no `__construct()` method, and you detect a method with the same name
    as the `class` `()`, you have the potential for failure. Please bear in mind that
    both method and class names are case-insensitive!'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，删除了与类本身相同名称的类构造方法的支持。如果也定义了`__construct()`方法，你就不会有问题：`__construct()`优先作为类构造函数。如果没有`__construct()`方法，并且检测到一个与`class`
    `()`相同名称的方法，你就有可能失败。请记住，方法和类名都是不区分大小写的！
- en: 'Have a look at the following example. It works in PHP 7 but not in PHP 8:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下的例子。它在PHP 7中有效，但在PHP 8中无效：
- en: 'First, we define a `Text` class with a class constructor method of the same
    name. The constructor method creates an `SplFileObject` instance based upon the
    supplied filename:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个`Text`类，它有一个同名的类构造方法。构造方法基于提供的文件名创建了一个`SplFileObject`实例：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then add three lines of procedural code to exercise the class, supplying
    the filename of a file containing the Gettysburg Address:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加了三行过程代码来使用这个类，提供一个包含葛底斯堡演说的文件的文件名：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Running the program in PHP 7 first produces a deprecation notice, followed
    by the expected text. Only the first few lines of the output are shown here:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在PHP 7中运行程序会产生一个弃用通知，然后是预期的文本。这里只显示了输出的前几行：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running the same program in PHP 8, however, a fatal `Error` is thrown instead,
    as you can see from this output:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，在PHP 8中运行相同的程序会抛出一个致命的`Error`，如你从这个输出中看到的：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It's important to note that the error shown in PHP 8 does not tell you the real
    reason why the program failed. Hence, it's extremely important that you scan your
    PHP applications, especially older applications, to see if there's a method with
    the same name as the class. Accordingly, the **best practice** is to simply rename
    the method having the same name as the class to `__construct()`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在PHP 8中显示的错误并没有告诉你程序失败的真正原因。因此，非常重要的是要扫描你的PHP应用程序，特别是旧的应用程序，看看是否有一个与类同名的方法。因此，**最佳实践**就是简单地将与类同名的方法重命名为`__construct()`。
- en: Now let's have a look at how inconsistencies in handling `Exception` and `exit`
    in the class constructor have been addressed in PHP 8.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看在PHP 8中如何解决类构造函数中处理`Exception`和`exit`的不一致性。
- en: Addressing inconsistencies in the class constructor
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决类构造函数中的不一致性
- en: Another issue addressed in PHP 8 has to do with a situation where the class
    construct method either throws an `Exception`, or executes `exit()`. In PHP versions
    prior to PHP 8, if an `Exception` is thrown in the class constructor, the `__destruct()`
    method, if defined, is *not called*. On the other hand, if either `exit()` or
    `die()` (both PHP functions are equivalent to each other) is used in the constructor,
    the `__destruct()` method *is* called. In PHP 8, this inconsistency is addressed.
    Now, in either case, the `__destruct()` method *is not* called.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8中解决的另一个问题与类构造方法中抛出`Exception`或执行`exit()`有关。在PHP 8之前的版本中，如果在类构造函数中抛出`Exception`，则*不会调用*`__destruct()`方法（如果定义了）。另一方面，如果在构造函数中使用`exit()`或`die()`（这两个PHP函数是等效的），则会调用`__destruct()`方法。在PHP
    8中，这种不一致性得到了解决。现在，在任何情况下，`__destruct()`方法都*不会*被调用。
- en: You may be wondering why this is of concern. The reason why you need to be aware
    of this important change is that you might have logic residing in the `__destruct()`
    method that was called in a situation where you also might call either `exit()`
    or `die()`. In PHP 8, you can no longer rely upon this code, which may cause a
    backwards compatibility break.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么这很重要。你需要意识到这个重要的改变的原因是，你可能有逻辑存在于`__destruct()`方法中，而这个方法在你可能调用`exit()`或`die()`的情况下被调用。在PHP
    8中，你不能再依赖这段代码，这可能导致向后兼容性的破坏。
- en: 'In this example, we have two connection classes. `ConnectPdo` uses the PDO
    extension to provide query results, whereas `ConnectMysqli` uses the MySQLi extension:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个连接类。`ConnectPdo`使用PDO扩展来提供查询结果，而`ConnectMysqli`使用MySQLi扩展：
- en: 'We begin by defining an interface specifying a query method. This method requires
    a SQL string as an argument and is expected to return an array as a result:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个接口，指定一个查询方法。这个方法需要一个SQL字符串作为参数，并且期望返回一个数组作为结果：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we define a base class in which there is a `__destruct()` magic method
    defined. Because this class implements `ConnectInterface` but doesn''t define
    `query()`, it''s marked `abstract`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个基类，其中定义了一个`__destruct()`魔术方法。因为这个类实现了`ConnectInterface`但没有定义`query()`，所以它被标记为`abstract`：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we define the `ConnectPdo` class. It extends `Base`, and its `query()`
    method uses `PDO` syntax to produce a result. The `__construct()` method throws
    a `PDOException` if there is a problem creating the connection:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义`ConnectPdo`类。它继承自`Base`，它的`query()`方法使用`PDO`语法来产生结果。`__construct()`方法如果创建连接时出现问题，则抛出`PDOException`：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In a similar manner, we define the `ConnectMysqli` class. It extends `Base`,
    and its `query()` method uses `MySQLi` syntax to produce a result. The `__construct()`
    method executes `die()` if there is a problem creating the connection:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以类似的方式，我们定义了`ConnectMysqli`类。它继承自`Base`，它的`query()`方法使用`MySQLi`语法来产生结果。`__construct()`方法如果创建连接时出现问题，则执行`die()`：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we define a calling program that uses the two connection classes described
    previously, and defines invalid values for the connection string, username, and
    password:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义一个调用程序，使用先前描述的两个连接类，并为连接字符串、用户名和密码定义无效值：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, in the calling program, we call both classes and attempt to execute a
    query. The connection deliberately fails as we supply the wrong username and password:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在调用程序中，我们调用两个类，并尝试执行查询。连接故意失败，因为我们提供了错误的用户名和密码：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you now know from our discussion above, the output running in PHP 7 shows
    the `PDOException` being thrown from the class constructor when the `ConnectPdo`
    instance is created. On the other hand, when the `ConnectMysqli` instance fails,
    `die()` is called, with the message **Unable to Connect**. You also see, on the
    very last line of the output, the error log information originating from the `__destruct()`
    method. Here is that output:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您从上面的讨论中所了解的，PHP 7中运行的输出显示了在创建`ConnectPdo`实例时从类构造函数抛出`PDOException`。另一方面，当`ConnectMysqli`实例失败时，将调用`die()`，并显示消息**无法连接**。您还可以在输出的最后一行看到来自`__destruct()`方法的错误日志信息。以下是该输出：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In PHP 8, the `__destruct()` method is not called in either case, resulting
    in the output shown here. As you can see in the output, the `PDOException` is
    caught, and the `die()` command is issued. There is no output from the `__destruct()`
    method. The PHP 8 output is shown here:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PHP 8中，`__destruct()`方法在任何情况下都不会被调用，导致如下所示的输出。正如您在输出中所看到的，`PDOException`被捕获，然后发出`die()`命令。`__destruct()`方法没有任何输出。PHP
    8的输出如下：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now that you have an idea how to spot a potential code break with regards to
    the `__destruct()` method along with a call to either `die()` or `exit()`, let's
    turn our attention to changes to the `__toString()` method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何发现与`__destruct()`方法以及对`die()`或`exit()`的调用有关的潜在代码中断，让我们将注意力转向`__toString()`方法的更改。
- en: Working with changes to __toString()
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理对__toString()的更改
- en: The `__toString()` magic method is invoked when an object is used as a string.
    A classic example is when you simply echo an object. The `echo` command expects
    a string as an argument. When non-string data is provided, PHP performs type juggling
    to convert the data to `string`. As an object cannot be readily converted to `string`,
    the PHP engine then looks to see if `__toString()` is defined, and if so, returns
    its value.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象被用作字符串时，将调用`__toString()`魔术方法。一个经典的例子是当您简单地echo一个对象时。`echo`命令期望一个字符串作为参数。当提供非字符串数据时，PHP执行类型转换将数据转换为`string`。由于对象不能直接转换为`string`，因此PHP引擎会查看是否定义了`__toString()`，如果定义了，则返回其值。
- en: 'The major change in this magic method is the introduction of `Stringable`,
    a brand new interface. The new interface is defined as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个魔术方法的主要变化是引入了`Stringable`，一个全新的接口。新接口定义如下：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Any class running in PHP 8 that defines the `__toString()` magic method silently
    implements the `Stringable` interface. This new behavior doesn't present any serious
    potential for a code break. However, since the class now implements the `Stringable`
    interface, you are no longer allowed to modify the `__toString()` method signature.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中运行的任何类，如果定义了`__toString()`魔术方法，都会静默实现`Stringable`接口。这种新行为并不会导致严重的潜在代码中断。然而，由于类现在实现了`Stringable`接口，您将不再允许修改`__toString()`方法的签名。
- en: 'Here is a short example that reveals the new association with the `Stringable`
    interface:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简短的示例，揭示了与`Stringable`接口的新关联：
- en: 'In this example, we define a `Test` class that defines `__toString()`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个定义了`__toString()`的`Test`类：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We then create an instance of the class, followed by a `ReflectionObject` instance:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建类的一个实例，然后是一个`ReflectionObject`实例：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first few lines of output running in PHP 7 (shown here) simply reveal that
    it''s an instance of the `Test` class:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中运行的输出的前几行（如下所示）只是显示它是`Test`类的一个实例：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Running the same code example in PHP 8, however, reveals the silent association
    with the `Stringable` interface:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PHP 8中运行相同的代码示例，揭示了与`Stringable`接口的静默关联：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The output shows that even though you did not explicitly implement the `Stringable`
    interface, the association was created at runtime, and is revealed by the `ReflectionObject`
    instance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，即使您没有显式实现`Stringable`接口，也会在运行时创建关联，并由`ReflectionObject`实例显示。
- en: Tip
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on magic methods, have a look at this documentation page:
    [https://www.php.net/manual/en/language.oop5.magic.php](https://www.php.net/manual/en/language.oop5.magic.php).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有关魔术方法的更多信息，请参阅此文档页面：[https://www.php.net/manual/en/language.oop5.magic.php](https://www.php.net/manual/en/language.oop5.magic.php)。
- en: Now that you have an understanding of the situations where PHP 8 code involving
    magic methods could cause a code break, let's have a look at changes in the serialization
    process.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了PHP 8代码涉及魔术方法可能导致代码中断的情况，让我们来看看序列化过程中的更改。
- en: Taking control of serialization
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制序列化
- en: There are many times when native PHP data needs to be stored in a file, or in
    a database table. The problem with current technology is that direct storage of
    complex PHP data such as objects or arrays is simply not possible, with some exceptions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多时候，需要将本机PHP数据存储在文件中，或者存储在数据库表中。当前技术的问题在于，直接存储复杂的PHP数据，如对象或数组，是不可能的，除了一些例外。
- en: One way to overcome this limitation is to convert the object or array into a
    string. **JSON** (**JavaScript Object Notation**) is often chosen for this reason.
    Once the data has been converted into a string, it can easily be stored in any
    file or database. However, there is a problem with formatting objects with JSON.
    Although JSON is able to represent object properties well enough, it's incapable
    of directly restoring the original object's class and methods.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 克服这种限制的一种方法是将对象或数组转换为字符串。**JSON**（JavaScript对象表示）通常因此而被选择。一旦数据被转换为字符串，它就可以轻松地存储在任何文件或数据库中。然而，使用JSON格式化对象存在问题。尽管JSON能够很好地表示对象属性，但它无法直接恢复原始对象的类和方法。
- en: To address this deficiency, the PHP language includes two native functions,
    `serialize()` and `unserialize()`, that can easily convert objects or arrays into
    a string and restore them back to their original state. As wonderful as this sounds,
    there are a number of issues associated with native PHP serialization.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个缺陷，PHP语言包括两个原生函数`serialize()`和`unserialize()`，可以轻松地将对象或数组转换为字符串，并将它们恢复到原始状态。尽管听起来很棒，但与原生PHP序列化相关的问题有很多。
- en: Before we can properly discuss the problem with the existing PHP serialization
    architecture, we need to have a closer look at how native PHP serialization works.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够正确讨论现有PHP序列化架构的问题之前，我们需要更仔细地了解原生PHP序列化的工作方式。
- en: Understanding PHP serialization
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解PHP序列化
- en: When a PHP object or array needs to be saved to a non-OOP environment such as
    a flat file or relational database table, `serialize()` can be used to *flatten*
    an object or array into a string, suitable for storage. Conversely, `unserialize()`
    restores the original object or array.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当PHP对象或数组需要保存到非面向对象编程环境（如平面文件或关系数据库表）时，可以使用`serialize()`将对象或数组“扁平化”为适合存储的字符串。相反，`unserialize()`会恢复原始对象或数组。
- en: 'Here is a simple example that demonstrates this concept:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是演示这个概念的一个简单示例：
- en: 'First, we define a class with three properties:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个具有三个属性的类：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We then create an instance, serialize the instance, and display the resulting
    string:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个实例，对该实例进行序列化，并显示生成的字符串：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is how the serialized object appears:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是序列化对象的样子：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see from the serialized string, the letter `O` designates *Object*,
    `a` is for *array*, `s` is for *string* and `i` is for *integer*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从序列化字符串中可以看出，字母`O`代表*对象*，`a`代表*数组*，`s`代表*字符串*，`i`代表*整数*。
- en: 'We then unserialize the object into a new variable and use `var_dump()` to
    examine the two:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将对象反序列化为一个新变量，并使用`var_dump()`来检查这两个变量：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Placing the `var_dump()` outputs side by side, you can clearly see that the
    restored object is identical to the original:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`var_dump()`的输出并排放置，您可以清楚地看到恢复的对象与原始对象是相同的：
- en: '![](image/B16992_05_table_1.1.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B16992_05_table_1.1.jpg)'
- en: 'Let''s now have a look at the magic methods that supply legacy PHP serialization
    support: `__sleep()` and `__wakeup()`.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下支持旧版PHP序列化的魔术方法：`__sleep()`和`__wakeup()`。
- en: Understanding the __sleep() magic method
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解`__sleep()`魔术方法
- en: The purpose of the `__sleep()` magic method is to provide a filter used to prevent
    certain properties from appearing in the serialized string. To use a user object
    as an example, you may wish to exclude sensitive properties such as a national
    identification number, credit card number, or password from the serialization.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`__sleep()`魔术方法的目的是提供一个过滤器，用于防止某些属性出现在序列化字符串中。以用户对象为例，您可能希望排除敏感属性，如国民身份证号码、信用卡号码或密码。'
- en: 'Here is an example using the `__sleep()` magic method to exclude a password:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`__sleep()`魔术方法来排除密码的示例：
- en: 'First, we define a `Test` class with three properties:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个具有三个属性的`Test`类：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We then define a `__sleep()` method that excludes the `$password` property:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个`__sleep()`方法来排除`$password`属性：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We then create an instance of this class and serialize it. The last line echoes
    the state of the serialized string:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建这个类的一个实例并对其进行序列化。最后一行输出序列化字符串的状态：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the output, you can clearly see that the `$password` property is not present.
    Here is the output:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输出中，您可以清楚地看到`$password`属性不存在。以下是输出：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is important in that, in most cases, the reason you need to serialize an
    object is you wish to store it somewhere, whether that be in a session file or
    in a database. If the filesystem or database is subsequently compromised, you
    have one less security vulnerability to worry about!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点很重要，因为在大多数情况下，您需要对对象进行序列化的原因是希望将其存储在某个地方，无论是在会话文件中还是在数据库中。如果文件系统或数据库随后受到损害，您就少了一个安全漏洞需要担心！
- en: Understanding a potential code break in the __sleep() method
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解`__sleep()`方法中潜在的代码中断
- en: There is a potential code break involving the `__sleep()` magic method. In versions
    prior to PHP 8, if `__sleep()` returns an array with non-existent properties,
    they are still serialized and assigned a value of `NULL`. The problem with this
    approach is that when the object is subsequently unserialized, an extra property
    now appears, one that is not there by design!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`__sleep()`魔术方法涉及潜在的代码中断。在PHP 8之前的版本中，如果`__sleep()`返回一个包含不存在属性的数组，它们仍然会被序列化并赋予一个`NULL`值。这种方法的问题在于，当对象随后被反序列化时，会出现一个额外的属性，这不是设计时存在的属性！'
- en: In PHP 8, non-existent properties in the `__sleep()` magic method return are
    silently ignored. If your legacy code anticipates the old behavior and takes steps
    to *delete* the unwanted property, or even worse, if your code assumes the unwanted
    property exists, you will ultimately have an error. Such assumptions are extremely
    dangerous as they can lead to unexpected code behavior.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，`__sleep()`魔术方法中不存在的属性会被静默忽略。如果您的旧代码预期旧的行为并采取步骤*删除*不需要的属性，或者更糟糕的是，如果您的代码假设不需要的属性存在，最终会出现错误。这样的假设非常危险，因为它们可能导致意外的代码行为。
- en: 'To illustrate the issue, have a look at the following code example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明问题，让我们看一下以下代码示例：
- en: 'First, we define a `Test` class that defines `__sleep()` to return a variable
    that doesn''t exist:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个`Test`类，该类定义了`__sleep()`来返回一个不存在的变量：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we create an instance of `Test` and serialize it:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`Test`的实例并对其进行序列化：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We then unserialize the string into a new instance, `$restored`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将字符串反序列化为一个新实例`$restored`：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In theory, the two object instances `$test` and `$restored` should be the same.
    However, have a look at the output running in PHP 7:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理论上，两个对象实例`$test`和`$restored`应该是相同的。然而，看一下在PHP 7中运行的输出：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see from the output, the two objects are clearly *not* the same!
    However, in PHP 8, the non-existent property is ignored. Have a look at the same
    script running in PHP 8:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输出中可以看出，这两个对象显然*不*相同！然而，在PHP 8中，不存在的属性被忽略。看一下在PHP 8中运行相同脚本的情况：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You might also observe that in PHP 7, a `Notice` is issued, whereas in PHP 8,
    the same situation produces a `Warning`. A pre-migration check for a potential
    code break in this case is difficult because you would need to determine, if the
    magic method `__sleep()` is defined, whether or not a non-existent property is
    being included in the list.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还注意到，在PHP 7中，会发出一个`Notice`，而在PHP 8中，相同的情况会产生一个`Warning`。在这种情况下，对潜在代码中断的预迁移检查是困难的，因为您需要确定魔术方法`__sleep()`是否被定义，以及是否在列表中包含了一个不存在的属性。
- en: Let's now have a look at the counterpart method, `__wakeup()`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看对应的方法`__wakeup()`。
- en: Learning about __wakeup()
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习__wakeup()
- en: 'The purpose of the `__wakeup()` magic method is mainly to perform additional
    initialization on the unserialized object. Examples would be to restore a database
    connection or reinstate a file handle. Here''s a very simple example that uses
    `__wakeup()` magic to re-open a file handle:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`__wakeup()`魔术方法的目的主要是在反序列化对象时执行额外的初始化。例如，恢复数据库连接或恢复文件句柄。下面是一个使用`__wakeup()`魔术方法重新打开文件句柄的非常简单的例子：'
- en: 'First, we define a class that opens a file handle upon instantiation. We also
    define a method that returns the contents of the file:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个在实例化时打开文件句柄的类。我们还定义一个返回文件内容的方法：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To use the class, create an instance, and run `getText()`. (This assumes that
    the file referenced by `$this->fn` exists!)
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用这个类，创建一个实例，并运行`getText()`。（这假设`$this->fn`引用的文件存在！）
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The output (not shown) is the Gettysburg Address.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出（未显示）是葛底斯堡演说。
- en: 'If we now attempt to serialize this object, a problem arises. Here''s an example
    of code that would serialize the object:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在尝试对这个对象进行序列化，就会出现问题。下面是一个可能序列化对象的代码示例：
- en: '`$str = serialize($old);`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`$str = serialize($old);`'
- en: 'At this point, running the code in place so far, here is the output:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，在原地运行代码，这是输出：
- en: '[PRE50]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In order to fix this problem, we return to the class and add a `__sleep()`
    method that prevents the `SplFileObject` instance from being serialized:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们返回到类中，添加一个`__sleep()`方法，防止`SplFileObject`实例被序列化：
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we then rerun the code to serialize the object, all is well. Here is the
    code to unserialize and call `getText()`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们重新运行代码来序列化对象，一切都很好。这是反序列化和调用`getText()`的代码：
- en: '[PRE52]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'However, if we then attempt to unserialize the object, another error occurs:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试对对象进行反序列化，就会出现另一个错误：
- en: '[PRE53]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The problem, of course, is that the file handle was lost during serialization.
    When the object was unserialized, the `__construct()` method was not called.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 问题当然是，在序列化过程中文件句柄丢失了。当对象被反序列化时，`__construct()`方法没有被调用。
- en: 'This is exactly why the `__wakeup()` magic method exists. To resolve the error,
    we define a `__wakeup()` method that calls the `__construct()` method:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这正是`__wakeup()`魔术方法存在的原因。为了解决错误，我们定义一个`__wakeup()`方法，调用`__construct()`方法：
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If we rerun the code, we now see the Gettysburg Address twice (not shown).
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们重新运行代码，现在我们会看到葛底斯堡演说出现两次（未显示）。
- en: Now you have an idea of how PHP native serialization works, and also know a
    bit about the `__sleep()` and `__wakeup()` magic methods, as well as potential
    code breaks. Let's now have a look at an interface that was designed to facilitate
    the custom serialization of objects.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了PHP原生序列化的工作原理，也了解了`__sleep()`和`__wakeup()`魔术方法，以及潜在的代码中断。现在让我们来看一下一个旨在促进对象自定义序列化的接口。
- en: Introducing the Serializable interface
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Serializable接口
- en: In order to facilitate the serialization of objects, the `Serializable` interface
    was added to the language beginning with PHP 5.1\. The idea behind this interface
    was to provide a way of identifying objects that had the ability to serialize
    themselves. In addition, the methods specified by this interface were designed
    to provide some degree of control over object serialization.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了促进对象的序列化，从PHP 5.1开始，语言中添加了`Serializable`接口。这个接口的想法是提供一种识别具有自我序列化能力的对象的方法。此外，该接口指定的方法旨在在对象序列化过程中提供一定程度的控制。
- en: 'As long as a class implements this interface, developers are assured that two
    methods are defined: `serialize()` and `unserialize()`. Here is the interface
    definition:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 只要一个类实现了这个接口，开发人员就可以确保两个方法被定义：`serialize()`和`unserialize()`。这是接口定义：
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Any class that implements this interface has its custom `serialize()` and `unserialize()`
    methods automatically invoked during native serialization or unserialization.
    To illustrate this technique, consider the following example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现了这个接口的类，在本地序列化或反序列化过程中，其自定义`serialize()`和`unserialize()`方法会自动调用。为了说明这种技术，考虑以下示例：
- en: 'First, we define a class that implements the `Serializable` interface. The
    class defines three properties – two of type string, the other representing date
    and time:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个实现`Serializable`接口的类。该类定义了三个属性 - 两个是字符串类型，另一个表示日期和时间：
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We then define a custom `serialize()` method that initializes the date and
    time before serializing the object''s properties. The `unserialize()` method restores
    values to all properties:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个自定义的`serialize()`方法，在序列化对象的属性之前初始化日期和时间。`unserialize()`方法将值恢复到所有属性中：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We then create an instance and examine its contents using `var_dump()`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个实例，并使用`var_dump()`检查其内容：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The output from `var_dump()` shows us that the `u` property is not yet initialized:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var_dump()`的输出显示`u`属性尚未初始化：'
- en: '[PRE59]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We then serialize it, and restore it to a variable, `$a2`:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们对其进行序列化，并将其恢复到一个变量`$a2`中：
- en: '[PRE60]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'From the `var_dump()` output below, you can see that the object has been fully
    restored. In addition, we know that the custom `serialize()` method was invoked
    because the `u` property is initialized with a date and time value. Here is the
    output:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下面的`var_dump()`输出中，您可以看到对象已经完全恢复。此外，我们知道自定义的`serialize()`方法被调用，因为`u`属性被初始化为日期和时间值。以下是输出：
- en: '[PRE61]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Let's now have a look at issues with the serialization process for objects that
    implement the `Serializable` interface.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下实现`Serializable`接口的对象在序列化过程中可能出现的问题。
- en: Examining PHP serializable interface issues
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查PHP可序列化接口问题
- en: There is an overall problem with the earlier approach to serialization. If a
    class to be serialized has defined a `__wakeup()` magic method, it's not invoked
    immediately upon unserialization. Rather, any defined `__wakeup()` magic methods
    are first queued up, the entire chain of objects is unserialized, and only then
    are methods in the queue executed. This can result in a mismatch between what
    is seen by an object's `unserialize()` method compared to what is seen by its
    queued `__wakeup()` method.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 早期序列化方法存在一个整体问题。如果要序列化的类定义了一个`__wakeup()`魔术方法，它不会立即在反序列化时被调用。相反，任何定义的`__wakeup()`魔术方法首先被排队，整个对象链被反序列化，然后才执行队列中的方法。这可能导致对象的`unserialize()`方法看到的与其排队的`__wakeup()`方法看到的不一致。
- en: This architectural flaw can result in inconsistent behavior and ambiguous results
    when dealing with objects that implement the `Serializable` interface. Many developers
    consider the `Serializable` interface to be severely broken due to the need to
    create back references when the serialization of nested objects occurs. This need
    arises in situations where **nested serialization calls** occur.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构缺陷可能导致处理实现`Serializable`接口的对象时出现不一致的行为和模棱两可的结果。许多开发人员认为`Serializable`接口由于在嵌套对象序列化时需要创建反向引用而严重破损。这种需要出现在**嵌套序列化调用**的情况下。
- en: Such nested calls might occur, for example, when a class defines a method that
    in turn calls the PHP `serialize()` function. The order in which back references
    are created is preset in PHP serialization prior to PHP 8, potentially causing
    an avalanche of cascading failures.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当一个类定义了一个方法，该方法反过来调用PHP的`serialize()`函数时，可能会发生这样的嵌套调用。在PHP 8之前，PHP序列化中预设了创建反向引用的顺序，可能导致一系列级联的失败。
- en: The solution is to use two new magic methods to give you complete control over
    serialization and unserialization sequencing, described next.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用两个新的魔术方法来完全控制序列化和反序列化的顺序，接下来将进行描述。
- en: New magic methods to control PHP serialization
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制PHP序列化的新魔术方法
- en: 'A new way of controlling serialization was first introduced in PHP 7.4 and
    carried over into PHP 8\. In order to take advantage of this new technology, all
    you need to do is to implement two magic methods: `__serialize()` and `__unserialize()`.
    If implemented, PHP turns control over serialization entirely to the `__serialize()`
    method. Likewise, unserialization is entirely controlled by the `__unserialize()`
    magic method. The `__sleep()` and `__wakeup()` methods, if defined, are ignored.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 控制序列化的新方法首先在PHP 7.4中引入，并在PHP 8中继续使用。为了利用这项新技术，您只需要实现两个魔术方法：`__serialize()`和`__unserialize()`。如果实现了，PHP将完全将序列化的控制权交给`__serialize()`方法。同样，反序列化完全由`__unserialize()`魔术方法控制。如果定义了`__sleep()`和`__wakeup()`方法，则会被忽略。
- en: 'As a further benefit, PHP 8 provides full support for the two new magic methods
    in the following SPL classes:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个进一步的好处，PHP 8完全支持以下SPL类中的两个新的魔术方法：
- en: '`ArrayObject`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayObject`'
- en: '`ArrayIterator`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayIterator`'
- en: '`SplDoublyLinkedList`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SplDoublyLinkedList`'
- en: '`SplObjectStorage`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SplObjectStorage`'
- en: Best practice
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'To gain full control over serialization, implement the new `__serialize()`
    and `__unserialize()` magic methods. You no longer need to implement the `Serializable`
    interface, nor do you need to define `__sleep()` and `__wakeup()`. For more information
    on the eventual discontinuation of the `Serializable` interface, see this RFC:
    [https://wiki.php.net/rfc/phase_out_serializable](https://wiki.php.net/rfc/phase_out_serializable).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全控制序列化，实现新的`__serialize()`和`__unserialize()`魔术方法。您不再需要实现`Serializable`接口，也不需要定义`__sleep()`和`__wakeup()`。有关`Serializable`接口最终停用的更多信息，请参阅此RFC：[https://wiki.php.net/rfc/phase_out_serializable](https://wiki.php.net/rfc/phase_out_serializable)。
- en: 'As an example of the new PHP serialization usage, consider the following code
    example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 作为新的PHP序列化用法的示例，请考虑以下代码示例：
- en: 'In the example, a `Test` class is initialized with a random key upon instantiation:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在示例中，一个`Test`类在实例化时使用一个随机密钥进行初始化：
- en: '[PRE62]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We add a `getKey()` method that reveals the current key value:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加一个`getKey()`方法来显示当前的关键值：
- en: '[PRE63]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'When serialized, the key is filtered out of the resulting string:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在序列化时，关键点被过滤出结果字符串：
- en: '[PRE64]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Upon unserialization, a new key is generated:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在反序列化时，生成一个新的关键点：
- en: '[PRE65]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We now create an instance, and reveal the key:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建一个实例，并揭示关键点：
- en: '[PRE66]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here is how the key might appear:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点可能会出现如下：
- en: '[PRE67]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We add code to serialize the object and display the string:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加代码来序列化对象并显示字符串：
- en: '[PRE68]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here is how the serialized string might appear:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是序列化字符串可能的样子：
- en: '[PRE69]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note from the output that the secret does not appear in the serialized string.
    This is important because if the storage location of the serialized string is
    compromised, a security vulnerability might be exposed, giving an attacker a way
    to break into your system.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看到，秘密不会出现在序列化的字符串中。这很重要，因为如果序列化字符串的存储位置受到损害，可能会暴露安全漏洞，使攻击者有可能侵入您的系统。
- en: 'We then add code to unserialize the string and reveal the key:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加代码来反序列化字符串并显示关键点：
- en: '[PRE70]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here is the last bit of output. Notice that a new key has been generated:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一部分输出。请注意，生成了一个新的关键点：
- en: '[PRE71]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As you can see, using the new PHP serialization feature is not complicated.
    Any timing issues are now fully in your control because the new magic methods
    are executed in the order in which the objects are serialized and unserialized.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，使用新的PHP序列化功能并不复杂。任何时间问题现在完全在您的控制之下，因为新的魔术方法是按照对象序列化和反序列化的顺序执行的。
- en: Important note
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: PHP 7.4 and above *understands* serialized strings from older versions of PHP,
    however, strings serialized by PHP 7.4 or 8.x might not be properly unserialized
    by older versions of PHP.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7.4及以上版本*能够*理解来自旧版本PHP的序列化字符串，但是由PHP 7.4或8.x序列化的字符串可能无法被旧版本的PHP正确反序列化。
- en: Tip
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For a full discussion, please see the RFC on custom serialization:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整讨论，请参阅有关自定义序列化的RFC：
- en: https://wiki.php.net/rfc/custom_object_serialization
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: https://wiki.php.net/rfc/custom_object_serialization
- en: You now have a full understanding of PHP serialization and the improved support
    provided by the two new magic methods. It's now time to shift gears and examine
    how PHP 8 expands variance support.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经完全了解了PHP序列化和两种新的魔术方法提供的改进支持。现在是时候转变思路，看看PHP 8如何扩展方差支持了。
- en: Understanding PHP 8 expanded variance support
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解PHP 8扩展的方差支持
- en: The concept of variance is at the heart of OOP. **Variance** is an umbrella
    term that covers how the various **subtypes** interrelate. Some 20 years ago,
    a pair of early computer scientists, Wing and Liskov, devised an important theorem
    that is at the heart of OOP subtypes, now known as **the Liskov Substitution Principle**.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 方差的概念是面向对象编程的核心。**方差**是一个涵盖各种**子类型**相互关系的总称。大约20年前，早期计算机科学家Wing和Liskov提出了一个重要的定理，它是面向对象编程子类型的核心，现在被称为**Liskov替换原则**。
- en: 'Without going into the precise mathematics, this principle can be paraphrased
    as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要进入精确的数学，这个原则可以被解释为：
- en: '*Class X can be considered a subtype of class Y if you are able to substitute
    an instance of X in place of an instance of Y, and the application''s behavior
    does not change in any way.*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您能够在类Y的实例的位置替换X的实例，并且应用程序的行为没有任何改变，那么类X可以被认为是类Y的子类型。*'
- en: Tip
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The actual paper that first described and provided the precise mathematical
    formulaic definition of the Liskov Substitution Principle can be found here: *A
    behavioral notion of subtyping*, ACM Transactions on Programming Languages and
    Systems, by B. Liskov and J. Wing, November 1994 (https://dl.acm.org/doi/10.1145/197320.197383).'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 首次描述并提供了Liskov替换原则的精确数学公式定义的实际论文可以在这里找到：*子类型的行为概念*，ACM编程语言和系统交易，由B. Liskov和J.
    Wing，1994年11月（https://dl.acm.org/doi/10.1145/197320.197383）。
- en: In this section, we examine how PHP 8 provides enhanced variance support in
    the form of **covariant returns** and **contraviariant parameters**. An understanding
    of covariance and contravariance will increase your ability to write good solid
    code. Without this understanding, your code might produce inconsistent results
    and become the source of many bugs.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨PHP 8如何以**协变返回**和**逆变参数**的形式提供增强的方差支持。对协变和逆变的理解将增强您编写良好稳固代码的能力。如果没有这种理解，您的代码可能会产生不一致的结果，并成为许多错误的根源。
- en: Let's start by covering covariant returns.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论协变返回。
- en: Understanding covariant returns
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解协变返回
- en: 'Covariance support in PHP is designed to preserve the ordering of types from
    the most specific to the most general. A classic example of this is seen in how
    `try / catch` blocks are formulated:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中的协变支持旨在保留从最具体到最一般的类型的顺序。这在`try / catch`块的构造中经典地体现出来：
- en: 'In this example, a `PDO` instance is created inside the `try` block. The following
    two `catch` blocks look first for a `PDOException`. Following this is a second
    `catch` block that catches any class that implements `Throwable`. Because both
    the PHP `Exception` and `Error` classes implement `Throwable`, the second `catch`
    block ends up as a fallback for any error other than a `PDOException`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，`PDO`实例是在`try`块内创建的。接下来的两个`catch`块首先寻找`PDOException`。接着是一个第二个`catch`块，它捕获任何实现`Throwable`的类。因为PHP的`Exception`和`Error`类都实现了`Throwable`，所以第二个`catch`块最终成为除了`PDOException`之外的任何错误的后备：
- en: '[PRE72]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this example, if a `PDO` instance fails due to invalid parameters, the error
    log would have the entry **Database Error** followed by a message gleaned from
    the `PDOException`.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，如果`PDO`实例由于无效参数而失败，错误日志将包含条目**数据库错误**，后面跟着从`PDOException`中获取的消息。
- en: On the other hand, if some other general error occurred, the error log would
    have the entry **Unknown Error** followed by the message coming from some other
    `Exception` or `Error` class.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，如果发生了其他一般错误，错误日志将包含条目**未知错误**，后面跟着来自其他`Exception`或`Error`类的消息。
- en: 'In this example, however, the order of the `catch` blocks is reversed:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，在这个例子中，`catch`块的顺序是颠倒的：
- en: '[PRE73]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Due to the way PHP covariance support works, the second `catch` block would
    never be invoked. Instead, all error log entries originating from this block of
    code would have an entry starting with **Unknown Error**.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于PHP协变支持的工作方式，第二个`catch`块永远不会被调用。相反，所有源自此代码块的错误日志条目将以**未知错误**开头。
- en: 'Let''s now have a look at how PHP covariance support applies to object method
    return data types:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看PHP协变支持如何适用于对象方法返回数据类型：
- en: 'First, we define an interface, `FactoryIterface`, that identifies a method,
    `make()`. This method accepts an `array` as an argument and is expected to return
    an object of type `ArrayObject`:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个接口`FactoryIterface`，它标识一个`make()`方法。此方法接受一个`array`作为参数，并且预期返回一个`ArrayObject`类型的对象：
- en: '[PRE74]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Next, we define an `ArrTest` class that extends `ArrayObject`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`ArrTest`类，它扩展了`ArrayObject`：
- en: '[PRE75]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `ArrFactory` class implements `FactoryInterface` and fully defines the
    `make()` method. Note, however, that this method returns the `ArrTest` data type
    and not `ArrayObject`:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ArrFactory`类实现了`FactoryInterface`并完全定义了`make()`方法。但是，请注意，此方法返回`ArrTest`数据类型而不是`ArrayObject`：'
- en: '[PRE76]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In the block of procedural calling code, we create an instance of `ArrFactory`,
    and run its `make()` method twice, theoretically producing two `ArrTest` instances.
    We then use `var_dump()` to reveal the current state of the two objects produced:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序调用代码块中，我们创建了一个`ArrFactory`的实例，并两次运行其`make()`方法，理论上产生了两个`ArrTest`实例。然后我们使用`var_dump()`来显示所产生的两个对象的当前状态：
- en: '[PRE77]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In PHP 7.1, as it does not support covariant return data types, a fatal `Error`
    is thrown. The output, shown here, tells us that the method return type declaration
    doesn''t match what''s been defined in `FactoryInterface`:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PHP 7.1中，由于它不支持协变返回数据类型，会抛出致命的`Error`。下面显示的输出告诉我们，方法返回类型声明与`FactoryInterface`中定义的不匹配：
- en: '[PRE78]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'When we run the same code in PHP 8, you can see that covariance support is
    provided for return types. Execution proceeds unhindered, as shown here:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在PHP 8中运行相同的代码时，您会看到对返回类型提供了协变支持。执行继续进行，如下所示：
- en: '[PRE79]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '`ArrTest` extends `ArrayObject` and is a suitable subtype that clearly meets
    the criteria defined by the Liskov Substitution Principle. As you can see from
    the last output, PHP 8 more fully embraces true OOP principles than the earlier
    versions of PHP. The end result is that your code and application architecture
    can be much more intuitive and logically reasonable when using PHP 8.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrTest`扩展了`ArrayObject`，是一个明显符合里氏替换原则定义的条件的子类型。正如您从最后的输出中看到的那样，PHP 8比之前的PHP版本更全面地接受了真正的面向对象编程原则。最终结果是，在使用PHP
    8时，您的代码和应用架构可以更直观和逻辑合理。'
- en: Let's now have a look at contravariant parameters.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看逆变参数。
- en: Using contravariant parameters
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用逆变参数
- en: 'Whereas covariance concerns the ordering of subtypes from general to specific,
    **contravariance** concerns the reverse: from specific to general. In PHP 7 and
    earlier, full support for contravariance was not available. Accordingly, implementing
    an interface or extending an abstract class, in PHP 7, parameter type hints are
    **invariant**.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 而协变关注的是从一般到特定的子类型的顺序，**逆变**关注的是相反的顺序：从特定到一般。在PHP 7及更早版本中，对逆变的完全支持是不可用的。因此，在PHP
    7中，实现接口或扩展抽象类时，参数类型提示是**不变**的。
- en: In PHP 8, on the other hand, due to support for contravariant parameters, you
    are free to be specific in top-level super classes and interfaces. As long as
    the subtype is compatible, you can then modify the type hint in the extending
    or implementing class to be more general.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在PHP 8中，由于对逆变参数的支持，您可以在顶级超类和接口中自由地具体化。只要子类型是兼容的，您就可以修改扩展或实现类中的类型提示为更一般的类型。
- en: This gives you much more freedom in defining an overall architecture where you
    define interfaces or abstract classes. Developers using your interfaces or super
    classes are given a great deal more flexibility in PHP 8 when it comes to implementing
    descendent class logic.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这使您在定义整体架构时更自由地定义接口或抽象类。在使用您的接口或超类的开发人员在实现后代类逻辑时，PHP 8在实现时提供了更多的灵活性。
- en: 'Let''s have a look at how PHP 8 support for contravariant parameters works:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看PHP 8对逆变参数的支持是如何工作的：
- en: 'In this example, we first define a `IterObj` class that extends the built-in
    `ArrayIterator PHP class`:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先定义了一个`IterObj`类，它扩展了内置的`ArrayIterator PHP类`：
- en: '[PRE80]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We then define an abstract `Base` class that mandates a method, `stringify()`.
    Note that the data type for its only argument is `IterObj`:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个抽象的`Base`类，规定了一个`stringify()`方法。请注意，它唯一参数的数据类型是`IterObj`：
- en: '[PRE81]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Next, we define a `IterTest` class that extends `Base` and provides an implementation
    for the `stringify()` method. Of particular interest is that we override the data
    type, changing it to `iterable`:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`IterTest`类，它扩展了`Base`并为`stringify()`方法提供了实现。特别值得注意的是，我们覆盖了数据类型，将其更改为`iterable`：
- en: '[PRE82]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The next few lines of code create instances of `IterTest`, `IterObj`, and `ArrayIterator`.
    We then invoke the `stringify()` method twice, supplying each of the latter objects
    as an argument:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的几行代码创建了`IterTest`、`IterObj`和`ArrayIterator`的实例。然后我们调用`stringify()`方法两次，分别将后两个对象作为参数提供：
- en: '[PRE83]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Running this code example in PHP 7.1 produces the expected fatal `Error` as
    shown here:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PHP 7.1中运行此代码示例会产生预期的致命`Error`，如下所示：
- en: '[PRE84]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Because PHP 7.1 does not provide support for contravariant parameters, it treats
    the data type for its parameters as invariant, and simply displays a message indicating
    that the data type of the child class is incompatible with the data type specified
    in the parent class.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 因为PHP 7.1不支持逆变参数，它将其参数的数据类型视为不变，并简单地显示一条消息，指示子类的数据类型与父类中指定的数据类型不兼容。
- en: 'PHP 8, on the other hand, provides support for contravariant parameters. Accordingly,
    it recognizes that `IterObj`, the data type specified in the `Base` class, is
    a subtype compatible with `iterable`. Further, both arguments provided are compatible
    with `iterable` as well, allowing program execution to proceed. Here is the PHP
    8 output:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，PHP 8提供了对逆变参数的支持。因此，它认识到`IterObj`，在`Base`类中指定的数据类型，是与`iterable`兼容的子类型。此外，提供的两个参数也与`iterable`兼容，允许程序执行继续进行。以下是PHP
    8的输出：
- en: '[PRE85]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The main advantage you derive from PHP 8 support for covariant returns and contravariant
    parameters is the ability to override not only method logic but the **method signature**
    as well. You will find that although PHP 8 is much stricter in its enforcement
    of good coding practices, the enhanced variance support gives you greater freedom
    in designing your inheritance structure. In a certain sense, at least with regards
    to parameter and return value data types, PHP 8 is, if anything, *less* restrictive!
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8对协变返回和逆变参数的支持带来的主要优势是能够覆盖方法逻辑以及**方法签名**。您会发现，尽管PHP 8在执行良好的编码实践方面要严格得多，但增强的变异支持使您在设计继承结构时拥有更大的自由度。在某种意义上，至少在参数和返回值数据类型方面，PHP
    8是*更*不受限制的！
- en: Tip
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For a full explanation of how variance support is applied in PHP 7.4 and PHP
    8, have a look here: https://wiki.php.net/rfc/covariant-returns-and-contravariant-parameters.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解PHP 7.4和PHP 8中如何应用方差支持的完整解释，请查看这里：https://wiki.php.net/rfc/covariant-returns-and-contravariant-parameters。
- en: We'll now have a look at changes to the SPL and how those changes can have an
    impact on application performance after migrating to PHP 8.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一下SPL的更改以及这些更改如何影响迁移到PHP 8后的应用程序性能。
- en: Handling Standard PHP Library (SPL) changes
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理标准PHP库（SPL）更改
- en: The **SPL** is an extension that contains key classes that implement basic data
    structures and enhance OOP functionality. It was first introduced in PHP 5 and
    is now included by default in all PHP installations. Covering the entire SPL is
    beyond the scope of this book. Instead, in this section, we discuss where significant
    changes have occurred in the SPL when running PHP 8\. In addition, we give you
    tips and guidance on SPL changes that have the potential to cause your existing
    applications to stop working.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**SPL**是一个包含实现基本数据结构和增强面向对象功能的关键类的扩展。它首次出现在PHP 5中，现在默认包含在所有PHP安装中。涵盖整个SPL超出了本书的范围。相反，在本节中，我们讨论了在运行PHP
    8时SPL发生了重大变化的地方。此外，我们还为您提供了有可能导致现有应用程序停止工作的SPL更改的提示和指导。'
- en: We start by examining changes to the `SplFileObject` class.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查`SplFileObject`类的更改。
- en: Understanding changes to SplFileObject
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解SplFileObject的更改
- en: '`SplFileObject` is an excellent class that incorporates most of the standalone
    `f*()` functions, such as `fgets()`, `fread()`, `fwrite()`, and so forth, into
    a single class. `SplFileObject ::__construct()` method arguments mirror the arguments
    provided to the `fopen()` function.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`SplFileObject`是一个很好的类，它将大部分独立的`f*()`函数（如`fgets()`，`fread()`，`fwrite()`等）合并到一个类中。`SplFileObject
    ::__construct()`方法的参数与`fopen()`函数提供的参数相同。'
- en: The main difference in PHP 8 is that a relatively obscure method, `fgetss()`,
    has been removed from the `SplFileObject` class. The `SplFileObject::fgetss()`
    method, available in PHP 7 and below, mirrors the standalone `fgetss()` function
    in that it combines `fgets()` with `strip_tags()`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8中的主要区别是，一个相对不常用的方法`fgetss()`已从`SplFileObject`类中删除。`SplFileObject::fgetss()`方法在PHP
    7及以下版本中可用，它将`fgets()`与`strip_tags()`结合在一起。
- en: 'For the sake of illustration, let''s assume you have created a website that
    allows users to upload text files. Before displaying content from the text file,
    you wish to remove any markup tags. Here is an example that uses the `fgetss()`
    method to accomplish this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，假设您已经创建了一个网站，允许用户上传文本文件。在显示文本文件内容之前，您希望删除任何标记。以下是使用`fgetss()`方法实现此目的的示例：
- en: 'We first define a block of code that acquires the filename:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个获取文件名的代码块：
- en: '[PRE86]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We then create the `SplFileObject` instance, and read the file line by line
    using the `fgetss()` method. At the end, we echo the safe contents:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建`SplFileObject`实例，并使用`fgetss()`方法逐行读取文件。最后，我们输出安全内容：
- en: '[PRE87]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Let''s say that the file to be read is this:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设要读取的文件是这个：
- en: '[PRE88]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Here is the output running in PHP 7.1 using this URL:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是在PHP 7.1中使用此URL运行的输出：
- en: '`http://localhost:7777/ch05/php7_spl_splfileobject.php? fn=includes/you_been_hacked.html`'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:7777/ch05/php7_spl_splfileobject.php? fn=includes/you_been_hacked.html`'
- en: 'As you can see from the output shown next, all HTML markup tags have been removed:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 从接下来显示的输出中可以看出，所有HTML标记都已被删除：
- en: '![Figure 5.1 – Result after reading a file using SplFileObject::fgetss()'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 - 使用SplFileObject::fgetss()读取文件后的结果'
- en: '](image/Figure_5.1_B6992.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.1_B6992.jpg)'
- en: Figure 5.1 – Result after reading a file using SplFileObject::fgetss()
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 - 使用SplFileObject::fgetss()读取文件后的结果
- en: 'To accomplish the same thing in PHP 8, the code shown previously would need
    to be modified by replacing `fgetss()` with `fgets()`. We would also need to use
    `strip_tags()` on the line concatenated to `$safe`. Here is how the modified code
    might appear:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中实现相同的功能，之前显示的代码需要通过用`fgets()`替换`fgetss()`来进行修改。我们还需要在连接到`$safe`的行上使用`strip_tags()`。修改后的代码可能如下所示：
- en: '[PRE89]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The output from the modified code is identical to that shown in *Figure 5.1*.
    We''ll now turn our attention to changes in another SPL class: `SplHeap`.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的代码的输出与*图5.1*中显示的相同。现在我们将注意力转向另一个SPL类的更改：`SplHeap`。
- en: Examining changes to SplHeap
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查SplHeap的更改
- en: '`SplHeap` is a foundational class used to represent data structured as a **binary
    tree**. Two additional classes are also available that build upon `SplHeap`. `SplMinHeap`
    organizes the tree with the minimum value at the top. `SplMaxHeap` does the reverse,
    placing the maximum value at the top.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`SplHeap`是一个基础类，用于表示**二叉树**结构的数据。另外还有两个类建立在`SplHeap`基础上。`SplMinHeap`将树组织为顶部是最小值。`SplMaxHeap`则相反，将最大值放在顶部。'
- en: A heap structure is especially useful in situations where data arrives out of
    order. Once inserted into the heap, the item is automatically placed in its proper
    order. Thus, at any given moment, you can display the heap safe in the knowledge
    that all items will be in order without having to run one of the PHP sort functions.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 堆结构在数据无序到达的情况下特别有用。一旦插入堆中，项目会自动按正确的顺序放置。因此，在任何给定时刻，您可以显示堆，确保所有项目都按顺序排列，而无需运行PHP排序函数之一。
- en: The key to maintaining the automatic sort order is to define an abstract method,
    `compare()`. As this method is abstract, `SplHeap` cannot be instantiated directly.
    Instead, you need to extend the class and implement `compare()`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 保持自动排序顺序的关键是定义一个抽象方法`compare()`。由于这个方法是抽象的，`SplHeap`不能直接实例化。相反，您需要扩展该类并实现`compare()`。
- en: 'There is the potential for a backward-compatible code break when using `SplHeap`
    in PHP 8 as the method signature for `compare()` must be exactly as follows: `SplHeap::compare($value1,
    $value2)`.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，使用`SplHeap`可能会导致向后兼容的代码中断，因为`compare()`的方法签名必须完全如下：`SplHeap::compare($value1,
    $value2)`。
- en: 'Let''s now have a look at a code example that uses `SplHeap` to build a list
    of billionaires organized by last name:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来看一个使用`SplHeap`构建按姓氏组织的亿万富翁列表的代码示例：
- en: 'First, we define a file with data on billionaires. In this example, we simply
    copied and pasted data from this source: https://www.bloomberg.com/billionaires/.'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个包含亿万富翁数据的文件。在这个例子中，我们只是从这个来源复制并粘贴了数据：https://www.bloomberg.com/billionaires/。
- en: We then define a `BillionaireTracker` class that extracts information from the
    pasted text into an array of ordered pairs. The full source code (not shown here)
    for the class can be found in the source code repository here:`/repo/src/Services/BillionaireTracker.php`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个`BillionaireTracker`类，从粘贴的文本中提取信息到有序对的数组中。该类的完整源代码（未在此处显示）可以在源代码存储库中找到：`/repo/src/Services/BillionaireTracker.php`。
- en: 'Here is how the data produced by the class appears:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该类生成的数据的样子：
- en: '[PRE90]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: As you can see, the data is presented in descending order where the key represents
    net worth. In contrast, in our sample program, we plan to produce data in ascending
    order by last name.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，数据以降序呈现，其中键表示净值。相比之下，在我们的示例程序中，我们计划按姓氏的升序产生数据。
- en: 'We then define a constant that identifies the billionaire data source file,
    and set up an autoloader:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个常量，用于标识亿万富翁数据源文件，并设置一个自动加载程序：
- en: '[PRE91]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next, we create an instance of the `BillionaireTracker` class and assign the
    results to `$list`:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`BillionaireTracker`类的实例，并将结果赋给`$list`：
- en: '[PRE92]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now comes the part of most interest: creating the heap. To accomplish this,
    we define an anonymous class that extends `SplHeap`. We then define a `compare()`
    method that performs the necessary logic to place inserted elements in their proper
    place. PHP 7 allows you to change the method signature. In this example, we provide
    arguments in the form of an array:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在来看最感兴趣的部分：创建堆。为了实现这一点，我们定义了一个扩展`SplHeap`的匿名类。然后，我们定义了一个`compare()`方法，执行必要的逻辑将插入的元素放在适当的位置。PHP
    7允许你改变方法签名。在这个例子中，我们以数组的形式提供参数：
- en: '[PRE93]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: You might also note that the value for `$cmp1` is assigned from the second array,
    and the value for `$cmp2` is from the first array. The reason for this switch
    is because we wish to produce results in ascending order.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还注意到`$cmp1`的值是从第二个数组中赋值的，而`$cmp2`的值是从第一个数组中赋值的。这种切换的原因是因为我们希望按升序产生结果。
- en: 'We then use `SplHeap::insert()` to add elements to the heap:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`SplHeap::insert()`将元素添加到堆中：
- en: '[PRE94]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Finally, we define a `BillionaireTracker::view()` method (not shown) to run
    through the heap and display results:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个`BillionaireTracker::view()`方法（未显示）来遍历堆并显示结果：
- en: '[PRE95]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Here is the output produced by our little program running in PHP 7.1:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是我们在PHP 7.1中运行的小程序产生的输出：
- en: '[PRE96]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You will note, however, that when we attempt to run the same program in PHP
    8, an error is thrown. Here is the output of the same program running in PHP 8:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们尝试在PHP 8中运行相同的程序时，会抛出错误。以下是在PHP 8中运行相同程序的输出：
- en: '[PRE97]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Accordingly, to get this working properly, we must redefine the anonymous class
    that extends `SplHeap`. Here is a modified version of that portion of the code:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使其正常工作，我们必须重新定义扩展`SplHeap`的匿名类。以下是代码的部分修改版本：
- en: '[PRE98]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The only change is in the `compare()` method signature. When executed, the results
    (not shown) are identical. The full code for PHP 8 can be viewed at `/repo/ch05/php8_spl_splheap.php`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的变化在于`compare()`方法的签名。执行时，结果（未显示）是相同的。PHP 8的完整代码可以在`/repo/ch05/php8_spl_splheap.php`中查看。
- en: This concludes our discussion of changes to the `SplHeap` class. Please note
    that the same change also applies to `SplMinHeap` and `SplMaxHeap`. Let's now
    have a look at a potentially significant change in the `SplDoublyLinkedList` class.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对`SplHeap`类的更改的讨论。请注意，相同的更改也适用于`SplMinHeap`和`SplMaxHeap`。现在让我们来看看`SplDoublyLinkedList`类中可能有重大变化的地方。
- en: Handling changes in SplDoublyLinkedList
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理`SplDoublyLinkedList`中的更改
- en: The `SplDoublyLinkedList` class is an iterator that's able to display information
    in either **FIFO** (**First-In, First-Out**) or **LIFO** (**Last-In, First-Out**)
    order. It's more common, however, to say that you can iterate through the list
    in either forward or reverse order.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`SplDoublyLinkedList`类是一个迭代器，能够以**FIFO**（先进先出）或**LIFO**（后进先出）的顺序显示信息。然而，更常见的是说你可以以正向或反向顺序遍历列表。'
- en: This is a very powerful addition to any developer's library. To do the same
    thing with `ArrayIterator`, for example, would require at least a dozen lines
    of code! Accordingly, PHP developers like to use this class for situations where
    they need to navigate a list in either direction at will.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这是任何开发者库中非常强大的一个补充。要使用`ArrayIterator`做同样的事情，例如，至少需要十几行代码！因此，PHP开发者喜欢在需要随意在列表中导航的情况下使用这个类。
- en: Unfortunately, there is a potential code break due to a difference in the return
    value of the `push()` and `unshift()` methods. The `push()` method is used to
    add a value at the *end* of the list. The `unshift()` method, on the other hand,
    adds value to the *beginning* of the list.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于`push()`和`unshift()`方法的返回值不同，可能会出现潜在的代码中断。`push()`方法用于在列表的*末尾*添加值。另一方面，`unshift()`方法则在列表的*开头*添加值。
- en: In PHP 7 and below, these methods, if successful, returned Boolean `TRUE`. If
    the method failed, it returned Boolean `FALSE`. In PHP 8, however, neither method
    returns a value. If you look at the method signature in the current documentation,
    you will see a return data type of `void`. The potential code break can arise
    where you check to return a value of either `push()` or `unshift()` before continuing.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7及以下版本中，如果成功，这些方法返回布尔值`TRUE`。如果方法失败，它返回布尔值`FALSE`。然而，在PHP 8中，这两种方法都不返回任何值。如果你查看当前文档中的方法签名，你会看到返回数据类型为`void`。可能会出现代码中断的情况，即在继续之前检查返回`push()`或`unshift()`的值。
- en: 'Let''s have a look at a simple example that populates a doubly linked list
    with a simple list of five values, and displays them in both FIFO and LIFO order:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子，用一个简单的五个值的列表填充一个双向链表，并以FIFO和LIFO顺序显示它们：
- en: 'First, we define an anonymous class that extends `SplDoublyLinkedList`. We
    also add a `show()` method that displays the contents of the list:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个匿名类，它继承了`SplDoublyLinkedList`。我们还添加了一个`show()`方法来显示列表的内容：
- en: '[PRE99]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Next, we define an array of sample data, and use `push()` to insert the value
    into the linked list. Note that an `if()` statement is used to determine whether
    the operation succeeds or fails. If the operation fails, an `Exception` is thrown:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个样本数据的数组，并使用`push()`将值插入到链表中。请注意，我们使用`if()`语句来确定操作是否成功或失败。如果操作失败，将抛出一个`Exception`：
- en: '[PRE100]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This is the block of code where the potential code break exists. In PHP 7 and
    below, `push()` returns `TRUE` or `FALSE`. In PHP 8, there is no return value.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这是潜在代码中断存在的代码块。在PHP 7及更低版本中，`push()`返回`TRUE`或`FALSE`。在PHP 8中，没有返回值。
- en: 'We then use the `SplDoublyLinkedList` class constants to set the mode to FIFO
    (forward), and display the list:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用`SplDoublyLinkedList`类的常量将模式设置为FIFO（正向），并显示列表：
- en: '[PRE101]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Next, we use the `SplDoublyLinkedList` class constants to set the mode to LIFO
    (reverse), and display the list:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`SplDoublyLinkedList`类的常量将模式设置为LIFO（反向），并显示列表：
- en: '[PRE102]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Here is the output running in PHP 7.1:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在PHP 7.1中运行的输出：
- en: '[PRE103]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'If we run the same code in PHP 8, this is the result:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在PHP 8中运行相同的代码，这是结果：
- en: '[PRE104]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: If no value is returned by `push()`, inside the `if()` statement PHP assumes
    `NULL`, which in turn is interpolated as Boolean `FALSE`! Accordingly, after the
    first `push()` command, the `if()` block causes an `Exception` to be thrown. Because
    the `Exception` is not caught, a fatal `Error` is generated.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`push()`没有返回任何值，在`if()`语句中PHP会假定为`NULL`，然后被插入为布尔值`FALSE`！因此，在第一个`push()`命令之后，`if()`块会导致抛出一个`Exception`。因为`Exception`没有被捕获，会生成一个致命的`Error`。
- en: 'To rewrite this block of code to work in PHP 8, all you need to do is to remove
    the `if()` statement, and not throw an `Exception`. Here''s how the rewritten
    code block (shown in *Step 2*) might appear:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这个代码块重写为在PHP 8中工作，您只需要删除`if()`语句，并且不抛出`Exception`。重写后的代码块（在*步骤2*中显示）可能如下所示：
- en: '[PRE105]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now, if we execute the rewritten code, the results are seen here:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们执行重写后的代码，结果如下所示：
- en: '[PRE106]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Now you have an idea of how to use `SplDoublyLinkedList`, and also know about
    the potential code break relating to `push()` or `unshift()`. You also have an
    idea about potential code breaks when using various SPL classes and functions
    in PHP 8\. This concludes our discussion for this chapter.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解如何使用`SplDoublyLinkedList`，并且也知道关于`push()`或`unshift()`可能出现的潜在代码中断。您还了解了在PHP
    8中使用各种SPL类和函数可能出现的潜在代码中断。这就结束了本章的讨论。
- en: Summary
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about potential problems in OOP code when migrating
    to PHP 8\. In the first section, you learned how a number of bad practices were
    allowed in PHP 7 and earlier versions, but now represent a potential code break
    in PHP 8\. With this knowledge, you are a better developer and can deliver high-quality
    code to benefit your company.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学到了在迁移到PHP 8时面向对象编程代码可能出现的问题。在第一节中，您了解到在PHP 7和之前的版本中允许许多不良实践，但现在在PHP 8中可能导致代码中断。有了这些知识，您将成为一个更好的开发人员，并能够提供高质量的代码来造福您的公司。
- en: In the next section, you learned good habits when using magic methods. Potential
    code breaks can occur because PHP 8 now enforces a degree of consistency not seen
    in earlier versions of PHP. These inconsistencies involve class constructor usage
    and certain aspects of magic method usage. The following section taught you about
    PHP serialization and how changes made in PHP 8 can make your code more resilient
    and less vulnerable to errors or attacks during the serialize and unserialize
    process.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您学到了在使用魔术方法时的良好习惯。由于PHP 8现在强制实施了在早期版本中没有看到的一定程度的一致性，因此可能会出现代码中断。这些不一致性涉及类构造函数的使用和魔术方法使用的某些方面。接下来的部分教会了您关于PHP序列化以及PHP
    8中所做的更改如何使您的代码更具弹性，并在序列化和反序列化过程中更不容易出现错误或受攻击。
- en: In this chapter, you also learned about enhanced PHP 8 support for covariant
    return types and contravariant parameters. Having knowledge of variance, and how
    support has improved in PHP 8, allows you to be more creative and flexible when
    developing class inheritance structures in PHP 8\. You now know how to write code
    that was simply not possible in earlier versions of PHP.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您还了解了PHP 8对协变返回类型和逆变参数的增强支持。了解了协变的知识，以及在PHP 8中支持的改进，使您在开发PHP 8中的类继承结构时更具创造性和灵活性。现在您知道如何编写在早期版本的PHP中根本不可能的代码。
- en: The last section covered a number of key classes in the SPL. You learned a great
    deal about how basic data structures such as heap and linked lists can be implemented
    in PHP 8\. The information in that section was critical in helping you to avoid
    problems with code involving the SPL.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一节涵盖了SPL中的许多关键类。您学到了关于如何在PHP 8中实现基本数据结构，比如堆和链表的重要知识。该部分的信息对帮助您避免涉及SPL的代码问题至关重要。
- en: The next chapter continues the discussion on potential code breaks. The emphasis
    in the next chapter, however, is on *procedural* rather than object code.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将继续讨论潜在的代码中断。然而，下一章的重点是*过程式*而不是对象代码。
