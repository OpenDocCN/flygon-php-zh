- en: Illuminating RESTful Web Services with Lumen
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Lumen照亮RESTful Web服务
- en: So far, we have created a very basic RESTful web service in Core PHP and identified
    flaws regarding design and security. We have also seen that to make things better
    we don't need to create everything from scratch. In fact, using open source code
    that is time tested makes more sense, to build better web services based on cleaner
    code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在核心PHP中创建了一个非常基本的RESTful Web服务，并发现了设计和安全方面的缺陷。我们还看到，为了改进，我们不需要从头开始创建所有东西。事实上，使用经过时间考验的开源代码更有意义，以基于更干净的代码构建更好的Web服务。
- en: In the last chapter, we have seen that Composer is a dependency manager for
    PHP projects. In this chapter, we will use an open source micro-framework to write
    RESTful web services. We will do the same work in an open source micro-framework
    that is in active development, time tested and well known in PHP community. The
    reason for using a framework instead of few components is that a proper framework
    can make a good structure of our code, and it comes with some basic required components.
    The micro-framework we have chosen is Lumen, a micro-framework version of the
    full-stack framework Laravel.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经看到Composer是PHP项目的依赖管理器。在本章中，我们将使用一个开源的微框架来编写RESTful Web服务。我们将在一个活跃开发、经过时间考验并在PHP社区中广为人知的开源微框架中完成相同的工作。使用框架而不是几个组件的原因是，一个合适的框架可以为我们的代码提供良好的结构，并且它带有一些基本所需的组件。我们选择的微框架是Lumen，它是全栈框架Laravel的微框架版本。
- en: 'Here is what we intend to cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们打算在本章中涵盖的内容：
- en: Introducing Lumen
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Lumen
- en: What Lumen provides
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lumen提供了什么
- en: What Lumen has in common with Laravel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lumen与Laravel有什么共同之处
- en: How Lumen is different from Laravel
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lumen与Laravel有何不同
- en: Installation and configuration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置
- en: Database Migrations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库迁移
- en: Writing REST API in Lumen
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Lumen中编写REST API
- en: Routes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由
- en: Controllers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器
- en: REST Resource
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST资源
- en: Eloquent (Model)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eloquent（模型）
- en: Relationships
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系
- en: User Access and Token based Authentication and Session
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户访问和基于令牌的身份验证和会话
- en: API Versioning
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API版本控制
- en: Rate Limits
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制
- en: Database Seeders of Users
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的数据库种子
- en: Using Lumen Packages for REST API
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lumen包进行REST API
- en: Reviewing Lumen based REST API
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查基于Lumen的REST API
- en: Need of encryption
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密的需求
- en: Different SSL Options
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的SSL选项
- en: Summary and more resources
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结和更多资源
- en: Introducing Lumen
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Lumen
- en: Lumen is a micro-framework version of the full-stack framework Laravel. In the
    PHP community, Laravel is a very well-known framework. So by using Lumen, we can
    always convert our project to Laravel and start using its full-stack capabilities
    if we have to.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen是全栈框架Laravel的微框架版本。在PHP社区中，Laravel是一个非常知名的框架。因此，通过使用Lumen，我们可以随时将我们的项目转换为Laravel，并开始使用其全栈功能。
- en: Why micro-framework?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用微框架？
- en: Every thing has a cost. We chose a micro-framework instead of a full-stack framework,
    because although a full-stack framework provides more features, to have those
    features it has to load more stuff. So to provide the luxury of more features,
    a full-stack framework has to compromise a bit on performance as compared to a
    micro-framework. The micro-framework on the other hand, lets go of some features
    which are not required for building web services like views and so on, which makes
    it faster.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都有代价。我们选择了微框架而不是全栈框架，因为尽管全栈框架提供了更多的功能，但为了拥有这些功能，它必须加载更多的东西。因此，为了提供更多功能的奢侈，与微框架相比，全栈框架在性能上必须做出一些妥协。另一方面，微框架放弃了一些构建Web服务所不需要的功能，比如视图等，这使得它更快。
- en: Why Lumen?
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Lumen？
- en: 'Lumen is not the only micro-framework in the PHP community. So why Lumen? There
    are three major reasons for that:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen并不是PHP社区中唯一的微框架。那么为什么选择Lumen？有三个主要原因：
- en: Lumen is micro-framework of Laravel, so with a little effort we can always convert
    it into Laravel and utilize its full-stack capabilities.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lumen是Laravel的微框架，因此我们可以通过一点努力将其转换为Laravel，并利用其全栈功能。
- en: As Lumen is a micro-framework of Laravel, it has awesome community support just
    like Laravel. A good community is always a very important factor. At the same
    time, Lumen is able to use a lot of the same packages that Laravel uses.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Lumen是Laravel的微框架，它像Laravel一样拥有出色的社区支持。一个良好的社区总是一个非常重要的因素。同时，Lumen能够使用许多与Laravel相同的包。
- en: Other than its relation with Laravel, Lumen is also very good with respect to
    performance. Based on performance, other alternative micro-frameworks could be
    Slim and Selex.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了与Laravel的关系，Lumen在性能方面也非常出色。基于性能，其他替代的微框架可能是Slim和Selex。
- en: What Lumen provides
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lumen提供了什么
- en: As we know that Lumen is a micro-framework version of Laravel, it provides a
    lot of capabilities that Laravel provides. For example, it is an MVC framework.
    However, it is good to know what Lumen and Laravel have in common and what Lumen
    doesn't have or has different. This will give us a good idea of what Lumen has
    in store for us.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，Lumen是Laravel的微框架版本，它提供了许多Laravel提供的功能。例如，它是一个MVC框架。然而，了解Lumen和Laravel的共同之处以及Lumen没有或具有不同的地方是很重要的。这将让我们对Lumen为我们提供了什么有一个很好的了解。
- en: What Lumen has in common with Laravel
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lumen与Laravel有什么共同之处
- en: 'Here, I didn''t say similarities between Laravel and Lumen, because Lumen is
    not a completely different framework. I said what is common in both of them, because
    they have common packages and components: that means they share the same code
    base in many cases.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我没有说Laravel和Lumen之间的相似之处，因为Lumen并不是一个完全不同的框架。我说的是它们之间的共同之处，因为它们有共同的包和组件：这意味着它们在许多情况下共享相同的代码库。
- en: Actually, Lumen is sort of a small, minimal Laravel. It just drops some of the
    components and uses different components for some tasks like routes. However,
    you can always turn on a lot of components in the same installation. Sometimes,
    you don't even need to write some code in the configuration for that. Instead,
    you just go to the configuration file and uncomment some lines of code and it
    starts using those components.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Lumen是一种小型、精简的Laravel。它只是放弃了一些组件，并对一些任务使用不同的组件，比如路由。然而，你总是可以在同一个安装中打开很多组件。有时，甚至不需要在配置中编写一些代码。相反，你只需转到配置文件，取消注释一些代码行，它就开始使用这些组件。
- en: In fact, Lumen has the same versions. For example, if there is 5.4 version of
    Laravel, Lumen will have the same version. So, these are not two different things.
    They have most things similar to each other. Lumen just drops some unrequired
    stuff for the sake of performance. However, if you just want to convert your application
    code that is written for Lumen to Laravel, you can simply put that code in a Laravel
    installation and it should mostly work. No major change in your application code
    is needed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Lumen具有相同的版本。例如，如果有Laravel的5.4版本，Lumen将具有相同的版本。因此，这些不是两个不同的东西。它们彼此之间有很多相似之处。Lumen只是为了性能而放弃了一些不必要的东西。然而，如果你只想将为Lumen编写的应用程序代码转换为Laravel，你只需将该代码放入Laravel安装中，它应该大部分工作。不需要对应用程序代码进行重大更改。
- en: How Lumen is different from Laravel
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lumen与Laravel有何不同
- en: 'As Lumen is built for micro-services and APIs, components related to front-end
    like an elixir, authentication bootstrap, sessions and views and so on do not
    come with Lumen out of the box, but these can be included later on, if required:
    it is very flexible in that.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Lumen是为微服务和API构建的，与前端相关的组件，如elixir、身份验证bootstrap、会话和视图等，不是Lumen的默认组件，但如果需要的话，可以稍后包含：它在这方面非常灵活。
- en: Routes are different in Lumen. In fact, it doesn't use Symfony router; instead
    it uses a different router which is faster but has fewer features. This is because
    Lumen sacrifices features for speed. Similarly, there are no separate configuration
    files like Laravel. Instead, some configurations are done in `.env` file while
    others related to registering a provider or alias and so on are done in the `bootstrap/app.php`
    file, probably to avoid loading different files for the sake of speed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen中的路由不同。事实上，它不使用Symfony路由器；而是使用一个速度更快但功能较少的不同路由器。这是因为Lumen为了速度而牺牲了功能。同样，像Laravel一样，没有单独的配置文件。相反，一些配置在`.env`文件中完成，而其他与注册提供程序或别名等相关的配置在`bootstrap/app.php`文件中完成，可能是为了避免为了速度而加载不同的文件。
- en: Both Lumen and Laravel have a lot of packages and a lot of them work for both.
    Still, there are packages which were mainly built for Laravel and don't work with
    Lumen without some changes. So if you intend to install a package, make sure it
    supports Lumen. For Laravel, most of the packages work for Laravel because Laravel
    is more popular and most of the packages were built for Laravel.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen和Laravel都有很多包，其中很多都适用于两者。但仍然有一些包主要是为Laravel构建的，如果没有一些更改，就无法在Lumen中使用。因此，如果你打算安装一个包，请确保它支持Lumen。对于Laravel，大多数包都适用于Laravel，因为Laravel更受欢迎，大多数包都是为Laravel构建的。
- en: What exactly Lumen provides
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lumen到底提供了什么
- en: You are probably thinking that this is the difference between Lumen and Laravel,
    but what exactly does Lumen provide us so we can build API? We will look into
    it, but not in detail, because Lumen documentation at [https://lumen.laravel.com/docs/5.4](https://lumen.laravel.com/docs/5.4)
    serves this purpose. What is not covered in the documentation is how we can make
    a RESTful web service using Lumen, and what packages we can utilize to make our
    work and life easier. We will look into this.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这就是Lumen和Laravel之间的区别，但Lumen到底提供了什么，让我们能够构建API？我们将研究一下，但不会详细讨论，因为Lumen的文档[https://lumen.laravel.com/docs/5.4](https://lumen.laravel.com/docs/5.4)已经涵盖了这一目的。文档中没有涵盖的是我们如何使用Lumen制作RESTful
    Web服务，以及我们可以利用哪些包来使我们的工作和生活更轻松。我们将深入研究这一点。
- en: First, we will discuss what comes with Lumen, so that we understand its different
    components and working.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论Lumen提供了什么，以便我们了解其不同的组件和工作方式。
- en: A Good Structure
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 良好的结构
- en: 'Lumen comes with a good structure. As it is derived from Laravel, which follows
    the MVC (Model View Controller) pattern, Lumen also has a Model and Controller
    layer. It does not have the view layer, because it does not need views: it is
    for web services. If you don''t know what MCV is, consider it just an architectural
    pattern where responsibilities are distributed in three layers. Model is a DB
    layer and sometimes also used as business logic layer (we will look into what
    should be in the model in a later chapter). The view layer is for template related
    stuff. Controller can be considered a layer handling requests while getting data
    from Model and rendering View. In case of Lumen, there are only Model and Controller
    layers.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen具有良好的结构。由于它源自Laravel，后者遵循MVC（模型视图控制器）模式，Lumen也有模型和控制器层。它没有视图层，因为它不需要视图：它是用于Web服务的。如果你不知道什么是MCV，可以将其视为一种架构模式，其中责任分布在三个层中。模型是一个数据库层，有时也用作业务逻辑层（我们将在后面的章节中讨论模型中应该包含什么）。视图层用于模板相关的内容。控制器可以被认为是一个处理请求的层，同时从模型获取数据并渲染视图。在Lumen的情况下，只有模型和控制器层。
- en: Lumen provides us a good structure so we don't need to make it on our own. In
    fact, Laravel does not only provide MVC structure but also **Service Container**
    which resolves dependencies beautifully. The structure of Lumen and Laravel is
    much more than one design pattern but it utilizes different design patterns nicely.
    So, let's see what else Lumen provides and look into Service container and many
    other topics.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen为我们提供了一个良好的结构，因此我们不需要自己制作。事实上，Laravel不仅提供MVC结构，还提供了**服务容器**，可以很好地解决依赖关系。Lumen和Laravel的结构不仅仅是一个设计模式，而是很好地利用了不同的设计模式。因此，让我们看看Lumen还提供了什么，并深入了解服务容器和许多其他主题。
- en: Separate configurations
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单独的配置
- en: In [Chapter 4](6a3f77e9-56c5-4ffd-877d-9b7b212ea40a.xhtml), *Reviewing Design
    Flaws and Security Threats*, we saw that configurations should be separate than
    implementation so Lumen does that for us. It has separate configuration files.
    In fact, it has a separate `.env` file that can be different in different environments.
    Other than the `.env` file, there is a configurations file where configuration
    related to different packages are stored, things like package registration or
    alias and so on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](6a3f77e9-56c5-4ffd-877d-9b7b212ea40a.xhtml)中，*审查设计缺陷和安全威胁*，我们看到配置应该与实现分开，所以Lumen为我们做到了这一点。它有单独的配置文件。事实上，它有一个单独的`.env`文件，可以在不同的环境中不同。除了`.env`文件，还有一个配置文件，其中存储了与不同包相关的配置，比如包注册或别名等。
- en: Please note that you probably don't see the `.env` file on Mac or Linux at first
    because it starts from the dot, so it will be hidden. You will need to make hidden
    files shown, and then you will see the `.env` file there.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可能一开始在Mac或Linux上看不到`.env`文件，因为它以点开头，所以它会被隐藏。你需要显示隐藏文件，然后你就会看到`.env`文件。
- en: Router
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器
- en: Lumen has better routing capabilities. It not only lets you tell which URLs
    should be served by which controller but also lets you tell which URLs with which
    HTTP Method should be served by which controller and which method of the controller.
    In fact, most of the HTTP methods that we use in the RESTful convention can be
    specified in Lumen.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen具有更好的路由能力。它不仅可以让你告诉哪些URL应该由哪个控制器提供，还可以让你告诉哪些URL以及使用哪种HTTP方法应该由哪个控制器的哪个方法提供。事实上，Lumen可以指定RESTful约定中大多数我们使用的HTTP方法。
- en: While creating RESTful web service for our blog example, we will see code examples
    as well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的博客示例创建RESTful web服务时，我们将看到代码示例。
- en: Middle-wares
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件
- en: Middle-ware is something that can come before or after serving a request by
    the controller. Many tasks can be performed in middle-wares, like authentication
    middle-ware, validation middle-ware and so on.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是在控制器提供请求之前或之后执行的一些操作。中间件可以执行许多任务，比如身份验证中间件、验证中间件等。
- en: There are some middle-wares which come with Lumen itself, while we can also
    write our own middle-ware to serve our purpose.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen自带一些中间件，同时我们也可以编写自己的中间件来实现我们的目的。
- en: Service Container and Dependency Injection
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务容器和依赖注入
- en: A service container is a tool provided for dependency injection and dependency
    resolution. Developers just tell which class should be injected where, and the
    service container resolves and injects that dependency.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 服务容器是一个用于依赖注入和依赖解析的工具。开发人员只需告诉哪个类应该在哪里注入，服务容器就会解析并注入该依赖。
- en: Dependency injection can be used for resolving any dependency of a class if
    its object is created through the application service container, not through the
    `new` keyword in the application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过应用程序服务容器创建对象，而不是通过应用程序中的`new`关键字，依赖注入可以用于解析类的任何依赖关系。
- en: 'For example, the Lumen service container is used to resolve all Lumen controllers.
    So, if they need any dependency, the service container is responsible for resolving
    that. For better understanding consider the following example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Lumen服务容器用于解析所有Lumen控制器。因此，如果它们需要任何依赖项，服务容器负责解析它们。为了更好地理解，考虑以下示例：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, I have just mentioned the simple `Controller` class,
    where the `Post` class is being injected in the `PostController` constructor.
    If we already have another object which we want to be injected instead of the
    actual `Post` object, we can also do so.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我只是提到了简单的`Controller`类，在`PostController`构造函数中注入了`Post`类。如果我们已经有另一个对象，我们希望注入而不是实际的`Post`对象，我们也可以这样做。
- en: 'You can simply do it using the following code from anywhere before dependencies
    are resolved:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在解析依赖项之前的任何地方使用以下代码来简单地做到这一点：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So now, if `Post` will be type hinted in a class' constructor or method then
    the object of `OurCustomPost` class will be injected there. This is because `$this->app->instance("\Post",
    $ourCustomerPost)` is telling the service container that if someone asks for an
    instance of `\Post` then give them `$ourCustomerPost`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果在类的构造函数或方法中对`Post`进行类型提示，那么`OurCustomPost`类的对象将被注入其中。这是因为`$this->app->instance("\Post",
    $ourCustomerPost)`告诉服务容器，如果有人要求一个`\Post`的实例，就给他们`$ourCustomerPost`。
- en: 'Note, other than controller resolution, we can also create an object in the
    following way if we want the service container to inject dependencies:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除了控制器解析，如果我们希望服务容器注入依赖项，我们还可以以以下方式创建对象：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So here, `PostController` will be resolved in the same way as controllers are
    resolved by Lumen itself. Please note that we are using the term *Lumen* because
    we are talking about Lumen but most of this stuff is the same in both Lumen and
    Laravel.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，`PostController`将以与Lumen本身解析控制器相同的方式解析。请注意，我们使用术语*Lumen*，因为我们正在谈论Lumen，但大部分内容在Lumen和Laravel中都是相同的。
- en: Don't worry if this sounds a bit overwhelming, you will start understanding
    this once you start using Lumen or Laravel and do practical work in it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来有点令人不知所措，不要担心，一旦你开始使用Lumen或Laravel并在其中进行实际工作，你就会开始理解这一点。
- en: HTTP responses
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP响应
- en: Lumen has built-in support for sending different types of responses, HTTP status
    codes and response headers. This is something that we previously discussed as
    important. It is even more important for web services because web services are
    used by a machine, on a human. The machine should be able to know what the response
    type is and what the status code is. This is not only useful to tell whether there
    is error or success but also to tell what type of error has occurred. You can
    look into this in more detail at [https://lumen.laravel.com/docs/5.4/responses](https://lumen.laravel.com/docs/5.4/responses).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen内置支持发送不同类型的响应、HTTP状态码和响应头。这是我们之前讨论过的重要内容。对于Web服务来说，这更加重要，因为Web服务是由机器使用的，而不是人类。机器应该能够知道响应类型和状态码是什么。这不仅有助于判断是否出现错误或成功，还有助于判断发生了什么类型的错误。您可以在[https://lumen.laravel.com/docs/5.4/responses](https://lumen.laravel.com/docs/5.4/responses)中更详细地了解这一点。
- en: Validation
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: Lumen also comes with support for Validation as well; not only validation support
    but also built-in validation rules that you can start using. However, if you need
    some custom validation logic for some field, you can always write that as well.
    We will look into that while creating our RESTful web service.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen还提供了对验证的支持；不仅是验证支持，还有内置的验证规则可以开始使用。但是，如果您需要为某个字段编写一些自定义验证逻辑，也可以随时进行编写。在创建我们的RESTful
    Web服务时，我们将深入研究这一点。
- en: Eloquent ORM
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eloquent ORM
- en: Lumen comes with an ORM tool named Eloquent. For ease of understanding, you
    can consider it as a database related high-level libraries by which you can get
    data without going into a lot of detail based on relationships. We will shortly
    look into it in detail while we use it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen带有一个名为Eloquent的ORM工具。为了便于理解，您可以将其视为与数据库相关的高级库，通过它可以在不涉及关系的大量细节的情况下获取数据。在我们使用它时，我们将很快详细了解它。
- en: Database migration and seeding
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库迁移和填充
- en: Nowadays, a developer is not always supposed to create databases using SQL or
    database tool. There should be something in the code which can be under Version
    Control System and every developer in the team can run on his/her system or on
    the server. This something is nowadays called migration. Another benefit of writing
    migration is that it is not for one specific database. The same migration can
    work on both MySQL and PostgreSQL. Migrations are about structural changes in
    the database.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，开发人员并不总是应该使用SQL或数据库工具来创建数据库。代码中应该有一些东西可以在版本控制系统下运行，并且团队中的每个开发人员都可以在自己的系统或服务器上运行。这个东西现在被称为迁移。编写迁移的另一个好处是它不是针对一个特定的数据库。相同的迁移可以在MySQL和PostgreSQL上工作。迁移涉及数据库的结构变化。
- en: A migration is for database table creation or modifications, or different constraints
    or indexes creation. In the same way, Seeders are there to insert data in the
    database.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移是用于创建或修改数据库表，或创建不同的约束或索引。同样，种子数据用于向数据库中插入数据。
- en: Unit testing
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing is also a very important for ensuring the quality of code, and
    Lumen provides support for that as well. We will not be writing the test in this
    chapter, but we will write it in a later chapter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试也是确保代码质量的非常重要的部分，Lumen也提供了对此的支持。我们不会在本章中编写测试，但我们将在以后的章节中编写测试。
- en: 'Note that we haven''t seen each and every thing that comes with Lumen, we have
    just seen some components which we may need to know in order to make RESTful web
    services in Lumen. For further details of Lumen, you can simply consult its documentation:
    [https://lumen.laravel.com/docs/5.4](https://lumen.laravel.com/docs/5.4).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还没有看到Lumen提供的每一项功能，我们只看到了一些我们可能需要了解的组件，以便在Lumen中创建RESTful Web服务。有关Lumen的更多详细信息，您可以简单地查阅其文档：[https://lumen.laravel.com/docs/5.4](https://lumen.laravel.com/docs/5.4)。
- en: Installing Lumen
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lumen的安装
- en: 'To install Lumen, if you have composer installed then simply run this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Lumen，如果您已经安装了composer，只需运行以下命令：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will create a directory named `blog` which has the Lumen installation
    in it. In case you find any difficulty, see the Lumen installation docs here:
    [https://lumen.laravel.com/docs/5.4](https://lumen.laravel.com/docs/5.4).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`blog`的目录，其中包含Lumen的安装。如果您遇到任何困难，请参阅此处的Lumen安装文档：[https://lumen.laravel.com/docs/5.4](https://lumen.laravel.com/docs/5.4)。
- en: I suggest that after installation, you go and look at the directory structure
    of this Lumen project named blog, as it will make more sense when we will be performing
    different tasks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在安装后，您去查看名为blog的这个Lumen项目的目录结构，因为当我们执行不同的任务时，这将更有意义。
- en: Configuration
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: If you look in the installation directory where we installed Lumen, in our case
    it was `blog`, you will see a `.env` file. Lumen keeps configurations in the `.env`
    file. You can see there is an option `APP_KEY=` if this is not yet set in the
    `.env` file, set it. This just needs to be set to a random string that has a 32
    character length.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看我们安装Lumen的安装目录，在我们的案例中是`blog`，您会看到一个`.env`文件。Lumen将配置保存在`.env`文件中。您可以看到有一个选项`APP_KEY=`，如果在`.env`文件中尚未设置，请设置它。这只需要设置为一个具有32个字符长度的随机字符串。
- en: As `.env` file starts with a dot, in Linux or Mac, this file may be hidden.
    In order to see this file, you need to see hidden files as well.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`.env`文件以点开头，在Linux或Mac中，此文件可能是隐藏的。为了查看此文件，您需要查看隐藏文件。
- en: 'And then, to run Lumen simply use the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要运行Lumen，只需使用以下命令：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we are using a PHP built-in server and giving the path of the
    `public` directory in our project. This is because the entry point is `public/index.php`.
    Then, on [http://localhost:8000/](http://_wp_link_placeholder/), you should see
    `Lumen (5.4.6) (Laravel Components 5.4.*)`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在使用PHP内置服务器，并在项目中给出`public`目录的路径。这是因为入口点是`public/index.php`。然后，在[http://localhost:8000/](http://_wp_link_placeholder/)上，您应该看到`Lumen
    (5.4.6) (Laravel Components 5.4.*)`。
- en: If you ever see the error `Class 'Memcached' not found`, this means you don't
    have Memcached installed and Lumen is trying to use it somewhere. If you don't
    need Memcached, you can simply go to `.env` file and change `CACHE_DRIVER=file`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到错误`Class 'Memcached' not found`，这意味着您没有安装Memcached，而Lumen正在尝试在某个地方使用它。如果您不需要Memcached，您可以简单地转到`.env`文件并更改`CACHE_DRIVER=file`。
- en: Now that we have Lumen installed and configured, we will create the same RESTful
    web services for the blog example in Lumen.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装和配置了Lumen，我们将在Lumen中为博客示例创建相同的RESTful Web服务。
- en: One more thing you should do is uncomment following in `bootstrap/app.php`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在`bootstrap/app.php`中取消注释以下内容。
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As was previously commented, with these features not available, Lumen can be
    faster. But we uncommented it because we also need to utilize some capabilities
    of Lumen. So what, exactly, do these two lines do? The first one enables use of
    Facades. We enabled it because we will need some packages which need Facade. The
    second one enables usage of the Eloquent ORM that comes with Laravel and Lumen.
    Eloquent isn't enabled by default for the sake of performance. However, Eloquent
    is a very important component that we shouldn't avoid, not even for the sake of
    performance, unless performance is critical for us and it is slowing down because
    of Eloquent. In my opinion, we shouldn't compromise clarity for performance unless
    it is critical.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如先前所述，Lumen在这些功能不可用时可能会更快。但我们取消了注释，因为我们还需要利用Lumen的一些功能。那么，这两行代码到底是做什么的呢？第一行代码启用了Facades的使用。我们启用它是因为我们将需要一些需要Facade的包。第二行代码启用了Laravel和Lumen附带的Eloquent
    ORM的使用。出于性能考虑，默认情况下不启用Eloquent。但是，Eloquent是一个非常重要的组件，我们不应该忽视它，即使是出于性能考虑，除非性能对我们非常重要并且由于Eloquent而变慢。在我看来，除非情况紧急，否则我们不应该为了性能而牺牲清晰度。
- en: Setting up the database
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置数据库
- en: We need to set up our database for the blog. In fact, we already did set this
    up in [Chapter 3](75dfe538-b06c-46b9-a07f-8ac29a158975.xhtml), *Creating Restful
    Endpoints*. We can use that database here as well. In fact, we will have the same
    DB structure, so we can easily use the same DB, but this is not recommended. In
    Lumen, we use migrations to create DB structure. It is not mandatory but it is
    useful so you can write migration once and use it to create DB structure anywhere.
    This purpose can be served by SQL files but the beauty of migration is that it
    works across different RDBMS as well. So create a DB manually, and name it `blog`.
    Now, we will write migration for structure.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为博客设置数据库。实际上，我们在[第3章](75dfe538-b06c-46b9-a07f-8ac29a158975.xhtml)中已经设置了这一点，*创建RESTful端点*。我们可以在这里使用该数据库。实际上，我们将拥有相同的数据库结构，因此我们可以轻松地使用相同的数据库，但这并不推荐。在Lumen中，我们使用迁移来创建数据库结构。这不是强制性的，但很有用，因此您可以编写一次迁移并在任何地方使用它来创建数据库结构。SQL文件也可以实现这个目的，但是迁移的美妙之处在于它也可以跨不同的关系型数据库管理系统工作。因此，手动创建一个名为`blog`的数据库。现在，我们将为结构编写迁移。
- en: Writing migrations
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写迁移
- en: 'To create migration files in Lumen, we can use this command in the `blog` directory
    to create migration file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Lumen中创建迁移文件，我们可以在`blog`目录中使用以下命令创建迁移文件：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will see something similar to this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似于这样的内容：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'and a file with this name will be created in the `/blog/database/migrations`
    directory. In this file, we can write migration code for the Users table. If you
    open the file and look into it, there are 2 methods in it: `up()` and `down()`.
    `up()` method executes when it has to run migration while `down()` executes when
    it has to rollback migration.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 并且将在`/blog/database/migrations`目录中创建一个具有此名称的文件。在此文件中，我们可以为用户表编写迁移代码。如果您打开文件并查看其中，您会发现其中有两个方法：`up()`和`down()`。`up()`方法在运行迁移时执行，而`down()`在回滚迁移时执行。
- en: 'Here is the content of this User table creation migration file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用户表创建迁移文件的内容：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here in the `up()` method, we have called the create method while passing a
    function in it. And that function has code to add fields. If you want to know
    more about fields and table creation through migration, you can have a look at
    [https://laravel.com/docs/5.4/migrations#tables](https://laravel.com/docs/5.4/migrations#tables).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`up()`方法中，我们调用了create方法，并传递了一个函数。该函数包含添加字段的代码。如果您想了解有关通过迁移创建字段和表的更多信息，可以查看[https://laravel.com/docs/5.4/migrations#tables](https://laravel.com/docs/5.4/migrations#tables)。
- en: 'However, before running the command to generate migration from the database,
    you should go to your `.env` file and add your DB name and credentials. In order
    to run the migration, run this command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在运行从数据库生成迁移的命令之前，您应该转到`.env`文件并添加您的数据库名称和凭据。为了运行迁移，请运行以下命令：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will run the migration, and will create two tables: a migrations table
    and a Users table. The Users table was created as the result of the previously
    mentioned code, while the migrations table was created by Laravel/Lumen as it
    is where it keeps the record of migrations which are run. This table is created
    the first time, and will always have more data in it whenever migrations run.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行迁移，并创建两个表：迁移表和用户表。用户表是由先前提到的代码创建的，而迁移表是由Laravel/Lumen创建的，用于记录运行的迁移。这个表是第一次创建的，每次运行迁移时都会有更多的数据。
- en: Please note that before running migration you should have MySQL or some other
    database installed and configured in the `.env` file. Otherwise, if there is no
    database installed or set up, then migration will not work.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在运行迁移之前，您应该在`.env`文件中安装和配置MySQL或其他数据库。否则，如果没有安装或设置数据库，则迁移将无法工作。
- en: Now, you can create posts and comments table creation migration files in the
    same way. Following is the content of the posts and comments table creation migration
    files respectively.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以以相同的方式创建帖子和评论表创建迁移文件。以下是帖子和评论表创建迁移文件的内容。
- en: 'Posts migration file content:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 帖子迁移文件内容：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And here is the comments table creation migration file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是评论表创建迁移文件：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After having the preceding two files, run the following command again:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有上述两个文件之后，再次运行以下命令：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding command will only execute new migration files which were not yet
    executed. With that, you will have all three of these tables in the database.
    And as we will have these migrations as well, it will be easy to just run migrations
    again and have this schema in DB. You are probably thinking, "what is good about
    writing migrations?". The good part is that migrations make it easier to deploy
    it on any RDBMS because the code is Laravel migration code and not SQL code. Also,
    it is always easier to have such stuff in code so that multiple developers can
    get each other's migrations and run them on the fly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将只执行尚未执行的新迁移文件。有了这样，你将在数据库中拥有这三个表。而且，由于我们也将有这些迁移，所以只需再次运行迁移，就可以在数据库中拥有这个模式。你可能会想，“编写迁移有什么好处呢？”。好处在于，迁移使得在任何
    RDBMS 上部署变得更容易，因为代码是 Laravel 迁移代码，而不是 SQL 代码。此外，将这样的东西放在代码中总是更容易的，这样多个开发人员就可以获取彼此的迁移并立即运行它们。
- en: If you remember, we also did some indexing and foreign key constraints. So,
    here is how we can do that in the migration way.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们还做了一些索引和外键约束。所以，这就是我们如何在迁移中做到的。
- en: 'Create a new migration file using the command as we did before:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与之前相同的命令创建一个新的迁移文件：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will create a migration file for comments table indexes. Let''s add content
    to this file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为评论表索引创建一个迁移文件。让我们给这个文件添加内容：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the same way, create a migration file for posts indexes. Here is the content
    of the file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，为帖子索引创建一个迁移文件。以下是文件的内容：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding indexes files code, there is some code that is a bit complex
    and needs our attention:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述索引文件代码中，有一些代码有点复杂，需要我们的注意：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, the `foreign()` method accepts the field name and name of the index.
    Then, the `references()` method accepts the foreign key field name in the parent
    table, and the `on()` method parameter is the referenced table name (in our case,
    it is the users table). And then, the rest of the two methods `onUpdate()` and
    `onDelete()` tell the user what to do on update and delete respectively. If you
    are not comfortable with migration syntax, it is fine; you just need to look at
    the Lumen/Laravel migration documentation. In fact, I recommend that you pause
    for a moment and look at the migration related documentation: [https://laravel.com/docs/5.4/migrations](https://laravel.com/docs/5.4/migrations).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`foreign()` 方法接受字段名和索引的名称。然后，`references()` 方法接受父表中外键字段的名称，`on()` 方法的参数是被引用的表名（在我们的例子中，是用户表）。然后，另外两个方法
    `onUpdate()` 和 `onDelete()` 告诉用户在更新和删除时该做什么。如果你对迁移语法不太熟悉，没关系；你只需要查看 Lumen/Laravel
    迁移文档。事实上，我建议你停下来，看一下与迁移相关的文档：[https://laravel.com/docs/5.4/migrations](https://laravel.com/docs/5.4/migrations)。
- en: 'Now, to have these migrations effective in the database, we need to run migrations
    again so that new migrations can execute and we can have changes reflected in
    the database. So run:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使这些迁移在数据库中生效，我们需要再次运行迁移，以便新的迁移可以执行，并且我们可以在数据库中看到变化。所以运行：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With that, we are done with migration. We can now insert some data in these
    tables through seeds, but we don't need it yet, so skipping writing seeds for
    now.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就完成了迁移。现在我们可以通过种子在这些表中插入一些数据，但现在我们不需要，所以暂时跳过编写种子。
- en: Writing RESTful web service endpoints
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 RESTful web service 端点
- en: Now, it is time to actually start writing the endpoints that we discussed in
    Chapter 1, *RESTful Web Services, Introduction and Motivation*, and wrote in plain
    Vanilla PHP in [Chapter 3](75dfe538-b06c-46b9-a07f-8ac29a158975.xhtml), *Creating
    Restful Endpoints*. So let's do that.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候真正开始编写我们在第1章“RESTful Web Services, Introduction and Motivation”中讨论过的端点，并在[第3章](75dfe538-b06c-46b9-a07f-8ac29a158975.xhtml)中用纯粹的
    Vanilla PHP 编写的端点了。所以让我们开始吧。
- en: As it has a Controller and Model layer, we will start writing API from the Controller
    layer which will serve different endpoints. For the first controller, what we
    are going to write is `PostController`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它有控制器和模型层，我们将从控制器层开始编写 API，该层将为不同的端点提供服务。对于第一个控制器，我们要编写的是 `PostController`。
- en: Writing the first controller
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写第一个控制器
- en: Technically, this is not the first controller, as Lumen comes with 2 controllers
    which you can find in the `/<our blog project path>/app/Http/Controllers/` directory.
    But this is our first controller that we are going to write. In Laravel (the big
    brother of Lumen), we don't need to go and create a controller because there are
    commands for that, but for Lumen those commands are not available. As these commands
    are not mandatory but very handy, it is better if we make those commands available.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这不是第一个控制器，因为 Lumen 自带了2个控制器，你可以在 `/<our blog project path>/app/Http/Controllers/`
    目录中找到。但这是我们要编写的第一个控制器。在 Laravel（Lumen 的大哥）中，我们不需要去创建控制器，因为有相应的命令，但是在 Lumen 中这些命令是不可用的。由于这些命令不是强制性的，但非常方便，最好是让这些命令可用。
- en: To use the extra features that we don't get with Lumen (some of which come in
    Laravel already), we need to install a package. Right now, the package we need
    to install is `flipbox/lumen-generator`. More information about this package can
    be found at [https://packagist.org/packages/flipbox/lumen-generator](https://packagist.org/packages/flipbox/lumen-generator).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们在 Lumen 中没有的额外功能（其中一些已经包含在 Laravel 中），我们需要安装一个包。现在，我们需要安装的包是 `flipbox/lumen-generator`。关于这个包的更多信息可以在
    [https://packagist.org/packages/flipbox/lumen-generator](https://packagist.org/packages/flipbox/lumen-generator)
    找到。
- en: 'As we have seen in the previous chapter, we install packages through composer,
    so let''s install it:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一章中所看到的，我们通过 composer 安装包，所以让我们安装它：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see that I have added a `--dev` flag there. I did this to avoid using
    it on production, because this way it will be added in the `require --dev` section
    in `composer.json`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我在那里添加了一个 `--dev` 标志。我这样做是为了避免在生产环境中使用它，因为这样它将被添加到 `composer.json` 中的 `require
    --dev` 部分。
- en: 'Anyway, once this is installed, you can register its `ServiceProvider` in `bootstrap/app.php`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，一旦安装了这个，你可以在 `bootstrap/app.php` 中注册它的 `ServiceProvider`。
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, you can see that we have lot more commands available. You can see it by
    running:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到我们有更多的命令可用。你可以通过运行以下命令来查看：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, let''s create a controller with a command. Note, we didn''t install it
    only for creating controller but it will be very handy when you will be working
    with it. Anyway, let''s create a controller with the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们使用命令创建一个控制器。请注意，我们不仅仅是为了创建控制器而安装它，但当你使用它时，它将非常方便。无论如何，让我们使用以下命令创建一个控制器：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It will create a controller at `app/Http/Controllers/PostController.php`. This
    command will not only create `PostController` but will also add REST Resource
    related methods as well. Open a file and look into it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在`app/Http/Controllers/PostController.php`创建一个控制器。这个命令不仅会创建`PostController`，还会添加与REST资源相关的方法。打开一个文件并查看它。
- en: 'Here is the content that it generated:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它生成的内容：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These methods were generated because we added the flag `--resource`. If you
    are wondering from where did I get the knowledge of this flag, because it isn't
    listed on package page, I got it from Laravel's Controller documentation at [https://laravel.com/docs/5.4/controllers#resource-controllers](https://laravel.com/docs/5.4/controllers#resource-controllers).
    However, as these commands are working because of a third party package, there
    can be a difference in Laravel documentation and these command's actual behavior,
    but as these were done to replicate those Laravel commands for Lumen, most probably
    they will be very similar.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法是因为我们添加了`--resource`标志而生成的。如果你想知道我是从哪里获取到这个标志的知识，因为它没有列在包页面上，我是从Laravel的控制器文档中获取的[https://laravel.com/docs/5.4/controllers#resource-controllers](https://laravel.com/docs/5.4/controllers#resource-controllers)。然而，由于这些命令是由第三方包工作的，所以Laravel文档和这些命令的实际行为可能会有所不同，但由于这些是为了复制Laravel命令而在Lumen中完成的，它们很可能会非常相似。
- en: Anyway, we have `PostController` with methods in it. Let's implement these methods
    one by one.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们有`PostController`及其方法。让我们逐个实现这些方法。
- en: However, note that in Lumen and Laravel, unlike other PHP MVC frameworks, every
    URL should be told in routes or else it will not be accessible. Routes are a sort
    of only entry point, unlike other frameworks like `CodeIgniter` where the route
    is optional. In Lumen, routes are mandatory. In other words, every method of Controller
    will only be accessible through routes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，在Lumen和Laravel中，与其他PHP MVC框架不同，每个URL都应该在路由中告知，否则它将无法访问。路由是一种唯一的入口点，不像其他框架如`CodeIgniter`，路由是可选的。在Lumen中，路由是必需的。换句话说，控制器的每个方法只能通过路由访问。
- en: So before proceeding with `PostController`, let's add routes for post endpoints,
    otherwise `PostController` will be of no use.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在继续使用`PostController`之前，让我们为帖子端点添加路由，否则`PostController`将毫无用处。
- en: Lumen routes
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lumen路由
- en: In Lumen, by default, routes live in `/routes/web.php`. I said by default because
    this path can be changed. Anyway, go to `routes/web.php` and look into it. You
    will see that it is returning a response by itself and not pointing towards any
    controller. So, you should know that it is up to route whether it returns a response
    or uses the controller for that. However, note that returning a response from
    route closure only makes sense if there isn't much logic involved. In our case,
    we will be mostly using controllers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lumen中，默认情况下，路由位于`/routes/web.php`。我说默认是因为这个路径可以更改。无论如何，进入`routes/web.php`并查看它。你会看到它自己返回一个响应，而不是指向任何控制器。所以，你应该知道它是由路由决定是否返回响应或使用控制器。但是，请注意，只有在路由闭包中返回响应才有意义，如果涉及的逻辑不多。在我们的情况下，我们将主要使用控制器。
- en: 'Here is how our routes will look when we add our first route:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加第一个路由时，我们的路由将如下所示：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The code in bold is written by us. Here, get in `$app->get()` is used to specify
    the HTTP Method. It could be `$app->post()` but we used `$app->get()` to specify
    that the `GET` method is accepted. Then, there are 2 parameters in this method
    that you can see in the preceding code. First is the route pattern while the second
    parameter is an associative array which has the controller and the method in the
    `uses` key and route name in the `as` key: means after the domain or project URLs
    if `api/posts/` is an URL, it should be served by the `index()` method of `PostController`.
    While the route name is just there, if you want to specify route URLs by name
    in code then it is useful.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体字中的代码是我们编写的。在这里，`$app->get()`中的`get`用于指定HTTP方法。它可以是`$app->post()`，但我们使用了`$app->get()`来指定接受`GET`方法。然后，在这个方法中有2个参数，你可以在前面的代码中看到。第一个是路由模式，而第二个参数是一个关联数组，其中`uses`键中有控制器和方法，`as`键中有路由名称：意味着在域或项目URL之后，如果`api/posts/`是一个URL，它应该由`PostController`的`index()`方法提供服务。而路由名称只是在那里，如果你想在代码中按名称指定路由URL，那么它是有用的。
- en: 'Now to check if our route is correct and getting a response from Controller''s
    index method, let''s add something to the index method of `PostController`. Here
    is what we have added, for now, just to test our route:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了检查我们的路由是否正确，并从控制器的`index`方法获取响应，让我们向`PostController`的`index`方法添加一些内容。这是我们现在添加的内容，只是为了测试我们的路由：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, try running this code. Before anything else, you need to use a PHP built-in
    server. Go to the `blog` directory where the whole code is and run:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试运行这段代码。在任何其他操作之前，你需要使用PHP内置服务器。进入整个代码所在的`blog`目录并运行：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, from the browser, hit: `http://localhost:8000/api/posts` and you will
    see the following response:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从浏览器中输入：`http://localhost:8000/api/posts`，你将看到以下响应：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, our route worked and served from the `index()` method of `PostController`,
    and if you return an array then Lumen converts it into JSON and returns it as
    JSON.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的路由起作用并从`PostController`的`index()`方法提供服务，如果你返回一个数组，Lumen会将其转换为JSON并作为JSON返回。
- en: 'To further see the list of routes that certain URLs map to a particular controller''s
    particular method, simply run:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步查看特定URL映射到特定控制器特定方法的路由列表，只需运行：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You will see the detail of routes telling you which URLs pattern is associated
    with which piece of code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到路由的详细信息，告诉你哪个URL模式与哪段代码相关联。
- en: REST resource
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST资源
- en: This was a very basic example of the route and served from a `PostController`
    method. However, if you look at `PostController`, it has 4 more methods, and we
    need to serve 4 more endpoints as we discussed in Chapter 1, *RESTful Web Services,
    Introduction and Motivation*, and implemented in [Chapter 3](75dfe538-b06c-46b9-a07f-8ac29a158975.xhtml),
    *Creating Restful Endpoints*. So, we need to do the same thing in Lumen for other
    4 methods. To map 4 endpoints with these 4 methods, we shouldn't need 4 more routes.
    We can simply add a resource-based route which will map REST based URL patterns
    to all methods in `PostController`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的路由示例，由 `PostController` 方法提供。然而，如果你查看 `PostController`，它还有4个方法，我们需要为第1章中讨论的4个端点提供服务，并在[第3章](75dfe538-b06c-46b9-a07f-8ac29a158975.xhtml)中实现*创建RESTful端点*。因此，我们需要在Lumen中为其他4个方法做同样的事情。为了将这4个方法映射到4个端点，我们不需要再添加4个路由。我们可以简单地添加一个基于资源的路由，它将将REST基础的URL模式映射到`PostController`的所有方法。
- en: 'As we created `PostController` through the command line, it created a Resource
    Controller which means it has the necessary methods to serve RESTful endpoints.
    So in `routes/web.php` file, we should simply replace code we previously wrote
    with the resource route. Now, we should be able to map all RESTful endpoints to
    `PostController` methods by having this statement in the routes file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过命令行创建`PostController`时，它创建了一个资源控制器，这意味着它具有提供RESTful端点所需的方法。因此，在`routes/web.php`文件中，我们应该用资源路由替换之前编写的代码。现在，我们应该能够通过在路由文件中添加这个语句来将所有RESTful端点映射到`PostController`的方法：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Unfortunately, this resource route is available in Laravel but not in Lumen.
    Lumen uses a different router for better performance. However, this resource method
    is also very handy, and if we have 4-5 more RESTful resources, we can map all
    their endpoints in just 4-5 statements instead of 16-20 statements. So, here is
    a small trick to have this resource route sort of thing available in Lumen. You
    can add this custom method to the same route file.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个资源路由在Laravel中可用，但在Lumen中不可用。Lumen使用不同的路由器以获得更好的性能。然而，这个资源方法也非常方便，如果我们有4-5个以上的RESTful资源，我们可以只用4-5个语句来映射它们的所有端点，而不是16-20个语句。因此，这里有一个小技巧，可以在Lumen中使用这种资源路由的方法。你可以将这个自定义方法添加到同一个路由文件中。
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So overall, our route file will look like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的路由文件将如下所示：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The code written in bold is added by us. So, as you can see we have defined
    the `resource()` function in the routes file once, and we can use it for all REST
    resource routes. And then on the last line, we used the resource function to map
    all of the `api/posts` endpoints to `PostController` respective methods.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体字中的代码是我们添加的。因此，你可以看到我们在路由文件中一次定义了`resource()`函数，并且我们可以将其用于所有REST资源路由。然后在最后一行，我们使用资源函数将所有`api/posts`端点映射到`PostController`的相应方法。
- en: 'Now you can test it, by hitting `http://localhost:8000/api/posts`. We can''t
    test other endpoints right now because we haven''t written any code in `PostController`
    other methods. However, you can see what routes exist by using this command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过访问 `http://localhost:8000/api/posts` 来测试它。我们现在无法测试其他端点，因为我们还没有在 `PostController`
    的其他方法中编写任何代码。但是，你可以使用以下命令来查看存在的路由：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In our case, this command will result in something like this on the command
    line:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这个命令将在命令行上产生类似这样的结果：
- en: '![](assets/d2d15438-6b99-4d46-9620-e339b0e5651f.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d2d15438-6b99-4d46-9620-e339b0e5651f.png)'
- en: Here, we can see this is mapping paths to `PostController` methods exactly based
    on the RESTful Resource convention that we discussed in [Chapter 1](https://cdp.packtpub.com/building_restful_web_services_with_php_7/wp-admin/post.php?post=260&action=edit&save=save#post_412),
    *RESTful Web Services, Introduction and Motivation*. So now, for posts endpoints
    we are done with routing. Now we need to add code in Controller so it can add
    data to the database as well as fetch from the database. The next step is to create
    a Model layer and use that in Controller and return a proper response.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这是根据我们在[第1章](https://cdp.packtpub.com/building_restful_web_services_with_php_7/wp-admin/post.php?post=260&action=edit&save=save#post_412)中讨论的RESTful资源约定将路径映射到`PostController`方法。因此，对于帖子端点，我们已经完成了路由。现在我们需要在控制器中添加代码，以便它可以向数据库添加数据并从数据库中获取数据。下一步是创建一个模型层，并在控制器中使用它并返回适当的响应。
- en: Eloquent ORM (model layer)
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eloquent ORM（模型层）
- en: Eloquent is an ORM that comes with Laravel and Lumen. It is responsible for
    database related operations as well as database relationships. **ORM** (**Object
    Relational Mapping**) basically maps objects with relations (tables) in the database.
    Not only that, based on the relationship you can get data of one table on the
    base of another table's relationship without going at the low-level detail. This
    not only saves our time but also keeps our code cleaner.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent是Laravel和Lumen附带的ORM。它负责数据库相关操作以及数据库关系。**ORM**（**对象关系映射**）基本上将对象与数据库中的关系（表）进行映射。不仅如此，基于关系，你可以在不涉及底层细节的情况下获取另一个表的数据。这不仅节省了我们的时间，还使我们的代码更加清晰。
- en: Creating models
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: We are now going to create models. Model layer is related to the database, so
    we will also mention database relationships in them. Let's create models for all
    three tables that we have. The model names will be `User`, `Post` and `Comment`,
    relating to the `users`, `posts` and `comments` tables.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要创建模型。模型层与数据库相关，因此我们也会在其中提及数据库关系。让我们为我们拥有的三个表创建模型。模型名称将是`User`、`Post`和`Comment`，分别对应`users`、`posts`和`comments`表。
- en: 'We don''t need to create a User model and it comes with Lumen. To create Post
    and Comment models, let''s run the following command that became available to
    us by using that `flipbox/lumen-generator` package. Run the following commands
    to make models:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要创建一个用户模型，因为它已经包含在Lumen中。要创建帖子和评论模型，让我们运行以下命令，这些命令是通过使用`flipbox/lumen-generator`包而变得可用的。运行以下命令来创建模型：
- en: 'This will create a `Post` model in the `app` directory:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`app`目录中创建一个`Post`模型：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will create the `Comment` model in the `app` directory:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`app`目录中创建一个`Comment`模型：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you look into these model files, you will find that these are classes inherited
    by the Eloquent Model; so, these models are Eloquent based models and have characteristics
    of Eloquent Model.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这些模型文件，你会发现这些都是继承自Eloquent Model的类；因此，这些模型都是基于Eloquent Model的模型，并具有Eloquent
    Model的特性。
- en: Note, as per Eloquent convention, if the model's name is Post, the table's name
    will be posts, the plural of the model's name. Similarly, for the Comment Model,
    it will be the comments table. We can override this if our tables names are different,
    but we are not doing so because in our case, our table and Model names are according
    to the same convention.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，根据Eloquent的约定，如果模型的名称是Post，表的名称将是posts，即模型名称的复数形式。同样，对于Comment模型，它将是comments表。如果我们的表名不同，我们可以覆盖这一点，但我们没有这样做，因为在我们的情况下，我们的表和模型名称都符合相同的约定。
- en: 'Eloquent is a big topic to discuss, however we are just going to use it to
    make our API, so I will limit discussion to Eloquent''s usage in serving our purpose.
    And I think this makes sense because a lot of detail is already in Eloquent''s
    documentation, so for further details about Eloquent, please consult Eloquent''s
    documentation here: [https://laravel.com/docs/5.4/eloquent](https://laravel.com/docs/5.4/eloquent).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent是一个大的讨论话题，但我们只是用它来制作我们的API，所以我将限制讨论Eloquent在服务我们目的方面的使用。我认为这是有道理的，因为Eloquent的文档中已经有很多细节，所以有关Eloquent的更多细节，请参阅这里的Eloquent文档：[https://laravel.com/docs/5.4/eloquent](https://laravel.com/docs/5.4/eloquent)。
- en: Eloquent relationships
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eloquent关系
- en: 'In the Model layer, especially when inheriting from ORM, there are 2 important
    things:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型层，特别是在从ORM继承时，有两个重要的事情：
- en: We should have Models so we can access data through them
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该有模型，这样我们可以通过它们访问数据
- en: We should specify relationships so we can utilize ORM's full capabilities
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该指定关系，这样我们可以利用ORM的全部功能
- en: For just accessing data without writing a query, we can use Query Builder as
    well. But, relationships advantage is that it comes only with ORM usage. So, let's
    specify all of the models' relationships.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 只需访问数据而不编写查询，我们也可以使用查询构建器。但是，关系的优势在于它仅与ORM使用一起出现。因此，让我们指定所有模型的关系。
- en: 'First of all, let''s specify User''s relationships. As the user can have many
    posts and the user can have many comments, the User model will have the `hasMany`
    relationship with both Post and Comment models. This is what the User model will
    look like after specifying the relationship:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们指定用户的关系。由于用户可以有多篇帖子和多条评论，用户模型将与帖子和评论模型都有`hasMany`关系。在指定关系后，用户模型将如下所示：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The only thing which we added to the User Model is these 2 methods in bold which
    are `posts()` and `comments()` specifying the relationship. Based on these methods,
    we can access a user's posts and comments data. Both of these methods tell us
    that User has many relationships with both the `Post` and `Comment` models.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在User Model中添加的唯一的东西是这两个用粗体标出的方法，它们是`posts()`和`comments()`，指定了关系。基于这些方法，我们可以访问用户的帖子和评论数据。这两个方法告诉我们，用户与`Post`和`Comment`模型都有多对多的关系。
- en: Now, let's add a relationship in the `Post` model. As a post can have many comments,
    the `Post` model has many relationships with the `Comment` model. Meanwhile, the
    `Post` model has an inverse of many relationships with the User model and that
    inverse relationship is a `belongsTo` relationship. Here is the `Post` model code
    after adding relationship information.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`Post`模型中添加一个关系。由于帖子可以有多条评论，`Post`模型与`Comment`模型有多个关系。同时，`Post`模型与用户模型有多个反向关系，该反向关系是`belongsTo`关系。在添加关系信息后，`Post`模型代码如下。
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, we have specified Post's relationship with the `User` and `Comment`
    models. Now, here is the `Comment` model with relationships.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经指定了帖子与`User`和`Comment`模型的关系。现在，这是带有关系的`Comment`模型。
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, for both the `Post` and `User` models, comments have a `belongsTo`
    relationship that is an inverse of `hasMany()`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，对于`Post`和`User`模型，评论都有一个`belongsTo`关系，这是`hasMany()`的反向关系。
- en: So, now we have specified relationships. It is time to implement `PostController`
    methods.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们已经指定了关系。是时候实现`PostController`的方法了。
- en: Controller Implementation
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器实现
- en: Let's first add proper code in the `PostController` `index()` method that will
    return actual data. But to see data coming in response, it is better to insert
    some dummy data in the users, posts and comments tables. A better way to do this
    is to write seeds for that. However, if you don't want to look into how to write
    seeds then you can insert it manually for now.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在`PostController`的`index()`方法中添加适当的代码，以返回实际数据。但是为了查看响应中的数据，最好在用户、帖子和评论表中插入一些虚拟数据。更好的方法是为此编写种子。但是，如果你不想了解如何编写种子，那么现在可以手动插入。
- en: 'Here is an implementation of the `index()` method:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`index()`方法的实现：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, `paginate(20)` means that it will return a paginated result with the limit
    of 20\. And as you can see, we have used dependency injection to get the `Post`
    object. This is something that we have already discussed in this chapter.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`paginate(20)`表示它将返回一个带有20个限制的分页结果。正如你所看到的，我们使用了依赖注入来获取`Post`对象。这是我们在本章中已经讨论过的内容。
- en: 'Similarly, we will have `PostController` other methods implemented here. This
    is what the `PostController` code will look like:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将在这里实现`PostController`的其他方法。`PostController`代码将如下所示：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see, we are using the Post model and using its methods to perform
    different operations. Lumen''s variable and function names make it easier to understand
    what is going on, but if you are wondering what Eloquent methods you can use,
    to see these methods check Eloquent at: [https://laravel.com/docs/5.4/eloquent](https://laravel.com/docs/5.4/eloquent).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正在使用Post模型并使用它的方法执行不同的操作。Lumen的变量和函数名称使我们更容易理解发生了什么，但如果你想知道可以使用哪些Eloquent方法，请查看Eloquent：[https://laravel.com/docs/5.4/eloquent](https://laravel.com/docs/5.4/eloquent)。
- en: If you don't find any of Eloquent method's documentation there note that, a
    lot of functions that we used are of Query Builder. So see query builder documentation
    as well, visit [https://laravel.com/docs/5.4/queries](https://laravel.com/docs/5.4/queries).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在那里找不到Eloquent方法的文档，请注意，我们使用的许多函数都是查询构建器的函数。因此，还要查看查询构建器的文档，网址为[https://laravel.com/docs/5.4/queries](https://laravel.com/docs/5.4/queries)。
- en: As `CommentController` implementation will be similar, I would suggest you to
    implement `CommentController` by yourself, because you will actually learn when
    you do it by yourself.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CommentController`的实现将类似，我建议您自己实现`CommentController`，因为您只有自己动手才能真正学会。
- en: What we are missing?
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们错过了什么？
- en: Are we done with making Controllers that serves RESTful resources endpoints?
    Actually no, we have missed many things. We just created basic RESTful web service,
    which can work just to give you an idea of how we can make it using Lumen, but
    we have missed many things. So, let's look at them and do them one by one.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否已经创建了为RESTful资源端点提供服务的控制器？实际上没有，我们错过了很多东西。我们只是创建了基本的RESTful网络服务，可以让您了解如何使用Lumen制作它，但我们错过了很多东西。因此，让我们看看它们，逐个完成它们。
- en: Validation and negative cases?
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证和负面情况？
- en: 'First, we are only dealing with positive cases: that means we are not considering
    what happens if the request is not according to our assumption. What if the user
    is sending data with the wrong method? What if a record doesn''t exist with the
    ID that the user is passing on?'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只处理积极的情况：这意味着我们不考虑如果请求不符合我们的假设会发生什么。如果用户使用错误的方法发送数据会发生什么？如果用户传递的ID不存在记录会发生什么？
- en: In short, we are not yet handling all that, but there are things that Lumen
    is handling for us already.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们还没有处理所有这些，但是Lumen已经为我们处理了一些事情。
- en: If you try to hit endpoint URLs, `http://localhost:8000/api/posts/1` with the
    `POST` method, then, it is an invalid method. On those URLs, we can only send
    a request with `GET`, `PUT` or `PATCH`. With `GET`, it will trigger the `PostController`
    `show()` method while `PUT` or `PATCH` will trigger the `update()` method. But
    the `POST` method shouldn't be allowed. And in fact, if you try to send a request
    on these URLs with the `POST` method, it will not work, and you will also get
    a `Method Not Allowed` error just like it should be. So by defining our routes
    once, Lumen will deal with such errors by itself.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试使用`POST`方法命中端点URL，`http://localhost:8000/api/posts/1`，那么这是一种无效的方法。在这些URL上，我们只能使用`GET`，`PUT`或`PATCH`发送请求。使用`GET`将触发`PostController`的`show()`方法，而`PUT`或`PATCH`将触发`update()`方法。但是不应该允许使用`POST`方法。实际上，如果您尝试使用`POST`方法在这些URL上发送请求，它将不起作用，您还将收到`Method
    Not Allowed`错误，就像应该的那样。因此，通过一次定义我们的路由，Lumen将自行处理此类错误。
- en: In the same way, Lumen will invalidate wrong URLs or wrong HTTP methods and
    URL combinations.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Lumen将使错误的URL或错误的HTTP方法和URL组合无效。
- en: Other than that, we are not going to make it handle each and every case, but
    let's look at important stuff that we must deal with; stuff without which our
    work couldn't be completed.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们不打算处理每一种情况，但让我们看看我们必须处理的重要事情；如果没有这些东西，我们的工作就无法完成。
- en: So, let's see what we have missed in each method of `PostController` regarding
    validation or missing use cases.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看`PostController`每个方法中我们错过了什么关于验证或缺失的用例。
- en: /api/posts with GET method
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GET方法的/api/posts
- en: 'Here is the response of `/api/posts` endpoint (in my case, there is only one
    record in DB):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`/api/posts`端点的响应（在我的情况下，数据库中只有一条记录）：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you recall the response that we saw in [Chapter 1](42e167df-3aca-4f21-8d1d-c39d5865ab39.xhtml),
    *RESTful Web Services, Introduction and Motivation*, you will see that we are
    getting most of the information that we discussed but we are getting it in a different
    format. Although that is perfectly fine as it is giving enough information, here
    is how we can make it similar to what we decided.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回忆一下我们在[第1章](42e167df-3aca-4f21-8d1d-c39d5865ab39.xhtml)中看到的响应，*RESTful Web
    Services, Introduction and Motivation*，您会发现我们得到了我们讨论的大部分信息，但是以不同的格式得到了。尽管这完全没问题，因为它提供了足够的信息，但是这是如何使其与我们决定的内容相似。
- en: 'Here is what the `index()` method will become:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`index()`方法将变成什么样子：
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The most important thing was that all the information at the root level of response
    isn't clean. We should eliminate the stuff that harms clarity because programmers'
    productivity can be affected if a programmer needs to spend more time just to
    understand something. We should have pagination related information under a separate
    attribute, which can be pagination or meta, so that the programmer can easily
    see data and other attributes.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，响应的根级别的所有信息都不清晰。我们应该消除损害清晰度的内容，因为如果程序员需要花更多时间才能理解某些内容，程序员的生产力可能会受到影响。我们应该将分页相关的信息放在一个单独的属性下，可以是pagination或meta，这样程序员就可以轻松地查看数据和其他属性。
- en: We did it, but we did it manually. For now, let's be done with it. In the next
    chapter, we will see what is wrong with this, why we called it manually, and what
    we can do about it.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了，但是我们是手动做的。现在，让我们暂时告一段落。在下一章中，我们将看看这其中有什么问题，为什么我们要手动调用它，以及我们可以做些什么。
- en: /api/posts with the POST method
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用POST方法的/api/posts
- en: 'This will trigger the `PostController::store()` method. The thing we have missed
    is validation. In fact, Lumen provides us validation support as well as some built-in
    validation rules. Lumen validation is very similar to Laravel, with some differences.
    I would suggest that you have a look at Laravel''s validation documentation, at
    [https://laravel.com/docs/5.4/validation](https://laravel.com/docs/5.4/validation),
    and Lumen''s validation differences with Laravel: [https://lumen.laravel.com/docs/5.4/validation](https://lumen.laravel.com/docs/5.4/validation).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这将触发`PostController::store()`方法。我们错过的是验证。实际上，Lumen还为我们提供了验证支持以及一些内置的验证规则。Lumen的验证与Laravel非常相似，但也有一些不同之处。我建议您查看Laravel的验证文档，网址为[https://laravel.com/docs/5.4/validation](https://laravel.com/docs/5.4/validation)，以及Lumen与Laravel的验证差异：[https://lumen.laravel.com/docs/5.4/validation](https://lumen.laravel.com/docs/5.4/validation)。
- en: 'Here, we have added validation in `store()`, so look at the code after adding
    validation and we will then discuss it:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`store()`中添加了验证，因此在添加验证后查看代码，然后我们将讨论它：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here we are doing 3 things:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在做3件事：
- en: 'First, we have set the following validation rules:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们设置了以下验证规则：
- en: For `content` and `title`, these fields will be required and will be a minimum
    of 1 character long.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`content`和`title`，这些字段将是必需的，并且至少为1个字符长。
- en: For `status`, it is required and its value can be either published or draft
    as it is set as ENUM in the database.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`status`，它是必需的，其值可以是已发布或草稿，因为它在数据库中设置为ENUM。
- en: '`user_id` is required and it should exist in the `users` table''s `id` field.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`user_id`是必需的，并且应存在于`users`表的`id`字段中。'
- en: Then, we made a validator object based on validation rules and input, and check
    if validator fails. Otherwise, we will keep proceeding.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们根据验证规则和输入创建了一个验证器对象，并检查验证器是否失败。否则，我们将继续进行。
- en: If the validator fails, it returns an error manually. It is returning the same
    error description that it gets from the validator while returning an appropriate
    response code manually. And that's why we have used `\Illuminate\Http\JsonResponse`.
    The first parameter is the response body while the second parameter is the response
    code. And instead of writing 400 error code, we can use a constant in `\Illuminate\Http\Response`**.**
    So we will not need to remember the response codes, and someone reading our code
    will not need to know what the 400 status code is.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果验证器失败，它将手动返回错误。它返回与验证器获得的相同错误描述，同时手动返回适当的响应代码。这就是为什么我们使用了`\Illuminate\Http\JsonResponse`。第一个参数是响应主体，而第二个参数是响应代码。而不是编写400错误代码，我们可以在`\Illuminate\Http\Response`中使用一个常量。因此，我们将不需要记住响应代码，阅读我们的代码的人也不需要知道400状态代码是什么。
- en: Please note that Error code, response code, and HTTP code represent the same
    thing. So don't get confused if you see them, they are used interchangeably in
    this book.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，错误代码、响应代码和HTTP代码表示相同的事情。因此，如果您看到它们，不要感到困惑，它们在本书中是可以互换使用的。
- en: /api/posts/1 with the GET method
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GET方法的/api/posts/1
- en: 'This will be served from the `show($id)` method. In our show method, we are
    just getting the record and returning, but what if ID coming in the `show()` method
    that is passed in URLs is incorrect, or records indicate that ID doesn''t exist?
    So, we just need to place a check to make sure that it returns a 404 error, if
    a post is not found with that ID. Our code for the `show()` method will look like
    this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这将由`show($id)`方法提供。在我们的show方法中，我们只是获取记录并返回，但是如果传递给URL中的`show()`方法的ID不正确，或者记录表明该ID不存在，该怎么办？因此，我们只需要放置一个检查以确保它返回404错误，如果找不到具有该ID的帖子。我们的`show()`方法的代码将如下所示：
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `abort()` method will stop execution with an error code passed to it. In
    this case, it will simply give a 404 Not Found Error.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`abort()`方法将使用传递给它的错误代码停止执行。在这种情况下，它将简单地给出404 Not Found错误。'
- en: /api/posts/1 with the PATCH/PUT method
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PATCH/PUT方法的/api/posts/1
- en: 'It will be served by the `update()` method. Again, it is based on ID provided,
    so we need to check if that ID is valid or not. So here is what we will do:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 它将由`update()`方法提供。同样，它是基于提供的ID，因此我们需要检查该ID是否有效。因此，这就是我们将要做的事情：
- en: '[PRE43]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, we have used model''s `fill()` method, which will assign Post model with
    fields and values in $input and will then save it with the `save()` method. In
    Laravel documentation, you can see Insert and Update using Eloquent in different
    ways, which can be handy in different places: [https://laravel.com/docs/5.4/eloquent#inserting-and-updating-models](https://laravel.com/docs/5.4/eloquent#inserting-and-updating-models).'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了模型的`fill()`方法，它将使用$input中的字段和值分配给Post模型，然后使用`save()`方法保存它。在Laravel文档中，您可以看到使用Eloquent以不同方式插入和更新的方法，这在不同的地方可能很方便：[https://laravel.com/docs/5.4/eloquent#inserting-and-updating-models](https://laravel.com/docs/5.4/eloquent#inserting-and-updating-models)。
- en: Sometimes, you will see a Laravel documentation link instead of Lumen. It is
    because Lumen is mostly using the same code as Laravel. The documentation for
    all those components are mostly written in Laravel's documentation and it isn't
    replicated in Lumen documentation, so Lumen documentation is good where Lumen
    is different from Laravel.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您会看到Laravel文档链接，而不是Lumen。这是因为Lumen大多使用与Laravel相同的代码。所有这些组件的文档大多是在Laravel的文档中编写的，并且没有在Lumen文档中复制，因此Lumen文档在Lumen与Laravel不同的地方是很好的。
- en: So that is what we have to do in the `update()` method.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在`update()`方法中要做的事情。
- en: /api/posts/1 with the DELETE method
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DELETE方法的/api/posts/1
- en: 'The delete operation will be served by `destroy($id)`. Again, it depends on
    ID coming from an API user, so we need to place a similar check as we placed for
    `update()` and `show()`. Here is what it will look like:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作将由`destroy($id)`提供。同样，它取决于来自API用户的ID，因此我们需要放置与我们为`update()`和`show()`放置的类似检查。它将如下所示：
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With that, our `PostController` will look like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的`PostController`将如下所示：
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We are now done with returning proper response codes and validation and so on.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了返回适当的响应代码和验证等工作。
- en: User authentication
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户身份验证
- en: The other thing we are missing till now is user authentication. We are passing
    `user_id` in the input, and that is wrong. We did that because we didn't have
    user authentication. So, we need to have an authentication mechanism. However,
    in addition to authentication, we need to have a token-generation mechanism as
    well. In fact, we will also need to refresh token as well. Although we can do
    this by ourselves, we will install another external package.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还缺少用户身份验证。我们在输入中传递了`user_id`，这是错误的。我们之所以这样做是因为我们没有用户身份验证。因此，我们需要有一个身份验证机制。但是，除了身份验证之外，我们还需要有一个令牌生成机制。实际上，我们还需要刷新令牌。虽然我们可以自己做到这一点，但我们将安装另一个外部包。
- en: Starting user authentication at the end of the chapter doesn't make much sense,
    so we will be dealing with user authentication in next chapter because there are
    different things associated with it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾开始用户身份验证并没有太多意义，因此我们将在下一章中处理用户身份验证，因为与之相关的事情有很多。
- en: Other missing elements
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他缺失的元素
- en: 'Other things that we are missing right now are listed as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在缺少的其他东西如下：
- en: API versioning
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API版本控制
- en: Rate Limiting or Throttling
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制或节流
- en: Need of encryption
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密的需求
- en: Transformers or Serializes
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换器或序列化
- en: (This is to avoid making hard code manual return format inside the controller)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: （这是为了避免在控制器内部进行硬编码手动返回格式）
- en: In the next chapter, we will deal with user authentication and the preceding
    mentioned elements, and will make some other improvements.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理用户认证和前面提到的元素，并进行一些其他改进。
- en: Comment Resource Implementation
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评论资源实现
- en: 'I left comment endpoints implementation to you, because it is very much similar
    to Post endpoints implementation. However, as comment''s two routes are different
    than others, just to give you an idea of what you need to implement, I am going
    to tell what you will add in the `routes` file so that you can implement `CommentController`
    accordingly. Here is the `routes/web.php` file:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我把评论端点的实现留给了你，因为它与帖子端点的实现非常相似。但是，由于评论的两个路由与其他路由不同，为了让你了解你需要实现什么，我将告诉你在`routes`文件中添加什么，以便你可以相应地实现`CommentController`。这是`routes/web.php`文件：
- en: '[PRE46]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see, we have added the `$except` array as an optional third argument
    in `resource()` so that if we don't want to generate some particular route for
    a resource, we can pass that in the `$except` array.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在`resource()`中添加了`$except`数组作为可选的第三个参数，这样如果我们不想为某个资源生成特定的路由，我们可以将其传递给`$except`数组。
- en: In `CommentController`, the code will be very similar to `PostController`, except
    that for `store()` and `index()`, `post_id` will be the first argument and will
    be used.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CommentController`中，代码将与`PostController`非常相似，只是对于`store()`和`index()`，`post_id`将是第一个参数并将被使用。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Till now, we have created RESTful web services endpoints in a micro-framework
    named Lumen. We created migrations, models and routes. I implemented `PostController`
    but left `CommentController` implementation for you. So, as we can see that lot
    of problems that we discussed related to implementation in [Chapter 3](75dfe538-b06c-46b9-a07f-8ac29a158975.xhtml),
    *Creating Restful Endpoints*, are solved already because of using a framework.
    And we are able to solve many other problems very easily. So, using the right
    framework and packages, we are able to work much faster.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在一个名为Lumen的微框架中创建了RESTful web服务端点。我们创建了迁移、模型和路由。我实现了`PostController`，但留下了`CommentController`的实现给你。因此，我们可以看到，我们在[第3章](75dfe538-b06c-46b9-a07f-8ac29a158975.xhtml)中讨论的许多与实现相关的问题，*创建RESTful端点*，已经得到解决，因为使用了一个框架。我们能够很容易地解决许多其他问题。因此，使用正确的框架和包，我们能够工作得更快。
- en: We have also identified some missing elements, including user authentication.
    We will solve them in the next chapter. In the next chapter, we will improve our
    work from the code aspect as well.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还确定了一些缺失的元素，包括用户认证。我们将在下一章中解决它们。在下一章中，我们还将从代码方面改进我们的工作。
- en: 'In this chapter, we were mostly working with Lumen. We looked at it but we
    were trying to proceed to make our API and so we were not able to see each and
    every part of Lumen and its code in detail. So, it is a good idea to see Lumen''s
    documentation: [https://lumen.laravel.com/docs/5.4/validation](https://lumen.laravel.com/docs/5.4/validation).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们主要使用Lumen。我们看了它，但我们试图继续制作我们的API，所以我们无法详细查看Lumen及其代码的每一个部分。因此，查看Lumen的文档是一个好主意：[https://lumen.laravel.com/docs/5.4/validation](https://lumen.laravel.com/docs/5.4)。
- en: 'For better understanding, you should look at Laravel''s documentation, as some
    common components are explained mostly in Laravel''s documentation: [https://laravel.com/docs/5.4](https://laravel.com/docs/5.4).
    Other than the documentation of Laravel and Lumen, it is a very good idea and
    is recommended to go to [http://laracasts.com/](http://laracasts.com/) and see
    videos on Laravel. Don''t worry if you don''t find much stuff on Lumen, it is
    very similar to Laravel. Other than a few changes, they are pretty much same.
    To understand Laravel and/or Lumen, Lara casts is an excellent resource and is
    very popular in the Laravel community. Lara casts are mostly by Jeffrey Way. I
    learned a lot from him and hope that you will learn as well. It will not only
    teach you Laravel but also teach you how to develop something, and how you should
    do development.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，您应该查看Laravel的文档，因为一些常见组件在Laravel的文档中有详细解释：[https://laravel.com/docs/5.4](https://laravel.com/docs/5.4)。除了Laravel和Lumen的文档之外，建议去[http://laracasts.com/](http://laracasts.com/)观看关于Laravel的视频。如果在Lumen上找不到太多内容，不要担心，它与Laravel非常相似。除了一些变化，它们基本上是一样的。要了解Laravel和/或Lumen，Lara
    casts是一个非常好的资源，在Laravel社区非常受欢迎。Lara casts主要由Jeffrey Way制作。我从他那里学到了很多东西，希望你也能学到。它不仅会教你Laravel，还会教你如何开发，以及你应该如何进行开发。
