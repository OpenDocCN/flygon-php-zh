- en: The All New PHP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全新的PHP
- en: Programming languages nowadays are a dime a dozen. New languages spring into
    existence every so often. Choosing the right one for the job is so much more than
    just a checklist of its features. Some of them target specific problem domains,
    others try to position themselves for more general use. This goes to say that
    software development is a dynamic ecosystem where languages need to constantly
    adapt to ever-changing industry in order to stay relevant to its consumers. These
    changes are particularly challenging for already established languages such as
    PHP, where backward compatibility is an important consideration.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如今编程语言不胜枚举。新的语言不时地出现。选择适合工作的语言远不止是其功能清单的一部分。有些针对特定的问题领域，其他则试图定位更广泛的使用。这说明软件开发是一个动态的生态系统，语言需要不断适应不断变化的行业，以保持对其消费者的相关性。这些变化对于已经建立的语言（如PHP）尤其具有挑战性，因为向后兼容性是一个重要的考虑因素。
- en: Originally created by Rasmus Lerdorf around 1995, PHP started its life as nothing
    more than a few **Common Gateway Interface** (**CGI**) programs in C. At that
    time, it was a simple scripting solution that empowered developers to build dynamic
    HTML pages with ease. Without the need to compile, developers could easily throw
    in a few lines of code into a file and see the results in the browser. This gave
    a rise to its early popularity. Two decades later, PHP matured into a rich general-purpose
    scripting language suited to web development. Throughout all these years, PHP
    managed to yield an impressive set of features with each new release whilst maintaining
    a trustworthy level of backward compatibility. Nowadays, large number of its core
    extensions ultimately simplify working with files, sessions, cookies, databases,
    web services, cryptography, and many other features common to web development.
    Its outstanding support for the **object-oriented programming** (**OOP**) paradigm
    made it truly competitive with other leading industry languages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: PHP最初由Rasmus Lerdorf于1995年左右创建，起初只是用C语言编写的一些CGI程序。那时，它是一个简单的脚本解决方案，使开发人员能够轻松构建动态HTML页面。无需编译，开发人员可以轻松地将几行代码放入文件中，并在浏览器中查看结果。这使得它早期非常受欢迎。二十年后，PHP发展成为一个适用于Web开发的丰富通用脚本语言。在这些年里，PHP成功地在每个新版本中提供了令人印象深刻的功能集，同时保持了可靠的向后兼容性水平。如今，其大量的核心扩展最终简化了与文件、会话、Cookie、数据库、Web服务、加密和许多其他Web开发常见功能的工作。它对面向对象编程（OOP）范式的出色支持使其真正与其他领先的行业语言竞争。
- en: The decade-old ruling of PHP 5 has been overthrown by the release of PHP 7 in
    December 2015\. It brought forth the all new execution engine, **Zend** Engine
    3.0, which significantly improved performance and reduced memory consumption.
    This simple software update now allowed us to serve more concurrent users without
    adding any physical hardware to the mix. Acceptance among developers has been
    almost instant, all the more so because backward incompatibility was minimal,
    making migration as painless as possible.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 5十年的统治在2015年12月PHP 7的发布中被推翻。它带来了全新的执行引擎Zend Engine 3.0，显著提高了性能并减少了内存消耗。这个简单的软件更新现在使我们能够为更多并发用户提供服务，而无需添加任何物理硬件。开发者的接受程度几乎是瞬间的，尤其是因为向后不兼容性很小，使得迁移尽可能轻松。
- en: 'In this chapter, we will take a detailed look into some of the new features
    introduced in PHP 7 and 7.1 releases:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细了解PHP 7和7.1版本中引入的一些新功能：
- en: Scalar type hints
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量类型提示
- en: Return type hints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型提示
- en: Anonymous classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名类
- en: Generator delegation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器委托
- en: Generator return expressions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器返回表达式
- en: The null coalesce operator
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空合并运算符
- en: The spaceship operator
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 太空船操作符
- en: Constant arrays
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量数组
- en: Uniform variable syntax
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一的变量语法
- en: Throwables
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可抛出的
- en: Group use declarations
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组使用声明
- en: Class constant visibility modifiers
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类常量可见性修饰符
- en: Catching multiple exceptions types
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获多个异常类型
- en: Iterable pseudo-type
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可迭代伪类型
- en: Nullable types
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可空类型
- en: Void return types
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无返回类型
- en: It is features like these that are bound to make a mark on the next generation
    of PHP frameworks and libraries, as well as how we write our own code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这些特性注定会在下一代PHP框架和库以及我们编写自己的代码的方式上留下深刻印记。
- en: Scalar type hints
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标量类型提示
- en: By classification, PHP is a dynamically typed and weakly typed language. These
    are two different concepts that often get mixed together. Dynamically typed languages
    do not require the explicit declaration of a variable before it is used. Weakly
    typed languages are those in which the variable is not of any specific data type,
    that is, its type can change through different value-type reassignments.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 按分类，PHP是一种动态类型和弱类型的语言。这是两个经常混在一起的不同概念。动态类型的语言不需要在使用之前显式声明变量。弱类型的语言是指变量不属于任何特定的数据类型，也就是说，它的类型可以通过不同的值类型重新分配而改变。
- en: 'Let''s take a look at the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下例子：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we see three different variables being used, none of
    which are predefined with a certain type. We just have values declared into them.
    PHP then determines the type on the go. Even when the variable type is determined,
    it can still be changed by simply assigning another type of value to it. These
    are two very powerful concepts, which, when used wisely, can save us lines and
    lines of code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们看到使用了三个不同的变量，其中没有一个预定义为特定类型。我们只是将值声明到它们中。PHP然后在运行时确定类型。即使确定了变量类型，也可以通过简单地分配另一种类型的值来更改它。这是两个非常强大的概念，当明智地使用时，可以为我们节省大量代码行。
- en: However, these powerful features often indirectly encourage bad design. This
    is particularly noticeable when writing functions, either by forcing function
    designers into multiple data type checks, or forcing them into multiple function
    return types.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些强大的特性往往间接地鼓励了不良设计。这在编写函数时特别明显，要么是通过强制函数设计者进行多个数据类型检查，要么是强制他们进行多个函数返回类型。
- en: 'Let''s take a look at the following example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下例子：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Given the type uncertainty of the input argument, the `addTab` function was
    forced to branch its logic. Similarly, the same function might decide to return
    different types of data, depending on the logic branch. Designs like these are
    usually a result of functions that simply try to do too much. The real problem
    is not even in the function, it is on the consumer side of things. If it happens
    that the developer using a function is not aware enough of the passing parameter
    type, unexpected results might occur.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到输入参数的类型不确定性，`addTab`函数被迫分支其逻辑。同样，同一个函数可能决定根据逻辑分支返回不同类型的数据。这样的设计通常是因为函数试图做太多事情。真正的问题甚至不在函数本身，而是在使用函数的开发人员那一边。如果发生开发人员对传递参数类型不够了解，可能会导致意外的结果。
- en: To help us write more correct and self-documenting programs, PHP introduced
    **type hinting**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们编写更正确和自我描述的程序，PHP引入了**类型提示**。
- en: 'PHP has supported function parameter type hinting from version 5.0, but only
    for objects, and from version 5.1 for arrays as well. With PHP 7, scalar types
    can be type-hinted as well, making it one of the more exciting features of the
    release. The following are the scalar type hints that are supported by PHP:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: PHP从5.0版本开始支持函数参数类型提示，但仅限于对象，从5.1版本开始也支持数组。PHP 7开始，标量类型也可以进行类型提示，这使其成为该版本中更令人兴奋的功能之一。以下是PHP支持的标量类型提示：
- en: '`int`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`float`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`'
- en: '`string`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`'
- en: '`bool`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`'
- en: 'We can now write functions in either of the following ways:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以以以下两种方式编写函数：
- en: It can  be `function register($email, $age, $notify) { /* ... */}`
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以是`function register($email, $age, $notify) { /* ... */}`
- en: It can be `function register($email, int $age, $notify) { /* ... */}`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以是`function register($email, int $age, $notify) { /* ... */}`
- en: It can be `function register(string $email, int $age, bool $notify) { /* ...
    */}`
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以是`function register(string $email, int $age, bool $notify) { /* ... */}`
- en: However, simply hinting scalar types is not enough as type declarations are
    not enforced by default. PHP will simply attempt to convert to the specified type
    without complaint. By adding the `declare(strict_types=1);` directive as the first
    statement in a PHP file, we can enforce the strict type checking behavior. It
    is worth noting that this directive only affects the specific file it is used
    in, and does not affect other included files. The **file-level** directive was
    used to preserve the backward compatibility with numerous extensions and built-in
    PHP functions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅对标量类型进行提示是不够的，因为类型声明默认情况下不会被强制执行。PHP会尝试将其转换为指定的类型而不会抱怨。通过在PHP文件的第一条语句中添加`declare(strict_types=1);`指令，我们可以强制执行严格的类型检查行为。值得注意的是，该指令只影响它所在的特定文件，并不影响其他包含的文件。**文件级别**指令用于保持与众多扩展和内置PHP函数的向后兼容性。
- en: 'Let''s take a look at the following example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With strict types directive turned on, trying to pass an improper data type
    to a hinted scalar parameter would result in a `\TypeError` exception, as per
    the following output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 打开严格类型指令后，尝试将不正确的数据类型传递给提示的标量参数将导致`\TypeError`异常，如下所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Scalar type hints are a powerful new addition to the PHP language. They empower
    developers with an extra layer of protection during runtime, without really sacrificing
    the weak type system in general.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 标量类型提示是PHP语言的一个强大的新功能。它们在运行时为开发人员提供了额外的保护层，而不会真正牺牲一般的弱类型系统。
- en: Return type hints
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回类型提示
- en: 'Type hinting features are not limited to function parameters only; as of PHP
    7, they expand to function return values as well. The same rules that apply to
    function parameters hinting, apply to function return type hinting. To specify
    a function return type, we simply follow the parameter list with a colon and the
    return type, as shown in the following example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示功能不仅限于函数参数；从PHP 7开始，它们还扩展到函数返回值。适用于函数参数提示的规则也适用于函数返回类型提示。要指定函数返回类型，我们只需在参数列表后面加上冒号和返回类型，如下例所示：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Developers can still write functions with multiple conditioned `return` statements;
    its just that in this case, each of these `return` statements, when reached, will
    have to match the hinted return type, otherwise `\TypeError` will be thrown.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员仍然可以编写带有多个条件`return`语句的函数；只是在这种情况下，每个达到的`return`语句都必须匹配提示的返回类型，否则会抛出`\TypeError`。
- en: 'The function return type hints play nicely with super types. Let''s take a
    look at the following example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回类型提示与超类型很好地配合。让我们看下面的例子：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We see that the function executes nicely for all three types. Given that `B`
    extends `A` directly, and `C` extends `B`, the function accepts them as the return
    value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到该函数对所有三种类型都执行得很好。鉴于`B`直接扩展了`A`，而`C`又扩展了`B`，该函数接受它们作为返回值。
- en: Given the dynamic nature of PHP, function return types might seem like a step
    in the wrong direction at first, more so because a lot of PHP code out there already
    uses the PHPDoc `@return` annotation, which plays nicely with modern IDE tools,
    such as PhpStorm. However, the `@return` annotation is merely informative, it
    does not enforce an actual return type during runtime, and it really makes sense
    only with a powerful IDE. Using the function return type hints ensures that our
    functions return what we intended them to return. They do not stand in the way
    of PHP's dynamic nature; they merely enrich it from a function consumer point
    of use.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到PHP的动态特性，函数返回类型可能一开始看起来似乎是朝错误的方向迈出的一步，更何况因为很多PHP代码已经使用了PHPDoc的`@return`注释，这与现代IDE工具（如PhpStorm）很好地配合。然而，`@return`注释只是提供信息，它在运行时并不强制实际返回类型，而且只有在强大的IDE中才有意义。使用函数返回类型提示可以确保我们的函数返回我们打算返回的内容。它们并不妨碍PHP的动态特性；它们只是从函数使用者的角度丰富了它。
- en: Anonymous classes
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名类
- en: Instantiating objects from classes is a pretty straightforward action. We use
    the `new` keyword, followed by a class name and possible constructor parameters.
    The class name part implies the existence of a previously defined class. Though
    rare, there are cases where classes are only used during execution. These rare
    cases make it verbose to force a class definition separately when we know that
    the class is only being used once. To address this verbosity challenge, PHP introduced
    a new functionality called **anonymous classes**. While the concept of anonymous
    classes has been around for quite some time in other languages, PHP only got to
    it in the PHP 7 release.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从类中实例化对象是一个非常简单的操作。我们使用`new`关键字，后面跟着类名和可能的构造函数参数。类名部分意味着之前定义的类的存在。虽然很少见，但有些情况下类只在执行期间使用。这些罕见的情况使得在我们知道类只被使用一次时，强制单独定义一个类变得冗长。为了解决这种冗长的挑战，PHP引入了一个名为**匿名类**的新功能。虽然匿名类的概念在其他语言中已经存在了相当长的时间，但PHP在PHP
    7版本中才引入了它。
- en: 'The syntax of anonymous classes is pretty straightforward, which is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类的语法非常简单，如下所示：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We use the `new` keyword , followed by the `class` keyword, followed by optional
    constructor parameters, and finally the body of the class packed in curly braces.
    Both objects are instantiated as a `class@anonymous` type. The functionality of
    objects instantiated through anonymous classes is no different from those instantiated
    via named classes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`new`关键字，后面跟着`class`关键字，然后是可选的构造函数参数，最后是用大括号包裹的类体。两个对象都被实例化为`class@anonymous`类型。通过匿名类实例化的对象的功能与通过命名类实例化的对象没有区别。
- en: Compared to named classes, anonymous classes are pretty much equal, in that,
    they can pass contractor parameters, extend other classes, implement interfaces,
    and use traits. However, anonymous classes cannot be serialized. Trying to serialize
    an instance of an anonymous class, as shown in the following code snippet, throws
    a fatal `Serialization of class@anonymous is not allowed…` error.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与命名类相比，匿名类几乎是相等的，它们可以传递构造函数参数，扩展其他类，实现接口，并使用特性。然而，匿名类不能被序列化。尝试序列化匿名类的实例，如下面的代码片段所示，会抛出一个致命的`Serialization
    of class@anonymous is not allowed…`错误。
- en: 'There are few other caveats to keep in mind when using anonymous classes. Nesting
    an anonymous class within another class hides the private and protected methods
    or properties of that outer class. To circumvent the limitation, we can pass the
    outer class'' private and protected properties into an anonymous class constructor,
    as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用匿名类时，需要牢记一些注意事项。在另一个类中嵌套匿名类会隐藏该外部类的私有和受保护的方法或属性。为了规避这个限制，我们可以将外部类的私有和受保护的属性传递到匿名类的构造函数中，如下所示：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this strip down `User` class example, we have a `salary` method that returns
    an anonymous class. To showcase the more robust use of anonymous classes, we make
    it implement the `Salary` interface and use the `Util` trait. The `Salary` interface
    forces the anonymous class to implement the `pay` method. Our implementation of
    `pay` method requires `IBAN` and `salary` member values from the outer class.
    Since an anonymous class does not allow access to private and protected members
    of the outer class, we pass those through anonymous class constructors. While
    the overall example certainly does not reflect notions of a good class design,
    it does showcase how to bypass the member visibility limitation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简化的`User`类示例中，我们有一个返回匿名类的`salary`方法。为了展示匿名类更强大的用法，我们让它实现`Salary`接口并使用`Util`特性。`Salary`接口强制匿名类实现`pay`方法。我们的`pay`方法的实现需要外部类的`IBAN`和`salary`成员值。由于匿名类不允许访问外部类的私有和受保护成员，我们通过匿名类构造函数传递这些值。虽然整体示例当然不反映出良好的类设计概念，但它展示了如何绕过成员可见性限制。
- en: There is also an option for an anonymous class to fetch the private and protected
    members of the outer class by extending the outer class itself. However, this
    requires the anonymous class constructor to properly instantiate the outer class;
    otherwise, we might end up with a warning, such as a missing argument, for `User::__construct()`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类还有一个选项，可以通过扩展外部类本身来获取外部类的私有和受保护成员。然而，这需要匿名类的构造函数正确实例化外部类；否则，我们可能会遇到警告，比如`User::__construct()`缺少参数。
- en: 'Even though they are namelessly defined, anonymous classes still get an internal
    name. Using the core PHP `get_class` method on an instance of an anonymous class,
    gets us that name, as shown in the following examples:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们没有名字，匿名类仍然有一个内部名称。在匿名类的实例上使用核心PHP `get_class`方法，可以得到这个名称，如下面的例子所示：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Observing these outputs, we see that the anonymous classes created in the same
    position (function or a loop) will yield the same internal name. Those with the
    same name return `true` for the equal (`==`) operator and `false` for the identity
    operator (`===`), an important consideration in order to avoid potential bugs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 观察这些输出，我们可以看到在相同位置（函数或循环）创建的匿名类将产生相同的内部名称。具有相同名称的匿名类对等号（`==`）运算符返回`true`，对身份运算符（`===`）返回`false`，这是一个重要的考虑因素，以避免潜在的错误。
- en: Support for an anonymous classes opens a door to some interesting use cases,
    such as mocking tests and doing the inline class overrides, both of which, when
    used wisely, can improve code quality and readability.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对匿名类的支持为一些有趣的用例打开了大门，比如模拟测试和进行内联类覆盖，这两者在明智使用时可以提高代码质量和可读性。
- en: Generator delegation
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器委托
- en: Iterating through a list of items is among the most common things in any programming
    language. PHP makes it easy to iterate over a diverse collection of data using
    the `foreach` construct. Many languages differentiate various data types of collection
    data, such as dictionary, list, set, tuple, and alike. PHP, however, does not
    dwell that much on data structures and simply uses the `array()` or `[]` constructs
    most of the time for its collections. This, in turn, can have a negative impact
    on creating large arrays in memory, which could cause exceeding memory limits
    or even increased processing times.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编程语言中，遍历项目列表是最常见的事情之一。PHP通过`foreach`结构使得遍历各种数据集合变得容易。许多语言区分各种类型的集合数据，如字典、列表、集合、元组等。然而，PHP并不过多关注数据结构，大多数情况下简单地使用`array()`或`[]`结构来表示集合。这反过来可能会对创建大型数组在内存中产生负面影响，可能导致超出内存限制甚至增加处理时间。
- en: Aside from the primitive *array* type, PHP also provides the `ArrayObject` and
    `ArrayIterator` classes. These turn arrays into a first class citizens in an OOP
    application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了原始的*array*类型外，PHP还提供了`ArrayObject`和`ArrayIterator`类。这些类将数组转变为面向对象应用程序中的一等公民。
- en: Generators allow us to write code that uses `foreach` to iterate over a set
    of data without needing to build an array. They are like a function that yields
    as many values as needed, instead of returning just one, which gives them an iterator-like
    behavior. While generators have been around from PHP 5.5, they lacked more advanced
    functionality. **Generator delegation** is one of the improvements made available
    with the release of PHP 7.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器允许我们编写使用`foreach`来遍历一组数据而无需构建数组的代码。它们就像一个产出尽可能多值的函数，而不是只返回一个值，这使它们具有类似迭代器的行为。虽然生成器从PHP
    5.5就存在，但它们缺乏更高级的功能。**生成器委托**是PHP 7发布后提供的改进之一。
- en: 'Let''s take a look at the following example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we define three generator functions: `even`, `odd`, and `mix`. The `mix`
    function demonstrates the concept of generator delegation via the use of `yield`
    from `<expr>`. Whereas, `<expr>` is any expression that evaluates to a traversable
    object or array. We can see that the result of looping through the `mix` function
    echoes all of the yielded values from both itself as well as the `even` and `odd`
    functions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了三个生成器函数：`even`、`odd`和`mix`。`mix`函数通过使用`yield` from `<expr>`演示了生成器委托的概念。而`<expr>`是任何评估为可遍历对象或数组的表达式。我们可以看到通过循环遍历`mix`函数的结果，会输出它自身以及`even`和`odd`函数的所有产出值。
- en: The generator delegation syntax allows the factoring of `yield` statements into
    smaller conceptual units, giving generators the similar organizational functionality
    as methods give to classes. Used carefully, this can improve our code quality
    and readability.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器委托语法允许将`yield`语句分解为更小的概念单元，使生成器具有类似方法对类的组织功能。谨慎使用时，这可以提高我们的代码质量和可读性。
- en: Generator return expressions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器返回表达式
- en: 'Though PHP 5.5 enriched the language by introducing generator functions functionality,
    it lacked the `return` expressions alongside their yielded values. This inability
    of generator functions to specify return values limited their usefulness with
    coroutines. The PHP 7 version addressed this limitation by adding support for
    the `return` expressions. Generators are basically interruptible functions, where
    the `yield` statement flags the interruption point. Let''s take a look at the
    following simple generator, written in the form of a self-invoking anonymous function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管PHP 5.5通过引入生成器函数功能丰富了语言，但它缺乏`return`表达式以及它们的产出值。生成器函数无法指定返回值的能力限制了它们在协程中的实用性。PHP
    7版本通过添加对`return`表达式的支持解决了这个限制。生成器基本上是可中断的函数，其中`yield`语句标志着中断点。让我们来看一个简单的生成器，以自调用匿名函数的形式编写：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Though the `$letters` variable is defined as a self-invoking anonymous function,
    the `yield` statements are preventing immediate function execution, turning the
    function into the generator. Generator itself stands still until we try to iterate
    over it. Once the iteration kicks in, generator yields value `A` followed by value
    `B`, but not `C`. What this means is that when used in the `foreach` construct,
    the iteration will only encompass yielded values, not the returned ones. Once
    the iteration is done, we are free to call the `getReturn()` method to retrieve
    the actual return value. Calling the `getReturn()` method prior to iterating over
    generator results cannot get the return value of a generator that hasn't returned
    an exception.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`$letters`变量被定义为自调用匿名函数，但`yield`语句阻止了立即函数执行，将函数转变为生成器。生成器本身保持静止，直到我们尝试对其进行迭代。一旦迭代开始，生成器产出值`A`，然后是值`B`，但不是`C`。这意味着在`foreach`结构中使用时，迭代将仅包括产出值，而不是返回值。一旦迭代完成，我们可以调用`getReturn()`方法来检索实际的返回值。在迭代生成器结果之前调用`getReturn()`方法无法获取未返回异常的生成器的返回值。
- en: The great thing about the generators is that they are not a one-way street;
    they are not limited to only yielding values, they can accept them as well. By
    being the instances of a `\Generator` class, they operate with several useful
    methods, two of which are `getReturn` and `send`. The send method enables us to
    send values back to the generator, which turns the one-way communication from
    the generator to the caller into a two-way channel between the two, effectively,
    turning generators into coroutines. The addition of the `getReturn` method empowered
    generators with the `return` statements, giving more flexibility with coroutines.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器的好处在于它们不是单向通道；它们不仅限于产出值，还可以接受值。作为`\Generator`类的实例，它们可以使用几个有用的方法，其中两个是`getReturn`和`send`。`send`方法使我们能够将值发送回生成器，将生成器与调用者之间的单向通信转变为双向通道，有效地将生成器转变为协程。添加`getReturn`方法赋予生成器`return`语句，为协程提供更灵活的功能。
- en: The null coalesce operator
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空合并运算符
- en: Working with variables in PHP is quite easy. Variable declaration and initialization
    is done via a single expression. For example, the expression `$user['name'] =
    'John';` will automatically declare variable `$user` of type array and initialize
    that array with a single key name of value `John`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中使用变量非常容易。变量的声明和初始化是通过单个表达式完成的。例如，表达式`$user['name'] = 'John';`将自动声明类型为数组的变量`$user`，并初始化该数组，其中包含一个键名为`name`，值为`John`。
- en: Day-to-day development often includes checking for the existence of a variable
    value for various branching decisions, such as `if ($user['name'] =='John') {
    … } else { … }`. As we write our code ourselves, we tend to make sure that our
    code does not use non-declared variables and non-initialized array keys. There
    are cases, however, where variables come from outside, so we are not really in
    a position to guarantee their existence at runtime. Calling for `$user['name']`
    when `$user` is not set, or is set but with keys other than name, will result
    in notice undefined index--`name`. Like any unexpected state in code, notices
    are bad, more so because they do not actually break your code, they allow it to
    execute further. When a notice occurs, unless we have the `display_errors` configuration
    set to `true`, and error reporting configured to show `E_ALL`, we would not even
    see the notice in the browser.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 日常开发通常包括检查各种分支决策的变量值的存在，比如`if ($user['name'] =='John') { … } else { … }`。当我们自己编写代码时，我们倾向于确保我们的代码不使用未声明的变量和未初始化的数组键。然而，有时变量来自外部，因此我们无法保证它们在运行时的存在。在`$user`未设置或设置但键不是name时调用`$user['name']`将导致未定义索引的通知--`name`。像代码中的任何意外状态一样，通知是不好的，更糟糕的是它们实际上不会破坏你的代码，而是允许它继续执行。当发生通知时，除非我们将`display_errors`配置设置为`true`，并配置错误报告以显示`E_ALL`，否则我们甚至不会在浏览器中看到通知。
- en: This is bad, as we might depend on the existence of variables and their values
    that are not there. This dependency might not even be handled in our code, and
    we would not even notice it because the code will continue to execute unless a
    specific variable check is put in place.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不好的，因为我们可能依赖不存在的变量和它们的值。这种依赖甚至可能没有在我们的代码中处理，我们甚至不会注意到，因为代码将继续执行，除非放置了特定的变量检查。
- en: 'The PHP language has a certain number of predefined variables called **superglobals**,
    which we can use from any function, class, or file, regardless of the scope. The
    most used ones are probably `$_POST` and `$_GET` superglobals, which are used
    to fetch the data submitted via forms or URL parameters. Since we cannot guarantee
    the existence of `$_GET[''name'']` in such cases, we need to check for it. Usually,
    this is done using the `isset` and `empty` functions in PHP, as shown in the following
    code block:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: PHP语言有一定数量的预定义变量，称为**超全局变量**，我们可以从任何函数、类或文件中使用它们，而不受范围的限制。最常用的可能是`$_POST`和`$_GET`超全局变量，它们用于获取通过表单或URL参数提交的数据。由于我们无法保证在这种情况下`$_GET['name']`的存在，因此我们需要检查它。通常，这是通过PHP中的`isset`和`empty`函数来完成的，如下面的代码块所示：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first example is the most robust one, as it uses both, the `isset` and `empty`
    functions. These functions are not the same, so it's important to understand what
    each of them does. The good thing about an `empty` function is that it will not
    trigger a notice if we try to pass it a variable that might not be set, such as `$_GET['name']`;
    it will simply return `true` or `false`. This makes the `empty` function a nice
    helper for most cases. However, even the fourth example, written via the use of
    the ternary operator, is somewhat robust.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例是最健壮的，因为它同时使用了`isset`和`empty`函数。这些函数并不相同，因此了解它们各自的功能是很重要的。`empty`函数的好处是，如果我们尝试传递一个可能未设置的变量给它，比如`$_GET['name']`，它不会触发通知，而是简单地返回`true`或`false`。这使得`empty`函数在大多数情况下都是一个不错的辅助工具。然而，即使是第四个示例，通过使用三元运算符编写，也是相当健壮的。
- en: 'PHP 7 introduced a new type of operator called the **null coalesce** (`??`)
    operator. It empowers us with the ability of writing shorter expressions. The
    following example demonstrates the elegance of its use:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7引入了一种新类型的运算符，称为**null coalesce**（`??`）运算符。它赋予我们编写更短表达式的能力。下面的示例演示了它的使用优雅之处：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It returns the result of its first operand if it exists and is not null, or
    else its second operand. In other words, reading it from left to right, the first
    existing value, which is not null, is the value that will be returned.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个操作数存在且不为null，则返回其结果，否则返回第二个操作数。换句话说，从左到右读取，将返回第一个存在且不为null的值。
- en: The spaceship operator
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 太空船操作符
- en: Comparing two values is a frequent operation in any programming language. We
    use various language operators to express the type of comparison we wish to execute
    between two variables. In PHP, these operators include equal (`$a == $b`), identical
    (`$a === $b`), not equal (`$a != $b` or `$a <> $b`), not identical (`$a !== $b`),
    less than (`$a < $b`), greater than (`$a > $b`), less than or equal to (`$a <=
    $b`), and greater than or equal to (`$a >= $b`) comparisons.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个值是任何编程语言中频繁的操作。我们使用各种语言运算符来表示我们希望在两个变量之间执行的比较类型。在PHP中，这些运算符包括相等（`$a == $b`），全等（`$a
    === $b`），不相等（`$a != $b`或`$a <> $b`），不全等（`$a !== $b`），小于（`$a < $b`），大于（`$a > $b`），小于或等于（`$a
    <= $b`），和大于或等于（`$a >= $b`）比较。
- en: All of these comparison operators result in Boolean `true` or `false`. Sometimes,
    however, there are cases where a three-way comparison is needed, in which case,
    the result of the comparison is more than just a Boolean `true` or `false`. While
    we can achieve a three-way comparison using various operators through various
    expressions, the solution is all but elegant.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些比较运算符的结果都是布尔值`true`或`false`。然而，有时候存在需要进行三路比较的情况，在这种情况下，比较的结果不仅仅是布尔值`true`或`false`。虽然我们可以通过各种表达式使用各种运算符来实现三路比较，但解决方案却并不优雅。
- en: 'With the release of PHP 7, a new spaceship `<=>` operator has been introduced,
    with a syntax as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 随着PHP 7的发布，引入了一个新的太空船`<=>`运算符，其语法如下：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The spaceship `<=>` operator offers combined comparison. After comparison,
    it follows these conditions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 太空船`<=>`运算符提供了组合比较。比较后，它遵循以下条件：
- en: It returns `0` if both operands are equal
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个操作数相等，则返回`0`
- en: It returns `1` if the left operand is greater
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果左操作数大，则返回`1`
- en: It returns `-1` if the right operand is greater
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果右操作数大，则返回`-1`
- en: 'Comparison rules used to yield the preceding results are the same as those
    used by existing comparison operators: `<`, `<=`, `==`, `>=`, and `>`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 用于产生上述结果的比较规则与现有比较运算符使用的规则相同：`<`、`<=`、`==`、`>=`和`>`。
- en: 'The usefulness of the new operator is especially apparent with ordering functions.
    Without it, the ordering functions were quite robust, as per the following example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 新运算符的实用性在排序函数中尤为明显。没有它，排序函数就会变得相当复杂，如下例所示：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can shorten the preceding example by applying the new operator to it, as
    follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过应用新的运算符来缩短上面的例子，如下所示：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Applying the spaceship `<=>` operator, where applicable, gives the expressions
    simplicity and elegance.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 应用太空船`<=>`运算符（如果适用）可以使表达式简洁而优雅。
- en: Constant arrays
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量数组
- en: There are two types of constants in PHP, the **constants** and the **class constants**.
    The constants can be defined pretty much anywhere using the define construct,
    while the `class` constants are defined within the individual class or interface
    using the `const` keyword.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中有两种常量，**常量**和**类常量**。常量可以在几乎任何地方使用定义构造定义，而`class`常量是使用`const`关键字在各个类或接口中定义的。
- en: While we cannot say that one type of constant is more important than the other,
    PHP 5.6 made the difference between the two by allowing class constants with the
    array data type. Aside from that difference, both types of constants supported
    scalar values (integer, float, string, Boolean, or null).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不能说一种常量类型比另一种更重要，但PHP 5.6通过允许具有数组数据类型的类常量来区分这两种类型。除了这种差异，这两种类型的常量都支持标量值（整数、浮点数、字符串、布尔值或null）。
- en: 'The PHP 7 release addressed this inequality by adding the array data type to
    constants as well, making the following into valid expressions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7发布通过将数组数据类型添加到常量中来解决了这种不平等，使以下表达式成为有效表达式：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Though having constants with the array data type might not be an exciting type
    of feature, it adds a certain flavor to the overall constant use.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管具有数组数据类型的常量可能不是一种令人兴奋的功能，但它为整体常量使用增添了一定的风味。
- en: Uniform variable syntax
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一变量语法
- en: The new variable syntax is probably one of the most impacting features of the
    PHP 7 release. It brings greater order into variable dereferencing. The impacting
    part, however, not only affects changes for better as it also introduces certain
    **backwards compatibility** (**BC**) breaks. Among the main reasons for these
    changes were inconsistencies with *variable variable* syntax.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 新的变量语法可能是PHP 7发布中最具影响力的功能之一。它为变量解引用带来了更大的秩序。然而，影响部分不仅对更好的变化产生影响，它还引入了某些**向后兼容性**（**BC**）破坏。这些变化的主要原因之一是与*变量变量*语法的不一致性。
- en: Observing the `$foo['bar']->baz` expression, first a variable named `$foo` is
    fetched, then the `bar` offset is taken from the result, and, finally, the `baz`
    property is accessed. This is how normally variable accesses is interpreted, from
    left to right. However, the *variable variable* syntax goes against this principle.
    Observing the `$$foo['baz']` variable, `$foo` is fetched first, then its `baz` offset,
    and finally looking for the variable with the name of the result is done.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 观察`$foo['bar']->baz`表达式，首先获取一个名为`$foo`的变量，然后从结果中取出`bar`偏移量，最后访问`baz`属性。这是正常的变量访问解释，从左到右。然而，*变量变量*语法违反了这个原则。观察`$$foo['baz']`变量，首先获取`$foo`，然后是它的`baz`偏移量，最后查找结果名称的变量。
- en: 'The newly introduced uniform variable syntax addresses these inconsistencies
    as per the following example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 新引入的统一变量语法解决了这些不一致性，如下例所示：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Other than addressing the preceding inconsistencies, several new syntax combinations
    have been added that make the following expressions now valid:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了解决上述的不一致性，还添加了几种新的语法组合，使以下表达式现在有效：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are quite a few different syntaxes here. While some of this might seem
    overwhelming and hard to find use for, it opens a door for new ways of thinking
    and code use.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多不同的语法。虽然其中一些可能看起来令人不知所措，难以找到用途，但它为新的思维方式和代码使用打开了一扇门。
- en: Throwables
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可抛出的
- en: The exceptions in PHP are not a new concept. They have been around ever since
    PHP 5 was released. However, they did not encompass all of PHP's error handling
    because errors were not considered to be exceptions. PHP, at the time, had two-error
    handling systems. This made it tricky to deal with, as traditional errors were
    not catchable via the `try...catch` blocks exceptions. Certain tricks were possible,
    where one could have used the `set_error_handler()` function in order to set a
    user-defined error handler function, basically listening for errors and turning
    them into exceptions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中的异常并不是一个新概念。自从PHP 5发布以来，它们一直存在。然而，它们并没有包括PHP所有的错误处理，因为错误并不被视为异常。当时的PHP有两种错误处理系统。这使得处理起来很棘手，因为传统错误无法通过`try...catch`块捕获异常。某些技巧是可能的，其中一个可以使用`set_error_handler()`函数来设置一个用户定义的错误处理程序函数，基本上监听错误并将其转换为异常。
- en: 'Let''s look at the following example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'PHP 5 would not be able to catch this, and instead throws `Catchable fatal
    error`, as shown here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 5将无法捕获这个错误，而是抛出`可捕获的致命错误`，如下所示：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'By adding the implementation of `set_error_handler()` before this code, as
    follows, we could turn that fatal error into an exception:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在此代码之前添加`set_error_handler()`的实现，我们可以将致命错误转换为异常：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With the preceding code in place, the `try...catch...finally` blocks would now
    kick in as intended. However, there were error types that could not be caught
    with `set_error_handler`, such as `E_ERROR`, `E_PARSE`, `E_CORE_ERROR`, `E_CORE_WARNING`,
    `E_COMPILE_ERROR`, `E_COMPILE_WARNING`, and most of `E_STRICT` raised in the file
    where `set_error_handler` is called.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上述代码，`try...catch...finally`块现在会按预期启动。然而，有一些错误类型无法通过`set_error_handler`捕获，例如`E_ERROR`、`E_PARSE`、`E_CORE_ERROR`、`E_CORE_WARNING`、`E_COMPILE_ERROR`、`E_COMPILE_WARNING`，以及在调用`set_error_handler`的文件中引发的大多数`E_STRICT`。
- en: The PHP 7 release improved the overall error handling system by introducing
    the `Throwable` interface, and moving the errors and exceptions under its umbrella.
    It is now the base interface for any object that can be thrown via a `throw` statement.
    While we cannot extend it directly, we can extend the `\Exception` and `\Error`
    classes. While `\Exception` is the base class for all PHP and user exceptions,
    `\Error` is the base class for all internal PHP errors.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7发布通过引入`Throwable`接口和将错误和异常移至其下，改进了整体的错误处理系统。它现在是通过`throw`语句抛出的任何对象的基本接口。虽然我们不能直接扩展它，但我们可以扩展`\Exception`和`\Error`类。`\Exception`是所有PHP和用户异常的基类，`\Error`是所有内部PHP错误的基类。
- en: 'We could now easily rewrite our preceding `try...catch...finally` block into
    one of the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以轻松地将我们之前的`try...catch...finally`块重写为以下之一：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice the use of `\Throwable` in the first example `catch` block. Even though
    we cannot extend it, we can use it as a shorthand for catching both `\Error` and
    `\Exception` in a single `catch` statement.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在第一个示例的`catch`块中使用了`\Throwable`。尽管我们不能扩展它，但我们可以将其用作在单个`catch`语句中捕获`\Error`和`\Exception`的简写。
- en: Implementation of `\Throwable` brings a much needed alignment between errors
    and exceptions, making them easier to reason with.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`\Throwable`带来了非常需要的错误和异常之间的对齐，使得它们更容易理解。
- en: Group use declarations
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组使用声明
- en: 'PHP introduced namespaces as part of the 5.3 release. It provided a way to
    group related classes, interfaces, functions, and constants, thus making our code
    base more organized and readable. However, dealing with modern libraries usually
    involves a lot of verbosity in terms of numerous `use` statements used to import
    classes from various namespaces, as shown in the following example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: PHP在5.3版本中引入了命名空间。它提供了一种将相关类、接口、函数和常量分组的方式，从而使我们的代码库更有组织和可读。然而，处理现代库通常涉及大量冗长的`use`语句，用于从各种命名空间导入类，如下例所示：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To address this verbosity, the PHP 7 release introduced the group use declarations,
    allowing the following syntax:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这种冗长，PHP 7发布引入了组使用声明，允许以下语法：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we condensed `Column` and `Extend` under a single declaration. We can
    further condense this using the following compound namespaces:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`Column`和`Extend`压缩到一个声明下。我们可以进一步使用以下复合命名空间来压缩这个：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The group use declarations act as a shorthand to condense `use` declarations,
    making it slightly easier to import classes, constants, and functions in a concise
    way. While their benefits seem somewhat marginal, their use is completely optional.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 组使用声明充当缩写，使得以简洁的方式导入类、常量和函数稍微更容易。尽管它们的好处似乎有些边缘，但它们的使用是完全可选的。
- en: Catching multiple exceptions types
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获多个异常类型
- en: With the introduction of throwables, PHP pretty much aligned its efforts around
    error detection, reporting, and handling. Developers are able to use the `try...catch...finally`
    blocks to handle the exceptions as they see fit. The possibility to use multiple
    `catch` blocks can give finer control over the response to certain types of exceptions.
    Sometimes, however, there are groups of exceptions we would like to respond equally.
    In PHP 7.1, exception handling was further refined to accommodate this challenge.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了可抛出对象后，PHP基本上围绕错误检测、报告和处理进行了调整。开发人员可以使用`try...catch...finally`块根据自己的意愿处理异常。使用多个`catch`块可以更好地控制对某些类型异常的响应。然而，有时我们希望对一组异常做出相同的响应。在PHP
    7.1中，异常处理进一步得到了改进以适应这一挑战。
- en: 'Let''s take a look at the following PHP 5.x example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下的PHP 5.x示例：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we are handling three exceptions, two of which are quite specific, and
    a third one that catches in if the previous two are not matched. The `finally`
    block is merely a cleanup, if it happens that one is needed. Imagine now that
    the same response is needed for both the `\InvalidArgumentException` and `\LengthException`
    blocks. The solution would be to either copy an entire chunk of code from one
    exception block into another, or, at best, write a function that wraps the response
    code and then calls that function within each exception block.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们处理了三种异常，其中两种异常非常具体，第三种异常是在前两种异常不匹配时捕获。`finally`块只是一个清理，如果需要的话。现在想象一下，对于`\InvalidArgumentException`和`\LengthException`块，需要相同的响应。解决方案要么是将一个异常块中的整个代码块复制到另一个异常块中，要么是最好的情况下编写一个包装响应代码的函数，然后在每个异常块中调用该函数。
- en: 'The newly added exception handling syntax is enabled to catch multiple exception
    types. By using a single vertical bar (`|`), we can define multiple exception
    types for the `catch` parameter, as per the following PHP 7.x example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 新增的异常处理语法可以捕获多个异常类型。通过使用单个竖线(`|`)，我们可以为`catch`参数定义多个异常类型，如下所示的PHP 7.x示例：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Aside from a touch of elegance, the new syntax directly affects code reuse for
    the better.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一丝优雅外，新的语法直接影响了代码重用的效果更好。
- en: Class constant visibility modifiers
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类常量可见性修饰符
- en: 'There are five types of access modifier in PHP: `public`, `private`, `protected`,
    `abstract`, and `final`. Often called **visibility modifiers**, not all of them
    are equally applicable. Their use is spread across classes, functions, and variables,
    as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中有五种访问修饰符：`public`、`private`、`protected`、`abstract`和`final`。通常称为**可见性修饰符**，它们并非都同样适用。它们的使用分布在类、函数和变量之间，如下所示：
- en: '**Functions**: `public`, `private`, `protected`, `abstract`, and `final`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**：`public`、`private`、`protected`、`abstract`和`final`'
- en: '**Classes**: `abstract` and `final`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：`abstract`和`final`'
- en: '**Variables**: `public`, `private`, and `protected`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**：`public`、`private`和`protected`'
- en: Class constants, however, are not on the list. The older versions of PHP did
    not allow a visibility modifier on the class constant. By default, class constants
    were merely assigned public visibility.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类常量不在此列表中。PHP的旧版本不允许在类常量上使用可见性修饰符。默认情况下，类常量仅被分配为公共可见性。
- en: 'The PHP 7.1 release addresses this limitation by introducing the `public`,
    `private`, and `protected` class constant visibility modifiers, as per the following
    example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7.1版本通过引入`public`、`private`和`protected`类常量可见性修饰符来解决了这个限制，如下例所示：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Similar to the old behavior, class constants declared without any explicit visibility
    default to `public.`
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与旧行为类似，没有明确可见性的类常量默认为`public`。
- en: Iterable pseudo-type
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可迭代伪类型
- en: Quite often, functions in PHP either accept or return an array or object implementing
    the `\Traversable` interface. Though both types can be used in the `foreach` constructs,
    fundamentally, an array is a primitive type; objects are not. This made it difficult
    for functions to reason about these types of iterative parameters and return values.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，函数通常接受或返回一个数组或实现`\Traversable`接口的对象。虽然这两种类型都可以在`foreach`结构中使用，但从根本上说，数组是一种原始类型；对象不是。这使得函数难以理解这些类型的迭代参数和返回值。
- en: PHP 7.1 addresses this need by introducing the iterable pseudo-type to the mix.
    The idea is to use it as a type declaration on a parameter or return type to indicate
    that the value is `iterable`. The `iterable` type accepts any array, any object
    implementing Traversable, and generators.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7.1通过引入可迭代伪类型来解决这个问题。其想法是在参数或返回类型上使用它作为类型声明，以指示该值是`iterable`。`iterable`类型接受任何数组，任何实现Traversable的对象和生成器。
- en: 'The following example demonstrates the use of `iterable` as a function parameter:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了将`iterable`用作函数参数的用法：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Trying to pass the value to the preceding `import` function other than an array
    instance of Traversable or generator will throw `\TypeError`. If, however, the
    default value is assigned, be it null or an empty array, the function will work.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将值传递给前面的`import`函数，而不是Traversable的数组实例或生成器，会抛出`\TypeError`。然而，如果分配了默认值，无论是null还是空数组，函数都会起作用。
- en: 'The following examples demonstrates the use of `iterable` as a function return
    value:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了将`iterable`用作函数返回值的用法：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: One thing to be careful about is that `iterable` is implemented as a reserved
    class name in PHP. What this means is that any user class, interface, or trait
    named `iterable` will throw an error.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，在PHP中，`iterable`被实现为一个保留的类名。这意味着任何名为`iterable`的用户类、接口或特性都会抛出错误。
- en: Nullable types
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可空类型
- en: Many programming languages allow some sort of optional or nullable types, depending
    on terminology. The PHP dynamic type already supports this notion via the built-in
    null type. A variable is considered to be of the null type if it has been assigned
    a constant value null, it has not been assigned any value, or it has been unset
    using the `unset()` construct. Aside from variables, the null type can also be
    used against the function parameters, by assigning them a default value of null.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言允许某种可选或可空类型，具体取决于术语。PHP动态类型已经通过内置的null类型支持了这个概念。如果变量被赋予了常量值null，它没有被赋予任何值，或者使用`unset()`构造函数取消了赋值，那么变量被认为是null类型。除了变量，null类型也可以用于函数参数，通过将它们赋予null的默认值。
- en: However, this imposed a certain limitation, as we could not declare a parameter
    that might be null without flagging it as optional at the same time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这带来了一定的限制，因为我们无法声明一个可能为null的参数，而不同时将其标记为可选。
- en: PHP 7.1 addressed this limitation by adding a leading question mark symbol (`?`)
    to indicate that a type can be null, unless specifically assigned to some other
    value. This also means that type could be null and mandatory at the same type.
    These nullable types are now permitted pretty much anywhere where type declarations
    are permitted.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7.1通过在类型前加上一个问号符号(`?`)来解决了这个限制，以指示类型可以为null，除非明确赋予其他值。这也意味着类型可以同时为null和必需。这些可空类型现在几乎可以在任何允许类型声明的地方使用。
- en: 'The following is an example of the nullable type with a mandatory parameter
    value:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是带有强制参数值的可空类型的示例：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first call to the `welcome` function throws an `\Error`, because its declaration
    is making the parameter mandatory. Goes to say that the nullable type should not
    be mistaken with `null` being passed as a value.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对`welcome`函数的第一次调用会抛出`\Error`，因为它的声明使参数成为了必需的。这说明可空类型不应该被误解为将`null`作为值传递。
- en: 'The following is an example of a nullable type with an optional parameter value,
    optional in the sense that it has been assigned a default value of `null` already:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个带有可选参数值的可空类型的示例，可选的意思是它已经被赋予了默认值`null`：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following is an example of function declaration using the nullable return
    type:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用可空返回类型声明函数的示例：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The nullable types work both with scalar types (Boolean, Integer, Float, String)
    and compound types (Array, Object, Callable).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 可空类型适用于标量类型（布尔值、整数、浮点数、字符串）和复合类型（数组、对象、可调用）。
- en: Void return types
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Void返回类型
- en: With all the power of function parameter types and function return types introduced
    in PHP 7, there was one thing missing from the `mix` function. While function
    return types allowed specifying a desired return type, they did not allow specifying
    the lack of return value. To address this inconsistency, the PHP 7.1 release introduced a
    `void` return type feature.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中引入的函数参数类型和函数返回类型的强大功能中，`mix`函数中缺少了一件事。虽然函数返回类型允许指定所需的返回类型，但它们不允许指定缺少返回值。为了解决这一不一致性，PHP
    7.1版本引入了`void`返回类型功能。
- en: Why is this important, we might ask ourselves? As with previously mentioned
    function return types, this feature can be extremely useful for documentation
    and error-checking purposes. By its nature, PHP does not require a `return` statement
    in its function definitions, making it unclear at first look if the function simply
    executes certain actions or returns a value. Using the `void` return type makes
    it clearer that a function's purpose is to perform an action, rather than producing
    a result.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很重要，我们可能会问自己？与前面提到的函数返回类型一样，这个特性对于文档和错误检查目的非常有用。由于PHP的性质，它在函数定义中不需要`return`语句，因此一开始不清楚函数是执行某些操作还是返回一个值。使用`void`返回类型使得函数的目的更清晰，即执行一个动作，而不是产生一个结果。
- en: 'Let''s take a look at the following example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `function A` and `function B` methods showcase a valid use of the `void`
    type parameter. The  `function A` method has no explicitly set return value, but
    that's OK, as PHP implicitly always returns `null.` The `function B` method simply
    uses the `return` statement without any following type, which also makes it valid.
    The `function C` method is a bit strange, as it looks like it might be valid at
    first, but it's not. How is it that `function C` is invalid while the `function
    A` method is, even though they do the same thing? Even though `return` and `return
    null` are technically equivalent in PHP, they are not really the same. The existence
    of a return type, or its lack, denotes a function intent. Specifying return values,
    even if its `null`, suggests the value is significant. With a void return type,
    the return value is insignificant. The use of the `void` return type, therefore,
    signifies an unimportant return value, the one that won’t be used anywhere after
    the function is called.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`function A`和`function B`方法展示了`void`类型参数的有效用法。`function A`方法没有明确设置返回值，但这没关系，因为PHP隐式地总是返回`null`。`function
    B`方法简单地使用了`return`语句，后面没有任何类型，这也是有效的。`function C`方法有点奇怪，乍看起来可能是有效的，但实际上不是。为什么`function
    C`无效，而`function A`方法却有效，即使它们做的事情是一样的？尽管在PHP中，`return`和`return null`在技术上是等价的，但它们并不完全相同。返回类型的存在或缺失表示了函数的意图。指定返回值，即使是`null`，都意味着这个值是重要的。对于void返回类型，返回值是无关紧要的。因此，使用`void`返回类型表示一个不重要的返回值，在函数调用后不会在任何地方使用。'
- en: The differentiation between explicit void and implicit null return might come
    as somewhat foggy. The takeaway here is that using void return types conveys that
    the function is not supposed to return any kind of value. While they do not make
    any major impact on the code itself, and their use is fully optional, they do
    bring a certain richness to the language.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 显式void和隐式null返回之间的区别可能有些模糊。这里的要点是，使用void返回类型传达了函数不应该返回任何类型的值。虽然它们对代码本身没有什么重大影响，它们的使用是完全可选的，但它们确实为语言带来了一定的丰富性。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The PHP 7 and 7.1 releases have introduced quite a few changes. Some of these
    changes transform the language beyond what PHP once was. While still pertaining
    the dynamic typing system, function parameters and return types can now be strictly
    defined. This changes the way we look and work with functions. Among function-related
    changes, there are several others targeting improvements over a decade old PHP
    5\. The ecosystem, as a whole, will take some time to catch up. For developers
    with experience in PHP 5, these changes are not merely technical in nature; they
    require change of mindset in order to successfully apply what is now possible.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7和7.1版本引入了许多变化。其中一些变化使语言超越了PHP曾经的样子。虽然仍然保持动态类型系统，但现在可以严格定义函数参数和返回类型。这改变了我们查看和处理函数的方式。在与函数相关的变化中，还有其他一些针对改进PHP
    5十多年历史的变化。整个生态系统需要一些时间来适应。对于有PHP 5经验的开发人员来说，这些变化不仅仅是技术上的，它们需要改变思维方式，以成功应用现在可能的东西。
- en: Moving forward, we will look into the current state of PHP standards, who defines
    them, what they describe, and how can we benefit from embracing them.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究PHP标准的当前状态，由谁定义它们，它们描述了什么，以及我们如何从中受益。
