- en: Chapter 5. Microservices Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 微服务开发
- en: In the last chapters, we explained how to install Docker, Composer, and Lumen,
    which will be necessary for each microservice. In this chapter, we will develop
    some parts of the *Finding secrets* application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后几章中，我们解释了如何安装Docker、Composer和Lumen，这对每个微服务都是必要的。在本章中，我们将开发*查找秘密*应用程序的一些部分。
- en: In this chapter, we will develop some of the more crucial parts, such as the
    routing, middleware, connection with a database, queues, and the communication
    between microservices of the Finding secrets application so that you will be able
    to develop the rest of the application in the future.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一些更关键的部分，例如路由、中间件、与数据库的连接、队列以及查找秘密应用程序的微服务之间的通信，这样您将能够在将来开发应用程序的其余部分。
- en: 'The structure of our application will have the following four microservices:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序结构将包括以下四个微服务：
- en: '**User:** It manages the registration and account actions. It is also responsible
    for storing and managing our secrets wallet.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**User:** 管理注册和账户操作。它还负责存储和管理我们的秘密钱包。'
- en: '**Secrets:** It generates random secrets around the world and also allows us
    to get information about each secret.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Secrets:** 在世界各地生成随机秘密，并允许我们获取有关每个秘密的信息。'
- en: '**Location**: It checks the closest secrets and users.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Location:** 检查最近的秘密和用户。'
- en: '**Battle:** It manages the battle between users. It also modifies the wallets
    to add and remove secrets after the battle.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Battle:** 管理用户之间的战斗。它还修改钱包以在战斗后添加和删除秘密。'
- en: Dependency management
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖管理
- en: Dependency management is a methodology that allows you to declare the libraries
    required for your project and makes it easier to install or update them. The most
    well-known tool for PHP is called **Composer**. In previous chapters, we gave
    a little overview about this tool.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖管理是一种方法论，允许您声明项目所需的库，并使其更容易安装或更新。PHP最知名的工具称为**Composer**。在之前的章节中，我们对这个工具进行了简要概述。
- en: For our project, we will need to use a single Composer setup for each microservice.
    When we installed Lumen, Composer did the work for us and created the configuration
    file, but now we will explain how it works in detail.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将需要为每个微服务使用单个Composer设置。当我们安装Lumen时，Composer为我们完成了工作并创建了配置文件，但现在我们将详细解释它是如何工作的。
- en: 'Once we have Docker installed and we are in the PHP-FPM container we want to
    work on, it is necessary to generate the `composer.json` file. This a configuration
    file for Composer where we define our project and all the dependencies:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了Docker并且我们在PHP-FPM容器中，我们需要工作，就需要生成`composer.json`文件。这是Composer的配置文件，我们在其中定义我们的项目和所有依赖项：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first 6 lines (name, description, keywords, license, and type) of the `composer.json` file
    are used to identify the project. It will be public if you share the project in
    any repository.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`composer.json`文件的前6行（名称、描述、关键字、许可证和类型）用于识别项目。如果您在任何存储库中分享项目，它将是公开的。'
- en: The `"require"` section defines the required libraries needed in our project
    and the version for each one. The `"require-dev"` is very similar, but they are
    the libraries that need to be installed on the development machines (for example,
    any test library).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`"require"`部分定义了项目中需要的必需库以及每个库的版本。`"require-dev"`非常类似，但它们是需要在开发机器上安装的库（例如，任何测试库）。'
- en: The `"autoload"` and `"autoload-dev"` define the way that our classes will be
    loaded and the folders to be mapped on the project for different uses.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`"autoload"`和`"autoload-dev"`定义了我们的类将如何加载以及要映射到项目的不同用途的文件夹。'
- en: 'Once we have this file created, we can execute the following command in our
    machine:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了这个文件后，我们可以在我们的机器上执行以下命令：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At this point, composer will check our settings, and it will download all the
    required libraries, including Lumen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Composer将检查我们的设置，并下载所有必需的库，包括Lumen。
- en: There are other tools out there, but they aren't used as much and they are less
    flexible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他工具，但它们没有被使用得那么多，也不够灵活。
- en: Routing
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: Routing is a mapping between the entry points of your application (requests)
    and a specific class and method in your source that executes your logic. For example,
    you can have defined in your application a mapping between the `/users` route
    and the method `list()` which is inside your `Users` class.  Once you have this
    mapping in place, as soon as your application receives a request for the route
    `/users`, it will execute all the logic you have inside the `list()` method (located
    in the `Users` class). Routing allows the API consumers to interact with your
    application. In microservices, the RESTful convention is the most used and we
    will follow it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是应用程序入口点（请求）和执行逻辑的源代码中的特定类和方法之间的映射。例如，您可以在应用程序中定义`/users`路由和`Users`类中的`list()`方法之间的映射。一旦您放置了这个映射，一旦您的应用程序收到对`/users`路由的请求，它将执行`Users`类中`list()`方法中的所有逻辑。路由允许API消费者与您的应用程序进行交互。在微服务中，最常用的是RESTful约定，我们将遵循它。
- en: '**HTTP Methods**:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP方法**：'
- en: '**GET:** It is used to retrieve information about a specified entity or collection
    of entities. The amount of data does not matter; we will use GET for one or many
    results, and also we can use filters in order to filter the results.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET:** 用于检索有关指定实体或实体集合的信息。数据量不重要；我们将使用GET来获取一个或多个结果，还可以使用过滤器来过滤结果。'
- en: '**POST:** It is used to enter information in the application. It is also used
    to send new information in order to create new things or send a message.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST:** 用于在应用程序中输入信息。它还用于发送新信息以创建新事物或发送消息。'
- en: '**PUT:** It is used to update an entire entity already stored in the application.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PUT:** 用于更新已存储在应用程序中的整个实体。'
- en: '**PATCH:** It is used to partially update an entity already stored in the application.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PATCH:** 用于部分更新已存储在应用程序中的实体。'
- en: '**DELETE:** It is used to remove an entity from the application.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE:** 用于从应用程序中删除实体。'
- en: 'The routes file in Lumen is located at `app/Http/routes.php`, so we will have
    one routes file for each microservice. For the `User` microservice, we will have
    the following endpoints:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen中的路由文件位于`app/Http/routes.php`，因此我们将为每个微服务有一个路由文件。对于`User`微服务，我们将有以下端点：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the earlier piece of code, we defined our routes for the `User` microservice.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为`User`微服务定义了我们的路由。
- en: In Lumen, the versioning for the API can be specified on the routes file by
    including `'prefix'`. This framework also allows us to have different API versions
    for the same microservice, so we do not need to modify an existing method to be
    used in a different version.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lumen中，API的版本可以在路由文件中通过包含'prefix'来指定。这个框架还允许我们为同一个微服务拥有不同的API版本，因此我们不需要修改现有的方法来在不同的版本中使用。
- en: 'The `''namespace''` defines the same namespace for all the methods included
    in the same group. The following lines define every entry point:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`''namespace''`为同一组中包含的所有方法定义了相同的命名空间。以下行定义了每个入口点：'
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For example, the preceding method is included in the group with the prefix `'api/v1'`;
    the verb is GET, and the entry point is `user/{id}`, so it could be retrieved
    executing an HTTP GET call to `http://localhost:8080/api/v1/user/123`. The `UserController@get` parameter
    defines where we need to develop the logic for this call--in this case, it is
    on the controller `UserController` and the method called `get`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，前面的方法包含在前缀为`'api/v1'`的组中；动词是GET，入口点是`user/{id}`，因此可以通过执行HTTP GET调用`http://localhost:8080/api/v1/user/123`来检索。`UserController@get`参数定义了我们需要在哪里开发此调用的逻辑--在这种情况下，它在控制器`UserController`和名为`get`的方法中。
- en: 'In Lumen, the standard folder to store all your controllers is `app/Http/Controllers`,
    so you only need to create the `app/Http/Controllers/UserController.php` file
    with your IDE with the following content:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lumen中，存储所有控制器的标准文件夹是`app/Http/Controllers`，因此您只需要使用IDE创建`app/Http/Controllers/UserController.php`文件，并包含以下内容：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code defined all the methods we have specified in our `app/Http/routes.php`
    file. For example, we return a simple JSON to test whether each route works fine.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码定义了我们在`app/Http/routes.php`文件中指定的所有方法。例如，我们返回一个简单的JSON来测试每个路由是否正常工作。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that the main language used in the communication between your microservices
    is JSON, so all our responses need to be in JSON.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，微服务之间通信使用的主要语言是JSON，因此我们所有的响应都需要是JSON格式。
- en: 'In Lumen, it is very easy to return a JSON response; you only need to use the
    `json()` method of the response instance, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lumen中，返回JSON响应非常容易；您只需要使用响应实例的`json()`方法，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the value stored in our `$id` variable is `123`, the preceding sentence
    will return a well-formed JSON response:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们`$id`变量中存储的值是`123`，则前面的句子将返回一个格式良好的JSON响应：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we have everything in place for our `User` microservice.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为我们的`User`微服务做好了一切准备。
- en: Perhaps, you are wondering what is the URI assigned to our `get()` method of
    the `User` microservice in our container environment. It is very easy to find
    it--simply open the `docker-compose.yml` file, and you can find the port mapping
    for the `microservice_user_nginx` container. The port mapping we have set up indicates
    that our localhost 8084 port will redirect the petitions to port 80 of the container.
    In summary, our URI will be `http://localhost:8084/api/v1/get/123`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，您想知道在我们的容器环境中，`User`微服务的`get()`方法分配了什么URI。找到它非常容易--只需打开`docker-compose.yml`文件，您就可以找到`microservice_user_nginx`容器的端口映射。我们设置的端口映射表明我们的本地主机8084端口将重定向请求到容器的80端口。总之，我们的URI将是`http://localhost:8084/api/v1/get/123`。
- en: Postman
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Postman
- en: Our application based on microservices will not have a frontend part; the goal
    of the API Rest is to create microservices that can be consumed by different platforms
    (Web, iOS, or Android) just by calling the available methods in the routes file;
    so in order to execute the calls to our microservices, we will use Postman. It
    is a tool that allows you to execute the different calls including the parameters
    you need. Using Postman, it is possible to save the methods to use them in the
    future.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基于微服务的应用程序将不会有前端部分；API Rest的目标是创建可以被不同平台（Web、iOS或Android）调用的微服务，只需调用路由文件中可用的方法；因此，为了执行对我们微服务的调用，我们将使用Postman。这是一个工具，允许您执行包括您需要的参数在内的不同调用。使用Postman，可以保存方法以便将来使用。
- en: 'You can download or install Postman from [https://www.getpostman.com](https://www.getpostman.com),
    as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://www.getpostman.com](https://www.getpostman.com)下载或安装Postman，如下所示：
- en: '![Postman](graphics/B06142_05_01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Postman](graphics/B06142_05_01.jpg)'
- en: Overview of the Postman tool
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Postman工具概述
- en: 'As you can see in the preceding Postman tool screenshot, it has many features,
    such as saving the requests or setting up different environments; but for now,
    we only need to know the basic functions to execute calls to our application,
    which are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的Postman工具截图中所看到的，它具有许多功能，比如保存请求或设置不同的环境；但是现在，我们只需要知道执行调用我们应用程序的基本功能，如下所示：
- en: Set the verb--GET, POST, PUT, PATCH, or DELETE. Some frameworks cannot reproduce
    PUT or PATCH calls, so you will need to set the verb POST instead, and include
    a parameter with key `_method` and value PUT or PATCH.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置动词--GET、POST、PUT、PATCH或DELETE。有些框架无法重现PUT或PATCH调用，因此您需要设置动词POST，并包含一个键为`_method`值为PUT或PATCH的参数。
- en: Set the request URL. It is the desired entry point for our application.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置请求URL。这是我们应用程序的期望入口点。
- en: Add more parameters, if necessary--for example, a parameter to filter results.
    For POST calls, the Body button will be enabled so that you can send parameters
    in the body request instead of the URL.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，添加更多参数--例如，用于过滤结果的参数。对于POST调用，Body按钮将被启用，以便您可以在请求正文中发送参数，而不是在URL中发送。
- en: Click on SEND to execute the call.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击发送以执行调用。
- en: The response will appear providing the status code and time in seconds.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应将显示状态代码和秒数。
- en: Middleware
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件
- en: As we explained in the previous chapters, middleware are very useful in applications
    based on microservices. Let's explain how you can use them using Lumen.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中所解释的，中间件在基于微服务的应用程序中非常有用。让我们解释一下如何使用它们使用Lumen。
- en: Lumen has a directory to place all the middleware, so we will create a middleware
    on the `User` microservice to check whether the consumer has the provided `API_KEY`
    to communicate with our application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen有一个目录用于放置所有的中间件，因此我们将在`User`微服务上创建一个中间件，以检查消费者是否具有提供的`API_KEY`以与我们的应用程序通信。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To identify our consumers, we recommend that you use an `API_KEY`. This practice
    will avoid unwelcome consumers using our application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别我们的消费者，我们建议您使用`API_KEY`。这种做法将避免不受欢迎的消费者使用我们的应用程序。
- en: 'Imagine that we provided our customer with an `API_KEY` with the value `RSAy430_a3eGR`,
    and it is necessary to send this value in every single request to our application.
    We can use a middleware to check whether this `API_KEY` was provided. Create a
    file called `App\Http\Middleware\ApiKeyMiddleware.php`, and place this piece of
    code in it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们向客户提供了一个值为`RSAy430_a3eGR`的`API_KEY`，并且在每个请求中都需要发送这个值。我们可以使用中间件来检查是否提供了这个`API_KEY`。创建一个名为`App\Http\Middleware\ApiKeyMiddleware.php`的文件，并将以下代码放入其中：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we have created our middleware, we have to add it to the application.
    To do this, include the following lines in the `bootstrap/app.php` file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了我们的中间件，我们必须将其添加到应用程序中。为此，请在`bootstrap/app.php`文件中包含以下行：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we can add the middleware to the `routes.php` file. It can be put in different
    places; you can put it in a single request or even in the entire group, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将中间件添加到`routes.php`文件中。它可以放在不同的地方；您可以将它放在单个请求中，甚至整个组中，如下所示：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Give it a try on Postman; make an HTTP POST call to `http://localhost:8084/api/v1/user`
    . You will see a message that says `API_KEY invalid`. Now make the same call but
    add a parameter called `API_KEY` with the value `RSAy430_a3eGR`; the request passes
    the middleware and arrives at the function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Postman上试试看；向`http://localhost:8084/api/v1/user`发出HTTP POST调用。您将看到一个消息，上面写着`API_KEY
    invalid`。现在做同样的调用，但添加一个名为`API_KEY`值为`RSAy430_a3eGR`的参数；请求通过中间件并到达函数。
- en: Implementing a microservice call
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现微服务调用
- en: Now that we know how to make a call, let's create a more complex example. We
    will build our battle system. As mentioned in the previous chapters, a battle
    is a fight between two players in order to get secrets from the loser. Our battle
    system will consist of three rounds, and in each round, there will be a dice throw;
    the user that wins the most rounds will be the winner and will get a secret from
    the loser's wallet.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道如何发出调用，让我们创建一个更复杂的例子。我们将构建我们的战斗系统。如前几章所述，战斗是两名玩家之间为了从失败者那里获取秘密而进行的战斗。我们的战斗系统将由三轮组成，在每一轮中都会进行一次掷骰子；赢得大多数轮次的用户将成为赢家，并从失败者的钱包中获得一个秘密。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We suggest using some testing development practices (TDD, BDD, or ATDD) as we
    explained before; you can see some examples in the preceding chapter. We will
    not include more tests in this chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用一些测试开发实践（TDD、BDD或ATDD），正如我们之前解释的那样；您可以在前面的章节中看到一些例子。在本章中，我们不会再包含更多的测试。
- en: 'In the Battle microservice, we can create a function for the battle in the
    `BattleController.php` file; let''s look at a valid structure method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Battle微服务中，我们可以在`BattleController.php`文件中创建一个用于战斗的函数；让我们看一个有效的结构方法：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Do not forget to add the endpoint on the `routes.php` file to link the URI
    to our method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`routes.php`文件中添加端点，将URI链接到我们的方法：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At this point, the `duel` method for the Battle microservice will be available;
    give it a try with Postman.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，Battle微服务的`duel`方法将可用；用Postman试试看。
- en: 'Now, we will implement the duel. We need to create a new class for the dice.
    To store a new class, we will create a new folder called `Algorithm` in the root,
    and the file `Dice.php` will include the dice methods:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现决斗。我们需要为骰子创建一个新的类。为了存储一个新的类，我们将在根目录下创建一个名为`Algorithm`的新文件夹，文件`Dice.php`将包含骰子方法：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once we have developed the `Dice` class, we will call it from the `BattleController`
    to see who wins a battle. The first thing is to include the `Dice` class on the
    `BattleController.php` file at the top, and then we can create an instance of
    the algorithm we will use for the duels (this is a good practice in order to change
    the duel system in the future; for example, if we want to use a duel based on
    energy points or card games, we would only need to change the `Dice` class for
    the new one).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开发了`Dice`类，我们将从`BattleController`中调用它，以查看谁赢得了战斗。首先要做的是在`BattleController.php`文件的顶部包含`Dice`类，然后我们可以创建一个我们将用于决斗的算法实例（这是一个很好的做法，以便在将来更改决斗系统；例如，如果我们想要使用基于能量点或卡牌游戏的决斗，我们只需要更改`Dice`类为新的类）。
- en: 'The duel function will return a JSON with the battle results. Please look at
    the new highlighted code included on the `BattleController.php`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`duel`函数将返回一个JSON，其中包含战斗结果。请查看`BattleController.php`中包含的新突出显示的代码：'
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Give it a try using Postman; remember that it is an HTTP POST request to the
    URI `http://localhost:8081/api/v1/battle/duel` (note that we set up the port 8081
    for the battle microservice on Docker), and it is necessary to send the parameters
    `userA` and `userB` with the usernames you want. If everything is correct, you
    should get a response similar to this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 试试使用Postman；记住这是一个HTTP POST请求到URI `http://localhost:8081/api/v1/battle/duel`（注意我们在Docker上设置了端口8081用于战斗微服务），并且需要发送参数`userA`和`userB`，其中包含您想要的用户名。如果一切正确，您应该会收到类似于这样的响应：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Request life cycle
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求生命周期
- en: 'The request life cycle is the map of a request until it is returned to the
    consumer as a response. It is interesting to understand this process in order
    to avoid issues during the request. Every framework has its own way of doing the
    request, but all of them are quite similar and follow some basic steps like Lumen
    does:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请求生命周期是请求被返回给消费者作为响应之前的地图。了解这个过程是很有趣的，以避免在请求过程中出现问题。每个框架都有自己的请求方式，但它们都非常相似，并遵循一些像Lumen一样的基本步骤：
- en: Every request is managed by `public/index.php`. It does not have much code,
    it just loads the Composer-generated autoloader definition and creates the instance
    of the application from `bootstrap/app.php`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个请求都由`public/index.php`管理。它没有太多的代码，只是加载由Composer生成的自动加载程序定义，并从`bootstrap/app.php`创建应用程序的实例。
- en: The request is sent to HTTP Kernel, which defines some necessary things such
    as error handling, logging, application environment, and other necessary tasks
    that should be added before the request is executed. HTTP Kernel also defines
    a list of middleware that the request must pass before retrieving the application.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求被发送到HTTP内核，它定义了一些必要的事情，比如错误处理、日志记录、应用环境和其他在请求执行之前应该添加的必要任务。HTTP内核还定义了请求在检索应用程序之前必须通过的中间件列表。
- en: Once the request passes the HTTP Kernel and arrives at the application, it reaches
    the routes and tries to match it with the correct one.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦请求通过了HTTP内核并到达应用程序，它就会到达路由并尝试将其与正确的路由匹配。
- en: It executes the controller and the code that correspond to the route and creates
    and returns a response object.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它执行控制器和对应路由的代码，并创建并返回一个响应对象。
- en: The HTTP headers and the response object content is returned to the client.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP头和响应对象内容被返回给客户端。
- en: This is just a basic example of the request-response workflow; the real process
    is more complex. You should take into account that the HTTP Kernel is like a big
    black box that does things that are not visible to the developer in a first instance,
    so understanding this example is enough for this chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是请求-响应工作流程的一个基本示例；真实的过程更加复杂。你应该考虑到HTTP内核就像一个大黑匣子，它做了一些对开发者来说并不可见的事情，所以理解这个例子对本章来说已经足够了。
- en: Communication between microservices with Guzzle
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Guzzle进行微服务之间的通信
- en: One of the most important things in microservices is the communication between
    them. Most of the time a single microservice doesn't have all the information
    requested by the consumer, so the microservice needs to call to a different microservice
    to get the desired data.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务中最重要的事情之一是它们之间的通信。大多数情况下，单个微服务并没有消费者所请求的所有信息，因此微服务需要调用不同的微服务来获取所需的数据。
- en: For example, adhering to the last example for the duel between two users, if
    we want to give all the information about the users included in the battle in
    the same call and we don't  have a specific method to get the user information
    in the Battle microservice, we can request the user information from the user
    microservice. To achieve this, we can use the PHP core feature cURL or use an
    external library that wraps cURL, giving an easier interface as `GuzzleHttp`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，遵循最后一个例子，对两个用户之间的决斗，如果我们想在同一个调用中提供有关战斗中包含的所有用户的信息，并且我们在Battle微服务中没有特定的方法来获取用户信息，我们可以从用户微服务中请求用户信息。为了实现这一点，我们可以使用PHP核心功能cURL，或者使用一个包装cURL的外部库，提供一个更简单的接口，比如`GuzzleHttp`。
- en: 'To include `GuzzleHttp` in our project, we only need to add the following line
    in the `composer.json` file of the Battle microservice:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的项目中包含`GuzzleHttp`，我们只需要在Battle微服务的`composer.json`文件中添加以下行：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once we save the changes, we can enter our PHP-FPM container and run the following
    command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们保存了更改，我们可以进入我们的PHP-FPM容器并运行以下命令：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`GuzzleHttp` will be installed and ready to use on the project.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`GuzzleHttp`将被安装并准备在项目中使用。'
- en: 'In order to get the user information from the `User` microservice, we will build
    a method that will give the information to the `Battle` microservice. For now,
    we will store the user information in a database, so we have an array to store
    it. In the `app/Http/Controllers/UserController.php` of the `User` microservice,
    we will add the following lines:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从`User`微服务中获取用户信息，我们将构建一个方法，将信息提供给`Battle`微服务。目前，我们将把用户信息存储在数据库中，所以我们有一个数组来存储它。在`User`微服务的`app/Http/Controllers/UserController.php`中，我们将添加以下行：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can test this new method on Postman by doing a GET call to `http://localhost:8084/api/v1/user/2`; you
    should get something like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在Postman上进行GET调用`http://localhost:8084/api/v1/user/2`来测试这种新方法；你应该会得到类似这样的东西：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once we know that the method to get the user information is working, we will call
    it from the `Battle` microservice. For security reasons, each container on Docker
    is isolated from the other containers, unless you specify that you want a connection
    in the links section of the `docker-composer.yml` file. To do so, use the following
    method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道获取用户信息的方法是有效的，我们将从`Battle`微服务中调用它。出于安全原因，Docker上的每个容器都与其他容器隔离，除非您在`docker-composer.yml`文件的链接部分指定要连接。要这样做，使用以下方法：
- en: 'Stop Docker containers:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止Docker容器：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Edit `docker-compose.yml` file by adding the following line:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加以下行来编辑`docker-compose.yml`文件：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Start Docker containers:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动Docker容器：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'From now on, the `Battle` microservice should be able to see the `User` microservice,
    so let''s call the `User` microservice in order to get the user information from
    the Battle microservice. To do this, we need to include the `GuzzleHttp\Client`
    in the `BattleController.php` file and create a Guzzle instance in the duel function
    to use it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，`Battle`微服务应该能够看到`User`微服务，所以让我们调用`User`微服务以获取来自Battle微服务的用户信息。为此，我们需要在`BattleController.php`文件中包含`GuzzleHttp\Client`，并在duel函数中创建一个Guzzle实例来使用它：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once we have finished the modifications, we can test it on Postman again by
    executing the same call as before--`http://localhost:8081/api/v1/battle/duel`
    (remember to make an HTTP POST call and send the parameters `userA` with value
    1 and `userB` with value 2). The response should be similar to this (note that
    this time the user information is coming from the `User` microservice, although
    we are calling the `Battle` microservice):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 修改完成后，我们可以通过在Postman上执行与之前相同的调用来再次测试它--`http://localhost:8081/api/v1/battle/duel`（记得进行HTTP
    POST调用，并发送参数`userA`值为1和`userB`值为2）。响应应该类似于这样（请注意，这次用户信息来自`User`微服务，尽管我们正在调用`Battle`微服务）：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Database operations
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库操作
- en: In the previous chapters, we explained that you can have single or multiple
    databases for your application. This is one of the advantages of microservices;
    you can scale a single microservice when you realize that it is getting a big
    load by dividing the database into a single database for a specific microservice.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们解释了您可以为应用程序拥有单个或多个数据库。这是微服务的优势之一；当您意识到某个微服务负载过大时，您可以将数据库分成单个数据库用于特定的微服务，从而实现单个微服务的扩展。
- en: For our example, we will create a single database for the secrets microservice.
    For storage software, we decided to use **Percona** (a MySQL fork), but feel free
    to use any database you like.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将为secrets微服务创建一个单独的数据库。对于存储软件，我们决定使用**Percona**（一个MySQL分支），但请随意使用您喜欢的任何数据库。
- en: 'To create a database container in Docker is very easy. We only need to edit
    our `docker-compose.yml` file, and change the links section of the `microservice_secret_fpm`
    service with the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker中创建数据库容器非常简单。我们只需要编辑我们的`docker-compose.yml`文件，并将`microservice_secret_fpm`服务的链接部分更改为以下内容：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the changes we did, we are telling Docker that now our `microservice_secret_fpm`
    can communicate with our `microservice_secret_database` container. Let’s create
    our database container. To do this, we only need to define the service in the
    `docker-compose.yml` file, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们所做的更改中，我们告诉Docker现在我们的`microservice_secret_fpm`可以与我们的`microservice_secret_database`容器进行通信。让我们创建我们的数据库容器。要做到这一点，我们只需要在`docker-compose.yml`文件中定义服务，如下所示：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we tell the application where Docker can find the `Dockerfile`
    where we set up some environment variables and also that we are mapping the port
    6666 of our machine to the default Percona port on the container. One important
    thing that you need to know about Docker and the Percona official image is that
    using some special environment variables, the container will create a database
    and some users for you.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们告诉应用程序Docker可以在哪里找到`Dockerfile`，我们在其中设置了一些环境变量，并且我们正在将我们机器的端口6666映射到容器上的默认Percona端口。关于Docker和Percona官方镜像的一个重要事项是，使用一些特殊的环境变量，容器将为您创建数据库和一些用户。
- en: You can find all the files you need in our Docker GitHub repository under the `chapter-05-basic-database` tag.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们的Docker GitHub存储库中找到所有所需的文件，标签为`chapter-05-basic-database`。
- en: Now that we have our container ready, it's time to set up our database. Lumen
    provides us with a tool to make migrations and manage them, so we can know if
    we have our database up to date if we are working with a team. A **migration**
    is a script to create and roll back operations in our database.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的容器准备就绪，是时候设置我们的数据库了。Lumen为我们提供了一个工具来进行迁移和管理迁移，因此我们可以知道我们的数据库是否是最新的，如果我们正在与团队合作。**迁移**是一个用于在我们的数据库中创建和回滚操作的脚本。
- en: 'To make a migration in Lumen, first you need to enter your secrets PHP-FPM container.
    To do this, you only need to open your terminal and execute the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Lumen中进行迁移，首先需要进入您的secrets PHP-FPM容器。要做到这一点，您只需要打开终端并执行以下命令：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The above command creates an interactive terminal in the container and runs
    the bash console so that you can start typing your commands. Please ensure that
    you are on the project root:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在容器中创建一个交互式终端，并运行bash控制台，以便您可以开始输入命令。请确保您在项目根目录下：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once you are on the project root, you need to create a migration; this can
    be done with the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在项目根目录下，您需要创建一个迁移；可以通过以下命令完成：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The above command will create an empty migration template in the `database/migrations/2016_11_09_200645_create_secrets_table.php`
    file, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在`database/migrations/2016_11_09_200645_create_secrets_table.php`文件中创建一个空的迁移模板，如下所示：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding piece of code is the sample generated by the artisan command.
    As you can see, there are two methods in the migration script. Everything you
    write inside the `up()` method will be used when a migration is executed. In the
    case of doing a rollback, everything inside the `down()` method will be used to
    undo your changes. Let''s fill our migration script with the following content:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段是由artisan命令生成的示例。如您所见，迁移脚本中有两种方法。在`up()`方法中编写的所有内容都将在执行迁移时使用。在执行回滚时，`down()`方法中的所有内容将用于撤消您的更改。让我们用以下内容填充我们的迁移脚本：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding sample is very easy to understand. In the `up()` method, we are
    creating a secrets table with some columns. It's a fast and easy way to create
    a table, which is similar to using a `CREATE TABLE` SQL statement. Our `down()`
    method will revert all our changes, and in our case, the way of reverting the
    changes is by removing the secrets table from our database.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例非常容易理解。在`up()`方法中，我们正在创建一个带有一些列的secrets表。这是创建表的一种快速简单的方法，类似于使用`CREATE TABLE`
    SQL语句。我们的`down()`方法将撤消所有更改，而在我们的情况下，撤消更改的方法是从我们的数据库中删除secrets表。
- en: 'Now, you are ready to execute the migration from your terminal with the following
    command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过以下命令从终端执行迁移：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The migrate command will run the `up()` method of our migration script and create
    our secrets table.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移命令将运行我们迁移脚本的`up()`方法并创建我们的secrets表。
- en: 'If you need to know the status of the execution of your migration scripts,
    you can perform a `php artisan migrate:status`, and the output will tell you the
    current status:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要了解迁移脚本的执行状态，您可以执行`php artisan migrate:status`，输出将告诉您当前状态：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: At this point, you can connect with your favorite database client to the 6666
    port of your machine; our database will be there, ready to be used in our application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可以连接到您的机器的6666端口，使用您喜欢的数据库客户端；我们的数据库已经准备好在我们的应用程序中使用。
- en: 'Imagine now that you need to do a rollback of the changes done to your database;
    it is very easy to do it in Lumen, you only need to run the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，您需要对数据库所做的更改进行回滚；在Lumen中很容易做到，您只需要运行以下命令：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once we have created the table, we can populate our table by doing seed on
    Lumen or manually. Our recommendation is that you use seeds, as this is an easy
    way to keep track of any changes. To populate our new table, we only need to create
    a new file `database/seeds/SecretsTableSeeder.php` with the following content:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了表，我们可以通过在Lumen上进行种子或手动填充我们的表。我们建议您使用种子，因为这是一种轻松跟踪任何更改的方法。要填充我们的新表，我们只需要创建一个新文件`database/seeds/SecretsTableSeeder.php`，其中包含以下内容：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding class, we defined a `run()` method, which will be executed
    every time we want to fill our database with some data. In our example, we added
    the different secrets we had hardcoded in our application. Now that we have our
    `SecretsTableSeeder` class ready, we need to edit the `database/seeds/DatabaseSeeder.php`
    to add a call to our custom seeder. If you change the `run()` method to match
    the following piece of code, your microservice will have some data:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类中，我们定义了一个`run()`方法，每当我们想要向数据库中填充一些数据时，它都会被执行。在我们的示例中，我们添加了我们在应用程序中硬编码的不同秘密。现在我们的`SecretsTableSeeder`类已经准备好了，我们需要编辑`database/seeds/DatabaseSeeder.php`，以调用我们的自定义seeder。如果您更改`run()`方法以匹配以下代码片段，您的微服务将具有一些数据：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once you have everything in place, it''s time to execute the seeder, so go
    to the secrets PHP-FPM container again and run the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一切就绪，现在是执行seeder的时候了，所以再次进入secrets PHP-FPM容器，并运行以下命令：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If `artisan` throws an error telling you that it can't find the table, it  is
    due to the composer autoloading system. Executing a `composer dump-autoload` will
    fix your problem, and you can run the `artisan` command again without any problems.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`artisan`抛出一个错误，告诉您找不到表，那是由于composer自动加载系统。执行`composer dump-autoload`将解决您的问题，然后您可以再次运行`artisan`命令而不会出现任何问题。
- en: At this point, you will have your secrets table created and populated with some
    example records.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您将创建并填充了您的秘密表，其中包含一些示例记录。
- en: Working with databases in Lumen is out of the box and uses Eloquent as an ORM.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lumen中使用数据库是开箱即用的，并使用Eloquent作为ORM。
- en: An **Object-Relational mapping** (**ORM**) is a programming model that transforms
    the database tables into entities that make the developer's work easier, allowing
    them to make basic queries faster and use less code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象关系映射**（**ORM**）是一种编程模型，它将数据库表转换为实体，使开发人员的工作更容易，使他们能够更快地进行基本查询并使用更少的代码。'
- en: 'We recommend using an ORM in order to avoid syntax problems if you want to
    migrate the database to a different system in the future. As you know, the SQL
    languages have few differences among them--for example, the way to get a determinate
    number of rows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议在将来要将数据库迁移到不同系统时使用ORM，以避免语法问题。正如您所知，SQL语言之间有一些差异--例如，获取确定数量的行的方式：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: So, if you use an ORM, you do not need to remember the SQL syntax, because it
    abstracts the developer from the database operations and the developer only needs
    to think about the development.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您使用ORM，您不需要记住SQL语法，因为它抽象了开发人员与数据库操作的关系，开发人员只需要考虑开发。
- en: 'The following are advantages of the ORM:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是ORM的优势：
- en: The security in the data access layer against attacks
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据访问层中的安全性防御攻击
- en: It is easy and fast to work with
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数据库一起工作很容易和快速
- en: It does not matter what database you use
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您使用的数据库并不重要
- en: Using an ORM is recommended when we are developing a public API in order to
    avoid security problems and make the queries easier and clearer for the rest of
    the team.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发公共API时，建议使用ORM，以避免安全问题，并使查询对团队的其他成员更容易和更清晰。
- en: 'To set up your Lumen project to work with Eloquent, you only need to open the
    `bootstrap/app.php` file and uncomment the following line (around line 28):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置您的Lumen项目与Eloquent一起工作，您只需要打开`bootstrap/app.php`文件，并取消注释以下行（大约在第28行附近）：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Also, you will need to set up the database parameters located in the `.env.example`
    file, you can find it in the root folder of each microservice. Once you finish
    editing the file, you need to rename it `.env` (removing `.example` from the file
    name):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您需要设置位于`.env.example`文件中的数据库参数，您可以在每个微服务的根文件夹中找到它。编辑文件完成后，您需要将其重命名为`.env`（从文件名中删除`.example`）：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, we are using the database, user, and password we set up in Docker
    in the beginning of the Database operations section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们在Docker中设置的数据库、用户名和密码在数据库操作部分的开始时已经设置好了。
- en: 'In order to work with our database, we need to create our models, and since
    we have a `finding_secrets` database, it makes sense to have a secret model in
    the `app/Models/Secret.php` file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们的数据库，我们需要创建我们的模型，因为我们有一个`finding_secrets`数据库，所以在`app/Models/Secret.php`文件中拥有一个秘密模型是有意义的：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding piece of code is very easy to understand; we only had to define
    the relationship between our model class and the database `$table` and the list
    of `$fillable` fields. This is the minimum you need for your model.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码非常容易理解；我们只需要定义我们的模型类和数据库`$table`之间的关系以及`$fillable`字段的列表。这是您的模型所需的最少内容。
- en: 'Fractal is a library that provides a presentation and transformation layer
    for our RESTful API. Using this library will keep our responses consistent, nice,
    and clean. To install this library, we only need to open the `composer.json` of
    our PHP-FPM containers, add `"league/fractal": "^0.14.0"` to the required list
    of elements and perform a `composer update`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fractal是一个为我们的RESTful API提供演示和转换层的库。使用这个库将使我们的响应保持一致，美观和干净。要安装这个库，我们只需要打开我们的PHP-FPM容器的`composer.json`，将`"league/fractal":
    "^0.14.0"`添加到所需元素的列表中，并执行`composer update`。'
- en: Tip
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Another way of installing fractal is by running the following command on your
    PHP-FMP terminal: `composer require league/fractal` . Note that this command will
    use the latest version and might not work with our examples.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 安装fractal的另一种方法是在您的PHP-FMP终端上运行以下命令：`composer require league/fractal`。请注意，此命令将使用最新版本，可能与我们的示例不兼容。
- en: 'With fractal installed, now it''s time to define our secret transformer. You
    can think about the transformers as an easy way of having the transformation from
    your model to a consistent response in one place. Create the `app/Transformers/SecretTransformer.php`
    file with your IDE  with the following content:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在安装了fractal，现在是时候定义我们的秘密转换器了。您可以将转换器视为一种简单的方式，将模型转换为一个一致的响应。在您的IDE中创建`app/Transformers/SecretTransformer.php`文件，并插入以下内容：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see from the preceding code, we are specifying the transformation
    of the secrets model, and because we want all the locations grouped, we added
    all the location information of the secret inside the location key. In the future,
    if you need to add new fields or modify the structure, now that everything is
    in one place, it will make your life as a developer easy.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中可以看出，我们正在指定秘密模型的转换，因为我们希望所有位置都被分组，所以我们在位置密钥内添加了秘密的所有位置信息。将来，如果您需要添加新字段或修改结构，现在一切都在一个地方，将会让作为开发人员的生活变得轻松。
- en: 'For our example purpose, we will modify the index method of our secrets controller
    to return a response from the database using fractal. Open your `app/Http/Controllers/SecretController.php`
    and insert the following uses:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了示例目的，我们将修改我们的secrets控制器的index方法，以使用fractal从数据库返回响应。打开您的`app/Http/Controllers/SecretController.php`并插入以下用法：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, you need to change the `index()`, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要更改`index()`如下：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Firstly, we added some object instances that we will need to the method signature,
    and thanks to the dependency injection built in Lumen, we don''t need to do any
    more work. They will be ready to use inside our method. The definition of our
    method does the following things:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在方法签名中添加了一些我们将需要的对象实例，由于Lumen内置了依赖注入，我们不需要做任何额外的工作。它们将准备好在我们的方法内使用。我们的方法定义了以下内容：
- en: Gets all the secret records from the database
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库获取所有秘密记录
- en: Creates a collection of secrets using our transformer
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们的转换器创建一个秘密集合
- en: The fractal library creates a data array from our collection
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fractal库从我们的集合创建一个数据数组
- en: Our controller returns our transformed collection as JSON
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的控制器将我们转换后的集合作为JSON返回
- en: 'If you give it a try with Postman, the response will be similar to this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Postman中尝试，响应将类似于这样：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: All our records are now returned from the database in a consistent way, all
    with the same structure inside our `"data"` response key.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的记录现在以一致的方式从数据库返回，所有都在我们的`"data"`响应键内具有相同的结构。
- en: Error handling
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: In the following section, we will explain how to validate the input data in
    our microservice and how to manage the possible errors. It is important to filter
    the request we are receiving--not only to notify the consumer that the request
    was not valid, but also to avoid security problems or parameters that we are not
    expecting.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将解释如何验证我们微服务中的输入数据以及如何处理可能的错误。过滤我们收到的请求非常重要，不仅是为了通知消费者请求无效，还要避免安全问题或我们不希望的参数。
- en: Validation
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证
- en: Lumen has a fantastic validation system, so we do not need to install anything
    to validate our data. Note that the following validation rules can be placed on
    the `routes.php` or on the controller inside every function. We will use it inside
    the function to be clearer.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen有一个很棒的验证系统，所以我们不需要安装任何东西来验证我们的数据。请注意，以下验证规则可以放在`routes.php`或控制器内的每个函数中。我们将在函数内使用它以更清晰地使用。
- en: 'To use our database for the validation system, we need to configure it. This
    is very simple; we just need to create a `config/database.php` file (and the folder)
    in our root with the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的数据库进行验证系统，我们需要对其进行配置。这非常简单；我们只需要在根目录中创建一个`config/database.php`文件（和文件夹），并插入以下代码：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, you have to add the database line in the `bootstrap/app.php` file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要在`bootstrap/app.php`文件中添加数据库行：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once you have done this, the Lumen validation system is ready. So, let''s write
    the rules to validate the POST method to create a new secret on the `Secrets`
    microservice:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，Lumen验证系统已准备就绪。因此，让我们编写规则来验证创建`Secrets`微服务上的新秘密的POST方法：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding code, we confirm that the parameters should pass the rules.
    The field `'name'` is required; it is a string, and also it should be unique in
    the `secrets` table. The field's `'latitude'` and `'longitude'` are numeric and
    required too. Also, the `'location_name'` field is required and it is a string.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们确认参数应该通过规则。字段`'name'`是必需的；它是一个字符串，而且在`secrets`表中应该是唯一的。字段`'latitude'`和`'longitude'`是数字且也是必需的。此外，`'location_name'`字段也是必需的，它是一个字符串。
- en: Tip
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In the Lumen documentation ([https://lumen.laravel.com/docs](https://lumen.laravel.com/docs)),
    you can check out all the available options to validate your inputs.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lumen文档中（[https://lumen.laravel.com/docs](https://lumen.laravel.com/docs)），您可以查看所有可用的选项来验证您的输入。
- en: 'You can try it out in your Postman; create a POST request with the following
    `application/json` parameters to check a failed insertion (note that you can also
    send it like form-data key values):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Postman中尝试它；创建一个带有以下`application/json`参数的POST请求来检查插入失败（请注意，您也可以像表单数据键值一样发送它）：
- en: '[PRE48]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding request will try to validate a new secret with the same name
    as other previous records. From our validation rules, we are not allowing the
    consumers to create new secrets with the same name, so our microservice will respond
    with a `422` error with the following body:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 上述请求将尝试验证一个与之前记录相同名称的新密钥。根据我们的验证规则，我们不允许消费者创建具有相同名称的新密钥，因此我们的微服务将以`422`错误响应，并返回以下内容：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that the status codes (or error codes) are very important to inform your
    consumers what happened with their requests; if everything is fine, it should
    respond with a `200` status code. Lumen returns a `200` status code by default.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，状态码（或错误码）对于通知您的消费者其请求发生了什么非常重要；如果一切正常，应该返回`200`状态码。Lumen默认返回`200`状态码。
- en: In [Chapter 11](ch11.html "Chapter 11. Best Practices and Conventions"), *Best
    Practices and Conventions*, we will see a full list of all the available codes
    that you can use in your application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](ch11.html "第11章。最佳实践和约定")*最佳实践和约定*中，我们将看到您可以在应用程序中使用的所有可用代码的完整列表。
- en: 'Once the validation rules pass, we should save the data on the database. This
    is very simple in Lumen, just do this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦验证规则通过，我们应该将数据保存在数据库中。这在Lumen中非常简单，只需这样做：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: After this, we will have our new record available in the database. Lumen provides
    other methods to create for other tasks such as fill, update, or delete.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们将在数据库中获得我们的新记录。Lumen提供了其他方法来创建其他任务，如填充、更新或删除。
- en: Manage exceptions
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理异常
- en: It is necessary to know that we have to manage the possible errors that happen
    in our application. To do this, Lumen provides us with a list of exceptions that
    can be used.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要知道，我们必须管理应用程序中发生的可能错误。为此，Lumen为我们提供了可以使用的异常列表。
- en: So, now we will try to get an exception when trying to call another microservice.
    To do this, we will call the secret microservice from the user microservice.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们将尝试在尝试调用另一个微服务时获得异常。为此，我们将从用户微服务调用密钥微服务。
- en: 'Please remember that for security reasons if you didn''t link a container with
    another container, they can''t see each other. Edit your `docker-compose.yml`
    and add the link from the `microservice_user_fpm` to the `microservice_secret_nginx`,
    as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，出于安全原因，如果您没有将一个容器与另一个容器链接起来，它们就无法相互看到。编辑您的`docker-compose.yml`，并从`microservice_user_fpm`到`microservice_secret_nginx`添加链接，如下所示：
- en: '[PRE51]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, you should start your containers again:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该再次启动您的容器：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Also, remember that we need to install `GuzzleHttp` as we did before on the
    `Battle` microservice and on the `User` microservice in order to call the `Secret`
    microservice.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，我们需要像之前在`Battle`微服务和`User`微服务上一样安装`GuzzleHttp`，以便调用`Secret`微服务。
- en: We will create a new function on the `User` microservice to show the secrets
    kept in a `user` wallet.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`User`微服务中创建一个新的函数，以显示`user`钱包中保存的秘密。
- en: 'Add this to `app/Http/routes.php`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将此添加到`app/Http/routes.php`：
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, we will create the method to get a secret from the `user` wallet--for
    example, look at this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个从`user`钱包中获取秘密的方法--例如，看一下这个：
- en: '[PRE54]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We are calling the `Secret` microservice, but we will modify the URI in order
    to get a `ConnectException`, so please modify it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在调用`Secret`微服务，但我们将修改URI以获得`ConnectException`，所以请修改它：
- en: '[PRE55]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Give it a try on Postman; you will receive a `ConnectException` error.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在Postman上试一试；您将收到一个`ConnectException`错误。
- en: 'Now, set the URI correctly again and put some wrong code on the secret microservice
    side:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次正确设置URI，并在密钥微服务端放入一些错误代码：
- en: '[PRE56]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The preceding code will return an error **500** for the secret microservice;
    but we are calling it from the `User` microservice, so now we will receive a `ServerException`
    error.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将为密钥微服务返回错误**500**；但我们是从`User`微服务调用它，所以现在我们将收到`ServerException`错误。
- en: 'There are hundreds of kinds of errors that you can manage in your microservice
    by catching them. In Lumen, all the exceptions are handled by the `Handler` class
    (located at `app/Exceptions/Handler.php`). This class has two defined methods:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lumen中，通过捕获它们来处理所有异常的类是`Handler`类（位于`app/Exceptions/Handler.php`）。这个类有两个定义的方法：
- en: '`report()`: This allows us to send our exceptions to external services--for
    example, a centralized logging system.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`report()`: 这允许我们将异常发送到外部服务--例如，一个集中的日志系统。'
- en: '`render()`: This transforms our exception into an HTTP response.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render()`: 这将我们的异常转换为HTTP响应。'
- en: 'We will be updating the `render()` method to return custom error messages and
    error codes. Imagine that we want to catch a Guzzle `ConnectException` and return
    a more friendly and easy-to-manage error. Take a look at the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新`render()`方法以返回自定义错误消息和错误码。想象一下，我们想捕获Guzzle的`ConnectException`并返回一个更友好和易于管理的错误。看一下以下代码：
- en: '[PRE57]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we are detecting the Guzzle `ConnectException` and giving a custom error
    message and code. Using this strategy helps us to know what is failing and allows
    us to act according to the error we are dealing with. For example, we can assign
    the code `123` to all our connection errors; so, when we detect this issue, we
    can avoid a cascade failure in other services or notify the developer.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在检测Guzzle的`ConnectException`并提供自定义的错误消息和代码。使用这种策略有助于我们知道哪里出了问题，并允许我们根据我们正在处理的错误采取行动。例如，我们可以将代码`123`分配给所有连接错误；因此，当我们检测到这个问题时，我们可以避免其他服务的级联故障或通知开发人员。
- en: Async and queue
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步和队列
- en: In microservices, the queues are one of the most important things that help
    increase the performance and reduce the execution time.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务中，队列是帮助提高性能和减少执行时间的最重要的事情之一。
- en: For instance, if you have to send an e-mail to a customer when the customer
    finishes the registration process of your application, the application does not
    need to send it at that moment; it can be put in a queue to be sent a few seconds
    later when the server is not as busy. Also, it is async because the customer does
    not need to wait for the e-mail. The application will display the message *Registration
    finished* and the e-mail will be put in the queue and processed at the same time.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您需要在客户完成应用程序的注册流程时向客户发送电子邮件，应用程序不需要立即发送它；它可以放入队列中，在服务器不太忙的时候几秒钟后发送。此外，它是异步的，因为客户不需要等待电子邮件。应用程序将显示消息*注册完成*，并且电子邮件将被放入队列并同时处理。
- en: Another example is when you need to do very heavy workloads, so you can have
    a dedicated machine with better hardware to do the tasks.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是当您需要处理非常繁重的工作负载时，您可以有一台专用的硬件更好的机器来执行这些任务。
- en: One of the most well-known in-memory data structure stores is **Redis**. You
    can use it as a database, a cache layer, as a message broker, or even as a queue
    storage. One of the key points of Redis is its support for different structure
    types, such as strings, hashes, lists, and sorted sets among others. This software
    was designed to be easy to manage and to have a high performance and, for these
    reasons, it is a de facto standard in the Web industry.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的内存数据结构存储之一是**Redis**。您可以将其用作数据库、缓存层、消息代理，甚至作为队列存储。Redis的关键点之一是它支持不同的结构类型，例如字符串、哈希、列表和有序集等。这个软件被设计成易于管理和具有高性能，因此它是Web行业的事实标准。
- en: One of the main uses of Redis is as a cache storage. You can store your data
    forever or add an expiration time,  without having to worry about how and when
    you need to remove the data; Redis will do it for you. Due to the easy use, great
    support and libraries available, Redis fits any project of any scale.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Redis的主要用途之一是作为缓存存储。您可以永久存储数据，也可以添加过期时间，而无需担心何时需要删除数据；Redis会为您完成。由于易用性、良好的支持和可用的库，Redis适用于任何规模的项目。
- en: We will build an example on the `User` microservice to send e-mails using a
    queue built on top of Redis.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`User`微服务上构建一个示例，使用基于Redis的队列发送电子邮件。
- en: Lumen provides us with a queue system using the database; but there are other
    options available using external services. In our example, we will use Redis,
    so let's see the steps to install it on Docker.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen为我们提供了使用数据库的队列系统；但也有其他选项可用，可以使用外部服务。在我们的示例中，我们将使用Redis，因此让我们看看如何在Docker上安装它。
- en: 'Open the `docker-compose.yml` and add the following container description:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`docker-compose.yml`并添加以下容器描述：
- en: '[PRE58]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You also need to update the links section of the `microservice_user_fpm` container
    to match the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要更新`microservice_user_fpm`容器的链接部分以匹配以下内容：
- en: '[PRE59]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the preceding pieces of code, we defined a new container for Redis, and
    we linked it to the `microservice_user_fpm` container. Now open the `microservices/user/redis/Dockerfile`
    file and add the following code to have the latest Redis version available:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们为Redis定义了一个新的容器，并将其链接到`microservice_user_fpm`容器。现在打开`microservices/user/redis/Dockerfile`文件，并添加以下代码以使最新的Redis版本可用：
- en: '[PRE60]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To use Redis in our Lumen project, we need to install a few dependencies through
    composer. So, open your `composer.json` and add the following lines to the required
    section and do a composer update inside the user PHP-FPM container:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的Lumen项目中使用Redis，我们需要通过composer安装一些依赖项。因此，打开您的`composer.json`，并将以下行添加到所需部分，然后在用户PHP-FPM容器内执行composer
    update：
- en: '[PRE61]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'For email support, you only need to add the following line to the require section
    of your composer.json file:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于电子邮件支持，您只需要将以下行添加到composer.json文件的require部分：
- en: '[PRE62]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Once Redis is installed, we need to set up the environment. Firstly, we need
    to add the following lines on the `.env` file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完Redis后，我们需要设置环境。首先，我们需要在`.env`文件中添加以下行：
- en: '[PRE63]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, we need to add the Redis configuration on the `config/database.php` file;
    if you have any other databases added (for example, MySQL), put this after that,
    but inside the return array:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在`config/database.php`文件中添加Redis配置；如果您添加了其他数据库（例如MySQL），请将其放在那之后，但在返回数组内部：
- en: '[PRE64]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Also, it is necessary to copy the `vendor/laravel/lumen-framework/config/queue.php`
    file to `config/queue.php`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要将`vendor/laravel/lumen-framework/config/queue.php`文件复制到`config/queue.php`。
- en: 'Finally, do not forget to register everything on the `bootstrap/app.php` file
    and add the following lines, so our application is able to read the configuration
    we just set up:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不要忘记在`bootstrap/app.php`文件上注册所有内容，并添加以下行，这样我们的应用程序就能够读取我们刚刚设置的配置了：
- en: '[PRE65]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: So now, we will explain how to build a queue in our `User` microservice. Imagine
    that in the application, when new users are created, we want to give them the
    first secret as a gift; so after the user creation, we will call the secret microservice
    in order to get the first secret for the user. This is not a priority, so that
    is the reason why we will use a queue to do this task.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将解释如何在我们的`User`微服务中构建一个队列。想象一下，在应用程序中，当创建新用户时，我们希望将第一个秘密作为礼物赠送给他们；因此，在用户创建之后，我们将调用秘密微服务以获取用户的第一个秘密。这不是一个优先级很高的任务，这就是为什么我们将使用队列来执行此任务的原因。
- en: 'Create a new file on `app/Jobs/GiftJob.php` with the following code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`app/Jobs/GiftJob.php`，其中包含以下代码：
- en: '[PRE66]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You can modify the class construction to pass data to your job, for example,
    an object instance with all the user information.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以修改类构造函数以向作业传递数据，例如，包含所有用户信息的对象实例。
- en: 'Now, we need to instance the job from our `app/Http/Controllers/UserController.php`
    controller:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要从我们的`app/Http/Controllers/UserController.php`控制器实例化作业：
- en: '[PRE67]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Once the queue job is done, we have to start the queue worker in the background.
    The following code will do the work for you, and it will keep running until the
    thread dies, you can add a supervisor to ensure that the queue continues working:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦队列任务完成，我们必须在后台启动队列工作程序。以下代码将为您完成这项工作，并且它将一直运行直到线程死亡，您可以添加一个监督程序来确保队列继续工作：
- en: '[PRE68]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You can give this a try on Postman by calling `http://localhost:8084/api/v1/user`.
    Once you call this, Lumen will put the work on Redis, and it will be available
    for the queue worker. Once the worker gets and processes the task from Redis,
    you will see the following next message in the terminal:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用`http://localhost:8084/api/v1/user`在Postman上尝试一下。一旦您调用此方法，Lumen将把工作放在Redis上，并且它将可供队列工作者使用。一旦工作者从Redis获取并处理任务，您将在终端中看到以下下一个消息：
- en: '[PRE69]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Lumen provides us with more possibilities for the queues. For example, you can
    set priorities for the queue, specify a time-out for a job or even set a delay
    for the task. You can find this information in the Lumen documentation.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen为我们提供了更多的队列可能性。例如，您可以为队列设置优先级，为作业指定超时，甚至为任务设置延迟。您可以在Lumen文档中找到这些信息。
- en: Caching
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: Many times consumers request the same things, and the application returns the
    same information. In this scenario, caching is the solution to avoid constantly
    processing the same request and returning the required data faster.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，消费者请求相同的内容，应用程序返回相同的信息。在这种情况下，缓存是避免不断处理相同请求并更快地返回所需数据的解决方案。
- en: 'Caching is used for data that does not change frequently in order to have a
    precalculated response without processing the request. The workflow is as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存用于不经常更改的数据，以便在不处理请求的情况下获得预先计算的响应。工作流程如下：
- en: The first time that the consumer requests some information, the application
    processes the request and gets the required data.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消费者第一次请求某些信息时，应用程序会处理请求并获取所需的数据。
- en: It saves the required data for that request in the cache with an expiration
    time that we define.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将请求所需的数据保存在缓存中，并设置我们定义的过期时间。
- en: It returns the data to the consumer.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将数据返回给消费者。
- en: 'Next time that a consumer requests something you need to do the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下一次消费者请求某些内容时，您需要执行以下操作：
- en: Check whether the request is in the application cache and it has not expired.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查请求是否在应用程序缓存中，并且尚未过期。
- en: Return the data located in the cache.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回缓存中的数据。
- en: So, in our example, we will use caching in the location microservice in order
    to avoid requesting the closest secrets multiple times.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的示例中，我们将在位置微服务中使用缓存，以避免多次请求最接近的秘密。
- en: 'The first thing that we need to use a cache layer for in our application is
    a container with Redis (you can find other cache software out there, but we decided
    to use Redis as it is very easy to install and use). Open the `docker-compose.yml`
    file and add the new container definition, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中需要使用缓存层的第一件事是具有一个带有Redis的容器（您可以在其他地方找到其他缓存软件，但我们决定使用Redis，因为它非常容易安装和使用）。打开`docker-compose.yml`文件，并添加新的容器定义，如下所示：
- en: '[PRE70]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Once we add the container, you need to update the links section for the `microservice_location_fpm`
    definition to connect to our new Redis container as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了容器，您需要更新`microservice_location_fpm`定义的链接部分，以连接到我们的新Redis容器，如下所示：
- en: '[PRE71]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In this case, our `docker/microservices/location/redis/Dockerfile` file will
    only contain the following (feel free to add more things to the container if you
    want):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的`docker/microservices/location/redis/Dockerfile`文件将只包含以下内容（如果需要，可以随意向容器添加更多内容）：
- en: '[PRE72]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Do not forget to execute `docker-compose stop` to successfully kill all the
    containers and start them again with our changes with a `docker-compose up -d`.
    You can check whether the new container is running by executing `docker ps` in
    your terminal.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记执行`docker-compose stop`以成功终止所有容器，并使用`docker-compose up -d`再次启动它们以应用我们的更改。您可以通过在终端中执行`docker
    ps`来检查新容器是否正在运行。
- en: 'Now is time to make some changes in the source of our location microservice
    to use our new cache layer. The first change we need to make is on the `composer.json`;
    add the following required libraries to the `"require"` section:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候对我们的位置微服务源代码进行一些更改，以使用我们的新缓存层。我们需要做的第一个更改是在`composer.json`中；将以下所需的库添加到`"require"`部分：
- en: '[PRE73]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Once you make the changes to the `composer.json` file, remember to do a composer
    update to get the libraries.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您对`composer.json`文件进行更改，请记得执行`composer update`以获取库。
- en: 'Now, open the location microservice `.env` file to add the Redis setup, as
    follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开位置微服务的`.env`文件，添加Redis设置，如下所示：
- en: '[PRE74]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Since our environment variables are now set up, we need to create the `config/database.php`
    with the following content:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的环境变量现在已设置好，我们需要创建`config/database.php`，内容如下：
- en: '[PRE75]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the preceding code, we defined how to connect to our Redis container.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们定义了如何连接到我们的Redis容器。
- en: Lumen comes without the cache configuration, so you can copy the `vendor/laravel/lumen-framework/config/cache.php`
    file into `config/cache.php`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen没有缓存配置，因此您可以将`vendor/laravel/lumen-framework/config/cache.php`文件复制到`config/cache.php`中。
- en: 'We will need to make some small adjustments to our `bootstrap/app.php`--uncomment
    `$app->withFacades();` and add the following lines:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对`bootstrap/app.php`进行一些小的调整--取消注释`$app->withFacades();`并添加以下行：
- en: '[PRE76]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We will change our `getClosestSecrets()` method to use cache instead of calculating
    the closest secrets every time. Open the `app/Http/Controllers/LocationController.php`
    file and add the required use for cache:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更改我们的`getClosestSecrets()`方法，以使用缓存而不是每次计算最接近的秘密。打开`app/Http/Controllers/LocationController.php`文件，并添加缓存所需的使用：
- en: '[PRE77]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In the preceding code, we changed the implementation of the method by adding
    the layer cache; so instead of always calculating the closest points, we first
    check on our cache with `remember()`. If nothing is returned from the cache, we
    make the calculation and store the result.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们通过添加缓存层改变了方法的实现；因此，我们首先使用`remember()`检查我们的缓存，而不是总是计算最接近的点。如果缓存中没有返回任何内容，我们进行计算并存储结果。
- en: Another option for saving data in Lumen cache is to use `Cache::put('key', 'value',
    $expirationTime);` where the `$expirationTime` can be the time in minutes (integer)
    or a date object.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lumen缓存中保存数据的另一个选项是使用`Cache::put('key', 'value', $expirationTime);`，其中`$expirationTime`可以是以分钟为单位的时间（整数）或日期对象。
- en: Tip
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The key is defined by you, so a good practice is generating a key that you can
    remember in order to regenerate in the future. In our example, we defined the
    key using `L` (for location) and then the `latitude` and `longitude`. However,
    if you are going to save an ID, it should be included as part of the key.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥由您定义，因此一个好的做法是生成一个您可以记住的密钥，以便将来重新生成。在我们的示例中，我们使用`L`（表示位置），然后是`纬度`和`经度`来定义密钥。然而，如果您要保存一个ID，它应该作为密钥的一部分包含在内。
- en: Working with our cache layer is easy in Lumen.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lumen中，与我们的缓存层一起工作很容易。
- en: 'To obtain elements from the cache, you can use `"get"`. It allows two parameters--the
    first one is to specify the key you want (and is required), and the second one
    is the value to use if the key is not stored in cache (and obviously is optional):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要从缓存中获取元素，可以使用`"get"`。它允许两个参数--第一个是指定您想要的密钥（必需的），第二个是在缓存中未存储密钥时要使用的值（显然是可选的）：
- en: '[PRE78]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: A similar method to store data available is `Cache::forever($cacheKey, $cacheValue);`
    this call will store the `$cacheValue` identified by `$cacheKey` in our cache
    layer, forever, until you delete or update it.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 存储数据的类似方法是`Cache::forever($cacheKey, $cacheValue);`，这个调用将永久地将$cacheValue存储在我们的缓存层中，直到您删除或更新它。
- en: If you don't specify the expiration time for your stored elements, it is important
    to know how to remove them. In Lumen, you can do it with `Cache::forget($cacheKey);`
    if you know the `$cacheKey` assigned to an element. In the case of needing to
    remove all the elements stored in the cache, we can do this with a simple `Cache::flush();`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有为存储的元素指定过期时间，那么了解如何删除它们就很重要。在Lumen中，如果您知道分配给元素的$cacheKey，可以使用`Cache::forget($cacheKey);`来删除它。如果需要删除缓存中存储的所有元素，可以使用简单的`Cache::flush();`来实现。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned how to develop the different parts of an application
    based on microservices. Now, you have the required knowledge to deal with database
    storage, cache, communication between microservices, queues, and the request workflow
    from the point of entry to the application (routes) and the validation of the
    data until the time it is given to the consumer. In the next chapter, you will
    learn how to monitor your application in order to avoid and fix issues that happen during
    the application execution process.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了如何开发基于微服务的应用程序的不同部分。现在，您已经具备了处理数据库存储、缓存、微服务之间的通信、队列以及从入口点到应用程序（路由）的请求工作流程以及数据验证的必要知识，直到将数据提供给消费者的时间。在下一章中，您将学习如何监控您的应用程序，以避免和解决应用程序执行过程中发生的问题。
