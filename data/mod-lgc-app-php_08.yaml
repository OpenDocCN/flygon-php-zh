- en: Chapter 8. Extract SQL statements to Gateways
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。将SQL语句提取到网关
- en: 'Now that we have moved all our class-oriented functionality to a central directory
    location (and have a reasonable test suite for those classes) we can begin extracting
    more logic from our page scripts and place that logic into classes. This will
    have two benefits: first, we will be able to keep the various concerns of the
    application separated; second, we will be able to test the extracted logic so
    that any breaks will be easy to notice before we deploy into production.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有基于类的功能移动到一个中央目录位置（并且对这些类有一个合理的测试套件），我们可以开始从我们的页面脚本中提取更多的逻辑并将该逻辑放入类中。这将有两个好处：首先，我们将能够保持应用程序的各种关注点分开；其次，我们将能够测试提取的逻辑，以便在部署到生产环境之前很容易注意到任何故障。
- en: The first of these extractions will be to move all SQL-oriented code to its
    own set of classes. For our purposes, SQL is a stand-in for any system of reading
    from and writing to a data store. This may be a no-SQL system, a CSV file, a remote
    resource, or anything else. We will concentrate on SQL-oriented data stores in
    this chapter because they are so common throughout legacy applications, but the
    principles apply to any form of data storage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些提取中的第一个将是将所有与SQL相关的代码移动到自己的一组类中。对于我们的目的，SQL是任何读取和写入数据存储系统的代名词。这可能是一个无SQL系统，一个CSV文件，一个远程资源或其他任何东西。我们将在本章集中讨论SQL导向的数据存储，因为它们在遗留应用程序中是如此普遍，但这些原则适用于任何形式的数据存储。
- en: Embedded SQL Statements
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式SQL语句
- en: 'Right now, our page scripts (and probably some of our classes) interact with
    a database directly with embedded SQL statements. For example, a page script might
    have some logic like this:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的页面脚本（可能还有一些我们的类）直接与数据库交互，使用嵌入式SQL语句。例如，一个页面脚本可能有一些类似以下的逻辑：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The problems with using embedded SQL strings are numerous. Among other things,
    we want to:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌入式SQL字符串的问题很多。除其他事项外，我们希望：
- en: Test the SQL interactions in isolation from the rest of the code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在与代码的其余部分隔离的情况下测试SQL交互
- en: Reduce the number of repeated SQL strings throughout the codebase
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少代码库中重复的SQL字符串数量
- en: Collect related SQL commands for generalization and reuse
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集相关的SQL命令以进行概括和重用
- en: Isolate and remove security flaws such as SQL injection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离并消除诸如SQL注入之类的安全漏洞
- en: These problems and more lead us to the conclusion that we need to extract all
    our SQL-related code to an SQL layer, and replace the embedded SQL logic with
    calls to our SQL-related class methods. We will do this by creating a series of
    `Gateway` classes. The only thing these `Gateway` classes will do is get data
    from, and send data back to, our data sources.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题和更多问题使我们得出结论，我们需要将所有与SQL相关的代码提取到一个SQL层，并用对我们的SQL相关类方法的调用替换嵌入式SQL逻辑。我们将通过创建一系列“网关”类来实现这一点。这些“网关”类唯一要做的事情就是从我们的数据源获取数据，并将数据发送回去。
- en: The `Gateway` classes in this chapter are technically more like table data gateways.
    However, you may choose to set up any kind of `Gateway` that is appropriate for
    your data source.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的“网关”类在技术上更像是表数据网关。然而，您可以选择设置适合您数据源的任何类型的“网关”。
- en: The extraction process
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取过程
- en: 'In general, this is the process we will follow:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，这是我们将要遵循的过程：
- en: Search the entire codebase for SQL statements.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索整个代码库以查找SQL语句。
- en: For each statement not already in a `Gateway`, move the statement and relevant
    logic to a related `Gateway` class method.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个尚未在“网关”中的语句，将语句和相关逻辑移动到相关的“网关”类方法中。
- en: Write a test for the new `Gateway` method.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新的“网关”方法编写测试。
- en: Replace the statement and relevant logic in the original file with a call to
    the `Gateway` class method.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用“网关”类方法的调用替换原始文件中的语句和相关逻辑。
- en: Test, commit, push, and notify QA.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试、提交、推送并通知QA。
- en: Repeat with the next SQL statement that is outside a `Gateway` class.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复上述步骤，直到下一个SQL语句不在“网关”类之外。
- en: Search for SQL statements
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索SQL语句
- en: 'As in previous chapters, we employ a project-wide search function here. Use
    a regular expression like the following to identify where SQL statement keywords
    are located in the codebase:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，在这里我们使用项目范围的搜索功能。使用类似以下的正则表达式来识别代码库中SQL语句关键字的位置：
- en: 'Search for:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We may find that our codebase uses other SQL commands as well. If so, we should
    include them in the search expression.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会发现我们的代码库还使用其他SQL命令。如果是这样，我们应该将它们包括在搜索表达式中。
- en: It will be easier on us if the codebase consistently uses only one case, whether
    upper or lower, for SQL keywords. However, this is not always the convention in
    legacy code. If our codebase is inconsistent regarding the case for SQL keywords,
    and our project-wide search facility has a case-insensitive option, we should
    use that option in this search. Otherwise, we need to expand the search terms
    to include lower-case (and perhaps mixed-case) variations of the SQL keywords.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码库在SQL关键字的大小写方面不一致，对我们来说更容易的是代码库始终只使用一个大小写，无论是大写还是小写。然而，这在遗留代码中并不总是约定俗成的。如果我们的代码库在SQL关键字的大小写方面不一致，并且我们的项目范围搜索工具有不区分大小写的选项，我们应该在这次搜索中使用该选项。否则，我们需要扩展搜索项，以包括SQL关键字的小写（也许是混合大小写）变体。
- en: Finally, the search results are likely to include false positives. For example,
    narrative text such as "Select one of the following options" will be in the result
    list. We will need to examine the results individually to determine if they are
    SQL statements or only narrative text.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，搜索结果可能会包括误报。例如，叙述文本如“选择以下选项之一”将出现在结果列表中。我们需要逐个检查结果，以确定它们是否是SQL语句还是仅仅是叙述文本。
- en: Move SQL to a Gateway class
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将SQL移动到网关类
- en: The task of extracting the SQL to a `Gateway` is detail-oriented and context-specific.
    The structure of the legacy codebase itself will determine one or more correct
    approaches to this task.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将SQL提取到“网关”的任务是细节导向的，具体情况具体分析。遗留代码库本身的结构将决定这项任务的一个或多个正确方法。
- en: 'To begin with, extracting a plain old SQL statement like the following seems
    straightforward:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，提取一个普通的SQL语句如下似乎很简单：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But it turns out we need to make a lot of decisions even with this simple example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但事实证明，即使在这个简单的例子中，我们也需要做出很多决定：
- en: What should we name the `Gateway` class and method?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该如何命名`Gateway`类和方法？
- en: How should we deal with parameters to the query?
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该如何处理查询的参数？
- en: How do we avoid security flaws?
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何避免安全漏洞？
- en: What is the proper return value?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当的返回值是什么？
- en: Namespace and Class names
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间和类名
- en: To determine our namespace and class names, the first thing we need to decide
    is whether to organize by layer or by entity.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定我们的命名空间和类名，我们需要首先决定是按层还是按实体进行组织。
- en: If we organize by implementation layers, the top-level namespaces for our class
    might be `Gateway` or `DataSource\Gateway`. This naming arrangement structures
    the classes by their operational purpose in the codebase.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们按照实现层进行组织，我们类的顶层命名空间可能是`Gateway`或`DataSource\Gateway`。这种命名安排将根据代码库中的操作目的来结构化类。
- en: If we organize by domain entities, the top-level namespaces would be something
    like `Comments`, or even `Domain\Comments`. This naming arrangement structures
    the classes by their purpose within the business logic domain.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们按领域实体进行组织，顶层命名空间可能是`Comments`，甚至是`Domain\Comments`。这种命名安排将根据业务逻辑领域内的目的来结构化类。
- en: The legacy codebase is likely to dictate which way to go. If there is code already
    organized by one or the other, then it might be better to continue in the established
    structure rather than redoing the existing work. We want to avoid setting up conflicting
    or inconsistent organizational structures in the codebase.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留的代码库很可能会决定前进的方向。如果已经有按照某种方式组织的代码，那么最好继续使用已建立的结构，而不是重新做现有的工作。我们希望避免在代码库中设置冲突或不一致的组织结构。
- en: Of the two, I recommend organizing by domain entities. I find it more sensible
    to collect functionality related to specific domain entity types within their
    relevant namespaces, than to spread operational implementations across several
    namespaces. We can also further segregate the implementation pieces within the
    specific domain feature in a way that is not easily done when organizing by layer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两者之间，我建议按领域实体进行组织。我认为将与特定领域实体类型相关的功能集中在其相关的命名空间内更有意义，而不是将操作实现分散在几个命名空间中。我们还可以在特定领域功能内进一步分隔实现部分，这在按层进行组织时不容易做到。
- en: To reflect my domain entity bias, the examples in the rest of this chapter will
    be structured along domain lines, not implementation layers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了反映我的领域实体偏见，本章其余部分的示例将按照领域的方式进行结构化，而不是按照实现层进行结构化。
- en: Once we have an organizing principle for our `Gateway` classes, we can easily
    find good class names. For example, our comments-related `Gateway` in PHP 5.3
    and later might be named `Domain\Comments\CommentsGateway`. If we are using PHP
    5.2 or earlier, we will need to avoid namespaces proper and use underscores in
    the class name instead; e.g., `Domain_Comments_CommentsGateway`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为我们的`Gateway`类确定了一个组织原则，我们就可以很容易地找到好的类名。例如，我们在PHP 5.3及更高版本中与评论相关的`Gateway`可能被命名为`Domain\Comments\CommentsGateway`。如果我们使用的是PHP
    5.2或更早版本，我们将需要避免使用正确的命名空间，并在类名中使用下划线；例如，`Domain_Comments_CommentsGateway`。
- en: Method names
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法名
- en: Choosing an appropriate method name, however, is a little more difficult. Once
    again, we should look to the existing legacy codebase for a convention. The common
    idiom may be to `get()` the data, `find()` the data, `fetch()` the data, `select()`
    the data, or something else entirely.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，选择适当的方法名可能会更加困难。再次，我们应该寻找现有遗留代码库中的惯例。常见的习语可能是`get()`数据，`find()`数据，`fetch()`数据，`select()`数据，或者完全不同的其他内容。
- en: We should stick with any existing naming convention as much as possible. While
    the method name itself does not matter, consistency-of-naming does. Consistency
    will make it easier for us to look at calls to the `Gateway` object and understand
    what is happening without having to read the underlying method code, and to search
    the codebase for data-access calls.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该尽可能坚持任何现有的命名约定。虽然方法名本身并不重要，但命名的一致性很重要。一致性将使我们更容易查看对`Gateway`对象的调用，并理解发生了什么，而无需阅读底层方法代码，并在代码库中搜索数据访问调用。
- en: If our legacy codebase does not reveal a consistent pattern, it is up to us
    to choose a consistent naming convention for the new `Gateway` methods. Because
    the `Gateway` classes are supposed to be a simple layer to wrap SQL calls, the
    examples in this chapter will use method names like `select`, `insert`, etc. to
    identify the behavior being wrapped.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的遗留代码库没有显示出一致的模式，那么我们就需要为新的`Gateway`方法选择一致的命名约定。因为`Gateway`类应该是一个简单的层，用于包装SQL调用，本章的示例将使用诸如`select`、`insert`等方法名来标识被包装的行为。
- en: Finally, the method name should probably indicate the kind of `select()` being
    performed. Are we selecting one record or or all of them? Are we selecting by
    specific criteria? Are there other considerations on the query? These and other
    questions will give us hints on how to name the `Gateway` methods.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，方法名可能应该指示正在执行的`select()`的类型。我们是选择一个记录还是所有记录？我们是按特定标准选择？查询中还有其他考虑吗？这些和其他问题将给我们一些提示，告诉我们如何命名`Gateway`方法。
- en: An initial Gateway class method
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个初始的Gateway类方法
- en: 'When extracting logic to a class method, we should be careful to follow all
    the lessons we learned about dependency injection in prior chapters. Among other
    things, this means: no use of globals, replacing superglobals with a `Request`
    object, no use of the `new` keyword outside `Factory` classes, and (of course)
    injecting objects via the constructor as needed.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在将逻辑提取到类方法时，我们应该小心遵循我们在之前章节中学到的关于依赖注入的所有教训。除其他事项外，这意味着：不使用全局变量，用`Request`对象替换超全局变量，不在`Factory`类之外使用`new`关键字，以及（当然）根据需要通过构造函数注入对象。
- en: 'Given the above naming principles, and the original `SELECT` statement to retrieve
    comment rows, we may build a `Gateway` that looks something like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述命名原则和原始的`SELECT`语句来检索评论行，我们可以构建一个类似于这样的`Gateway`：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is practically an exact copy of the logic from the original page script.
    It leaves at least one major issue in place, though: it uses the input parameter
    directly in the query. This leaves us open to SQL injection attacks.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是原始页面脚本的逻辑的几乎完全复制。但是，它至少留下了一个主要问题：它直接在查询中使用输入参数。这使我们容易受到SQL注入攻击。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**What Is SQL Injection**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是SQL注入**'
- en: The classic XKCD comic regarding Little Bobby Tables should help to illustrate
    the problem. The input parameter being used directly in a database query is maliciously
    formed to change the query so that it damages or otherwise exploits the database.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 关于小鲍比表的经典XKCD漫画应该有助于说明问题。恶意形成的输入参数直接用于数据库查询，以更改查询，从而损害或利用数据库。
- en: Defeating SQL Injection
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 击败SQL注入
- en: When we create our `Gateway` methods, we should never assume the parameter values
    are safe. It doesn't matter if we expect the parameters to be hard-coded to constant
    values on every call, or otherwise guaranteed to be safe. At some point, someone
    is going to change a bit of code that calls the `Gateway` method and we will have
    a security issue. Instead, we need to treat every parameter value as unsafe, and
    deal with it accordingly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建我们的`Gateway`方法时，我们不应假设参数值是安全的。无论我们是否期望参数在每次调用时都被硬编码为常量值，或者以其他方式保证是安全的。在某个时候，有人会更改调用`Gateway`方法的代码的一部分，我们将会有安全问题。相反，我们需要将每个参数值视为不安全，并相应处理。
- en: 'Thus, to defeat SQL injection attempts, we should do one of three things with
    every query in our `Gateway` methods (indeed, in any SQL statement anywhere in
    the codebase):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了击败SQL注入尝试，我们应该在我们的`Gateway`方法中执行每个查询的三件事中的一件（实际上，在代码库中的任何SQL语句中）：
- en: The best solution is to use prepared statements and parameter binding instead
    of query string interpolation.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最好的解决方案是使用准备语句和参数绑定，而不是查询字符串插值。
- en: The second-best solution is to use the database layer's "quote-and-escape" mechanism
    on each parameter before interpolating it into the query string.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二好的解决方案是在将其插入查询字符串之前，对每个参数使用数据库层的“引用和转义”机制。
- en: The third-best solution is to escape each of the input parameters before interpolating
    them into the query string.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三好的解决方案是在将其插入查询字符串之前转义每个输入参数。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Alternatively, we can avoid the problem of strings entirely by casting expected
    numeric values to `int` or `float`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过将预期的数值转换为`int`或`float`来完全避免字符串的问题。
- en: 'Let''s examine the third-best solution first, since it is more likely to already
    be present in our legacy codebase. We use the database''s `escape` functionality
    to escape each parameter before we use it in a query string, and quote it appropriately
    for the database. Thus, we can rewrite the `selectAllByPostId()` method like so,
    assuming a MySQL database:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先检查第三好的解决方案，因为它更有可能已经存在于我们的遗留代码库中。我们使用数据库的`escape`功能来转义每个参数，然后在查询字符串中使用它，并为数据库适当地引用它。因此，我们可以像这样重写`selectAllByPostId()`方法，假设使用MySQL数据库：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Escaping values for interpolation into strings is a third-best solution for
    several reasons. The main one is that the escaping logic is sometimes insufficient.
    Something like `mysql_escape_string()` function is simply not good enough for
    our purposes here. Even the `mysql_real_escape_string()` method has a flaw that
    will allow attackers to succeed at SQL injection attempts depending on the current
    character set. However, this may be the only option available to the underlying
    database driver.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对值进行转义以插入字符串是第三好的解决方案，原因有几个。主要原因是转义逻辑有时不够。像`mysql_escape_string()`函数对我们的目的来说根本不够好。甚至`mysql_real_escape_string()`方法也有一个缺陷，这将允许攻击者根据当前字符集成功进行SQL注入尝试。然而，这可能是底层数据库驱动程序可用的唯一选项。
- en: The second-best solution is a variation of escaping called quote-and-escape.
    This feature, available only via the `PDO::quote()` method, is safer than escaping
    because it additionally wraps the value in quotes and deals with the proper character
    set automatically. This avoids the character set mismatch issues inherent to just
    escaping and adding quotes on our own.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第二好的解决方案是一种称为引用和转义的转义的变体。这个功能只能通过`PDO::quote()`方法使用，比转义更安全，因为它还会自动将值包装在引号中，并处理适当的字符集。这避免了仅仅转义和自己添加引号时固有的字符集不匹配问题。
- en: 'A rewritten `selectAllByPostId()` method might look like this with a `Db` object
    that exposes the `PDO::quote()` method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重写的`selectAllByPostId()`方法可能看起来像这样，使用暴露`PDO::quote()`方法的`Db`对象：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a safe approach when we remember to use it. The issue here, of course,
    is that if we add a parameter to the method, we may forget to quote it, and then
    we are vulnerable to SQL injection again.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们记得使用它时，这是一种安全的方法。当然，问题在于，如果我们向方法添加参数，可能会忘记引用它，然后我们又容易受到SQL注入攻击。
- en: 'Finally, the best solution: prepared statements and parameter binding. These
    are only available via PDO (which works with almost all databases) and the `mysqli`
    extension. Each has its own variations on how to handle statement preparation.
    We will use `PDO` style examples here.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最好的解决方案：准备语句和参数绑定。这些只能通过PDO（几乎适用于所有数据库）和`mysqli`扩展使用。每个都有自己的处理语句准备的变体。我们将在这里使用`PDO`样式的示例。
- en: Instead of interpolating values into query strings, we use named placeholders
    to indicate where parameters should be placed in a query string. We then tell
    `PDO` to prepare the string as a `PDOStatement` object, and bind values to the
    named placeholders when we execute the query through that prepared statement.
    `PDO` automatically uses safe representations of the parameter values, making
    us secure against SQL injection attacks.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用命名占位符而不是将值插入查询字符串，以指示参数应放置在查询字符串中的位置。然后，我们告诉`PDO`将字符串准备为`PDOStatement`对象，并在通过准备的语句执行查询时将值绑定到命名占位符。`PDO`自动使用参数值的安全表示，使我们免受SQL注入攻击。
- en: 'Here is an example of what a rewrite would look like using a `Db` object that
    exposes the `PDO` statement preparation logic and execution:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用公开`PDO`语句准备逻辑和执行的`Db`对象进行重写的示例：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The great benefit here is that we never use the parameter variables in the query
    string. We always and only use named placeholders, and bind the placeholders to
    the parameter values into the prepared statement. This idiom makes it clear when
    we are improperly using interpolated variables, and `PDO` automatically complains
    if there are extra or missing bound values, so the chances of accidentally making
    an insecure change are greatly reduced.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的巨大好处是我们从不在查询字符串中使用参数变量。我们总是只使用命名占位符，并将占位符绑定到准备好的语句中的参数值。这种习惯用法使我们清楚地知道何时不正确地使用了插入的变量，而且`PDO`会自动投诉如果有额外或缺少的绑定值，因此意外进行不安全的更改的机会大大减少了。
- en: Write a test
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写一个测试
- en: Now it is time to write a test for our new class method. The test we write at
    this point is going to be less perfect than we would like because we need to interact
    with the database. However, an imperfect test is better than no test. As *The
    Way Of Testivus* tells us, we write the test we can at the time we can.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为我们的新类方法编写测试了。我们此时编写的测试可能不够完美，因为我们需要与数据库交互。然而，一个不完美的测试总比没有测试好。正如《测试之道》所告诉我们的，我们在能够的时候编写测试。
- en: 'The test for our new `Gateway` method might look something like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新“Gateway”方法的测试可能看起来像这样：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we run our test suite to see if the test passes. If it does, we rejoice
    and move on! If it does not, we continue to refine the `Gateway` method and the
    related test until both are working properly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行我们的测试套件，看看测试是否通过。如果通过，我们会庆祝并继续前进！如果没有通过，我们将继续完善`Gateway`方法和相关测试，直到两者都正常工作。
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Perfecting Our Tests**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**完善我们的测试**'
- en: As noted earlier, this is very much an imperfect test. Among other things, it
    depends on a working database connection, and on having data seeded into the database
    in the first place. By depending on the database, we are dependent on it being
    in a correct state. If the database does not have the correct data in it, then
    the test will fail. The failure will come not from the code, which is what we
    are testing, but from the database, which is mostly beyond our control. One opportunity
    for improving the test is to change the `Gateway` class to depend on a `DbInterface`
    instead of a concrete `Db` class. We would then create a `FakeDb` class for testing
    purposes that implements the `DbInterface`, and inject a `FakeDb` instance into
    the `Gateway` instead of a real `Db` instance. Doing so would give us greater
    insight into the correctness of the SQL query string along with greater control
    over the the data being returned to the `Gateway`. Above all, it would decouple
    the test from its dependency on a working database. For now, in the interest of
    expediency, we will use the imperfect test.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，这是一个非常不完美的测试。除其他事项外，它取决于一个可用的数据库连接，并且首先需要在数据库中种子数据。通过依赖数据库，我们依赖它处于正确的状态。如果数据库中没有正确的数据，那么测试将失败。失败不是来自我们正在测试的代码，而是来自大部分超出我们控制的数据库。改进测试的一个机会是将`Gateway`类更改为依赖于`DbInterface`而不是具体的`Db`类。然后，我们将为测试目的创建一个实现`DbInterface`的`FakeDb`类，并将一个`FakeDb`实例注入到`Gateway`中，而不是一个真正的`Db`实例。这样做将使我们更深入地了解SQL查询字符串的正确性，以及对返回给`Gateway`的数据具有更大的控制。最重要的是，它将使测试与对可用数据库的依赖解耦。目前，出于迅速进行的考虑，我们将使用不完美的测试。
- en: Replace the original code
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换原始代码
- en: 'Now that we have a working and tested `Gateway` method, we replace the original
    code with a call to the `Gateway`. Whereas the old code looked like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可工作且经过测试的“Gateway”方法，我们用调用“Gateway”方法替换原始代码。而旧代码看起来像这样：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The new version would look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本将如下所示：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that we have done little to modify the operational logic. For example,
    we have not added error checking that was not previously present. The furthest
    extent of our modification has been to secure the query against SQL injection
    via prepared statements.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们几乎没有修改操作逻辑。例如，我们没有添加以前不存在的错误检查。我们修改的最远程度是通过准备好的语句来保护查询免受SQL注入。
- en: Test, Commit, Push, Notify QA
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试，提交，推送，通知QA
- en: As in previous chapters, we now need to spot check the legacy application. Although
    we have a unit test for the new `Gateway` method, we still need to spot check
    the part of the application we have modified. If we prepared a characterization
    test earlier that covers this part of our legacy application, we can run that
    now. Otherwise, we can do this by browsing to or otherwise invoking the changed
    part of the application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的章节一样，现在我们需要抽查旧应用程序。虽然我们对新的“Gateway”方法有一个单元测试，但我们仍然需要抽查我们修改过的应用程序的部分。如果我们之前准备了一个表征测试来覆盖我们遗留应用程序的这一部分，我们现在可以运行它。否则，我们可以通过浏览或以其他方式调用应用程序的更改部分来进行此操作。
- en: Once we are satisfied that we have successfully replaced the embedded SQL with
    a call to our new `Gateway` method, we commit the changes, including our tests,
    to revision control. We then push to the central repository and notify the QA
    team of our changes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确信已成功用调用我们的新“Gateway”方法替换了嵌入式SQL，我们就将更改提交到版本控制，包括我们的测试。然后我们推送到中央仓库，并通知QA团队我们的更改。
- en: Do ... While
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 做...直到
- en: With that complete, we search the codebase again for uses of SQL keywords to
    indicate embedded query strings. Where they exist outside of a `Gateway` class,
    we continue extracting the queries to an appropriate `Gateway`. Once all the SQL
    statements have been moved to `Gateway` classes, we're done.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们再次搜索代码库，查找SQL关键字以指示嵌入式查询字符串的用法。如果它们存在于`Gateway`类之外，我们将继续将查询提取到适当的`Gateway`中。一旦所有SQL语句都已移动到`Gateway`类中，我们就完成了。
- en: Common Questions
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见问题
- en: What about INSERT, UPDATE, and DELETE Statements?
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 那么插入、更新和删除语句呢？
- en: So far we have looked exclusively at `SELECT` statements since they are likely
    to be the most common case in our legacy codebase. However, there will be a significant
    number of `INSERT`, `UPDATE`, `DELETE`, and perhaps other statements as well.
    These are treated essentially the same as the `SELECT` for purposes of extraction
    to a `Gateway`, but there are some minor differences.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看了`SELECT`语句，因为它们很可能是我们传统代码库中最常见的情况。然而，还会有大量的`INSERT`，`UPDATE`，`DELETE`，以及其他语句。在提取到`Gateway`时，这些基本上与`SELECT`相同，但也有一些细微的差异。
- en: In particular, `INSERT` and `UPDATE` statements may contain a large number of
    parameters indicating the column values to be inserted or updated. Adding too
    many parameters to the extracted `Gateway` method signature will make it difficult
    to work with.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是`INSERT`和`UPDATE`语句可能包含大量的参数，指示要插入或更新的列值。将太多的参数添加到提取的`Gateway`方法签名中将使其难以处理。
- en: In these cases, we can use a data array to indicate the column names and their
    corresponding values. We need to make sure that we are inserting or updating only
    the correct columns, though.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们可以使用数据数组来指示列名及其对应的值。但我们需要确保只插入或更新正确的列。
- en: 'For example, say we start with the following code in a page script to save
    a new comment with the name of the commenter, the comment body, the IP address
    of the commenter, and the post ID to which the comment is attached:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们从页面脚本中开始，保存一个新的评论，包括评论者的姓名、评论内容、评论者的IP地址以及评论所附加的帖子ID：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When we extract this to a method in our `CommentsGateway`, we could have a parameter
    for each column value being inserted. In this case there are only four columns,
    but if there were a dozen, the method signature would be harder to deal with.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将这些提取到`CommentsGateway`中的方法时，我们可以为每个要插入的列值设置一个参数。在这种情况下，只有四列，但如果有十几列，方法签名将更难处理。
- en: 'As an alternative to one parameter per column, we could pass an array of data
    as a single parameter and then work with that inside the method. This example
    of using a data array includes a prepared statement with placeholders to defeat
    SQL injection attacks:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为每列一个参数的替代方案，我们可以将数据数组作为单个参数传递，然后在方法内部处理。这个使用数据数组的示例包括一个带有占位符的预处理语句，以防止SQL注入攻击：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once we have a method like this in the `CommentsGateway`, we can modify the
    original code to read more like the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`CommentsGateway`中有了这样的方法，我们可以修改原始代码，使其更像下面这样：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What about Repetitive SQL strings?
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复的SQL字符串怎么办？
- en: One thing we will probably encounter during this process is a large amount of
    repetition, or repetition with variation, in the query strings throughout our
    legacy application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们可能会遇到的一件事是，在我们的传统应用程序中，查询字符串中存在大量的重复，或者是带有变化的重复。
- en: 'For example, we may find a comments-related query elsewhere in our legacy application
    that looks like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能会在传统应用程序的其他地方找到一个类似于这样的与评论相关的查询：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The query string is identical to the example code from the beginning of this
    chapter, except it has a `LIMIT` clause attached. Should we create an entirely
    new method for this query, or do we modify an existing method?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串与本章开头的示例代码相同，只是附加了一个`LIMIT`子句。我们应该为这个查询创建一个全新的方法，还是修改现有的方法？
- en: This is the sort of thing that requires professional judgment and familiarity
    with the codebase. In this case, modification seems to be reasonable, but in other
    situations the difference might be great enough to warrant an entirely new method.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是需要专业判断和对代码库的熟悉。在这种情况下，修改似乎是合理的，但在其他情况下，差异可能足够大，需要创建一个全新的方法。
- en: 'If we choose to modify an existing method in the `CommentsGateway`, we might
    rewrite `selectAllByPostId()` to include an optional `LIMIT`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择修改`CommentsGateway`中的现有方法，我们可以重写`selectAllByPostId()`以包括一个可选的`LIMIT`：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have modified the application class, we need to run our existing
    tests. If they fail, we rejoice! We have discovered that our change was flawed,
    and the tests have prevented that bug from making it into production. If they
    pass, we rejoice, because things are still working the way they used to before
    the change.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修改了应用程序类，我们需要运行现有的测试。如果测试失败，那我们就庆幸！我们发现了我们的改变有缺陷，而测试阻止了这个bug进入生产。如果测试通过，我们也庆幸，因为事情仍然像改变之前一样工作。
- en: 'Finally, after the existing tests pass, we modify the `CommentsGatewayTest`
    so that it checks to see if the new `LIMIT` functionality works properly. This
    test continues to be imperfect, but it gets the point across:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在现有测试通过后，我们修改`CommentsGatewayTest`，以检查新的`LIMIT`功能是否正常工作。这个测试仍然不完美，但它传达了要点。
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We run the tests yet again to make sure our new `LIMIT` functionality works,
    and refine the code and test until it passes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次运行测试，以确保我们的新的`LIMIT`功能正常工作，并不断完善代码和测试，直到通过为止。
- en: We then proceed to replace the original embedded SQL code with a call to the
    `Gateway`, spot check, commit, and so on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们继续用`Gateway`的调用替换原始的嵌入式SQL代码，进行抽查，提交等等。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We need to be cautious here. After seeing one variation of a query, we will
    be able to imagine many other possible variations of that query. The resulting
    temptation will be to preemptively modify our `Gateway` methods to account for
    the imagined variations before we actually encounter them. Unless we have actually
    seen a particular variation in the legacy codebase, we should restrain ourselves
    from writing code for that variation. We do not want to get too far ahead of what
    the codebase actually requires right now. The goal is to improve in small steps
    on a visible path, not to make giant leaps into a fog of imagination.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要谨慎处理。在看到一个查询的变体之后，我们将能够想象出许多其他可能的查询变体。由此产生的诱惑是在实际遇到这些变体之前，就预先修改我们的`Gateway`方法来适应想象中的变体。除非我们实际在遗留代码库中看到了特定的变体，否则我们应该克制自己，不要为那种变体编写代码。我们不希望超前于代码库当前实际需要的情况。目标是在可见的路径上小步改进，而不是在想象的迷雾中大步跨越。
- en: What about complex query strings?
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复杂的查询字符串怎么办？
- en: 'The examples so far have been relatively simple query strings. These simple
    examples help to keep the process clear. However, we are likely to see very complicated
    queries in our legacy codebase. These may include queries built up in pieces,
    using several conditional statements to modify how the pieces are built, with
    many different parameters being used in the query. Here is one example of a complex
    query taken from [Appendix A](apa.xhtml "Appendix A. Typical Legacy Page Script"),
    *Typical Legacy Page Script*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，示例都是相对简单的查询字符串。这些简单的示例有助于保持流程清晰。然而，在我们的遗留代码库中，我们可能会看到非常复杂的查询。这些查询可能是由多个条件语句构建而成，使用多个不同的参数在查询中使用。以下是一个复杂查询的示例，摘自[附录A](apa.xhtml
    "附录 A. 典型的遗留页面脚本")，*典型的遗留页面脚本*：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For complex arrangements of this sort, we will need to pay great attention to
    detail in extracting the relevant query-building logic to our `Gateway`. The main
    considerations are to determine which variables are used in the query-building
    logic, and to set those up as parameters to our new `Gateway` method. We can then
    move the query-building logic to our `Gateway`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种复杂的安排，我们需要非常注意细节，将相关的查询构建逻辑提取到我们的`Gateway`中。主要考虑因素是确定查询构建逻辑中使用了哪些变量，并将其设置为我们新的`Gateway`方法的参数。然后我们可以将查询构建逻辑移动到我们的`Gateway`中。
- en: 'A first pass at extracting the embedded SQL-related logic to a `Gateway` method
    follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以尝试将嵌入的与SQL相关的逻辑提取到`Gateway`方法中：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even though we have removed some dependencies (e.g. the implicit global dependency
    on a `mysql_connect()` link identifier), there are still lots of problems with
    this first pass. Among other things, it is still vulnerable to SQL injection.
    We would need to use `mysql_real_escape_string()` on every parameter used in the
    query, and cast the `LIMIT` values to integers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经删除了一些依赖项（例如对`mysql_connect()`链接标识符的隐式全局依赖），但这第一次尝试仍然存在许多问题。其中，它仍然容易受到SQL注入的影响。我们需要在查询中使用`mysql_real_escape_string()`对每个参数进行转义，并将`LIMIT`值转换为整数。
- en: 'Once we complete the extraction and its related test, we change the original
    code to something like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了提取及其相关的测试，我们将把原始代码更改为以下内容：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What about queries inside non-Gateway classes?
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非Gateway类内的查询怎么办？
- en: The examples in this chapter show SQL query strings embedded in page scripts.
    It is just as likely that we will find query strings embedded in non-Gateway classes
    as well.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例显示了嵌入在页面脚本中的SQL查询字符串。同样可能的是，我们也会在非Gateway类中找到嵌入的查询字符串。
- en: 'In these cases, we follow the same process as we did for page scripts. One
    added issue is that we will have to pass the `Gateway` dependency to the class.
    For example, say we have a `Foo` class that uses a `doSomething()` method to retrieve
    comments:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们遵循与页面脚本相同的流程。一个额外的问题是，我们将不得不将`Gateway`依赖项传递给该类。例如，假设我们有一个`Foo`类，它使用`doSomething()`方法来检索评论：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We extract the SQL query string and its related logic as we did with the page
    script. We then modify the `Foo` class to take the `Gateway` as a dependency instead
    of the `Db` object, and use the `Gateway` as needed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提取SQL查询字符串及其相关逻辑，就像我们在页面脚本中所做的那样。然后我们修改`Foo`类，将`Gateway`作为依赖项，而不是`Db`对象，并根据需要使用`Gateway`：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Can we extend from a base Gateway class?
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们可以从基类Gateway类扩展吗？
- en: 'If we have many `Gateway` classes that all have similar functionality, it may
    be reasonable to collect some of that functionality into an `AbstractGateway`.
    For example, if they all need the a `Db` connection, and all have similar `select*()`
    methods, we might do something like the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有许多具有类似功能的`Gateway`类，将一些功能收集到`AbstractGateway`中可能是合理的。例如，如果它们都需要`Db`连接，并且都有类似的`select*()`方法，我们可以做如下操作：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can then extend a class from that base `AbstractGateway` and tune the extended
    properties for a specific table:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以从基类`AbstractGateway`扩展一个类，并调整特定表的扩展属性：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The base `selectOneByPrimaryKey()` method can then work with a wide range of
    `Gateway` classes. We can still add other concrete methods on specific `Gateway`
    classes as needed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的`selectOneByPrimaryKey()`方法可以与各种`Gateway`类一起使用。根据需要，我们仍然可以在特定的`Gateway`类上添加其他具体的方法。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be cautious with this approach. We should abstract only the functionality that
    already exists in the behaviors we have already extracted. Resist the temptation
    to preemptively create functionality that we have not actually seen in the legacy
    codebase.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种方法要谨慎。我们应该只抽象出已经存在于我们已经提取的行为中的功能。抵制提前创建我们在遗留代码库中实际上还没有看到的功能的诱惑。
- en: What about multiple queries and complex result structures?
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个查询和复杂的结果结构怎么办？
- en: 'The examples in this chapter have shown single queries against single tables.
    It is likely that we will encounter logic that uses multiple queries against several
    different tables and then combines the results into a complex domain entity or
    collection. Here is an example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例已经显示了针对单个表的单个查询。我们可能会遇到使用多个查询针对几个不同的表，然后将结果合并为复杂领域实体或集合的逻辑。以下是一个例子：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example shows a classic N+1 problem where one query is issued for each
    member of a master set. The first query to get the blog posts will be followed
    by 10 more queries, one for each blog post, to get the comments. The total number
    of queries is thus 10, plus one for the initial query. For 50 posts, there would
    be 51 queries total. This is a typical source of performance drags in legacy applications.
    For extended discussion of, and solutions to, the N+1 problem, please see *Solving
    The N+1 Problem in PHP* ([https://leanpub.com/sn1php](https://leanpub.com/sn1php))
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了一个经典的N+1问题，其中为主集合的每个成员发出一个查询。获取博客文章的第一个查询将跟随10个查询，每个博客文章一个，以获取评论。因此，总查询数为10，加上初始查询为1。对于50篇文章，总共将有51个查询。这是遗留应用程序中性能拖慢的典型原因。有关N+1问题的详细讨论和解决方案，请参见*Solving
    The N+1 Problem in PHP* ([https://leanpub.com/sn1php](https://leanpub.com/sn1php))
- en: The first issue is to identify how we can split up the queries into `Gateway`
    methods. Some queries will have to go together, while others can be separated.
    In this case, the first and second queries can be separated into different `Gateway`
    classes and methods.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是确定如何将查询拆分为`Gateway`方法。有些查询必须一起进行，而其他查询可以分开。在这种情况下，第一个和第二个查询可以分开到不同的`Gateway`类和方法中。
- en: The next issue is to determine which `Gateway` class should receive the extracted
    logic. This can sometimes be hard to figure out when multiple tables are involved,
    so we have to choose which is the primary subject of the query. The first query
    above references posts, authors, and stats, but it seems clear from the logic
    that we are primarily interested in the posts.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是确定哪个`Gateway`类应接收提取的逻辑。当涉及多个表时，有时很难确定，因此我们必须选择查询的主要主题。上面的第一个查询涉及到文章、作者和统计数据，但从逻辑上看，我们主要关注的是文章。
- en: 'As such, we can extract the first query to a `PostsGateway`. We want to modify
    the query itself as little as possible, so we leave the joins and such in place:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将第一个查询提取到`PostsGateway`中。我们希望尽可能少地修改查询本身，因此我们保留连接和其他内容不变：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once completed, we proceed to write a test for the new functionality based on
    the first query. We modify the code and test until the test passes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们继续根据第一个查询编写新功能的测试。我们修改代码并进行测试，直到测试通过。
- en: The second query, the one related to comments, is the same as our earlier example.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个查询，与评论相关的查询，与我们之前的例子相同。
- en: 'After we finish the extractions and their related tests, we can modify the
    page script to look like the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成提取及其相关测试后，我们可以修改页面脚本，使其如下所示：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What if there is no Database Class?
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果没有数据库类会怎么样？
- en: Many legacy codebases do not have a database access layer. Instead, these legacy
    applications use the `mysql` extension directly in their page scripts. Calls to
    `mysql` functions are scattered throughout the codebase and are not gathered into
    a single class.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 许多遗留代码库没有数据库访问层。相反，这些遗留应用程序直接在其页面脚本中使用`mysql`扩展。对`mysql`函数的调用分散在整个代码库中，并未收集到单个类中。
- en: If we can upgrade to `PDO`, we should. However, it may not be possible to upgrade
    away from `mysql` for various reasons. `PDO` does not work quite the same way
    as `mysql`, and changing from `mysql` idioms to `PDO` ones might be too much to
    do in a single step. A migration at this point might also make testing more difficult
    than we would like.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以升级到`PDO`，我们应该这样做。然而，由于各种原因，可能无法从`mysql`升级。`PDO`的工作方式与`mysql`不完全相同，从`mysql`习语更改为`PDO`习语可能一次性做得太多。此时进行迁移可能会使测试变得比我们想要的更加困难。
- en: On the other hand, we could move the `mysql` calls as they are into our `Gateway`
    classes. Doing so seems reasonable at first. However, the `mysql` extension has
    a bit of global state built into it. Any `mysql` functions that need a link identifer
    (i.e., a server connection) automatically use the most-recent connection resource
    when no link identifier is passed. This is counter to the principles of dependency
    injection, since we would rather not be dependent on global state if we can help
    it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以将`mysql`调用按原样移入我们的`Gateway`类中。起初这样做似乎是合理的。然而，`mysql`扩展内置了一些全局状态。任何需要链接标识符（即服务器连接）的`mysql`函数在没有传递链接标识符时会自动使用最近的连接资源。这与依赖注入的原则相违背，因为如果可能的话，我们宁愿不依赖全局状态。
- en: Thus, instead of migrating directly to PDO, and instead of leaving the `msyql`
    function calls as they are, I suggest we wrap the `mysql` calls in a class that
    proxies method calls to the `mysql` functions. We can then use the class methods
    instead of the `mysql` functions. The class itself can contain the link identifier
    and pass it to each method call. This will give us a database access layer that
    our `Gateway` objects can use without changing the `mysql` idiomatic usage too
    greatly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我建议我们不直接迁移到PDO，也不将`msyql`函数调用保持原样，而是将`mysql`调用封装在一个类中，该类代理方法调用到`mysql`函数。然后，我们可以使用类方法而不是`mysql`函数。类本身可以包含链接标识符，并将其传递给每个方法调用。这将为我们提供一个数据库访问层，我们的`Gateway`对象可以使用，而不会太大地改变`mysql`的习惯用法。
- en: One operational example implementation of such a wrapper is the `MysqlDatabase`
    class. When we create an instance of `MysqlDatabase`, it retains the connection
    information but does not actually connect to the server. It only connects when
    we call a method that actually needs a server connection. This lazy-loading approach
    helps us reduce resource usage. In addition, the `MysqlDatabase` class explicitly
    adds the link identifier argument, which is optional in the relevant `mysql` functions,
    so that we are never dependent on the implicit global state of the `mysql` extension.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个包装器的一个操作示例实现是`MysqlDatabase`类。当我们创建一个`MysqlDatabase`的实例时，它会保留连接信息，但实际上不会连接到服务器。只有在我们调用实际需要服务器连接的方法时才会连接。这种延迟加载的方法有助于减少资源使用。此外，`MysqlDatabase`类明确添加了链接标识参数，这在相关的`mysql`函数中是可选的，这样我们就不会依赖于`mysql`扩展的隐式全局状态。
- en: 'To replace `mysql` function calls with `MysqlDatabase` calls:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要用`MysqlDatabase`调用替换`mysql`函数调用：
- en: Search the entire codebase for the `mysql_` prefix on function calls.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在整个代码库中搜索`mysql_`前缀的函数调用。
- en: In each file where there are function calls with the `mysql_` function prefix
    ...
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个文件中，如果有带有`mysql_`函数前缀的函数调用...
- en: Create or inject an instance of `MysqlDatabase`.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建或注入一个`MysqlDatabase`的实例。
- en: Replace each `mysql_` function prefix with the `MysqlDatabase` object variable
    and a single arrow operator (`->`). If we are sticklers for style, we can can
    convert the remaining method name portion from `snake_case()` to `camelCase()`
    as well.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用`MysqlDatabase`对象变量和一个箭头操作符(`->`)替换每个`mysql_`函数前缀。如果我们对风格很挑剔，我们还可以将剩余的方法名部分从`snake_case()`转换为`camelCase()`。
- en: Spot check, commit, push, and notify QA.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽查，提交，推送，并通知QA。
- en: Continue searching for the `mysql_` prefix on function calls until they have
    all been replaced with `MysqlDatabase` method calls.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续搜索`mysql_`前缀的函数调用，直到它们都被替换为`MysqlDatabase`方法调用。
- en: 'For example, say we have a piece of legacy code like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有这样一个遗留代码：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using the above process, we can convert the code to use the `MysqlDatabase`
    object instead:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述过程，我们可以将代码转换为使用`MysqlDatabase`对象：
- en: '**Using the MysqlDatabase class**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用MysqlDatabase类**'
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That code, in turn, can be extracted to a `Gateway` class using an injected
    `MysqlDatabase` object.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码，反过来可以使用一个注入的`MysqlDatabase`对象提取到一个`Gateway`类中。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For our page scripts, it may be best to create a `MysqlDatabase` instance in
    our existing setup file and use that, instead of creating one separately in each
    page script. The lazy-connecting nature of the implementation means that if we
    never make a call to the database, no connection will ever be made, so we don't
    need to worry about unnecessary resource usage. The existing legacy codebase will
    help us determine if this is a reasonable approach.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的页面脚本，最好在现有的设置文件中创建一个`MysqlDatabase`实例并使用它，而不是在每个页面脚本中单独创建一个。实现的延迟连接性意味着如果我们从未对数据库进行调用，就永远不会建立连接，因此我们不需要担心不必要的资源使用。现有的遗留代码库将帮助我们确定这是否是一个合理的方法。
- en: Once our `Gateway` classes use an injected `MysqlDatabase` object, we can then
    proceed to planning a migration away from the wrapped `mysql` functions over to
    `PDO` with its different idioms and usage. Because the database access logic is
    now wrapped by `Gateway` objects, the migration and testing will be easier than
    if we had replaced `mysql` calls spread throughout the codebase.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的`Gateway`类使用了一个注入的`MysqlDatabase`对象，我们就可以开始计划从封装的`mysql`函数迁移到具有不同习惯用法和用法的`PDO`。因为数据库访问逻辑现在由`Gateway`对象封装，所以迁移和测试将比如果我们替换了遍布整个代码库的`mysql`调用要容易。
- en: Review and next steps
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查和下一步
- en: When we have completed this step, all of our SQL statements will be inside `Gateway`
    classes, and no longer in our page scripts or other non-Gateway classes. We will
    also have tests for our `Gateway` classes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成了这一步，我们所有的SQL语句将在`Gateway`类中，而不再在我们的页面脚本或其他非`Gateway`类中。我们还将对我们的`Gateway`类进行测试。
- en: From here on out, any time we need to add new calls to the database, we will
    do so only in the `Gateway` classes. Any time we need to fetch or save data, we
    will use the `Gateway` methods instead of writing embedded SQL. This gives us
    a clear separation of concerns between the database interactions and our future
    model layer and entity objects.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每当我们需要向数据库添加新的调用时，我们只会在`Gateway`类中这样做。每当我们需要获取或保存数据时，我们将使用`Gateway`方法，而不是编写嵌入式SQL。这使我们在数据库交互和未来的模型层和实体对象之间有了明确的关注点分离。
- en: Now that we have separated our database interactions into their own layer, we
    are going to inspect all the calls to the `Gateway` objects throughout the legacy
    application. We will examine how the returned results are manipulated by the page
    scripts and other classes, and begin extracting the behaviors that define our
    model layer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将数据库交互分离到了它们自己的层中，我们将检查整个遗留应用程序中对`Gateway`对象的所有调用。我们将检查页面脚本和其他类如何操作返回的结果，并开始提取定义我们模型层的行为。
