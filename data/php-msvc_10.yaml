- en: Chapter 10. Strategies for Scalability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 可扩展性策略
- en: You have your application ready. Now it is time to plan for the future. In this
    chapter, we will give you a global overview of how you can check the possible
    bottlenecks of your application and how you can calculate the capacity of your
    application. At the end of the chapter, you will have the basic knowledge to create
    your own scalability plan.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序已准备就绪。现在是计划未来的时候了。在本章中，我们将为您全面介绍如何检查应用程序可能的瓶颈以及如何计算应用程序的容量。在本章结束时，您将具备创建自己的可扩展性计划的基本知识。
- en: Capacity planning
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容量规划
- en: '**Capacity planning** is the process of determining the infrastructure resources
    required by your application to meet future workload demands for your app. This
    process ensures that you have adequate resources available only when they are
    needed, reducing costs to the minimum. If you know how your application is used
    and the limits of your current resources, you can extrapolate the data and know,
    more or less, the future requirements. Creating a capacity plan for your application
    has some benefits, among which we can highlight the following ones:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**容量规划**是确定应用程序所需的基础设施资源的过程，以满足应用程序未来的工作负载需求。该过程确保您在需要时有足够的资源可用，从而将成本降至最低。如果您知道应用程序的使用方式和当前资源的限制，您可以推断数据并大致了解未来的需求。为您的应用程序创建容量规划具有一些好处，其中我们可以突出以下好处：'
- en: '**Minimize costs and avoid waste from over-provisioning**: Your application
    will use only the required resources, so it makes no sense, for example, to have
    a 64 GB RAM server for your database when you are only using 8 GB.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化成本并避免过度配置的浪费**：您的应用程序将仅使用所需的资源，因此，例如，当您只使用8GB时，为数据库拥有64GB RAM服务器是没有意义的。'
- en: '**Prevent bottlenecks and save time**: Your capacity plan highlights when each
    element of your infrastructure reaches its peak, giving you a hint about where
    the bottleneck can be.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预防瓶颈并节省时间**：您的容量计划突出显示基础设施的每个元素何时达到峰值，为您提供有关瓶颈可能出现的提示。'
- en: '**Increase business productivity**: If you have a detailed plan that indicates
    the limits of each element of your infrastructure and knows when each element
    will reach its limits, it gives you spare room to dedicate your time to other
    business tasks. You will have a set of instructions to follow on the precise moment
    you need to increase the capacity of your application. No more crazy moments when
    you are suffering bottlenecks and don’t know what to do.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高业务生产力**：如果您有一个详细的计划，指出基础设施的每个元素的限制，并知道每个元素何时达到其限制，那么您就有了空余时间来专注于其他业务任务。您将有一套指令，以便在需要增加应用程序容量的确切时刻遵循。当您遇到瓶颈并不知道该怎么办时，就不会再有疯狂的时刻了。'
- en: '**Used as a mapping of business objectives**: If your application is critical
    for your business, this document can be used to highlight some business objectives.
    For example, if the business wants to reach 1,000 users, your infrastructure needs
    to be allowed to support them, flagging some investments needed to fulfill this
    requirement.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用作业务目标的映射**：如果您的应用程序对您的业务至关重要，此文档可用于突出一些业务目标。例如，如果业务想要达到1,000个用户，您的基础设施需要支持它们，标记一些需要满足此要求的投资。'
- en: Knowing the limits of your application
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解您的应用程序的限制
- en: 'The main purpose of knowing the limits of your application is to know how much
    capacity we still have at any given point of time before we start having issues.
    The first thing we need to do is create an inventory of the components of our
    application. Make the inventory as detailed as possible; it will help you know
    all the tools you have in your project. In our example application, the list of
    different components could be something similar to this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 了解您的应用程序的限制的主要目的是在开始出现问题之前知道我们在任何给定时间点还有多少容量。我们需要做的第一件事是创建我们应用程序组件的清单。尽可能详细地制作清单；这将帮助您了解项目中所有工具。在我们的示例应用程序中，不同组件的清单可能类似于以下内容：
- en: 'Autodiscovery service:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动发现服务：
- en: Hashicorp Consul
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hashicorp Consul
- en: 'Telemetry service:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遥测服务：
- en: Prometheus
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus
- en: 'Battle microservice:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 战斗微服务：
- en: 'Proxy: NGINX'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理：NGINX
- en: 'App engine: PHP 7 FPM'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用引擎：PHP 7 FPM
- en: 'Data storage: Percona'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储：Percona
- en: 'Cache storage: Redis'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存存储：Redis
- en: 'Location microservice:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置微服务：
- en: 'Proxy: NGINX'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理：NGINX
- en: 'App engine: PHP 7 FPM'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用引擎：PHP 7 FPM
- en: 'Data storage: Percona'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储：Percona
- en: 'Cache storage: Redis'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存存储：Redis
- en: 'Secret microservice:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密微服务：
- en: 'Proxy: NGINX'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理：NGINX
- en: 'App engine: PHP 7 FPM'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用引擎：PHP 7 FPM
- en: 'Data storage: Percona'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储：Percona
- en: 'Cache storage: Redis'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存存储：Redis
- en: 'User microservice:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户微服务：
- en: 'Proxy: NGINX'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理：NGINX
- en: 'App engine: PHP 7 FPM'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用引擎：PHP 7 FPM
- en: 'Data storage: Percona'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储：Percona
- en: 'Cache storage: Redis'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存存储：Redis
- en: Once we have reduced our application to the base components, we need to analyze
    and determine the usage of each component over time and its maximum capacity in
    an appropriate measurement.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将应用程序减少到基本组件，我们需要分析并确定每个组件的使用情况以及适当测量中的最大容量。
- en: Some components can have multiple measurements associated, for example, the
    data storage layer (Percona in our case). For this component, we can measure the
    number of SQL transactions, amount of storage used, CPU load, and so on. In the
    previous chapters, we added a Telemetry service; you can use this service to gather
    basic stats from each component.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 某些组件可能有多个���联的测量，例如数据存储层（在我们的案例中为Percona）。对于此组件，我们可以测量SQL事务数量、使用的存储量、CPU负载等。在前几章中，我们添加了一个遥测服务；您可以使用此服务从每个组件中收集基本统计信息。
- en: 'Some of the basic stats you can log for each component of your application
    are as listed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为应用程序的每个组件记录的一些基本统计信息如下：
- en: CPU load
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU负载
- en: Memory usage
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存使用
- en: Network usage
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络使用
- en: IOPS
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IOPS
- en: Disk utilization
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘利用率
- en: 'In some software, you need to gather some specific measurements. For instance,
    on a database you can check the following things:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些软件中，您需要收集一些特定的测量。例如，在数据库上，您可以检查以下内容：
- en: Transactions per second
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每秒事务数
- en: Cache hit ratio (if you have enabled query cache)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存命中率（如果启用了查询缓存）
- en: User connections
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户连接
- en: The next step is determining the natural growth of the application. This measurement
    can be defined as the growth performed by your application if nothing special
    has been done (such as PPC campaigns and new features). This measurement can be
    the number of new users or the amount of active users, for example. Imagine that
    you deploy your application to production and stop adding new features or doing
    marketing campaigns. If the number of new users increased 7% over the last month,
    that amount is the natural growth of your application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确定应用程序的自然增长。如果没有进行特殊操作（如PPC广告活动和新功能），则可以将此测量定义为应用程序的增长。这个测量可以是新用户的数量或活跃用户的数量，例如。想象一下，您将应用程序部署到生产环境，并停止添加新功能或进行营销活动。如果过去一个月新用户的数量增加了7%，那么这个数量就是您的应用程序的自然增长。
- en: Some businesses/projects have seasonal trends, which means that at specific
    dates, the usage of your application increases. Imagine that you are a gifts'
    retailer, most of your sales probably are done around Valentine’s day or at the
    end of the year (Black Friday, Xmas). If this is your case, analyze all the data
    you have to establish the seasonality data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一些企业/项目具有季节性趋势，这意味着在特定日期，您的应用程序的使用量会增加。想象一下，您是一个礼品零售商，您的大部分销售可能是在情人节或年底（黑色星期五，圣诞节）左右完成的。如果这是您的情况，请分析您拥有的所有数据以建立季节性数据。
- en: 'Now that you have some basic stats of your application, it is time to calculate
    what is known as the headroom. The headroom can be defined as the amount of resources
    you have until you are out of resources. It can be calculated with the following
    formula:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了应用程序的一些基本统计数据，是时候计算所谓的剩余空间了。剩余空间可以定义为在资源耗尽之前您拥有的资源量。可以用以下公式计算：
- en: '![Knowing the limits of your application](graphics/B06142_10_01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![了解应用程序的限制](graphics/B06142_10_01.jpg)'
- en: Headroom formula
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余空间公式
- en: 'As you can see from the preceding formula, calculating the headroom for a specific
    component is very easy. Let’s explain each variable before we take an example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述公式中可以看出，计算特定组件的剩余空间非常简单。在我们举例之前，让我们解释每个变量：
- en: '**IdealUsage:** This is a percentage that describes the amount of capacity
    for a specific component of your application that we are planning to use. This
    ideal usage should never be 100%, as strange behaviors, such as not being able
    to save data in your database, can start appearing when you approach the resource
    limits. Our recommendation is to set this amount to be between 60% and 75%, giving
    you enough extra space for peak moments.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理想使用率：** 这是一个百分比，描述了我们计划使用的应用程序特定组件的容量。理想使用率永远不应该达到100%，因为当接近资源限制时，可能会出现无法保存数据库中数据等奇怪的行为。我们建议将此量设置在60%至75%之间，为高峰时刻留出足够的额外空间。'
- en: '**MaxCapacity:** This is the amount that indicates the maximum capacity of
    the component subject of our study. For example, a web server that can manage
    up to 250 concurrent connections.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大容量：** 这是指我们研究对象组件的最大容量。例如，一个能够处理最多250个并发连接的Web服务器。'
- en: '**CurrentUsage:** This is the amount that indicates the current usage of the
    component that we are studying.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前使用率：** 这是指我们正在研究的组件的当前使用率。'
- en: '**Growth:** This is the percentage that indicates the natural growth of our
    application.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增长：** 这是指我们应用程序的自然增长的百分比。'
- en: '**Optimizations:** This is the optional variable that describes the amount
    of optimizations we can achieve in a specific amount of time. For instance, if
    your current database can manage 35 queries per second, you can achieve 50 queries
    per second after a few optimizations. In this case, the amount of optimization
    is 15.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化：** 这是可选变量，描述了在特定时间内我们可以实现的优化量。例如，如果您当前的数据库每秒可以处理35个查询，经过一些优化后，您可以实现每秒50个查询。在这种情况下，优化量为15。'
- en: Imagine that you are calculating the headroom of requests per second that can
    be managed by one of our NGINX. For our application, we have decided to set the
    ideal usage to 60% (0.6). From our measurements and from the data extracted from
    our load testing (explained later in the chapter), we know that the maximum number
    of **requests per second** (**RPS**) is 215\. In our current stats, our NGINX
    server served a peak of 193 RPS today and we have calculated the growth for the
    next year to be at least 11 RPS.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在计算我们的一个NGINX可以处理的每秒请求的剩余空间。对于我们的应用程序，我们已经决定将理想使用率设置为60%（0.6）。根据我们的测量和从负载测试中提取的数据（稍后在本章中解释），我们知道每秒请求的最大数量（RPS）为215。在我们当前的统计数据中，我们的NGINX服务器今天提供了最高193
    RPS，并且我们已经计算出了下一年的增长至少为11 RPS。
- en: 'The time period we want to measure is 1 year, and we think that we can achieve
    the 250 RPS of maximum capacity in this time, so our Headroom value will be as
    follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要测量的时间段是1年，我们认为我们可以在这段时间内实现最大容量250 RPS，因此我们的剩余空间值将如下所示：
- en: '*Headroom = 0.6 * 215 - 123 - (11 - 35) = 30 RPS*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*剩余空间= 0.6 * 215 - 123 - (11 - 35) = 30 RPS*'
- en: What does this calculation mean? Since the result is positive, it means that
    we have enough spare room for our predictions. If we divide the result by the
    sum of growth and optimizations, we can calculate how much time we have until
    we reach our limits.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算意味着什么？由于结果是正数，这意味着我们有足够的预留空间。如果我们将结果除以增长和优化的总和，我们可以计算出我们达到资源限制之前还有多少时间。
- en: 'Since our time period is 1 year, we can calculate how much time we have until
    we reach our limits, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的时间段是1年，我们可以计算出我们达到资源限制之前还有多少时间，如下所示：
- en: '*Headroom Time = 30 rpms / 24 = 1.25 years*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*Headroom时间= 30 rpm / 24 = 1.25年*'
- en: As you have probably already deduced, we have 1.25 years until our NGINX server
    reaches the limit of RPS. In this section, we showed you how to calculate the
    headroom of a specific component; now, it is your turn to make the calculations
    for each one of your components and for the different metrics available for each
    component.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经推断出，我们的NGINX服务器还有1.25年才能达到RPS的极限。在本节中，我们向您展示了如何计算特定组件的余量；现在轮到您为您的每个组件和每个组件可用的不同指标进行计算了。
- en: Availability math
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用性数学
- en: '**Availability** can be defined as how often the site is available in a specific
    period of time, for example, a week, a day, a year, and so on. Depending on how
    critical your application is for you or your business, a downtime can equal lost
    revenue. As you can suppose, the availability can become the most important metric
    on scenarios where your application is used by customers/users and they need your
    service at any time.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**可用性**可以定义为网站在特定时间段内的可用性，例如一周，一天，一年等。根据您的应用程序对您或您的业务的重要性，停机时间可能等于丢失的收入。正如您可以想象的那样，可用性可能成为应用程序由客户/用户使用并且他们需要您的服务的任何时间的情况下最重要的指标。'
- en: We have the theoretical concept about what availability is. It is time to do
    some math, so take your calculator. As from the earlier general definition, the
    availability can be calculated as the amount of time your application can be used
    by your users/customers for divided by the time frame (the specific period of
    time we are measuring).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对可用性有了理论概念。现在是时候做一些数学运算了，拿出你的计算器。根据早期的一般定义，可用性可以计算为您的应用程序可以被用户/客户使用的时间除以时间范围（我们正在测量的特定时间段）。
- en: 'Let’s imagine that we want to measure the availability of our application over
    one week. In one week, we have `10,080` minutes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要测量我们的应用程序在一周内的可用性。一周内，我们有`10,080`分钟：
- en: '*7 days x 24 hours per day x 60 minutes per hour = 7 * 24 * 60 = **10,080 minutes***'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '* 7天x每天24小时x每小时60分钟= 7 * 24 * 60 = **10,080分钟***'
- en: 'Now, imagine that your application had a few outages that week and the amount
    of available minutes of your application was reduced to `10,000`. To calculate
    the availability for our example, we only need to do some simple math:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您的应用程序在那周发生了一些故障，并且您的应用程序的可用分钟数减少到`10,000`。要计算我们示例的可用性，我们只需要进行一些简单的数学运算：
- en: '*10,000 / 10,080 = 0.9920634921*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '* 10,000 / 10,080 = 0.9920634921*'
- en: 'The availability was usually measured as a percentage (%), so we need to transform
    our result to a percentage:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性通常以百分比（％）表示，因此我们需要将结果转换为百分比：
- en: '*0.9920634921 * 100 = 99.20634921% ~ **99.21***'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '* 0.9920634921 * 100 = 99.20634921％〜**99.21***'
- en: 'The availability of our application over the week was `99.21%`. Not too bad,
    but far from the result we aim for, that is, the closest percentage to `100%`
    that we can get. Most of the time, the availability percentage is referred as
    the **number of nines** and, the closer they are to `100%`, the more difficult
    it is to maintain the availability of your application. To give you an overview
    of how difficult it will be to reach the `100%` availability, here are some examples
    of availabilities and the possible downtime:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序在一周内的可用性为`99.21％`。不算太糟糕，但离我们的目标结果还差得远，即尽可能接近`100％`。大多数情况下，可用性百分比被称为**数量的九**，并且它们越接近`100％`，就越难以维护应用程序的可用性。为了让您了解达到`100％`可用性将有多困难，这里有一些可用性和可能停机时间的示例：
- en: '99.21% (our example):'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 99.21％（我们的示例）：
- en: 'Weekly: 1 h 19 m 37.9 s'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每周：1小时19分钟37.9秒
- en: 'Monthly: 5 h 46 m 15.0 s'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每月：5小时46分钟15.0秒
- en: 'Yearly: 69 h 14 m 59.9 s'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每年：69小时14分钟59.9秒
- en: '99.5%:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 99.5％：
- en: 'Weekly: 50 m 24.0 s'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每周：50分钟24.0秒
- en: 'Monthly: 3 h 39 m 8.7 s'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每月：3小时39分钟8.7秒
- en: 'Yearly: 43 h 49 m 44.8 s'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每年：43小时49分钟44.8秒
- en: '99.9%:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 99.9％：
- en: 'Weekly: 10 m 4.8 s'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每周：10分钟4.8秒
- en: 'Monthly: 43 m 49.7 s'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每月：43分钟49.7秒
- en: 'Yearly: 8 h 45 m 57.0 s'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每年：8小时45分钟57.0秒
- en: '99.99%:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 99.99％：
- en: 'Weekly: 1 m 0.5 s'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每周：1分钟0.5秒
- en: 'Monthly: 4 m 23.0 s'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每月：4分钟23.0秒
- en: 'Yearly: 52 m 35.7 s'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每年：52分钟35.7秒
- en: '99.999%:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 99.999％：
- en: 'Weekly: 6.0 s'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每周：6.0秒
- en: 'Monthly: 26.3 s'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每月：26.3秒
- en: 'Yearly: 5m 15.6 s'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每年：5分钟15.6秒
- en: '99.9999%:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 99.9999％：
- en: 'Weekly: 0.6 s'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每周：0.6秒
- en: 'Monthly: 2.6 s'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每月：2.6秒
- en: 'Yearly: 31.6 s'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每年：31.6秒
- en: '99.99999%:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 99.99999％：
- en: 'Weekly: 0.1 s'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每周：0.1秒
- en: 'Monthly: 0.3 s'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每月：0.3秒
- en: 'Yearly: 3.2 s'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每年：3.2秒
- en: 'As you can see, as getting close to `100%` availability becomes harder and
    harder, the downtimes are tighter. However, how can you reduce your downtime or
    at least ensure that you are doing your best to keep it low? There is no easy
    answer to this question, but we can give you a few hints of the different things
    you can do:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，接近`100％`的可用性变得越来越困难，停机时间变得更紧。但是，您如何减少停机时间或至少确保尽力保持低水平呢？这个问题没有简单的答案，但我们可以给您一些建议，告诉您可以做的不同事情：
- en: The worst possible scenario will happen, so you should simulate failures frequently
    to be ready to deal with the apocalypse of your application.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最坏的情况将发生，因此您应该经常模拟故障，以便随时准备应对应用程序的大灾难。
- en: Find the possible bottlenecks of your application.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找出应用程序可能的瓶颈。
- en: Tests, tests, and more tests everywhere, and, of course, keep them updated.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试，到处都是测试，当然，要保持它们更新。
- en: Log any event, any metric, anything you can measure or save as a log, and keep
    it for future references.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录任何事件，任何指标，您可以测量或保存为日志的任何内容，并保存以供将来参考。
- en: Know the limits of your application.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解您的应用程序的限制。
- en: 'Have some good development practices in place, at least to share the knowledge
    of how your application was built. Among all of them, you can do the following
    ones:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少要有一些良好的开发实践，至少要分享应用程序构建的知识。在所有这些实践中，您可以执行以下操作之一：
- en: Second approval for any hotfix or feature
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何热修复或功能，需要第二次批准
- en: Programming in pairs
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成对编程
- en: Create a continuous delivery pipeline.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建持续交付管道。
- en: Have a backup plan and keep your backups safe and ready to be used.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制定备份计划并确保您的备份安全并随时可用。
- en: Document everything, any small change or design, and always keep the documentation
    up to date.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录所有内容，任何小的更改或设计，并始终保持文档最新。
- en: You now have a global overview about what **availability** means and the maximum
    downtime expected for each rate. Be careful if you give your users/customers a
    SLA (Service Level Agreement), as you will be creating a promise about the availability
    of your application that you will have to fulfill.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经全面了解了“可用性”意味着什么，以及每个速率的最大停机时间。如果您向用户/客户提供SLA（服务级别协议），请注意，您将会对应用程序的可用性做出承诺，您将需要履行这个承诺。
- en: Load testing
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载测试
- en: Load testing can be defined as the process of putting a demand (load) in your
    application to measure its response. This process helps you identify the maximum
    capacity of your application or infrastructure and it can highlight bottlenecks
    or problematic elements of your application or infrastructure. The normal way
    of doing load testing is first doing a test on "normal" conditions, that is, with
    a normal load in your application. Having measured the response of your system
    under normal conditions allows you to have a baseline that you will use to compare
    with in future testings.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试可以定义为在应用程序中施加需求（负载）以测量其响应的过程。这个过程可以帮助您确定应用程序或基础设施的最大容量，并且可以突出显示应用程序或基础设施的瓶颈或问题元素。进行负载测试的正常方式是首先在应用程序中进行“正常”条件下的测试，也就是在应用程序中进行正常负载的测试。在正常条件下测量系统的响应可以让您拥有一个基线，您将用它来与未来的测试进行比较。
- en: Let’s see some of the most common tools you can use for your load testing. Some
    are simple and easy to use and others are more complex and powerful.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些您可以用于负载测试的最常见工具。有些简单易用，而其他一些更复杂和强大。
- en: Apache JMeter
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apache JMeter
- en: The Apache JMeter application is an open source software built in Java and designed
    to do load testing and measure performance. At first, it was designed for web
    applications, but it was expanded to test other functions in time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Apache JMeter应用程序是一个用Java构建的开源软件，旨在进行负载测试和性能测量。起初，它是为Web应用程序设计的，但随着时间的推移，它扩展到测试其他功能。
- en: 'Some of the most interesting features of Apache JMeter are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Apache JMeter的一些最有趣的功能如下：
- en: 'Support for different applications/servers/protocols: HTTP(S), SOAP/Rest, FTP,
    LDAP, TCP, and Java objects.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持不同的应用程序/服务器/协议：HTTP(S)、SOAP/Rest、FTP、LDAP、TCP和Java对象。
- en: 'Easy integration with third-party Continuous Integration tools: It has libraries
    for Maven, Gradle, and Jenkins.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与第三方持续集成工具轻松集成：它具有用于Maven、Gradle和Jenkins的库。
- en: 'Command-line mode (non GUI/headless mode): This enables you to do your test
    from any OS with Java installed.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行模式（非GUI/无头模式）：这使您可以在安装了Java的任何操作系统上进行测试。
- en: 'Multi-threading framework: This allows you to make concurrent samples by many
    threads and simultaneous sampling of different functions by separate thread groups.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程框架：这允许您通过许多线程进行并发样本，并通过单独的线程组同时对不同功能进行采样。
- en: 'Highly extensible: It is extensible through libraries or plugins, among others.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度可扩展：它可以通过库或插件等进行扩展。
- en: 'Full featured test IDE: It allows you to create, record, and debug your test
    plans.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的测试IDE：它允许您创建、记录和调试您的测试计划。
- en: As you can see, this project is an interesting tool you can use in your loading
    tests. In the following sections, we will show you how to build a simple test
    scenario. Unfortunately, we don’t have enough space in the book to cover all the
    features, but at least you will know the basics that will be the foundations of
    more complex tests in the future.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个项目是一个有趣的工具，您可以在负载测试中使用。在接下来的部分中，我们将向您展示如何构建一个简单的测试场景。不幸的是，我们的书中没有足够的空间来涵盖所有功能，但至少您将了解未来更复杂测试的基础知识。
- en: Installing Apache JMeter
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Apache JMeter
- en: Being developed in Java allows this application to be portable to any OS with
    Java installed. Let’s install it in our development machine.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于是用Java开发的，这个应用程序可以在安装了Java的任何操作系统上使用。让我们在开发机器上安装它。
- en: The first step is to fulfill the main requirement--you need a JVM 6 or later
    version to make the application work. You probably have Java in your machine already,
    but if this is not the case, you can download the latest JDK from the Oracle page.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是满足主要要求——您需要一个JVM 6或更高版本来使应用程序工作。您可能已经在您的计算机上安装了Java，但如果不是这种情况，您可以从Oracle页面下载最新的JDK。
- en: 'To check the version of your Java runtime, you only need to open a terminal
    in your OS and execute the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查您的Java运行时版本，您只需要在您的操作系统中打开终端并执行以下命令：
- en: '[PRE0]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command will tell you the version available in your machine.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将告诉您在您的计算机上可用的版本。
- en: As soon as we are sure that we have the correct version, we only need to go
    to the official Apache JMeter page ([http://jmeter.apache.org](http://jmeter.apache.org))
    and download the latest binaries in ZIP or TGZ formats. Once the binaries are
    fully downloaded to your machine, you only need to uncompress the downloaded ZIP or
    TGZ, and Apache JMeter is ready to be used.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了正确的版本，我们只需要转到官方的Apache JMeter页面（[http://jmeter.apache.org](http://jmeter.apache.org)）并下载最新的ZIP或TGZ格式的二进制文件。一旦二进制文件完全下载到您的计算机上，您只需要解压下载的ZIP或TGZ，Apache
    JMeter就可以使用了。
- en: Executing load tests with Apache JMeter
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Apache JMeter执行负载测试
- en: 'Open the folder where you have uncompressed the Apache JMeter binaries. There,
    you can find a `bin` folder and some scripts for different OSes in it. If you
    are using Linux/UNIX or Mac OS, you can execute the `jmeter.sh` script to open
    the application GUI. If you are running Windows, there is a `jmeter.bat` executable
    that you can use to open the GUI:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您解压缩Apache JMeter二进制文件的文件夹。在那里，您可以找到一个`bin`文件夹和一些不同操作系统的脚本。如果您使用Linux/UNIX或Mac
    OS，您可以���行`jmeter.sh`脚本来打开应用程序的GUI。如果您使用Windows，有一个`jmeter.bat`可执行文件，您可以用它来打开GUI：
- en: '![Executing load tests with Apache JMeter](graphics/B06142_10_02.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![使用Apache JMeter执行负载测试](graphics/B06142_10_02.jpg)'
- en: Apache JMeter GUI
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Apache JMeter GUI
- en: The Apache JMeter GUI allows you to build your different testing plans and,
    as you can see in the preceding screenshot, the interface is very easy to understand
    even without reading the manual. Let’s build a test plan with the GUI.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Apache JMeter GUI允许您构建不同的测试计划，正如您在前面的截图中所看到的，即使不阅读手册，界面也非常容易理解。让我们用GUI构建一个测试计划。
- en: Tip
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A test plan can be described as a series of steps that Apache JMeter will run
    in a specific order.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试计划可以被描述为Apache JMeter将按特定顺序运行的一系列步骤。
- en: 'Our first step in order to create our test plan is adding a **Thread Group**
    under the **Test Plan** node. In Apache JMeter, a thread group can be defined
    as a simulation of concurrent users. Follow the given steps to create a new group:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的测试计划的第一步，需要在**测试计划**节点下添加一个**线程组**。在Apache JMeter中，线程组可以被定义为并发用户的模拟。按照给定的步骤创建一个新的组：
- en: Right-click on the **Test Plan** node.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**测试计划**节点。
- en: In the context menu, select **Add** | **Threads (Users)** | **Thread Group**.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上下文菜单中，选择**添加 | 线程（用户） | 线程组**。
- en: 'The preceding steps will create a child element in our **Test Plan** node.
    Select it so that we can make some adjustments to our group. Refer to the following
    screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤将在我们的**测试计划**节点中创建一个子元素。选择它，以便我们可以对我们的组进行一些调整。参考以下截图：
- en: '![Executing load tests with Apache JMeter](graphics/B06142_10_03-1.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![使用Apache JMeter执行负载测试](graphics/B06142_10_03-1.jpg)'
- en: Thread group settings
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 线程组设置
- en: 'As you can see in the preceding screenshot, each thread group allows you to
    specify the amount of users for your tests and the duration of the test. The main
    options available are as listed:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，每个线程组都允许您指定测试的用户数量和测试的持续时间。主要可用的选项如下所示：
- en: '**Actions to be taken after a Sample error:** This option allows you to control
    the behavior of the test as soon as a sample error is thrown. The most used option
    is the **Continue** behavior.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**样本错误后要采取的操作：**这个选项允许您控制测试在抛出样本错误时的行为。最常用的选项是**继续**行为。'
- en: '**Number of Threads (users):** This field allows you to specify the number
    of concurrent users you will be using to hit your application.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程数（用户数）：**这个字段允许您指定要用来击打您的应用程序的并发用户数量。'
- en: '**Ramp-Up Period (in seconds):** This field is used to tell Apache JMeter how
    much time can be used to create all the threads you specified in the previous
    field. For example, if you set this field to 60 seconds and the **Number of Threads
    (users)** was set to 6, Apache JMeter will take 60 seconds to spin up all the
    6 threads, one each 10 seconds.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ramp-up周期（以秒为单位）：**这个字段用于告诉Apache JMeter可以用多少时间来创建您在前一个字段中指定的所有线程。例如，如果您将此��段设置为60秒，并且**线程数（用户数）**设置为6，Apache
    JMeter将花费60秒来启动所有6个线程，每10秒一个。'
- en: '**Loop count and Forever:** These fields allow you to stop the test after a
    specific number of executions.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环计数和永远：**这些字段允许您在特定次数的执行后停止测试。'
- en: The remaining options are self-explanatory and in our example, we will only
    use the mentioned fields.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其余选项都是不言自明的，在我们的示例中，我们将只使用上述字段。
- en: Imagine that you want to use 25 threads (like users) and you set up the ramp-up
    to 100 seconds. The math will tell you that a new thread will be created every
    4 seconds until you have the 25 threads running (100/25 = 4). These two fields
    allow you to design your tests to start slowly and increase the amount of users
    hitting your application at the right time.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想使用25个线程（就像用户），并将ramp-up设置为100秒。数学会告诉您，每4秒将创建一个新的线程，直到有25个线程在运行（100/25 =
    4）。这两个字段允许您设计您的测试，以便在合适的时间开始缓慢增加击打您的应用程序的用户数量。
- en: 'Once we have our threads/users defined, it is time to add a request because
    our test will do nothing without a request. To add a request, you only need to
    select the Thread Group node, right-click on the context menu, and choose **Add** | **Sampler** | **HTTP
    Request**. The previous action will add a new children node to our Thread Group.
    Selecting the new node, Apache JMeter, will show you a form similar to the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了我们的线程/用户，就是时候添加一个请求了，因为没有请求，我们的测试将无法进行。要添加一个请求，您只需要选择线程组节点，右键单击上下文菜单，然后选择**添加
    | 取样器 | HTTP请求**。前面的操作将在我们的线程组中添加一个新的子节点。选择新节点，Apache JMeter将向您显示一个类似于以下截图的表单：
- en: '![Executing load tests with Apache JMeter](graphics/B06142_10_04.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![使用Apache JMeter执行负载测试](graphics/B06142_10_04.jpg)'
- en: HTTP Request options
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求选项
- en: As you can see in the preceding screenshot, we can set up the host we want to
    hit our test with. In our case, we decide to hit `localhost` on port `8083` with
    a `GET` request to the `/api/v1/secret/` path. Feel free to explore the advanced
    options or add custom parameters. Apache JMeter is very flexible and covers practically
    every possible scenario.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，我们可以设置要用我们的测试击打的主机。在我们的情况下，我们决定在端口8083上用`GET`请求击打`localhost`的`/api/v1/secret/`路径。随意探索高级选项或添加自定义参数。Apache
    JMeter非常灵活，几乎涵盖了每种可能的场景。
- en: At this point, we have set up a basic test, now it's time to see the results.
    Let’s explore a few interesting ways to gather the information from the test.
    To see and analyze the results of each iteration of our test, we need to add a
    **Listener**. To do this, as in the previous steps, right-click on the **Thread
    Group** and navigate to **Add | Listener | View Results in Table**. This action
    will add a new node to our tests and, as soon as we start the test, the results
    will appear in the application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经建立了一个基本的测试，现在是时候看看结果了。让我们探索一些有趣的方法来收集测试的信息。为了查看和分析我们测试的每次迭代的结果，我们需要添加一个**监听器**。要做到这一点，就像在之前的步骤中一样，右键单击**线程组**，然后导航到**添加
    | 监听器 | 在表中查看结果**。这个操作将在我们的测试中添加一个新的节点，一旦我们开始测试，结果将出现在应用程序中。
- en: If you had selected the **Forever** option in the **Thread Group**, you need
    to stop your test by hand. You can do it with the red cross icon displayed next
    to the green play. This button will stop the tests waiting for each thread to
    end their actions. If you click on the stop icon, Apache JMeter will kill all
    the threads immediately.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在**线程组**中选择了**永远**选项，则需要手动停止测试。您可以使用绿色播放旁边显示的红色十字图标来停止。此按钮将停止等待每个线程结束其操作的测试。如果单击停止图标，Apache
    JMeter将立即终止所有线程。
- en: 'Let’s give it a try and click on the green play icon to start your test. Click
    on your **View Results in Table** node and you will see all the results of the
    test appearing:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试，点击绿色播放图标开始测试。点击**查看结果表**节点，您将看到测试结果的所有结果出现：
- en: '![Executing load tests with Apache JMeter](graphics/B06142_10_05.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![使用Apache JMeter执行负载测试](graphics/B06142_10_05.jpg)'
- en: Apache JMeter Results in Table
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Apache JMeter表中的结果
- en: As you can see in the preceding screenshot, Apache JMeter records different
    data for each request, such as the amount of bytes sent/returned, the status,
    or the request latency, among others. All this data is interesting to analyze
    the behaviour of your application when you change the amount of load and with
    this Listener, you can even export the data so that you can use external tools
    to analyze the results.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，Apache JMeter为每个请求记录了不同的数据，例如发送/返回的字节数，状态或请求延迟等。当您更改负载量时，所有这些数据都很有趣。使用此监听器，您甚至可以导出数据，以便使用外部工具分析结果。
- en: 'If you don’t have external tools to analyze your data with, but you want to
    have some basic stats to compare with the different loads you are exposing your
    application to, you can add another interesting Listener. As we did before, open
    the right-click context menu of the **Thread Group** and navigate to `Add` | **Listener** | `Summary
    Report`. This listener will give you some basic stats that you can use to compare
    results:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有外部工具来分析数据，但是您想要一些基本的统计数据来与您的应用程序暴露给不同负载进行比较，您可以添加另一个有趣的监听器。与之前一样，打开**线程组**的右键上下文菜单，导航到`添加`
    | **监听器** | `摘要报告`。此监听器将为您提供一些基本统计数据，供您用于比较结果：
- en: '![Executing load tests with Apache JMeter](graphics/B06142_10_06.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![使用Apache JMeter执行负载测试](graphics/B06142_10_06.jpg)'
- en: Apache JMeter Summary Report
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Apache JMeter摘要报告
- en: As you can see from the preceding screenshot, this listener has given us some
    averages from our measurements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，此监听器为我们提供了一些测量的平均值。
- en: 'Using a table to show the results is fine. However, as we all know, a picture
    is worth a thousand words, so let’s add a few graph listeners so that you can
    complete your load testing report. Right-click on the **Thread Group** and, in
    the context menu, go to **Add** | **Listener** | **Response Time Graph**. You
    will see a screen similar to the following one:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表格显示结果是可以的。但是众所周知，一张图片胜过千言万语，因此让我们添加一些图形监听器，以便您完成负载测试报告。右键单击**线程组**，在上下文菜单中转到**添加**
    | **监听器** | **响应时间图**。您将看到一个类似于以下的屏幕：
- en: '![Executing load tests with Apache JMeter](graphics/B06142_10_07.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![使用Apache JMeter执行负载测试](graphics/B06142_10_07.jpg)'
- en: Apache JMeter Response Time Graph
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Apache JMeter响应时间图
- en: 'Feel free to make some changes to the default settings. For instance, you can
    reduce the **Interval (ms)**. If you run your tests again, all the data generated
    by the test will be used to generate a nice graph, such as the following one:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 随意对默认设置进行一些更改。例如，您可以减少**间隔（毫秒）**。如果再次运行测试，测试生成的所有数据将用于生成一个漂亮的图表，如下图所示：
- en: '![Executing load tests with Apache JMeter](graphics/B06142_10_08-1.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![使用Apache JMeter执行负载测试](graphics/B06142_10_08-1.jpg)'
- en: Response time graph
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 响应时间图
- en: As you can see from the graph generated from our test results, the increase
    of threads (users) leads to an increase in the response times. What do you think
    this means? If you said that our testing infrastructure needs to scale up to accommodate
    the increase in the loading, your response is correct.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的测试结果生成的图表中可以看出，线程（用户）的增加导致响应时间的增加。你认为这意味着什么？如果你说我们的测试基础设施需要扩大以适应负载的增加，那么你的回答是正确的。
- en: Apache JMeter comes with multiple options to create your loading test. We have
    only showed you how to create a basic test and how to see the results. Now, it’s
    your turn to explore all the different options available to create advanced tests
    and discover which features are more suitable for your project. Let’s see some
    other tools that you can use for your load tests.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Apache JMeter具有多个选项来创建您的负载测试。我们只向您展示了如何创建基本测试以及如何查看结果。现在轮到您探索所有可用的不同选项来创建高级测试，并发现哪些功能更适合您的项目。让我们看看您可以用于负载测试的其他工具。
- en: Load testing with Artillery
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Artillery进行负载测试
- en: '**Artillery** is an open source toolkit that you can use to do load testing
    to your application, and it is similar to Apache JMeter. Among other features,
    we can highlight the following advantages of this tool:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**Artillery**是一个开源工具包，您可以使用它对应用程序进行负载测试，它类似于Apache JMeter。除其他功能外，我们可以强调此工具的以下优点：'
- en: Support for multiple protocols, and HTTP(S) or WebSockets come out of the box
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多种协议，HTTP(S)或WebSockets可以直接使用
- en: Easy to integrate with real-time reporting software or services like DataDog
    an InfluxDB
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于与实时报告软件或DataDog和InfluxDB等服务集成
- en: High performance, so it can be used on commodity hardware/servers
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高性能，因此可以在普通硬件/服务器上使用
- en: Very easy to extend, so it can be adapted to your needs
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常容易扩展，因此可以根据您的需求进行调整
- en: Different report options with detailed performance metrics
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有详细性能指标的不同报告选项
- en: Very flexible, so you can test practically any possible scenario
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常灵活，因此您可以测试几乎任何可能的场景
- en: Installing Artillery
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Artillery
- en: Artillery was built on node.js, so the main requirement is to have this runtime
    installed on the machine you will use to fire the tests.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Artillery是基于node.js构建的，因此主要要求是在您将用于执行测试的计算机上安装此运行时。
- en: We love the containerization technology but unfortunately there is no easy way
    of using artillery on Docker without a dirty hack. In any case we recommend you
    to use a dedicated VM or server were you can fire your load testings.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢容器化技术，但不幸的是，在Docker上使用artillery没有简单的方法，除非进行一些不干净的操作。无论如何，我们建议您使用专用的VM或服务器进行负载测试。
- en: To use Artillery you need node.js in your VM/server and this software is very
    easy to install. We are not going to explain how to create a local VM (you can
    use VirtualBox or VMWare to create one), we are only going to show you how you
    can install it on RHEL/CentOS. For other OSes and options, you can find detailed
    information on the node.js documentation ([https://nodejs.org/en/download/](https://nodejs.org/en/download/)).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Artillery，您需要在您的VM/server中安装node.js，这个软件非常容易安装。我们不打算解释如何创建本地VM（您可以使用VirtualBox或VMWare创建一个），我们只会向您展示如何在RHEL/CentOS上安装它。对于其他操作系统和选项，您可以在node.js文档中找到详细信息（[https://nodejs.org/en/download/](https://nodejs.org/en/download/)）。
- en: 'Open the terminal of your RHEL/CentOS VM or server and download the setup script
    for the LTS version:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的RHEL/CentOS虚拟机或服务器的终端，并下载LTS版本的设置脚本：
- en: '[PRE1]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As soon as the previous command finishes, you need to execute the next command
    as root, as shown in the following command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上一个命令完成，您需要以root身份执行下一个命令，如下所示：
- en: '[PRE2]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After executing the previous commands you will have Node.js installed and ready
    in your VM/server. It is time to install Artillery with the Node.js package manager,
    the `npm` command. In your terminal, execute the following command to install
    globally Artillery:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述命令后，您的VM/server将安装并准备好Node.js。现在是时候使用Node.js包管理器`npm`命令全局安装Artillery了。在您的终端中，执行以下命令以全局安装Artillery：
- en: '[PRE3]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As soon as the previous command finishes, you will have Artillery ready to use
    it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上一个命令完成，您就可以使用Artillery了。
- en: 'The first thing we can do is to check that Artillery was correctly installed
    and that it is available. Enter the following command to do it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第一件事是检查Artillery是否已正确安装并可用。输入以下命令进行检查：
- en: '[PRE4]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding command will show you a lovely dinosaur, which means that Artillery
    is ready to be used.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将向您显示一个可爱的恐龙，这意味着Artillery已经准备好使用了。
- en: Executing loading tests with Artillery
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Artillery执行负载测试
- en: 'Artillery is a very flexible toolkit. You can run your tests from the console
    or you can have YAML or JSON files, which describe your testing scenarios, and
    run them. Please note that in our following examples we are using `microservice_secret_nginx`
    as the host we are going to test, you need to adjust this host to the IP address
    of your local environment. Let’s give you a sneak peek of this tool; run the following
    command in our load testing VM/server:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Artillery是一个非常灵活的工具包。您可以从控制台运行测试，也可以使用描述测试场景的YAML或JSON文件运行它们。请注意，在我们的以下示例中，我们使用`microservice_secret_nginx`作为我们要测试的主机，您需要将此主机调整为您本地环境的IP地址。让我们来看看这个工具；在我们的负载测试VM/server中运行以下命令：
- en: '[PRE5]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding command will do a quick test in a duration of 30 seconds. In
    this time, Artillery will create five virtual users; each one of them will do
    one GET request to the provided URL. As soon as the preceding command is executed,
    Artillery will start the tests and print some stats every 10 seconds. At the end
    of the tests (30 seconds), this tool will show you a small report similar to the
    following one:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在30秒的时间内进行快速测试。在此期间，Artillery将创建五个虚拟用户；每个用户将对提供的URL进行一次GET请求。一旦执行了上述命令，Artillery将开始测试并每10秒打印一些统计信息。在测试结束时（30秒），此工具将向您显示一个类似于以下的小报告：
- en: '[PRE6]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding report is very easy to understand and gives you an overview of how
    your infrastructure and app are performing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上述报告非常易于理解，并为您提供了基础设施和应用程序的绩效概述。
- en: 'A basic concept you need to understand before we start analyzing the Artillery
    report is the concept of Scenarios. In a few words, a **Scenario** is a sequence
    of tasks or actions you want to test, and they are related. Imagine that you have
    an e-commerce application; a testing scenario can be all the steps a user performs before
    they complete a purchase. Consider the following example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始分析Artillery报告之前，您需要了解的一个基本概念是场景的概念。简而言之，**场景**是您想要测试的一系列任务或操作，它们是相关的。想象一下，您有一个电子商务应用程序；一个测试场景可以是用户在完成购买之前执行的所有步骤。考虑以下示例：
- en: The user loads the home.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户加载主页。
- en: The user searches for a product.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户搜索产品。
- en: The user adds a product to the basket.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户向购物篮中添加产品。
- en: The user goes to the checkout.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户去结账。
- en: The user makes the purchase.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户进行购买。
- en: All the mentioned actions can be transformed into a request to your application
    that simulates the user action, which means that a scenario is a group of requests.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 所有提到的操作都可以转换为对您的应用程序的请求，模拟用户操作，这意味着一个场景是一组请求。
- en: Now that we have this concept clear, we can start analyzing the report output
    from Artillery. In our sample, we only have one scenario with only one request
    (`GET`) to `http://microservice_secret_nginx/api/v1/secret/`. This testing scenario
    is executed by five virtual users who fire only one `GET` request for 30 seconds.
    A simple math calculation, `5 * 1 * 30`, gives us the total of scenarios tested
    (`150`), which is the same amount of requests in our case. The `RPS sent` field
    gives you the average requests per second our test server has made during our
    tests. It is not a very important field, but it gives you an idea about how the
    test is performed.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们清楚了这个概念，我们可以开始分析Artillery输出的报告。在我们的示例中，我们只有一个场景，只有一个请求（`GET`）到`http://microservice_secret_nginx/api/v1/secret/`。这个测试场景由五个虚拟用户执行，他们在30秒内只发出一个`GET`请求。一个简单的数学计算，`5
    * 1 * 30`，给出了我们测试的场景总数（`150`），这与我们的情况下的请求总数相同。`RPS sent`字段给出了我们的测试服务器在测试期间平均每秒发送的请求。这不是一个非常重要的字段，但它可以让您了解测试的执行情况。
- en: Let’s check the `Request latency` and `Scenario duration` stats given by Artillery.
    The first thing you need to know is that all the measures from these groups are
    measured in milliseconds.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Artillery给出的`Request latency`和`Scenario duration`统计数据。您需要知道的第一件事是，这些组的所有测量都是以毫秒为单位的。
- en: In the case of `Request latency`, the data is showing us the time used by our
    application to process the requests we have sent. Two important stats are the
    95% (`p95`) and the 99% (`p99`). As you probably already know, the percentile
    is a measure used in statistics that indicates the value under which a given percentage
    of observations fall. From our example, we can see that 95% of the requests were
    processed in 1,146.5 milliseconds or less or that 99% of them were processed in
    1,191.1 milliseconds or less.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Request latency`的情况下，数据向我们展示了应用程序处理我们发送的请求所用的时间。两个重要的统计数据是95%（`p95`）和99%（`p99`）。您可能已经知道，百分位数是统计学中用于指示给定百分比观察值落在其下的值的度量。从我们的示例中，我们可以看到95%的请求在1146.5毫秒或更短的时间内被处理，或者99%的请求在1191.1毫秒或更短的时间内被处理。
- en: The stats shown in the `Scenario duration` in our example are pretty much the
    same as the `Request latency`, because each scenario is formed by only one request.
    If you create more complex scenarios with multiple requests on each one, the data
    of both the groups will differ.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`Scenario duration`中显示的统计数据与`Request latency`几乎相同，因为每个场景只包含一个请求。如果您创建了更复杂的场景，每个场景包含多个请求，那么这两组数据将有所不同。
- en: Creating Artillery scripts
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Artillery脚本
- en: As we have told you before, Artillery allows you to create YAML or JSON files
    with the load testing scenarios. Let’s transform our quick example into a YAML file
    so that you can keep it in a repository for future executions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前告诉过您的，Artillery允许您创建YAML或JSON文件来进行负载测试场景。让我们将我们的快速示例转换为一个YAML文件，这样您就可以将其保存在存储库中以备将来执行。
- en: 'To do this, you only need to create a file in our testing container called,
    for example, `test-secret.yml`, with the following content:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，您只需要在我们的测试容器中创建一个名为`test-secret.yml`的文件，内容如下：
- en: '[PRE7]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see in the preceding code, it is similar to our `artillery quick`
    command, but now you can store them in your code repository to run it again and
    again against your application.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上文中所看到的，它与我们的`artillery quick`命令类似，但现在您可以将它们存储在您的代码存储库中，以便反复针对您的应用程序运行。
- en: You can run your test with the `artillery run test-secret.yml` command and the
    results should be similar to those generated by the quick command.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`artillery run test-secret.yml`命令运行您的测试，结果应该与快速命令生成的结果类似。
- en: The Docker container images come with the minimum software needed, so you probably
    can’t find a text editor in our load testing image. At this point of the book,
    you will be able to create a Docker volume and attach it to our testing container
    so that you can share files.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器镜像只包含所需的最小软件，因此您可能无法在我们的负载测试镜像中找到文本编辑器。在本书的这一部分，您将能够创建一个Docker卷并将其附加到我们的测试容器，以便您可以共享文件。
- en: Advanced scripting
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级脚本编写
- en: One of the highlighted features of this toolkit is the ability to create custom
    scripts, but you are not only attached to fire static requests. This tool allows
    you to randomize the requests using external CSV files, parsing JSON responses,
    or inline values from the script.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具包的一个突出特点是能够创建自定义脚本，但您不仅仅局限于发送静态请求。该工具允许您使用外部CSV文件、解析JSON响应或脚本中的内联值来随机化请求。
- en: 'Imagine that you want to test your API endpoint responsible for the creation
    of new accounts in your application and instead of using YAML files, you are using
    a JSON script. You can use an external CSV file with the user data to be used
    in the tests with the following adjustments:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要测试负责在您的应用程序中创建新帐户的API端点，而不是使用YAML文件，您正在使用JSON脚本。您可以使用外部CSV文件与以下调整一起在测试中使���用户数据：
- en: '[PRE8]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding `config` fields will tell Artillery where our CSV file is located
    and the different columns used in the CSV. Once we have set up our external file,
    we can use this data in our scenarios. In our example, Artillery will pick random
    rows from `test-data.csv` and generate post request to `/api/v1/user` with that
    data. The fields field from `payload` will create variables we can use, such as 
    `{{ variableName }}`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`config`字段将告诉Artillery我们的CSV文件的位置以及CSV中使用的不同列。设置好外部文件后，我们可以在场景中使用这些数据。在我们的示例中，Artillery将从`test-data.csv`中随机选择行，并使用这些数据生成对`/api/v1/user`的post请求。`payload`中的字段将创建我们可以使用的变量，比如`{{
    variableName }}`。'
- en: 'Creating this kind of scripts seems easy but, at some point of the creation
    of your scripts, you will need some debug information to know what your script
    is doing. If you want to see the details of every request, you can run your script
    as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这种类型的脚本似乎很容易，但是在创建脚本的过程中，您可能需要一些调试信息来了解您的脚本在做什么。如果您想查看每个请求的详细信息，可以按照以下方式运行您的脚本：
- en: '[PRE9]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the case of you wanting to also see the responses, you can run the load
    testing scripts as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要查看响应，可以按照以下方式运行负载测试脚本：
- en: '[PRE10]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Unfortunately, there is no space in the book to cover, in great detail, all
    the options available in Artillery. However, we wanted to show you an interesting
    tool that you can use to do load testing. If you need more information or even
    if you want to contribute to the project, you only need to go to the project’s
    page ([https://artillery.io](https://artillery.io)).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，本书中没有足够的空间来详细介绍Artillery中的所有可用选项。但是，我们想向您展示一个有趣的工具，您可以使用它进行负载测试。如果您需要更多信息，甚至如果您想要为项目做出贡献，您只需要访问项目的页面（[https://artillery.io](https://artillery.io)）。
- en: Load testing with siege
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用siege进行负载测试
- en: 'Siege is an interesting multithread HTTP(s) load testing and benchmarking tool.
    It seems small and simple compared with other tools, but it is efficient and easy
    to use, for example, to do a quick test to your latest changes. This tool allows
    you to hit an HTTP(S) endpoint with a configurable number of concurrent virtual
    users and it can be used in three different modes: regression, Internet simulation,
    and brute force.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Siege是一个有趣的多线程HTTP(s)负载测试和基准测试工具。与其他工具相比，它似乎小而简单，但它高效且易于使用，例如，对您最新更改进行快速测试。此工具允许您使用可配置数量的并发虚拟用户命中HTTP(S)端点，并且可以在三种不同模式下使用：回归、互联网模拟和暴力。
- en: Siege was developed for GNU/Linux, but it has been successfully ported to AIX,
    BSD, HP-UX, and Solaris. If you want to compile it, you shouldn’t have any problem
    on most System V UNIX variants and on most newer BSD systems.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Siege是为GNU/Linux开发的，但已成功移植到AIX、BSD、HP-UX和Solaris。如果您想要编译它，在大多数System V UNIX变体和大多数较新的BSD系统上都不应该有任何问题。
- en: Installing siege on RHEL, CentOS, and similar operating systems
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在RHEL、CentOS和类似的操作系统上安装siege
- en: 'If you use CentOS with the extras repository enabled, you can install the EPEL repo
    with a simple command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用启用了额外存储库的CentOS，您可以使用一个简单的命令安装EPEL存储库：
- en: '[PRE11]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As soon as you have the EPEL repo available, you only need to do a `sudo yum
    install siege` to have this tool available in your OS.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了EPEL存储库，您只需要执行`sudo yum install siege`就可以在您的操作系统中使用此工具。
- en: 'Sometimes, the `sudo yum install epel-release` command does not work, for example,
    when you are not using Centos, your distribution is RHEL or a similar one. In
    these cases, you can install the EPEL repository by hand with the following commands:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，例如当您不使用Centos时，`sudo yum install epel-release`命令不起作用，您的发行版是RHEL或类似的发行版。在这些情况下，您可以使用以下命令手动安装EPEL存储库：
- en: '[PRE12]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once the EPEL repository is available in your OS, you can `install siege` with
    the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦EPEL存储库在您的操作系统中可用，您可以使用以下命令`安装siege`：
- en: '[PRE13]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Installing siege on Debian or Ubuntu
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Debian或Ubuntu上安装siege
- en: 'Siege is very easy to install on Debian or Ubuntu with the official repositories.
    If you have one of the latest version of these OSs, you only need to execute the
    following commands:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian或Ubuntu上安装siege非常简单，只需使用官方存储库。如果您有这些操作系统的最新版本之一，您只需要执行以下命令：
- en: '[PRE14]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding commands will update your system and install the `siege` package.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将更新您的系统并安装`siege`软件包。
- en: Installing siege on other OS
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在其他操作系统上安装siege
- en: If your OS wasn’t covered in the previous steps, you can do it by compiling
    the sources, there are plenty of how-tos on the Internet explaining what you need
    to do.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的操作系统在之前的步骤中没有涵盖，您可以通过编译源代码来完成，互联网上有很多说明您需要做什么的教程。
- en: Quick siege example
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速siege示例
- en: 'Let’s create a quick text to one of our endpoints. In this case, we will test
    our endpoint in 30 seconds with 50 concurrent users. Open the terminal of the
    machine you have siege installed in and type in the following command. Feel free
    to change the command to the correct host or endpoint:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速创建一个文本到我们的一个端点。在这种情况下，我们将在30秒内使用50个并发用户测试我们的端点。打开您安装了siege的机器的终端，并输入以下命令。随意更改命令以正确的主机或端点：
- en: '[PRE15]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding command is explained in the following points:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在以下几点中得到解释：
- en: '`-c50` : Create 50 concurrent users'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c50`：创建50个并发用户'
- en: '`-d10` : Delay each simulated user for a random number of seconds between 1
    and 10'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d10`：每个模拟用户之间的延迟为1到10秒之间的随机秒数'
- en: '`-t30s` : Time to run the test; 30 seconds in our case'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t30s`：运行测试的时间；在我们的情况下为30秒'
- en: '`http://localhost:8083/api/v1/secret/` : Endpoint to be tested'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8083/api/v1/secret/`：要测试的端点'
- en: 'As soon as you hit *Enter*, the `siege` command will start firing requests
    to your server and you will have an output similar to the following one:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您按下*Enter*，`siege`命令将开始向服务器发送请求，并且您将获得类似以下的输出：
- en: '[PRE16]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After around 30 seconds, siege will stop the requests and show you some stats,
    such as the following ones:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 大约30秒后，siege将停止请求并向您显示一些统计信息，例如以下内容：
- en: '[PRE17]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: From the preceding results, we can conclude that all our requests were okay,
    none of our requests failed, and the average response time was 3.33 seconds. As
    you can see, this tool is simpler and it can be used on a day-to-day basis to
    check at which level of concurrent users your application starts throwing errors
    or to put the app under stress while you check other metrics.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述结果中，我们可以得出结论，我们所有的请求都没有问题，没有一个请求失败，平均响应时间为3.33秒。正如您所看到的，这个工具更简单，可以在日常基础上使用，以检查您的应用程序从哪个并发用户级别开始出现错误，或者在您检查其他指标时将应用程序置于压力之下。
- en: Scalability plan
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性计划
- en: A **scalability plan** is a document that describes all the different components
    of your application and the necessary steps to scale the application as soon as
    it is needed. The scalability plan is a live document, so you need to review it
    and keep it updated frequently.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展性计划**是一份描述应用程序的所有不同组件以及在需要时扩展应用程序所需步骤的文件。可扩展性计划是一份实时文件，因此您需要经常审查并保持更新。'
- en: There is no master template ready to fill as the scalability plan is more an
    internal document with all the information you need to make the right decision
    about the scalability of your app. Our recommendation is to use the scalability
    plan as your guide, including all the contents of your capacity plan, you can
    even add how to hire new workers to this document.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可扩展性计划更多地是一个内部文件，其中包含您需要做出关于应用程序可扩展性的正确决策的所有信息，因此没有准备好填写的主模板。我们建议使用可扩展性计划作为您的指南，包括您的容量计划的所有内容，甚至可以将如何雇佣新员工添加到此文档中。
- en: 'Some of the sections you can have in your scalability plan can be the following
    ones:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您的可扩展性计划中可能包括以下部分：
- en: An overview of the application and its components
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序及其组件的概述
- en: Comparison of cloud providers or places where you will deploy your application
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云提供商或您将部署应用程序的地点的比较
- en: Resume of your capacity plan and theoretical limits of the application
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的容量计划和应用程序的理论极限的总结
- en: Scalability phases or steps
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性阶段或步骤
- en: Provisioning times and costs
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置时间和成本
- en: Organization scalability steps
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织可扩展性步骤
- en: The preceding sections are only a suggestion, feel free to add or remove any
    section to fit in your business plan.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分只是一个建议，随时可以添加或删除任何部分以适应您的业务计划。
- en: 'Here''s an overview of some sections of the capacity plan. Imagine that we
    have our example microservices application ready and want to start scaling from
    the minimum resources available. First, we can describe the different elements
    we have in our application as a basic inventory from which we evolve our application:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是容量计划的一些部分概述。假设我们的示例微服务应用程序已准备就绪，并且希望从最低资源开始扩展。首先，我们可以将我们应用程序中的不同元素描述为基本清单，从而使我们的应用程序得以发展：
- en: Battle microservice
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 战斗微服务
- en: NGINX
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NGINX
- en: PHP 7 fpm
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 7 fpm
- en: Location microservice
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置微服务
- en: NGINX
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NGINX
- en: PHP 7 fpm
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 7 fpm
- en: Secret microservice
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密微服务
- en: NGNIX
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NGNIX
- en: PHP 7 fpm
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 7 fpm
- en: User microservice
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户微服务
- en: NGINX
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NGINX
- en: PHP 7 fpm
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 7 fpm
- en: Data storage layer
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储层
- en: 'Database: Percona'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库：Percona
- en: As you can see, we have described each component needed for our application,
    and we have started sharing the data layer between all the microservices. We didn’t
    add any cache layer; also, we didn’t add any autodiscovery and telemetry service
    (we will add extra features in the following steps).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已经描述了我们应用程序所需的每个组件，并开始在所有微服务之间共享数据层。我们没有添加任何缓存层；此外，我们也没有添加任何自动发现和遥测服务（我们将在接下来的步骤中添加额外功能）。
- en: Once we have our minimum requirements, let’s take a look at the different steps
    we can have in our scalability plan.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们满足了最低要求，让我们来看看我们的可扩展性计划中可以有哪些不同步骤。
- en: 'Step #0'
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第0步
- en: 'In this step, we will have all our requirements in one machine even though
    it is not production ready yet because your application cannot survive an issue
    in your machine. A single server with the following characteristics will be enough:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，即使应用程序尚未准备好投入生产，我们将在一台机器上满足所有我们的要求，因为您的应用程序无法在机器出现问题时生存。以下特征的单个服务器将足够：
- en: 8 GB RAM
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8 GB RAM
- en: 500 GB disk
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 500 GB磁盘
- en: 'The base OS will be RHEL or CentOS, with the following software installed:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 基本操作系统将是RHEL或CentOS，并安装以下软件：
- en: NGINX with multiple vhosts setup
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有多个虚拟主机设置的NGINX
- en: Git
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Percona
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Percona
- en: PHP 7 fpm
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 7 fpm
- en: In this step, the provisioning time can be a few hours. We not only need to
    spin up the server, but also need to set up each one of the required services
    (NGINX, Percona, and others). Using tools such as Ansible can help us with the
    quick and repeatable provisioning.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，配置时间可能需要几个小时。我们不仅需要启动服务器，还需要设置所需服务（NGINX、Percona等）。使用诸如Ansible之类的工具可以帮助我们快速和可重复地进行配置。
- en: 'Step #1'
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1步
- en: At this point you are getting the application ready for production, choosing
    between VM or containers (in our case, we have decided to use containers for flexibility
    and performance), splitting the single server configuration into multiple servers
    dedicated to each service required, like our previous requirements, and adding
    autodiscovery and telemetry services.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您正在为生产环境准备应用程序，选择虚拟机或容器（在我们的情况下，我们决定使用容器以获得灵活性和性能），将单个服务器配置拆分为专用于每个所需服务的多个服务器，如我们之前的要求，并添加自动发现和遥测服务。
- en: 'You can find a small description of the architecture of our application at
    this step:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，您可以找到我们应用程序架构的简要描述：
- en: Autodiscovery
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动发现
- en: Hashicorp Consul container with ContainerPilot
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有ContainerPilot的Hashicorp Consul容器
- en: Telemetry
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遥测
- en: Prometheus container with ContainerPilot
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有ContainerPilot的Prometheus容器
- en: Battle microservice
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 战斗微服务
- en: NGINX container with ContainerPilot
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有ContainerPilot的NGINX容器
- en: PHP 7 fpm container with ContainerPilot
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有ContainerPilot的PHP 7 fpm容器
- en: Location microservice
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置微服务
- en: NGINX container with ContainerPilot
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有ContainerPilot的NGINX容器
- en: PHP 7 fpm container with ContainerPilot
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有ContainerPilot的PHP 7 fpm容器
- en: Secret microservice
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密微服务
- en: NGINX container with ContainerPilot
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有ContainerPilot的NGINX容器
- en: PHP 7 fpm container with ContainerPilot
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有ContainerPilot的PHP 7 fpm容器
- en: User microservice
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户微服务
- en: NGINX container with ContainerPilot
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有ContainerPilot的NGINX容器
- en: PHP 7 fpm container with ContainerPilot
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有ContainerPilot的PHP 7 fpm容器
- en: Data storage layer
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储层
- en: 'Database: Percona container with ContainerPilot'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有ContainerPilot的Percona容器
- en: The provisioning time in this step will be reduced from hours, like the preceding step,
    to minutes. We have an autodiscovery service (HashiCorp Consul) in place and,
    thanks to ContainerPilot, each of our different components will register itself
    in the autodiscovery register and it will auto setup. In a few minutes, we can
    have all the containers provisioned and set up.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，配置时间将从前一步的几小时减少到几分钟。我们已经有了一个自动发现服务（HashiCorp Consul），并且由于ContainerPilot，我们的每个不同组件将在自动发现注册中注册自己，并自动设置。几分钟内，我们可以完成所有容器的配置和设置。
- en: 'Step #2'
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2步
- en: In this step of your scalability planning, you will be adding cache layers to
    all the application microservices to reduce the number of requests and improve
    the overall performance. To improve the performance, we decided to use Redis as
    our cache engine, so you need to create a Redis container on each microservice.
    The provisioning time for this step will be like the previous one but measured
    in minutes.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的可扩展性规划的这一步中，您将为所有应用程序微服务添加缓存层，以减少请求数量并提高整体性能。为了提高性能，我们决定使用Redis作为我们的缓存引擎，因此您需要在每个微服务上创建一个Redis容器。这一步的配置时间将与上一步相似，但以分钟为单位。
- en: 'Step #3'
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3步
- en: In this step, you will be moving the storage layer to each microservice, adding
    three Percona containers in Master-Slave mode with automatic setup with ContainerPilot
    and Consul.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，您将把存储层移动到每个微服务中，使用ContainerPilot和Consul自动设置Master-Slave模式的三个Percona容器。
- en: The provisioning time for this step will be like the previous one, measured
    in minutes.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步的配置时间将与上一步相似，以分钟为单位。
- en: 'Step #4'
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4步
- en: In this step of the scalability plan you will be studying the load and usage
    patterns of the application. You will add load balancers in front of the NGINX
    containers to have more flexibility. Thanks to this new layer, we can do A/B testing
    or Blue/Green deployments, among other features. Some interesting and open source
    tools you can use in this case are Fabio Proxy and Traefik.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在可扩展性计划的这一步中，您将研究应用程序的负载和使用模式。您将在NGINX容器前面添加负载均衡器，以获得更大的灵活性。由于这个新层，我们可以进行A/B测试或蓝/绿部署，以及其他功能。在这种情况下，您可以使用一些有趣的开源工具，如Fabio代理和Traefik。
- en: The provisioning time for this step will be like the previous one, measured
    in minutes.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步的预配时间将与上一步相似，以分钟为单位。
- en: 'Step #5'
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5步
- en: At this final step you will be checking again the application infrastructure
    to keep it up to date and scaling up and horizontally when necessary.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这最后一步中，您将再次检查应用程序基础设施，使其保持最新，并在必要时进行水平扩展。
- en: The provisioning time for this step will be like the previous one, measured
    in minutes.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步的预配时间将与上一步相似，以分钟为单位。
- en: As we told you before, the scalability plan is a live document, so you need
    to revise it frequently. Imagine that a new database software is created in a
    few months and it is optimal for high loads; you can review your scalability plan
    and introduce this new database in your infrastructure. Feel free to add all the
    information you consider important for the scalability of your application.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前告诉过您的，可扩展性计划是一个动态文件，因此您需要经常进行修订。想象一下，几个月后会有一种新的数据库软件问世，它非常适合高负载；您可以审查您的可扩展性计划，并将这个新数据库引入您的基础设施。请随意添加您认为对应用程序的可扩展性重要的所有信息。
- en: Summary
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we showed you how to check the limits of your application,
    which gives you an idea about the possible bottlenecks you will be fighting with.
    We also showed you the basic concepts you need to have to create your capacity
    and scalability plans. We also showed you a few options to do some load testing
    to your application. You should have enough knowledge to have your application
    ready for heavy use, or at least you know the weak points of your app.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您展示了如何检查应用程序的限制，这可以让您了解可能会遇到的瓶颈。我们还向您展示了创建容量和可扩展性计划所需的基本概念。我们还向您展示了一些对应用程序进行负载测试的选项。您应该有足够的知识，使您的应用程序能够应对高负载使用，或者至少了解您应用程序的薄弱点。
