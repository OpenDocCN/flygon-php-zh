- en: Chapter 7. Functional Techniques and Topics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。函数式技术和主题
- en: We've covered the foundational techniques relative to functional programming.
    But, as you can probably imagine, there are a lot more topics to cover. In this
    chapter, you will learn about some of those patterns and ideas.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了与函数式编程相关的基础技术。但是，你可能可以想象，还有很多其他主题需要涵盖。在本章中，你将学习一些这些模式和想法。
- en: Some topics will be covered in depth and others will be mentioned with pointers
    to external resources if you want to learn more. As this is an introductory book
    to functional programming in PHP, the most advanced ideas are out of scope. If
    you encounter an article about such a topic somewhere, you should, however, have
    enough understanding to grasp at least the gist of it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一些主题将被深入讨论，其他主题将被提及，并指向外部资源，如果你想了解更多。由于这是一本关于PHP函数式编程的入门书，最先进的想法超出了范围。然而，如果你在某个地方遇到了关于这样一个主题的文章，你应该有足够的理解力，至少能够理解其要点。
- en: The sections of this chapter are not necessarily linked with one another. Some
    content might be novel to you and some is linked to excerpts presented earlier.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的各节并不一定彼此关联。有些内容可能对你来说是新的，有些则与之前呈现的摘录相关。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Type systems, type signature, and their uses
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型系统、类型签名及其用途
- en: Point-free style
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无点风格
- en: Using the `const` keyword to facilitate anonymous function usage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`const`关键字来方便匿名函数的使用
- en: Recursion, stack overflows, and trampolines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归、堆栈溢出和跳板
- en: Pattern matching
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Type classes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型类
- en: Algebraic structures and category theory
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代数结构和范畴论
- en: Monad transformers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单子变换器
- en: Lenses
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜头
- en: Type systems
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型系统
- en: 'Disclaimer: I have no intention to launch quarrels between static and dynamic
    typing aficionados. Discussing which one is better and why is not at all the objective
    of this book and I''ll let each and every one of you decide what you prefer. If
    the subject interests you, I can recommend reading [http://pchiusano.github.io/2016-09-15/static-vs-dynamic.html](http://pchiusano.github.io/2016-09-15/static-vs-dynamic.html),
    which is a good summary, even if a bit biased in favor of static typing.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 免责声明：我并不打算在静态和动态类型的爱好者之间挑起争端。讨论哪种更好以及为什么并不是本书的目标，我会让你们每个人自己决定喜欢什么。如果你对这个主题感兴趣，我可以推荐阅读[http://pchiusano.github.io/2016-09-15/static-vs-dynamic.html](http://pchiusano.github.io/2016-09-15/static-vs-dynamic.html)，这是一个很好的总结，尽管有点偏向静态类型。
- en: That is said, types and typing systems are an important topic in functional
    programming, even if said types aren't enforced by the language. The types of
    a function signature are a meta language enabling succinct and effective communication
    about the purpose of a function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，类型和类型系统是函数式编程中的重要主题，即使这些类型并不是由语言强制执行的。函数签名的类型是一种元语言，可以简洁有效地传达有关函数目的的信息。
- en: As we will see, clearly declaring the expected types of the input and output
    of a function is an important part of its documentation. Not only does it reduce
    the cognitive burden by allowing you to skip reading the function code, it also
    allows you to deduce important facts about what is happening and derive *free
    theorems*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的那样，清楚地声明函数的输入和输出的预期类型是其文档的重要部分。它不仅通过允许你跳过阅读函数代码来减轻认知负担，还允许你推断出关于正在发生的重要事实并推导出“自由定理”。
- en: The Hindley-Milner type system
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hindley-Milner类型系统
- en: Hindley-Milner, also known as Damas-Milner or Damas-Hindley-Milner, from the
    name of the people whom first theorized it, is a type system. A type system is
    a set of rules that define what type a variable or parameter can have and how
    different types interact with each other.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Hindley-Milner，也称为Damas-Milner或Damas-Hindley-Milner，以最早理论化它的人的名字命名，是一种类型系统。类型系统是一组规则，定义变量或参数可以具有的类型以及不同类型如何相互作用。
- en: One of the main features of Hindley-Milner is that it allows type inference.
    This means that you often don't have to explicitly define the type; it can be
    inferred from other sources such as the context or the types of surrounding elements.
    To be exact, the type inference is done by an algorithm called **Algorithm W**
    and is related to, but not the same as, the Hindley-Milner type system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Hindley-Milner的主要特点之一是它允许类型推断。这意味着你通常不需要明确地定义类型；它可以从其他来源推断出，比如上下文或周围元素的类型。确切地说，类型推断是由一种叫做**算法W**的算法完成的，它与Hindley-Milner类型系统有关，但并不完全相同。
- en: It also allows polymorphism; this means that if you have a function returning
    the length of a list, the type of the elements of the list doesn't need to be
    known as it doesn't matter for the computation. It is an idea akin to the Generics
    that you can find in C++ or Java, but not quite the same as it is more powerful.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它还允许多态性；这意味着如果你有一个返回列表长度的函数，列表元素的类型不需要被知道，因为它对计算没有影响。这类似于你可以在C++或Java中找到的泛型，但并不完全相同，因为它更加强大。
- en: Most statically typed functional languages, such as Haskell, **OCaml**, and
    **F#**, use Hindley-Milner as their type system, often with extensions to manage
    some edge cases. Scala is notable for using its own type system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数静态类型的函数式语言，如Haskell、OCaml和F#，使用Hindley-Milner作为它们的类型系统，通常还会使用扩展来处理一些边缘情况。Scala以其自己的类型系统而著称。
- en: Besides the theory about type systems, there is a commonly accepted way to describe
    the input and output parameters of a function and this is what we are interested
    in here. It is quite different from the type hints you can use with PHP and it
    is often put in a comment at the top of a function when the language does not
    use this particular syntax. As of now we will refer to such type annotation as
    the *type signature* of a function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关于类型系统的理论，还有一种通常被接受的方法来描述函数的输入和输出参数，这正是我们感兴趣的。这与你可以在PHP中使用的类型提示非常不同，当语言不使用这种特定语法时，它通常被放在函数顶部的注释中。从现在开始，我们将把这样的类型注释称为函数的“类型签名”。
- en: Type signatures
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型签名
- en: 'As a first and simple example, we will start with the type signatures of the
    `strtoupper` and `strlen` PHP functions:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个简单的例子，我们将从`strtoupper`和`strlen` PHP函数的类型签名开始：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It''s pretty simple to understand: we start with the function name, followed
    by the type of the parameter, an arrow, and the type of the return value.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单理解：我们从函数名开始，后面是参数的类型，一个箭头，和返回值的类型。
- en: 'What about functions with multiple arguments? Consider the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 那么有多个参数的函数呢？考虑以下情况：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Why are there multiple arrows? If you think of currying this might help you
    to get the answer. If we write the same function signature using parentheses,
    this will probably help you further:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么有多个箭头？如果您考虑到柯里化，这可能会帮助您得到答案。如果我们使用括号编写相同的函数签名，这可能会进一步帮助您：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Basically, we have a function that takes a `string` type and returns a new
    function taking an array of strings and returning a string. The right most type
    is always the type of the return value. All other types are the various parameters
    in order. Parentheses are used to denote a function. Let''s see how it looks with
    more parameters:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们有一个接受`string`类型并返回一个接受字符串数组并返回字符串的新函数。最右边的类型始终是返回值的类型。所有其他类型都是按顺序的各种参数。括号用于表示函数。让我们看看它在有更多参数的情况下是什么样子的：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or without parentheses:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 或者不使用括号：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I don't know what your opinion is, but I personally prefer the latter as it
    is less noisy and once you get used to it, the parentheses don't bring much information.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道您的意见是什么，但我个人更喜欢后者，因为它的噪音较小，一旦您习惯了它，括号就不会带来太多信息。
- en: 'If you are familiar with the `number_format` function, you might have noted
    that the type signature I proposed contains all parameters, even the optional
    ones. This is because there is no canonical way to convey this information, because
    functional languages usually do not allow such parameters. However, Haskell has
    an `Optional` data type that is used to emulate this. With this information in
    mind, arguments with a default value are sometimes displayed like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉`number_format`函数，您可能已经注意到我提出的类型签名包含所有参数，甚至是可选参数。这是因为没有一种传达这些信息的标准方法，因为函数式语言通常不允许这样的参数。然而，Haskell有一个`Optional`数据类型，用于模拟这一点。有了这些信息，具有默认值的参数有时会显示如下：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This works fairly well and is self-explanatory, until you have a type called
    the `Optional` data type. There is also no common way to express what the default
    value is.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有效，并且很容易理解，直到你有一个名为`Optional`的数据类型。也没有一种常见的方法来表达默认值是什么。
- en: 'As far as I know, there is no way to convey the information that a function
    takes a variable number of arguments. Since PHP 7.0 introduced a new syntax for
    this, I propose we use that for the remainder of this book:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 据我所知，没有办法传达函数接受可变数量参数的信息。由于PHP 7.0引入了一个新的语法，我建议我们在本书的其余部分使用它：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We saw earlier that parentheses are used to express the idea of functions,
    but that they were usually not used for readability reasons. However, this is
    not true when using functions as parameters. In this case, we need to retain the
    information that the function expects or returns another function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到括号用于表示函数的概念，但通常出于可读性的原因通常不使用。然而，当使用函数作为参数时，情况并非如此。在这种情况下，我们需要保留函数期望或返回另一个函数的信息：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You might be asking yourself, What are those `a` and `b` variables? This is
    the polymorphism feature we were talking about earlier. The `array_reduce` and
    `array_map` functions do not care about what the real types of the elements contained
    in the array are, they don't need to know that information to perform their job.
    We could have used `mixed` function like we did earlier with the`printf` method,
    but then we would have lost some useful data.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问自己，那些`a`和`b`变量是什么？这是我们之前谈到的多态特性。`array_reduce`和`array_map`函数不关心数组中包含的元素的真实类型是什么，它们不需要知道这些信息来执行它们的工作。我们可以像我们之前使用`printf`方法那样使用`mixed`函数，但那样我们将丢失一些有用的数据。
- en: The `a` variable is a certain type, and the `b` variable is another, or it could
    also be the same. Variables like `a` and `b` are sometimes called **type variables**.
    What those type signatures are saying is that we have an array of values having
    a certain type (the type `a`), a function that takes such a value and returns
    one having another type (the type `b`); obviously, the final value is the same
    as the one of the callback.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`变量是某种类型，`b`变量是另一种类型，或者也可以是相同的。像`a`和`b`这样的变量有时被称为**类型变量**。这些类型签名所说的是，我们有一个具有某种类型（类型`a`）的值数组，一个接受这样一个值并返回另一个类型（类型`b`）的函数；显然，最终值与回调的值相同。'
- en: The names `a` and `b` are a convention, but you are free to use anything you
    want. In some occasions, using a longer name or some particular letter might help
    convey more information.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`a`和`b`是一种约定，但您可以自由使用任何您想要的东西。在某些情况下，使用更长的名称或某些特定字母可能有助于传达更多信息。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you have trouble understanding the signature for the `array_reduce` function,
    this is perfectly normal. You are not familiar with the syntax yet. Let''s try
    to take the arguments one by one:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对`array_reduce`函数的签名有困难，这是完全正常的。您还不熟悉语法。让我们尝试逐个接受参数：
- en: An array containing elements of type `a` type
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含`a`类型元素的数组
- en: A function, taking a type `b` (the accumulator), a type`a` (the current value),
    and returning a type`b` (the new accumulator content)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数，接受类型`b`（累加器），类型`a`（当前值），并返回类型`b`（新的累加器内容）
- en: An optional initial value of the same type as the array elements
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个与数组元素相同类型的可选初始值
- en: The return value is of type `b`, the same type as the accumulator
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值是`b`类型，与累加器相同类型
- en: What this signature does not tell us is the exact types of `a` and `b`. For
    all we care, `b` could be an array itself, a class, a Boolean, really anything.
    The types `a` and `b` can also be of the same type.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个签名没有告诉我们`a`和`b`的确切类型。就我们所知，`b`本身可能是一个数组，一个类，一个布尔值，真的可以是任何东西。类型`a`和`b`也可以是相同的类型。
- en: 'You can also have a unique type variable, as is the case for the `array_filter`
    function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以有一个唯一的类型变量，就像`array_filter`函数一样：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since the type signature only uses the `a` type, this means that the elements
    in the input array and the returned array will have exactly the same type. Since
    the `a` type is not a specific type, this type signature also informs us that
    the `array_filter` function works for all types, meaning it cannot transform the
    values. The elements inside of the list can only be rearranged or filtered.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型签名只使用了`a`类型，这意味着输入数组中的元素和返回的数组将具有完全相同的类型。由于`a`类型不是特定类型，这个类型签名也告诉我们`array_filter`函数适用于所有类型，这意味着它不能转换值。列表中的元素只能被重新排列或过滤。
- en: 'One final feature of type signatures is that you can narrow down the possible
    types for a given type variable. For example, you can specify that a certain type
    `m` should be a child of a given class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 类型签名的最后一个特点是，您可以缩小给定类型变量的可能类型。例如，您可以指定某个类型`m`应该是给定类的子类：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We just introduced a new double arrow symbol. You will always find it at the
    beginning of the type signature, never in the middle of one. It means that what
    comes before defines some kind of specificity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚引入了一个新的双箭头符号。您将始终在类型签名的开头找到它，而不会在中间找到。这意味着前面的内容定义了某种特定性。
- en: In our case, we constraint the `m` type variable to be a descendant of the `Monad`
    class. This allows us to declare that the `filterM` method first takes a function
    returning a Boolean value enclosed in a monad as a first argument and that its
    return value will be enclosed in the same monad.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将`m`类型变量约束为`Monad`类的后代。这使我们能够声明`filterM`方法首先接受一个返回布尔值的函数封装在一个monad中作为第一个参数，并且它的返回值将被封装在相同的monad中。
- en: 'You can specify multiple constraints if you''d like. If we imagine having two
    types, the `TypeA` and the `Typeb` types, we could have the following type signature:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以指定多个约束。如果我们想象有两种类型，`TypeA`和`TypeB`类型，我们可以有以下类型签名：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What this function does is not clear just by looking at the type signature,
    but we know that it expects one instance of the `TypeA` type and one instance
    of the `TypeB` type. The return value will be a string, obviously the result of
    a computation based on the parameters.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅通过查看类型签名就无法清楚地知道这个函数的作用，但我们知道它期望`TypeA`类型的一个实例和`TypeB`类型的一个实例。返回值将是一个字符串，显然是基于参数计算的结果。
- en: In this case, we cannot make the same assumption as for the `array_filter` method,
    namely that no transformation will happen, because we have a constraint on the
    type variables. Our functions may very well know how to operate on our data since
    they are an instance of a certain type or its children.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不能像`array_filter`方法那样做出相同的假设，即不会发生任何转换，因为我们对类型变量有约束。我们的函数很可能知道如何操作我们的数据，因为它们是某种类型或其子类的实例。
- en: I know there are a lot of things to take in, but as the preceding the `array_reduce`
    function example proves, type signatures allow us to encode a lot of information
    in a concise way. They are also more precise than PHP type hints as they, for
    example, allow us to say that the `array_map` method can transform from one type
    to another, whereas the `array_filter` method will maintain the types in the array.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道有很多东西要理解，但正如前面的`array_reduce`函数示例所证明的那样，类型签名允许我们以简洁的方式编码大量信息。它们也比PHP类型提示更精确，因为它们允许我们说`array_map`方法可以从一种类型转换为另一种类型，而`array_filter`方法将保持数组中的类型。
- en: If you've perused the code of the `php-functional` library, you might have noticed
    that the author used such type signatures in the doc blocks of most of the functions.
    You will also find that some other functional libraries do the same and the habit
    is also spreading in the JavaScript world for example.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您浏览过`php-functional`库的代码，您可能已经注意到作者在大多数函数的文档块中使用了这样的类型签名。您还会发现一些其他函数式库也在做同样的事情，这种习惯在JavaScript世界也在传播。
- en: Free theorems
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自由定理
- en: Not only do type signatures give us insight in to what the function does, they
    also allow us to deduce useful theorems and rules based on the type information.
    These are called **free theorems** because they come for free with the type signature.
    The idea was developed by Philip Walder in the paper *Theorems for free!* published
    in 1989.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 类型签名不仅让我们了解函数的作用，还允许我们根据类型信息推导出有用的定理和规则。这些被称为**自由定理**，因为它们随类型签名免费提供。这个想法是由Philip
    Walder在1989年发表的论文*Theorems for free!*中发展起来的。
- en: 'By using a free theorem, we can affirm the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用一个自由定理，我们可以肯定以下事实：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This might seem obvious to you using a bit of common sense and knowing what
    the functions do, but a computer lacks common sense. So, in order to optimize
    the left hand of our equality to the right hand, our compiler or interpreter must
    rely on the free theorem to do so.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这对您来说可能显而易见，因为您有一些常识并知道函数的作用，但计算机缺乏常识。因此，为了将等式的左边优化到右边，我们的编译器或解释器必须依赖自由定理来实现。
- en: How can the type signatures prove this theorem? Remember when we said that the
    type `a` is a generic type that our functions know nothing about? The corollary
    is that they cannot modify the values inside the array because such a generic
    function does not exist. The only function that knows how to transform something
    is `f` because it needs to conform to the `(a -> b)` type signature enforced by
    map.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类型签名如何证明这个定理？还记得我们说过`a`类型是我们的函数一无所知的通用类型吗？推论是它们不能修改数组中的值，因为这样的通用函数不存在。唯一知道如何转换的函数是`f`，因为它需要符合map强制的`(a
    -> b)`类型签名。
- en: 'Since nor `head` nor `map` functions modify the elements, we can deduce that
    first applying the function and then taking the first element is exactly the same
    as taking the first element and applying the function. Only the second way is
    much faster:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`head`和`map`函数都不修改元素，我们可以推断先应用函数然后取第一个元素与先取第一个元素再应用函数是完全相同的。只是第二种方式更快：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A bit more complicated, this free theorem says that if your predicate needs
    a value transformed using the function `f` and then you apply the `f` function
    on the result it is exactly the same as first applying `f` to all elements and
    filtering afterward. Again the idea is to optimize for performances by applying
    `f` only one time instead of two.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微复杂一些，这个自由定理说，如果你的谓词需要使用函数`f`转换一个值，然后你在结果上应用`f`函数，这与首先对所有元素应用`f`然后进行过滤完全相同。再次的想法是通过只应用一次`f`来优化性能，而不是两次。
- en: When composing functions together or calling them after one another, try to
    look at the type signatures to see if you cannot improve your code by deducing
    some free theorems.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当将函数组合在一起或在彼此之后调用它们时，尝试查看类型签名，看看是否可以通过推导一些自由定理来改进你的代码。
- en: Haskell users even have a free theorem generator at their disposition at [http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi](http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell用户甚至可以在[http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi](http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi)上使用自由定理生成器。
- en: Closing words
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束语
- en: Type signatures bring so much to the table that you can find function search
    engines based on them. Sites such as [https://www.haskell.org/hoogle/](https://www.haskell.org/hoogle/)
    and [http://scala-search.org/](http://scala-search.org/) lets you search for functions
    based solely on their type signature.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 类型签名为我们带来了很多东西，你可以找到基于它们的函数搜索引擎。像[https://www.haskell.org/hoogle/](https://www.haskell.org/hoogle/)和[http://scala-search.org/](http://scala-search.org/)这样的网站允许你仅基于它们的类型签名搜索函数。
- en: When working with functional techniques, it also often happens that you have
    a certain structure for your data and you need to transform that to something
    else. Since most functions are totally generic, it is often complicated coming
    up for the right keyword to search for what you are looking for. This is also
    where type signatures and search engines like **Hoogle** come in handy. Just enter
    the type structure of your input, the wanted type of the output, and peruse the
    function list returned by the search engine.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用函数式技术时，经常会出现这样的情况，你的数据有一定的结构，你需要将其转换为其他形式。由于大多数函数都是完全通用的，很难找到正确的关键字来搜索你要找的东西。这也是类型签名和**Hoogle**这样的搜索引擎派上用场的地方。只需输入你的输入的类型结构，想要的输出类型，然后浏览搜索引擎返回的函数列表。
- en: PHP being a dynamically typed language and only having recently introduced scalar
    typing, useful tools around type signatures obviously don't yet exist. But maybe
    it is only a matter of time before people will come up with something.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: PHP是一种动态类型的语言，而且最近才引入了标量类型，显然还没有围绕类型签名的有用工具。但也许只是时间的问题，人们会想出一些东西。
- en: Point-free style
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无点风格
- en: Point-free style, also called tacit programming is a way of writing functions
    where you don't explicitly define the parameters or points, hence the name. Depending
    on the language, it is possible to apply this particular style on different levels.
    How can you have functions without identified arguments? By using function composition
    or currying.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 无点风格，也称为暗示编程，是一种编写函数的方式，其中你不明确定义参数或点，因此得名。根据语言的不同，可以在不同的层次上应用这种特定的风格。你如何有没有确定参数的函数？通过使用函数组合或柯里化。
- en: 'In fact, we already did some point-free style programming before in this book.
    Let''s use an example from [Chapter 4](ch04.html "Chapter 4. Composing Functions"),
    *Composing Function*, to illustrate what it is about:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在本书中我们之前已经进行了一些无点风格的编程。让我们使用[第4章](ch04.html "第4章。组合函数")中的一个例子，*组合函数*，来说明它是关于什么的：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first part is a traditional function where you declare an input parameter.
    In the second case, however, you can see no explicit parameter declarations; you
    rely on the definitions of the composed functions. The second function is said
    to be in point-free style.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是传统函数，其中你声明一个输入参数。然而，在第二种情况下，你看不到明确的参数声明；你依赖于组合函数的定义。第二个函数被称为无点风格。
- en: 'PHP syntax forces us to assign our composed or curryied function to a variable,
    but there is no such clear separation in some other languages. Here are three
    examples in Haskell:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: PHP语法要求我们将组合或柯里化的函数分配给一个变量，但在一些其他语言中并没有这样清晰的分离。以下是Haskell中的三个例子：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we can see, the structure of the function definition is the same in the three
    cases. The first one is how you would define the `sum` method without using folding.
    The second example acknowledges that we can simply fold on the data, but still
    keeps the argument explicitly declared. Finally, the last example is point-free
    as there is no trace at all of the arguments.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这三种情况下函数定义的结构是相同的。第一个是在不使用折叠的情况下定义`sum`方法的方式。第二个例子承认我们可以简单地对数据进行折叠，但仍然明确声明了参数。最后一个例子是无点风格的，因为没有任何参数的痕迹。
- en: 'Another language where the difference between functions and variables is more
    tenuous than in PHP is JavaScript. In fact, all functions are variables and since
    there is no special syntax for variables, there is no distinction between a traditional
    function and an anonymous one assigned to a variable:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种语言中，函数和变量之间的区别比在PHP中更微妙的是JavaScript。事实上，所有函数都是变量，由于没有变量的特殊语法，传统函数和分配给变量的匿名函数之间没有区别：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Obviously, this is not valid JavaScript because there is no native `compose`
    function and both functions working on strings cannot be called like that so simply.
    There are, however, multiple libraries allowing you to write such code with ease,
    such as **Ramda**, which I highly recommend. The point of the example is just
    to demonstrate that you cannot distinguish a traditional function and an anonymous
    function in JavaScript, as is the case in PHP.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这不是有效的JavaScript，因为没有原生的`compose`函数，而且两个作用于字符串的函数不能这样简单地调用。然而，有多个库可以让你轻松编写这样的代码，比如**Ramda**，我强烈推荐。这个例子的重点只是为了证明你无法区分传统函数和JavaScript中的匿名函数，就像在PHP中一样。
- en: 'There are some benefits to using such a style:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种风格有一些好处：
- en: You usually have a more concise code, which some consider cleaner and easier
    to read.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常你会有更简洁的代码，有些人认为这样更清晰，更容易阅读。
- en: It helps thinking in terms of abstraction. The parameter name `word` in the
    JavaScript examples hints that the function works on single words only whereas
    it can work on any string. This is especially true for more generic functions
    such as those working on lists, for example.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于以抽象的方式思考。JavaScript示例中的参数名`word`暗示该函数只对单词起作用，而它实际上可以对任何字符串起作用。这对于更通用的函数尤其如此，比如那些在列表上工作的函数。
- en: It helps developers think in terms of function composition instead of data structures,
    which often results in better code.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于开发人员以函数组合而不是数据结构的方式思考，这通常会导致更好的代码。
- en: 'There are, however, also some possible drawbacks:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一些可能的缺点：
- en: Removing explicit arguments from the definition might make things harder to
    understand; having no parameter name, for example, sometimes removes useful information.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从定义中去掉显式参数可能会使事情更难理解；没有参数名，例如，有时会去掉有用的信息。
- en: Long chains of composed functions can lead to losing sight of the data structure
    and types.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长链的组合函数可能导致失去对数据结构和类型的视野。
- en: Code can be more difficult to maintain. When you have an explicit function you
    can easily add new lines, debugging, and so on. This is made nearly impossible
    when functions are composed together.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可能更难维护。当你有一个明确的函数时，你可以很容易地添加新的行，进行调试等。但是当函数组合在一起时，这几乎是不可能的。
- en: Some opponents to the paradigm sometimes use the term *pointless style* to describe
    this technique as a result of those issues.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有些反对者有时会使用术语*无意义的风格*来描述这种技术的结果。
- en: Reading and using point-free code definitely takes some time getting used to.
    I have personally no strong opinion about it. I advise you to use the style that
    suits you best and also, even if you prefer one, there are situations where the
    other is arguably better so don't hesitate to mix the two.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读和使用无点代码肯定需要一些时间来适应。我个人对此没有强烈的意见。我建议你使用最适合你的风格，而且即使你更喜欢其中一种，也有一些情况下另一种可能更好，所以不要犹豫混合使用两种风格。
- en: As a closing word, I would like to remind you that "Parameter order matters,
    a lot!" as we discussed in [Chapter 4](ch04.html "Chapter 4. Composing Functions"),
    *Composing functions*. And it is especially true if you want to use a point-free
    style. If the data you need to work on isn't the last parameter, you won't be
    able to.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想提醒你，“参数顺序很重要！”就像我们在[第4章](ch04.html "第4章. 组合函数")中讨论的那样，*组合函数*。如果你想使用无点风格，这一点尤其重要。如果你需要处理的数据不是最后一个参数，你将无法使用。
- en: Using const for functions
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用const关键字来定义函数
- en: This technique is not related to functional programming, but rather it is a
    neat trick in PHP itself. It will, however, probably help you a lot, so here we
    go.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术与函数式编程无关，而是PHP本身的一个巧妙技巧。然而，它可能会帮助你很多，所以我们来试试。
- en: 'If you''ve had a look at the code of the `functional-php` library, you might
    have noticed that there are definitions of constants at the top of nearly all
    functions. Here is a small example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看过`functional-php`库的代码，你可能已经注意到几乎所有函数顶部都有常量的定义。这里有一个小例子：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The idea behind this is to allow a simpler usage of functions as parameters.
    We've seen earlier that the way you pass a function or method as an argument is
    to use something called a `callable`, which usually is either a string or an array
    for methods composed of an object instance and a string for the method to call.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这背后的想法是允许更简单地使用函数作为参数。我们之前看到，你传递函数或方法作为参数的方式是使用一个叫做`callable`的东西，通常是一个字符串或一个由对象实例和要调用的方法的字符串组成的数组。
- en: 'Using a `const` keyword allows us to have something much more akin to what
    you can find in languages where functions are not a separate construct from variables:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`const`关键字使我们更接近于在函数与变量不是分开构造的语言中找到的东西：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Exit the awkward quotes around our function name. It really looks like you are
    passing the function itself, as would be the case in other languages such as Python
    or JavaScript.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 去掉我们函数名周围的尴尬引号。这看起来真的像你在传递函数本身，就像其他语言如Python或JavaScript中的情况一样。
- en: If you are using an IDE it gets even better. You can use the *Go to declaration*
    or equivalent function and the file where you defined the `const` will open on
    the line where it is defined. If you declared it either just on top or at the
    bottom of the *real* function, you will have quick access to its definition.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是IDE，情况会更好。你可以使用*转到声明*或等效的功能，定义`const`的文件将在定义它的行上打开。如果你将它声明在*真正*函数的顶部或底部，你将快速访问到它的定义。
- en: Some IDE, I am not aware of, might offer the same feature for `callable` in
    the form of strings, but it is at least not the case for the one that I am using.
    Whereas if I press *Ctrl* + click on the `increment` function in the second example,
    it focuses on the `const` declaration, which is a real time-saver.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一些我不知道的IDE可能会为`callable`提供相同的功能，但至少对我使用的这个来说并不是这样。然而，如果我在第二个例子中按下*Ctrl* +点击`increment`函数，它会聚焦在`const`声明上，这真的节省了很多时间。
- en: 'When declaring constants like that, you are not limited to shadow functions;
    it also works with static object methods. You can also use **DocBlock** annotations
    to declare that your constant represents a `callable` type:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当像这样声明常量时，你不仅限于影子函数；它也适用于静态对象方法。你还可以使用**DocBlock**注释来声明你的常量代表一个`callable`类型：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Sadly, this trick will not work for anonymous functions stored inside a variable
    or calling methods on object instances. If you try to do so, PHP will gratify
    you with a resounding `Warning: Constants may only evaluate to scalar values or
    arrays` warning.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '遗憾的是，这个技巧对存储在变量中的匿名函数或在对象实例上调用方法不起作用。如果你尝试这样做，PHP会用一个响亮的`Warning: Constants
    may only evaluate to scalar values or arrays`警告来回报你。'
- en: Although not a silver bullet and accompanied by limitations, this little technique
    will help you write code that is a bit cleaner and easier to navigate in if you
    are using an IDE.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不是万能的，而且伴随着一些限制，这个小技巧将帮助你编写更清晰、更容易在IDE中导航的代码。
- en: Recursion, stack overflows, and trampolines
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归、堆栈溢出和跳板
- en: We first presented recursion as a possible solution to programming problems
    in [Chapter 3](ch03.html "Chapter 3.  Functional Basis in PHP"), *Functional basis
    in PHP*. Some memory complications were hinted at; it is time to investigate those
    further.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在[第3章](ch03.html "第3章。PHP中的函数基础")中将递归作为解决编程问题的可能解决方案进行了介绍，*PHP中的函数基础*。一些内存问题已经被暗示出来；现在是时候进一步调查了。
- en: Tail-calls
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾调用
- en: 'A call to a function that is the last statement done before returning a value
    is called a **tail-call**. Let''s have a look at some examples to get a grasp
    of what it means:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回值之前执行的最后一个语句是称为**尾调用**的函数调用。让我们看一些例子来理解它的含义：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is without any doubt a tail-call. The last statement of the function returns
    the result of the `strtoupper` function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，这是一个尾调用。函数的最后一个语句返回`strtoupper`函数的结果：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, both calls to the `strtoupper` function are tail-calls. The position
    inside the function does not matter; what does matter is if there are any kinds
    of operations made after the call to the function is made. In our case, if the
    argument value is `Gilles` the last thing the function will do is call the `strtoupper`
    function, making it a tail-call:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对`strtoupper`函数的两次调用都是尾调用。函数内的位置并不重要；重要的是在函数调用之后是否进行了任何操作。在我们的例子中，如果参数值是`Gilles`，函数将做的最后一件事是调用`strtoupper`函数，使其成为尾调用：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: None of those two functions have a tail-call. In both cases, the return value
    of the call is used to compute a final value before the function returns. The
    order of operation does not matter, the interpreter needs to first get the value
    of the `strtoupper` and the `max` functions in order to compute the result.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都没有尾调用。在这两种情况下，调用的返回值被用来计算最终值，然后函数返回。操作的顺序并不重要，解释器需要首先获取`strtoupper`和`max`函数的值，以计算结果。
- en: As we just saw, spotting a tail-call is not always easy. You can have one in
    the first few lines of a very long function, and being on the last line is not
    a sufficient criterion.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，发现尾调用并不总是容易的。你可以在一个非常长的函数的前几行中有一个尾调用，并且处于最后一行并不是一个充分的标准。
- en: If the tail-call is made to the function itself, or in other words it is a recursive
    call, the term of **tail recursion** is often used.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尾调用是对函数本身的调用，或者换句话说是递归调用，那么**尾递归**这个术语经常被使用。
- en: Tail-call elimination
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾调用消除
- en: Why bother you are maybe asking yourself? Because compilers and parsers can
    perform something called tail-call elimination or sometimes **Tail-Call Optimization** (**TCO**)
    in short.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要费心呢？也许你正在问自己？因为编译器和解析器可以执行一种称为尾调用消除或有时称为**尾调用优化**（**TCO**）的东西。
- en: Instead of performing a new function call and suffering from all the related
    overhead, the program simply jumps to the next function without adding more information
    to the stack and wasting precious time passing parameters around.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 程序不是执行一个新的函数调用并遭受所有相关的开销，而是简单地跳转到下一个函数，而不向堆栈添加更多信息并浪费宝贵的时间传递参数。
- en: This particularly matters in cases of tail recursion as it allows the stack
    to stay flat, not using any more memory than the first function call.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这在尾递归的情况下特别重要，因为它允许堆栈保持平坦，不使用比第一个函数调用更多的内存。
- en: 'It sounds great, but as with most advanced compilation techniques, the PHP
    engine does not implement tail-call elimination. However, other languages do:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很棒，但是像大多数高级编译技术一样，PHP引擎并没有实现尾调用消除。然而，其他语言做到了：
- en: Any **ECMAScript** 6 compliant JavaScript engine
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何符合**ECMAScript** 6标准的JavaScript引擎
- en: Python after installing the tco module
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了tco模块后的Python
- en: Scala, you even have an annotation (`@tailrec`) to trigger a compiler error
    if your method is not tail recursive
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Scala中，甚至有一个注解（`@tailrec`）可以触发编译器错误，如果你的方法不是尾递归的
- en: '**Elixir**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Elixir**'
- en: '**Lua**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lua**'
- en: '**Perl**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Perl**'
- en: Haskell
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haskell
- en: There is also ongoing proposition and work to perform tail-call elimination
    at the **Java Virtual Machine** (**JVM**) level, but no concrete implementation
    so far has landed in Java 8, as this is not considered a priority feature.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Java虚拟机**（**JVM**）级别也有正在进行的提案和工作来执行尾调用消除，但到目前为止在Java 8中还没有具体的实现，因为这不被认为是一个优先特性。
- en: Tail recursive functions are usually simpler to work with especially with regards
    to folding; as we saw in this section, techniques exist to alleviate the growing
    stack issue at the cost of some processing power.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归函数通常更容易处理，特别是在折叠方面；正如我们在本节中看到的，存在一些技术来缓解堆栈增长问题，但代价是一些处理能力。
- en: From recursion to tail recursion
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从递归到尾递归
- en: Now that we have a clearer understanding of what we are talking about, let's
    learn how we can transform a recursive function in to a tail recursive one if
    that is not already the case.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们对我们正在谈论的内容有了更清晰的理解，让我们学习如何将递归函数转换为尾递归函数，如果还不是的话。
- en: 'We declined to use the computation of a factorial as a good recursion example
    in [Chapter 3](ch03.html "Chapter 3.  Functional Basis in PHP"), *Functional Basis
    in PHP*, but as it is probably the simplest recursive function that could be written,
    we will start with that example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拒绝将计算阶乘作为[第3章](ch03.html "第3章。PHP中的函数基础")中好的递归示例，*PHP中的函数基础*，但是因为它可能是最简单的递归函数，我们将从这个例子开始：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Is this function tail-recursive? No, we multiply a value with the result of
    our recursive call to `fact` method. Let''s see the various steps in more detail:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是尾递归的吗？不是，我们将一个值与我们递归调用`fact`方法的结果相乘。让我们更详细地看一下各个步骤：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Any idea how we can transform this to a tail-recursive function? Take some time
    to play around with some ideas before reading further. If you need a hint, think
    about how functions used for folding operate.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你有什么想法可以将这个转换为尾递归函数吗？在继续阅读之前，花点时间玩一下一些想法。如果你需要提示，想一想用于折叠的函数是如何操作的。
- en: 'The usual answer when it comes to tail recursion revolves around using accumulators:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到尾递归时，通常的答案是使用累加器：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here we wrote it using an inner helper to hide the implementation detail of
    the accumulator, but we could just have written it using a unique function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用了一个内部辅助函数来隐藏累加器的实现细节，但我们也可以只使用一个唯一的函数来写它：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s have a look at the steps once again:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看一下这些步骤：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Great, no more pending operation after each recursive call; we truly have a
    tail recursive function. Our `fact` function was pretty simple. What about the
    *Tower of Hanoi* solver we wrote earlier? Here it is so you don''t have to search
    for it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，在每个递归调用之后没有未决操作了；我们真的有一个尾递归函数。我们的`fact`函数非常简单。我们之前写的*汉诺塔*求解器呢？这里有它，这样你就不用再去找了：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Like for our factorial computation, take some time to try transforming the
    function into a tail recursive one yourself:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的阶乘计算一样，花点时间尝试将函数转换为尾递归函数：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the solution is pretty similar, even when there are multiple
    recursive calls inside the function, we can still use an accumulator. The trick
    is to use an array instead of storing only the current value. In most cases, the
    accumulator will be a **stack**, meaning you can only add elements at the beginning
    and remove them from the beginning. A stack is said to be a **Last In, First Out**
    (**LIFO**) structure.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，解决方案非常相似，即使在函数内部有多个递归调用时，我们仍然可以使用一个累加器。诀窍是使用一个数组而不是仅存储当前值。在大多数情况下，累加器将是一个**堆栈**，这意味着你只能在开头添加元素并从开头删除它们。堆栈被称为**后进先出**（**LIFO**）结构。
- en: If you don't quite get why this refactoring works, I encourage you to write
    down the steps for both variants as we did for the `fact` method so that you can
    get a better feel for the involved mechanics.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太明白这个重构是如何工作的，我鼓励你写下两种变体的步骤，就像我们为`fact`方法所做的那样，这样你就可以更好地理解涉及的机制。
- en: In fact, taking the time to write down the steps of a recursive algorithm is
    often a great way to clearly understand what is happening and how it can be refactored
    to be tail recursive or fix a bug if there is one.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，花时间写下递归算法的步骤通常是清楚地理解发生了什么以及如何重构为尾递归或修复错误的好方法。
- en: Stack overflows
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈溢出
- en: 'The fact we used a stack-like data structure for our tail recursive Hanoi solver
    is no coincidence. When you call functions, all needed information is also stored
    in a stack-like structure in memory. In the case of recursion, it will look something
    like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为尾递归的汉诺塔求解器使用类似堆栈的数据结构并非巧合。当你调用函数时，所有需要的信息也会存储在内存中类似堆栈的结构中。在递归的情况下，它看起来会像这样：
- en: '![Stack overflows](graphics/image_07_001.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![堆栈溢出](graphics/image_07_001.jpg)'
- en: This stack has a limited size. It is bound through the `memory_limit` configuration
    option and even if you remove the limit you won't be able to go beyond the available
    memory in the system. Also, extensions such as **Xdebug** introduce specific mechanisms
    to avoid having too many nested recursive calls. For example, you have a configuration
    option named `xdebug.max_nesting_level`, which defaults to 256, meaning that if
    you call a function recursively more than that, an error will be raised.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个堆栈有一个有限的大小。它通过`memory_limit`配置选项进行限制，即使你移除了限制，也无法超出系统中可用的内存。此外，诸如**Xdebug**之类的扩展引入了特定的机制，以避免有太多嵌套的递归调用。例如，你有一个名为`xdebug.max_nesting_level`的配置选项，默认值为256，这意味着如果你递归调用一个函数超过这个值，就会引发错误。
- en: If PHP performed tail-call optimization, instead of stacking the pieces of function
    information on top of one another, the call would replace the current information
    in the stack. It is safe to do so because the final result of a tail-call does
    not depend on any variable local to the function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果PHP执行尾调用优化，而不是将函数信息的各个部分堆叠在一起，调用将会替换堆栈中的当前信息。这样做是安全的，因为尾调用的最终结果不依赖于函数局部变量。
- en: Since PHP does not perform this kind of optimization, we need to find another
    solution to avoid blowing up the stack. If you encounter this issue and you are
    willing to sacrifice some processing power to limit the memory usage, you can
    use **trampolines**.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PHP不执行这种优化，我们需要找到另一个解决方案来避免堆栈溢出。如果你遇到这个问题，并且愿意牺牲一些处理能力来限制内存使用，你可以使用**trampolines**。
- en: Trampolines
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: trampolines
- en: The only way we can avoid stack growth is to return a value instead of calling
    a new function. This value can hold information needed to perform a new function
    call, which will continue the computation. This also means we need some cooperation
    from the caller of the function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免堆栈增长的唯一方法是返回一个值而不是调用一个新函数。这个值可以保存执行新函数调用所需的信息，从而继续计算。这也意味着我们需要函数的调用者的一些合作。
- en: 'This helpful caller is the trampoline and here is how it works:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有用的调用者就是trampoline，这是它的工作原理：
- en: The trampoline calls our function `f`
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: trampoline调用我们的函数`f`
- en: Instead of making a recursive call, the `f` function returns the next call encapsulated
    inside a data structure with all the arguments
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f`函数不再进行递归调用，而是返回封装在数据结构中的下一个调用和所有参数'
- en: The trampoline extracts the information and performs a new call to the `f` function
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: trampoline提取信息并对`f`函数进行新的调用
- en: Repeat the two last steps until the `f` function returns a *real* value
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复最后两个步骤，直到`f`函数返回一个*真实*值
- en: The trampoline receives a value and it returns to the *real* caller
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: trampoline接收一个值并返回给*真实*的调用者
- en: These steps should also explain where the name of the technique comes from,
    each time the function returns to the trampoline, it bounced back with the next
    arguments.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤也应该解释了这个技术的名称来源，每次函数返回到trampoline时，它都会以下一个参数弹回来。
- en: 'To perform these steps, we need a data structure holding both the function
    to call in the form of a `callable` and the arguments. We also need a helper function
    that will continue calling whatever is stored inside the data structure until
    it gets a real value:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这些步骤，我们需要一个数据结构，其中包含以`callable`形式调用的函数和参数。我们还需要一个辅助函数，它将继续调用数据结构中存储的任何内容，直到获得真实值：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Simple enough, let''s try it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 足够简单，让我们试试：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Works fine, and the code isn't that much harder to read. There is, however,
    a performance hit when using trampolines. In the case of computing a factorial,
    the trampoline version is roughly five times slower on my laptop. This is explained
    by the fact that the interpreter has to do to a lot more work than simply calling
    the next function.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 效果很好，代码也没有那么难读。然而，在使用蹦床时会有性能损失。在计算阶乘的情况下，蹦床版本在我的笔记本电脑上大约慢了五倍。这是因为解释器需要做的工作比简单调用下一个函数要多得多。
- en: Knowing this, if your recursive algorithm has a bound depth and you are certain
    that you are at no risk of a stack overflow, I recommend you to just perform a
    traditional recursion instead of using a trampoline. In the case of doubt, however,
    don't hesitate, as a stack overflow error can be critical on a production system.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 知道这一点，如果你的递归算法有一个有限的深度，并且你确信不会发生堆栈溢出，我建议你只执行传统的递归，而不是使用蹦床。然而，如果有疑问，不要犹豫，因为堆栈溢出错误可能对生产系统造成严重影响。
- en: Multi-step recursion
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多步递归
- en: 'Trampolines even have their usefulness for languages performing incomplete
    tail-call elimination. For example, Scala is unable to perform such an optimization
    when there are two functions involved. Instead of trying to explain what I am
    talking about, let''s see some code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 蹦床甚至对执行不完全尾调用消除的语言也有用处。例如，当涉及两个函数时，Scala无法执行这样的优化。不要试图解释我在说什么，让我们看一些代码：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This might not be the best and most efficient way to determine if a number is
    odd or even, but it has the merits to simply illustrate what I am talking about.
    Both functions are calling themselves until the number reaches 0, at which time
    we can decide if it is odd or even.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是确定一个数字是奇数还是偶数的最佳最有效的方法，但它有简单说明我在谈论什么的优点。两个函数都在调用自己，直到数字达到0为止，这时我们可以决定它是奇数还是偶数。
- en: 'Depending on whom you ask, this might or might not be recursion. It respects
    the academic definition we gave in [Chapter 3](ch03.html "Chapter 3.  Functional
    Basis in PHP"), *Functional basis in PHP*:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你问的人，这可能是递归，也可能不是。它符合我们在[第3章](ch03.html "第3章。PHP中的函数基础")中给出的学术定义，*PHP中的函数基础*：
- en: '*Recursion is the idea to divide a problem into smaller instance of the same
    problem.*'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*递归是将问题分解为相同问题的较小实例的想法。*'
- en: However, the function does not call itself, so this is why some people will
    try to define what is happening here with other terms. In the end, what we call
    that does not matter; we will have a stack overflow on a big number.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该函数并没有调用自身，所以这就是为什么有些人会尝试用其他术语来定义这里发生的事情。最终，我们称之为什么并不重要；在一个大数字上，我们将会遇到堆栈溢出。
- en: As I was saying, Scala performs an incomplete tail-call elimination as it will
    only do so if the function calls itself as its last instruction, leading to a
    stack overflow error as PHP will do. This is why trampolines are used even in
    some functional languages.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说，Scala执行不完全的尾调用消除，只有当函数调用自身作为最后一条指令时才会这样做，这会导致堆栈溢出错误，就像PHP会做的那样。这就是为什么即使在一些函数式语言中也会使用蹦床来解决堆栈溢出问题。
- en: As a real simple exercise, I invite you to rewrite both `odd` and `even` functions
    using trampolines.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个真正简单的练习，我邀请你使用蹦床来重写`odd`和`even`函数。
- en: The trampoline library
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蹦床库
- en: 'If you want to use trampolines in your own project, I invite you to install
    the following library using the `composer` command, as it offers some helpers
    compared to our crude implementation:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在自己的项目中使用蹦床，我邀请你使用`composer`命令安装以下库，因为它相对于我们的粗糙实现提供了一些帮助：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The data structure and features have been conflated inside the same class called
    `Trampoline`. Helpers are available in the form of functions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构和功能已经合并在同一个名为`Trampoline`的类中。助手以函数的形式可用：
- en: The `bounce` helper is used to create a new function wrapper. It takes a `callable`
    and the arguments.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bounce`助手用于创建一个新的函数包装器。它接受一个`callable`和参数。'
- en: The `trampoline` helper runs a callable until completion. It takes a `callable`
    and its arguments. The method also accepts a `Trampoline` class instance as parameter,
    but in this case, the arguments will be ignored as they are already wrapped inside
    the instance.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trampoline`助手运行一个可调用对象直到完成。它接受一个`callable`和它的参数。该方法还接受`Trampoline`类实例作为参数，但在这种情况下，参数将被忽略，因为它们已经包装在实例中。'
- en: The class also defines `__callStatic`, which allows us to call any function
    from the global namespace on the class directly.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还定义了`__callStatic`，这允许我们直接在类上调用全局命名空间中的任何函数。
- en: 'Here are some examples taken from the documentation:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从文档中摘取的一些示例：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Another helper returning a callable with all the trampoline capabilities turned
    on also exists, and it is called the `trampoline_wrapper` helper:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个带有所有蹦床功能的可调用返回助手，它被称为`trampoline_wrapper`助手：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As an exercise, you can try to transform our *Tower of Hanoi* solver to use
    the `trampoline` library and see if you get the same results.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以尝试将我们的*汉诺塔*求解器转换为使用`trampoline`库，并看看是否得到相同的结果。
- en: Alternative method
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代方法
- en: Instead of using trampolines to solve stack overflow issues, it is also possible
    to use a queue to store all the arguments of the successive recursive calls to
    our function.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用蹦床来解决堆栈溢出问题之外，还可以使用队列来存储对我们函数的连续递归调用的所有参数。
- en: 'The original function needs to be wrapped inside a helper that will hold the
    queue and call the original function with all the arguments in a chain. In order
    for this to work, the recursive call needs to be made to the wrapper instead:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 原始函数需要包装在一个辅助函数中，该函数将保存队列并以链式调用所有参数调用原始函数。为了使其工作，递归调用需要在包装器而不是原始函数中进行：
- en: Create the wrapper function
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建包装器函数
- en: First call to the wrapper with the first arguments
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第一个参数调用包装器的第一次调用
- en: The wrapper enters a loop that calls the original function while there are arguments
    in the queue
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当队列中有参数时，包装器进入一个循环，调用原始函数
- en: Each subsequent call to the wrapper adds arguments to the queue instead of calling
    the original function
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次对包装器的后续调用都会将参数添加到队列中，而不是调用原始函数
- en: Once the loop is finished (that is, all recursive calls have been made), the
    wrapper returns the final value
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环完成后（即所有递归调用都已完成），包装器返回最终值
- en: For it to work, it is really important that the original function calls the
    wrapper when making a recursive call. This can be done either by using an anonymous
    function that you use inside of your wrapped function or using the `bindTo` method
    on the `Closure` class, as we discussed in [Chapter 1](ch01.html "Chapter 1. Functions
    as First Class Citizens in PHP"), *Functions as First Class Citizen in PHP*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，原始函数在进行递归调用时真的很重要。这可以通过在包装函数内部使用的匿名函数或使用“Closure”类的“bindTo”方法来完成，正如我们在[第1章](ch01.html
    "第1章。PHP中的一等公民函数")中讨论的那样，“PHP中的一等公民函数”。
- en: 'The `trampoline` library has an implementation of this method using the later
    technique. Here is how you can use it instead of a trampoline:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: “trampoline”库使用后一种技术实现了这种方法。以下是您可以使用它而不是蹦床的方法：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The wrapper created by the `pool` function binds an instance of the `Pool` class
    to `$this`. This class has an `__invoke` method, which is callable inside our
    original function. Doing so will call the wrapper again, but this time it will
    add the arguments to the queue instead of calling the original function.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由“pool”函数创建的包装器将“Pool”类的实例绑定到“$this”。该类具有一个“__invoke”方法，在我们的原始函数中可调用。这样做将再次调用包装器，但这次它将把参数添加到队列中，而不是调用原始函数。
- en: From a performance standpoint there is no difference between this method and
    the trampoline, both should perform roughly the same way. However, you cannot
    do multi-step recursion using a `pool` function as the wrapper is only aware of
    one function.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能的角度来看，这种方法和蹦床之间没有区别，两者的性能应该大致相同。然而，使用“pool”函数时，不能进行多步递归，因为包装器只知道一个函数。
- en: Also, until PHP 7.1 is released, this method is also limited to anonymous functions
    due to some difficulties transforming a callable in the form of a string to an
    instance of `Closure` class in order to bind the class to it. PHP 7.1 will introduce
    a new `fromCallable` method on `Closure`, which allows lifting this limitation.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，直到PHP 7.1发布，由于一些困难将可调用的字符串形式转换为“Closure”类的实例以绑定类，此方法也仅限于匿名函数。PHP 7.1将在“Closure”上引入一个新的“fromCallable”方法，允许解除此限制。
- en: Closing words
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束语
- en: As a final note, both the trampoline and queue techniques we've seen to solve
    the stack overflow problem will only work if the recursive function is tail recursive.
    This is a mandatory condition as the function needs to fully return in order for
    the helper to continue the computation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的是，我们已经看到的蹦床和队列技术只有在递归函数是尾递归时才能解决堆栈溢出问题。这是一个强制条件，因为函数需要完全返回，以便辅助函数继续计算。
- en: Also, as the trampoline method has fewer drawbacks, I would recommend this instead
    of the `pool` function implementation.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于蹦床方法的缺点较少，我建议使用它而不是“pool”函数实现。
- en: Pattern matching
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Pattern matching is a really powerful feature of most functional languages.
    It is embedded inside the language at various levels. In Scala, for example, you
    can use it as a beefed up `switch` statement, and in Haskell it is an integral
    part of function definition.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是大多数函数式语言中非常强大的功能。它嵌入在语言的各个层面。例如，在Scala中，您可以将其用作强化的“switch”语句，在Haskell中，它是函数定义的一个组成部分。
- en: Pattern matching is the process of checking a series of tokens against a pattern.
    It is different from pattern recognition as the match needs to be exact. The process
    does not only match as a switch statement does, it also assigns the value as with
    the `list` construct in PHP, a process called **destructuring assignment**.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是检查一系列标记与模式是否匹配的过程。它不同于模式识别，因为匹配需要精确。该过程不仅匹配，还分配值，就像PHP中的“list”构造一样，这个过程称为**解构赋值**。
- en: It is not to be confused with regular expressions. Regular expressions can only
    operate on the content of strings, where as pattern matching can also operate
    on the structure of the data. For example, you can match on the number of elements
    of an array.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 不要与正则表达式混淆。正则表达式只能操作字符串的内容，而模式匹配还可以操作数据的结构。例如，您可以匹配数组的元素数量。
- en: 'Let''s see some examples in Haskell so we get a feel for it. The simplest form
    of pattern matching is to match to a specific value:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Haskell中看一些例子，以便我们对其有所了解。最简单的模式匹配形式是匹配特定值：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is how you could define `fact` function in Haskell:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您可以在Haskell中定义“fact”函数的方式：
- en: The first line is the type signature, which should remind you something we saw
    earlier in this chapter; `Integral` is a type that is a bit less restrictive than
    the `Integer` type without entering in the details.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行是类型签名，应该让您想起本章前面看到的内容；“Integral”是一种比“Integer”类型不那么严格的类型，不详细介绍。
- en: The second line is the function body if the argument has the value 0.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行是如果参数的值为0的函数体。
- en: The last line is executed in all other cases. The value is assigned to the `n`
    variable.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一行在所有其他情况下执行。该值分配给“n”变量。
- en: 'If you are not interested in some values, you can ignore them using the `_`(underscore)
    wildcard pattern. For example, you can easily define functions to get the first,
    second, and third value from a tuple:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对某些值不感兴趣，可以使用`_`（下划线）通配符模式来忽略它们。例如，您可以轻松地定义函数来从元组中获取第一个、第二个和第三个值：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A tuple is a data structure with a fixed number of elements, as opposed to an
    array, which can change size. The `(1, 2)` and `('a', 'b')` tuples are both of
    size two. The advantage of using tuples over arrays when there is a known number
    of elements lies in enforcing the correct size and performance.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是一个具有固定数量元素的数据结构，与可以改变大小的数组相对。`(1, 2)`和`('a', 'b')`元组的大小都是两个。在已知元素数量的情况下使用元组而不是数组的优势在于强制正确的大小和性能。
- en: Languages such as Haskell, Scala, Python, C#, and Ruby have a tuple type inside
    their core or standard library.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如Haskell、Scala、Python、C#和Ruby之类的语言在其核心或标准库中都有元组类型。
- en: 'You can destruct the values into more than just one variable. In order to understand
    the following examples, you need to know that "`:`" (colon) is the operator to
    prepend an element to a list. This means that the `1:[2, 3]` tuple will return
    the list `[1, 2, 3]`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将值解构为不止一个变量。为了理解以下示例，您需要知道“:`”（冒号）是将元素前置到列表的操作符。这意味着`1:[2, 3]`元组将返回列表`[1,
    2, 3]`：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `head` and `tail` variable have the same structure, if the list is empty,
    they return an error. Otherwise either return `x`, which is the element at the
    beginning of the list, or `xs`, which is the rest of the list. The `sum` variable
    is also similar, but instead it uses both `x` and `xs`. By the way, Haskell would
    disallow defining those two functions as they already exist:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`head`和`tail`变量具有相同的结构，如果列表为空，它们返回一个错误。否则，返回`x`，即列表开头的元素，或者`xs`，即列表的其余部分。`sum`变量也类似，但它同时使用`x`和`xs`。顺便说一句，Haskell将不允许定义这两个函数，因为它们已经存在：'
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `firstThree` variable is a bit different. It first tries to match a list
    with at least three elements, `x`, `y`, and `z`. In this case the `_`pattern can
    be the empty list or not, the pattern will match. If it doesn't succeed, we know
    that the list has fewer than three elements and we display an error.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`firstThree`变量有点不同。它首先尝试匹配至少三个元素的列表，`x`，`y`和`z`。在这种情况下，`_`模式可以是空列表，也可以不是，模式将匹配。如果匹配不成功，我们知道列表少于三个元素，然后显示一个错误。'
- en: 'You can also use pattern matching as a beefed up switch statement. For example,
    this would also be a valid implementation of `head`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将模式匹配用作强化的开关语句。例如，这也是`head`的有效实现：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you want to use both the destructuring data and the whole value, you can
    use **as patterns**:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想同时使用解构数据和整个值，可以使用**as模式**：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, you can also use constructors when doing pattern matching. Here is
    a small example using the `Maybe` type:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还可以在进行模式匹配时使用构造函数。以下是使用`Maybe`类型的一个小例子：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Yes, you can get the value inside a monad just like that, using destructuring.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，您可以像这样轻松地获取Monad中的值，使用解构。
- en: You can have overlapping patterns; Haskell will use the first one that matches.
    And if it isn't able to find a matching one, it will raise an error saying `Non-exhaustive
    patterns in function XXX`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以有重叠的模式；Haskell将使用第一个匹配的模式。如果它无法找到匹配的模式，它将引发一个错误，显示`函数XXX中的非穷尽模式`。
- en: We could demonstrate roughly the same kind of features for Scala, Clojure, or
    other functional languages, but as this was just an example to understand what
    pattern matching is about, I would rather advise you to read tutorials on the
    subject if the topic is of interest to you. Instead, we will try to emulate part
    of this powerful feature in PHP.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以大致展示Scala、Clojure或其他函数语言的相同类型的功能，但由于这只是一个了解模式匹配的示例，如果您对此话题感兴趣，我建议您阅读有关该主题的教程。相反，我们将尝试在PHP中模拟这一强大功能的一部分。
- en: Pattern matching in PHP
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP中的模式匹配
- en: Obviously, we will never be able to declare functions the same way we just saw
    in Haskell as this needs to be implemented at the heart of the language. However,
    a library tries to emulate pattern matching as best as possible to create a more
    powerful version of the switch statement with automatic destructuring.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们永远无法像在Haskell中看到的那样声明函数，因为这需要在语言的核心实现。但是，一个库试图尽可能地模拟模式匹配，以创建一个更强大的开关语句版本，具有自动解构功能。
- en: 'You can install the library using `composer` command in Composer:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Composer中的`composer`命令安装该库：
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In order to be as expressive as possible to what is available in Haskell, it
    uses a string to hold the patterns. Here is a table defining the various possible
    syntaxes:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能地表达Haskell中的可用内容，它使用字符串来保存模式。以下是定义各种可能语法的表格：
- en: '| Name | Format | Example |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 格式 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Constant | Any scalar value (integer, float, string, Boolean) | `1.0`, `42`,
    "test" |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 任何标量值（整数、浮点数、字符串、布尔值） | `1.0`，`42`，"test" |'
- en: '| Variable | identifier | `a`, `name`, `anything` |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 标识符 | `a`，`name`，`anything` |'
- en: '| Array | [<pattern>, ..., <pattern>] | `[]`, `[a]`, `[a, b, c]` |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | [<模式>, ..., <模式>] | `[]`，`[a]`，`[a, b, c]` |'
- en: '| Cons | (identifier:list-identifier) | `(x:xs)`, `(x:y:z:xs)` |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| Cons | (标识符:列表标识符) | `(x:xs)`，`(x:y:z:xs)` |'
- en: '| Wildcard | _ | _ |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 通配符 | _ | _ |'
- en: '| As | identifier@(<pattern>) | all@(x:xs) |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| As | 标识符@(<模式>) | all@(x:xs) |'
- en: At the time of writing, there is no support for automatic destructuring of values
    inside a Monad, or other types, nor the possibility to constrain the type of a
    particular item we match upon. There are, however, opened issues concerning those
    two features [https://github.com/functional-php/pattern-matching/issues](https://github.com/functional-php/pattern-matching/issues).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，尚不支持在Monad或其他类型内部自动解构值，也不支持约束我们匹配的特定项的类型的可能性。但是，关于这两个功能存在已打开的问题[https://github.com/functional-php/pattern-matching/issues](https://github.com/functional-php/pattern-matching/issues)。
- en: As there is no possibility to use named parameters in PHP, the parameters will
    be passed in the order they are defined in the pattern and there will be no matching
    done based on their names. This makes using the library a bit tedious at times.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在PHP中无法使用命名参数，参数将按照它们在模式中定义的顺序传递，并且不会根据它们的名称进行匹配。这使得有时使用该库会有点麻烦。
- en: Better switch statements
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更好的switch语句
- en: 'The library can be used to perform more advanced `switch` statements by also
    using the structure and extracting data instead of just equating on the value.
    Since the functions are curryied, you can also map them over arrays contrary to
    a `switch` statement:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 该库还可以用于执行更高级的`switch`语句，还可以使用结构并提取数据，而不仅仅是对值进行等价判断。由于函数是柯里化的，您还可以将它们映射到数组上，与`switch`语句相反。
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first pattern in the list that matches is used. As you can see, the callback
    can either be a function as for the first pattern or a constant that will be returned.
    Obviously in this case all of them could have been constants, but this was for
    the sake of the example.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中匹配的第一个模式将被使用。如您所见，回调可以是一个函数，如第一个模式，也可以是一个将被返回的常量。显然，在这种情况下，它们都可以是常量，但这是为了举例。
- en: One of the benefits over a traditional `switch` statement as you can see is
    that you are not constrained by the structure of the data to perform your match.
    In our case, we created a catch-all pattern at the end for erroneous data. Using
    a `switch` statement you would have needed to either filter out the data or perform
    some kind of other data normalization.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的`switch`语句无法像您所看到的那样灵活，因为您不受数据结构的约束。在我们的例子中，我们为错误的数据创建了一个通用模式。使用`switch`语句，您需要过滤数据或执行某种其他数据规范化。
- en: 'This example could also use the destructuring to avoid having three patterns
    with constants (and while we are at it, we will also use the name from the array):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也可以使用解构来避免具有常量的三个模式（同时，我们还将使用数组中的名称）。
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You could also write patterns that match a wide variety of different structures
    and use that to determine what to do based on it. It could also be used to perform
    some kind of basic routing inside a web application:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以编写匹配各种不同结构的模式，并根据它确定要执行的操作。它还可以用于在Web应用程序内执行某种基本路由。
- en: '[PRE46]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Obviously a more specialized library would do a better job at routing with a
    better performances, but keeping the possibility in mind can come in handy and
    it demonstrates the versatility of pattern matching.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，一个更专业的库会更好地执行路由并具有更好的性能，但牢记这种可能性会很方便，并且它展示了模式匹配的多功能性。
- en: Other usages
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他用途
- en: 'If you are just interested in destructuring your data, the `extract` function
    has you covered:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只对解构数据感兴趣，`extract`函数可以满足您的需求。
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Once you've extracted your data, you can use the `extract` function from PHP
    to import the variables into the current scope.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 提取数据后，您可以使用PHP的`extract`函数将变量导入当前作用域。
- en: 'If you want to create functions a bit like we saw in the Haskell examples,
    there is the `func` helper method. Obviously the syntax is not as good, but it
    can come in handy:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建类似我们在Haskell示例中看到的函数，可以使用`func`辅助方法。显然，语法不太好，但它可能会派上用场。
- en: '[PRE48]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Beware that function creation is still in the beta stage at the time of writing.
    There are some issues, so the API might change in the future. If you encounter
    any issues, consult the documentation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，函数创建仍处于测试阶段。存在一些问题，因此API可能会在将来更改。如果遇到任何问题，请参阅文档。
- en: Type classes
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类
- en: Another idea you will encounter often when reading papers, posts, or tutorials
    about functional programming is the type class, especially if the content is about
    Haskell.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读有关函数式编程的论文、帖子或教程时，您经常会遇到的另一个概念是类型类，特别是如果内容涉及Haskell。
- en: The concept of a type class was first introduced in Haskell as a way of implementing
    operators that could be easily overloaded for various types. Since then a lot
    of other uses have been discovered for them. For example, in Haskell, functors,
    applicatives, and monads are all type classes.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类的概念最初是在Haskell中引入的，作为一种实现可以轻松地为各种类型进行重载的操作符的方法。从那时起，人们发现了它们的许多其他用途。例如，在Haskell中，函子、应用函子和单子都是类型类。
- en: Haskell needed type classes mostly because it is not an object-oriented language.
    The overloading of operators was, for example, solved differently in Scala. You
    can write equivalents to type classes in Scala, but it is more of a pattern than
    a language feature. In other languages, there are various ways to emulate some
    features of Haskell type classes using *traits* and *interfaces*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell主要需要类型类，因为它不是面向对象的语言。例如，操作符的重载在Scala中是以不同的方式解决的。您可以在Scala中编写类型类的等效物，但这更像是一种模式而不是一种语言特性。在其他语言中，可以使用*traits*和*interfaces*来模拟Haskell类型类的一些特性。
- en: 'In Haskell, a type class is a set of functions that need to be implemented
    on a given type. One of the simplest examples is the `Eq` type class:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell中，类型类是一组需要在给定类型上实现的函数。最简单的例子之一是`Eq`类型类。
- en: '[PRE49]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Any type implementing, the dedicated term is **derives**, the `Eq` class must
    also have corresponding implementation for the `==` and `/=` operators, otherwise
    you will have a compilation error. This is exactly like an interface for a class,
    but for a type instead. This means you can enforce the creation of operators,
    like in our case, not just methods.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现`Eq`类的类型，都必须为`==`和`/=`操作符实现相应的实现，否则将出现编译错误。这与类的接口非常相似，但适用于类型而不是类。这意味着您可以强制创建操作符，就像我们的情况一样，而不仅仅是方法。
- en: 'You can create instances for your type class pretty easily; here is one for
    the `Maybe` instance:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以相当容易地为您的类型类创建实例；这是`Maybe`实例的一个例子。
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It should be fairly easy to understand. The two `Just` values on the left are
    equal if their inner content is, the`Nothing`value is equal to itself, anything
    else is different. Defining these `Eq` instances allows you to check for the equality
    of two monads anywhere in your Haskell code. The instance definition in itself
    just enforces that the type `m` variable stored inside the monad also implements
    the `Eq` type class.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该很容易理解。 左侧的两个`Just`值在其内部内容相等时是相等的，`Nothing`值等于自身，其他任何值都是不同的。 定义这些`Eq`实例允许您在Haskell代码中的任何地方检查两个单子的相等性。
    实例定义本身只是强制要求存储在单子内的类型`m`变量也实现了`Eq`类型类。
- en: As you can see, the functions from the type class are not implemented inside
    the type. It is done as a separate instance. This allows you to declare this instance
    anywhere in your code.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，类型类的函数并未在类型内部实现。 它是作为一个单独的实例来完成的。 这使您可以在代码的任何地方声明此实例。
- en: 'You can even have multiple instances for the same type class for any given
    type and import the one you need. Imagine, for example, having two monoid instances
    for integers, one for the product and the other for the sum. This is, however,
    discouraged as it causes conflicts when both instances are imported:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以为任何给定类型拥有相同类型类的多个实例，并导入你需要的实例。 想象一下，例如，为整数有两个单子实例，一个是乘积，另一个是总和。 然而，这是不鼓励的，因为当导入两个实例时会导致冲突：
- en: '[PRE51]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Prelude>` is the prompt in the Haskell REPL on which you can simply run Haskell
    code like you do when running PHP on the CLI with the `-a` parameter.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`Prelude>`是Haskell REPL中的提示符，您可以在其中简单地运行Haskell代码，就像在CLI上运行PHP时使用`-a`参数一样。'
- en: We might think that type classes are just interfaces, or rather traits as they
    can also contain implementation. But if we take a closer look at both our type
    class and its implementation for monads, there are at least three shortcomings
    that anything we could do in PHP, at least while being reasonable, will have.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能认为类型类只是接口，或者更确切地说是特征，因为它们也可以包含实现。 但是，如果我们仔细看看我们的类型类及其单子实现，至少有三个缺点，任何我们在PHP中所做的事情，至少在合理的范围内，都会有。
- en: 'To demonstrate this, let''s imagine we created a PHP interface called `Comparable`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，让我们想象我们创建了一个名为`Comparable`的PHP接口：
- en: '[PRE52]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Setting aside the fact that PHP does not allow for operator overloading like
    we demonstrated with the `==` symbol in Haskell, try thinking of the three features
    that a Haskell type class allows that are near to impossible to emulate in PHP.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 撇开PHP不允许像我们在Haskell中用`==`符号演示的那样进行运算符重载这一事实，试着想一想Haskell类型类允许的三个特性，这在PHP中几乎不可能模拟。
- en: Two of them are about enforcing the correct type. Haskell will do checks for
    us automatically, but in PHP we will have to write code to check if our values
    are of the right type. The third issue is related to extensibility. Think, for
    example, of classes declared in an external library that you want to compare.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 其中两个问题与强制正确类型有关。 Haskell将自动为我们进行检查，但在PHP中，我们将不得不编写代码来检查我们的值是否是正确的类型。 第三个问题与可扩展性有关。
    例如，考虑在外部库中声明的要比较的类。
- en: The first issue is related to the fact that the `compare` function expects a
    value of the same type as the interface, meaning if you have two unrelated classes,
    `A` and `B`, both implementing the `Comparable` interface, you could compare an
    instance of the class `A` with an instance of the `B` class without any error
    from PHP. Obviously this is wrong and this forces you to first check if both values
    are of the same type before comparing them.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题与`compare`函数期望与接口相同类型的值有关，这意味着如果您有两个不相关的类`A`和`B`，都实现了`Comparable`接口，您可以比较类`A`的实例与类`B`的实例而不会出现PHP的任何错误。
    显然这是错误的，这迫使您首先检查两个值是否是相同类型，然后再进行比较。
- en: Things get even trickier when you have a class hierarchy as you don't really
    know what type to test for. Haskell, however, will automatically get the first
    common type both values share and use the related comparator.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有一个类层次结构时，情况变得更加棘手，因为您真的不知道要测试什么类型。 然而，Haskell将自动获取两个值共享的第一个公共类型，并使用相关的比较器。
- en: The second issue is a bit more complicated to find out. If we implement the
    `Comparable` interface on any kind of container, we will need to check when the
    comparison is run that the contained values are also comparable. In Haskell, the
    type signature `(Eq m) => Eq (Maybe m)` already takes care of that for us and
    an error will be raised automatically if you try to compare two monads that hold
    non-comparable values.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题更加复杂。 如果我们在任何类型的容器上实现`Comparable`接口，我们将需要在比较运行时检查包含的值是否也是可比较的。 在Haskell中，类型签名`(Eq
    m) => Eq (Maybe m)`已经为我们处理了这个问题，如果您尝试比较包含不可比较值的两个单子，将自动引发错误。
- en: The Haskell type system also enforces that the values inside the monad are of
    the same type, which is an issue related to the first problem we spotted previously.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell类型系统还强制要求单子内的值是相同类型，这与我们之前发现的第一个问题有关。
- en: Finally, the third and probably biggest issue is about the possibility to implement
    the `Comparable` interface on a class from an external library or the core of
    PHP. Since Haskell type class instances are outside of the class itself, you can
    add one for anything at anytime, be it for an existing type class or a new one
    you just created.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第三个问题可能是关于在外部库或PHP核心的类上实现`Comparable`接口的可能性。 由于Haskell类型类实例位于类本身之外，您可以随时为任何类型添加一个实例，无论是现有类型类还是您刚刚创建的新类型类。
- en: You can create adapters or wrapping classes around those objects, but then you
    will have to perform some kind of boxing/unboxing dance to pass the right type
    to the various methods using your objects, which is far from a pleasant experience.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建适配器或包装类来包围这些对象，但然后您将不得不执行某种装箱/拆箱操作，以将正确的类型传递给使用对象的各种方法，这远非愉快的体验。
- en: Scala being an object-oriented language without core support for type classes,
    the extensibility issue is solved cleverly by using a feature of the language
    called **implicit conversion**. Broadly, the idea is that you define a conversion
    from type `A` to type `B` and when the compiler finds a method expecting an instance
    of the `B` class, but you passed an instance of the `A` class, it will look for
    this conversion and apply it if available.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Scala是一种面向对象的语言，没有对类型类提供核心支持，可扩展性问题通过使用语言特性**隐式转换**巧妙地解决了。广义上来说，这个想法是你定义了从类型`A`到类型`B`的转换，当编译器发现一个方法期望一个`B`类的实例，但你传递了一个`A`类的实例时，它会寻找这个转换并在可用时应用它。
- en: This way, you can create the adapters or wrappers we proposed using before,
    but instead of having to perform the transformation manually, the Scala compilers
    take care of it for you, making the process completely transparent.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以创建我们之前提出的适配器或包装器，但是不需要手动执行转换，Scala编译器会为你处理，使整个过程完全透明。
- en: 'As a closing note, since we spoke about comparing objects and redefining operators,
    there are currently two RFCs proposed for PHP about these two topics:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们谈到了比较对象和重新定义运算符，目前有两个关于PHP的RFC提出了关于这两个主题的讨论：
- en: '[https://wiki.php.net/rfc/operator-overloading](https://wiki.php.net/rfc/operator-overloading)'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://wiki.php.net/rfc/operator-overloading](https://wiki.php.net/rfc/operator-overloading)'
- en: '[https://wiki.php.net/rfc/comparable](https://wiki.php.net/rfc/comparable)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://wiki.php.net/rfc/comparable](https://wiki.php.net/rfc/comparable)'
- en: There is, however, no RFC in sight concerning type classes or implicit type
    casting like we saw exists in Scala.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目前还没有关于类型类或隐式类型转换的RFC，就像我们在Scala中看到的那样。
- en: Algebraic structures and category theory
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代数结构和范畴论
- en: Until now we have avoided talking too much about mathematics. This section will
    try to do so in a light way as most functional concepts have roots in mathematics
    and a lot of abstractions we already discussed are ideas taken from the field
    of category theory. The content in this section will probably help you to gain
    a better understanding of the content of this book, but there is no need to understand
    them perfectly to use functional programming.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直避免谈论数学。本节将试图以轻松的方式这样做，因为大多数函数概念都源于数学，我们已经讨论过的许多抽象都是从范畴论领域借鉴的想法。本节的内容可能会帮助你更好地理解本书的内容，但并不需要完全理解它们才能使用函数式编程。
- en: Throughout this section, mathematical terms will be defined when encountered.
    It is not that important that you get all the nuances, it is just to give you
    a broad idea of what we are talking about.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，遇到数学术语时将对其进行定义。重要的不是你理解所有的细微差别，而是给你一个大致的概念。
- en: The root of functional programming is the *lambda calculus*, or *λ-calculus*.
    It is a *Turing complete formal system* in mathematical logic to express computation.
    The term lambda to refer to closure and anonymous functions comes from this. Any
    code you write can be transformed to lambda calculus.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的根源是*λ演算*，或*λ-演算*。它是数理逻辑中的一个*图灵完备形式系统*，用于表达计算。将lambda这个术语用于闭包和匿名函数是来自于这个。你写的任何代码都可以转换为λ演算。
- en: Note
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A language or system is said to be Turing-complete when it can be used to simulate
    a Turing machine. A synonym is computationally universal. All major programming
    languages are Turing-complete, meaning that anything you can write in C, Java,
    PHP, Haskell, JavaScript, and so on, can be also written in any of the others.
    A formal system is composed of the following elements:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个语言或系统可以用来模拟图灵机时，就被称为图灵完备。一个同义词是计算通用。所有主要的编程语言都是图灵完备的，这意味着你可以在C、Java、PHP、Haskell、JavaScript等任何一种语言中编写的任何东西也可以在其他任何一种语言中编写。一个形式系统由以下元素组成：
- en: A finite set of symbols or keywords
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组符号或关键词的有限集
- en: A grammar defining a valid syntax
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个有效语法的语法
- en: A set of axioms, or founding rules
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组公理，或者基本规则
- en: A set of inference rules to derive other rules from the axioms
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组推理规则，用于从公理中推导出其他规则
- en: 'An algebraic structure is a set with one or more operations defined on it and
    a list of axioms, or laws. All abstractions we studied in the previous chapters
    are algebraic structures: monoids, functors, applicatives, and monads. This is
    important, because, when a new problem is shown to follow the same rules as an
    existing set, anything that was previously theorized can be reused.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 代数结构是在其上定义了一个或多个操作的集合，并且有一系列公理或法则。我们在前几章中学习的所有抽象都是代数结构：幺半群、函子、应用函子和单子。这很重要，因为当一个新问题被证明遵循与现有集合相同的规则时，以前理论化的任何东西都可以被重用。
- en: Note
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*A set is a fundamental concept in mathematics. It is a collection of distinct
    objects*. You can decide to group anything together and call it a set, for example,
    the numbers 5, 23, and 42 can form a set {5, 23, 42}. Sets can be defined explicitly
    as we just did, or using a rule, for example, all positive integers.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合是数学中的一个基本概念。它是一组不同对象的集合*。你可以决定将任何东西组合在一起并称之为集合，例如，数字5、23和42可以形成一个集合{5, 23,
    42}。集合可以明确地定义，就像我们刚刚做的那样，也可以使用规则来定义，例如，所有正整数。'
- en: 'Category theory is the field that studies the relationship between two or more
    mathematical structures. It formalizes them in terms of a collection of objects
    and arrows, or **morphisms**. A morphism transforms one object or one category
    to another. A category has two properties:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论是研究两个或多个数学结构之间关系的领域。它以对象和箭头或**态射**的集合来形式化它们。态射将一个对象或一个类别转换为另一个。一个范畴具有两个属性：
- en: The ability to **compose morphisms** associatively
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够**组合态射**以关联
- en: An **identity morphism** going from one object or category to itself
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个从一个对象或类别到自身的**恒等态射**
- en: Sets are one of the multiple possible categories that respect these two properties.
    The idea of category, objects, and morphisms can be highly abstract. For example,
    you can consider types, functions, functors, or monoids as categories. They can
    be finite or infinite and hold a variety objects as long as the two properties
    are respected.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是满足这两个属性的多个可能类别之一。类别、对象和态射的概念可以非常抽象。例如，你可以将类型、函数、函子或幺半群视为类别。只要这两个属性得到遵守，它们可以是有限的或无限的，并且持有各种对象。
- en: 'If you are interested in this subject and want to learn more about the mathematical
    aspect of it, I can recommend the book *Cakes, Custard and Category Theory: Easy
    Recipes for Understanding Complex Maths* written by Eugenia Cheng. It is really
    accessible, no prior mathematical knowledge is required, and actually fun to read.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个主题感兴趣，并想了解更多数学方面的知识，我可以推荐Eugenia Cheng写的书《蛋糕、卡斯塔和范畴论：理解复杂数学的简单配方》。这本书非常易懂，不需要先前的数学知识，而且读起来很有趣。
- en: The whole idea of pure functions and referential transparency comes from the
    lambda calculus. Type systems, and especially Hindley-Milner, are deeply ingrained
    in formal logic and category theory. The concept of morphism is so close to the
    one of function and the fact that composition is at the center of category theory
    results in the fact that most advances made in the last couple of years on functional
    languages being in one way or another linked to this mathematical field.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数和引用透明的整个概念来自于λ演算。类型系统，特别是Hindley-Milner，深深植根于形式逻辑和范畴论中。态射的概念与函数的概念非常接近，而组合处于范畴论的中心，导致了在过去几年对函数式语言的大多数进展在某种程度上与这个数学领域相关。
- en: From mathematics to computer science
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数学到计算机科学
- en: As we just saw, category theory is an important cornerstone in the functional
    world. You don't have to know about it to code functionally, but it definitely
    helps you understand the underlying concepts and reason about the most abstract
    stuff. Also, a lot of the terms used in papers about functional programming or
    even libraries are taken directly from category theory. So, if you develop a good
    instinct about it, it will usually be a lot easier to understand what you are
    reading.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚看到的，范畴论是函数式世界中的一个重要基石。你不必了解它来编写函数式代码，但它绝对有助于你理解基本概念并推理最抽象的东西。此外，关于函数式编程甚至库的论文中使用的许多术语都直接来自范畴论。因此，如果你对它有良好的直觉，通常会更容易理解你所阅读的内容。
- en: 'A category is in fact a pretty simple concept. It is only some objects with
    arrows that go between them. If you are able to represent something graphically
    using those ideas, it will most probably be correct and it will greatly help you
    to understand what is happening. For example, if we decide to represent function
    composition we will end up with something like this:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 类别实际上是一个非常简单的概念。它只是一些对象和它们之间的箭头。如果你能够使用这些想法以图形方式表示某些东西，那么它很可能是正确的，并且将极大地帮助你理解发生了什么。例如，如果我们决定表示函数组合，我们最终会得到类似这样的东西：
- en: '![From mathematics to computer science](graphics/image_07_002.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![从数学到计算机科学](graphics/image_07_002.jpg)'
- en: In the diagram, it doesn't really matter if our three shapes are whole categories
    or objects in a given category. What is, however, immediately clear is that if
    we have two morphisms, `f` and `g`, the result is the same if we apply them sequentially
    or if we apply the composed version. The function can work on the same types,
    for example, we transform from one shape to another, or the triangle represents
    the strings, the diamond represents chars, and the circles represent integers.
    It makes no difference.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，我们的三个形状是整个类别或给定类别中的对象并不重要。然而，立即清楚的是，如果我们有两个态射`f`和`g`，如果我们按顺序应用它们或者应用组合版本，结果是相同的。函数可以在相同类型上工作，例如，我们从一个形状转换到另一个形状，或者三角形代表字符串，菱形代表字符，圆圈代表整数。这没有区别。
- en: 'Another example would be the homomorphism law for applicative; `pure(f)->apply($x)
    == pure(f($x))`. If we consider the `pure` function to be a morphism from one
    category to the category that represents the possible objects for the applicative,
    we can visualize the law as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是applicative的同态定律；`pure(f)->apply($x) == pure(f($x))`。如果我们将`pure`函数视为从一个类别到表示applicative可能对象的类别的态射，我们可以将这个定律可视化如下：
- en: '![From mathematics to computer science](graphics/image_07_003.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![从数学到计算机科学](graphics/image_07_003.jpg)'
- en: The dotted arrow is the `pure` function, which is used to move `x`, `f`, and
    `y` over the applicative category. It becomes fairly self-evident that the law
    is sound when we see it like that. What do you think? By the way, both those diagrams
    are called **commutative diagrams**. In a commutative diagram, each path with
    the same start and endpoints are equivalent when using composition between the
    arrows.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 虚线箭头是`pure`函数，用于在applicative类别中移动`x`，`f`和`y`。当我们这样看时，这个定律显然是正确的。你觉得呢？顺便说一句，这两个图表都被称为**可交换图表**。在可交换图表中，每条具有相同起点和终点的路径在箭头之间使用组合时是等价的。
- en: Also, you could consider that each type is a category and that a morphism is
    a function. You can imagine functions as morphisms going from an object in a category
    to an object in the same category or a different one. You can represent the type
    and class hierarchy by smaller categories inside bigger ones. For example, integers
    and floats would be two categories inside the numeric category and they would
    overlap on some numbers.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以考虑每种类型都是一个类别，而态射是一个函数。你可以想象函数作为从一个类别中的对象到同一个类别或不同类别中的对象的态射。你可以通过更小的类别在更大的类别中表示类型和类别的层次结构。例如，整数和浮点数将是数值类别中的两个类别，并且它们在一些数字上重叠。
- en: This might not be the most academically sound way to describe both types and
    functions and category theory, but it's an easy one to grasp. It makes it easier
    to conceptualize abstract concepts such as functors or monads in parallel with
    what we are accustomed to.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是最学术上正确的描述类型、函数和范畴论的方式，但这是一个容易理解的方式。它使得更容易将抽象概念（如函子或单子）与我们习惯的东西并行概念化。
- en: You can visualize more traditional functions operating on values themselves.
    For example, the `strtoupper` function is a morphism from an object in the `string`
    category to another object in the same category, whereas the `count` method is
    a morphism from an object in the `array` category to an object in the `integer`
    category. So these are arrows from an object to another object.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将更传统的函数可视化为对值本身的操作。例如，`strtoupper`函数是从`string`类别中的一个对象到同一类别中的另一个对象的态射，而`count`方法是从`array`类别中的一个对象到`integer`类别中的一个对象的态射。因此，这些都是从一个对象到另一个对象的箭头。
- en: If we step back from our basic types as we did in the second diagram, we can
    imagine functions working on types themselves. For example, the `pure` function
    of a monad takes a certain category, be it a type or a function, and lifts it
    to a new category in which all objects are now wrapped inside the context of the
    monad.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像在第二个图表中那样，从我们的基本类型中退后一步，我们可以想象函数作用于类型本身。例如，单子的`pure`函数接受某个类别，无论是类型还是函数，并将其提升到一个新的类别中，在这个类别中，所有对象现在都被包裹在单子的上下文中。
- en: The idea is interesting, because any arrows that you had before can also be
    lifted and will continue to have the same results inside their new context, as
    proved by the *homomorphism* law we just visualized.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很有趣，因为你以前的任何箭头也可以被提升，并且将继续在它们的新上下文中产生相同的结果，正如我们刚刚可视化的*同态*法则所证明的那样。
- en: This means that, if you have trouble understanding what is happening when you
    use a monad, or any abstraction really, just draw the operations on a sheet of
    paper using categories, objects, and arrows and you can then boil everything down
    to its essence either by removing or adding context.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果你在使用单子或任何抽象概念时遇到困难，只需在纸上使用类别、对象和箭头绘制操作，然后你可以通过删除或添加上下文将一切归结为其本质。
- en: Important mathematical terms
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重要的数学术语
- en: There are some mathematical terms that you might encounter when reading about
    functional programming. They are used because they allow us to quickly convey
    what the topic is about and what properties can be expected from the structure
    currently described.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读有关函数式编程时，你可能会遇到一些数学术语。它们被使用是因为它们让我们能够快速传达当前描述的结构是关于什么以及可以从中期望什么属性。
- en: 'One such term we already learned about is the monoid. One mathematical definition
    you can find about it is *A monoid is a set that is closed under an associative
    binary operation and possess an identity element*. At this point you should be
    able to understand this definition; however, here is a quick rundown for the string
    concatenation monoid:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了一个这样的术语，那就是幺半群。你可以在数学定义中找到关于它的一个定义：*幺半群是一个在关联二进制操作下封闭并具有单位元素的集合*。在这一点上，你应该能够理解这个定义；然而，这里是一个关于字符串连接幺半群的快速概述：
- en: The set is all possible string values
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合是所有可能的字符串值
- en: The binary operation is the string concatenation operator, `.`
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制操作是字符串连接运算符，`.`
- en: The identity element is the empty string, `''`
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单位元素是空字符串，`''`
- en: The idea of a set being closed under an operation indicates that the given operation
    result is also part of the set. For example, performing an addition of two integers
    will always result in an integer.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 集合在操作下封闭的概念表明给定操作的结果也是集合的一部分。例如，对两个整数进行加法运算总是会得到一个整数。
- en: Here is a quick glossary of various mathematical terms that you might encounter
    in your readings.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你可能在阅读中遇到的各种数学术语的快速词汇表。
- en: '**Associative**: An operation is associative if the order of operation does
    not matter; examples are addition, and product is *a + (b + c) === (a + b) + c*.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联性**：如果操作的顺序不重要，则操作是关联的；例如加法和乘法是 *a + (b + c) === (a + b) + c*。'
- en: '**Commutative**: An operation is commutative if you can change the order of
    the operands. Most associative operations are also commutative as *a + b === b
    + a`*. An example of an associative operation that isn''t commutative is function
    composition as *f (g h) === (f g) h* but *f g != g f*.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交换性**：如果你可以改变操作数的顺序，那么操作是可交换的。大多数关联操作也是可交换的，如 *a + b === b + a`*。一个不可交换的关联操作的例子是函数组合，如
    *f (g h) === (f g) h*，但 *f g != g f*。'
- en: '**Distributive**: Two operations are distributive if *a * (b + c) == (a * b)
    + (a * c)*. In this case, multiplication is "distributive over" addition. In the
    example, *** and *+* can be replaced by any binary operation.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分配性**：如果 *a * (b + c) == (a * b) + (a * c)*，则两个操作是分配的。在这种情况下，乘法是“分配于”加法。在这个例子中，***和*+*可以被任何二进制操作替换。'
- en: '**Semigroup**: A set closed under an associative operation.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半群**：在一个关联操作下封闭的集合。'
- en: '**Monoid**: A semigroup with an identity element.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**幺半群**：具有单位元素的半群。'
- en: '**Group**: A monoid with inverse elements. The inverse is a value you can add
    to another element to get the identity. For example, *10 + -10 = 0, -10* is the
    inverse of 10 in the integer addition group.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**群**：具有逆元素的幺半群。逆元是一个值，你可以将其添加到另一个元素中以获得身份元素。例如，*10 + -10 = 0，-10*是整数加法群中10的逆元。'
- en: '**Abelian group**: A group where the operation is commutative.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阿贝尔群**：操作是可交换的群。'
- en: '**Ring**: An abelian group with a second monoidal operation, which is distributive
    over the first one. For example, integers are a ring where addition is the first
    operation and multiplication is the second.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环**：具有第二个幺半群操作的阿贝尔群，该操作对第一个操作具有分配性。例如，整数是一个环，其中加法是第一个操作，乘法是第二个操作。'
- en: '**Semiring**: A ring where the abelian group is replaced by a commutative monoid
    (that is, the inverse element does not exist).'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半环**：一个环，其中阿贝尔群被可交换的幺半群（即，逆元素不存在）所取代。'
- en: '**Comonad**, **cofunctor**, **coXXX**: The dual category to monad, functor,
    or anything. Another word for dual would be opposite. If a monad is a way to put
    something in a context, its comonad would be the way to get it out from it. This
    is a really vague definition without explaining the use, which would require a
    chapter in itself.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**余单子**、**余函子**、**余XXX**：单子、函子或任何东西的对偶范畴。对偶的另一个词是相反的。如果一个单子是将某物放入上下文的一种方式，那么它的余单子将是从中取出的一种方式。这是一个非常模糊的定义，没有解释用途，这需要一个章节来解释。'
- en: Fantasy Land
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 幻想乡
- en: Now that we've got the theory out of the way, I want to present you the JavaScript
    project that describes interfaces for common algebraic structures named **Fantasy
    Land** at[https://github.com/fantasyland/fantasy-land](https://github.com/fantasyland/fantasy-land).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了理论，我想向你介绍一个描述常见代数结构接口的JavaScript项目，名为**Fantasy Land**，网址为[https://github.com/fantasyland/fantasy-land](https://github.com/fantasyland/fantasy-land)。
- en: It has been widely adopted by the community and more and more projects each
    day implement the proposed interface for a better interoperability between various
    implementations of those algebraic structures. Under the Fantasy Land namespace
    itself you can find implementations of the various monads we already discovered
    before and many other more advanced functional constructs. Notably, there is also
    the **Bilby** library ([http://bilby.brianmckenna.org/](http://bilby.brianmckenna.org/)),
    which tries to be as close as possible to the Haskell philosophy.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 它已经被社区广泛采用，每天有越来越多的项目实现了这个提议的接口，以便更好地在这些代数结构的各种实现之间进行互操作。在幻想乡命名空间下，你可以找到我们之前发现的各种单子的实现，以及许多其他更高级的函数构造。值得注意的是，还有**Bilby**库([http://bilby.brianmckenna.org/](http://bilby.brianmckenna.org/))，它试图尽可能接近Haskell的哲学。
- en: Why am I talking about a JavaScript library? Because the `php-functional` library
    has kind of ported the Fantasy Land specification to PHP [https://github.com/widmogrod/php-functional/tree/master/src/FantasyLand](https://github.com/widmogrod/php-functional/tree/master/src/FantasyLand).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我要谈论一个JavaScript库呢？因为`php-functional`库已经将幻想乡规范移植到了PHP[https://github.com/widmogrod/php-functional/tree/master/src/FantasyLand](https://github.com/widmogrod/php-functional/tree/master/src/FantasyLand)。
- en: I would like nothing better than other projects using those as a base for their
    own implementation of functional code as it would bolster functional programming
    in PHP by providing developers with a bigger set of possible features they can
    use.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我最希望其他项目以这些为基础，实现他们自己的函数代码，因为这将通过为开发人员提供更多可能使用的特性集，来增强PHP中的函数式编程。
- en: At the time of writing, there are discussions to separate the Fantasy Land port
    from the rest of the library so that it can be used without also depending on
    everything else. I hope by the time you read this, undertaking has been completed
    and I urge you to use this set of common interfaces.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，有讨论要将幻想乡移植与库的其余部分分开，以便可以在不依赖其他一切的情况下使用。我希望在你阅读本文时，这项工作已经完成，我敦促你使用这套常见接口。
- en: Monad transformers
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单子变换器
- en: We saw that monads are already a pretty powerful idea if you take each of them
    separately. What if I told that you can compose monads together to benefit from
    the features of multiples of them at the same time? For example, a `Maybe` interface
    and a `Writer` monad that could inform you why the operation returned no result.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，如果你单独考虑每一个单子，它们已经是一个非常强大的想法。如果我告诉你，你可以将单子组合在一起，以便同时从它们的多个特性中受益，你会怎么想？例如，一个`Maybe`接口和一个`Writer`单子，可以告诉你为什么操作没有返回结果。
- en: This is exactly what monad transformers are about. A monad transformer is in
    every respect similar to the monad that it exemplifies, except that it is not
    a standalone entity, instead it modifies the behavior of another monad. In a way,
    we can imagine this as adding a new monadic layer in top of some other monad.
    Of course, you can stack multiple layers on top of one another.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是单子变换器的意义所在。单子变换器在各个方面都类似于它所示范的单子，只是它不是一个独立的实体，而是修改另一个单子的行为。在某种程度上，我们可以想象这是在另一个单子的顶部添加一个新的单子层。当然，你可以将多个层堆叠在一起。
- en: 'In Haskell, most existing monads have a corresponding transformer. Usually,
    they have the same name with a `T` suffixed: `StateT`, `ReaderT`, `WriterT`. If
    you were to apply a transformer to the identity monad, the result will have the
    exact same feature as the equivalent monad as the identity monad is just a simple
    container.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell中，大多数现有的单子都有对应的变换器。通常，它们的名称相同，只是后面加了一个`T`：`StateT`、`ReaderT`、`WriterT`。如果你要将一个变换器应用到恒等单子上，结果将具有与等效单子完全相同的特性，因为恒等单子只是一个简单的容器。
- en: In order for this to work correctly, the `State`, `Reader`, `Writer`, and other
    Haskell monads are in fact type classes with two instances; one is the transformer
    and the other is the traditional monad.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其正确工作，`State`、`Reader`、`Writer`和其他Haskell单子实际上是具有两个实例的类型类；一个是变换器，另一个是传统单子。
- en: We will end our foray here as there are no implementations of this concept I
    am aware of in PHP; it would be sufficiently difficult to try doing it ourselves
    and it would require at least one full chapter.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里结束我们的探索，因为我所知道的PHP中没有这个概念的实现；尝试自己做这件事将是相当困难的，至少需要一个完整的章节。
- en: At least you've heard about the idea and who knows, maybe someone will create
    a library adding monad transformers to PHP in the future.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 至少你已经听说过这个想法，谁知道，也许将来会有人创建一个库，为PHP添加单子变换器。
- en: Lenses
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜头
- en: Modifying data when everything is immutable can become cumbersome pretty quickly
    if you have some complicated data structure. Say, for example, you have a list
    of users, each user has a list of post associated to them and you need to change
    something on one of the posts. You will need to copy or recreate everything just
    to modify your value, since you cannot change anything in place.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切都是不可变的时，修改数据可能会变得非常麻烦，特别是如果你有一些复杂的数据结构。比如，假设你有一个用户列表，每个用户都有与他们关联的帖子列表，你需要在其中一个帖子上做一些改变。由于你不能直接改变任何东西，你需要复制或重新创建一切来修改你的值。
- en: Like I said, cumbersome. But as with mostly everything, there is a nice and
    clean solution in the form of lenses. Imagine your lens as if it was a part of
    a binocular; it lets you focus on one part of your data structure easily. You
    then have the tools to modify this as easily and get a whole new shiny data structure
    with your data changed to whatever you want it to be.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我说的，很繁琐。但与大多数事物一样，镜头有一个漂亮干净的解决方案。想象一下您的镜头就像双筒望远镜的一部分；它让您可以轻松地聚焦在数据结构的一部分上。然后，您可以轻松地修改它，并获得一个全新的闪亮数据结构，其中您的数据已更改为您想要的任何内容。
- en: A lens is a lookup function that lets you get a particular field at the current
    depth of your data structure. You can read from a lens, it will return the pointed
    value. And you can write to a lens, it will return you the whole data structure
    with your modification.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 镜头是一种查找函数，它让您可以在数据结构的当前深度获取特定字段。您可以从镜头中读取，它将返回指定的值。您也可以向镜头写入，它将返回您修改后的整个数据结构。
- en: What is really great about lenses is that since they are functions you can compose
    them, so if you want to go deeper than the first level, compose your second lookup
    function with the first one. And you can add a third, fourth, and so on lookups
    on top of that. At each step you could get or set the value if you want.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 镜头真正伟大的地方在于，由于它们是函数，您可以将它们组合在一起，因此如果您想深入到第一级之下，可以将第二个查找函数与第一个组合。您还可以在其上添加第三、第四等查找。在每一步，您都可以获取或设置值（如果需要）。
- en: And since they are functions, you can use them as any other function, you can
    map them, put them in applicatives, bind them to a monad. Suddenly, an operation
    that was very cumbersome can leverage all the power of your language.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是函数，您可以像使用其他函数一样使用它们，可以映射它们，将它们放入应用函子，将它们绑定到单子。突然之间，一个非常繁琐的操作可以利用您的语言的所有功能。
- en: Sadly, as immutable data structures are not really common in PHP, no one took
    the time to write a lens library for it. Also, the details of how this is possible
    are a bit messy and would need quite some time to explain. This is why we'll leave
    it here for now.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，由于PHP中不常见不可变数据结构，没有人花时间为其编写镜头库。此外，这种可能性的细节有些混乱，需要相当长的时间来解释。这就是为什么我们现在将其留在这里的原因。
- en: If you are interested, the Haskell `lens` library has a webpage with lots of
    information and a great introduction, although a truly challenging video, at [http://lens.github.io/](http://lens.github.io/).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您感兴趣，Haskell的`lens`库有一个网页，上面有大量信息和很好的介绍，尽管有一个真正具有挑战性的视频，网址是[http://lens.github.io/](http://lens.github.io)。
- en: Summary
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a lot of different topics. Some were concepts you
    will be able to use when developing in PHP such as avoiding stack overflows when
    doing recursion, pattern matching, the point-free style, and the usage of the
    `const` keyword to make your code a bit easier to read.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了许多不同的主题。其中一些概念在PHP开发中会很有用，比如在递归时避免堆栈溢出、模式匹配、无点风格以及使用`const`关键字使您的代码更易于阅读。
- en: Others were purely theoretical with no current usage in PHP, ideas that were
    only presented so that you will be able to understand a bit better other writings
    about functional programming, such as monad transformers, the link between functional
    programming and category theory, and lenses.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些主题纯粹是理论性的，在PHP中目前没有使用，这些想法只是为了让您能够更好地理解有关函数式编程的其他写作，比如单子变换器、函数式编程与范畴论之间的联系以及镜头。
- en: Finally, some topics were somewhat in the middle, useful in your day-to-day
    coding, but a bit harder to put in to practice as the support in PHP is lacking.
    Even if it is not perfect, you are now aware of type classes, type signatures,
    and algebraic structures.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有些主题在日常编码中有一定用处，但在PHP中实践起来有些困难，因为支持不足。即使不完美，您现在也了解了类型类、类型签名和代数结构。
- en: I have faith that you were not too much put off by the never-ending change of
    topics in this chapter and that you learned some valuable and interesting stuff.
    I also hope that this content sparked some interest in you to learn more about
    those topics and maybe try a functional language to see what all that hinted goodness
    was about.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信您并没有因为本章中主题的不断变化而感到太过困扰，并且学到了一些有价值和有趣的东西。我也希望这些内容激发了您对这些主题的进一步学习的兴趣，也许尝试一种函数式语言，看看所有这些暗示的好处是什么。
- en: In the next chapter, we'll get back to a more practical topic as we will discuss
    testing functional code first, and second we will learn about a methodology called
    property-based testing, which is not strictly speaking about functional programming,
    but was first theorized in Haskell.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到一个更实际的话题，首先讨论测试功能代码，其次学习一种称为基于属性的测试的方法论，这并不严格属于函数式编程，但最初是在Haskell中理论化的。
