- en: Solving Problems with Advanced Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高级技术解决问题
- en: We have explored different data structures and algorithms so far in this book.
    We are yet to explore some of the most exciting areas of algorithms. There are
    many efficient ways of doing things in computer programming. We will focus on
    some of the key advanced techniques and concepts in this chapter. These topics
    are so important that a separate book could be written about them. However, we
    will keep our focus on the very basic understanding of these advanced topics.
    When we say advanced topics, we are referring to memoization, dynamic programming,
    greedy algorithm, backtracking, puzzle solving, machine learning, and so on. Let's
    learn some new and exciting topics in the following sections.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在本书中已经探讨了不同的数据结构和算法。我们还没有探索一些最激动人心的算法领域。在计算机编程中有许多高效的方法。在本章中，我们将重点关注一些关键的高级技术和概念。这些主题非常重要，以至于可以单独写一本书来讨论它们。然而，我们将专注于对这些高级主题的基本理解。当我们说高级主题时，我们指的是记忆化、动态规划、贪婪算法、回溯、解谜、机器学习等。让我们在接下来的章节中学习一些新颖和激动人心的主题。
- en: Memoization
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆化
- en: 'Memoization is an optimization technique where we the store results of previous
    expensive operations and use them without repeating the operation. It helps us
    speed up the solution significantly. When we have problems where we can have repetitive
    sub problems, we can easily apply this technique to store those results and use
    them later on without repeating the steps. Since PHP has a great support for associative
    arrays and dynamic array properties, we can cache the results without any problems.
    One thing we have to remember is that though we are saving time by caching the
    results, we will require more memory to store these results in the cache. So,
    we have to make the trade-off between space and memory. Now, let''s revisit [Chapter
    5](text00118.html) , *Applying Recursive Algorithms - Recursion* , for our recursive
    example of generating Fibonacci numbers. We will just modify that function with
    a counter to know how many times the function is called and the running time of
    the function to get the thirtieth Fibonacci number. Here is the code for this:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化是一种优化技术，我们在其中存储先前昂贵操作的结果，并在不重复操作的情况下使用它们。这有助于显著加快解决方案的速度。当我们遇到可以重复子问题的问题时，我们可以轻松地应用这种技术来存储这些结果，并在以后使用它们而不重复步骤。由于PHP对关联数组和动态数组属性有很好的支持，我们可以毫无问题地缓存结果。我们必须记住的一件事是，尽管我们通过缓存结果来节省时间，但我们需要更多的内存来存储这些结果。因此，我们必须在空间和内存之间进行权衡。现在，让我们重新访问[第5章](text00118.html)，*应用递归算法-递归*，以了解我们生成斐波那契数的递归示例。我们将只需修改该函数，添加一个计数器来知道函数被调用的次数以及函数运行时间来获取第30个斐波那契数。以下是此代码：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will have the following output in the command line. Note that timing and
    results may vary from one system to the other or from one version of PHP to the
    other. It completely depends on the where the program is running:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在命令行中产生以下输出。请注意，计时和结果可能会因系统不同或PHP版本不同而有所不同。这完全取决于程序运行的位置：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first number 1346269 is the thirtieth Fibonacci number, and the next line
    shows that the `fibonacci` function was called 2692537 times during the generation
    of the thirtieth number. The whole process took 0.5 seconds (we are using the
    `microtime` function of PHP). If we were generating the fiftieth Fibonacci number,
    the function call count would be more than 40 billion times. That is one big number.
    However, we know from our Fibonacci formula that when we are calculating *n* .
    We are doing it through *n* -1 and *n* -2; those are already calculated in the
    previous steps. So, we are repeating the steps, and hence, it is costing us time
    and efficiency. Now, let''s store the Fibonacci results in an indexed array, and
    we will check whether the Fibonacci number we are looking for is already calculated
    or not. If it is calculated, we will use it; otherwise, we will calculate that
    and store the result. Here is the modified code for generating Fibonacci numbers
    using the same recursive process, but with help of memorization:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数字1346269是第30个斐波那契数，下一行显示在生成第30个数字时“fibonacci”函数被调用了2692537次。整个过程花了0.5秒（我们使用了PHP的“microtime”函数）。如果我们要生成第50个斐波那契数，函数调用次数将超过400亿次。这是一个非常大的数字。然而，我们知道根据斐波那契数列的公式，当我们计算n时，我们是通过n-1和n-2来计算的；这些在之前的步骤中已经计算过了。所以，我们在重复这些步骤，因此，这会浪费我们的时间和效率。现在，让我们将斐波那契结果存储在一个索引数组中，并检查我们要找的斐波那契数是否已经计算过。如果已经计算过，我们将使用它；否则，我们将计算并存储结果。以下是使用相同递归过程生成斐波那契数的修改后的代码，但是借助记忆化：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As we can see from the preceding code, we have introduced a new global variable
    called `$fibCache` , which will store the calculated Fibonacci numbers. We also
    check whether the number we are looking for is already in the array or not. We
    do not calculate the Fibonacci if the number is already stored in our cache array.
    If we run this code now, we will see the following output:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们引入了一个名为“$fibCache”的新全局变量，它将存储计算出的斐波那契数。我们还检查我们要查找的数字是否已经在数组中。如果数字已经存储在我们的缓存数组中，我们就不再计算斐波那契数。如果现在运行这段代码，我们将看到以下输出：
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let's examine the result. The thirtieth Fibonacci number is the same as
    we had the last time. However, look at the function call count. It is just 31
    instead of 2.7 million calls. Now, let's look at the time. We have taken only
    0.00005299 seconds, which is 10,000 times faster than the non-memoized version.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查结果。第30个斐波那契数与上次相同。但是，看一下函数调用次数。只有31次，而不是270万次。现在，让我们看看时间。我们只用了0.00005299秒，比非记忆化版本快了10000倍。
- en: With a simple example, we can see that we can optimize our solutions by utilizing
    memoization where it is applicable. One thing we have to remember is that memoization
    will work better where we have repeating sub problems or where we have to consider
    the previous calculation to compute the current or future calculation. Although
    memoization will take extra space to store the partially computed data, utilization
    of memoization can increase performance by a big margin
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个简单的例子，我们可以看到我们可以通过利用适用的记忆化来优化我们的解决方案。我们必须记住的一件事是，记忆化将在我们有重复的子问题或者我们必须考虑以前的计算来计算当前或未来的计算的情况下更有效。尽管记忆化将占用额外的空间来存储部分计算的数据，但利用记忆化可以大幅提高性能
- en: Pattern matching algorithms
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配算法
- en: 'Pattern matching is one of the most common tasks we perform on a day-to-day
    basis. PHP has built-in support for regular expression, and mostly, we rely on
    the regular expression and built-in string functions to solve our regular needs
    for such problems. PHP has a readymade function named `strops` , which returns
    the position of the first occurrence of the string in a text. Since it only returns
    the position of the first occurrence, we can try to write a function that will
    return all possible positions. We will explore the brute-force approach first,
    where we will check each of the character for the actual string with each one
    of the pattern string. Here is the function that will do the job for us:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是我们日常工作中执行的最常见任务之一。PHP内置支持正则表达式，大多数情况下，我们依赖正则表达式和内置字符串函数来解决这类问题的常规需求。PHP有一个名为`strops`的现成函数，它返回文本中字符串的第一次出现的位置。由于它只返回第一次出现的位置，我们可以尝试编写一个函数，它将返回所有可能的位置。我们首先将探讨蛮力方法，其中我们将检查实际字符串的每个字符与模式字符串的每个字符。以下是将为我们完成工作的函数：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The approach is very straightforward. We start from position 0 of the actual
    string and keep on going until the `$N-$M` position, where `$M` is the length
    of the pattern we are looking for. We do not need to search the full string even
    at the worst case where there is no match for the pattern. Now, let''s call the
    function with some arguments:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常直接。我们从实际字符串的位置0开始，一直进行到`$N-$M`位置，其中`$M`是我们要查找的模式的长度。即使在最坏的情况下，模式没有匹配，我们也不需要搜索整个字符串。现在，让我们用一些参数调用函数：
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will produce following output:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we look at our `$txt` string, we can find that there are tree occurrences
    of our pattern `AABA.` The first one is at the beginning, second one is at the
    center, and third one is close to the end of the string. The algorithm we have
    written will take `O((N - M) * M)` complexity, where N is the length of the text
    and M is the length of the pattern we are searching for. If we want, we can improve
    the efficiency of such matching using a popular algorithm known as **Knuth-Morris-Pratt**
    (**KMP** ) string-matching algorithm.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看我们的`$txt`字符串，我们可以发现我们的模式`AABA`出现了三次。第一次是在开头，第二次是在中间，第三次是在字符串末尾附近。我们编写的算法将具有`O((N
    - M) * M)`的复杂度，其中N是文本的长度，M是我们正在搜索的模式的长度。如果需要，我们可以使用一种称为**Knuth-Morris-Pratt**（**KMP**）字符串匹配算法的流行算法来提高这种匹配的效率。
- en: Implementing Knuth-Morris-Pratt algorithm
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Knuth-Morris-Pratt算法
- en: 'Knuth-Morris-Pratt (KMP) string-matching algorithm is very similar to the naive
    algorithm we just implemented. The basic difference is that the KMP algorithm
    uses information from the partial matches and takes a decision to stop matching
    on any mismatch. It can also precompute the locations where the pattern can exist
    so that we can reduce the number of repeating comparison or false checks. The
    KMP algorithm pre-computes a table that helps during the search operation and
    increases efficiency. While implementing KMP algorithm, we need to computer the
    **Longest Proper Prefix Suffix** (**LPS** ). Let''s check the function to generate
    the LPS part:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Knuth-Morris-Pratt（KMP）字符串匹配算法与我们刚刚实现的朴素算法非常相似。基本区别在于KMP算法使用部分匹配的信息，并决定在任何不匹配时停止匹配。它还可以预先计算模式可能存在的位置，以便我们可以减少重复比较或错误检查的次数。KMP算法预先计算了一个在搜索操作期间有助于提高效率的表。在实现KMP算法时，我们需要计算**最长适当前缀后缀**（**LPS**）。让我们检查生成LPS部分的函数：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For our pattern from the previous example AABA, the LPS will be `[0,1,0,1]`
    ; now, let''s write the KMP implementation for our string/pattern search problem:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们之前例子中的模式AABA，LPS将是`[0,1,0,1]`；现在，让我们为我们的字符串/模式搜索问题编写KMP实现：
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code is the implementation of the KMP algorithm. Now, let''s
    run the following example with our implemented algorithm:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是KMP算法的实现。现在，让我们用我们实现的算法运行以下示例：
- en: '[PRE9]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will produce the following output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE10]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The complexity of the KMP algorithm is `O(N + M)` , which is much better than
    regular pattern matching. Here, `O (M)` is for computing LPS and `O (N)` for KMP
    algorithm itself.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: KMP算法的复杂度是`O(N + M)`，比常规模式匹配要好得多。这里，`O(M)`是用于计算LPS，`O(N)`是用于KMP算法本身。
- en: There are many detailed descriptions of the KMP algorithm that can be found
    online.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在网上找到许多关于KMP算法的详细描述。
- en: Greedy algorithms
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贪婪算法
- en: Though the name is greedy algorithms, actually, it is a programming technique
    that focuses on finding out the best possible solution at the given moment. This
    means that greedy algorithm makes a locally optimal choice in the hope that it
    will lead to the globally optimal solution. One thing we have to remember is that
    not all greedy approaches will take us to globally optimal solutions. However,
    still, greedy algorithm is applied in many problem-solving areas. One of the most
    popular uses of greedy algorithm is in Huffman encoding, which is used to encode
    a big text and compress the string by converting them into different codes. We
    will explore the concept and implementation of Huffman coding in the next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名为贪婪算法，但实际上它是一种专注于在给定时刻找到最佳解决方案的编程技术。这意味着贪婪算法在希望它将导致全局最优解的情况下做出局部最优选择。我们必须记住的一件事是，并非所有贪婪方法都会带我们到全局最优解。然而，贪婪算法仍然应用于许多问题解决领域。贪婪算法最常见的用途之一是哈夫曼编码，它用于对大文本进行编码并通过将其转换为不同的代码来压缩字符串。我们将在下一节中探讨哈夫曼编码的概念和实现。
- en: Implementing Huffman coding algorithm
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现哈夫曼编码算法
- en: '**Huffman coding** is a compression technique used to reduce the number of
    bits required to send or store a message or string. It is based on the idea that
    frequently appearing characters will have shorter bit representation, and less
    frequent characters will have longer bit representation. If we consider the Huffman
    coding as a tree structure, the less frequent characters or items will be at the
    top part of the tree and more frequent items will be at the bottom of the tree
    or in the leaf. Huffman encoding relies a lot on the priority queue. Huffman encoding
    can be computed by first creating a tree of nodes.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈夫曼编码**是一种压缩技术，用于减少发送或存储消息或字符串所需的位数。它基于这样一个想法，即频繁出现的字符将具有较短的位表示，而不太频繁的字符将具有较长的位表示。如果我们将哈夫曼编码视为树结构，则较不频繁的字符或项目将位于树的顶部，而更频繁的项目将位于树的底部或叶子中。哈夫曼编码在很大程度上依赖于优先级队列。哈夫曼编码可以通过首先创建节点树来计算。'
- en: 'Process to create a tree of nodes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建节点树的过程：
- en: We have to create a leaf node for each symbol and add it to the priority queue.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须为每个符号创建一个叶节点并将其添加到优先级队列。
- en: 'While there is more than one node in the queue, do the following:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当队列中有多个节点时，执行以下操作：
- en: 1\. Remove the node of highest priority (lowest probability/frequency) twice
    to get two nodes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 两次删除优先级最高（概率/频率最低）的节点以获得两个节点。
- en: 2\. Create a new internal node with these two nodes as children and with probability/frequency
    equal to the sum of the two nodes' probabilities/frequencies.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 创建一个新的内部节点，将这两个节点作为子节点，并且概率/频率等于这两个节点概率/频率的总和。
- en: 3\. Add the new node to the queue.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 将新节点添加到队列中。
- en: The remaining node is the root node, and the tree is complete.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的节点是根节点，树是完整的。
- en: 'Then, we have to traverse the constructed binary tree from root to leaves assigning
    and accumulating a "0" for one branch and a "1" for the other at each node. The
    accumulated zeros and ones at each leaf constitute a Huffman encoding for those
    symbols and weights. Here is an implementation of Huffman encoding algorithm using
    the SPL priority queue:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须从根到叶遍历构建的二叉树，在每个节点分配和累积“0”和“1”。每个叶子处累积的零和一构成了这些符号和权重的哈夫曼编码。以下是使用SPL优先级队列实现的哈夫曼编码算法：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we are building a min heap for each of the symbols and using their weight
    to set the priority. Once the heap is constructed, we extract two nodes one after
    another and combining their data and priority to add them back to the heap. This
    continues unless only one node exists, which is the root node. Now, let''s run
    the following code to generate the Huffman code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为每个符号构建了一个最小堆，并使用它们的权重来设置优先级。一旦堆构建完成，我们依次提取两个节点，并将它们的数据和优先级组合以将它们添加回堆中。这将继续，直到只剩下一个节点，即根节点。现在，让我们运行以下代码生成哈夫曼编码：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we are using `str_split` to break the string into an array and then using
    array count values to convert it into an associative array where the character
    will be the key and its number of appearance in the string will be the value.
    The preceding code will produce the following output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`str_split`将字符串分割成数组，然后使用数组计数值将其转换为一个关联数组，其中字符将是键，字符串中出现的次数将是值。上述代码将产生以下输出：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There are many other practical usages of greedy algorithms. We will solve a
    job-scheduling problem with greedy algorithms. Let''s consider an example of a
    team of agile software developers who are working in a two-week iteration or sprint.
    They have some user stories to complete with some deadlines (by date) for the
    tasks and velocity (size of the story) attached to the story. The target for the
    team is to gain maximum velocity for the sprint within the given deadline. Let''s
    consider the following tasks with deadline and velocity:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 贪婪算法有许多其他实际用途。我们将使用贪婪算法解决作业调度问题。让我们考虑一个敏捷软件开发团队的例子，他们在两周的迭代或冲刺中工作。他们有一些用户故事要完成，这些故事有一些任务的截止日期（按日期）和与故事相关的速度（故事的大小）。团队的目标是在给定的截止日期内获得冲刺的最大速度。让我们考虑以下具有截止日期和速度的任务：
- en: '| **Index** | 1 | 2 | 3 | 4 | 5 | 6 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **索引** | 1 | 2 | 3 | 4 | 5 | 6 |'
- en: '| **Story** | S1 | S2 | S3 | S4 | S5 | S6 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **故事** | S1 | S2 | S3 | S4 | S5 | S6 |'
- en: '| **Deadline** | 2 | 1 | 2 | 1 | 3 | 4 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **截止日期** | 2 | 1 | 2 | 1 | 3 | 4 |'
- en: '| **Velocity** | 95 | 32 | 47 | 42 | 28 | 64 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **速度** | 95 | 32 | 47 | 42 | 28 | 64 |'
- en: 'As we can see from the preceding table, we have six user stories, and they
    have four different deadlines from **1** to **4** . We have to finish the user
    story **S2** or **S4** for slot 1 since the deadline for the task is 1\. The same
    goes for story **S1** and **S3,** and they have to be finished on or before slot
    **2** . However, since we have **S3** and the velocity of **S3** is bigger than
    **S2** and **S4, S3** will be chosen for slot 1 by the greedy approach. Let''s
    write the greedy code for our velocity calculation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从上表中可以看出，我们有六个用户故事，它们有四个不同的截止日期，从1到4。我们必须在时间槽1完成用户故事**S2**或**S4**，因为任务的截止日期是1。对于故事**S1**和**S3**也是一样，它们必须在时间槽**2**之前或之内完成。然而，由于我们有**S3**，而**S3**的速度大于**S2**和**S4**，所以**S3**将被贪婪地选择为时间槽1。让我们为我们的速度计算编写贪婪代码：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we are getting the list of jobs (user story ID, deadline, and velocity)
    that we will use to find the maximum velocity and their respective user story
    ID. First, we sort the jobs array with custom user sort function `usort` and sort
    the array in the descending order based on their velocity. After that, we calculate
    the maximum number of slots available from the deadline column. We are then initializing
    the slot array to -1 to keep a flag of used slots. The next code block is to traverse
    through each of the user stories and find a proper slot for the user story. If
    the available timeslots are filled, we don''t continue further. Now, let''s run
    this code using the following code block:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们得到了作业列表（用户故事ID，截止日期和速度），我们将用它们来找到最大速度及其相应的用户故事ID。首先，我们使用自定义用户排序函数`usort`对作业数组进行排序，并根据它们的速度按降序对数组进行排序。之后，我们计算从截止日期列中可用的最大时间槽数。然后，我们将时间槽数组初始化为-1，以保持已使用时间槽的标志。下一个代码块是遍历每个用户故事，并为用户故事找到合适的时间槽。如果可用的时间槽已满，我们就不再继续。现在，让我们使用以下代码块运行此代码：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will produce the following output in command line:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在命令行中产生以下输出：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Greedy algorithms can be helpful in solving locally optimized problems such
    as job scheduling, network traffic control, graph algorithm, among other things.
    However, to get a globally optimized solution, we need to focus on another aspect
    of algorithms, which is known as dynamic programming.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 贪婪算法可以帮助解决诸如作业调度、网络流量控制、图算法等局部优化问题。然而，要获得全局优化的解决方案，我们需要关注算法的另一个方面，即动态规划。
- en: Understanding dynamic programming
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解动态规划
- en: Dynamic programming is a way of solving complex problems by dividing them into
    smaller sub problems and finding solution for those sub problems. We accumulate
    the solutions of sub problems to find the global solution. The good part of dynamic
    programming is that we reduce the recalculation of sub problems by storing their
    results. Dynamic programming is a very well-known method for optimization. The
    use of dynamic algorithm can be found everywhere in the programming world. Dynamic
    programming can solve problems such as coin changing, finding the longest common
    subsequence, finding the longest increasing sequences, sequencing DNA strings,
    and so on. The core difference between the greedy algorithm and dynamic programming
    is that dynamic programming will always prefer a globally optimized solution.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划是通过将复杂问题分解为较小的子问题并找到这些子问题的解决方案来解决复杂问题的一种方法。我们累积子问题的解决方案以找到全局解决方案。动态规划的好处是通过存储它们的结果来减少子问题的重新计算。动态规划是优化的一个非常著名的方法。动态规划可以解决问题，如找零钱、找到最长公共子序列、找到最长递增序列、排序DNA字符串等。贪婪算法和动态规划的核心区别在于，动态规划总是更倾向于全局优化的解决方案。
- en: We can solve a problem with dynamic programming if the problem has either optimal
    substructure or overlapping sub problems. Optimal substructure means that the
    optimization for the actual problem can be solved using a combination of optimal
    solution of its sub problems. In other words, if a problem is optimized for n,
    it will be optimized for any size less than n or more than n. The overlapping
    sub problems indicates that smaller sub problems will be solved over and over
    again as they are overlapping with each other. Fibonacci series is a great example
    for overlapping sub problems. So, having basic recursion here will not help at
    all. Dynamic programming solves each subproblem exactly once and does not attempt
    to resolve any further. It is achieved either via a top-down approach or a bottom-up
    approach.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题具有最优子结构或重叠子问题，我们可以使用动态规划来解决问题。最优子结构意味着实际问题的优化可以使用其子问题的最优解的组合来解决。换句话说，如果问题对n进行了优化，那么对于小于n或大于n的任何大小，它都将被优化。重叠子问题表示较小的子问题将一遍又一遍地解决，因为它们彼此重叠。斐波那契数列是重叠子问题的一个很好的例子。因此，在这里基本的递归将一点帮助也没有。动态规划只解决每个子问题一次，并且不会尝试进一步解决任何问题。这可以通过自顶向下的方法或自底向上的方法来实现。
- en: In a top-down approach, we start with a bigger problem and recursively solve
    the smaller sub problems. However, we have to use the memoization technique to
    store the subproblem results so that we do not have to recalculate that subproblem
    in future. In the bottom-up approach, we solve the smallest subproblem first and
    then move to the other smaller sub problems. Usually, subproblem results are stored
    in a tabular format using a multidimensional array for bottom-up approach.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在自顶向下的方法中，我们从一个更大的问题开始，递归地解决较小的子问题。然而，我们必须使用记忆化技术来存储子问题的结果，以便将来不必重新计算该子问题。在自底向上的方法中，我们首先解决最小的子问题，然后再转向其他较小的子问题。通常，使用多维数组以表格格式存储子问题的结果。
- en: Now, we will explore some examples from the dynamic programming world. Some
    might sound very familiar from our day-to-day programming problems. We will get
    started with the famous knapsack problem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨动态规划世界中的一些例子。有些可能在我们日常编程问题中听起来很熟悉。我们将从著名的背包问题开始。
- en: 0 - 1 knapsack
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 0-1背包
- en: 'A knapsack is a bag with straps, usually carried by soldiers to help them take
    their necessary items or valuables during their journey. Each item has a value
    and definite weight attached to it. So, the soldier has to pick the most valuable
    items within their maximum weight limit as they cannot put everything in their
    bag. The word 0/1 means that either we can take it or leave it. We cannot take
    an item partially. This is known as the famous 0-1 knapsack problem. We will take
    the bottom-up approach for solving the 0-1 knapsack problem. Here is the pseudocode
    for the solution:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 背包是一种带有肩带的袋子，通常由士兵携带，以帮助他们在旅途中携带必要的物品或贵重物品。每件物品都有一个价值和确定的重量。因此，士兵必须在其最大重量限制内选择最有价值的物品，因为他们无法把所有东西都放在包里。0/1表示我们要么可以拿走它，要么留下它。我们不能部分拿走物品。这就是著名的0-1背包问题。我们将采用自底向上的方法来解决0-1背包问题。以下是解决方案的伪代码：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For example, if we have five items, `[1,2,3,4,5]` , and they have the weight
    of 10,20,30,40,50, respectively, a maximum allowed weight of 10 will produce the
    following table using the bottom-up approach:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有五个物品，`[1,2,3,4,5]`，它们的重量分别为10,20,30,40,50，最大允许的重量为10，将使用自底向上的方法产生以下表：
- en: '![](Image00091.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00091.jpg)'
- en: 'As we can see, we build the up the table bottom up where we start with one
    item and one weight and increase it to our desired weight and maximize the value
    count by choosing the best possible items. At the end, the last cell in the bottom-right
    corner is the one with the expected result for the 0-1 knapsack problem. Here
    is the implementation and code to run the function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们从底部开始构建表格，从一个物品和一个重量开始，逐渐增加到我们想要的重量，并通过选择最佳可能的物品来最大化价值计数。最后，底部右下角的最后一个单元格是0-1背包问题的预期结果。以下是运行该函数的实现和代码：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will show 100 on the command line, which actually matches our expected
    result from the preceding table. The complexity of this algorithm is O (*n* **W*
    ), where n is the number of items and W is the target weight.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在命令行上显示100，这实际上与我们从前面的表中预期的结果相匹配。该算法的复杂度为O（*n* **W*），其中n是物品的数量，W是目标重量。
- en: Finding the longest common subsequence-LCS
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找最长公共子序列-LCS
- en: 'Another very popular algorithm to solve using dynamic programming is finding
    the longest common subsequence, or LCS, between two strings. The process is very
    similar to the knapsack solution where we had a two-dimensional table and we started
    with one weight to move to our target weight. Here, we will start with the first
    character of the first string and move across the whole string for the second
    string to match the characters. We will continue this until all the characters
    of the first string are matched with individual characters of the second string.
    So, when we find a match, we consider the top-left corner cell or diagonally left
    cell of the matched cell. Let''s consider the following two tables to understand
    how the matching occurs:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态规划解决的另一个非常流行的算法是找到两个字符串之间的最长公共子序列或LCS。这个过程与解决背包问题的过程非常相似，我们有一个二维表格，从一个重量开始移动到我们的目标重量。在这里，我们将从第一个字符串的第一个字符开始，并横跨整个字符串以匹配字符。我们将继续进行，直到第一个字符串的所有字符都与第二个字符串的各个字符匹配。因此，当我们找到匹配时，我们会考虑匹配单元格的左上角单元格或对角线左侧单元格。让我们考虑以下两个表格，以了解匹配是如何发生的：
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;  &#124;  &#124; A &#124; B &#124;'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;  &#124;  &#124; A &#124; B &#124;'
- en: '&#124;  &#124; 0 &#124; 0 &#124; 0 &#124;'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;  &#124; 0 &#124; 0 &#124; 0 &#124;'
- en: '&#124; C &#124; 0 &#124; 0 &#124; 0 &#124;'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; C &#124; 0 &#124; 0 &#124; 0 &#124;'
- en: '&#124; B &#124; 0 &#124; 0 &#124; 1 &#124;'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; B &#124; 0 &#124; 0 &#124; 1 &#124;'
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;  &#124;  &#124; B &#124; D &#124;'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;  &#124;  &#124; B &#124; D &#124;'
- en: '&#124;  &#124; 0 &#124; 0 &#124; 0 &#124;'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;  &#124; 0 &#124; 0 &#124; 0 &#124;'
- en: '&#124; B &#124; 0 &#124; 1 &#124; 1 &#124;'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; B &#124; 0 &#124; 1 &#124; 1 &#124;'
- en: '&#124; D &#124; 0 &#124; 1 &#124; 2 &#124;'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; D &#124; 0 &#124; 1 &#124; 2 &#124;'
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'On the left table, we have two strings AB and CB. When B matches B in the table,
    the value of the matched cell will be the value of its diagonal cell plus one.
    That is why the dark background cell of the first table has a value of 1 since
    the diagonally left cell has a value of 0\. For the same reason, the table on
    the right has right lowest cell of value 2 as the diagonal cell has a value of
    1\. Here is the pseudocode for finding the LCS length:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧的表中，我们有两个字符串AB和CB。当B在表中匹配B时，匹配单元格的值将是其对角线单元格的值加一。这就是为什么第一个表的深色背景单元格的值为1，因为对角线左侧单元格的值为0。出于同样的原因，右侧表格的右下角单元格的值为2，因为对角线单元格的值为1。以下是查找LCS长度的伪代码：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is the implementation of our pseudocode to find the LCS length:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的伪代码实现，用于查找LCS长度：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s run the `LCS` function with two strings to see whether we can find
    the longest common subsequence:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行`LCS`函数与两个字符串，看看是否可以找到最长的公共子序列：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will produce the output `LCS Length:5` in the command line. This seems
    to be correct as both the strings have GGTAB as the common subsequence.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在命令行中产生输出`LCS Length:5`。这似乎是正确的，因为两个字符串都有GGTAB作为公共子序列。
- en: DNA sequencing using dynamic programming
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态规划进行DNA测序
- en: 'We have just seen how to find the longest common subsequence. Using the same
    principle, we can implement DNA or protein sequencing, which can be very helpful
    for us in solving bioinformatic problems. For alignment purpose, we will use the
    most popular algorithm known as the Needleman-Wunsch algorithm. It is similar
    to our LCS algorithm, but the scoring system is different. Here, we score a match,
    mismatch, and gap in a different scoring system. There are two parts of the algorithm:
    one to calculate the matrix with possible sequence and the second part is tracking
    back the actual sequence with the best possible one. The Needleman-Wunsch algorithm
    provides the best global alignment solution for any given sequence. Since the
    algorithm itself is little bigger along with the scoring system explanation, which
    we can find in many websites or books, we want to keep our focus on the implementation
    part of the algorithm. We will divide the problem into two parts. First, we will
    generate the computational table using dynamic programming, and then, we will
    track it backwards to generate the actual sequence alignment. For our implementation,
    we will use 1 for matching, and -1 for gap penalty and mismatch score. Here is
    the first part of our implementation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何找到最长公共子序列。使用相同的原理，我们可以实现DNA或蛋白质测序，这对我们解决生物信息学问题非常有帮助。为了对齐目的，我们将使用最流行的算法，即Needleman-Wunsch算法。它类似于我们的LCS算法，但得分系统不同。在这里，我们对匹配、不匹配和间隙进行不同的得分系统。算法有两部分：一部分是计算可能序列的矩阵，另一部分是回溯找到最佳序列。Needleman-Wunsch算法为任何给定序列提供了最佳的全局对齐解决方案。由于算法本身有点复杂，加上得分系统的解释，我们可以在许多网站或书籍中找到，我们希望把重点放在算法的实现部分。我们将把问题分为两部分。首先，我们将使用动态规划生成计算表，然后我们将向后跟踪以生成实际的序列对齐。对于我们的实现，我们将使用1表示匹配，-1表示间隙惩罚和不匹配得分。以下是我们实现的第一部分：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we have created a two-dimensional array of size M,N, where M is the size
    of string #1 and N is the size of string #2\. We initialized the first row and
    column of the grid to a negative value in the decreasing order. We multiplied
    the index with a gap penalty to achieve this behavior. Here, our constant SP indicates
    the matching score point, MS for mismatch score, GP for gap penalty, and GC indicates
    the Gap Character, which we will use during sequence printing. At the end of dynamic
    programming, the matrix will be generated. Let''s consider the following two strings:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个大小为M，N的二维数组，其中M是字符串#1的大小，N是字符串#2的大小。我们将网格的第一行和第一列初始化为递减顺序的负值。我们将索引乘以���隙惩罚来实现这种行为。在这里，我们的常数SP表示匹配得分点，MS表示不匹配得分，GP表示间隙惩罚，GC表示间隙字符，在序列打印时我们将使用它。在动态规划结束时，矩阵将被生成。让我们考虑以下两个字符串：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, our table will look like this after running the Needleman algorithm:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行Needleman算法后，我们的表将如下所示：
- en: '|  |  | G | A | A | T | T | C | A | G | T | T | A |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|  |  | G | A | A | T | T | C | A | G | T | T | A |'
- en: '|  | 0 | -1 | -2 | -3 | -4 | -5 | -6 | -7 | -8 | -9 | -10 | -11 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|  | 0 | -1 | -2 | -3 | -4 | -5 | -6 | -7 | -8 | -9 | -10 | -11 |'
- en: '| G | -1 | 1 | 0 | -1 | -2 | -3 | -4 | -5 | -6 | -7 | -8 | -9 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| G | -1 | 1 | 0 | -1 | -2 | -3 | -4 | -5 | -6 | -7 | -8 | -9 |'
- en: '| G | -2 | 0 | 0 | -1 | -2 | -3 | -4 | -5 | -4 | -5 | -6 | -7 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| G | -2 | 0 | 0 | -1 | -2 | -3 | -4 | -5 | -4 | -5 | -6 | -7 |'
- en: '| A | -3 | -1 | 1 | 1 | 0 | -1 | -2 | -3 | -4 | -5 | -6 | -5 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| A | -3 | -1 | 1 | 1 | 0 | -1 | -2 | -3 | -4 | -5 | -6 | -5 |'
- en: '| T | -4 | -2 | 0 | 0 | 2 | 1 | 0 | -1 | -2 | -3 | -4 | -5 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| T | -4 | -2 | 0 | 0 | 2 | 1 | 0 | -1 | -2 | -3 | -4 | -5 |'
- en: '| C | -5 | -3 | -1 | -1 | 1 | 1 | 2 | 1 | 0 | -1 | -2 | -3 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| C | -5 | -3 | -1 | -1 | 1 | 1 | 2 | 1 | 0 | -1 | -2 | -3 |'
- en: '| G | -6 | -4 | -2 | -2 | 0 | 0 | 1 | 1 | 2 | 1 | 0 | -1 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| G | -6 | -4 | -2 | -2 | 0 | 0 | 1 | 1 | 2 | 1 | 0 | -1 |'
- en: '| A | -7 | -5 | -3 | -1 | -1 | -1 | 0 | 2 | 1 | 1 | 0 | 1 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| A | -7 | -5 | -3 | -1 | -1 | -1 | 0 | 2 | 1 | 1 | 0 | 1 |'
- en: 'Now, using this scoring table, we can find out the actual sequence. Here, we
    will start from the bottom-right cell in the table and consider the top cell,
    left cell, and the diagonal cell values. If the max value among the three cells
    is the top one, then the top string requires an insertion of gap character (-).
    If the maximum value is the diagonal one, then there is a better chance of matching.
    So, we can compare the two characters of the two strings, and if they match, then
    we can put a bar or pipe character to show the alignment. Here is what the sequencing
    function will look like:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用这个得分表，我们可以找出实际的序列。在这里，我们将从表中的右下角单元格开始，并考虑顶部单元格、左侧单元格和对角线单元格的值。如果三个单元格中的最大值是顶部单元格，则顶部字符串需要插入间隙字符(-)。如果最大值是对角线单元格，则匹配的可能性更大。因此，我们可以比较两个字符串的两个字符，如果它们匹配，则可以放置一条竖线或管字符来显示对齐。以下是序列函数的样子：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since we are starting from back and slowly moving to the front, we are using
    array push to keep the alignment in order. Then, we are printing the array by
    reversing it. The complexity of the algorithm is O (M * N). Here is the output
    if we call `NWSquencing` for our two strings `$X` and `$Y` :'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是从后往前开始，慢慢向前移动，我们使用数组推送来保持对齐顺序。然后，我们通过反转数组来打印数组。算法的复杂度为O(M*N)。如果我们为我们的两个字符串`$X`和`$Y`调用`NWSquencing`，输出将如下所示：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Backtracking to solve puzzle problem
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回溯解决难题问题
- en: Backtracking is a recursive algorithm strategy where we backtrack when a result
    is not found and continue search for solution in other possible ways. Backtracking
    is a popular way to solve many famous problems, especially chess, Sudoku, crosswords,
    and so on. Since recursion is the key component of backtracking, we need to ensure
    that our problem can be divided into sub problems, and we apply recursion into
    those sub problems. In this section, we will solve one of the most popular games,
    Sudoku, using backtracking.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯是一种递归算法策略，当找不到结果时我们回溯并继续在其他可能的方式中搜索解决方案。回溯是解决许多著名问题的一种流行方式，尤其是国际象棋、数独、填字游戏等。由于递归是回溯的关键组成部分，我们需要确保我们的问题可以分解为子问题，并将递归应用到这些子问题中。在本节中，我们将使用回溯来解决最受欢迎的游戏之一，数独。
- en: 'In Sudoku, we have a partially filled box with nice boxes of size 3X3\. The
    rule of the game is to place a number 1 to 9 in each cell, where the same number
    cannot exist in the same row or column. So, in the 9X9 cell, each number 1 to
    9 will be present only once for each row and each column:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在数独中，我们有一个部分填充的盒子，大小为3X3。游戏的规则是在每个单元格中放置1到9的数字，其中相同的数字不能存在于同一行或同一列。因此，在9X9单元格中，每个数字1到9将分别出现一次，每行和每列都是如此。
- en: '|  |  | 7 |  | 3 |  | 8 |  |  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 7 |  | 3 |  | 8 |  |  |'
- en: '|  |  |  | 2 |  | 5 |  |  |  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  | 2 |  | 5 |  |  |  |'
- en: '| 4 |  |  | 9 |  | 6 |  |  | 1 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 4 |  |  | 9 |  | 6 |  |  | 1 |'
- en: '|  | 4 | 3 |  |  |  | 2 | 1 |  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  | 4 | 3 |  |  |  | 2 | 1 |  |'
- en: '| 1 |  |  |  |  |  |  |  | 5 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 1 |  |  |  |  |  |  |  | 5 |'
- en: '|  | 5 | 8 |  |  |  | 6 | 7 |  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|  | 5 | 8 |  |  |  | 6 | 7 |  |'
- en: '| 5 |  |  | 1 |  | 8 |  |  | 9 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 5 |  |  | 1 |  | 8 |  |  | 9 |'
- en: '|  |  |  | 5 |  | 3 |  |  |  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  | 5 |  | 3 |  |  |  |'
- en: '|  |  | 2 |  | 9 |  | 5 |  |  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 2 |  | 9 |  | 5 |  |  |'
- en: 'For example, in the preceding Sudoku board, the first column has 4, 1, 5 and
    the first row have 7, 3, 8\. As a result, we cannot use any of these six numbers
    in the first empty cell on the top left. So, the possible numbers can be 2, 6,
    and 9\. We do not know which one of these numbers will satisfy the solution. We
    can pick two and put in the first cell and then start looking for values for the
    remaining empty cells. This will continue until all the cells are filled up or
    still there is a way to place a number in the empty cell without violating the
    game principle. If no solution is possible, we will backtrack and come back to
    2 again, replace it with the next possible option 6, and run the same recursive
    way of finding numbers for other empty cells. This continues until the board is
    solved. Let''s write some recursive code to solve the Sudoku:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面的数独板中，第一列有4、1、5，第一行有7、3、8。因此，我们不能在左上角的第一个空单元格中使用这六个数字中的任何一个。因此，可能的数字可以是2、6和9。我们不知道这些数字中的哪一个将满足解决方案。我们可以选择两个数字放在第一个单元格中，然后开始寻找其余空单元格的值。这将持续到所有单元格都填满，或者仍然有一种方法可以在空单元格中放置一个数字而不违反游戏原则。如果没有解决方案，我们将回溯并回到2，再用下一个可能的选项6替换它，并运行相同的递归方式找到其他空单元格的数字。这将持续到解决数独。让我们写一些递归代码来解决数独：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we can see all the auxiliary functions required to implement the `Sudoku`
    function. First, we defined the max size of the grid along with the unassigned
    cell indicator, which is 0 in this case. The first function we have is to find
    any unassigned location in the 9 X 9 grid, starting from the top-left corner cell,
    and search the empty cell row wise. Then, we have three functions to check whether
    a number is used in a particular row or column or a 3 X 3 box. If the number is
    not used in the row, column, or in the box, we can use it for a possible value
    in the cell, and that is why, we are returning true in the `isSafe` function check.
    If it is used in any one of these places, the function will return false. Now,
    we are ready to implement the recursive function for solving the Sudoku:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到实现`Sudoku`函数所需的所有辅助函数。首先，我们定义了网格的最大大小以及未分配单元格指示符，在这种情况下为0。我们的第一个函数是在9X9网格中查找任何未分配的位置，从左上角单元格开始，逐行搜索空单元格。然后，我们有三个函数来检查数字是否在特定行、列或3X3框中使用。如果数字在行、列或框中没有使用，我们可以将其用作单元格中的可能值，这就是为什么在`isSafe`函数检查中我们返回true。如果它在这些地方的任何一个中使用，函数将返回false。现在，我们准备实现解决数独的递归函数：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `SolveSudoku` function is self-explanatory. Here, we visited one cell,
    and if the cell is empty, put a temporary number, any number from 1 to 9, in the
    cell. Then, we checked whether the number is redundant in the row or in the column
    or in the 3 X 3 matrix. If it does not conflict, we keep the number in the cell
    and move to the next empty cell. We do this via recursion so that if required,
    we can track back and change the value in the case of a conflict. This continues
    until a solution is found. We also have added a `printGrid` function to print
    a given grid in the command line. Let''s now run the code with the sample Sudoku
    matrix we have used in this example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`SolveSudoku`函数是不言自明的。在这里，我们访问了一个单元格，如果单元格是空的，就在单元格中放入一个临时数字，从1到9的任意数字。然后，我们检查数字是否在行、列或3X3矩阵中是多余的。如果不冲突，我们将数字保留在单元格中并移动到下一个空单元格。我们通过递归来做到这一点，这样如果需要的话，我们可以跟踪回来并在冲突的情况下更改单元格中的值。这将持续到找到解决方案为止。我们还添加了一个`printGrid`函数，在命令行中打印给定的网格。现在让我们用这个示例数独矩阵运行代码：'
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have used a two-dimensional array to represent our Sudoku matrix. If we
    run the code, it will produce following output in the command line:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个二维数组来表示我们的数独矩阵。如果我们运行代码，它将在命令行中产生以下输出：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Alternatively, if we present that in a nice Sudoku matrix, it will look like
    this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们以一个漂亮的数独矩阵呈现，它将看起来像这样：
- en: '| 2 | 9 | 7 | 4 | 3 | 1 | 8 | 5 | 6 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 9 | 7 | 4 | 3 | 1 | 8 | 5 | 6 |'
- en: '| 3 | 6 | 1 | 2 | 8 | 5 | 4 | 9 | 7 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 6 | 1 | 2 | 8 | 5 | 4 | 9 | 7 |'
- en: '| 4 | 8 | 5 | 9 | 7 | 6 | 3 | 2 | 1 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 8 | 5 | 9 | 7 | 6 | 3 | 2 | 1 |'
- en: '| 7 | 4 | 3 | 6 | 5 | 9 | 2 | 1 | 8 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 4 | 3 | 6 | 5 | 9 | 2 | 1 | 8 |'
- en: '| 1 | 2 | 6 | 8 | 4 | 7 | 9 | 3 | 5 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 6 | 8 | 4 | 7 | 9 | 3 | 5 |'
- en: '| 9 | 5 | 8 | 3 | 1 | 2 | 6 | 7 | 4 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 5 | 8 | 3 | 1 | 2 | 6 | 7 | 4 |'
- en: '| 5 | 3 | 4 | 1 | 2 | 8 | 7 | 6 | 9 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 3 | 4 | 1 | 2 | 8 | 7 | 6 | 9 |'
- en: '| 8 | 7 | 9 | 5 | 6 | 3 | 1 | 4 | 2 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 7 | 9 | 5 | 6 | 3 | 1 | 4 | 2 |'
- en: '| 6 | 1 | 2 | 7 | 9 | 4 | 5 | 8 | 3 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 1 | 2 | 7 | 9 | 4 | 5 | 8 | 3 |'
- en: Backtracking can be very useful to find solutions to find path or solve game
    problems. There are many references available online for backtracking, which can
    be very useful to us.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯法可以非常有用地找到解决方案，找到路径或解决游戏问题。有许多关于回溯法的在线参考资料，对我们非常有用。
- en: Collaborative filtering recommendation system
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协同过滤推荐系统
- en: Recommendation systems are used everywhere in the Internet today. From e-commerce
    sites to restaurants, hotels, tickets, events, and so on. are recommended to us
    everywhere. Have we ever asked ourselves how do they know what will be the best
    for us? How do they come up with this calculation of showing the items we might
    like? The answer is most sites use collaborative filtering (CF) to recommend something.
    Collaborative filtering is a process of making automatic prediction (filtering)
    about the interests of a user by analyzing other user's choices or preferences
    (collaborative). We will build a simple recommendation system using the Pearson
    correlation method where a similarity score between two people is calculated on
    the range of -1 to +1\. If the similarity score is +1, then it means two people
    are a perfect match. If the similarity score is 0, then it means no there is no
    similarity between them, and if the score is -1, then they are negatively similar.
    Usually, the scores are mostly fractional.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐系统今天在互联网上随处可见。从电子商务网站到餐馆、酒店、门票、活动等等，都向我们推荐。我们是否曾经问过自己，他们是如何知道什么对我们最好？他们是如何计算出显示我们可能喜欢的物品的？答案是大多数网站使用协同过滤（CF）来推荐。协同过滤是通过分析其他用户的选择或偏好（协同）来自动预测（过滤）用户兴趣的过程。我们将使用皮尔逊相关方法构建一个简单的推荐系统，在这个方法中，计算两个人之间的相似度得分在-1到+1的范围内。如果相似度得分是+1，那么意味着两个人完全匹配。如果相似度得分是0，那么意味着他们之间没有相似之处，如果得分是-1，那么他们是负相关的。通常，得分大多是分数形式。
- en: 'The Pearson correlation is calculated using the following formula:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 皮尔逊相关是使用以下公式计算的：
- en: '![](Image00092.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00092.jpg)'
- en: 'Here, *x* denotes preferences from person one, y represents preferences from
    person two, and N represents the number of items in the preferences, which are
    common between *x* and *y* . Let''s now implement a sample review system for restaurants
    in Dhaka. There are reviewers who have reviewed some restaurants. Some of them
    are common, some are not. Our job will be to find a recommendation for person
    *X* based on the reviews of others. Our reviews look like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*x*表示第一个人的偏好，y表示第二个人的偏好，N表示偏好中的项目数，这些项目在*x*和*y*之间是共同的。现在让我们为达卡的餐馆实现一个样本评论系统。有一些评论者已经评论了一些餐馆。其中一些是共同的，一些不是。我们的工作将是根据其他人的评论为*X*找到一个推荐。我们的评论看起来像这样：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, based on the structure, we can write our Pearson correlation calculation
    between two reviewers. Here is the implementation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基于这个结构，我们可以编写我们的皮尔逊相关计算器之间的计算。这是实现：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, we have just implemented the equation we have shown for the Pearson correlation
    calculator. Now, we will write the recommendation function based on Pearson scoring:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们刚刚实现了我们为皮尔逊相关计算器所展示的方程。现在，我们将根据皮尔逊得分编写推荐函数：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding function, we calculated the similarity score between each
    reviewer and weighted their reviews with each other. Based on the top score, we
    showed the recommendation for the reviewer. Let''s run the following code to get
    some recommendations:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们计算了每个评论者之间的相似度分数，并加权了他们的评论。基于最高分，我们展示了对评论者的推荐。让我们运行以下代码来获得一些推荐：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will produce the following output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can use the Pearson correlation scoring system to recommend items or show
    users who to follow to get better reviews. There are many other ways to get the
    collaborative filtering to work, but that is beyond the scope of this book.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用皮尔逊相关评分系统来推荐物品或向用户展示如何获得更好的评论。还有许多其他方法可以使协同过滤工作，但这超出了本书的范围。
- en: Using bloom filters and sparse matrix
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用布隆过滤器和稀疏矩��
- en: 'Sparse matrix can be used as highly efficient data structure. A sparse matrix
    has more 0 values compared to actual values. For example, a 100 X 100 matrix may
    have 10,000 cells. Now, out of this 10,000 cells, only 100 have values; rest are
    0\. Other than the 100 values, remaining cells are occupied with the default value
    of 0, and they are taking same byte size to store the value 0 to indicate the
    empty cell. It is a huge waste of space, and we can reduce it using the sparse
    matrix. We can use different techniques to store the values to the sparse matrix
    in a separate matrix that will be very lean and will not take any unnecessary
    spaces. We can also use a linked list to represent the sparse matrix. Here is
    an example of the sparse matrix:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵可以用作高效的数据结构。稀疏矩阵的0值比实际值多。例如，一个100 X 100的矩阵可能有10,000个单元。现在，在这10,000个单元中，只有100个有值；其余都是0。除了这100个值，其余的单元都被默认值0占据，并且它们占据相同的字节大小来存储值0以表示空单元。这是对空间的巨大浪费，我们可以使用稀疏矩阵来减少它。我们可以使用不同的技术将值存储到稀疏矩阵中的一个单独的矩阵中，这将非常精简并且不会占用任何不必要的空间。我们还可以使用链表来表示稀疏矩阵。这是稀疏矩阵的一个例子：
- en: '|'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 1 &#124; 0 &#124; 0 &#124;
    0 &#124; 0 &#124;'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 1 &#124; 0 &#124; 0 &#124;
    0 &#124; 0 &#124;'
- en: '&#124; 1 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124;
    0 &#124; 0 &#124;'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124;
    0 &#124; 0 &#124;'
- en: '&#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 2 &#124; 0 &#124; 0 &#124; 0 &#124;
    0 &#124; 0 &#124;'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 2 &#124; 0 &#124; 0 &#124; 0 &#124;
    0 &#124; 0 &#124;'
- en: '&#124; 0 &#124; 0 &#124; 2 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124;
    0 &#124; 0 &#124;'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 0 &#124; 0 &#124; 2 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124;
    0 &#124; 0 &#124;'
- en: '&#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 1 &#124; 0 &#124;
    0 &#124; 0 &#124;'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 1 &#124; 0 &#124;
    0 &#124; 0 &#124;'
- en: '&#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 2 &#124;
    0 &#124; 0 &#124;'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 2 &#124;
    0 &#124; 0 &#124;'
- en: '&#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 1 &#124; 0 &#124;
    0 &#124; 0 &#124;'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 1 &#124; 0 &#124;
    0 &#124; 0 &#124;'
- en: '&#124; 1 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124;
    0 &#124; 0 &#124;'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124;
    0 &#124; 0 &#124;'
- en: '|'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124; **Row** &#124; **Col** &#124; **Value** &#124;'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; **行** &#124; **列** &#124; **值** &#124;'
- en: '&#124; 0 &#124; 5 &#124; 1 &#124;'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 0 &#124; 5 &#124; 1 &#124;'
- en: '&#124; 1 &#124; 0 &#124; 1 &#124;'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1 &#124; 0 &#124; 1 &#124;'
- en: '&#124; 2 &#124; 4 &#124; 2 &#124;'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 2 &#124; 4 &#124; 2 &#124;'
- en: '&#124; 3 &#124; 2 &#124; 2 &#124;'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 3 &#124; 2 &#124; 2 &#124;'
- en: '&#124; 4 &#124; 6 &#124; 1 &#124;'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4 &#124; 6 &#124; 1 &#124;'
- en: '&#124; 5 &#124; 7 &#124; 2 &#124;'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 5 &#124; 7 &#124; 2 &#124;'
- en: '&#124; 6 &#124; 6 &#124; 1 &#124;'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 6 &#124; 6 &#124; 1 &#124;'
- en: '&#124; 7 &#124; 1 &#124; 1 &#124;'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7 &#124; 1 &#124; 1 &#124;'
- en: '|'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Since PHP array is dynamic in nature, the best approach for sparse matrix in
    PHP will be using only the indexes that have values; others are not used at all.
    When we are using the cell, we can do a check to see whether the cell has any
    value; else, the default value of 0 is used, just as shown in the following example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PHP数组的性质是动态的，因此在PHP中稀疏矩阵的最佳方法将只使用具有值的索引；其他索引根本不使用。当我们使用单元格时，我们可以检查单元格是否有任何值；否则，将使用默认值0，就像下面的例子所示：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will produce the following output in the command line:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在命令行中产生以下输出：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When we have a large dataset, doing lookup in the dataset can be very time consuming
    and costly. Let's assume we have a dataset of 10 million phone numbers and we
    want to search for a particular phone number. This can be easily done using a
    database query. However, what if it is 1 billion phone numbers? Will it still
    be faster to find from a database? Such a big database can create slow-performing
    lookups. In order to solve this problem, an efficient approach can be using bloom
    filters.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个大型数据集时，在数据集中查找可能非常耗时和昂贵。假设我们有1000万个电话号码的数据集，我们想要搜索一个特定的电话号码。这可以很容易地通过数据库查询来完成。但是，如果是10亿个电话号码呢？从数据库中查找仍然会更快吗？这样一个庞大的数据库可能会导致性能下降的查找。为了解决这个问题，一个高效的方法可以是使用布隆过滤器。
- en: 'A bloom filter is a space-efficient, probabilistic data structure that determines
    whether a particular item is part of a set or not. It returns two values: "possibly
    in set" and "definitely not in set". If an item does not belong to a set, bloom
    filter returns false. However, if it returns true, the item may or may not be
    in the set. The reason for this is described here.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 布隆过滤器是一种高效的、概率性的数据结构，用于确定特定项是否属于集合。它返回两个值：“可能在集合中”和“绝对不在集合中”。如果一个项不属于集合，布隆过滤器返回false。但是，如果返回true，则该项可能在集合中，也可能不在集合中。这个原因在这里描述。
- en: 'In general, a bloom filter is a bit array of size m, where all initial values
    are 0\. There is k different `hash` function, which converts an item to a hashed
    integer value, which is mapped in the bit array. This hash value can be between
    0 to m, as m is the max size of our bit array. The `hash` functions are similar
    to `md5` , `sha1` , `crc32` , and so on, but they are very fast and efficient.
    Usually, in bloom filter fnv, murmur, Siphash, and so on, `hash` functions are
    used. Let''s take an example of 16 (16+1 cells) bit bloom filter with the initial
    value of 0:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，布隆过滤器是一个大小为m的位数组，所有初始值都是0。有k个不同的“哈希”函数，它将一个项转换为一个哈希整数值，该值被映射到位数组中。这个哈希值可以在0到m之间，因为m是位数组的最大大小。哈希函数类似于md5，sha1，crc32等，但它们非常快速和高效。通常在布隆过滤器fnv，murmur，Siphash等中使用哈希函数。让我们以初始值为0的16（16+1个单元）位布隆过滤器为例：
- en: '| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '&#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124;
    0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124;'
- en: 'Let''s assume that we have two hash functions, `k1` and `k2` , to convert our
    items to integer values between 0 to 16\. Let our first item to store in the bloom
    filter be "PHP". Then, our `hash` function will return following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个哈希函数k1和k2，将我们的项转换为0到16之间的整数值。让我们要存储在布隆过滤器中的第一个项是“PHP”。然后，我们的哈希函数将返回以下值：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Two `hash` functions have returned two different values. We can now put 1 in
    the bit array to mark that. The bit array will now look like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 两个哈希函数返回了两个不同的值。现在我们可以在位数组中放置1来标记它。位数组现在看起来是这样的：
- en: '| 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '&#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 1 &#124; 0 &#124; 0 &#124;
    0 &#124; 1 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124;'
- en: 'Let''s now add another item in the list, for example, "algorithm". Suppose
    our `hash` functions will return the following values:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在列表中添加另一个项，例如“algorithm”。假设我们的哈希函数将返回以下值：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Since we can see that 5 is already marked by another item, we do not have to
    mark it again. Now, the bit array will look like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以看到5已经被另一个项标记，我们不���再次标记它。现��，位数组将如下所示：
- en: '| 0 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '&#124; 0 &#124; 0 &#124; 1 &#124; 0 &#124; 0 &#124; 1 &#124; 0 &#124; 0 &#124;
    0 &#124; 1 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124;'
- en: 'For example, now, we want to check an item called "error", which is hashed
    to the following values:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，现在，我们想要检查一个名为“error”的项，它被哈希为以下值：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As we can see that our `hash` functions `k1` and `k2` returned a hashed value
    for string "error," which is not present in the array. So, this is definitely
    an error, and we expect to have such errors if our `hash` functions are only few
    in number. The more `hash` functions we have, lesser the errors we will have,
    as different `hash` functions will return different values. There is a relationship
    between error rate, number of `hash` functions, and the size of bloom filter.
    For example, a bloom filter for 5000 items and 0.0001 error rate will require
    roughly 14 `hash` functions and approximately 96000 bits. We can get such numbers
    from online bloomfilter calculators such as [https://krisives.github.io/bloom-calculator/](https://krisives.github.io/bloom-calculator/)
    .
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们的哈希函数k1和k2为字符串“error”返回了一个哈希值，而该值不在数组中。因此，这肯定是一个错误，如果我们���哈希函数只有少数，我们期望会有这样的错误。哈希函数越多，错误就越少，因为不同的哈希函数将返回不同的值。错误率、哈希函数的数量和布隆过滤器的大小之间存在关系。例如，一个包含5000个项和0.0001错误率的布隆过滤器将需要大约14个哈希函数和大约96000位。我们可以从在线布隆过滤器计算器（例如[https://krisives.github.io/bloom-calculator/](https://krisives.github.io/bloom-calculator/)）中获得这样的数字。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have seen many advanced algorithms and techniques that can be used to solve
    different types of problems in this chapter. There are many good resources available
    to study these topics. Dynamic programming is such an important topic and can
    be covered in several chapters or have a separate book for itself. We tried to
    explain few of the topics, but there are more to explore. You also learned about
    sparse matrix and bloom filter, which can be used for efficient data storage for
    big data blocks. We can use these data structure concepts whenever we need them.
    Now, as we are reaching the end of the book, we will wrap up our discussion with
    some available libraries, functions, and references for data structure and algorithm
    in PHP 7.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了许多先进的算法和技术，可以用来解决不同类型的问题。有许多好的资源可供学习这些主题。动态规划是一个如此重要的主题，可以在几章中进行介绍，或者有一个单独的书籍来介绍它。我们试图解释了一些主题，但还有更多可以探索的。您还学习了稀疏矩阵和布隆过滤器，它们可以用于大数据块的高效数据存储。我们可以在需要时使用这些数据结构概念。现在，随着我们接近本书的结尾，我们将用一些可用的库、函数和参考资料来总结我们关于PHP
    7中数据结构和算法的讨论。
