- en: Chapter 9.  Performance Efficiency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章 性能效率
- en: Now that we have covered various techniques related to functional programming,
    it is time to analyze how it impacts performance in a language such as PHP, which
    is still imperative at its core even if there are more and more functional features
    introduced with each version.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了与函数式编程相关的各种技术，是时候分析它如何影响像 PHP 这样的语言的性能了，尽管每个版本都引入了越来越多的函数式特性，但 PHP
    仍然在其核心是命令式的。
- en: We will also discuss why performance does not matter so much in the end and
    how we can leverage memoization and other techniques to alleviate this issue in
    some cases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论为什么性能最终并不那么重要，以及我们如何利用记忆化和其他技术来在某些情况下缓解这个问题。
- en: We will also explore two optimization techniques enabled by referential transparency.
    The first one will be memoization, which is a type of caching. We will also speak
    about running long computations in parallel and how you can take advantage of
    this in PHP.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨两种由引用透明性启用的优化技术。第一种是记忆化，这是一种缓存类型。我们还将谈论如何在 PHP 中并行运行长时间的计算，以及您如何利用这一点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Performance impact of functional programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程的性能影响
- en: Memoization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆化
- en: Parallelization of computation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算的并行化
- en: Performance impact
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能影响
- en: Since there is no core support for features such as currying and function composition,
    they need to be emulated using anonymous wrapper functions. Obviously, this comes
    with a performance cost. Also, as we have already discussed in the part about
    tail-call recursion in [Chapter 7](ch07.html "Chapter 7. Functional Techniques
    and Topics"), *Functional Techniques and Topics*, using a trampoline is also slower.
    But how much execution time do you lose compared to a more traditional approach?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有核心支持柯里化和函数组合等功能，它们需要使用匿名包装函数来模拟。显然，这会带来性能成本。此外，正如我们在关于尾调用递归的部分已经讨论过的那样，在
    [第 7 章](ch07.html "第 7 章 函数式技术和主题") *函数式技术和主题* 中，使用跳板也更慢。但与更传统的方法相比，你会损失多少执行时间呢？
- en: 'Let''s create a few functions that will serve as a benchmark and test the various
    speeds we can achieve. The function will execute a really simple task, adding
    two numbers, in order to ensure we measure the overhead as effectively as possible:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些函数作为基准，并测试我们可以实现的各种速度。该函数将执行一个非常简单的任务，即将两个数字相加，以确保我们尽可能有效地测量开销：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We created the first function `add` and curryied it; this will be our first
    benchmark. We will then compare a specialized function adding `4` to a value to
    two different compositions. The first will be the composition of two specialized
    functions and the second the composition of two curryied versions of the `add`
    function.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了第一个函数 `add` 并对其进行了柯里化；这将是我们的第一个基准。然后我们将比较一个专门添加 `4` 到一个值的函数与两种不同的组合。第一个是两个专门函数的组合，第二个是两个
    `add` 函数的柯里化版本的组合。
- en: 'We will use the following code to benchmark our functions. It is pretty basic
    but it should suffice to demonstrate any meaningful differences:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下代码来对我们的函数进行基准测试。它非常基础，但应该足以展示任何有意义的差异：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The statistics methods are from the `oefenweb/statistics` package available
    via composer. We also check that the returned value is the one we expect as an
    extra precaution. We will run each function 2 million times 10 times in a row
    and display the mean time for the 2 million runs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 统计方法来自于可通过 composer 获取的 `oefenweb/statistics` 包。我们还检查返回的值是否符合预期，作为额外的预防措施。我们将连续运行每个函数
    200 万次，每次运行 10 次，并显示 200 万次运行的平均时间。
- en: 'Let''s run the benchmark for currying first. The displayed results are for
    PHP 7.0.12\. When trying this with PHP 5.6, all benchmarks are slower but they
    exhibit the same differences between the various functions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先运行柯里化的基准测试。显示的结果是针对 PHP 7.0.12。当尝试在 PHP 5.6 中运行时，所有基准测试都会变慢，但它们在各种函数之间表现出相同的差异：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Obviously, the results will vary depending on the system the test is run on,
    but the relative difference should stay roughly the same.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，结果将根据测试运行的系统而有所不同，但相对差异应该保持大致相同。
- en: First, if we look at the standard deviation, we can see that each of the 10
    runs took mostly the same time, which indicates that we can trust our numbers
    to be a good indicator of the performances.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们看标准偏差，我们可以看到 10 次运行大多数情况下花费了相同的时间，这表明我们可以相信我们的数字是性能的良好指标。
- en: 'We can see the curryied version is definitively slower. Manual currying is
    a bit more efficient, but both curryied versions were mostly three times slower
    than the simple function version. Before drawing conclusions, let''s see the results
    for the composed functions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到柯里化版本明显更慢。手动柯里化效率稍微更高，但两个柯里化版本大部分情况下比简单函数版本慢三倍。在得出结论之前，让我们看看组合函数的结果：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Again, the standard deviation is small enough so that we can consider the numbers
    valid.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 标准偏差足够小，以至于我们可以认为这些数字是有效的。
- en: Concerning the values themselves, we can see that the composition is also about three
    times slower and the composition of the curryied function is, without much surprise,
    nine times slower.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关于值本身，我们可以看到组合也大约慢了三倍，而柯里化函数的组合，毫不奇怪，慢了九倍。
- en: Now if we take our worst case at `3.55` seconds against our best case at `0.434`
    seconds, this means we have an overhead of `3` seconds when using composition
    and currying. Does it matter? Does it seem like a lot of lost time? Let's try
    to imagine these numbers in the context of a web application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们将最坏情况的 3.55 秒与最佳情况的 0.434 秒进行比较，这意味着在使用组合和柯里化时我们有 3 秒的开销。这重要吗？看起来失去了很多时间吗？让我们试着在一个
    web 应用程序的背景下想象这些数字。
- en: Does the overhead matter?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开销重要吗？
- en: We performed two million executions of our methods and it accounted for three
    seconds. A recent project I worked on, an e-commerce application for a luxury
    brand available in 26 countries and more than 10 languages and written entirely
    from scratch without the help of any framework, had more or less 25,000 function
    calls to render one page.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对我们的方法进行了两百万次执行，用了三秒钟。我最近参与的一个项目是一个奢侈品牌的电子商务应用程序，在26个国家和10多种语言中可用，完全是从零开始编写的，没有使用任何框架，渲染一个页面需要大约25,000次函数调用。
- en: Even if we admit that all of those calls are made to composed functions that
    were curryied beforehand, this means that the overhead is now around 40 milliseconds
    in the worst case scenario. The application in question took roughly 180 milliseconds
    to display a page, so we are speaking of a 20-25% decrease in performance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们承认所有这些调用都是事先柯里化的组合函数，这意味着在最坏的情况下，开销现在大约为40毫秒。该应用程序大约需要180毫秒来显示一个页面，因此我们在性能上会有20-25%的降低。
- en: It is still a lot, but far from the three times slower figure we were seeing
    before. The overhead linked to the functional techniques will grow linearly with
    each function call. In the benchmark it seems great because the performed computation
    is trivial. In a real-life application, you have external bottlenecks such as
    databases, third-party APIs, or filesystems. You also have functions performing
    complex computations taking more time than a simple addition. In such a case the
    introduced overhead is a smaller part of the total execution time of your application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然很多，但远不及我们之前看到的三倍慢的数字。与每个函数调用相关的函数式技术的开销将随着每个函数调用的增加而线性增长。在基准测试中看起来很好，因为执行的计算是微不足道的。在现实应用中，你会有外部瓶颈，比如数据库、第三方API或文件系统。你还有执行复杂计算的函数，需要比简单的加法更多的时间。在这种情况下，引入的开销将成为应用程序总执行时间的一个较小部分。
- en: This is also a worst-case scenario where we assume everything is composed and
    curryied. In a real-world application, you might use a traditional framework containing
    functions and methods without overhead. You will also be able to identify hot
    paths in your code and manually optimize them using explicit currying and composition
    instead of the helper functions. It is also not necessary to curry everything;
    you will have functions with only one argument that won't need it and some functions
    for which it makes no sense to use currying.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个最坏的情况，我们假设一切都是组合和柯里化的。在现实世界的应用程序中，你可能会使用传统的框架，其中包含没有开销的函数和方法。你还可以识别代码中的热点路径，并手动优化它们，使用显式的柯里化和组合而不是辅助函数。也不需要对所有东西都进行柯里化；你将有只有一个参数的函数不需要它，还有一些函数使用柯里化是没有意义的。
- en: Also, those are numbers to be considered for an application with a cold cache.
    Any mechanism you already have in place to reduce the rendering time of you pages
    will continue to work the same. For example, if you have a Varnish instance running,
    your pages will probably continue to be served at the same speed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字是考虑到缓存不热的应用程序。你已经采取的任何减少页面渲染时间的机制将继续发挥作用。例如，如果你有一个Varnish实例在运行，你的页面可能会以相同的速度提供。
- en: Let's not forget
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要忘记
- en: 'We compared a really small function to composition and currying. A modern PHP
    codebase would use classes both for holding business logic and values. Let''s
    simulate this using the following implementation of our `add` function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个非常小的函数与组合和柯里化进行了比较。现代PHP代码库将使用类来保存业务逻辑和值。让我们使用以下`add`函数的实现来模拟这一点：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The time taken by the traditional approach would increase:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 传统方法所需的时间会增加：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Just by wrapping everything in a class and using a getter, the execution time
    nearly doubled, meaning suddenly the functional approach is only 1.5 times slower
    in the benchmark, and the overhead in our sample application is now 10-15%, which
    is already a lot better.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将所有东西封装在一个类中并使用getter，执行时间几乎翻了一番，这意味着在基准测试中，函数式方法只比传统方法慢1.5倍，而我们示例应用程序中的开销现在已经是10-15%，这已经好多了。
- en: Can we do something?
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们能做些什么吗？
- en: Sadly, there is not really something that we could do ourselves. We could shave
    off a little bit of time with more efficient implementation of the `curry` and
    `compose` methods as we demonstrated using the manually curryied version of the`add`
    method, but this won't amount to much.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，我们实际上没有什么可以做的。我们可以通过更有效地实现`curry`和`compose`方法来节省一点时间，就像我们使用手动柯里化版本的`add`方法一样，但这不会带来太大的影响。
- en: An implementation of both those techniques as a core part of PHP would, however,
    bring a lot of benefits, probably getting them on a par with traditional functions
    and methods, or really close. But, as far as I know, there is no plan to do so
    in the near future.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将这两种技术作为PHP的核心部分实现，将带来很多好处，可能使它们与传统函数和方法持平，或者非常接近。但据我所知，目前没有计划这样做。
- en: It could also be possible to create a C language extension for PHP to implement
    those two functions in a more efficient way. This will, however, be impractical
    as most PHP-hosting companies do not let people install custom extensions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还可以创建一个C语言扩展程序，以更有效的方式实现这两个函数在PHP中的应用。然而，这将是不切实际的，因为大多数PHP托管公司不允许用户安装自定义扩展程序。
- en: Closing words
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束语
- en: As we just saw, using techniques such as currying and function composition has
    an impact on performance that is rather hard to mitigate on your own. In my opinion,
    the benefits outweigh this cost but it is important to switch to functional programming
    knowingly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，使用柯里化和函数组合等技术对性能有一定影响，而这种影响很难自行减轻。在我看来，收益大于成本，但重要的是要有意识地转向函数式编程。
- en: Also, most web applications nowadays have some kind of caching mechanism in
    front of the PHP application. So the only cost would be when populating this cache.
    If you are in such a situation, I see no reason to avoid using the techniques
    we learned.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大多数Web应用程序都在PHP应用程序前面有某种缓存机制。因此，唯一的成本将是在填充此缓存时。如果你处于这种情况，我认为没有理由避免使用我们学到的技术。
- en: Memoization
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆化
- en: Memoization is an optimization technique where the result of an expensive function
    is stored so that it can be returned directly in any subsequent call with the
    same parameters. It is a specific case of data caching.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化是一种优化技术，它会存储昂贵函数的结果，以便在任何后续具有相同参数的调用中直接返回。这是数据缓存的一个特例。
- en: Although it can be used on non-pure functions with the same invalidation issues
    as any other cache mechanism, it is mostly used in functional languages where
    all functions are pure, thus simplifying greatly its usage.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它可以用于非纯函数，并具有与任何其他缓存机制相同的失效问题，但它主要用于所有函数都是纯函数的函数式语言，因此极大地简化了它的使用。
- en: 'The idea is to trade computation time for storage space. The first time you
    call a function for a given input, the result is stored and the next time the
    same function is called with the same arguments, the already computed result can
    be returned immediately. This can be achieved fairly easily in PHP using the `static`
    keyword inside your function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是用存储空间来换取计算时间。第一次使用给定的输入调用函数时，结果会被存储，下一次使用相同参数调用相同函数时，已经计算出的结果可以立即返回。在PHP中可以很容易地使用`static`关键字来实现这一点：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are obviously a dozen different ways to do something similar, but this
    is simple enough to get an idea of how it works. One can also imagine implementing
    an expiration mechanism, or, since we use memory space instead of computation
    time, some kind of data structure where values get erased when not used to make
    room for newer results.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 显然有很多种不同的方法来做类似的事情，但这种方法足够简单，可以让你了解它是如何工作的。人们也可以想象实现一种过期机制，或者，由于我们使用内存空间而不是计算时间，一种数据结构，在这种数据结构中，值在不使用时被擦除以为新的结果腾出空间。
- en: Another option would be to store the information to disk, to keep the values
    saved between multiple runs of the same script, for example. There exists at least
    one library in PHP ([https://github.com/koktut/php-memoize](https://github.com/koktut/php-memoize))
    doing just that.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是将信息存储到磁盘上，以便在同一脚本的多次运行之间保留值，例如。PHP中至少存在一个库（[https://github.com/koktut/php-memoize](https://github.com/koktut/php-memoize)）就是这样做的。
- en: The library, however, does not work well with recursive calls out-of-the-box,
    as the function itself is not modified and thus the value will only be saved for
    the first call, not the recursive ones. The article ([http://eddmann.com/posts/implementing-and-using-memoization-in-php/](http://eddmann.com/posts/implementing-and-using-memoization-in-php/))
    linked in the library readme discusses this issue in more detail and proposes
    a solution.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该库不能很好地处理递归调用，因为函数本身没有被修改，因此值只会保存第一次调用，而不是递归调用。库自述文件中链接的文章（[http://eddmann.com/posts/implementing-and-using-memoization-in-php/](http://eddmann.com/posts/implementing-and-using-memoization-in-php/)）更详细地讨论了这个问题并提出了解决方案。
- en: It is interesting to note that **Hack** has an attribute that will automatically
    memoize the results of a function with arguments of a certain type ([https://docs.hhvm.com/hack/attributes/special#__memoize](https://docs.hhvm.com/hack/attributes/special#__memoize)).
    If you are using Hack and want to use the annotation, I recommend you read the
    *Gotchas* section first as it might not always do what you want.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是**Hack**有一个属性，可以自动记忆具有特定类型参数的函数的结果（[https://docs.hhvm.com/hack/attributes/special#__memoize](https://docs.hhvm.com/hack/attributes/special#__memoize)）。如果您正在使用Hack并希望使用注释，我建议您首先阅读*Gotchas*部分，因为它可能并不总是按照您的意愿进行操作。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Hack is a language adding new features on top of PHP and running on the PHP
    Virtual Machine written by Facebook-the **HipHop Virtual Machine** (**HHVM**).
    Any PHP code is compatible with Hack, but Hack adds some new syntax, making the
    code incompatible with the vanilla PHP interpreter. For more information, you
    can visit [http://hacklang.org](http://hacklang.org)/.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Hack是一种在PHP基础上添加新功能并在Facebook编写的PHP虚拟机上运行的语言-**HipHop虚拟机**（**HHVM**）。任何PHP代码都与Hack兼容，但Hack添加了一些新的语法，使代码与原始的PHP解释器不兼容。有关更多信息，您可以访问[http://hacklang.org](http://hacklang.org)/。
- en: Haskell, Scala, and memoization
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Haskell、Scala和记忆化
- en: Neither Haskell nor Scala performs memoization automatically. And none of the
    two has something in their core to do so, although you can find multiple libraries
    offering this feature.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell和Scala都不会自动执行记忆化。这两者都没有核心功能来执行记忆化，尽管你可以找到多个提供这一功能的库。
- en: There is a misconception that Haskell memoizes all functions by default, which
    is due to the fact that the language is lazy. What really happens is that Haskell
    tries to delay the computation of a function call as much as possible and, once
    it does so, it uses the referential transparency property to replace other similar
    calls with the computed values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种误解认为Haskell默认情况下会对所有函数进行记忆化，这是因为这种语言是惰性的。实际上，Haskell试图尽可能延迟函数调用的计算，并且一旦这样做了，它就使用了引用透明属性来用计算出的值替换其他类似的调用。
- en: There are, however, multiple cases where this replacement cannot happen automatically,
    leaving no other choice than to compute the value again. If you are interested
    in the topic, this *Stack Overflow* question is a good start with all the right
    keywords at[http://stackoverflow.com/questions/3951012/when-is-memoization-automatic-in-ghc-haskell](http://stackoverflow.com/questions/3951012/when-is-memoization-automatic-in-ghc-haskell).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有多种情况下，这种替换不能自动发生，除了重新计算值之外别无选择。如果您对这个话题感兴趣，这个*Stack Overflow*问题是一个很好的起点，其中包含所有正确的关键字[http://stackoverflow.com/questions/3951012/when-is-memoization-automatic-in-ghc-haskell](http://stackoverflow.com/questions/3951012/when-is-memoization-automatic-in-ghc-haskell)。
- en: We'll leave the discussion here, as this book is about PHP.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里结束讨论，因为这本书是关于PHP的。
- en: Closing words
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束语
- en: This was a really quick presentation of memoization as the technique is fairly
    simple to implement and there is nothing much to really say about it. I just wanted
    to present it so you are aware of the term.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个对记忆化的快速介绍，因为这种技术相当简单实现，实际上并没有太多可以说的。我只是想介绍一下，让你了解这个术语。
- en: If you have some long-running computation that gets called multiple times with
    the same arguments, I recommend you use the technique as it can really speed up
    things and requires nothing from the caller. It is really transparent to use.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些长时间运行的计算，会多次使用相同的参数，我建议你使用这种技术，因为它可以真正加快速度，并且不需要调用者做任何事情。使用起来非常透明。
- en: Beware that it is, however, not a silver bullet. Depending on the data structure
    of your return values, it can eat up memory pretty quickly. If you encounter this
    issue, you can use some mechanism to clean up older, or less used, values from
    the cache.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但要注意，这并不是万能的。根据返回值的数据结构，它可能会很快地消耗内存。如果遇到这个问题，你可以使用一些机制来清理缓存中的旧值或者少用的值。
- en: Parallelization of computation
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算的并行化
- en: Another nice benefit of having pure functions is that you can divide a computation
    into multiple small parts, distribute the workload, and assemble the result. It
    is possible to do so for any mapping, filtering, and folding operations. The function
    used for folding needs to be monoidal as we will see. Functions for mapping and
    filtering have no particular constraint besides purity.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有纯函数的另一个好处是，你可以将计算分成多个小部分，分发工作负载，并组装结果。对于任何映射、过滤和折叠操作都可以这样做。我们将看到，用于折叠的函数需要是单子的。用于映射和过滤的函数除了纯度之外没有特定的约束。
- en: 'Mapping does not have any particular constraint beside a pure function. Say
    you have four cores, or computers; you will only need to follow these steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 映射除了纯函数之外没有特定的约束。假设你有四个核心或计算机，你只需要按照以下步骤进行：
- en: Split the array into four parts.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数组分成四部分。
- en: Send a part to each core to do the mapping.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将部分任务发送到每个核心进行映射。
- en: Merge the results.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并结果。
- en: In this particular case, it might be slower than doing it on a single core as
    the merging operation adds an overhead. However, as soon as the computation takes
    longer, you are able to use more of the computing power at your disposal, and
    thus gain time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特殊情况下，它可能比在单个核心上执行要慢，因为合并操作会增加额外的开销。然而，一旦计算时间变长，你就能够利用更多的计算能力，从而节省时间。
- en: Filtering operates in exactly the same way as mapping, except you send a predicate
    instead of a function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤操作与映射完全相同，只是你发送的是一个谓词而不是一个函数。
- en: 'Folding can only happen if you have a monoidal operation, because each split
    needs to start with the empty value otherwise it might skew the results:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当你拥有一个单子操作时，折叠操作才能发生，因为每个拆分都需要从空值开始，否则可能会使结果产生偏差：
- en: Split the array into four parts.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数组分成四部分。
- en: Send a part to each core to do the folding with the empty value as initial value.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将部分任务发送到每个核心进行折叠，初始值为空值。
- en: Put all results in a new array.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有结果放入一个新数组中。
- en: Perform the same fold operation on the new array.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新数组上执行相同的折叠操作。
- en: If your collection is really big, you can again divide the final fold into multiple
    parts.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的集合非常大，你可以将最终的折叠再次分成多个部分。
- en: Parallel tasks in PHP
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP中的并行任务
- en: PHP was created when computers had only one core and since then the traditional
    way of using it is to have a single thread to serve each request. You can have
    multiple workers declared in your web server to serve different requests using
    different processes, but one request will usually use only one thread, and thus
    only one core.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: PHP是在计算机只有一个核心时创建的，自那时起，使用它的传统方式是为每个请求提供一个单独的线程。你可以在web服务器中声明多个工作进程来处理不同的请求，但一个请求通常只会使用一个线程，因此只会使用一个核心。
- en: Although a thread-safe version of the PHP binary exists, Linux distributions
    usually ships the non-thread-safe one because of the aforementioned reason. This
    does not mean it is impossible to parallelize tasks in PHP, but it sure makes
    it a lot harder.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管PHP的线程安全版本存在，但由于前述原因，Linux发行版通常会提供非线程安全版本。这并不意味着在PHP中无法并行执行任务，但这确实会使任务变得更加困难。
- en: The pthreads extension
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pthreads扩展
- en: PHP 7 has seen the release of a new version of the **pthreads** extension, which
    allows you to run multiple tasks in parallel using a newly designed object-oriented
    API. It is really great and there is even a *polyfill* to perform the tasks sequentially
    if the extension is not available.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7发布了一个新版本的**pthreads**扩展，它允许你使用新设计的面向对象API并行运行多个任务。这真的很棒，甚至还有一个*polyfill*，如果扩展不可用，可以按顺序执行任务。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The term *polyfill* originated in JavaScript development. It is a small piece
    of code that replaces a feature that is not implemented in the user's browser.
    Another term that is sometimes used is *shim*. In our case, the *pthreads-polyfill*
    provides an API in all points similar to the one of the extension but that runs
    the tasks sequentially.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*polyfill*起源于JavaScript开发。它是一小段代码，用于替换用户浏览器中未实现的功能。有时也会使用另一个术语*shim*。在我们的情况下，*pthreads-polyfill*提供了一个与扩展API在所有点上相似的API，但是它是按顺序运行任务的。
- en: Sadly, using the extension is kind of a challenge. First of all, you need to
    have a thread-safe PHP binary, also called a **ZTS** binary for **Zend Thread-safe**.
    As we just saw, distributions usually don't ship this version. As far as I know,
    there are currently no distributions with official PHP packages having ZTS enabled.
    Google is usually helpful when trying to find instructions to create your own
    ZTS binary for your Linux distribution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，使用这个扩展有点挑战。首先，你需要一个线程安全的PHP二进制文件，也称为**ZTS**二进制文件，即**Zend Thread-safe**。正如我们刚才看到的，发行版通常不提供这个版本。据我所知，目前没有官方PHP软件包支持ZTS。当你尝试为你的Linux发行版创建自己的ZTS二进制文件时，通常可以在谷歌上找到相关的指导。
- en: Windows and Mac OS users are in a better place as you can download ZTS binaries
    on [http://www.php.net](http://www.php.net) and you can enable the option when
    installing PHP with the`homebrew` package manager.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Windows和Mac OS用户则更加方便，因为你可以在[http://www.php.net](http://www.php.net)上下载ZTS二进制文件，并且在使用`homebrew`软件包管理器安装PHP时可以启用该选项。
- en: The other limitation is that the extension will refuse to load in a CGI context.
    This means you will only be able to use it on the command line. If you are interested
    in the reason the maintainer of the pthreads extension chose to put this constraint
    in place, I suggest you read this blog post he wrote, at [http://blog.krakjoe.ninja/2015/09/the-worth-of-advice.html](http://blog.krakjoe.ninja/2015/09/the-worth-of-advice.html).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个限制是该扩展将拒绝在CGI环境中加载。这意味着您只能在命令行上使用它。如果您对pthreads扩展的维护者为什么选择设置这个限制感兴趣，我建议您阅读他写的这篇博客文章，网址为[http://blog.krakjoe.ninja/2015/09/the-worth-of-advice.html](http://blog.krakjoe.ninja/2015/09/the-worth-of-advice.html)。
- en: Now, if we assume you are able to have a ZTS version of PHP and you are only
    writing a CLI application, let's see how we could perform a parallel fold using
    the **pthreads** extension. The extension is hosted on GitHub at [https://github.com/krakjoe/pthreads](https://github.com/krakjoe/pthreads),
    and installation instructions can be found in the official PHP documentation at
    [http://docs.php.net/manual/en/book.pthreads.php](http://docs.php.net/manual/en/book.pthreads.php).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们假设您能够拥有PHP的ZTS版本，并且只编写CLI应用程序，让我们看看如何使用**pthreads**扩展执行并行折叠。该扩展程序托管在GitHub上，网址为[https://github.com/krakjoe/pthreads](https://github.com/krakjoe/pthreads)，安装说明可以在官方PHP文档中找到，网址为[http://docs.php.net/manual/en/book.pthreads.php](http://docs.php.net/manual/en/book.pthreads.php)。
- en: 'There are obviously multiple ways we could go about implementing folding using
    threads. We will try to go for a generic method. In some cases, a more specialized
    version might be quicker but this should cover a whole range of use cases already:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以以多种方式实现使用线程进行折叠。我们将尝试采用一种通用的方法。在某些情况下，更专门的版本可能更快，但这应该已经涵盖了整个一系列用例：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The implementation is pretty simple; we have a simple `Thread` performing the
    reducing of each chunk and we combine them at the end using a simple `array_reduce`
    function. We could have opted to use a `Pool` instance to manage the various threads
    but, in such a simple case, it would have complicated the implementation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 实现非常简单；我们有一个简单的`Thread`执行每个块的减少，然后使用简单的`array_reduce`函数将它们组合在一起。我们本可以选择使用`Pool`实例来管理各个线程，但在这种简单情况下，这将使实现变得复杂。
- en: Another possibility would have been to recurse until the resulting arrays contain
    at most `$threads` elements; this way, we would have used the full computational
    power at our disposal until the end. But again, this would have complicated the
    implementation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是递归，直到生成的数组包含最多`$threads`个元素为止；这样，我们将利用我们手头的全部计算能力直到结束。但同样，这将使实现变得复杂。
- en: 'How do you use it? Just call the static method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何使用它？只需调用静态方法：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you want to play with this idea a bit, a little library implements all three
    higher-order functions in a parallel way ([https://github.com/functional-php/parallel](https://github.com/functional-php/parallel)).
    You can install it using composer:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想尝试一下这个想法，一个小型库以并行方式实现了所有三个高阶函数（[https://github.com/functional-php/parallel](https://github.com/functional-php/parallel)）。您可以使用composer安装它：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Messaging queues
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息队列
- en: Another option in PHP to parallelize tasks is to use a messaging queue. Message
    queues provide an asynchronous communication protocol. You will have a server
    that will hold the messages until one or multiple clients retrieve them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中另一个并行化任务的选项是使用消息队列。消息队列提供了一种异步通信协议。您将拥有一个服务器，它将保存消息，直到一个或多个客户端检索它们。
- en: We can implement parallel computation by having our application send X messages
    to the server, one for each distributed task. A certain number of workers will
    then retrieve the messages and perform the computation, sending back the result
    to the application as a new message.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过让我们的应用程序向服务器发送X条消息来实现并行计算，每个分布式任务发送一条消息。然后，一定数量的工作线程将检索消息并执行计算，将结果作为新消息发送回应用程序。
- en: There are a lot of different message queue implementations that you can use.
    Usually, the queue itself is not implemented in PHP, but most of them have a client
    implementation that you can use. We will use **RabbitMQ** and the **php-amqplib**
    client.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多不同的消息队列实现可以使用。通常，队列本身并不是用PHP实现的，但它们大多数都有客户端实现可以使用。我们将使用**RabbitMQ**和**php-amqplib**客户端。
- en: 'Explaining how to install the server is out of scope for this book, but you
    have a lot of tutorials available on the Internet. We will also not explain all
    the details about the implementation, only what is related to our topic. You can
    install the PHP library using composer:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 解释如何安装服务器超出了本书的范围，但您可以在互联网上找到很多教程。我们也不会解释所有关于实现的细节，只解释与我们主题相关的内容。您可以使用composer安装PHP库：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will need both an implementation for our workers and the application. Let''s
    first create a file containing the common parts, which we will call `09-rabbitmq.php`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的工作线程和应用程序都实现。让我们首先创建一个包含公共部分的文件，我们将其命名为`09-rabbitmq.php`：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we create the worker:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建工作线程：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And now we create the application itself:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建应用程序本身：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Obviously, this is a really naive implementation. Requiring files like that
    is bad practice since PHP 5 at least and the code is really brittle, but it serves
    the purpose of demonstrating the possibilities offered by a message queue.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是一个非常天真的实现。自PHP 5以来，要求这样的文件是不好的做法，而且代码非常脆弱，但它达到了演示消息队列提供的可能性的目的。
- en: When you launch the worker, it registers itself as a consumer of the `fold_queue`
    queue. When a message is received, it uses the folding function declared in the
    common part on the data and sends the result back on the queue defined as the
    reply to. The loop ensures we wait for incoming messages; given the code, the
    worker should never exit by itself.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动工作线程时，它会注册自己作为`fold_queue`队列的消费者。当接收到消息时，它会使用在公共部分声明的折叠函数对数据进行折叠，并将结果发送回作为回复的队列。循环确保我们等待传入的消息；根据代码，工作线程不应该自行退出。
- en: The application has a `send` function that sends messages on the `fold_queue`
    queue. The `Results` class instance registers itself as a consumer of the default
    queue in order to receive the results of each worker. Then four messages are sent,
    and we ask the `Results` instance to wait for them. Finally, we reduce the received
    data to get the final result.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序有一个`send`函数，它在`fold_queue`队列上发送消息。`Results`类实例注册自己作为默认队列的消费者，以接收每个工作进程的结果。然后发送四条消息，并要求`Results`实例等待它们。最后，我们减少接收的数据以获得最终结果。
- en: If you launch only one worker, the results will be sent sequentially; however,
    if you launch multiple workers, each one of them will retrieve a message from
    the RabbitMQ server and process it, thus enabling parallelization.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只启动一个工作进程，结果将按顺序发送；但是，如果启动多个工作进程，每个工作进程将从RabbitMQ服务器检索消息并处理它，从而实现并行化。
- en: 'Compared to using threads, a message queue has multiple benefits:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用线程相比，消息队列有多个好处：
- en: The workers can be on multiple computers
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作进程可以在多台计算机上
- en: The worker can be implemented in any other language having a client for the
    chosen queue
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作进程可以在任何其他具有所选队列客户端的语言中实现
- en: The queue server provides redundancy and failover mechanisms
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列服务器提供冗余和故障转移机制
- en: The queue server can perform load-balancing between the workers
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列服务器可以在工作进程之间进行负载平衡
- en: Using the pthreads library when available is probably a bit easier if you plan
    on only distributing your workload across the cores of a unique computer, but
    if you want to have more flexibility, message queues are the way to go.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在可用时使用pthreads库可能会更容易一些，如果你计划只在唯一计算机的核心之间分配工作负载，但如果你想要更灵活性，消息队列是更好的选择。
- en: Other options
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他选择
- en: There are other ways to start parallelizing computations in PHP, but usually
    they make retrieving the values more difficult than what we just saw.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中启动并行计算的其他方法，但通常会使检索值比我们刚才看到的更加困难。
- en: One option is to use the `curl_multi_exec` function to execute multiple HTTP
    requests asynchronously. The general structure would be similar to what we used
    in the message queue example. However, the possibilities are also limited compared
    to the full power of a complete messaging system.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是使用`curl_multi_exec`函数异步执行多个HTTP请求。一般结构类似于我们在消息队列示例中使用的内容。但是，与完整消息系统的全部功能相比，可能也有限制。
- en: You can also create other PHP processes using one of the multiple related functions.
    In this case, the difficulty is often to pass and retrieve the data without loss
    as the way to do so will depend on a number of factors related to the environment.
    If you want to go this way, the `popen`, `exec`, or `passthru` functions are probably
    your best bet.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用多个相关函数之一创建其他PHP进程。在这种情况下，难点通常是在不丢失数据的情况下传递和检索数据，因为这样做的方式将取决于与环境相关的许多因素。如果你想这样做，`popen`、`exec`或`passthru`函数可能是你最好的选择。
- en: 'If you don''t want to do all the grunt work, you can also use the `Parallel.php`
    library, which abstracts most of the complexity away. You can install it using
    composer:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想做所有的苦力活，你也可以使用`Parallel.php`库，它可以将大部分复杂性抽象化。你可以使用composer安装它：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The documentation is available on GitHub at [https://github.com/kzykhys/Parallel.php](https://github.com/kzykhys/Parallel.php).
    As the library uses Unix sockets, most of the issues related to data loss are
    gone. However, you won't be able to use it on Windows.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可在GitHub上找到[https://github.com/kzykhys/Parallel.php](https://github.com/kzykhys/Parallel.php)。由于该库使用Unix套接字，大部分与数据丢失相关的问题都已经解决。但是你无法在Windows上使用它。
- en: Closing words
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束语
- en: As we saw, it might not be the easiest thing to work with multiple threads or
    processes in PHP, especially when in the context of a web page. This can, however,
    be achieved and it can greatly speed up long computations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用多个线程或进程在PHP中可能并不是最容易的事情，特别是在网页的上下文中。然而，这是可以实现的，并且可以大大加快长时间计算的速度。
- en: With the rewrite of pthreads for PHP 7, we can hope that more Linux distributions
    and hosting companies will start providing a ZTS version.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 随着PHP 7中pthreads的重写，我们可以希望更多的Linux发行版和托管公司将开始提供ZTS版本。
- en: If this is the case, and parallel computation starts becoming a real thing in
    PHP, it might be possible to do some light big data processing without having
    to resort to external libraries in other languages such as the **Hadoop framework**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这种情况，并且并行计算开始在PHP中变得真实，可能可以进行一些轻量级的大数据处理，而无需求助于其他语言的外部库，比如**Hadoop框架**。
- en: I want to finish with a few words about message queues. Even if you don't use
    them in a functional way to process data and get results back, they are a great
    way to perform lengthy operations in the context of a web request. For example,
    if you give your users a way to upload a bunch of images and you need to process
    them, you can enqueue the operation and return immediately to the user. The queued
    message will be processed in due time and your user won't have to wait.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我想用几句话来结束关于消息队列的话题。即使你不以功能方式使用它们来处理数据并获取结果，它们也是在网页请求的上下文中执行长时间操作的好方法。例如，如果你让用户上传一堆图片并且你需要处理它们，你可以将操作加入队列并立即返回给用户。排队的消息将在适当的时间被处理，你的用户不必等待。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discovered that sadly there is a cost to pay when doing
    functional programming. Since PHP has no core support for features such as currying
    and function composition, there is an overhead linked to the wrapper functions
    when using them. This can obviously be an issue in some cases, but caching can
    often alleviate this cost.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现当进行函数式编程时，很遗憾是需要付出代价的。由于PHP没有对柯里化和函数组合等功能的核心支持，因此在使用它们时会有与包装函数相关的开销。在某些情况下，这显然可能是一个问题，但缓存通常可以减轻这种成本。
- en: We talked about memoization, a caching technique that, coupled with pure functions,
    allows you to speed up subsequent calls to a given function without having to
    invalidate the stored results.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈到了记忆化，这是一种缓存技术，结合纯函数，可以加速对给定函数的后续调用，而无需使存储的结果失效。
- en: Finally, we discussed parallelizing computations in PHP by leveraging the fact
    that any pure operation performed on a collection can be distributed across multiple
    nodes without having any concerns about shared state.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了通过利用在集合上执行的任何纯操作可以在多个节点之间分发，而不必担心共享状态来并行化计算在PHP中的计算。
- en: The next chapter will be dedicated to developers using a framework as we will
    discover how we can leverage the techniques we've learned so far in the context
    of the most common frameworks currently in use in the PHP world.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专门针对使用框架的开发人员，我们将发现如何在PHP世界中目前最常用的框架的背景下利用我们迄今为止学到的技术。
