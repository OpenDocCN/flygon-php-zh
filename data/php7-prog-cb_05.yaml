- en: Chapter 5. Interacting with a Database
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。与数据库交互
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using PDO to connect to a database
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PDO连接到数据库
- en: Building an OOP SQL query builder
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建面向对象的SQL查询生成器
- en: Handling pagination
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理分页
- en: Defining entities to match database tables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义实体以匹配数据库表
- en: Tying entity classes to RDBMS queries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实体类与RDBMS查询绑定
- en: Embedding secondary lookups into query results
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将辅助查找嵌入到查询结果中
- en: Implementing jQuery DataTables PHP lookups
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现jQuery DataTables PHP查找
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will cover a series of database connectivity recipes that
    take advantage of the **PHP Data Objects** (**PDO**) extension. Common programming
    problems such as **Structured Query Language** (**SQL**) generation, pagination,
    and tying objects to database tables, will be addressed. Finally, at the end,
    we will present code that processes secondary lookups in the form of embedded
    anonymous functions, and using jQuery DataTables to make AJAX requests.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一系列利用**PHP数据对象**（**PDO**）扩展的数据库连接配方。将解决常见的编程问题，如**结构化查询语言**（**SQL**）生成，分页和将对象与数据库表绑定。最后，我们将呈现处理嵌入式匿名函数形式的辅助查找的代码，并使用jQuery
    DataTables进行AJAX请求。
- en: Using PDO to connect to a database
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PDO连接到数据库
- en: '**PDO** is a highly performant and actively maintained database extension that
    has a unique advantage over vendor-specific extensions. It has a common **Application
    Programming Interface** (**API**) that is compatible with almost a dozen different
    **Relational Database Management Systems** (**RDBMS**). Learning how to use this
    extension will save you hours of time trying to master the command subsets of
    the equivalent individual vendor-specific database extensions.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**PDO**是一个高性能且积极维护的数据库扩展，具有与特定供应商扩展不同的独特优势。它具有一个通用的**应用程序编程接口**（**API**），与几乎十几种不同的**关系数据库管理系统**（**RDBMS**）兼容。学习如何使用此扩展将节省您大量时间，因为您无需尝试掌握等效的各个特定供应商数据库扩展的命令子集。'
- en: 'PDO is subdivided into four main classes, as summarized in the following table:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: PDO分为四个主要类，如下表所示：
- en: '| Class | Functionality |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 功能 |'
- en: '| --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `PDO` | Maintains the actual connection to the database, and also handles
    low-level functionality such as transaction support |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `PDO` | 维护与数据库的实际连接，并处理低级功能，如事务支持 |'
- en: '| `PDOStatement` | Processes results |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `PDOStatement` | 处理结果 |'
- en: '| `PDOException` | Database-specific exceptions |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `PDOException` | 特定于数据库的异常 |'
- en: '| `PDODriver` | Communicates with the actual vendor-specific database |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `PDODriver` | 与实际特定供应商数据库通信 |'
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Set up the database connection by creating a `PDO` instance.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建`PDO`实例建立数据库连接。
- en: 'You need to construct a **Data Source Name** (**DSN**). The information contained
    in the DSN varies according to the database driver used. As an example, here is
    a DSN used to connect to a **MySQL** database:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要构建一个**数据源名称**（**DSN**）。DSN中包含的信息根据使用的数据库驱动程序而变化。例如，这是一个用于连接到**MySQL**数据库的DSN：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On the other hand, **SQlite**, a simpler extension, only requires the following
    command:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，**SQlite**，一个更简单的扩展，只需要以下命令：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**PostgreSQL**, on the other hand, includes the username and password directly
    in the DSN:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，**PostgreSQL**直接在DSN中包括用户名和密码：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The DSN could also include server-specific directives, such as `unix_socket`,
    as shown in the following example:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DSN还可以包括特定于服务器的指令，例如`unix_socket`，如下例所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Best practice**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Wrap the statement that creates the PDO instance in a `try {} catch {}` block.
    Catch a `PDOException` for database-specific information in case of failure. Catch
    `Throwable` for errors or any other exceptions. Set the PDO error mode to `PDO::ERRMODE_EXCEPTION`
    for best results. See step 8 for more details about error modes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建PDO实例的语句包装在`try {} catch {}`块中。在发生故障时，捕获`PDOException`以获取特定于数据库的信息。捕获`Throwable`以处理错误或任何其他异常。将PDO错误模式设置为`PDO::ERRMODE_EXCEPTION`以获得最佳结果。有关错误模式的更多详细信息，请参见第8步。
- en: In PHP 5, if the PDO object cannot be constructed (for example, when invalid
    parameters are used), the instance is assigned a value of `NULL`. In PHP 7, an
    `Exception` is thrown. If you wrap the construction of the PDO object in a `try
    {} catch {}` block, and the `PDO::ATTR_ERRMODE` is set to `PDO::ERRMODE_EXCEPTION`,
    you can catch and log such errors without having to test for `NULL`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 5中，如果无法构造PDO对象（例如，使用无效参数），则实例将被赋予`NULL`值。在PHP 7中，会抛出一个`Exception`。如果将PDO对象的构造包装在`try
    {} catch {}`块中，并且将`PDO::ATTR_ERRMODE`设置为`PDO::ERRMODE_EXCEPTION`，则可以捕获并记录此类错误，而无需测试`NULL`。
- en: 'Send an SQL command using `PDO::query()`. A `PDOStatement` instance is returned,
    against which you can fetch results. In this example, we are looking for the first
    20 customers sorted by ID:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`PDO::query()`发送SQL命令。返回一个`PDOStatement`实例，您可以针对其获取结果。在此示例中，我们正在查找按ID排序的前20个客户：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PDO also provides a convenience method, `PDO::exec()`, which does not return
    a result iteration, just the number of rows affected. This method is best used
    for administrative operations such as `ALTER TABLE`, `DROP TABLE`, and so on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: PDO还提供了一个方便的方法`PDO::exec()`，它不返回结果迭代，只返回受影响的行数。此方法最适用于诸如`ALTER TABLE`，`DROP
    TABLE`等管理操作。
- en: 'Iterate through the `PDOStatement` instance to process results. Set the **fetch
    mode** to either `PDO::FETCH_NUM` or `PDO::FETCH_ASSOC` to return results in the
    form of a numeric or associative array. In this example we use a `while()` loop
    to process results. When the last result has been fetched, the result is a boolean
    `FALSE`, ending the loop:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代`PDOStatement`实例以处理结果。将**获取模式**设置为`PDO::FETCH_NUM`或`PDO::FETCH_ASSOC`，以返回以数字或关联数组形式的结果。在此示例中，我们使用`while()`循环处理结果。当获取到最后一个结果时，结果为布尔值`FALSE`，结束循环：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PDO fetch operations involve a **cursor** that defines the direction (that is,
    forward or reverse) of the iteration. The second argument to `PDOStatement::fetch()`
    can be any of the `PDO::FETCH_ORI_*` constants. Cursor orientations include prior,
    first, last, absolute, and relative. The default cursor orientation is `PDO::FETCH_ORI_NEXT`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: PDO获取操作涉及定义迭代方向（即向前或向后）的**游标**。`PDOStatement::fetch()`的第二个参数可以是`PDO::FETCH_ORI_*`常量中的任何一个。游标方向包括prior、first、last、absolute和relative。默认游标方向是`PDO::FETCH_ORI_NEXT`。
- en: 'Set the fetch mode to `PDO::FETCH_OBJ` to return results as a `stdClass` instance.
    Here you will note that the `while()` loop takes advantage of the fetch mode,
    `PDO::FETCH_OBJ`. Notice that the `printf()` statement refers to object properties,
    in contrast with the preceding example, which references array elements:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将获取模式设置为`PDO::FETCH_OBJ`以将结果作为`stdClass`实例返回。在这里，您会注意到`while()`循环利用了获取模式`PDO::FETCH_OBJ`。请注意，`printf()`语句引用了对象属性，与前面的示例相反，前者引用了数组元素。
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you want to create an instance of a specific class while processing a query,
    set the fetch mode to `PDO::FETCH_CLASS`. You must also have the class definition
    available, and `PDO::query()` should set the class name. As you can see in the
    following code snippet, we have defined a class called `Customer`, with public
    properties `$id`, `$name`, and `$level`. Properties need to be `public` for the
    fetch injection to work properly:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要在处理查询时创建特定类的实例，请将获取模式设置为`PDO::FETCH_CLASS`。您还必须有类定义可用，并且`PDO::query()`应该设置类名。如下面的代码片段中所示，我们定义了一个名为`Customer`的类，具有公共属性`$id`、`$name`和`$level`。属性需要是`public`，以使获取注入正常工作：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When fetching objects, a simpler alternative to the technique shown in step
    5 is to use `PDOStatement::fetchObject()`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在获取对象时，与步骤5中显示的技术相比，更简单的替代方法是使用`PDOStatement::fetchObject()`：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You could also use `PDO::FETCH_INTO`, which is essentially the same as `PDO::FETCH_CLASS`,
    but you need an active object instance instead of a class reference. Each iteration
    through the loop re-populates the same object instance with the current information
    set. This example assumes the same class `Customer` as in step 5, with the same
    database parameters and PDO connections as defined in step 1:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以使用`PDO::FETCH_INTO`，它本质上与`PDO::FETCH_CLASS`相同，但您需要一个活动对象实例，而不是一个类引用。通过循环的每次迭代，都会使用当前信息集重新填充相同的对象实例。此示例假定与步骤5中相同的类`Customer`，以及与步骤1中定义的相同的数据库参数和PDO连接：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you do not specify an error mode, the default PDO error mode is `PDO::ERRMODE_SILENT`.
    You can set the error mode using the `PDO::ATTR_ERRMODE` key, and either the `PDO::ERRMODE_WARNING`
    or the `PDO::ERRMODE_EXCEPTION` value. The error mode can be specified as the
    fourth argument to the PDO constructor in the form of an associative array. Alternatively,
    you can use `PDO::setAttribute()` on an existing instance.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您没有指定错误模式，默认的PDO错误模式是`PDO::ERRMODE_SILENT`。您可以使用`PDO::ATTR_ERRMODE`键设置错误模式，以及`PDO::ERRMODE_WARNING`或`PDO::ERRMODE_EXCEPTION`值。错误模式可以作为关联数组的第四个参数指定给PDO构造函数。或者，您可以在现有实例上使用`PDO::setAttribute()`。
- en: 'Let us assume you have the following DSN and SQL (before you start thinking
    that this is a new form of SQL, please be assured: this SQL statement will not
    work!):'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您有以下DSN和SQL（在您开始认为这是一种新形式的SQL之前，请放心：这个SQL语句不起作用！）：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you then formulate your PDO connection using the default error mode, the
    only clue that something is wrong is that instead of producing a `PDOStatement`
    instance, the `PDO::query()` will return a boolean `FALSE`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果您使用默认错误模式制定PDO连接，出现问题的唯一线索是，`PDO::query()`将返回一个布尔值`FALSE`，而不是生成`PDOStatement`实例：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The next example shows setting the error mode to `WARNING` using the constructor
    approach:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个示例显示了使用构造函数方法将错误模式设置为`WARNING`：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you need full separation of the prepare and execute phases, use `PDO::prepare()`
    and `PDOStatement::execute()` instead. The statement is then sent to the database
    server to be pre-compiled. You can then execute the statement as many times as
    is warranted, most likely in a loop.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您需要完全分离准备和执行阶段，请使用`PDO::prepare()`和`PDOStatement::execute()`。然后将语句发送到数据库服务器进行预编译。然后可以根据需要执行语句，很可能是在循环中。
- en: The first argument to `PDO::prepare()` can be an SQL statement with placeholders
    in place of actual values. An array of values can then be supplied to `PDOStatement::execute()`.
    PDO automatically provides database quoting, which helps safeguard against **SQL
    Injection**.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PDO::prepare()`的第一个参数可以是带有占位符的SQL语句，而不是实际值。然后可以向`PDOStatement::execute()`提供值数组。PDO自动提供数据库引用，有助于防止**SQL注入**。'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Best practice**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Any application in which external input (that is, from a form posting) is combined
    with an SQL statement is subject to an SQL injection attack. All external input
    must first be properly filtered, validated, and otherwise sanitized. Do not put
    external input directly into the SQL statement. Instead, use placeholders, and
    provide the actual (sanitized) values during the execution phase.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序中，如果外部输入（即来自表单提交）与SQL语句结合在一起，都会受到SQL注入攻击的影响。所有外部输入必须首先经过适当的过滤、验证和其他清理。不要直接将外部输入放入SQL语句中。而是使用占位符，并在执行阶段提供实际（经过清理的）值。
- en: 'To iterate through the results in reverse, you can change the orientation of
    the **scrollable cursor**. Alternatively, and probably more easily, just reverse
    the `ORDER BY` from `ASC` to `DESC`. This line of code sets up a `PDOStatement`
    object requesting a scrollable cursor:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要以相反的顺序迭代结果，可以更改**可滚动游标**的方向。或者，更简单地，将`ORDER BY`从`ASC`更改为`DESC`。以下代码行设置了一个请求可滚动游标的`PDOStatement`对象：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You also need to specify cursor instructions during the fetch operation. This
    example gets the last row in the result set, and then scrolls backwards:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行获取操作期间，您还需要指定游标指令。此示例获取结果集中的最后一行，然后向后滚动：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Neither MySQL nor SQLite support scrollable cursors! To achieve the same results,
    try the following modifications to the preceding code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MySQL和SQLite都不支持可滚动的游标！要实现相同的结果，请尝试对上述代码进行以下修改：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'PDO provides support for transactions. Borrowing the code from step 9, we can
    wrap the `INSERT` series of commands into a transactional block:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PDO提供了对事务的支持。借用第9步的代码，我们可以将`INSERT`系列命令包装到一个事务块中：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, to keep everything modular and re-usable, we can wrap the PDO connection
    into a separate class `Application\Database\Connection`. Here, we build a connection
    through the constructor. Alternatively, there is a static `factory()` method that
    lets us generate a series of PDO instances:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了保持一切模块化和可重用，我们可以将PDO连接封装到一个单独的类`Application\Database\Connection`中。在这里，我们通过构造函数建立连接。另外，还有一个静态的`factory()`方法，让我们生成一系列PDO实例：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'An important component of this `Connection` class is a generic method that
    can be used to construct a DSN. All we need for this to work is to establish the
    `PDODriver` as a prefix, followed by "`:"`. After that, we simply append key/value
    pairs from our configuration array. Each key/value pair is separated by a semi-colon.
    We also need to strip off the trailing semi-colon, using `substr()` with a negative
    limit for that purpose:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`Connection`类的一个重要组成部分是一个通用方法，用于构造DSN。我们需要的一切就是将`PDODriver`作为前缀，后面跟着“`:`”。之后，我们只需从配置数组中追加键值对。每个键值对之间用分号分隔。我们还需要使用`substr()`来去掉末尾的分号，为此目的使用了负限制：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作...
- en: 'First of all, you can copy the initial connection code from step 1 into a `chap_05_pdo_connect_mysql.php`
    file. For the purposes of this illustration, we will assume you have created a
    MySQL database called `php7cookbook`, with a username of cook and a password of
    book. Next, we send a simple SQL statement to the database using the `PDO::query()`
    method. Finally, we use the resulting statement object to fetch results in the
    form of an associative array. Don''t forget to wrap your code in a `try {} catch
    {}` block:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以将第1步中的初始连接代码复制到一个名为`chap_05_pdo_connect_mysql.php`的文件中。为了说明的目的，我们假设您已经创建了一个名为`php7cookbook`的MySQL数据库，用户名为cook，密码为book。接下来，我们使用`PDO::query()`方法向数据库发送一个简单的SQL语句。最后，我们使用生成的语句对象以关联数组的形式获取结果。不要忘记将您的代码放在`try
    {} catch {}`块中：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is the resulting output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生成的输出：
- en: '![How it works...](graphics/B05314_05_01.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_05_01.jpg)'
- en: 'Add the option to the PDO constructor, which sets the error mode to `EXCEPTION`.
    Now alter the SQL statement and observe the resulting error message:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将选项添加到PDO构造函数中，将错误模式设置为`EXCEPTION`。现在修改SQL语句并观察生成的错误消息：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You will observe something like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到类似这样的东西：
- en: '![How it works...](graphics/B05314_05_02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_05_02.jpg)'
- en: Placeholders can be named or positional. **Named placeholders** are preceded
    by a colon (`:`) in the prepared SQL statement, and are references as keys in
    an associative array provided to `execute()`. **Positional placeholders** are
    represented as question marks (`?`) in the prepared SQL statement.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符可以是命名的或位置的。**命名占位符**在准备的SQL语句中以冒号（`:`）开头，并且在提供给`execute()`的关联数组中作为键引用。**位置占位符**在准备的SQL语句中表示为问号（`?`）。
- en: 'In the following example, named placeholders are used to represent values in
    a `WHERE` clause:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，使用命名占位符来表示`WHERE`子句中的值：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This example shows using positional placeholders in an `INSERT` operation.
    Notice that the data to be inserted as the fourth customer includes a potential
    SQL injection attack. You will also notice that some awareness of the SQL syntax
    for the database being used is required. In this case, MySQL column names are
    quoted using back-ticks (`''`):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了在`INSERT`操作中使用位置占位符。请注意，要插入的作为第四个客户的数据包括潜在的SQL注入攻击。您还会注意到，需要对正在使用的数据库的SQL语法有一定的了解。在这种情况下，MySQL列名使用反引号（`'`）引用：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To test the use of a prepared statement with named parameters, modify the SQL
    statement to add a `WHERE` clause that checks for customers with a balance less
    than a certain amount, and a level equal to either `BEG`, `INT`, or `ADV` (that
    is, beginning, intermediate, or advanced). Instead of using `PDO::query()`, use
    `PDO::prepare()`. Before fetching results, you must then perform `PDOStatement::execute()`,
    supplying the values for balance and level:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试使用带有命名参数的准备语句，修改SQL语句以添加一个`WHERE`子句，检查余额小于某个特定金额的客户，以及级别等于`BEG`、`INT`或`ADV`（即初级、中级或高级）。不要使用`PDO::query()`，而是使用`PDO::prepare()`。在获取结果之前，您必须执行`PDOStatement::execute()`，提供余额和级别的值：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is the resulting output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生成的输出：
- en: '![How it works...](graphics/B05314_05_03.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_05_03.jpg)'
- en: Instead of providing parameters when calling `PDOStatement::execute()`, you
    could alternatively bind parameters. This allows you to assign variables to placeholders.
    At the time of execution, the current value of the variable is used.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`PDOStatement::execute()`时，您可以选择绑定参数。这允许您将变量分配给占位符。在执行时，将使用变量的当前值。
- en: 'In this example, we bind the variables `$min`, `$max`, and `$level` to the
    prepared statement:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将变量`$min`，`$max`和`$level`绑定到准备好的语句中：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When the values of these variables change, the next execution will reflect the
    modified criteria.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些变量的值发生变化时，下一次执行将反映修改后的条件。
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Use `PDO::query()` for one-time database commands. Use `PDO::prepare()` and
    `PDOStatement::execute()` when you need to process the same statement multiple
    times but using different values.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一次性数据库命令，请使用`PDO::query()`。当您需要多次处理相同的语句但使用不同的值时，请使用`PDO::prepare()`和`PDOStatement::execute()`。
- en: See also
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For information on the syntax and unique behavior associated with different
    vendor-specific PDO drivers, have a look this article:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有关与不同供应商特定PDO驱动程序相关的语法和独特行为的信息，请参阅本文：
- en: '[http://php.net/manual/en/pdo.drivers.php](http://php.net/manual/en/pdo.drivers.php)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://php.net/manual/en/pdo.drivers.php](http://php.net/manual/en/pdo.drivers.php)'
- en: 'For a summary of PDO predefined constants, including fetch modes, cursor orientation,
    and attributes, see the following article:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PDO预定义常量的摘要，包括获取模式、游标方向和属性，请参阅以下文章：
- en: '[http://php.net/manual/en/pdo.constants.php](http://php.net/manual/en/pdo.constants.php)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://php.net/manual/en/pdo.constants.php](http://php.net/manual/en/pdo.constants.php)'
- en: Building an OOP SQL query builder
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建面向对象的SQL查询构建器
- en: PHP 7 implements something called a **context sensitive lexer**. What this means
    is that words that are normally reserved can be used if the context allows. Thus,
    when building an object-oriented SQL builder, we can get away with using methods
    named `and`, `or`, `not`, and so on.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7实现了一种称为**上下文敏感词法分析器**的东西。这意味着通常保留的单词可以在上下文允许的情况下使用。因此，当构建面向对象的SQL构建器时，我们可以使用命名为`and`、`or`、`not`等的方法。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We define a `Application\Database\Finder` class. In the class, we define methods
    that match our favorite SQL operations:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个`Application\Database\Finder`类。在这个类中，我们定义与我们喜欢的SQL操作相匹配的方法：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Each function used to generate an SQL fragment returns the same property, `$instance`.
    This allows us to represent the code using a fluent interface, such as this:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于生成SQL片段的每个函数都返回相同的属性`$instance`。这使我们能够使用流畅的接口来表示代码，例如：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Copy the code defined precedingly into a `Finder.php` file in the `Application\Database`
    folder. You can then create a `chap_05_oop_query_builder.php` calling program,
    which initializes the autoloader defined in [Chapter 1](ch01.html "Chapter 1. Building
    a Foundation"), *Building a Foundation*. You can then run `Finder::select()` to
    generate an object from which the SQL string can be rendered:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面定义的代码复制到`Application\Database`文件夹中的`Finder.php`文件中。然后，您可以创建一个调用程序`chap_05_oop_query_builder.php`，该程序初始化了[第1章](ch01.html
    "第1章。建立基础")中定义的自动加载程序，*建立基础*。然后，您可以运行`Finder::select()`来生成一个对象，从中可以呈现SQL字符串：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is the result of the precding code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上述代码的结果：
- en: '![How it works...](graphics/B05314_05_04.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_05_04.jpg)'
- en: See also
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information on the context-sensitive lexer, have a look at this article:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有关上下文敏感词法分析器的更多信息，请参阅本文：
- en: '[https://wiki.php.net/rfc/context_sensitive_lexer](https://wiki.php.net/rfc/context_sensitive_lexer)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.php.net/rfc/context_sensitive_lexer](https://wiki.php.net/rfc/context_sensitive_lexer)'
- en: Handling pagination
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理分页
- en: 'Pagination involves providing a limited subset of the results of a database
    query. This is usually done for display purposes, but could easily apply to other
    situations. At first glance, it would seem the `LimitIterator` class is ideally
    suited for the purposes of pagination. In cases where the potential result set
    could be massive; however, `LimitIterator` is not such an ideal candidate, as
    you would need to supply the entire result set as an inner iterator, which would
    most likely exceed memory limitations. The second and third arguments to the `LimitIterator`
    class constructor are offset and count. This suggests the pagination solution
    we will adopt, which is native to SQL: adding `LIMIT` and `OFFSET` clauses to
    a given SQL statement.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 分页涉及提供数据库查询结果的有限子集。这通常是为了显示目的，但也可以轻松应用于其他情况。乍一看，似乎`LimitIterator`类非常适合分页的目的。然而，在潜在结果集可能非常庞大的情况下，`LimitIterator`并不是一个理想的选择，因为您需要提供整个结果集作为内部迭代器，这很可能会超出内存限制。`LimitIterator`类构造函数的第二个和第三个参数是偏移和计数。这表明我们将采用的分页解决方案，这是SQL本身的一部分：向给定的SQL语句添加`LIMIT`和`OFFSET`子句。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we create a class called `Application\Database\Paginate` to hold the
    pagination logic. We add properties to represent values associated with pagination,
    `$sql`, `$page`, and `$linesPerPage`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`Application\Database\Paginate`的类来保存分页逻辑。我们添加属性来表示与分页相关的值，`$sql`、`$page`和`$linesPerPage`：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Next, we define a `__construct()` method that accepts a base SQL statement,
    the current page number, and the number of lines per page as arguments. We then
    need to refactor the SQL string modifying or adding the `LIMIT` and `OFFSET` clauses.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`__construct()`方法，它接受基本SQL语句、当前页码和每页行数作为参数。然后，我们需要重构SQL字符串，修改或添加`LIMIT`和`OFFSET`子句。
- en: 'In the constructor, we need to calculate the offset using the current page
    number and the number of lines per page. We also need to check to see if `LIMIT`
    and `OFFSET` are already present in the SQL statement. Finally, we need to revise
    the statement using lines per page as our `LIMIT` with the recalculated `OFFSET`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们需要使用当前页码和每页行数来计算偏移量。我们还需要检查SQL语句中是否已经存在`LIMIT`和`OFFSET`。最后，我们需要使用每页行数作为我们的`LIMIT`，使用重新计算的`OFFSET`来修改语句：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are now ready to execute the query using the `Application\Database\Connection`
    class discussed in the first recipe.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用第一篇食谱中讨论的`Application\Database\Connection`类来执行查询。
- en: 'In our new pagination class, we add a `paginate()` method, which takes a `Connection`
    instance as an argument. We also need the PDO fetch mode, and optional prepared
    statement parameters:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的新分页类中，我们添加了一个`paginate()`方法，它以`Connection`实例作为参数。我们还需要PDO获取模式和可选的准备好的语句参数：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It might not be a bad idea to provide support for the query builder class mentioned
    in the previous recipe. This will make updating `LIMIT` and `OFFSET` much easier.
    All we need to do to provide support for `Application\Database\Finder` is to use
    the class and modify the `__construct()` method to check to see if the incoming
    SQL is an instance of this class:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了提供对前面一篇食谱中提到的查询构建器类的支持可能是个好主意。这将使更新`LIMIT`和`OFFSET`变得更容易。我们需要做的就是为`Application\Database\Finder`提供支持，使用该类并修改`__construct()`方法以检查传入的SQL是否是这个类的实例：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now all that remains to be done is to add a `getSql()` method in case we need
    to confirm that the SQL statement was correctly formed:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在剩下要做的就是添加一个`getSql()`方法，以便在需要确认SQL语句是否正确形成时使用：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Copy the preceding code into a `Paginate.php` file in the `Application/Database`
    folder. You can then create a `chap_05_pagination.php` calling program, which
    initializes the autoloader defined in [Chapter 1](ch01.html "Chapter 1. Building
    a Foundation"), *Building a Foundation*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述代码复制到 `Application/Database` 文件夹中的 `Paginate.php` 文件中。然后可以创建一个 `chap_05_pagination.php`
    调用程序，该程序初始化了[第1章](ch01.html "第1章。建立基础")中定义的自动加载程序，*建立基础*：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, use the `Application\Database\Finder`, `Connection`, and `Paginate` classes,
    create an instance of `Application\Database\Connection`, and use `Finder` to generate
    SQL:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `Application\Database\Finder`、`Connection` 和 `Paginate` 类，创建一个 `Application\Database\Connection`
    实例，并使用 `Finder` 生成 SQL：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can now get the page number and balance from `$_GET` parameters, and create
    the `Paginate` object, ending the PHP block:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从 `$_GET` 参数中获取页码和余额，并创建 `Paginate` 对象，结束 PHP 代码块：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the output portion of the script, we simply iterate through the pagination
    using a simple `foreach()` loop:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的输出部分，我们只需使用简单的 `foreach()` 循环迭代通过分页：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is page 3 of the output, where the balance is less than 1,000:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出的第3页，余额小于1,000：
- en: '![How it works...](graphics/B05314_05_05.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_05_05.jpg)'
- en: See also
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information on the `LimitIterator` class, refer to this article:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `LimitIterator` 类的更多信息，请参阅本文：
- en: '[http://php.net/manual/en/class.limititerator.php](http://php.net/manual/en/class.limititerator.php)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://php.net/manual/en/class.limititerator.php](http://php.net/manual/en/class.limititerator.php)'
- en: Defining entities to match database tables
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义与数据库表匹配的实体
- en: A very common practice among PHP developers is to create classes that represent
    database tables. Such classes are often referred to as **entity** classes, and
    form the core of the **domain model** software design pattern.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: PHP开发人员中非常常见的做法是创建代表数据库表的类。这些类通常被称为**实体**类，并且构成**领域模型**软件设计模式的核心。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First of all, we will establish some common features of a series of entity classes.
    These might include common properties and common methods. We will put these into
    a `Application\Entity\Base` class. All future entity classes will then extend
    `Base`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将确定一系列实体类的一些共同特征。这些可能包括共同的属性和共同的方法。我们将把这些放入 `Application\Entity\Base` 类中。然后，所有未来的实体类都将扩展
    `Base`。
- en: 'For the purposes of this illustration, let''s assume all entities will have
    two properties in common: `$mapping` (discussed later), and `$id` (with its corresponding
    getter and setter):'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了说明的目的，让我们假设所有实体都有两个共同的属性：`$mapping`（稍后讨论）和 `$id`（及其相应的 getter 和 setter）：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It's not a bad idea to define a `arrayToEntity()` method, which converts an
    array to an instance of the entity class, and vice versa (`entityToArray()`).
    These methods implement a process often referred to as **hydration**. As these
    methods should be generic, they are best placed in the `Base` class.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `arrayToEntity()` 方法并不是一个坏主意，它将数组转换为实体类的实例，反之亦然（`entityToArray()`）。这些方法实现了一个经常被称为**水合**的过程。由于这些方法应该是通用的，因此最好将它们放在
    `Base` 类中。
- en: 'In the following methods, the `$mapping` property is used to translate between
    database column names and object property names. `arrayToEntity()` populates values
    of this object instance from an array. We can define this method as static in
    case we need to call it outside of an active instance:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下方法中，`$mapping` 属性用于在数据库列名和对象属性名之间进行转换。`arrayToEntity()` 从数组中填充此对象实例的值。我们可以定义此方法为静态方法，以防需要在活动实例之外调用它：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `entityToArray()` produces an array from current instance property values:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`entityToArray()` 从当前实例属性值生成数组：'
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To build the specific entity, you need to have the structure of the database
    table you plan to model at hand. Create properties that map to the database columns.
    The initial values assigned should reflect the ultimate data-type of the database
    column.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建特定的实体，您需要手头有要建模的数据库表的结构。创建映射到数据库列的属性。分配的初始值应反映数据库列的最终数据类型。
- en: 'In this example we''ll use the `customer` table. Here is the `CREATE` statement
    from a MySQL data dump, which illustrates its data structure:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此示例中，我们将使用 `customer` 表。以下是来自 MySQL 数据转储的 `CREATE` 语句，说明了其数据结构：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We are now in a position to flesh out the class properties. This is also a
    good place to identify the corresponding table. In this case, we will use a `TABLE_NAME`
    class constant:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以填充类属性。这也是确定相应表的好地方。在这种情况下，我们将使用 `TABLE_NAME` 类常量：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It is considered a best practice to define the properties as `protected`. In
    order to access these properties, you will need to design `public` methods that
    `get` and `set` the properties. Here is a good place to put to use the PHP 7 ability
    to data-type to the return value.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将属性定义为 `protected` 被认为是最佳实践。为了访问这些属性，您需要设计 `public` 方法来 `get` 和 `set` 属性。这是一个很好的地方，可以利用
    PHP 7 对返回值进行数据类型定义。
- en: 'In the following block of code, we have defined getters and setters for `$name`
    and `$balance`. You can imagine how the remainder of these methods will be defined:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们已经为 `$name` 和 `$balance` 定义了 getter 和 setter。您可以想象其余这些方法将如何定义：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is not a good idea to data type check the incoming values on the setters.
    The reason is that the return values from a RDBMS database query will all be a
    `string` data type.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 setter 中对传入值进行数据类型检查并不是一个好主意。原因是来自 RDBMS 数据库查询的返回值都将是 `string` 数据类型。
- en: If the property names do not exactly match the corresponding database column,
    you should consider creating a `mapping` property, an array of key/value pairs
    where the key represents the database column name and the value the property name.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果属性名称与相应的数据库列不完全匹配，您应该考虑创建一个 `mapping` 属性，一个键/值对数组，其中键表示数据库列名，值表示属性名。
- en: 'You will note that three properties, `$securityQuestion`, `$confirmCode`, and
    `$profileId`, do not correspond to their equivalent column names, `security_question`,
    `confirm_code`, and `profile_id`. The `$mapping` property will ensure that the
    appropriate translation takes place:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到，三个属性`$securityQuestion`、`$confirmCode`和`$profileId`与它们对应的列名`security_question`、`confirm_code`和`profile_id`不对应。`$mapping`属性将确保适当的转换发生：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Copy the code from steps 2, 4, and 5 into a `Base.php` file in the `Application/Entity`
    folder. Copy the code from steps 8 through 12 into a `Customer.php` file, also
    in the `Application/Entity` folder. You will then need to create getters and setters
    for the remaining properties not shown in step 10: `email`, `password`, `status`,
    `securityQuestion`, `confirmCode`, `profileId`, and `level`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将步骤2、4和5中的代码复制到`Application/Entity`文件夹中的`Base.php`文件中。将步骤8到12中的代码复制到`Application/Entity`文件夹中的`Customer.php`文件中。然后，您需要为步骤10中未显示的剩余属性`email`、`password`、`status`、`securityQuestion`、`confirmCode`、`profileId`和`level`创建getter和setter。
- en: 'You can then create a `chap_05_matching_entity_to_table.php` calling program,
    which initializes the autoloader defined in [Chapter 1](ch01.html "Chapter 1. Building
    a Foundation"), *Building a Foundation*, uses the `Application\Database\Connection`,
    and the newly created `Application\Entity\Customer` classes:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以创建一个`chap_05_matching_entity_to_table.php`调用程序，该程序初始化了[第1章](ch01.html
    "第1章。建立基础")中定义的自动加载程序，使用`Application\Database\Connection`和新创建的`Application\Entity\Customer`类：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, get a database connection, and use the connection to acquire an associative
    array of data for one customer at random:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，获取一个数据库连接，并使用连接随机获取一个客户的数据的关联数组：
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, you can create a new `Customer` entity instance from the array and
    use `var_dump()` to view the result:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以从数组中创建一个新的`Customer`实体实例，并使用`var_dump()`查看结果：
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here is the output of the preceding code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![How it works...](graphics/B05314_05_06.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_05_06.jpg)'
- en: See also
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: There are many good works that describe the domain model. Probably the most
    influential is *Patterns of Enterprise Application Architecture* by Martin Fowler
    (see [http://martinfowler.com/books/eaa.html](http://martinfowler.com/books/eaa.html)).
    There is also a nice study, also available as a free download, entitled *Domain
    Driven Design Quickly* by InfoQ (see [http://www.infoq.com/minibooks/domain-driven-design-quickly](http://www.infoq.com/minibooks/domain-driven-design-quickly)).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多描述领域模型的好作品。可能最有影响力的是Martin Fowler的*企业应用架构模式*（参见[http://martinfowler.com/books/eaa.html](http://martinfowler.com/books/eaa.html)）。还有一份很好的研究，也可以免费下载，名为*快速领域驱动设计*的InfoQ（参见[http://www.infoq.com/minibooks/domain-driven-design-quickly](http://www.infoq.com/minibooks/domain-driven-design-quickly)）。
- en: Tying entity classes to RDBMS queries
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将实体类与RDBMS查询联系起来
- en: Most commercially viable RDBMS systems evolved at a time when procedural programming
    was at the fore. Imagine the RDBMS world as two dimensional, square, and procedurally
    oriented. In contrast, entities could be thought of as round, three dimensional,
    and object oriented. This gives you a picture of what we want to accomplish by
    tying the results of an RDBMS query into an iteration of entity instances.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数商业上可行的RDBMS系统是在过程式编程处于前沿时演变而来的。想象一下RDBMS世界是二维的、方形的、过程化的。相比之下，实体可以被认为是圆形的、三维的、面向对象的。这给了你一个关于我们想要通过将RDBMS查询的结果与实体实例的迭代联系起来实现的想法。
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **relational model**, upon which modern RDBMS systems are based, was first
    described by the mathematician Edgar F. Codd in 1969\. The first commercially
    viable systems evolved in the mid-to-late 1970s. So, in other words, RDBMS technology
    is over 40 years old!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系模型**，现代RDBMS系统所基于的模型，是由数学家Edgar F. Codd在1969年首次描述的。第一个商业上可行的系统是在70年代中期至70年代末期演变而来的。换句话说，RDBMS技术已经有40多年的历史了！'
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First of all, we need to design a class which will house our query logic. If
    you are following the Domain Model, this class might be called a **repository**.
    Alternatively, to keep things simple and generic, we could simply call the new
    class `Application\Database\CustomerService`. The class will accept an `Application\Database\Connection`
    instance as an argument:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要设计一个类，用于容纳我们的查询逻辑。如果你遵循领域模型，这个类可能被称为**存储库**。或者，为了保持简单和通用，我们可以简单地将新类称为`Application\Database\CustomerService`。该类将接受一个`Application\Database\Connection`实例作为参数：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now we will define a `fetchById()` method, which takes a customer ID as an
    argument, and returns a single `Application\Entity\Customer` instance or boolean
    `FALSE` on failure. At first glance, it would seem a no-brainer to simply use
    `PDOStatement::fetchObject()` and specify the entity class as an argument:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将定义一个`fetchById()`方法，它以客户ID作为参数，并在失败时返回单个`Application\Entity\Customer`实例或布尔值`FALSE`。乍一看，似乎很简单，只需简单地使用`PDOStatement::fetchObject()`并将实体类指定为参数：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The danger here, however, is that `fetchObject()` actually populates the properties
    (even if they are protected) before the constructor is called! Accordingly, there
    is a danger that the constructor could accidentally overwrite values. If you don't
    define a constructor, or if you can live with this danger, we're done. Otherwise,
    it starts to get tougher to properly implement the tie between RDBMS query and
    OOP results.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里的危险是`fetchObject()`实际上在调用构造函数之前填充属性（即使它们是受保护的）！因此，存在构造函数可能意外覆盖值的危险。如果你没有定义构造函数，或者如果你可以接受这种危险，那就完成了。否则，正确实现RDBMS查询和OOP结果之间的联系就开始变得更加困难。
- en: 'Another approach for the `fetchById()` method is to create the object instance
    first, thereby running its constructor, and setting the fetch mode to `PDO::FETCH_INTO`,
    as shown in the following example:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fetchById()`方法的另一种方法是首先创建对象实例，从而运行其构造函数，并将获取模式设置为`PDO::FETCH_INTO`，如下例所示：'
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here again, however, we encounter a problem: `fetch()`, unlike `fetchObject()`,
    is not able to overwrite protected properties; the following error message is
    generated if it tries. This means we will either have to define all properties
    as `public`, or consider another approach.![How to do it...](graphics/B05314_05_07.jpg)'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，我们在这里又遇到了一个问题：`fetch()`与`fetchObject()`不同，它无法覆盖受保护的属性；如果尝试覆盖，将生成以下错误消息。这意味着我们要么将所有属性定义为`public`，要么考虑另一种方法。![如何做...](graphics/B05314_05_07.jpg)
- en: 'The last approach we will consider will be to fetch the results in the form
    of an array, and manually *hydrate* the entity. Even though this approach is slightly
    more costly in terms of performance, it allows any potential entity constructor
    to run properly, and keeps properties safely defined as `private` or `protected`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将考虑的最后一种方法是以数组形式获取结果，并手动*hydrate*实体。尽管这种方法在性能方面略微昂贵，但它允许任何潜在的实体构造函数正常运行，并且可以安全地将属性定义为`private`或`protected`：
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To process a query that produces multiple results, all we need to do is to
    produce an iteration of populated entity objects. In this example, we implement
    a `fetchByLevel()` method that returns all customers for a given level, in the
    form of `Application\Entity\Customer` instances:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要处理产生多个结果的查询，我们只需要生成填充的实体对象的迭代。在这个例子中，我们实现了一个`fetchByLevel()`方法，它以`Application\Entity\Customer`实例的形式返回给定级别的所有客户：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The next method we wish to implement is `save()`. Before we can proceed, however,
    some thought must be given to what value will be returned if an `INSERT` takes
    place.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望实现的下一个方法是`save()`。然而，在我们继续之前，必须考虑如果发生`INSERT`，将返回什么值。
- en: Normally, we would return the newly completed entity class after an `INSERT`.
    There is a convenient `PDO::lastInsertId()` method which, at first glance, would
    seem to do the trick. Further reading of the documentation reveals, however, that
    not all database extensions support this feature, and the ones that do are not
    consistent in their implementation. Accordingly, it would be a good idea to have
    a unique column other than `$id` that can be used to uniquely identify the new
    customer.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，我们会在`INSERT`后返回新完成的实体类。有一个方便的`PDO::lastInsertId()`方法，乍一看似乎可以解决问题。然而，进一步阅读文档后发现，并非所有的数据库扩展都支持这个特性，而且支持的数据库扩展在实现上也不一致。因此，最好有一个除了`$id`之外的唯一列，可以用来唯一标识新客户。
- en: 'In this example we have chosen the `email` column, and thus need to implement
    a `fetchByEmail()` service method:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们选择了`email`列，因此需要实现一个`fetchByEmail()`服务方法：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now we are ready to define the `save()` method. Rather than distinguish between
    `INSERT` and `UPDATE`, we will architect this method to update if the ID already
    exists, and otherwise do an insert.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备定义`save()`方法。我们不再区分`INSERT`和`UPDATE`，而是将这个方法设计为如果ID已经存在，则更新，否则进行插入。
- en: 'First, we define a basic `save()` method, which accepts a `Customer` entity
    as an argument, and uses `fetchById()` to determine if this entry already exists.
    If it exists, we call an `doUpdate()` update method; otherwise, we call a `doInsert()`
    insert method:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个基本的`save()`方法，它接受一个`Customer`实体作为参数，并使用`fetchById()`来确定此条目是否已经存在。如果存在，我们调用一个`doUpdate()`更新方法；否则，我们调用一个`doInsert()`插入方法：
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, we define `doUpdate()`, which pulls `Customer` entity object properties
    into an array, builds an initial SQL statement, and calls a `flush()` method,
    which pushes data to the database. We do not want the ID field updated, as it''s
    the primary key. Also we need to specify which row to update, which means appending
    a `WHERE` clause:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义`doUpdate()`，它将`Customer`实体对象的属性提取到一个数组中，构建一个初始的SQL语句，并调用`flush()`方法，将数据推送到数据库。我们不希望ID字段被更新，因为它是主键。另外，我们需要指定要更新的行，这意味着要添加一个`WHERE`子句：
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `doInsert()` method is similar, except that the initial SQL needs to start
    with `INSERT INTO ...` and the `id` array element needs to be unset. The reason
    for the latter is that we want this property to be auto-generated by the database.
    If this is successful, we use our newly defined `fetchByEmail()` method to look
    up the new customer and return a completed instance:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`doInsert()`方法类似，只是初始的SQL需要以`INSERT INTO ...`开头，并且需要取消`id`数组元素。后者的原因是我们希望这个属性由数据库自动生成。如果成功，我们使用我们新定义的`fetchByEmail()`方法查找新客户并返回一个完成的实例：'
- en: '[PRE55]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we are in a position to define `flush()`, which does the actual preparation
    and execution:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以定义`flush()`，它执行实际的准备和执行：
- en: '[PRE56]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To round off the discussion, we need to define a `remove()` method, which deletes
    a customer from the database. Again, as with the `save()` method defined previously,
    we use `fetchById()` to ensure the operation was successful:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了结束讨论，我们需要定义一个`remove()`方法，它可以从数据库中删除一个客户。与之前定义的`save()`方法一样，我们再次使用`fetchById()`来确保操作成功：
- en: '[PRE57]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Copy the code described in steps 1 to 5 into a `CustomerService.php` file in
    the `Application/Database` folder. Define a `chap_05_entity_to_query.php` calling
    program. Have the calling program initialize the autoloader, using the appropriate
    classes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将步骤1到5中描述的代码复制到`Application/Database`文件夹中的`CustomerService.php`文件中。定义一个`chap_05_entity_to_query.php`调用程序。让调用程序初始化自动加载器，使用适当的类：
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can now create an instance of the service, and fetch a single customer
    at random. The service will then return a customer entity as a result:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以创建一个服务的实例，并随机获取一个客户。然后服务将返回一个客户实体作为结果：
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here is the output:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '![How it works...](graphics/B05314_05_08.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_05_08.jpg)'
- en: 'Now copy the code shown in steps 6 to 15 into the service class. Add the data
    to insert to the `chap_05_entity_to_query.php` calling program. We then generate
    a `Customer` entity instance using this data:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将步骤6到15中显示的代码复制到服务类中。将要插入的数据添加到`chap_05_entity_to_query.php`调用程序中。然后使用这些数据生成一个`Customer`实体实例：
- en: '[PRE60]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can then examine the ID before and after the call to `save()`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在调用`save()`之前和之后检查ID：
- en: '[PRE61]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, we modify the balance, and again call `save()`, viewing the results:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们修改余额，然后再次调用`save（）`，查看结果：
- en: '[PRE62]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here is the output from the calling program:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调用程序的输出：
- en: '![How it works...](graphics/B05314_05_09.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_05_09.jpg)'
- en: There's more...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: For more information on the relational model, please refer to [https://en.wikipedia.org/wiki/Relational_model](https://en.wikipedia.org/wiki/Relational_model).
    For more information on RDBMS, please refer to [https://en.wikipedia.org/wiki/Relational_database_management_system](https://en.wikipedia.org/wiki/Relational_database_management_system).
    For information on how `PDOStatement::fetchObject()` inserts property values even
    before the constructor, have a look at the comment by "rasmus at mindplay dot
    dk" in the php.net documentation reference on `fetchObject()` ([http://php.net/manual/en/pdostatement.fetchobject.php](http://php.net/manual/en/pdostatement.fetchobject.php)).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有关关系模型的更多信息，请参阅[https://en.wikipedia.org/wiki/Relational_model](https://en.wikipedia.org/wiki/Relational_model)。有关RDBMS的更多信息，请参阅[https://en.wikipedia.org/wiki/Relational_database_management_system](https://en.wikipedia.org/wiki/Relational_database_management_system)。有关`PDOStatement::fetchObject（）`在构造函数之前插入属性值的信息，请查看php.net文档参考中关于`fetchObject（）`的"rasmus
    at mindplay dot dk"的评论（[http://php.net/manual/en/pdostatement.fetchobject.php](http://php.net/manual/en/pdostatement.fetchobject.php)）。
- en: Embedding secondary lookups into query results
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将辅助查找嵌入到查询结果中
- en: On the road towards implementing relationships between entity classes, let us
    first take a look at how we can embed the code needed to perform a secondary lookup.
    An example of such a lookup is when displaying information on a customer, have
    the view logic perform a second lookup that gets a list of purchases for that
    customer.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现实体类之间的关系之路上，让我们首先看一下如何嵌入执行辅助查找所需的代码。这样一个查找的示例是，在显示客户信息时，视图逻辑执行第二次查找，获取该客户的购买列表。
- en: Note
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The advantage of this approach is that processing is deferred until the actual
    view logic is executed. This will ultimately smooth the performance curve, with
    the workload distributed more evenly between the initial query for customer information,
    and the later query for purchase information. Another benefit is that a massive
    `JOIN` is avoided with its inherent redundant data.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优势在于，处理被推迟直到实际视图逻辑被执行。这将最终平滑性能曲线，工作负载在客户信息的初始查询和后来的购买信息查询之间更均匀地分布。另一个好处是避免了大量的`JOIN`及其固有的冗余数据。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First of all, define a function that finds a customer based on their ID. For
    the purposes of this illustration, we will simply fetch an array using the fetch
    mode `PDO::FETCH_ASSOC`. We will also continue to use the `Application\Database\Connection`
    class discussed in [Chapter 1](ch01.html "Chapter 1. Building a Foundation"),
    *Building a Foundation*:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，定义一个根据其ID查找客户的函数。为了说明这一点，我们将简单地使用`PDO::FETCH_ASSOC`的获取模式获取一个数组。我们还将继续使用[第1章](ch01.html
    "第1章。建立基础")中讨论的`Application\Database\Connection`类，*建立基础*：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, we analyze the purchases table to see how the `customer` and `product`
    tables are linked. As you can see from the `CREATE` statement for this table,
    the `customer_id` and `product_id` foreign keys form the relationships:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们分析购买表，看看`customer`和`product`表是如何关联的。从这个表的`CREATE`语句中可以看出，`customer_id`和`product_id`外键形成了关系：
- en: '[PRE64]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We now expand the original `findCustomerById()` function, defining the secondary
    lookup in the form of an anonymous function, which can then be executed in a view
    script. The anonymous function is assigned to the `$results[''purchases'']` element:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在扩展原始的`findCustomerById（）`函数，定义形式为匿名函数的辅助查找，然后可以在视图脚本中执行。将匿名函数分配给`$results['purchases']`元素：
- en: '[PRE65]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Assuming we have successfully retrieved customer information into a `$results`
    array, in the view logic, all we need to do is to loop through the return value
    of the anonymous function. In this example, we retrieve customer information at
    random:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们已成功将客户信息检索到`$results`数组中，在视图逻辑中，我们所需要做的就是循环遍历匿名函数的返回值。在这个例子中，我们随机检索客户信息：
- en: '[PRE66]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the view logic, we loop through the results returned by the secondary lookup.
    The call to the embedded anonymous function is highlighted in the following code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图逻辑中，我们循环遍历辅助查找返回的结果。嵌入的匿名函数的调用在以下代码中突出显示：
- en: '[PRE67]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: How it works...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Create a `chap_05_secondary_lookups.php` calling program and insert the code
    needed to create an instance of `Application\Database\Connection`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`chap_05_secondary_lookups.php`调用程序，并插入所需的代码以创建`Application\Database\Connection`的实例：
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, add the `findCustomerById()`function shown in step 3\. You can then pull
    information for a random customer, ending the PHP part of the calling program:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在步骤3中显示的`findCustomerById（）`函数中添加。然后，您可以获取随机客户的信息，结束调用程序的PHP部分：
- en: '[PRE69]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'For the view logic, you can display core customer information as shown in several
    of the preceding recipes:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视图逻辑，您可以显示核心客户信息，就像在前面的几个示例中所示的那样：
- en: '[PRE70]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You can display information on purchases like so:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以这样显示购买信息：
- en: '[PRE71]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The critical piece is that the secondary lookup is performed as part of the
    view logic by calling the embedded anonymous function, `$result[''purchases'']($result[''id''],
    $conn)`. Here is the output:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的一点是，通过调用嵌入的匿名函数`$result['purchases']($result['id'], $conn)`，辅助查找作为视图逻辑的一部分执行。这是输出：
- en: '![How it works...](graphics/B05314_05_10.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_05_10.jpg)'
- en: Implementing jQuery DataTables PHP lookups
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现jQuery DataTables PHP查找
- en: Another approach to secondary lookups is to have the frontend generate the request.
    In this recipe, we will make a slight modification to the secondary lookup code
    presented in the preceding recipe, Embedding secondary lookups into QueryResults.
    In the previous recipe, even though the view logic is performing the lookup, all
    processing is still done on the server. When using **jQuery DataTables**, however,
    the secondary lookup is actually performed directly by the client, in the form
    of an **Asynchronous JavaScript and XML** (**AJAX**) request issued by the browser.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 进行次要查找的另一种方法是让前端生成请求。在这个食谱中，我们将对前面食谱中介绍的次要查找代码进行轻微修改，将次要查找嵌入到QueryResults中。在以前的食谱中，即使视图逻辑执行查找，所有处理仍然在服务器上完成。但是，当使用**jQuery
    DataTables**时，次要查找实际上是由客户端直接执行的，以**异步JavaScript和XML**（**AJAX**）请求的形式由浏览器发出。
- en: How to do it...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First we need to spin-off the secondary lookup logic (discussed in the recipe
    above) into a separate PHP file. The purpose of this new script is to perform
    the secondary lookup and return a JSON array.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将上面讨论的次要查找逻辑（在上面的食谱中讨论）分离到一个单独的PHP文件中。这个新脚本的目的是执行次要查找并返回一个JSON数组。
- en: The new script we will call `chap_05_jquery_datatables_php_lookups_ajax.php`.
    It looks for a `$_GET` parameter, `id`. Notice that the `SELECT` statement is
    very specific as to which columns are delivered. You will also note that the fetch
    mode has been changed to `PDO::FETCH_NUM`. You might also notice that the last
    line takes the results and assigns it to a `data` key in a JSON-encoded array.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的脚本我们将称之为`chap_05_jquery_datatables_php_lookups_ajax.php`。它寻找一个`$_GET`参数，`id`。请注意，`SELECT`语句非常具体，以确定传递了哪些列。您还会注意到，提取模式已更改为`PDO::FETCH_NUM`。您可能还会注意到，最后一行将结果取出并将其分配给JSON编码数组中的`data`键。
- en: Tip
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is *extremely* important when dealing with zero configuration jQuery DataTables
    to only return the exact number of columns matching the header.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理零配置jQuery DataTables时，非常重要的一点是只返回与标题匹配的确切列数。
- en: '[PRE72]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, we need to modify the function that retrieves customer information by
    ID, removing the secondary lookup embedded in the previous recipe:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改通过ID检索客户信息的函数，删除在前面食谱中嵌入的次要查找：
- en: '[PRE73]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'After that, in the view logic, we import the minimum jQuery, DataTables, and
    stylesheets for a zero configuration implementation. At a minimum, you will need
    jQuery itself (in this example `jquery-1.12.0.min.js`) and DataTables (`jquery.dataTables.js`).
    We''ve also added a convenient stylesheet associated with DataTables, `jquery.dataTables.css`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在视图逻辑中，我们导入最少的jQuery，DataTables和样式表，以实现零配置。至少，您将需要jQuery本身（在本例中为`jquery-1.12.0.min.js`）和DataTables（`jquery.dataTables.js`）。我们还添加了一个方便的与DataTables关联的样式表，`jquery.dataTables.css`：
- en: '[PRE74]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We then define a jQuery document `ready` function, which associates a table
    with DataTables. In this case, we assign an id attribute of `customerTable` to
    the table element that will be assigned to DataTables. You''ll also notice that
    we specify the AJAX data source as the script defined in step 1, `chap_05_jquery_datatables_php_lookups_ajax.php`.
    As we have the `$id` available, this is appended to the data source URL:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个jQuery文档`ready`函数，将一个表格与DataTables关联起来。在这种情况下，我们将id属性`customerTable`分配给将分配给DataTables的表元素。您还会注意到，我们将AJAX数据源指定为步骤1中定义的脚本`chap_05_jquery_datatables_php_lookups_ajax.php`。由于我们有`$id`可用，因此将其附加到数据源URL中：
- en: '[PRE75]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In the body of the view logic, we define the table, making sure the `id` attribute
    matches the one specified in the preceding code. We also need to define headers
    that will match the data presented in response to the AJAX request:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图逻辑的主体中，我们定义表格，确保`id`属性与前面的代码中指定的一致。我们还需要定义标题，以匹配响应AJAX请求呈现的数据：
- en: '[PRE76]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now, all that remains to do is to load the page, choose the customer ID (in
    this case, at random), and let jQuery make the request for the secondary lookup.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，剩下的就是加载页面，选择客户ID（在这种情况下是随机选择），并让jQuery发出次要查找的请求。
- en: How it works...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Create a `chap_05_jquery_datatables_php_lookups_ajax.php` script, which will
    respond to an AJAX request. Inside, place the code to initialize auto-loading
    and create a `Connection` instance. You can then append the code shown in step
    2 of the preceding recipe:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`chap_05_jquery_datatables_php_lookups_ajax.php`脚本，用于响应AJAX请求。在其中，放置初始化自动加载和创建`Connection`实例的代码。然后，您可以附加前面食谱中步骤2中显示的代码：
- en: '[PRE77]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Next, create a `chap_05_jquery_datatables_php_lookups.php` calling program
    that will pull information on a random customer. Add the function described in
    step 3 of the preceding code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个`chap_05_jquery_datatables_php_lookups.php`调用程序，将随机客户的信息提取出来。添加前面代码中描述的步骤3中的函数：
- en: '[PRE78]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The calling program will also contain the view logic that imports the minimum
    JavaScript to implement jQuery DataTables. You can add the code shown in step
    3 of the preceding code. Then, add the document `ready` function and the display
    logic shown in steps 5 and 6\. Here is the output:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 调用程序还将包含导入最少JavaScript以实现jQuery DataTables的视图逻辑。您可以添加前面代码中显示的步骤3中的代码。然后，添加文档`ready`函数和显示逻辑，如步骤5和6中所示。这是输出：
- en: '![How it works...](graphics/B05314_05_11.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_05_11.jpg)'
- en: There's more...
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: For more information on jQuery, please visit their website at [https://jquery.com/](https://jquery.com/).
    To read about the DataTables plugin to jQuery, refer to this article at [https://www.datatables.net/](https://www.datatables.net/).
    Zero configuration data tables are discussed at [https://datatables.net/examples/basic_init/zero_configuration.html](https://datatables.net/examples/basic_init/zero_configuration.html).
    For more information on AJAX sourced data, have a look at [https://datatables.net/examples/data_sources/ajax.html](https://datatables.net/examples/data_sources/ajax.html).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 有关jQuery的更多信息，请访问他们的网站[https://jquery.com/](https://jquery.com/)。要了解有关jQuery的DataTables插件的信息，请参阅此文章[https://www.datatables.net/](https://www.datatables.net/)。零配置数据表的讨论在[https://datatables.net/examples/basic_init/zero_configuration.html](https://datatables.net/examples/basic_init/zero_configuration.html)。有关AJAX数据来源的更多信息，请查看[https://datatables.net/examples/data_sources/ajax.html](https://datatables.net/examples/data_sources/ajax.html)。
