- en: '*Chapter 10*: Improving Performance'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：提高性能'
- en: PHP 8.x introduces a number of new features that have a positive effect on performance.
    Also, a number of internal improvements, especially in array handling and managing
    object references, lead to a substantive performance increase over earlier PHP
    versions. In addition, many of the PHP 8 best practices covered in this chapter
    lead to greater efficiency and lower memory usage. In this chapter, you'll discover
    how to optimize your PHP 8 code to achieve maximum performance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8.x引入了许多新功能，对性能产生了积极影响。此外，许多PHP 8最佳实践涵盖的内容可以提高效率并降低内存使用。在本章中，您将了解如何优化您的PHP
    8代码以实现最佳性能。
- en: PHP 8 includes a technology referred to as weak references. By mastering this
    technology, discussed in the last section of this chapter, your applications will
    use far less memory. By carefully reviewing the material covered in this chapter
    and by studying the code examples, you will be able to write faster and more efficient
    code. Such mastery will vastly improve your standing as a PHP developer and result
    in satisfied customers, as well as improving your career potential.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8包括一种称为弱引用的技术。通过掌握本章最后一节讨论的这项技术，您的应用程序将使用更少的内存。通过仔细审查本章涵盖的材料并研究代码示例，您将能够编写更快，更高效的代码。这种掌握将极大地提高您作为PHP开发人员的地位，并带来满意的客户，同时提高您的职业潜力。
- en: 'Topics covered in this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: Working with the **Just-In-Time** (**JIT**) compiler
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用即时（JIT）编译器
- en: Speeding up array handling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速数组处理
- en: Implementing stable sort
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现稳定排序
- en: Using weak references to improve efficiency
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用弱引用来提高效率
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To examine and run the code examples provided in this chapter, the minimum
    recommended hardware is the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查和运行本章提供的代码示例，最低推荐的硬件如下：
- en: x86_64 based desktop PC or laptop
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于x86_64的台式PC或笔记本电脑
- en: 1 gigabyte (GB) free disk space
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 GB的可用磁盘空间
- en: 4 GB of RAM
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 GB的RAM
- en: 500 kilobits per second (Kbps) or faster internet connection
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每秒500千比特（Kbps）或更快的互联网连接
- en: 'In addition, you will need to install the following software:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还需要安装以下软件：
- en: Docker
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Docker Compose
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Please refer to the *Technical requirements* section of [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013),
    *Introducing New PHP 8 OOP Features*, for more information on Docker and Docker
    Compose installation, as well as how to build the Docker container used to demonstrate
    the code explained in this book. In this book, we refer to the directory in which
    you stored the sample code for this book as `/repo`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Docker和Docker Compose安装的更多信息，请参阅[*第1章*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013)的*技术要求*部分，以及如何构建用于演示本书中解释的代码的Docker容器。在本书中，我们将存储本书示例代码的目录称为“/repo”。
- en: 'The source code for this chapter is located here: https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices.
    We can now begin our discussion by having a look at the long-awaited JIT compiler.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于此处：https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices。现在我们可以开始讨论了，看看备受期待的JIT编译器。
- en: Working with the JIT compiler
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JIT编译器
- en: PHP 8 introduces the long-awaited **JIT compiler**. This is an important step
    and has important ramifications for the long-term viability of the PHP language.
    Although PHP already had the ability to produce and cache **bytecode**, before
    the introduction of the JIT compiler, PHP did not have the ability to directly
    cache **machine code**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8引入了备受期待的JIT编译器。这是一个重要的步骤，对PHP语言的长期可行性有重要影响。尽管PHP已经有能力生成和缓存字节码，但在引入JIT编译器之前，PHP没有直接缓存机器码的能力。
- en: There have actually been several attempts to add JIT compiler capabilities to
    PHP, dating back to 2011\. The performance boost seen in PHP 7 was a direct result
    of these early efforts. None of the earlier JIT compiler efforts were proposed
    as **RFCs** (**Requests for Comments**) as they didn't significantly improve performance.
    The core team now feels that any further performance gains can now only be achieved
    using JIT. As a side benefit, this opens the possibility of PHP being used as
    a language for non-web environments. Another benefit is that the JIT compiler
    opens the possibility to develop PHP extensions in languages other than C.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，自2011年以来就有几次尝试为PHP添加JIT编译器功能。PHP 7中看到的性能提升是这些早期努力的直接结果。由于它们并没有显著提高性能，因此以前的JIT编译器努力都没有被提议为RFC（请求评论）。核心团队现在认为，只有使用JIT才能实现进一步的性能提升。作为一个附带的好处，这打开了PHP作为非Web环境语言的可能性。另一个好处是JIT编译器打开了使用其他语言（而不是C）开发PHP扩展的可能性。
- en: It's extremely important to pay close attention to the details given in this
    chapter as proper use of the new JIT compiler has the potential to greatly improve
    the performance of your PHP applications. Before we get into implementation details,
    it's first necessary to explain how PHP executes bytecode without the JIT compiler.
    We'll then show you how the JIT compiler works. After this, you will be in a better
    position to understand the various settings and how they can be fine-tuned to
    produce the best possible performance for your application code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中非常重要的是要仔细阅读给出的细节，因为正确使用新的JIT编译器有可能极大地提高PHP应用程序的性能。在我们深入实现细节之前，首先需要解释PHP在没有JIT编译器的情况下如何执行字节码。然后我们将向您展示JIT编译器的工作原理。之后，您将更好地理解各种设置以及如何对其进行微调，以产生最佳的应用程序代码性能。
- en: Let's now turn our attention to how PHP works without the JIT compiler.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在关注PHP在没有JIT编译器的情况下是如何工作的。
- en: Discovering how PHP works without JIT
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解PHP在没有JIT的情况下如何工作
- en: When PHP is installed on a server (or in a Docker container), in addition to
    the core extensions, the main component installed is actually a **virtual machine**
    (**VM**) often referred to as the **Zend Engine**. This VM operates in a manner
    quite different from virtualization technologies such as *VMware* or *Docker*.
    The Zend Engine is closer in nature to the **Java Virtual Machine** (**JVM**)
    in that it accepts *bytecode* and produces *machine code*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当在服务器上安装PHP（或在Docker容器中），除了核心扩展之外，实际安装的主要组件是一个通常被称为**Zend引擎**的**虚拟机**（**VM**）。这个虚拟机的运行方式与*VMware*或*Docker*等虚拟化技术大不相同。Zend引擎更接近于**Java虚拟机**（**JVM**），它接受*字节码*并产生*机器码*。
- en: 'This begs the question: *what is bytecode* and *what is machine code*? Let''s
    have a look at this question now.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个问题：*什么是字节码*和*什么是机器码*？让我们现在来看一下这个问题。
- en: Understanding bytecode and machine code
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解字节码和机器码
- en: Machine code, or **machine language**, is a set of hardware instructions understood
    by the CPU directly. Each piece of machine code is an instruction that causes
    the CPU to perform a specific operation. These low-level operations include moving
    information between registers, moving a given number of bytes in or out of memory,
    adding, subtracting, and so forth.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 机器码，或**机器语言**，是CPU直接理解的一组硬件指令。每条机器码都是一条指令，会导致CPU执行特定的操作。这些低级操作包括在寄存器之间移动信息，在内存中移动指定字节数，加法，减法等等。
- en: 'Machine code is often rendered somewhat human-readable by using **assembly
    language**. Here is an example of machine code rendered in assembly language:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 机器码通常通过使用**汇编语言**来使其在一定程度上可读。以下是一个以汇编语言呈现的机器码示例：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Although, for the most part, the commands are not easily understood, you can
    see from the assembly language representation that the instructions include commands
    to compare (`cmp`), move information between registers and/or memory (`mov`),
    and jump to another point in the instruction set (`jmp`).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大部分命令不容易理解，但您可以从汇编语言表示中看到指令包括比较（`cmp`），在寄存器和/或内存之间移动信息（`mov`），以及跳转到指令集中的另一个点（`jmp`）。
- en: Bytecode, also called **opcode**, is a greatly reduced symbolic representation
    of the original program code. Bytecode is produced by a parsing process (often
    called the **interpreter**) that breaks human-readable program code into symbols
    known as **tokens**, along with values. Values would be any string, integer, float,
    and Boolean data used in the program code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码，也称为**操作码**，是原始程序代码的大大简化的符号表示。字节码是由一个解析过程（通常称为**解释器**）产生的，该过程将可读的程序代码分解为称为**标记**的符号，以及值。值可以是程序代码中使用的任何字符串，整数，浮点数和布尔数据。
- en: 'Here is an example of a fragment of the bytecode produced based upon the example
    code (shown later) used to create a Mandelbrot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于后面显示的示例代码创建Mandelbrot所产生的字节码片段的一个示例：
- en: '![Figure 10.1 – Bytecode fragment produced by the PHP parsing process'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 - PHP解析过程产生的字节码片段'
- en: '](image/B16992_Figure_10.1.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16992_Figure_10.1.jpg)'
- en: Figure 10.1 – Bytecode fragment produced by the PHP parsing process
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 - PHP解析过程产生的字节码片段
- en: Let's now have a look at the conventional execution flow of a PHP program.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下PHP程序的传统执行流程。
- en: Understanding conventional PHP program execution
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解传统的PHP程序执行
- en: In a conventional PHP program run cycle, the PHP program code is evaluated and
    broken down into bytecode by an operation known as **parsing**. The bytecode is
    then passed to the Zend Engine, which in turn converts the bytecode into machine
    code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的PHP程序运行周期中，PHP程序代码通过一个称为**解析**的操作进行评估并分解为字节码。然后将字节码传递给Zend引擎，Zend引擎将字节码转换为机器码。
- en: When PHP is first installed on a server, the installation process kicks in the
    necessary logic that tailors the Zend Engine to the specific CPU and hardware
    (or virtual CPU and hardware) for that particular server. Thus, when you write
    PHP code, you have no awareness of the particulars of the actual CPU that eventually
    runs your code. It is the Zend Engine that provides hardware-specific awareness.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当PHP首次安装在服务器上时，安装过程会启动必要的逻辑，将Zend引擎定制为特定服务器的CPU和硬件（或虚拟CPU和硬件）。因此，当您编写PHP代码时，您并不知道最终运行代码的实际CPU的具体情况。正是Zend引擎提供了硬件特定的意识。
- en: '*Figure 10.2*, shown next, illustrates conventional PHP execution:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来显示的*图10.2*说明了传统的PHP执行方式：
- en: '![Figure 10.2 – Conventional PHP program execution flow'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2 - 传统的PHP程序执行流程'
- en: '](image/B16992_Figure_10.2.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16992_Figure_10.2.jpg)'
- en: Figure 10.2 – Conventional PHP program execution flow
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 - 传统的PHP程序执行流程
- en: Although PHP, especially PHP 7, is quite fast, it's still of interest to gain
    additional speed. For this purpose, most installations also enable the PHP **OPcache**
    extension. Let's have a quick look at OPcache before moving on to the JIT compiler.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管PHP，特别是PHP 7，非常快，但获得额外的速度仍然很有意义。出于这个目的，大多数安装也启用了PHP **OPcache**扩展。在继续讨论JIT编译器之前，让我们快速了解一下OPcache。
- en: Understanding the operation of PHP OPcache
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解PHP OPcache的操作
- en: As the name implies, the PHP OPcache extension *caches* opcode (bytecode) the
    first time a PHP program is run. On subsequent program runs, the bytecode is drawn
    from the cache, eliminating the parsing phase. This saves a significant amount
    of time and is a highly desirable feature to enable on a production site. The
    PHP OPcache extension is part of the set of core extensions; however, it's not
    enabled by default.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，PHP OPcache扩展在首次运行PHP程序时*缓存*了操作码（字节码）。在后续的程序运行中，字节码将从缓存中获取，消除了解析阶段。这节省了大量时间，是一个在生产环境中启用的非常理想的功能。PHP
    OPcache扩展是核心扩展集的一部分；但是，默认情况下它并未启用。
- en: 'Before enabling this extension, you must first confirm that your version of
    PHP has been compiled with the `--enable-opcache` configure option. You can check
    this by executing the `phpinfo()` command from inside PHP code running on your
    web server. From the command line, enter the `php -i` command. Here is an example
    running `php -i` from the Docker container used for this book:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用此扩展之前，您必须首先确认您的PHP版本是否使用了`--enable-opcache`配置选项进行编译。您可以通过在运行在Web服务器上的PHP代码中执行`phpinfo()`命令来检查这一点。从命令行中，输入`php
    -i`命令。以下是在本书使用的Docker容器中运行`php -i`的示例：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see from the output, OPcache was included in the configuration for
    this PHP installation. To enable OPcache, add or uncomment the following `php.ini`
    file settings:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，OPcache已包含在此PHP安装的配置中。要启用OPcache，请添加或取消注释以下`php.ini`文件设置：
- en: '`zend_extension=opcache`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zend_extension=opcache`'
- en: '`opcache.enable=1`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache.enable=1`'
- en: '`opcache.enable_cli=1`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache.enable_cli=1`'
- en: The last setting is optional. It determines whether or not PHP commands executed
    from the command line are also processed by OPcache. Once enabled, there are a
    number of other `php.ini` file settings that affect performance, however, these
    are beyond the scope of this discussion.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个设置是可选的。它确定是否还要处理从命令行执行的PHP命令。一旦启用，还有许多其他`php.ini`文件设置会影响性能，但这超出了本讨论的范围。
- en: Tip
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on PHP `php.ini` file settings that affect OPcache, have
    a look here: https://www.php.net/manual/en/opcache.configuration.php.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有关影响OPcache的PHP `php.ini`文件设置的更多信息，请查看这里：https://www.php.net/manual/en/opcache.configuration.php。
- en: Let's now have a look at how the JIT compiler operates, and how it differs from
    OPcache.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看JIT编译器的运行方式，以及它与OPcache的区别。
- en: Discovering PHP program execution with the JIT compiler
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用JIT编译器发现PHP程序执行
- en: 'The problem with the current approach is that whether or not the bytecode is
    cached, it''s still necessary for the Zend Engine to convert the bytecode into
    machine code each and every time the program request is made. What the JIT compiler
    offers is the ability to not only compile bytecode into machine code but to *cache
    machine code* as well. The process is facilitated by a tracing mechanism that
    creates traces of requests. The trace allows the JIT compiler to determine which
    blocks of machine code need to be optimized and cached. The execution flow using
    the JIT compiler is summarized in *Figure 10.3*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当前方法的问题在于，无论字节码是否被缓存，Zend引擎仍然需要每次程序请求时将字节码转换为机器代码。JIT编译器提供的是将字节码编译成机器代码并且*缓存机器代码*的能力。这个过程是通过一个跟踪机制来实现的，它创建请求的跟踪。跟踪允许JIT编译器确定哪些块的机器代码需要被优化和缓存。使用JIT编译器的执行流程总结在*图10.3*中：
- en: '![Figure 10.3 – PHP execution flow with the JIT compiler'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3 - 带有JIT编译器的PHP执行流'
- en: '](image/B16992_Figure_10.3.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16992_Figure_10.3.jpg)'
- en: Figure 10.3 – PHP execution flow with the JIT compiler
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 - 带有JIT编译器的PHP执行流
- en: As you can see from the diagram, the normal execution flow incorporating OPcache
    is still present. The main difference is that a request might invoke a trace,
    causing the program flow to shift immediately to the JIT compiler, effectively
    bypassing not only the parsing process but the Zend Engine as well. Both the JIT
    compiler and the Zend Engine can produce machine code ready for direct execution.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表中可以看出，包含OPcache的正常执行流仍然存在。主要区别在于请求可能会调用一个trace，导致程序流立即转移到JIT编译器，有效地绕过了解析过程和Zend引擎。JIT编译器和Zend引擎都可以生成准备直接执行的机器代码。
- en: The JIT compiler did not evolve out of thin air. The PHP core team elected to
    port the highly performant and well-tested **DynASM** preprocessing assembler.
    Although DynASM was primarily developed for the JIT compiler used by the **Lua**
    programming language, its design is such that it's perfectly suited to form the
    basis of a JIT compiler for any C-based language (such as PHP!).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: JIT编译器并非凭空产生。PHP核心团队选择移植了高性能和经过充分测试的**DynASM**预处理汇编器。虽然DynASM主要是为**Lua**编程语言使用的JIT编译器开发的，但其设计非常适合作为任何基于C的语言（如PHP！）的JIT编译器的基础。
- en: Another favorable aspect of the PHP JIT implementation is that it doesn't produce
    any **Intermediate Representation** (**IR**) code. In contrast, the **PyPy VM**
    used to run Python code using JIT compiler technology, has to first produce IR
    code in a **graph structure**, used for flow analysis and optimization, before
    the actual machine code is produced. The DynASM core in the PHP JIT doesn't require
    this extra step, resulting in greater performance than is possible in other interpreted
    programming languages.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: PHP JIT实现的另一个有利方面是它不会产生任何**中间表示**（**IR**）代码。相比之下，用于使用JIT编译器技术运行Python代码的**PyPy
    VM**必须首先产生**图结构**中的IR代码，用于流分析和优化，然后才能产生实际的机器代码。PHP JIT中的DynASM核心不需要这一额外步骤，因此比其他解释性编程语言可能实现的性能更高。
- en: Tip
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on DynASM, have a look at this website: https://luajit.org/dynasm.html.
    Here''s an excellent overview of how the PHP 8 JIT operates: https://www.zend.com/blog/exploring-new-php-jit-compiler.
    You can also read the official JIT RFC here: https://wiki.php.net/rfc/jit.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有关DynASM的更多信息，请查看此网站：https://luajit.org/dynasm.html。这是关于PHP 8 JIT操作的出色概述：https://www.zend.com/blog/exploring-new-php-jit-compiler。您还可以在这里阅读官方的JIT
    RFC：https://wiki.php.net/rfc/jit。
- en: Now that you have an idea of how the JIT compiler fits into the general flow
    of a PHP program execution cycle, it's time to learn how to enable it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了JIT编译器如何适应PHP程序执行周期的一般流程，是时候学习如何启用它了。
- en: Enabling the JIT compiler
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用JIT编译器
- en: Because the primary function of the JIT compiler is to cache machine code, it
    operates as an independent part of the OPcache extension. OPcache serves as a
    gateway to both enable JIT functionality as well as to allocate memory to the
    JIT compiler from its own allotment. Therefore, in order to enable the JIT compiler,
    you must first enable OPcache (see the previous section, *Understanding the operation
    of PHP OPcache*).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因为JIT编译器的主要功能是缓存机器代码，它作为OPcache扩展的独立部分运行。OPcache既可以作为启用JIT功能的网关，也可以从自己的分配中为JIT编译器分配内存。因此，为了启用JIT编译器，您必须首先启用OPcache（请参阅前一节，*理解PHP
    OPcache的操作*）。
- en: In order to enable the JIT compiler, you must first confirm that PHP has been
    compiled with the `--enable-opcache-jit` configuration option. You are then in
    a position to enable or disable the JIT compiler by simply assigning a non-zero
    value to the `php.ini` file's `opcache.jit_buffer_size` directive.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用JIT编译器，您必须首先确认PHP已经使用`--enable-opcache-jit`配置选项进行编译。然后，您可以通过简单地将非零值分配给`php.ini`文件的`opcache.jit_buffer_size`指令来启用或禁用JIT编译器。
- en: 'Values are specified either as an integer – in which case, the value represents
    the number of bytes; a value of zero (the default), which disables the JIT compiler;
    or you can assign a number followed by any of the following letters:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 值可以指定为整数——在这种情况下，该值表示字节数；值为零（默认值）会禁用JIT编译器；或者您可以分配一个数字，后面跟着以下任何一个字母：
- en: '`K`: Kilobytes'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`K`：千字节'
- en: '`M`: Megabytes'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M`：兆字节'
- en: '`G`: Gigabytes'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G`：千兆字节'
- en: The value you specify for the JIT compiler buffer size must be less than the
    memory allocation you assigned to OPcache because the JIT buffer is taken out
    of the OPcache buffer.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您为JIT编译器缓冲区大小指定的值必须小于您为OPcache分配的内存分配，因为JIT缓冲区是从OPcache缓冲区中取出的。
- en: 'Here is an example that sets the OPcache memory consumption to 256 M and the
    JIT buffer to 64 M. These values can be placed anywhere in the `php.ini` file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，将OPcache内存消耗设置为256 M，JIT缓冲区设置为64 M。这些值可以放在`php.ini`文件的任何位置：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that you have an idea of how the JIT compiler works, and how it can be enabled,
    it's extremely important that you know how to properly set the tracing mode.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了JIT编译器的工作原理，以及如何启用它，了解如何正确设置跟踪模式非常重要。
- en: Configuring the tracing mode
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置跟踪模式
- en: 'The `php.ini` setting `opcache.jit` controls the JIT tracer operation. For
    convenience, one of the following four preset strings can be used:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`php.ini`设置`opcache.jit`控制JIT跟踪器的操作。为了方便起见，可以使用以下四个预设字符串之一：'
- en: '`opcache.jit=disable`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache.jit=disable`'
- en: Completely disables the JIT compiler (regardless of other settings).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 完全禁用JIT编译器（不考虑其他设置）。
- en: '`opcache.jit=off`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache.jit=off`'
- en: Disables the JIT compiler but (in most cases) you can enable it at runtime using
    `ini_set()`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用JIT编译器，但（在大多数情况下）您可以使用`ini_set()`在运行时启用它。
- en: '`opcache.jit=function`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache.jit=function`'
- en: Sets the JIT compiler tracer to function mode. This mode corresponds to the
    **CPU Register Trigger Optimization (CRTO)** digits 1205 (explained next).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将JIT编译器跟踪器设置为功能模式。此模式对应于**CPU寄存器触发优化（CRTO）**数字1205（下面解释）。
- en: '`opcache.jit=tracing`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache.jit=tracing`'
- en: Sets the JIT compiler tracer to tracing mode. This mode corresponds to the CRTO
    digits 1254 (explained next). In most cases, this setting gives you the best performance.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将JIT编译器跟踪器设置为跟踪模式。此模式对应于CRTO数字1254（下面解释）。在大多数情况下，此设置可以获得最佳性能。
- en: '`opcache.jit=on`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache.jit=on`'
- en: This is an alias for tracing mode.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是跟踪模式的别名。
- en: Tip
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Relying upon runtime JIT activation is risky and can produce inconsistent application
    behavior. The best practice is to use either the `tracing` or the `function` setting.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖运行时JIT激活是有风险的，并且可能产生不一致的应用程序行为。最佳实践是使用`tracing`或`function`设置。
- en: 'The four convenience strings actually resolve into a four-digit number. Each
    digit corresponds to a different aspect of the JIT compiler tracer. The four digits
    are not bitmasks unlike other `php.ini` file settings and are specified in this
    order: `CRTO`. Here is a summary of each of the four digits.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个便利字符串实际上解析为一个四位数。每个数字对应JIT编译器跟踪器的不同方面。这四个数字不像其他`php.ini`文件设置那样是位掩码，并且按照这个顺序指定：`CRTO`。以下是每个四位数的摘要。
- en: C (CPU opt flags)
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C（CPU优化标志）
- en: The first digit represents CPU optimization settings. If you set this digit
    to 0, no CPU optimization takes place. A value of 1 enables the generation of
    **Advanced Vector Extensions** (**AVX**) **instructions**. AVX are extensions
    to the x86 instruction set architecture for microprocessors from Intel and AMD.
    AVX has been supported on Intel and AMD processors since 2011\. AVX2 is available
    on most server-type processors such as Intel Xeon.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数字代表CPU优化设置。如果将此数字设置为0，则不会进行CPU优化。值为1会启用**高级矢量扩展**（**AVX**）**指令**的生成。AVX是针对英特尔和AMD微处理器的x86指令集架构的扩展。自2011年以来，AVX已在英特尔和AMD处理器上得到支持。大多数服务器型处理器（如英特尔至强）都支持AVX2。
- en: R (register allocation)
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: R（寄存器分配）
- en: The second digit controls how the JIT compiler deals with **registers**. Registers
    are like RAM, except that they reside directly inside the CPU itself. The CPU
    constantly moves information in and out of registers in order to perform operations
    (for example, adding, subtracting, performing logical AND, OR, and NOT operations,
    and so forth). The options associated with this setting allow you to disable register
    allocation optimization or allow it at either the local or global level.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第二位数字控制JIT编译器如何处理**寄存器**。寄存器类似于RAM，只是它们直接驻留在CPU内部。CPU不断地在寄存器中移动信息，以执行操作（例如，加法、减法、执行逻辑AND、OR和NOT操作等）。与此设置相关的选项允许您禁用寄存器分配优化，或者在本地或全局级别允许它。
- en: T (JIT trigger)
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T（JIT触发器）
- en: The third digit dictates when the JIT compiler should trigger. Options include
    having the JIT compiler operate the first time a script is loaded or upon first
    execution. Alternatively, you can instruct the JIT when to compile **hot functions**.
    Hot functions are ones that are called the most frequently. There is also a setting
    that tells JIT to only compile functions marked with the `@jit docblock` annotation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第三位数字决定JIT编译器何时触发。选项包括在加载脚本时首次操作JIT编译器或在首次执行时操作。或者，您可以指示JIT何时编译**热函数**。热函数是最常被调用的函数。还有一个设置，告诉JIT只编译带有`@jit
    docblock`注释的函数。
- en: O (optimization level)
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: O（优化级别）
- en: The fourth digit corresponds to the optimization level. Options include disabling
    optimization, minimal, and selective. You can also instruct the JIT compiler to
    optimize based upon individual functions, call trees, or the results of inner
    procedure analysis.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第四位数字对应优化级别。选项包括禁用优化、最小化和选择性。您还可以指示JIT编译器根据单个函数、调用树或内部过程分析的结果进行优化。
- en: Tip
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For a complete breakdown of the four JIT compiler tracer settings, have a look
    at this documentation reference page: https://www.php.net/manual/en/opcache.configuration.php#ini.opcache.jit.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全了解四个JIT编译器跟踪器设置，请查看此文档参考页面：https://www.php.net/manual/en/opcache.configuration.php#ini.opcache.jit。
- en: Let's now have a look at the JIT compiler in action.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看JIT编译器的运行情况。
- en: Using the JIT compiler
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JIT编译器
- en: 'In this example, we use a classic benchmark program that produces a **Mandelbrot**.
    This is an excellent test as it''s extremely computation-intensive. The implementation
    we use here is drawn from the implementation code produced by **Dmitry Stogov**,
    one of the PHP core development team members. You can view the original implementation
    here: [https://gist.github.com/dstogov/12323ad13d3240aee8f1](https://gist.github.com/dstogov/12323ad13d3240aee8f1):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用一个经典的基准测试程序来生成**Mandelbrot**。这是一个非常消耗计算资源的优秀测试。我们在这里使用的实现是来自PHP核心开发团队成员**Dmitry
    Stogov**的实现代码。您可以在这里查看原始实现：[https://gist.github.com/dstogov/12323ad13d3240aee8f1](https://gist.github.com/dstogov/12323ad13d3240aee8f1)：
- en: 'We first define the Mandelbrot parameters. Especially important is the number
    of iterations (`MAX_LOOPS`). A large number spawns more calculations and slows
    down overall production. We also capture the start time:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义Mandelbrot参数。特别重要的是迭代次数（`MAX_LOOPS`）。较大的数字会产生更多的计算并减慢整体生产速度。我们还捕获开始时间：
- en: '[PRE3]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In order to facilitate multiple program runs, we add an option to capture a
    command line param, `-n`. If this parameter is present, the Mandelbrot output
    is suppressed:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了方便多次运行程序，我们添加了一个捕获命令行参数`-n`的选项。如果存在此参数，则Mandelbrot输出将被抑制：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We then define a function, `iterate()`, drawn directly from the Mandelbrot implementation
    by Dmitry Stogov. The actual code, not shown here, can be viewed at the URL mentioned
    earlier.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个名为`iterate()`的函数，直接从Dmitry Stogov的Mandelbrot实现中提取。实际代码在此未显示，可以在前面提到的URL中查看。
- en: 'Next, we produce the ASCII image by running through the X/Y coordinates determined
    by `EDGE`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过`EDGE`确定的X/Y坐标运行，生成ASCII图像：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we produce output. If running through a web request, the output is
    wrapped in `<pre>` tags. If the `-n` flag is present, only the elapsed time is
    shown:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们生成输出。如果通过Web请求运行，则输出将包含在`<pre>`标签中。如果存在`-n`标志，则只显示经过的时间：
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We first run the program in the PHP 7 Docker container three times using the
    `-n` flag. Here is the result. Please note that the elapsed time was easily over
    10 seconds in the demo Docker container used in conjunction with this book:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先在PHP 7 Docker容器中使用`-n`标志运行程序三次。以下是结果。请注意，在与本书配合使用的演示Docker容器中，经过的时间很容易超过10秒：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We now turn to the PHP 8 Docker container. To start, we adjust the `php.ini`
    file to disable the JIT compiler. Here are the settings:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们转向PHP 8 Docker容器。首先，我们调整`php.ini`文件以禁用JIT编译器。以下是设置：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is the result of running the program three times in PHP 8 using the `-n`
    flag:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是在使用`-n`标志的PHP 8中运行程序三次的结果：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Right away, you can see a great reason to switch to PHP 8! Even without the
    JIT compiler, PHP 8 was able to perform the same program in a little over 1 second:
    1/10 of the amount of time!'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 立即可以看到切换到PHP 8的一个很好的理由！即使没有JIT编译器，PHP 8也能在1秒多一点的时间内执行相同的程序：1/10的时间量！
- en: 'Next, we modify the `php.ini` file settings to use the JIT compiler `function`
    tracer mode. Here are the settings used:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们修改`php.ini`文件设置，以使用JIT编译器`function`跟踪器模式。以下是使用的设置：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We then run the same program again using the `-n` flag. Here are the results
    running in PHP 8 using the JIT compiler `function` tracer mode:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们再次使用`-n`标志运行相同的程序。以下是在使用JIT编译器`function`跟踪器模式的PHP 8中运行的结果：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Wow! We managed to speed up processing by a factor of 3\. The speed is now
    less than 1/3 of a second! But what happens if we try the recommended JIT compiler
    `tracing` mode? Here are the settings to invoke that mode:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哇！我们成功将处理速度提高了3倍。速度现在不到1/3秒！但是如果我们尝试推荐的JIT编译器`tracing`模式会发生什么呢？以下是调用该模式的设置：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here are the results of our last set of program runs:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是我们上一组程序运行的结果：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The last result, as shown in the output, is truly staggering. Not only can we
    run the same program 10x faster than PHP 8 without the JIT compiler, but we are
    running *100x faster* than PHP 7!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如输出所示，最后的结果真是令人震惊。我们不仅可以比没有JIT编译器的PHP 8运行相同的程序快10倍，而且比PHP 7运行*快100倍*！
- en: Important note
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It's important to note that times will vary depending on the host computer you
    are using to run the Docker containers associated with this book. You will not
    see exactly the same times as shown here.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，时间会根据您用于运行与本书相关的Docker容器的主机计算机而变化。您将看不到与此处显示的完全相同的时间。
- en: Let's now have a look at JIT compiler debugging.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看JIT编译器调试。
- en: Debugging with the JIT compiler
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JIT编译器进行调试
- en: Normal debugging using **XDebug** or other tools will not work effectively when
    using the JIT compiler. Accordingly, the PHP core team added an additional `php.ini`
    file option, `opcache.jit_debug`, which produces additional debugging information.
    In this case, the settings available take the form of bit flags, which means you
    can combine them using bitwise operators such as `AND`, `OR`, `XOR`, and so forth.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用JIT编译器时，使用**XDebug**或其他工具进行常规调试效果不佳。因此，PHP核心团队添加了一个额外的`php.ini`文件选项`opcache.jit_debug`，它会生成额外的调试信息。在这种情况下，可用的设置采用位标志的形式，这意味着您可以使用按位运算符（如`AND`，`OR`，`XOR`等）将它们组合起来。
- en: '*Table 10.1* summarizes values that can be assigned as an `opcache.jit_debug`
    setting. Please note that the column labeled **Internal Constant** does not show
    PHP predefined constants. These values are internal C code references:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*表10.1*总结了可以分配为`opcache.jit_debug`设置的值。请注意，标有**内部常量**的列不显示PHP预定义常量。这些值是内部C代码引用：'
- en: '![Table 10.1 – opcache.jit_debug settings'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![表10.1 - opcache.jit_debug设置'
- en: '](image/Table_10.1_B16992.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_10.1_B16992.jpg)'
- en: Table 10.1 – opcache.jit_debug settings
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1 - opcache.jit_debug设置
- en: 'So, for example, if you wish to enable debugging for `ZEND_JIT_DEBUG_ASM`,
    `ZEND_JIT_DEBUG_PERF`, and `ZEND_JIT_DEBUG_EXIT`, you could make the assignment
    in the `php.ini` file as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您希望为`ZEND_JIT_DEBUG_ASM`，`ZEND_JIT_DEBUG_PERF`和`ZEND_JIT_DEBUG_EXIT`启用调试，可以在`php.ini`文件中进行如下分配：
- en: 'First, you need to add up the values you wish to set. In this example, we would
    add:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要将要设置的值相加。在这个例子中，我们将添加：
- en: '`1 + 16 + 32768`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`1 + 16 + 32768`'
- en: 'You then apply the sum to the `php.ini` setting:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将总和应用于`php.ini`设置：
- en: '`opcache.jit_debug=32725`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`opcache.jit_debug=32725`'
- en: 'Or, alternatively, represent the values using bitwise `OR`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，使用按位`OR`表示这些值：
- en: '`opcache.jit_debug=1|16|32768`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`opcache.jit_debug=1|16|32768`'
- en: Depending on the debug setting, you are now in a position to debug the JIT compiler
    using tools such as the Linux `perf` command, or Intel `VTune`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 根据调试设置，您现在可以使用诸如Linux `perf`命令或Intel `VTune`之类的工具来调试JIT编译器。
- en: 'Here is a partial example of debug output when running the Mandelbrot test
    program discussed in the previous section. For the purposes of illustration, we
    are using the `php.ini` file setting `opcache.jit_debug=32725`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在运行前一节讨论的Mandelbrot测试程序时的部分调试输出示例。为了说明，我们使用了`php.ini`文件设置`opcache.jit_debug=32725`：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What the output shows you is machine code rendered in assembly language. If
    you experience problems with your program code when using the JIT compiler, the
    assembly language dump might assist you in locating the source of the error.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示的是用汇编语言呈现的机器代码。如果在使用JIT编译器时遇到程序代码问题，汇编语言转储可能会帮助您找到错误的源头。
- en: However, please be aware that assembly language is not portable, and is completely
    oriented toward the CPU being used. Accordingly, you might have to obtain the
    hardware reference manual for that CPU and look up the assembly language code
    being used.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，汇编语言不具有可移植性，完全面向使用的CPU。因此，您可能需要获取该CPU的硬件参考手册，并查找正在使用的汇编语言代码。
- en: Let's now have a look at the other `php.ini` file settings that affect the operation
    of the JIT compiler.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看影响JIT编译器操作的其他`php.ini`文件设置。
- en: Discovering additional JIT compiler settings
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现额外的JIT编译器设置
- en: '*Table 10.2* provides a summary of all other `opcache.jit*` settings in the
    `php.ini` file that have not already been covered:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*表10.2*提供了`php.ini`文件中尚未涵盖的所有其他`opcache.jit*`设置的摘要：'
- en: '![Table 10.2 – Additional opcache.jit* php.ini file settings'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![表10.2 - 附加的opcache.jit* php.ini文件设置'
- en: '](image/Table_10.2_B16992.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_10.2_B16992.jpg)'
- en: Table 10.2 – Additional opcache.jit* php.ini file settings
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.2 - 附加的opcache.jit* php.ini文件设置
- en: As you can see from the table, you have a high degree of control over how the
    JIT compiler operates. Collectively, these settings represent thresholds that
    control decisions the JIT compiler makes. These settings, if properly configured,
    allow the JIT compiler to ignore infrequently used loops and function calls. We'll
    now leave the exciting world of the JIT compiler and have a look at how to improve
    array performance.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从表中可以看出，您对JIT编译器的操作有很高的控制度。总体而言，这些设置代表了控制JIT编译器做出决策的阈值。如果正确配置这些设置，JIT编译器可以忽略不经常使用的循环和函数调用。现在我们将离开JIT编译器的激动人心的世界，看看如何提高数组性能。
- en: Speeding up array handling
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加速数组处理
- en: Arrays are a vital part of any PHP program. Indeed, dealing with arrays is unavoidable
    as much of the real-world data your program handles day to day arrives in the
    form of an array. One example is data from an HTML form posting. The data ends
    up in either `$_GET` or `$_POST` as an array.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是任何PHP程序的重要组成部分。实际上，处理数组是不可避免的，因为您的程序每天处理的大部分现实世界数据都以数组的形式到达。一个例子是来自HTML表单提交的数据。数据最终以数组的形式出现在`$_GET`或`$_POST`中。
- en: 'In this section, we''ll introduce you to a little-known class included with
    the SPL: the `SplFixedArray` class. Migrating your data from a standard array
    over to a `SplFixedArray` instance will not only improve performance but requires
    significantly less memory as well. Learning how to take advantage of the techniques
    covered in this chapter can have a substantial impact on the speed and efficiency
    of any program code currently using arrays with a massive amount of data.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您介绍SPL中包含的一个鲜为人知的类：`SplFixedArray`类。将数据从标准数组迁移到`SplFixedArray`实例不仅可以提高性能，而且还需要更少的内存。学习如何利用本章涵盖的技术可以对当前使用大量数据的数组的任何程序代码的速度和效率产生重大影响。
- en: Working with SplFixedArray in PHP 8
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在PHP 8中使用SplFixedArray
- en: The `SplFixedArray` class, introduced in PHP 5.3, is literally an object that
    acts like an array. Unlike `ArrayObject`, however, this class requires you to
    place a hard limit on the array size, and only allows integer indices. The reason
    why you might want to use `SplFixedArray` rather than `ArrayObject` is `SplFixedArray`
    takes significantly less memory and is highly performant. In fact, `SplFixedArray`
    actually takes *less memory* than a standard array with the same data!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`SplFixedArray`类是在PHP 5.3中引入的，它实际上是一个像数组一样操作的对象。然而，与`ArrayObject`不同，这个类要求您对数组大小设置一个硬限制，并且只允许整数索引。您可能想要使用`SplFixedArray`而不是`ArrayObject`的原因是，`SplFixedArray`占用的内存明显更少，并且性能非常好。事实上，`SplFixedArray`实际上比具有相同数据的标准数组占用*更少的内存*！'
- en: Comparing SplFixedArray with array and ArrayObject
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将SplFixedArray与数组和ArrayObject进行比较
- en: 'A simple benchmark program illustrates the differences between a standard array,
    `ArrayObject`, and `SplFixedArray`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的基准程序说明了标准数组、`ArrayObject`和`SplFixedArray`之间的差异：
- en: 'First, we define a couple of constants used later in the code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了代码中稍后使用的一对常量：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we define a function that adds 1 million elements comprised of a string
    64 bytes long:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个函数，该函数添加了100万个由64个字节长的字符串组成的元素：
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We then call the function three times, supplying `array`, `ArrayObject`, and
    `SplFixedArray` respectively as arguments:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们调用该函数三次，分别提供`array`、`ArrayObject`和`SplFixedArray`作为参数：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here are the results from our PHP 7.1 Docker container:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是我们的PHP 7.1 Docker容器的结果：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In PHP 8, the amount of time taken is significantly less, as shown here:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PHP 8中，所花费的时间显著减少，如下所示：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see from the results, PHP 8 handles arrays 10 times faster than PHP
    7.1\. The amount of memory used is identical between the two versions. What stands
    out, using either version of PHP, is that `SplFixedArray` uses significantly less
    memory than either a standard array or `ArrayObject`. Let's now have a look at
    how `SplFixedArray` usage has changed in PHP 8.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中可以看出，PHP 8处理数组的速度比PHP 7.1快10倍。两个版本使用的内存量是相同的。无论使用哪个版本的PHP，`SplFixedArray`使用的内存量都明显少于标准数组或`ArrayObject`。现在让我们来看看在PHP
    8中`SplFixedArray`的使用方式发生了哪些变化。
- en: Working with SplFixedArray changes in PHP 8
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在PHP 8中使用SplFixedArray的变化
- en: You might recall a brief discussion on the `Traversable` interface in [*Chapter
    7*](B16992_07_Final_JC_ePub.xhtml#_idTextAnchor162), *Avoiding Traps When Using
    PHP 8 Extensions*, in the *Traversable to IteratorAggregate migration* section.
    The same considerations brought out in that section also apply to `SplFixedArray`.
    Although `SplFixedArray` does not implement `Traversable`, it does implement `Iterator`,
    which in turn extends `Traversable`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得在[*第7章*](B16992_07_Final_JC_ePub.xhtml#_idTextAnchor162)中对`Traversable`接口的简要讨论，*在使用PHP
    8扩展时避免陷阱*，*Traversable to IteratorAggregate migration*部分。在该部分提出的相同考虑也适用于`SplFixedArray`。虽然`SplFixedArray`没有实现`Traversable`，但它实现了`Iterator`，而`Iterator`又扩展了`Traversable`。
- en: 'In PHP 8, `SplFixedArray` no longer implements `Iterator`. Instead, it implements
    `IteratorAggregate`. The benefit of this change is that `SplFixedArray` in PHP
    8 is faster, more efficient, and also safe to use in nested loops. The downside,
    and also a potential code break, is if you are using `SplFixedArray` along with
    any of these methods: `current()`, `key()`, `next()`, `rewind()`, or `valid()`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，`SplFixedArray`不再实现`Iterator`。相反，它实现了`IteratorAggregate`。这种变化的好处是，PHP
    8中的`SplFixedArray`更快，更高效，并且在嵌套循环中使用也更安全。不利之处，也是潜在的代码中断，是如果您正在与以下任何方法一起使用`SplFixedArray`：`current()`、`key()`、`next()`、`rewind()`或`valid()`。
- en: 'If you need access to array navigation methods, you now must use the `SplFixedArray::getIterator()`
    method to access the inner iterator, from which all of the navigation methods
    are available. A simple code example, shown here, illustrates the potential code
    break:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要访问数组导航方法，现在必须使用`SplFixedArray::getIterator()`方法来访问内部迭代器，从中可以使用所有导航方法。下面的简单代码示例说明了潜在的代码中断：
- en: 'We start by building an `SplFixedArray` instance from an array:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从数组构建一个`SplFixedArray`实例：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then use array navigation methods to iterate through the array:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用数组导航方法来遍历数组：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In PHP 7, the output is the five words in the array:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中，输出是数组中的五个单词：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In PHP 8, however, the result is quite different, as seen here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，结果却大不相同，如下所示：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to get the example working in PHP 8, all you need to do is to use
    the `SplFixedArray::getIterator()` method to access the inner iterator. The remainder
    of the code does not need to be rewritten. Here is the revised code example rewritten
    for PHP 8:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使示例在PHP 8中工作，您只需要使用`SplFixedArray::getIterator()`方法来访问内部迭代器。代码的其余部分不需要重写。以下是为PHP
    8重新编写的修订后的代码示例：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is now the five words, without any errors:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出的是五个单词，没有任何错误：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that you have an idea of how to improve array handling performance, we''ll
    turn our attention to yet another aspect of array performance: sorting.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何提高数组处理性能，我们将把注意力转向数组性能的另一个方面：排序。
- en: Implementing stable sort
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现稳定排序
- en: When designing the logic for array sorting, the original PHP developers sacrificed
    stability for speed. At the time, this was considered a reasonable sacrifice.
    However, if complex objects are involved in the sorting process, a **stable sort**
    is needed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计数组排序逻辑时，最初的PHP开发人员为了速度而牺牲了稳定性。当时，这被认为是一个合理的牺牲。然而，如果在排序过程中涉及复杂对象，则需要**稳定排序**。
- en: In this section, we discuss what stable sort is, and why it's important. If
    you can ensure that data is stably sorted, your application code will produce
    more accurate output, which results in greater customer satisfaction. Before we
    get into the details of how PHP 8 enables stable sorting, we first need to define
    what a stable sort is.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论稳定排序是什么，以及为什么它很重要。如果您可以确保数据被稳定排序，您的应用代码将产生更准确的输出，从而提高客户满意度。在我们深入了解PHP
    8如何实现稳定排序之前，我们首先需要定义什么是稳定排序。
- en: Understanding stable sorts
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解稳定排序
- en: 'When the values of properties used for the purposes of a sort are equal, in
    a *stable sort* the original order of elements is guaranteed. Such a result is
    closer to user expectations. Let''s have a look at a simple dataset and determine
    what would comprise a stable sort. For the sake of illustration, let''s assume
    our dataset includes entries for access time and username:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于排序目的的属性的值相等时，在*稳定排序*中保证了元素的原始顺序。这样的结果更接近用户的期望。让我们看一个简单的数据集，并确定什么构成了稳定排序。为了说明，让我们假设我们的数据集包括访问时间和用户名的条目：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we wish to sort by time, you will note right away that there are duplications
    for `2021-06-01 11:11:11`. If we were to perform a stable sort on this dataset,
    the expected outcome would appear as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望按时间排序，您会立即注意到`2021-06-01 11:11:11`存在重复。如果我们对这个数据集执行稳定排序，预期的结果将如下所示：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You'll notice from the sorted dataset that entries for the duplicate time of
    `2021-06-01 11:11:11` appear in the order they were originally entered. Thus,
    we can say that this result represents a stable sort.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到从排序后的数据集中，重复时间`2021-06-01 11:11:11`的条目按照它们最初的输入顺序出现。因此，我们可以说这个结果代表了一个稳定的排序。
- en: In an ideal world, the same principle should also apply to a sort that retains
    the key/value association. One additional criterion for a stable sort is that
    it should offer no difference in performance compared to an unregulated sort.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的情况下，相同的原则也应该适用于保留键/值关联的排序。稳定排序的一个额外标准是，它在性能上不应该与无序排序有任何差异。
- en: Tip
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on PHP 8 stable sorts, have a look at the official RFC
    here: https://wiki.php.net/rfc/stable_sorting.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PHP 8稳定排序的更多信息，请查看官方RFC：https://wiki.php.net/rfc/stable_sorting。
- en: In PHP 8, the core `*sort*()` functions and `ArrayObject::*sort*()` methods
    have been rewritten to achieve a stable sort. Let's have a look at a code example
    that illustrates the issue that may arise in earlier versions of PHP.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，核心的`*sort*()`函数和`ArrayObject::*sort*()`方法已经被重写以实现稳定排序。让我们看一个代码示例，说明在PHP的早期版本中可能出现的问题。
- en: Contrasting stable and non-stable sorting
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对比稳定和非稳定排序
- en: 'In this example, we wish to sort an array of `Access` instances by time. Each
    `Access` instance has two properties, `$name` and `$time`. The sample dataset
    contains duplicate access times, but with different usernames:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们希望按时间对`Access`实例的数组进行排序。每个`Access`实例有两个属性，`$name`和`$time`。样本数据集包含重复的访问时间，但用户名不同：
- en: 'First, we define the `Access` class:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义`Access`类：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we define a sample dataset that consists of a CSV file, `/repo/sample_data/access.csv`,
    with 21 rows. Each row represents a different name and access time combination:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个样本数据集，其中包含一个CSV文件，`/repo/sample_data/access.csv`，共有21行。每一行代表不同的姓名和访问时间的组合：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You will note, scanning the sample data, that all of the dates that have `11:11:11`
    as an entry time are duplicates, however, you will also note that the original
    order for any given date is always users `Fred`, `Betty`, `Barney`, and `Wilma`.
    Additionally, note that for dates with a time of `03:33:33`, entries for `Betty`
    always precede `Barney`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，扫描样本数据时，所有具有`11:11:11`作为入口时间的日期都是重复的，但是您还会注意到，任何给定日期的原始顺序始终是用户`Fred`，`Betty`，`Barney`和`Wilma`。另外，请注意，对于时间为`03:33:33`的日期，`Betty`的条目总是在`Barney`之前。
- en: 'We then define a calling program. The first thing to do in this program is
    to configure autoloading and `use` the `Access` class:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个调用程序。在这个程序中，首先要做的是配置自动加载和`use` `Access`类：
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we load the sample data into the `$access` array:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将样本数据加载到`$access`数组中：
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We then execute `usort()`. Note that the user-defined callback function performs
    a comparison of the `time` properties of each instance:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们执行`usort()`。请注意，用户定义的回调函数执行每个实例的`time`属性的比较：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we loop through the newly sorted array and display the result:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们循环遍历新排序的数组并显示结果：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In PHP 7, note that although the times are in order, the names do not reflect
    the expected order `Fred`, `Betty`, `Barney`, and `Wilma`. Here is the PHP 7 output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中，请注意虽然时间是有序的，但是姓名并不反映预期的顺序`Fred`，`Betty`，`Barney`和`Wilma`。以下是PHP 7的输出：
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see from the output, in the first set of `11:11:11` dates, the final
    order is `Fred`, `Wilma`, `Betty`, and `Barney`, whereas the original order of
    entry was `Fred`, `Betty`, `Barney`, and `Wilma`. You'll also notice that for
    the date and time `2021-06-13 03:33:33`, `Barney` precedes `Betty` whereas the
    original order of entry is the reverse. According to our definition, PHP 7 does
    not implement a stable sort!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，在第一组`11:11:11`日期中，最终顺序是`Fred`，`Wilma`，`Betty`和`Barney`，而原始的入口顺序是`Fred`，`Betty`，`Barney`和`Wilma`。您还会注意到，对于日期和时间`2021-06-13
    03:33:33`，`Barney`在`Betty`之前，而原始的入口顺序是相反的。根据我们的定义，PHP 7没有实现稳定排序！
- en: 'Let''s now have a look at the same code example running in PHP 8\. Here is
    the PHP 8 output:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下在PHP 8中运行相同代码示例的输出。以下是PHP 8的输出：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see from the PHP 8 output, for all of the `11:11:11` entries, the
    original order of entry `Fred`, `Betty`, `Barney`, and `Wilma` is respected. You'll
    also notice that for the date and time `2021-06-13 03:33:33`, `Betty` precedes
    `Barney` consistently. Thus, we can conclude that PHP 8 performs a stable sort.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从PHP 8的输出中可以看出，对于所有的`11:11:11`条目，原始的输入顺序`Fred`，`Betty`，`Barney`和`Wilma`都得到了尊重。您还会注意到，对于日期和时间`2021-06-13
    03:33:33`，`Betty`始终在`Barney`之前。因此，我们可以得出结论，PHP 8执行了稳定排序。
- en: Now that you can see the issue in PHP 7, and are now aware that PHP 8 addresses
    and resolves this issue, let's have a look at the effect on keys in stable sorting.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了PHP 7中的问题，并且现在知道了PHP 8如何解决这个问题，让我们来看看稳定排序对键的影响。
- en: Examining the effect of stable sorting on keys
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查稳定排序对键的影响
- en: 'The concept of stable sorting also affects key/value pairs when using `asort()`,
    `uasort()`, or the equivalent `ArrayIterator` methods. In the example shown next,
    `ArrayIterator` is populated with 20 elements, every other element being a duplicate.
    The key is a hexadecimal number that increments sequentially:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定排序的概念也影响使用`asort()`、`uasort()`或等效的`ArrayIterator`方法时的键/值对。在接下来展示的示例中，`ArrayIterator`被填充了20个元素，每隔一个元素是重复的。键是一个按顺序递增的十六进制数：
- en: 'First, we define a function to produce random 3-letter combinations:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个函数来生成随机的3个字母组合：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we load an `ArrayIterator` instance with sample data. Every other element
    is a duplicate. We also capture the starting time:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用示例数据加载了一个`ArrayIterator`实例。每隔一个元素是重复的。我们还记录了开始时间：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We then perform `ArrayIterator::asort()` and display the resulting order along
    with the elapsed time:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们执行`ArrayIterator::asort()`并显示结果的顺序以及经过的时间：
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is the result of this code example running in PHP 7:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PHP 7中运行此代码示例的结果：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you can see from the output, although the values are in order, in the case
    of duplicate values, the keys appear in chaotic order. In contrast, have a look
    at the output from the same program code running in PHP 8:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，尽管值是有序的，但在重复值的情况下，键是以混乱的顺序出现的。相比之下，看一下在PHP 8中运行相同程序代码的输出：
- en: '[PRE40]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output shows that the keys for any duplicate entries appear in the output
    in their original order. The output demonstrates that PHP 8 implements stable
    sorting for not only values but for keys as well. Further, as the elapsed time
    results show, PHP 8 has managed to retain the same (or better) performance as
    before. Let''s now turn our attention to another difference in PHP 8 that directly
    affects array sorting: the handling of illegal sort functions.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，任何重复条目的键都按照它们原始的顺序出现在输出中。输出表明，PHP 8不仅对值实现了稳定排序，而且对键也实现了稳定排序。此外，从经过的时间结果来看，PHP
    8已经成功地保持了与以前相同（或更好）的性能。现在让我们将注意力转向PHP 8中直接影响数组排序的另一个不同之处：处理非法排序函数。
- en: Handling illegal sort functions
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理非法排序函数
- en: PHP 7 and earlier allows developers to get away with an **illegal function**
    when using `usort()` or `uasort()` (or the equivalent `ArrayIterator` methods).
    It's extremely important for you to be aware of this bad practice. Otherwise,
    when you migrate your code to PHP 8, a potential backward-compatibility break
    exists.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7及更早版本允许开发人员在使用`usort()`或`uasort()`（或等效的`ArrayIterator`方法）时使用**非法函数**。您非常重要的是要意识到这种不良实践。否则，当您将代码迁移到PHP
    8时，可能存在潜在的向后兼容性问题。
- en: 'In the example shown next, the same array is created as in the example described
    in the *Contrasting stable and non-stable sorting* section. The *illegal* sort
    function returns a Boolean value, whereas the `u*sort()` callback needs to return
    the *relative position* between the two elements. In literal terms, the user-defined
    function, or callback, needs to return `-1` if the first operand is less than
    the second, `0` if equal, and `1` if the first operand is greater than the second.
    If we rewrite the line of code the defines the `usort()` callback, an illegal
    function might appear as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来展示的示例中，创建了与“对比稳定和非稳定排序”部分中描述的示例相同的数组。*非法*排序函数返回一个布尔值，而`u*sort()`回调需要返回两个元素之间的*相对位置*。从字面上讲，用户定义的函数或回调需要在第一个操作数小于第二个操作数时返回`-1`，相等时返回`0`，第一个操作数大于第二个操作数时返回`1`。如果我们重写定义`usort()`回调的代码行，一个非法函数可能如下所示：
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this code snippet, instead of using the spaceship operator (`<=>`), which
    would return `-1`, `0`, or `1`, we use a less-than symbol (`<`). In PHP 7 and
    below, a callback that returns a boolean return value is acceptable and produces
    the desired results. But what actually happens is that the PHP interpreter needs
    to add an additional operation to make up the missing operation. Thus, if the
    callback only performs this comparison:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，我们没有使用太空船操作符（`<=>`），而是使用了小于符号（`<`）。在PHP 7及更低版本中，返回布尔返回值的回调是可以接受的，并且会产生期望的结果。但实际发生的是，PHP解释器需要添加额外的操作来弥补缺失的操作。因此，如果回调只执行这个比较：
- en: '`op1 > op2`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`op1 > op2`'
- en: 'The PHP interpreter adds an additional operation:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: PHP解释器添加了一个额外的操作：
- en: '`op1 <= op2`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`op1 <= op2`'
- en: 'In PHP 8, illegal sort functions spawn a deprecation notice. Here is the rewritten
    code running in PHP 8:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，非法排序函数会产生一个弃用通知。以下是在PHP 8中运行的重写代码：
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see from the output, PHP 8 allows the operation to continue, and
    the results are consistent when using the proper callback. However, you can also
    see that a `Deprecation` notice is issued.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，PHP 8允许操作继续进行，并且在使用正确的回调时结果是一致的。但是，您还可以看到发出了一个`Deprecation`通知。
- en: Tip
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can also use the arrow function in PHP 8\. The callback shown previously
    might be rewritten as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在PHP 8中使用箭头函数。之前展示的回调可以重写如下：
- en: '`usort($array, fn($a, $b) => $a <=> $b)`.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`usort($array, fn($a, $b) => $a <=> $b)`。'
- en: You now have a greater understanding of what a stable sort is, and why it's
    important. You also are able to spot potential problems due to differences in
    handling between PHP 8 and earlier versions. We'll now have a look at other performance
    improvements introduced in PHP 8.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对稳定排序是什么以及为什么它很重要有了更深入的了解。您还能够发现由于PHP 8和早期版本之间处理差异而可能出现的潜在问题。现在我们将看一下PHP
    8中引入的其他性能改进。
- en: Using weak references to improve efficiency
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用弱引用来提高效率
- en: As PHP continues to grow and mature, more and more developers are turning to
    PHP frameworks to facilitate rapid application development. A necessary by-product
    of this practice, however, is ever larger and more complex objects occupying memory.
    Large objects that contain many properties, other objects, or sizeable arrays
    are often referred to as **expensive objects**.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 随着PHP的不断发展和成熟，越来越多的开发人员开始使用PHP框架来促进快速应用程序开发。然而，这种做法的一个必然副产品是占用内存的对象变得越来越大和复杂。包含许多属性、其他对象或大型数组的大对象通常被称为**昂贵的对象**。
- en: Compounding the potential memory issues caused by this trend is the fact that
    all PHP object assignments are automatically made by reference. Without references,
    the use of third-party frameworks would become cumbersome in the extreme. When
    you assign an object by reference, however, the object must remain in memory,
    in its entirety, until all references are destroyed. Only then, after unsetting
    or overwriting the object, is it entirely destroyed.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这种趋势引起的潜在内存问题的加剧是，所有 PHP 对象赋值都是自动通过引用进行的。没有引用，第三方框架的使用将变得非常麻烦。然而，当您通过引用分配一个对象时，对象必须保持在内存中，直到所有引用被销毁。只有在取消设置或覆盖对象之后，对象才会完全被销毁。
- en: In PHP 7.4, a potential solution to this problem was introduced in the form
    of weak reference support. PHP 8 expanded upon this new ability by adding a weak
    map class. In this section, you'll learn how this new technology works, and how
    it can prove advantageous to development. Let's first have a look at weak references.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 7.4 中，弱引用支持以解决这个问题的潜在解决方案首次引入。PHP 8 通过添加弱映射类扩展了这种新能力。在本节中，您将学习这项新技术的工作原理，以及它如何对开发有利。让我们先看看弱引用。
- en: Taking advantage of weak references
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用弱引用
- en: '**Weak references** were first introduced in PHP 7.4, and have been refined
    in PHP 8\. This class serves as a wrapper for object creation that allows the
    developer to use references to objects in such a manner whereby out-of-scope (for
    example, `unset()`) objects are not protected from garbage collection.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**弱引用** 首次在 PHP 7.4 中引入，并在 PHP 8 中得到改进。这个类作为对象创建的包装器，允许开发人员以一种方式使用对象的引用，使得超出范围（例如
    `unset()`）的对象不受垃圾回收的保护。'
- en: There are a number of PHP extensions currently residing on [pecl.php.net](http://pecl.php.net)
    that provide support for weak references. Most of the implementations hack into
    the C language structures of the PHP language core, and either overload object
    handlers, or manipulate the stack and various C pointers. The net result, in most
    cases, is a loss of portability and lots of segmentation faults. The PHP 8 implementation
    avoids these problems.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有许多 PHP 扩展驻留在 [pecl.php.net](http://pecl.php.net)，提供对弱引用的支持。大多数实现都是通过入侵 PHP
    语言核心的 C 语言结构，要么重载对象处理程序，要么操纵堆栈和各种 C 指针。在大多数情况下，结果是丧失可移植性和大量的分段错误。PHP 8 的实现避免了这些问题。
- en: It's important to master the use of PHP 8 weak references if you are working
    on program code that involves large objects and where the program code might run
    for a long time. Before getting into usage details, let's have a look at the class
    definition.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在处理涉及大型对象并且程序代码可能运行很长时间的程序代码，那么掌握 PHP 8 弱引用的使用是非常重要的。在深入使用细节之前，让我们先看一下类的定义。
- en: Reviewing the WeakReference class definition
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查 `WeakReference` 类的定义
- en: 'The formal definition for the `WeakReference` class is as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakReference` 类的正式定义如下：'
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, the class definition is quite simple. The class can be used
    to provide a wrapper around any object. The wrapper makes it easier to completely
    destroy an object without fear there may be a lingering reference causing the
    object to still reside in memory.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，类的定义非常简单。该类可用于提供任何对象的包装器。这个包装器使得完全销毁一个对象变得更容易，而不必担心可能会有残留的引用导致对象仍然驻留在内存中。
- en: Tip
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on the background and nature of weak references, have
    a look here: https://wiki.php.net/rfc/weakrefs. The documentation reference is
    here: [https://www.php.net/manual/en/class.weakreference.php](https://www.php.net/manual/en/class.weakreference.php).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 有关弱引用的背景和性质的更多信息，请查看这里：https://wiki.php.net/rfc/weakrefs。文档参考在这里：[https://www.php.net/manual/en/class.weakreference.php](https://www.php.net/manual/en/class.weakreference.php)。
- en: Let's now have a look at a simple example to help your understanding.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个简单的例子来帮助您理解。
- en: Using weak references
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用弱引用
- en: 'This example demonstrates how weak references could be used. You will see in
    this example that when a normal object assignment by reference is made, even if
    the original object is unset, it still remains loaded in memory. On the other
    hand, if you assign the object reference using `WeakReference`, once the original
    object is unset, it''s completely removed from memory:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了如何使用弱引用。您将在这个例子中看到，当通过引用进行普通对象赋值时，即使原始对象被取消设置，它仍然保留在内存中。另一方面，如果您使用 `WeakReference`
    分配对象引用，一旦原始对象被取消设置，它就会完全从内存中删除。
- en: 'First, we define four objects. Note that `$obj2` is a normal reference to `$obj1`,
    whereas `$obj4` is a weak reference to `$obj3`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了四个对象。请注意，`$obj2` 是对 `$obj1` 的普通引用，而 `$obj4` 是对 `$obj3` 的弱引用：
- en: '[PRE44]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We then display the contents of `$obj2` before and after `$obj1` is unset.
    Because the connection between `$obj1` and `$obj2` is a normal PHP reference,
    `$obj1` remains in memory due to the strong reference created:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们显示 `$obj1` 在取消设置之前和之后的 `$obj2` 的内容。由于 `$obj1` 和 `$obj2` 之间的连接是一个普通的 PHP
    引用，所以由于创建了强引用，`$obj1` 仍然保留在内存中：
- en: '[PRE45]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We then do the same for `$obj3` and `$obj4`. Note that we need to use `WeakReference::get()`
    to obtain the associated object. Once `$obj3` is unset, all information pertaining
    to both `$obj3` and `$obj4` is removed from memory:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们对 `$obj3` 和 `$obj4` 做同样的操作。请注意，我们需要使用 `WeakReference::get()` 来获取关联的对象。一旦取消设置了
    `$obj3`，与 `$obj3` 和 `$obj4` 相关的所有信息都将从内存中删除：
- en: '[PRE46]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here is the output from this code example running in PHP 8:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 PHP 8 中运行此代码示例的输出：
- en: '[PRE47]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The output tells us an interesting story! The second `var_dump()` operation
    shows us that even though `$obj1` has been unset, it still lives on like a zombie
    because of the strong reference created with `$obj2`. If you are dealing with
    expensive objects and complex application code, in order to free up memory, you'll
    need to first hunt down and destroy all the references before memory is freed!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 输出告诉我们一个有趣的故事！第二个 `var_dump()` 操作向我们展示了，即使 `$obj1` 已经取消设置，由于与 `$obj2` 创建的强引用，它仍然像僵尸一样存在。如果您正在处理昂贵的对象和复杂的应用程序代码，为了释放内存，您需要首先找到并销毁所有引用，然后才能释放内存！
- en: On the other hand, if you really need the memory, instead of making a direct
    object assignment, which in PHP is automatically by reference, create the reference
    using the `WeakReference::create()` method. A weak reference has all the power
    of a normal reference. The only difference is that if the object it refers to
    is destroyed or goes out of scope, the weak reference is automatically destroyed
    as well.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你真的需要内存，而不是直接进行对象赋值，在PHP中是自动引用的，可以使用`WeakReference::create()`方法创建引用。弱引用具有普通引用的所有功能。唯一的区别是，如果它引用的对象被销毁或超出范围，弱引用也会被自动销毁。
- en: As you can see from the output, the result of the last `var_dump()` operation
    was `NULL`. This tells us that the object has truly been destroyed. When the main
    object is unset, all of its weak references go away automatically. Now that you
    have an idea of how to use weak references, and the potential problem they solve,
    it's time to take a look at a new class, `WeakMap`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，最后一个`var_dump()`操作的结果是`NULL`。这告诉我们对象确实已经被销毁。当主对象取消引用时，它的所有弱引用也会自动消失。现在你已经了解了如何使用弱引用以及它们解决的潜在问题，是时候来看看一个新类`WeakMap`了。
- en: Working with WeakMap
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用WeakMap
- en: 'In PHP 8, a new class, `WeakMap`, has been added that leverages weak reference
    support. The new class is similar to `SplObjectStorage` in functionality. Here
    is the official class definition:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，添加了一个新类`WeakMap`，它利用了弱引用支持。这个新类在功能上类似于`SplObjectStorage`。以下是官方的类定义：
- en: '[PRE48]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Just like `SplObjectStorage`, this new class appears as an array of objects.
    Because it implements `IteratorAggregate`, you can use the `getIterator()` method,
    to gain access to the inner iterator. Thus, the new class offers not only traditional
    array access, but OOP iterator access as well, the best of both worlds! Before
    getting into the details of how to use `WeakMap`, it's important for you to understand
    typical usage for `SplObjectStorage`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`SplObjectStorage`一样，这个新类看起来像一个对象数组。因为它实现了`IteratorAggregate`，你可以使用`getIterator()`方法来访问内部迭代器。因此，这个新类不仅提供了传统的数组访问，还提供了面向对象的迭代器访问，两全其美！在深入了解如何使用`WeakMap`之前，你需要了解`SplObjectStorage`的典型用法。
- en: Implementing a container class using SplObjectStorage
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SplObjectStorage实现容器类
- en: A potential use for the `SplObjectStorage` class is to use it to form the basis
    of a **dependency injection** (**DI**) container (also referred to as a **service
    locator** or **inversion of control** container). DI container classes are designed
    to create and hold instances of objects for easy retrieval.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`SplObjectStorage`类的一个潜在用途是将其用作**依赖注入**（**DI**）容器的基础（也称为**服务定位器**或**控制反转**容器）。DI容器类旨在创建和保存对象实例，以便轻松检索。'
- en: 'In this example, we load a container class with an array of expensive objects
    drawn from the `Laminas\Filter\*` classes. We then use the container to sanitize
    sample data, after which we unset the array of filters:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用一个包含从`Laminas\Filter\*`类中提取的昂贵对象数组的容器类。然后我们使用容器来清理样本数据，之后我们取消过滤器数组：
- en: 'First, we define a container class based on `SplObjectStorage`. (Later, in
    the next section, we develop another container class that does the same thing
    and is based upon `WeakMap`.) Here is the `UsesSplObjectStorage` class. In the
    `__construct()` method, we attach configured filters to the `SplObjectStorage`
    instance:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们基于`SplObjectStorage`定义一个容器类。（稍后，在下一节中，我们将开发另一个执行相同功能并基于`WeakMap`的容器类。）这是`UsesSplObjectStorage`类。在`__construct()`方法中，我们将配置的过滤器附加到`SplObjectStorage`实例：
- en: '[PRE49]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We then define a `get()` method that iterates through the `SplObjectStorage`
    container and returns the filter if found. If not found, a default class that
    simply passes the data straight through is returned:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个`get()`方法，遍历`SplObjectStorage`容器并返回找到的过滤器。如果找不到，则返回一个简单地将数据直接传递的默认类：
- en: '[PRE50]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that when using a `foreach()` loop to iterate a `SplObjectStorage` instance,
    we return the *value* (`$obj`), not the key. If we're using a `WeakMap` instance,
    on the other hand, we need to return the *key* and not the value!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当使用`foreach()`循环来迭代`SplObjectStorage`实例时，我们返回*值*（`$obj`），而不是键。另一方面，如果我们使用`WeakMap`实例，我们需要返回*键*而不是值！
- en: 'We then define a calling program that uses our newly created `UsesSplObjectStorage`
    class to contain the filter set:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个调用程序，使用我们新创建的`UsesSplObjectStorage`类来包含过滤器集：
- en: 'First, we define autoloading and use the appropriate classes:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义自动加载并使用适当的类：
- en: '[PRE51]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we define an array of sample data:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个样本数据数组：
- en: '[PRE52]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We then assign filters that are required for all fields (`$required`) and filters
    specific to certain fields (`$added`):'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们分配了对所有字段（`$required`）和对某些字段特定的过滤器（`$added`）：
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After that, we create an array of filter instances, used to populate our service
    container, `UseSplObjectStorage`. Please bear in mind that each filter class carries
    a lot of overhead and can be considered an *expensive* object:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们创建一个过滤器实例数组，用于填充我们的服务容器`UseSplObjectStorage`。请记住，每个过滤器类都带有很大的开销，可以被认为是一个*昂贵*的对象：
- en: '[PRE54]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We now cycle through the data files using our container class to retrieve filter
    instances. The `filter()` method produces a sanitized value specific to that filter:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用我们的容器类循环遍历数据文件，以检索过滤器实例。`filter()`方法会产生特定于该过滤器的经过清理的值：
- en: '[PRE55]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we grab memory statistics to form the basis of comparison between
    `SplObjectStorage` and `WeakMap` usage. We also unset `$filters`, which should
    theoretically release a sizeable amount of memory. We run `gc_collect_cycles()`
    to force the PHP garbage collection process, releasing freed memory back into
    the pool:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们获取内存统计信息，以便比较`SplObjectStorage`和`WeakMap`的使用情况。我们还取消了`$filters`，理论上应该释放大量内存。我们运行`gc_collect_cycles()`来强制PHP垃圾回收过程，将释放的内存重新放入池中。
- en: '[PRE56]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here is the result, running in PHP 8, of the calling program just shown:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在PHP 8中运行的调用程序的结果：
- en: '[PRE57]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As you can see from the output, our container class works perfectly, giving
    us access to any of the stored filter classes. What is also of interest is that
    the memory released following the `unset($filters)` command is `264` bytes: not
    very much!'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，我们的容器类完美地工作，让我们可以访问存储的任何过滤器类。另一个有趣的地方是，在执行`unset($filters)`命令后释放的内存是`264`字节：并不多！
- en: You now have an idea of the typical usage of the `SplObjectStorage` class. Let's
    now have a look at a potential problem with the `SplObjectStorage` class, and
    how `WeakMap` solves it.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了`SplObjectStorage`类的典型用法。现在让我们来看看`SplObjectStorage`类可能存在的问题，以及`WeakMap`是如何解决的。
- en: Understanding the benefits of WeakMap over SplObjectStorage
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解WeakMap相对于SplObjectStorage的优势
- en: The main problem with `SplObjectStorage` is that when an assigned object gets
    unset or otherwise goes out of scope, it still remains in memory. The reason for
    this is when the object is attached to the `SplObjectStorage` instance, it's done
    by reference.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`SplObjectStorage`的主要问题是，当分配的对象被取消分配或者超出范围时，它仍然保留在内存中。原因是当对象附加到`SplObjectStorage`实例时，是通过引用进行的。'
- en: If you're only dealing with a small number of objects, you'll probably not experience
    any serious issues. If you use `SplObjectStorage` and assign a large number of
    expensive objects for storage, this could eventually cause memory leaks in long-running
    programs. If, on the other hand, you use a `WeakMap` instance for storage, garbage
    collection is allowed to remove the object, which in turn frees up memory. When
    you start to integrate `WeakMap` instances into your regular programming practice,
    you end up with more efficient code that takes up much less memory.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只处理少量对象，可能不会遇到严重的问题。如果你使用`SplObjectStorage`并为存储分配大量昂贵的对象，这可能最终会导致长时间运行的程序内存泄漏。另一方面，如果你使用`WeakMap`实例进行存储，垃圾回收可以移除对象，从而释放内存。当你开始将`WeakMap`实例整合到你的常规编程实践中时，你会得到更高效的代码，占用更少的内存。
- en: Tip
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information about `WeakMap`, have a look at the original RFC here:
    https://wiki.php.net/rfc/weak_maps. Also have a look at the documentation: https://www.php.net/weakMap.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`WeakMap`的更多信息，请查看原始RFC：https://wiki.php.net/rfc/weak_maps。还请查看文档：https://www.php.net/weakMap。
- en: 'Let''s now rewrite the example from the previous section (`/repo/ch010/php7_weak_map_problem.php`),
    but this time using `WeakMap`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重新编写前一节的示例(`/repo/ch010/php7_weak_map_problem.php`)，但这次使用`WeakMap`：
- en: 'As described in the previous code example, we define a container class called
    `UsesWeakMap` that holds our expensive filter classes. The main difference between
    this class and the one shown in the previous section is that `UsesWeakMap` uses
    `WeakMap` instead of `SplObjectStorage` for storage. Here is the class setup and
    `__construct()` method:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前面的代码示例所述，我们定义了一个名为`UsesWeakMap`的容器类，其中包含我们昂贵的过滤器类。这个类和前一节中显示的类的主要区别在于`UsesWeakMap`使用`WeakMap`而不是`SplObjectStorage`进行存储。以下是类设置和`__construct()`方法：
- en: '[PRE58]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Another difference between the two classes is that `WeakMap` implements `IteratorAggregate`.
    However, this still allows us to use a simple `foreach()` loop in the `get()`
    method:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个类之间的另一个区别是`WeakMap`实现了`IteratorAggregate`。然而，这仍然允许我们在`get()`方法中使用简单的`foreach()`循环：
- en: '[PRE59]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that when using a `foreach()` loop to iterate a `WeakMap` instance, we
    return the *key* (`$idx`) and not the value!
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当使用`foreach()`循环来迭代`WeakMap`实例时，我们返回的是*键*(`$idx`)，而不是值！
- en: 'We then define a calling program that invokes the autoloader and uses the appropriate
    filter classes. The biggest difference between this calling program and the one
    from the previous section is that we use our new container class that''s based
    upon `WeakMap`:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个调用程序，调用自动加载程序并使用适当的过滤器类。这个调用程序和上一节的程序最大的区别在于我们使用基于`WeakMap`的新容器类：
- en: '[PRE60]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As in the previous example, we define an array of sample data and assign filters.
    This code is not shown as it's identical to *steps 2* and *3* of the previous
    example.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与前一个示例一样，我们定义了一个样本数据数组并分配过滤器。这段代码没有显示，因为它与前一个示例的*步骤2*和*3*相同。
- en: 'We then create filter instances in an array that serves as an argument to our
    new container class. We use the array of filters as an argument to create the
    container class instance:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在一个数组中创建过滤器实例，该数组作为参数传递给我们的新容器类。我们使用过滤器数组作为参数来创建容器类实例：
- en: '[PRE61]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Finally, exactly as shown in *step 6* from the previous example, we cycle through
    the data and apply filters from the container class. We also collect and display
    memory statistics.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，就像前一个示例中的*步骤6*一样，我们循环遍历数据并应用容器类中的过滤器。我们还收集并显示内存统计信息。
- en: 'Here is the output, running in PHP 8, for the revised program using `WeakMap`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在PHP 8中运行的输出，使用`WeakMap`进行修订的程序：
- en: '[PRE62]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you might expect, overall memory usage is slightly lower. The biggest difference,
    however, is the difference in memory after unsetting `$filters`. In the previous
    example, the difference was `264` bytes. In this example, using `WeakMap` produced
    a difference of `800` bytes. This means that using `WeakMap` has the potential
    to free up more than three times the amount of memory compared with using `SplObjectStorage`!
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的，总体内存使用略低。然而，最大的区别在于取消分配`$filters`后的内存差异。在前一个示例中，差异是`264`字节。而在这个示例中，使用`WeakMap`产生了`800`字节的差异。这意味着使用`WeakMap`有可能释放的内存量是使用`SplObjectStorage`的三倍以上！
- en: This ends our discussion of weak references and weak maps. You are now in a
    position to write code that is more efficient and uses less memory. The larger
    the objects being stored, the greater the potential for memory saving.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对弱引用和弱映射的讨论。现在你可以编写更高效、占用更少内存的代码了。存储的对象越大，节省的内存就越多。
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned not only how the new JIT compiler works, but you
    gained an understanding of the traditional PHP interpret-compile-execute cycle.
    Using PHP 8 and enabling the JIT compiler has the potential to speed up your PHP
    application anywhere from three times faster and up.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您不仅了解了新的JIT编译器的工作原理，还了解了传统的PHP解释-编译-执行循环。使用PHP 8并启用JIT编译器有可能将您的PHP应用程序加速三倍以上。
- en: In the next section, you learned what a stable sort is, and how PHP 8 implements
    this vital technology. By mastering the stable sort, your code will produce data
    in a rational manner, resulting in greater customer satisfaction.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将了解什么是稳定排序，以及PHP 8如何实现这一重要技术。通过掌握稳定排序，您的代码将以一种理性的方式产生数据，从而带来更大的客户满意度。
- en: The section following introduced you to a technique that can vastly improve
    performance and reduce memory consumption by taking advantage of the `SplFixedArray`
    class. After that, you learned about PHP 8 support for weak references as well
    as the new `WeakMap` class. Using the techniques covered in this chapter will
    cause your applications to execute much quicker, run more efficiently, and use
    less memory.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分介绍了一种可以通过利用`SplFixedArray`类大大提高性能并减少内存消耗的技术。之后，您还了解了PHP 8对弱引用的支持以及新的`WeakMap`类。使用本章涵盖的技术将使您的应用程序执行速度更快，运行更高效，并且使用更少的内存。
- en: In the next chapter, you'll learn how to perform a successful migration to PHP
    8.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何成功迁移到PHP 8。
