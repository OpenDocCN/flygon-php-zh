- en: Chapter 7. Accessing Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。访问Web服务
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Converting between PHP and XML
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PHP和XML之间进行转换
- en: Creating a simple REST client
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的REST客户端
- en: Creating a simple REST server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的REST服务器
- en: Creating a simple SOAP client
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的SOAP客户端
- en: Creating a simple SOAP server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的SOAP服务器
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Making background queries to external web services is becoming an ever-increasing
    part of any PHP web practice. The ability to provide appropriate, timely, and
    plentiful data means more business for your customers and the websites you develop.
    We start with a couple of recipes aimed at data conversion between **eXtensible
    Markup Language** (**XML**) and native PHP. Next, we show you how to implement
    a simple **Representational State Transfer** (**REST**) client and server. After
    that, we turn our attention to **SOAP** clients and servers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 向外部Web服务进行后台查询正成为任何PHP Web实践的日益重要的一部分。提供适当、及时和丰富的数据意味着为您的客户和您开发的网站带来更多的业务。我们首先介绍了一些旨在在**可扩展标记语言**（**XML**）和本机PHP之间进行数据转换的配方。接下来，我们将向您展示如何实现一个简单的**表述状态转移**（**REST**）客户端和服务器。之后，我们将把注意力转向**SOAP**客户端和服务器。
- en: Converting between PHP and XML
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PHP和XML之间进行转换
- en: When considering a conversion between PHP native data types and XML, we would
    normally consider an array as the primary target. With this in mind, the process
    of converting from a PHP array to XML differs radically from the approach needed
    to do the reverse.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑PHP本机数据类型和XML之间的转换时，我们通常将数组视为主要目标。基于此，从PHP数组转换为XML的过程与需要执行相反操作的方法有很大的不同。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Objects could also be considered for conversion; however, it is difficult to
    render object methods in XML. Properties can be represented, however, by using
    the `get_object_vars()` function, which reads object properties into an array.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对象也可以考虑进行转换；然而，将对象方法呈现为XML是困难的。属性可以通过使用`get_object_vars()`函数来表示，该函数将对象属性读入数组中。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we define an `Application\Parse\ConvertXml` class. This class will holdthe
    methods that will convert from XML to a PHP array, and vice versa. We will need
    both the `SimpleXMLElement` and `SimpleXMLIterator` classes from the SPL:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个`Application\Parse\ConvertXml`类。这个类将包含将从XML转换为PHP数组，反之亦然的方法。我们将需要SPL中的`SimpleXMLElement`和`SimpleXMLIterator`类：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we define a `xmlToArray()` method that will accept a `SimpleXMLIterator`
    instance as an argument. It will be called recursively and will produce a PHP
    array from an XML document. We take advantage of the `SimpleXMLIterator` ability
    to advance through the XML document, using the `key()`, `current()`, `next()`,
    and `rewind()` methods to navigate:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`xmlToArray()`方法，它将接受一个`SimpleXMLIterator`实例作为参数。它将被递归调用，并将从XML文档生成一个PHP数组。我们利用`SimpleXMLIterator`能够通过XML文档前进的能力，使用`key()`、`current()`、`next()`和`rewind()`方法进行导航：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For the reverse process, also called recursively, we define two methods. The
    first method, `arrayToXml()`, sets up an initial `SimpleXMLElement` instance,
    and then calls the second method, `phpToXml()`:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于相反的过程，也称为递归，我们定义了两种方法。第一种方法`arrayToXml()`设置了一个初始的`SimpleXMLElement`实例，然后调用第二种方法`phpToXml()`：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that in the second method, we use `get_object_vars()` in case one of the
    array elements is an object. You''ll also note that numbers alone are not allowed
    as XML tags, which means adding some text in front of the number:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，在第二种方法中，我们使用`get_object_vars()`，以防数组元素是对象。您还会注意到，单独的数字不允许作为XML标签，这意味着在数字前面添加一些文本：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As a sample XML document, you can use the **Web Services Definition Language**
    (**WSDL**) for the United States National Weather Service. This is an XML document
    that describes a SOAP service, and can be found at [http://graphical.weather.gov/xml/SOAP_server/ndfdXMLserver.php?wsdl](http://graphical.weather.gov/xml/SOAP_server/ndfdXMLserver.php?wsdl).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个示例XML文档，您可以使用美国国家气象局的**Web服务定义语言**（**WSDL**）。这是一个描述SOAP服务的XML文档，可以在[http://graphical.weather.gov/xml/SOAP_server/ndfdXMLserver.php?wsdl](http://graphical.weather.gov/xml/SOAP_server/ndfdXMLserver.php?wsdl)找到。
- en: 'We will use the `SimpleXMLIterator` class to provide an iteration mechanism.
    You can then configure autoloading, and get an instance of `Application\Parse\ConvertXml`,
    using `xmlToArray()` to convert the WSDL to a PHP array:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`SimpleXMLIterator`类来提供迭代机制。然后，您可以配置自动加载，并使用`xmlToArray()`获取`Application\Parse\ConvertXml`的实例，将WSDL转换为PHP数组：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The resulting array is shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 结果数组显示如下：
- en: '![How it works...](graphics/B05314_07_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_07_01.jpg)'
- en: 'To do the reverse, use the `arrayToXml()` method described in this recipe.
    As a source document, you can use a `source/data/mongo.db.global.php` file that
    contains an outline for a training video on MongoDB available through O''Reilly
    Media (disclaimer: by this author!). Using the same autoloader configuration and
    instance of `Application\Parse\ConvertXml`, here is the sample code you could
    use:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行相反的操作，请使用本配方中描述的`arrayToXml()`方法。作为源文档，您可以使用一个包含通过O'Reilly Media提供的MongoDB培训视频大纲的`source/data/mongo.db.global.php`文件（免责声明：由本作者提供！）。使用相同的自动加载程序配置和`Application\Parse\ConvertXml`的实例，这是您可以使用的示例代码：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is the output in a browser:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在浏览器中的输出：
- en: '![How it works...](graphics/B05314_07_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_07_02.jpg)'
- en: Creating a simple REST client
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的REST客户端
- en: REST clients use **HyperText Transfer Protocol** (**HTTP**) to generate requests
    to external web services. By changing the HTTP method, we can cause the external
    service to perform different operations. Although there are quite a few methods
    (or verbs) available, we will only focus on `GET` and `POST`. In this recipe,
    we will use the **Adapter** software design pattern to present two different ways
    of implementing a REST client.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: REST客户端使用**超文本传输协议**（**HTTP**）向外部Web服务生成请求。通过更改HTTP方法，我们可以导致外部服务执行不同的操作。虽然有很多可用的方法（或动词），但我们只关注`GET`和`POST`。在这个配方中，我们将使用**适配器**软件设计模式来呈现实现REST客户端的两种不同方式。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Before we can define REST client adapters, we need to define common classes
    to represent request and response information. First, we will start with an abstract
    class that has methods and properties needed for either a request or response:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们定义REST客户端适配器之前，我们需要定义用于表示请求和响应信息的通用类。首先，我们将从一个抽象类开始，该类具有请求或响应所需的方法和属性：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we define class constants that represent HTTP information:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义代表HTTP信息的类常量：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then define properties that are needed for either a request or a response:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了请求或响应所需的属性：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It logically follows to define getters and setters for these properties:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逻辑上，我们需要为这些属性定义getter和setter：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Some properties require access by key. For this purpose, we define `getXxxByKey()`
    and `setXxxByKey()` methods:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有些属性需要通过键访问。为此，我们定义了`getXxxByKey()`和`setXxxByKey()`方法：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In some cases, the request will require parameters. We will assume that the
    parameters will be in the form of a PHP array stored in the `$data` property.
    We can then build the request URL using the `http_build_query()` function:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在某些情况下，请求将需要参数。我们假设参数将以PHP数组的形式存储在`$data`属性中。然后我们可以使用`http_build_query()`函数构建请求URL：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we set `$transport` based on the original request:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们根据原始请求设置`$transport`：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this recipe, we will define a `Application\Web\Request` class that can accept
    parameters when we wish to generate a request, or, alternatively, populate properties
    with incoming request information when implementing a server that accepts requests:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将定义一个`Application\Web\Request`类，当我们希望生成一个请求时，可以接受参数，或者在实现接受请求的服务器时，可以填充属性与传入的请求信息：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can turn our attention to a response class. In this case, we will define
    an `Application\Web\Received` class. The name reflects the fact that we are re-packaging
    data received from the external web service:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以转向响应类。在这种情况下，我们将定义一个`Application\Web\Received`类。这个名称反映了我们正在重新打包从外部网络服务接收到的数据的事实：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating a streams-based REST client
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建基于流的REST客户端
- en: 'We are now ready to consider two different ways to implement a REST client.
    The first approach is to use an underlying PHP I/O layer referred to as **Streams**.
    This layer provides a series of wrappers that provide access to external streaming
    resources. By default, any of the PHP file commands will use the file wrapper,
    which gives access to the local filesystem. We will use the `http://` or `https://`
    wrappers to implement the `Application\Web\Client\Streams` adapter:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备考虑两种不同的实现REST客户端的方式。第一种方法是使用一个称为**Streams**的底层PHP I/O层。这一层提供了一系列包装器，用于访问外部流资源。默认情况下，任何PHP文件命令都将使用文件包装器，这使得可以访问本地文件系统。我们将使用`http://`或`https://`包装器来实现`Application\Web\Client\Streams`适配器：
- en: 'First, we define a `Application\Web\Client\Streams` class:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个`Application\Web\Client\Streams`类：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we define a method to send the request to the external web service. In
    the case of `GET`, we add the parameters to the URI. In the case of `POST`, we
    create a stream context that contains metadata instructing the remote service
    that we are supplying data. Using PHP Streams, making a request is just a matter
    of composing the URI, and, in the case of `POST`, setting the stream context.
    We then use a simple `fopen()`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个方法来将请求发送到外部网络服务。在`GET`的情况下，我们将参数添加到URI中。在`POST`的情况下，我们创建一个包含元数据的流上下文，指示远程服务我们正在提供数据。使用PHP
    Streams，发出请求只是简单地组合URI，在`POST`的情况下设置流上下文。然后我们使用一个简单的`fopen()`：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we have a look at retrieving and packaging results into a `Received`
    object. You will notice that we added a provision to decode data received in JSON
    format:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将看一下如何将结果检索并打包成一个`Received`对象。您会注意到我们添加了一个解码以JSON格式接收数据的规定：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Defining a cURL-based REST client
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义基于cURL的REST客户端
- en: 'We will now have a look at our second approach for a REST client, one of which
    is based on the cURL extension:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看一下我们的第二种REST客户端的方法，其中之一是基于cURL扩展的：
- en: 'For this approach, we will assume the same request and response classes. The
    initial class definition is much the same as for the Streams client discussed
    previously:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这种方法，我们将假设相同的请求和响应类。初始类定义与之前讨论的Streams客户端基本相同：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `send()` method is quite a bit simpler than when using Streams. All we
    need to do is to define an array of options, and let cURL do the rest:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`send()`方法比使用Streams时要简单得多。我们所需要做的就是定义一个选项数组，然后让cURL来处理剩下的事情：'
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`POST` requires slightly different cURL parameters:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST`需要稍有不同的cURL参数：'
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then execute a series of cURL functions and run the results through `getResults()`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们执行一系列cURL函数，并通过`getResults()`运行结果：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `getResults()` method packages results into a `Received` object:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getResults()`方法将结果打包成一个`Received`对象：'
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Be sure to copy all the preceding code into these classes:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将所有前面的代码复制到这些类中：
- en: '`Application\Web\AbstractHttp`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Web\AbstractHttp`'
- en: '`Application\Web\Request`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Web\Request`'
- en: '`Application\Web\Received`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Web\Received`'
- en: '`Application\Web\Client\Streams`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Web\Client\Streams`'
- en: '`Application\Web\Client\Curl`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Web\Client\Curl`'
- en: For this illustration, you can make a REST request to the Google Maps API to
    obtain driving directions between two points. You also need to create an API key
    for this purpose by following the directions given at [https://developers.google.com/maps/documentation/directions/get-api-key](https://developers.google.com/maps/documentation/directions/get-api-key).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您可以向Google Maps API发出REST请求，以获取两个点之间的驾驶路线。您还需要按照[https://developers.google.com/maps/documentation/directions/get-api-key](https://developers.google.com/maps/documentation/directions/get-api-key)上的说明创建一个API密钥。
- en: 'You can then define a `chap_07_simple_rest_client_google_maps_curl.php` calling
    script that issues a request using the `Curl` client. You might also consider
    define a `chap_07_simple_rest_client_google_maps_streams.php` calling script that
    issues a request using the `Streams` client:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以定义一个`chap_07_simple_rest_client_google_maps_curl.php`调用脚本，使用`Curl`客户端发出请求。您还可以考虑定义一个`chap_07_simple_rest_client_google_maps_streams.php`调用脚本，使用`Streams`客户端发出请求：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can then get the origin and destination:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以获取起点和目的地：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You are now in a position to populate the `Request` object, and use it to generate
    the request:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以填充`Request`对象，并使用它来生成请求：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For the purposes of illustration, you could also define a template that represents
    view logic to display the results of the request:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明的目的，您还可以定义一个表示视图逻辑的模板，以显示请求结果：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here are the results of the request as seen in a browser:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在浏览器中看到的请求结果：
- en: '![How it works...](graphics/B05314_07_03.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_07_03.jpg)'
- en: There's more...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '**PHP Standards Recommendations** (**PSR-7**) precisely defines request and
    response objects to be used when making requests between PHP applications. This
    is covered extensively in [Appendix](apa.html "Appendix A. Defining PSR-7 Classes"),
    *Defining PSR-7 Classes* .'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**PHP标准建议**（**PSR-7**）精确地定义了在PHP应用程序之间进行请求时要使用的请求和响应对象。这在[附录](apa.html "附录 A. 定义PSR-7类")中有详细介绍，*定义PSR-7类*。'
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information on `Streams`, see this PHP documentation page [http://php.net/manual/en/book.stream.php](http://php.net/manual/en/book.stream.php).
    An often asked question is "what is the difference between HTTP PUT and POST?"
    for an excellent discussion on this topic please refer to [http://stackoverflow.com/questions/107390/whats-the-difference-between-a-post-and-a-put-http-request](http://stackoverflow.com/questions/107390/whats-the-difference-between-a-post-and-a-put-http-request).
    For more information on obtaining an API key from Google, please refer to these
    web pages:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`Streams`的更多信息，请参阅此PHP文档页面[http://php.net/manual/en/book.stream.php](http://php.net/manual/en/book.stream.php)。一个经常被问到的问题是“HTTP
    PUT和POST之间有什么区别？”关于这个话题的优秀讨论，请参考[http://stackoverflow.com/questions/107390/whats-the-difference-between-a-post-and-a-put-http-request](http://stackoverflow.com/questions/107390/whats-the-difference-between-a-post-and-a-put-http-request)。有关从Google获取API密钥的更多信息，请参考以下网页：
- en: '[https://developers.google.com/maps/documentation/directions/get-api-key](https://developers.google.com/maps/documentation/directions/get-api-key)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/maps/documentation/directions/get-api-key](https://developers.google.com/maps/documentation/directions/get-api-key)'
- en: '[https://developers.google.com/maps/documentation/directions/intro#Introduction](https://developers.google.com/maps/documentation/directions/intro#Introduction)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/maps/documentation/directions/intro#Introduction](https://developers.google.com/maps/documentation/directions/intro#Introduction)'
- en: Creating a simple REST server
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的REST服务器
- en: 'There are several considerations when implementing a REST server. The answers
    to these three questions will then let you define your REST service:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现REST服务器时有几个考虑因素。回答这三个问题将让您定义REST服务：
- en: How is the raw request captured?
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何捕获原始请求？
- en: What **Application Programming Interface** (**API**) do you want to publish?
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想要发布什么**应用程序编程接口**（**API**）？
- en: How do you plan to map HTTP verbs (for example, `GET`, `PUT`, `POST`, and `DELETE`)
    to API methods?
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您打算如何将HTTP动词（例如`GET`、`PUT`、`POST`和`DELETE`）映射到API方法？
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will implement our REST server by building onto the request and response
    classes defined in the previous recipe, *Creating a simple REST client*. Review
    the classes discussed in the previous recipe, including the following:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过构建在前一篇文章*创建一个简单的REST客户端*中定义的请求和响应类来实现我们的REST服务器。回顾前一篇文章中讨论的类，包括以下内容：
- en: '`Application\Web\AbstractHttp`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Web\AbstractHttp`'
- en: '`Application\Web\Request`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Web\Request`'
- en: '`Application\Web\Received`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Web\Received`'
- en: 'We will also need to define a formal `Application\Web\Response` response class,
    based on `AbstractHttp`. The primary difference between this class and the others
    is that it accepts an instance of `Application\Web\Request` as an argument. The
    primary work is accomplished in the `__construct()` method. It''s also important
    to set the `Content-Type` header and status:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要定义一个正式的`Application\Web\Response`响应类，基于`AbstractHttp`。这个类与其他类的主要区别在于它接受`Application\Web\Request`的实例作为参数。主要工作是在`__construct()`方法中完成的。设置`Content-Type`标头和状态也很重要：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We are now in a position to define the `Application\Web\Rest\Server` class.
    You may be surprised at how simple it is. The real work is done in the associated
    API class:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以定义`Application\Web\Rest\Server`类。您可能会对它有多简单感到惊讶。真正的工作是在相关的API类中完成的：
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note the use of the PHP 7 group use syntax:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意PHP 7组使用语法的使用：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we define a `listen()` method that serves as a target for the request.
    The heart of the server implementation is this line of code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`listen()`方法，作为请求的目标。服务器实现的核心是这行代码：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This captures raw input, which is assumed to be in JSON format:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这捕获了假定为JSON格式的原始输入：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We have also added a provision for authentication. Otherwise, anybody could
    make requests and obtain potentially sensitive data. You will note that we do
    not have the server class performing authentication; rather, we leave it to the
    API class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了身份验证的规定。否则，任何人都可以发出请求并获取潜在的敏感数据。您会注意到我们没有服务器类执行身份验证；相反，我们把它留给API类：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We then map API methods to the primary HTTP methods `GET`, `PUT`, `POST`,and
    `DELETE`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将API方法映射到主要的HTTP方法`GET`、`PUT`、`POST`和`DELETE`：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we package the response and send it out, JSON-encoded:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们打包响应并发送它，以JSON编码：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `processResponse()` method sets headers and makes sure the result is packaged
    as an `Application\Web\Response` object:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`processResponse()`方法设置标头，并确保结果打包为`Application\Web\Response`对象：'
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As mentioned earlier, the real work is done by the API class. We start by defining
    an abstract class that ensures the primary methods `get()`, `put()`, and so on
    are represented, and that all such methods accept request and response objects
    as arguments. You might notice that we have added a `generateToken()` method that
    uses the PHP 7 `random_bytes()` function to generate a truly random series of
    16 bytes:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，API类完成了真正的工作。我们首先定义一个抽象类，确保主要方法`get()`，`put()`等都有对应的实现，并且所有这些方法都接受请求和响应对象作为参数。您可能会注意到我们添加了一个`generateToken()`方法，它使用PHP
    7的`random_bytes()`函数生成一个真正随机的16字节序列：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We also define a corresponding interface that can be used for architectural
    and design purposes, as well as code development control:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还定义了一个相应的接口，可用于架构和设计目的，以及代码开发控制：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, we present a sample API based on `AbstractApi`. This class leverages
    database classes defined in [Chapter 5](ch05.html "Chapter 5. Interacting with
    a Database"), *Interacting with a Database*:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们提供了一个基于`AbstractApi`的示例API。这个类利用了在[第5章](ch05.html "第5章。与数据库交互")中定义的数据库类，*与数据库交互*：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'All methods receive request and response as arguments. You will notice the
    use of `getDataByKey()` to retrieve data items. The actual database interaction
    is performed by the service class. You might also notice that in all cases, we
    set an HTTP status code to inform the client of success or failure. In the case
    of `get()`, we look for an ID parameter. If received, we deliver information on
    a single customer only. Otherwise, we deliver a list of all customers using limit
    and offset:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有方法都接收请求和响应作为参数。您会注意到使用`getDataByKey()`来检索数据项。实际的数据库交互是由服务类执行的。您可能还会注意到，在所有情况下，我们都设置了HTTP状态码来通知客户端成功或失败。在`get()`的情况下，我们会查找ID参数。如果收到，我们只提供有关单个客户的信息。否则，我们使用限制和偏移量提供所有客户的列表：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `put()` method is used to insert customer data:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`put()`方法用于插入客户数据：'
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `post()` method is used to update existing customer entries:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`post()`方法用于更新现有的客户条目：'
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As the name implies, `delete()` removes a customer entry:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如其名称所示，`delete()`会删除客户条目：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we define `authenticate()` to provide, in this example, a low-level
    mechanism to protect API usage:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义`authenticate()`来提供一个低级机制来保护API使用，例如在这个例子中：
- en: '[PRE43]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Define the following classes, which were discussed in the previous recipe:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 定义以下在前面的教程中讨论的类：
- en: '`Application\Web\AbstractHttp`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Web\AbstractHttp`'
- en: '`Application\Web\Request`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Web\Request`'
- en: '`Application\Web\Received`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Web\Received`'
- en: 'You can then define the following classes, described in this recipe, summarized
    in this table:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以定义以下在本教程中描述的类，总结在下表中：
- en: '| Class Application\Web\* | Discussed in these steps |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 类Application\Web\* | 在这些步骤中讨论 |'
- en: '| --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Response` | 2 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `Response` | 2 |'
- en: '| `Rest\Server` | 3 - 8 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `Rest\Server` | 3 - 8 |'
- en: '| `Rest\AbstractApi` | 9 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `Rest\AbstractApi` | 9 |'
- en: '| `Rest\ApiInterface` | 10 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `Rest\ApiInterface` | 10 |'
- en: '| `Rest\CustomerApi` | 11 - 16 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `Rest\CustomerApi` | 11 - 16 |'
- en: 'You are now free to develop your own API class. If you choose to follow the
    illustration `Application\Web\Rest\CustomerApi`, however, you will need to also
    be sure to implement these classes, covered in [Chapter 5](ch05.html "Chapter 5. Interacting
    with a Database"), *Interacting with a Database*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以自由开发自己的API类。但是，如果您选择遵循示例`Application\Web\Rest\CustomerApi`，您还需要确保实现这些类，这些类在[第5章](ch05.html
    "第5章。与数据库交互")中有介绍，*与数据库交互*：
- en: '`Application\Entity\Customer`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Entity\Customer`'
- en: '`Application\Database\Connection`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Database\Connection`'
- en: '`Application\Database\CustomerService`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Database\CustomerService`'
- en: 'You can now define a `chap_07_simple_rest_server.php` script that invokes the
    REST server:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以定义一个`chap_07_simple_rest_server.php`脚本来调用REST服务器：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can then use the built-in PHP 7 development server to listen on port `8080`
    for REST requests:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用内置的PHP 7开发服务器来监听端口`8080`以接收REST请求：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To test your API, use the `Application\Web\Rest\AbstractApi::generateToken()`
    method to generate an authentication token that you can place in an `api_key.php`
    file, something like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试您的API，可以使用`Application\Web\Rest\AbstractApi::generateToken()`方法生成一个认证令牌，然后将其放入一个`api_key.php`文件中，类似于这样：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can then use a generic API client (such as the one described in the previous
    recipe), or a browser plugin such as RESTClient by Chao Zhou (see [http://restclient.net/](http://restclient.net/)
    for more information) to generate sample requests. Make sure you include the token
    for your request, otherwise the API as defined will reject the request.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用通用的API客户端（例如前面介绍的那种）或浏览器插件，比如Chao Zhou的RESTClient（有关更多信息，请参见[http://restclient.net/](http://restclient.net/)）来生成示例请求。确保在请求中包含令牌，否则定义的API将拒绝请求。
- en: 'Here is an example of a `POST` request for `ID` `1`, which sets the `balance`
    field to a value of `888888`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于`AbstractApi`的`POST`请求的示例，用于`ID`为`1`，将`balance`字段设置为`888888`的值：
- en: '![How it works...](graphics/B05314_07_04.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_07_04.jpg)'
- en: There's more...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are a number of libraries that help you implement a REST server. One
    of my favorites is an example implementing a REST server in a single file: [https://www.leaseweb.com/labs/2015/10/creating-a-simple-rest-api-in-php/](https://www.leaseweb.com/labs/2015/10/creating-a-simple-rest-api-in-php/)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多库可以帮助您实现REST服务器。我最喜欢的之一是一个在单个文件中实现REST服务器的示例：[https://www.leaseweb.com/labs/2015/10/creating-a-simple-rest-api-in-php/](https://www.leaseweb.com/labs/2015/10/creating-a-simple-rest-api-in-php/)
- en: Various frameworks, such as CodeIgniter and Zend Framework, also have REST server
    implementations.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 各种框架，如CodeIgniter和Zend Framework，也有REST服务器实现。
- en: Creating a simple SOAP client
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的SOAP客户端
- en: Using SOAP, in contrast to the process of implementing a REST client or server,
    is quite easy as there is a PHP SOAP extension that provides both capabilities.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与实现REST客户端或服务器的过程相比，使用SOAP非常容易，因为有一个PHP SOAP扩展提供了这两种功能。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A frequently asked question is "what is the difference between SOAP and REST?"
    SOAP uses XML internally as its data format. SOAP uses HTTP but only for transport,
    and otherwise has no awareness of other HTTP methods. REST directly operates HTTP,
    and can use anything for data formats, but JSON is preferred. Another key difference
    is that SOAP can operate in conjunction with a WSDL, which makes the service self-describing,
    thus more publicly available. Thus, SOAP services are often offered by public
    institutions such as national health organizations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经常被问到的问题是“SOAP和REST之间有什么区别？” SOAP在内部使用XML作为数据格式。SOAP使用HTTP但仅用于传输，否则不了解其他HTTP方法。REST直接操作HTTP，并且可以使用任何数据格式，但首选JSON。另一个关键区别是SOAP可以与WSDL一起操作，这使得服务自描述，因此更容易公开。因此，SOAP服务通常由国家卫生组织等公共机构提供。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'For this example, we will make a SOAP request for an existing SOAP service
    offered by the United States National Weather service:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将为美国国家气象局提供的现有SOAP服务进行SOAP请求：
- en: 'The first consideration is to identify the **WSDL** document. The WSDL is an
    XML document that describes the service:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要考虑的是识别**WSDL**文档。WSDL是描述服务的XML文档：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we create a `soap client` instance using the WSDL:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用WSDL创建一个`soap client`实例：
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We are then free to initialize some variables in anticipation of a weather
    forecast request:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以自由地初始化一些变量，以期待天气预报请求：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can then make a `LatLonListCityNames()` SOAP request, identified as an operation
    in the WSDL, for a list of cities supported by the service. The request is returned
    in XML format, which suggests creating a `SimpleXLMElement` instance:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以进行`LatLonListCityNames()` SOAP请求，该请求在WSDL中标识为一个操作，以获取服务支持的城市列表。请求以XML格式返回，这表明需要创建一个`SimpleXLMElement`实例：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Unfortunately, the list of cities and their corresponding latitude and longitude
    are in separate XML nodes. Accordingly, we use the `array_combine()` PHP function
    to create an associative array where latitude/longitude is the key, and the city
    name is the value. We can then later use this to present an HTML `SELECT` drop-down
    list, using `asort()` to alphabetize the list:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不幸的是，城市及其对应的纬度和经度列表在单独的XML节点中。因此，我们使用`array_combine()` PHP函数创建一个关联数组，其中纬度/经度是键，城市名是值。然后，我们可以稍后使用这个数组来呈现HTML
    `SELECT`下拉列表，使用`asort()`对列表进行按字母排序：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can then get city data from a web request as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以按以下方式从Web请求中获取城市数据：
- en: '[PRE52]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The SOAP call we wish to make is `NDFDgenByDay()`. We can determine the nature
    of the parameters supplied to the SOAP server by examining the WSDL:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望进行的SOAP调用是`NDFDgenByDay()`。我们可以通过检查WSDL来确定提供给SOAP服务器的参数的性质：
- en: '[PRE53]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If the value of `$currentLatLon` is set, we can process the request. We wrap
    the request in a `try {} catch {}` block in case any exceptions are thrown:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果设置了`$currentLatLon`的值，我们可以处理请求。我们将请求包装在`try {} catch {}`块中，以防抛出任何异常：
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Copy all the preceding code into a `chap_07_simple_soap_client_weather_service.php`
    file. You can then add view logic that displays a form with the list of cities,
    as well as the results:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有前面的代码复制到`chap_07_simple_soap_client_weather_service.php`文件中。然后，您可以添加视图逻辑，显示带有城市列表的表单，以及结果：
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here is the result, in a browser, of requesting the weather forecast for Cleveland,
    Ohio:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在浏览器中请求俄亥俄州克利夫兰天气预报的结果：
- en: '![How it works...](graphics/B05314_07_05.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_07_05.jpg)'
- en: See also
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For a good discussion on the difference between SOAP and REST, refer to the
    article present at [http://stackoverflow.com/questions/209905/representational-state-transfer-rest-and-simple-object-access-protocol-soap?lq=1](http://stackoverflow.com/questions/209905/representational-state-transfer-rest-and-simple-object-access-protocol-soap?lq=1).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有关SOAP和REST之间的区别的讨论，请参阅[http://stackoverflow.com/questions/209905/representational-state-transfer-rest-and-simple-object-access-protocol-soap?lq=1](http://stackoverflow.com/questions/209905/representational-state-transfer-rest-and-simple-object-access-protocol-soap?lq=1)上的文章。
- en: Creating a simple SOAP server
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的SOAP服务器
- en: As with the SOAP client, we can use the PHP SOAP extension to implement a SOAP
    server. The most difficult part of the implementation will be generating the WSDL
    from the API class. We do not cover that process here as there are a number of
    good WSDL generators available.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与SOAP客户端一样，我们可以使用PHP SOAP扩展来实现SOAP服务器。实现中最困难的部分将是从API类生成WSDL。我们在这里不涵盖该过程，因为有许多好的WSDL生成器可用。
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'First, you need an API that will be handled by the SOAP server. For this example,
    we define an `Application\Web\Soap\ProspectsApi` class that allows us to create,
    read, update, and delete the `prospects` table:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要一个API，该API将由SOAP服务器处理。在本例中，我们定义了一个`Application\Web\Soap\ProspectsApi`类，允许我们创建、读取、更新和删除`prospects`表：
- en: '[PRE56]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We then define methods that correspond to create, read, update, and delete.
    In this example, the methods are named `put()`, `get()`, `post()`, and `delete()`.
    These, in turn, call methods that generate SQL requests that are executed from
    a PDO instance. An example for `get()` is as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义与创建、读取、更新和删除相对应的方法。在本例中，方法名为`put()`、`get()`、`post()`和`delete()`。这些方法依次调用生成SQL请求的方法，这些方法从PDO实例执行。`get()`的示例如下：
- en: '[PRE57]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can then generate a WSDL from your API. There are quite a few PHP-based
    WSDL generators available (see the *There''s more...* section). Most require that
    you add `phpDocumentor` tags before the methods that will be published. In our
    example, the two arguments are both arrays. Here is the full WSDL for the API
    discussed earlier:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以从您的API生成WSDL。有许多基于PHP的WSDL生成器可用（请参阅*还有更多...*部分）。大多数要求您在将要发布的方法之前添加`phpDocumentor`标签。在我们的示例中，两个参数都是数组。以下是先前讨论的API的完整WSDL：
- en: '[PRE58]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, create a `chap_07_simple_soap_server.php` file, which will execute the
    SOAP server. Start by defining the location of the WSDL and any other necessary
    files (in this case, one for database configuration). If the `wsdl` parameter
    is set, deliver the WSDL rather than attempting to process the request. In this
    example, we use a simple API key to authenticate requests. We then create a SOAP
    server instance, assign an instance of our API class, and run `handle()`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个`chap_07_simple_soap_server.php`文件，用于执行SOAP服务器。首先定义WSDL的位置和任何其他必要的文件（在本例中，用于数据库配置的文件）。如果设置了`wsdl`参数，则提供WSDL而不是尝试处理请求。在这个例子中，我们使用一个简单的API密钥来验证请求。然后创建一个SOAP服务器实例，分配一个API类的实例，并运行`handle()`：
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Depending on the settings for your `php.ini` file, you may need to disable
    the WSDL cache, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的`php.ini`文件的设置，您可能需要禁用WSDL缓存，方法如下：
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If you have problems with incoming `POST` data, you can adjust this parameter
    as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在处理传入的`POST`数据时遇到问题，可以按照以下方式调整此参数：
- en: '[PRE61]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You can easily test this recipe by first creating your target API class, and
    then generating a WSDL. You can then use the built-in PHP webserver to deliver
    the SOAP service with this command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过首先创建目标API类，然后生成WSDL来轻松测试此示例。然后，您可以使用内置的PHP Web服务器来提供SOAP服务，命令如下：
- en: '[PRE62]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can then use the SOAP client discussed in the previous recipe to make a
    call to test the SOAP service:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用前面讨论的SOAP客户端来调用测试SOAP服务：
- en: '[PRE63]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here is the output for email address `test5393@unlikelysource.com:`
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是电子邮件地址`test5393@unlikelysource.com`的输出：
- en: '![How it works...](graphics/B05314_07_06.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_07_06.jpg)'
- en: See also
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: A simple Google search for WSDL generators for PHP came back with easily a dozen
    results. The one used to generate the WSDL for the `ProspectsApi` class was based
    on [https://code.google.com/archive/p/php-wsdl-creator/](https://code.google.com/archive/p/php-wsdl-creator/).
    For more information on `phpDocumentor`, refer to the page at [https://www.phpdoc.org/](https://www.phpdoc.org/).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地在谷歌上搜索PHP的WSDL生成器就会得到大约十几个结果。用于生成`ProspectsApi`类的WSDL的生成器基于[https://code.google.com/archive/p/php-wsdl-creator/](https://code.google.com/archive/p/php-wsdl-creator/)。有关`phpDocumentor`的更多信息，请参阅[https://www.phpdoc.org/](https://www.phpdoc.org/)页面。
