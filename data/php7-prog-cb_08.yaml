- en: Chapter 8. Working with Date/Time and International Aspects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。处理日期/时间和国际化方面
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using emoticons or emoji in a view script
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图脚本中使用表情符号或emoji
- en: Converting complex characters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换复杂字符
- en: Getting the locale from browser data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从浏览器数据中获取locale
- en: Formatting numbers by locale
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按区域设置数字格式
- en: Handling currency by locale
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按区域设置货币
- en: Formatting date/time by locale
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按区域设置日期/时间格式
- en: Creating an HTML international calendar generator
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个HTML国际日历生成器
- en: Building a recurring events generator
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建重复事件生成器
- en: Handling translation without gettext
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理翻译而无需gettext
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: We will start this chapter with two recipes that take advantage of a new **Unicode**
    escape syntax introduced with **PHP 7**. After that, we will cover how to determine
    a web visitor's **locale** from browser data. The next few recipes will cover
    the creation of a locale class, which will allow you to represent numbers, currency,
    dates, and time in a format specific to a locale. Finally, we will cover recipes
    that demonstrate how to generate an internationalized calendar, handle recurring
    events, and perform translation without having to use `gettext`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从利用**PHP 7**引入的新**Unicode**转义语法开始本章的两个配方。之后，我们将介绍如何从浏览器数据中确定Web访问者的**locale**。接下来的几个配方将涵盖创建一个locale类，它将允许您以特定于locale的格式表示数字、货币、日期和时间。最后，我们将介绍一些演示如何生成国际化日历、处理重复事件和执行翻译的配方，而无需使用`gettext`。
- en: Using emoticons or emoji in a view script
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在视图脚本中使用表情符号或emoji
- en: The word **emoticons** is a composite of *emotion* and *icon*. **Emoji**, originating
    from Japan, is another, larger, widely used set of icons. These icons are the
    little smiley faces, tiny ninjas, and rolling-on-the-floor-laughing icons that
    are so popular on any website that has a social networking aspect. Prior to PHP
    7, however, producing these little beasties was an exercise in frustration.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 单词**emoticons**是*emotion*和*icon*的组合。**Emoji**源自日本，是另一个更大、更广泛使用的图标集。这些图标是小笑脸、小忍者和在地板上打滚大笑的图标，在任何具有社交网络方面的网站上都很受欢迎。然而，在PHP
    7之前，制作这些小家伙是一种沮丧的练习。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First and foremost, you need to know the Unicode for the icon you wish to present.
    A quick search on the Internet will direct you to any one of several excellent
    charts. Here are the codes for the three *hear-no-evil*, *see-no-evil*, and *speak-no-evil*
    monkey icons:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要知道您希望呈现的图标的Unicode。在互联网上快速搜索将指引您到几个优秀的图表之一。以下是三个*hear-no-evil*，*see-no-evil*和*speak-no-evil*猴子图标的代码：
- en: '`U+1F648`, `U+1F649`, and `U+1F64A`'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`U+1F648`，`U+1F649`和`U+1F64A`'
- en: '![How to do it...](graphics/B05314_08_11.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B05314_08_11.jpg)'
- en: 'Any Unicode output to the browser must be properly identified. This is most
    often done by way of a `meta` tag. You should set the character set to UTF-8\.
    Here is an example:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向浏览器输出任何Unicode必须得到正确的标识。这通常是通过`meta`标签完成的。您应该将字符集设置为UTF-8。以下是一个示例：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The traditional approach was to simply use HTML to display the icons. Thus,
    you could do something like this:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传统的方法是简单地使用HTML来显示图标。因此，您可以做如下操作：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As of PHP 7, you can now construct full Unicode characters using this syntax:
    `"\u{xxx}"`. Here is an example with the same three icons as in the preceding
    bullet:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从PHP 7开始，您现在可以使用此语法构造完整的Unicode字符：`"\u{xxx}"`。以下是与前述项目中相同的三个图标的示例：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Your operating system and browser must both support Unicode and must also have
    the right set of fonts. In Ubuntu Linux, for example, you would need to install
    the `ttf-ancient-fonts` package to see emoji in your browser.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您的操作系统和浏览器都必须支持Unicode，并且还必须具有正确的字体集。例如，在Ubuntu Linux中，您需要安装`ttf-ancient-fonts`软件包才能在浏览器中看到表情符号。
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In PHP 7, a new syntax was introduced that lets you render any Unicode character.
    Unlike other languages, the new PHP syntax allows for a variable number of hex
    digits. The basic format is this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中，引入了一种新的语法，允许您呈现任何Unicode字符。与其他语言不同，新的PHP语法允许变量数量的十六进制数字。基本格式如下：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The entire construct must be double quoted (or use **heredoc**). `xxxx` could
    be any combination of hex digits, 2, 4, 6, and above.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 整个结构必须使用双引号引起来（或使用**heredoc**）。`xxxx`可以是任意组合的十六进制数字，2、4、6及以上。
- en: 'Create a file called `chap_08_emoji_using_html.php`. Be sure to include the
    `meta` tag that signals the browser that UTF-8 character encoding is being used:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`chap_08_emoji_using_html.php`的文件。一定要包含`meta`标签，表示正在使用UTF-8字符编码的浏览器：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, set up a basic HTML table, and display a row of emoticons/emoji:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置一个基本的HTML表格，并显示一行表情符号/emoji：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now add a row using PHP to emit emoticons/emoji:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用PHP添加一行以发出表情符号/emoji：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the output seen from Firefox:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从Firefox中看到的输出：
- en: '![How it works...](graphics/B05314_08_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_08_01.jpg)'
- en: See also
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For a list of emoji codes, see [http://unicode.org/emoji/charts/full-emoji-list.html](http://unicode.org/emoji/charts/full-emoji-list.html)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关emoji代码的列表，请参阅[http://unicode.org/emoji/charts/full-emoji-list.html](http://unicode.org/emoji/charts/full-emoji-list.html)
- en: Converting complex characters
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换复杂字符
- en: The ability to access the entire Unicode character set opens up many new possibilities
    for rendering complex characters, especially characters in alphabets other than
    Latin-1.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 访问整个Unicode字符集的能力为呈现复杂字符，特别是拉丁-1字母表之外的字符，打开了许多新的可能性。
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Some languages are read right-to-left instead of left-to-right. Examples include
    Hebrew and Arabic. In this example, we show you how to present *reverse* text
    using the `U+202E` Unicode character for right-to-left override. The following
    line of code prints `txet desreveR`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有些语言是从右到左而不是从左到右阅读的。例如希伯来语和阿拉伯语。在这个例子中，我们向您展示如何使用`U+202E` Unicode字符来呈现*反向*文本。以下代码行打印`txet
    desreveR`：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't forget to invoke the left-to-right override character, `U+202D`, when
    finished!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后不要忘记调用从左到右覆盖字符`U+202D`！
- en: 'Another consideration is the use of composed characters. One such example is
    `ñ` (the letter `n` with a tilde `~` floating above). This is used in words such
    as *mañana* (the Spanish word for morning or tomorrow, depending on the context).
    There is a *composed character* available, represented by Unicode code `U+00F1`.
    Here is an example of its use, which echoes `mañana`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个考虑因素是使用组合字符。一个例子是`ñ`（字母`n`上面漂浮着一个波浪符`~`）。这在词语中使用，比如*mañana*（西班牙语中的早晨或明天，取决于上下文）。有一个*组合字符*，用Unicode代码`U+00F1`表示。这是它的使用示例，回显`mañana`：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This could potentially impact search possibilities, however. Imagine that your
    customers do not have a keyboard with this composed character. If they start to
    type `man` in an attempt to search for `mañana`, they will be unsuccessful.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，这可能会影响搜索的可能性。想象一下，您的客户没有带有这个组合字符的键盘。如果他们开始输入`man`试图搜索`mañana`，他们将不成功。
- en: 'Having access to the *full* Unicode set offers other possibilities. Instead
    of using the *composed* character, you can use a combination of the original letter
    `n` along with the Unicode *combining* code, which places a floating tilde on
    top of the letter. In this `echo` command, the output is the same as previously.
    Only the way the word is formed differs:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问*完整*的Unicode集合提供了其他可能性。您可以使用*组合*字符，而不是使用*组合*字符，它可以在字母上方放置一个浮动的波浪符。在这个`echo`命令中，输出与以前相同。只是形成单词的方式不同：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A similar application could be made for accents. Consider the French word `élève`
    (student). You could render it using composed characters, or by using combining
    codes to float the accents above the letter. Consider the two following examples.
    Both examples produce the same output, but are rendered differently:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似的应用可以用于重音符号。考虑法语单词`élève`（学生）。您可以使用组合字符来呈现它，也可以使用组合代码将重音符号浮动在字母上方。考虑以下两个例子。这两个例子产生相同的输出，但呈现方式不同：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Create a file called `chap_08_control_and_combining_unicode.php`. Be sure to
    include the `meta` tag that signals the browser that UTF-8 character encoding
    is being used:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`chap_08_control_and_combining_unicode.php`的文件。确保包含`meta`标签，表示正在使用UTF-8字符编码的浏览器：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, set up basic PHP and HTML to display the examples discussed previously:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置基本的PHP和HTML来显示之前讨论的示例：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is the output from a browser:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是浏览器的输出：
- en: '![How it works...](graphics/B05314_08_02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_08_02.jpg)'
- en: Getting the locale from browser data
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从浏览器数据获取locale
- en: In order to improve the user experience on a website, it's important to display
    information in a format that is acceptable in the user's locale. **Locale** is
    a generic term used to indicate an area of the world. An effort in the I.T. community
    has been made to codify locales using a two-part designation consisting of codes
    for both language and country. But when a person visits your website, how do you
    know their locale? Probably the most useful technique involves examining the HTTP
    language header.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改善网站上的用户体验，重要的是以用户的区域设置可接受的格式显示信息。Locale是一个通用术语，用来指示世界的某个地区。IT社区已经努力使用由语言和国家代码组成的两部分指定来编码locale。但是当一个人访问您的网站时，如何知道他们的区域设置呢？可能最有用的技术涉及检查HTTP语言标头。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: In order to encapsulate locale functionality, we will assume a class, `Application\I18n\Locale`.
    We will have this class extend an existing class, `Locale`, which is part of the
    PHP `Intl` extension.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了封装locale功能，我们将假设一个类`Application\I18n\Locale`。我们将使这个类扩展一个现有的类`Locale`，这是PHP的Intl扩展的一部分。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**I18n** is a common abbreviation for **Internationalization**. (Count the
    number of letters!)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: I18n是Internationalization的常见缩写。(计算字母的数量！)
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To get an idea of what an incoming request looks like, use `phpinfo(INFO_VARIABLES)`.
    Be sure to disable this function immediately after testing as it gives away too
    much information to potential attackers:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了了解传入请求的样子，使用`phpinfo(INFO_VARIABLES)`。在测试后立即禁用此功能，因为它会向潜在攻击者透露太多信息：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Locale information is stored in `$_SERVER[''HTTP_ACCEPT_LANGUAGE'']`. The value
    will take this general form: `ll-CC,rl;q=0.n, ll-CC,rl;q=0.n`, as defined in this
    table:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Locale信息存储在`$_SERVER['HTTP_ACCEPT_LANGUAGE']`中。该值将采用这种一般形式：`ll-CC,rl;q=0.n,
    ll-CC,rl;q=0.n`，如表中所定义：
- en: '| Abbreviation | Meaning |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 缩写 | 意义 |'
- en: '| --- | --- |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ll` | Two-character lowercase code representing the language. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `ll` | 代表语言的两个小写字母代码。 |'
- en: '| `-` | Separates language from country in the locale code `ll-CC`. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 在语言和国家之间分隔区域代码`ll-CC`。 |'
- en: '| `CC` | Two-character uppercase code representing the country. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `CC` | 代表国家的两个大写字母代码。 |'
- en: '| `,` | Separates locale code from fallback **root locale** code (usually the
    same as the language code). |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `,` | 将locale代码与回退**根locale**代码（通常与语言代码相同）分隔开。 |'
- en: '| `rl` | Two-character lowercase code representing the suggested root locale.
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `rl` | 代表建议的根locale的两个小写字母代码。 |'
- en: '| `;` | Separates locale information from quality. If quality is missing, default
    is `q=1` (100%) probability; this is preferred. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `;` | 将locale信息与质量分隔开。如果质量丢失，默认为`q=1`（100%）概率；这是首选的。 |'
- en: '| `q` | Quality. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `q` | 质量。 |'
- en: '| `0.n` | Some value between 0.00 and 1.0\. Multiply this value by 100 to get
    the percentage of probability that this is the actual language preferred by this
    visitor. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `0.n` | 0.00到1.0之间的某个值。将此值乘以100，以获得此访问者实际首选语言的概率百分比。 |'
- en: 'There can easily be more than one locale listed. For example, the website visitor
    could have multiple languages installed on their computer. It so happens that
    the PHP `Locale` class has a method, `acceptFromHttp()`, which reads the `Accept-language`
    header string and gives us the desired setting:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能会列出多个locale。例如，网站访问者可能在他们的计算机上安装了多种语言。PHP的Locale类恰好有一个方法`acceptFromHttp()`，它读取`Accept-language`标头字符串并给我们所需的设置：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can then define the appropriate getters. The `get AcceptLanguage()` method
    returns the value from `$_SERVER[''HTTP_ACCEPT_LANGUAGE'']`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以定义适当的getter。`get AcceptLanguage()`方法返回`$_SERVER['HTTP_ACCEPT_LANGUAGE']`中的值。
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next we define a constructor that allows us to "manually" set the locale. Otherwise,
    the locale information is drawn from the browser:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个构造函数，允许我们“手动”设置区域设置。否则，区域设置信息将从浏览器中获取：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now comes the big decision: what to do with this information! This is covered
    in the next few recipes.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在要做出重要的决定：如何处理这些信息！这将在接下来的几篇文章中介绍。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even though a visitor appears to accept one or more languages, that visitor
    does not necessarily want contents in the language/locale indicated by their browser.
    Accordingly, although you can certainly set the locale given this information,
    you should also provide them with a static list of alternative languages.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 即使访问者似乎接受一个或多种语言，该访问者并不一定希望以其浏览器指示的语言/区域设置显示内容。因此，尽管您可以根据这些信息设置区域设置，但您还应该为他们提供一个静态的备选语言列表。
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this illustration, let''s take three examples:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们举三个例子：
- en: information derived from the browser
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从浏览器获取的信息
- en: a preset locale `fr-FR`
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预设区域设置`fr-FR`
- en: 'a string taken from RFC 2616: `da, en-gb;q=0.8, en;q=0.7`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从RFC 2616中获取的字符串：`da, en-gb;q=0.8, en;q=0.7`
- en: Place the code from steps 1 to 6 into a file, `Locale.php`, which is in the
    `Application\I18n` folder.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将步骤1到6的代码放入一个名为`Locale.php`的文件中，该文件位于`Application\I18n`文件夹中。
- en: 'Next, create a file, `chap_08_getting_locale_from_browser.php`, which sets
    up autoloading and uses the new class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`chap_08_getting_locale_from_browser.php`的文件，该文件设置自动加载并使用新的类：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now you can define an array with the three test locale strings:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以定义一个包含三个测试区域设置字符串的数组：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, loop through the three locale strings, creating instances of the new
    class. Echo the value returned from `getLocaleCode()` to see what choice was made:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，循环遍历三个区域设置字符串，创建新类的实例。回显从`getLocaleCode()`返回的值，以查看做出了什么选择：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is the result (with a little bit of styling):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果（稍微加了一点样式）：
- en: '![How it works...](graphics/B05314_08_03.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_08_03.jpg)'
- en: See also
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For information on the PHP `Locale` class, see [http://php.net/manual/en/class.locale.php](http://php.net/manual/en/class.locale.php)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关PHP`Locale`类的信息，请参阅[http://php.net/manual/en/class.locale.php](http://php.net/manual/en/class.locale.php)
- en: 'For more information on the `Accept-Language` header, see section 14.4 of RFC
    2616: [https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`Accept-Language`标头的更多信息，请参阅RFC 2616的第14.4节：[https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)
- en: Formatting numbers by locale
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按区域设置格式化数字
- en: 'Numeric representations can vary by locale. As a simple example, in the UK
    one would see the number three million, eighty thousand, five hundred and twelve,
    and ninety-two one hundredths as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 数字表示可以根据区域设置而变化。举一个简单的例子，在英国，三百万八千五百一十二点九十二可以看作是：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In France, however, the same number might appear like so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在法国，同样的数字可能会显示如下：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Before you can represent a number in a locale-specific manner, you need to determine
    the locale. This can be accomplished using the `Application\I18n\Locale` class
    discussed in the previous recipe. The locale can be set manually or from header
    information.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在表示特定区域的数字之前，您需要确定区域设置。这可以使用前面一篇文章中讨论的`Application\I18n\Locale`类来实现。区域设置可以手动设置或从标头信息中获取。
- en: 'Next, we will make use of the `format()` method of the `NumberFormatter` class,
    to both output and parse numbers in a locale-specific format. First we add a property
    that will contain an instance of the `NumberFormatter` class:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`NumberFormatter`类的`format()`方法，以区域特定的格式输出和解析数字。首先，我们添加一个属性，该属性将包含`NumberFormatter`类的一个实例：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Our initial thought would be to consider using the PHP function `setlocale()`
    to produce numbers formatted according to locale. The problem with this legacy
    approach, however, is that *everything* will be considered based on this locale.
    This could introduce problems dealing with data that is stored according to database
    specifications. Another issue with `setlocale()` is that it is based on outdated
    standards, including RFC 1766 and ISO 639\. Finally, `setlocale()` is highly dependent
    on operating system locale support, which will make our code non-portable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的想法是考虑使用PHP函数`setlocale()`根据区域设置生成格式化的数字。然而，这种传统方法的问题在于*一切*都将基于这个区域设置。这可能会引入处理根据数据库规范存储的数据的问题。`setlocale()`的另一个问题是它基于过时的标准，包括RFC
    1766和ISO 639。最后，`setlocale()`高度依赖于操作系统的区域支持，这将使我们的代码不可移植。
- en: 'Normally, the next step would be to set `$numberFormatter` in the constructor.
    The problem with this approach, in the case of our `Application\I18n\Locale` class,
    is that we would end up with a top-heavy class, as we will also need to perform
    currency and date formatting as well. Accordingly, we add a `getter` that first
    checks to see whether an instance of `NumberFormatter` has already been created.
    If not, an instance is created and returned. The first argument in the new `NumberFormatter`
    is the locale code. The second argument, `NumberFormatter::DECIMAL`, represents
    what type of formatting we need:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，下一步将是在构造函数中设置`$numberFormatter`。然而，对于我们的`Application\I18n\Locale`类，这种方法的问题在于，我们最终会得到一个过于庞大的类，因为我们还需要执行货币和日期格式化。因此，我们添加一个`getter`，首先检查是否已经创建了`NumberFormatter`的实例。如果没有，则创建并返回一个实例。新的`NumberFormatter`中的第一个参数是区域代码。第二个参数`NumberFormatter::DECIMAL`表示我们需要的格式化类型：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We then add a method that, given any number, will produce a string that represents
    that number formatted according to the locale:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加一个方法，给定任何数字，将生成一个字符串，该字符串根据区域设置格式化该数字：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next we add a method that can be used to parse numbers according to the locale,
    producing a native PHP numeric value. Please note that the result might not return
    `FALSE` on parse failure depending on the server''s ICU version:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个方法，该方法可用于根据区域设置解析数字，生成本机PHP数值。请注意，根据服务器的ICU版本，结果可能在解析失败时不会返回`FALSE`：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Make the additions to the `Application\I18n\Locale` class as discussed in the
    preceding bullet points. You can then create a `chap_08_formatting_numbers.php`
    file, which sets up autoloading and uses this class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前面的要点对`Application\I18n\Locale`类进行添加。然后，您可以创建一个`chap_08_formatting_numbers.php`文件，其中设置自动加载并使用此类：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For this illustration, create two `Locale` instances, one for the UK, the other
    for France. You can also designate a large number to be used for testing:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为此说明，创建两个`Locale`实例，一个用于英国，另一个用于法国。您还可以指定一个大数字用于测试：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, you can wrap the `formatNumber()` and `parseNumber()` methods in the
    appropriate HTML display logic and view the results:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以将`formatNumber()`和`parseNumber()`方法包装在适当的HTML显示逻辑中，并查看结果：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is the result as seen from a browser:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从浏览器中看到的结果：
- en: '![How it works...](graphics/B05314_08_04.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_08_04.jpg)'
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that if the locale is set to `fr_FR`, a UK formatted number, when parsed,
    does not return the correct value. Likewise, when the locale is set to `en_GB`,
    a French formatted number does not return the correct value upon parsing. Accordingly,
    you might want to consider adding a validation check before attempting to parse
    the number.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果区域设置为`fr_FR`，则解析时，以英国格式化的数字不会返回正确的值。同样，当区域设置为`en_GB`时，以法国格式化的数字在解析时也不会返回正确的值。因此，在尝试解析数字之前，您可能需要考虑添加验证检查。
- en: See also
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information on the use and abuse of `setlocale()` please refer to
    this page: [http://php.net/manual/en/function.setlocale.php](http://php.net/manual/en/function.setlocale.php).'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关使用和滥用`setlocale()`的更多信息，请参阅此页面：[http://php.net/manual/en/function.setlocale.php](http://php.net/manual/en/function.setlocale.php)。
- en: 'For a brief note on why number formatting will produce an error on some servers,
    but not others, check the **ICU** (**International Components for Unicode**) version.
    See the comments on this page: [http://php.net/manual/en/numberformatter.parse.php](http://php.net/manual/en/numberformatter.parse.php).
    For more info on ICU formatting, see [http://userguide.icu-project.org/formatparse](http://userguide.icu-project.org/formatparse).'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于为什么数字格式化在一些服务器上会产生错误，而在其他服务器上不会产生错误的简要说明，请查看**ICU**（**国际Unicode组件**）版本。请参阅此页面上的评论：[http://php.net/manual/en/numberformatter.parse.php](http://php.net/manual/en/numberformatter.parse.php)。有关ICU格式化的更多信息，请参见[http://userguide.icu-project.org/formatparse](http://userguide.icu-project.org/formatparse)。
- en: Handling currency by locale
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按区域设置处理货币
- en: 'The technique for handling currency is similar to that for numbers. We will
    even use the same `NumberFormatter` class! There is one major difference, however,
    and it is a *show stopper*: in order to properly format currency, you will need
    to have on hand the currency code.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 处理货币的技术与处理数字的技术类似。我们甚至会使用相同的`NumberFormatter`类！然而，有一个主要区别，这是一个*停滞不前*的问题：为了正确格式化货币，您需要掌握货币代码。
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The first order of business is to have the currency codes available in some
    format. One possibility is to simply add the currency code as an `Application\I18n\Locale`
    class constructor argument:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首要任务是以某种格式使货币代码可用。一种可能性是将货币代码简单地添加为`Application\I18n\Locale`类的构造函数参数：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This approach, although obviously solid and workable, tends to fall into the
    category called *halfway measures* or *the easy way out*! This approach would
    also tend to eliminate full automation as the currency code is not available from
    the HTTP header. As you have probably gathered from other recipes in this book,
    we do not shy away from a more complex solution so, as the saying goes, *strap
    on your seat belts*!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法显然是可靠且可行的，但往往会属于*半途而废*或*走捷径*的范畴！这种方法也往往会消除完全自动化，因为货币代码无法从HTTP标头中获取。正如您可能从本书的其他示例中了解到的，我们不会回避更复杂的解决方案，所以，俗话说得好，*系好安全带*！
- en: 'We will first need to establish some sort of lookup mechanism, where, given
    a country code, we can obtain its predominant currency code. For this illustration,
    we will use the Adapter software design pattern. According to this pattern, we
    should be able to create different classes, which could potentially operate in
    entirely different ways, but which produce the same result. Accordingly, we need
    to define the desired result. For this purpose, we introduce a class, `Application\I18n\IsoCodes`.
    As you can see, this class has all the pertinent properties, along with a sort-of
    universal constructor:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要建立某种查找机制，即给定一个国家代码，我们可以获取其主要货币代码。为此说明，我们将使用适配器软件设计模式。根据此模式，我们应该能够创建不同的类，这些类可能以完全不同的方式运行，但产生相同的结果。因此，我们需要定义所需的结果。为此目的，我们引入一个类，`Application\I18n\IsoCodes`。正如您所看到的，这个类具有所有相关的属性，以及一种类似通用的构造函数：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next we define an interface that has the method we require to perform the *country-code-to-currency-code*
    lookup. In this case, we introduce `Application\I18n\IsoCodesInterface`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个接口，其中包含我们需要执行*国家代码到货币代码*查找的方法。在这种情况下，我们引入`Application\I18n\IsoCodesInterface`：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we are ready to build a lookup adapter class, which we will call `Application\I18n\IsoCodesDb`.
    It implements the abovementioned interface, and accepts an `Application\Database\Connection`
    instance (see [Chapter 1](ch01.html "Chapter 1. Building a Foundation"), *Building
    a Foundation*), which is used to perform the lookup. The constructor sets up the
    required information, including the connection, the lookup table name, and the
    column that represents the ISO2 code. The lookup method required by the interface
    then issues an SQL statement and returns an array, which is then used to build
    an `IsoCodes` instance:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备构建一个查找适配器类，我们将其称为“Application\I18n\IsoCodesDb”。它实现了上述接口，并接受一个“Application\Database\Connection”实例（参见[第1章](ch01.html
    "第1章。建立基础")，“建立基础”），用于执行查找。构造函数设置所需的信息，包括连接、查找表名称和表示ISO2代码的列。接口所需的查找方法然后发出一个SQL语句并返回一个数组，然后用于构建一个“IsoCodes”实例：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we turn our attention back to the `Application\I18n\Locale` class. We first
    add a couple of new properties and class constants:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将注意力转回到“Application\I18n\Locale”类。我们首先添加了一些新的属性和类常量：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We add new method that retrieves the country code from the locale string. We
    can leverage the `getRegion()` method, which comes from the PHP `Locale` class
    (which we extend). Just in case it''s needed, we also add a method, `getCurrencyCode()`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个新的方法，从区域设置字符串中检索国家代码。我们可以利用来自PHP“Locale”类（我们扩展的类）的“getRegion（）”方法。以防需要，我们还添加了一个“getCurrencyCode（）”方法：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As with formatting numbers, we define a `getCurrencyFormatter(I)`, much as
    we did `getNumberFormatter()` (shown previously). Notice that `$currencyFormatter`
    is defined using `NumberFormatter`, but with a different second parameter:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与格式化数字一样，我们定义了一个“getCurrencyFormatter（I）”，就像我们之前所做的“getNumberFormatter（）”一样。请注意，使用“NumberFormatter”定义了“$currencyFormatter”，但第二个参数不同：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We then add a currency code lookup to the class constructor if the lookup class
    has been defined:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果已定义查找类，我们将在类构造函数中添加货币代码查找：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then add the appropriate currency format and parse methods. Note that parsing
    currency, unlike parsing numbers, will return `FALSE` if the parsing operation
    is not successful:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加适当的货币格式和解析方法。请注意，与解析数字不同，如果解析操作不成功，解析货币将返回“FALSE”：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Create the following classes, as covered in the first several bullet points:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下类，如前面几个要点中所述：
- en: '| Class | Bullet point discussed |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 讨论的要点 |'
- en: '| --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Application\I18n\IsoCodes` | 3 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `Application\I18n\IsoCodes` | 3 |'
- en: '| `Application\I18n\IsoCodesInterface` | 4 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `Application\I18n\IsoCodesInterface` | 4 |'
- en: '| `Application\I18n\IsoCodesDb` | 5 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `Application\I18n\IsoCodesDb` | 5 |'
- en: 'We will assume, for the purposes of this illustration, that we have a populated
    MySQL database table, `iso_country_codes`, which has this structure:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明的目的，我们假设有一个填充了数据的MySQL数据库表“iso_country_codes”，其结构如下：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Make the additions to the `Application\I18n\Locale` class, as discussed in
    bullet points 6 to 9 previously. You can then create a `chap_08_formatting_currency.php`
    file, which sets up autoloading and uses the appropriate classes:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前讨论的要点6到9，对“Application\I18n\Locale”类进行添加。然后可以创建一个“chap_08_formatting_currency.php”文件，其中设置自动加载并使用适当的类：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we create instances of the `Connection` and `IsoCodesDb` classes:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建“Connection”和“IsoCodesDb”类的实例：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For this illustration, create two `Locale` instances, one for the UK, the other
    for France. You can also designate a large number to be used for testing:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为此示例，创建两个“Locale”实例，一个用于英国，另一个用于法国。您还可以指定一个大数字用于测试：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, you can wrap the `formatCurrency()` and `parseCurrency()` methods
    in the appropriate HTML display logic and view the results. Base your view logic
    on that presented in the *How it works...* section of the previous recipe (not
    repeated here to save trees!). Here is the final output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以将“formatCurrency（）”和“parseCurrency（）”方法包装在适当的HTML显示逻辑中，并查看结果。根据前一个配方中呈现的*工作原理...*部分（此处未重复以节省树木！）制定您的视图逻辑。这是最终输出：
- en: '![How it works...](graphics/B05314_08_05.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_08_05.jpg)'
- en: See also
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'The most up-to-date list of currency codes is maintained by **ISO** (**International
    Standards Organization**). You can obtain this list in either **XML** or **XLS**
    (that is, **Microsoft Excel** spreadsheet format). Here is the page where these
    lists can be found: [http://www.currency-iso.org/en/home/tables/table-a1.html](http://www.currency-iso.org/en/home/tables/table-a1.html).'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 货币代码的最新列表由**ISO**（**国际标准化组织**）维护。您可以在**XML**或**XLS**（即**Microsoft Excel**电子表格格式）中获取此列表。以下是这些列表的页面：[http://www.currency-iso.org/en/home/tables/table-a1.html](http://www.currency-iso.org/en/home/tables/table-a1.html)。
- en: Formatting date/time by locale
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按区域设置格式化日期/时间
- en: The formatting of date and time varies region to region. As a classic example,
    consider the year 2016, month April, day 15 and a time in the evening. The format
    preferred by denizens of the United States would be 7:23 PM, 4/15/2016, whereas
    in China you would most likely see 2016-04-15 19:23\. As mentioned with number
    and currency formatting, it would also be important to display (and parse) dates
    in a format acceptable to your web visitors.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间的格式因地区而异。作为一个经典的例子，考虑2016年，4月，15日和晚上的时间。美国人民偏好的格式可能是下午7:23，2016年4月15日，而在中国，您很可能会看到2016-04-15
    19:23。与数字和货币格式化一样，以一种对您的网站访问者可接受的格式显示（和解析）日期也很重要。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'First of all, we need to modify `Application\I18n\Locale`, adding statements
    to use date formatting classes:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要修改“Application\I18n\Locale”，添加语句以使用日期格式化类：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we add a property to represent an `IntlDateFormatter` instance, as well
    as a series of predefined constants:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个属性来表示“IntlDateFormatter”实例，以及一系列预定义的常量：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After that, we are in a position to define a method, `getDateFormatter()`,
    which returns an `IntlDateFormatter` instance. The value of `$type` matches one
    of the `DATE_TYPE_*` constants defined previously:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以定义一个方法`getDateFormatter()`，它返回一个`IntlDateFormatter`实例。`$type`的值与之前定义的`DATE_TYPE_*`常量之一相匹配：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next we define a method that produces a locale formatted date. Defining the
    format of the incoming `$date` is a bit tricky. It cannot be locale-specific,
    otherwise we will need to parse it according to locale rules, with unpredictable
    results. A better strategy would be to accept an array of values that represent
    year, month, day, and so on as integers. As a fallback, we will accept a string
    but only in this format: `YYYY-mm-dd HH:ii:ss`. Time zone is optional, and can
    be set separately. First we initialize variables:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个方法，生成一个区域设置格式的日期。定义传入的`$date`的格式有点棘手。它不能是特定于区域设置的，否则我们将需要根据区域设置规则解析它，结果难以预测。更好的策略是接受一个代表年、月、日等值的整数数组。作为备用方案，我们将接受一个字符串，但只能是这种格式：`YYYY-mm-dd
    HH:ii:ss`。时区是可选的，可以单独设置。首先我们初始化变量：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After that we produce a breakdown of values that represent year, month, day,
    and so on:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们生成代表年、月、日等值的值的分解：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next we create an `IntlCalendar` instance, which will serve as an argument
    when running `format()`. We set the date using the discreet integer values:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`IntlCalendar`实例，它将作为运行`format()`时的参数。我们使用离散的整数值设置日期：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we obtain the date formatter instance, and produce the result:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们获得日期格式化程序实例，并生成结果：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `parseDate()` method is actually simpler than formatting. The only complication
    is what to do if the type is not specified (which will be the most likely case).
    All we need to do is to loop through all possible types (of which there are only
    four) until a result is produced:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`parseDate()`方法实际上比格式化更简单。唯一的复杂之处在于如果未指定类型要做什么（这可能是最常见的情况）。我们需要做的就是循环遍历所有可能的类型（只有四种），直到产生结果为止：'
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Code the changes to `Application\I18n\Locale`, discussed previously. You can
    then create a test file, `chap_08_formatting_date.php`, which sets up autoloading,
    and creates two instances of the `Locale` class, one for the USA, the other for
    France:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对之前讨论过的`Application\I18n\Locale`进行更改。然后，您可以创建一个测试文件`chap_08_formatting_date.php`，设置自动加载，并创建`Locale`类的两个实例，一个用于美国，另一个用于法国：
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, with suitable styling, run a test of `formatDate()` and `parseDate()`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过合适的样式，运行`formatDate()`和`parseDate()`的测试：
- en: '[PRE52]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'An example of the output is shown here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了输出的一个示例：
- en: '![How it works...](graphics/B05314_08_06.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_08_06.jpg)'
- en: See also
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: ISO 8601 gives precise definitions for all aspects of date and time. There is
    also an RFC that discusses the impact of ISO 8601 on the Internet. For reference,
    see [https://tools.ietf.org/html/rfc3339](https://tools.ietf.org/html/rfc3339).
    For a good overview of date formats by country, see [https://en.wikipedia.org/wiki/Date_format_by_country](https://en.wikipedia.org/wiki/Date_format_by_country).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO 8601为日期和时间的所有方面提供了精确的定义。还有一个RFC讨论了ISO 8601对互联网的影响。有关参考，请参阅[https://tools.ietf.org/html/rfc3339](https://tools.ietf.org/html/rfc3339)。有关各国日期格式的概述，请参阅[https://en.wikipedia.org/wiki/Date_format_by_country](https://en.wikipedia.org/wiki/Date_format_by_country)。
- en: Creating an HTML international calendar generator
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HTML国际日历生成器
- en: Creating a program to display a calendar is something you would most likely
    do as a student at secondary school. A nested `for()` loop, where the inside loop
    generates a list of seven days, will generally suffice. Even the problem of how
    many days there are in the month is easily solved in the form of a simple array.
    Where it starts to get tricky is when you need to figure out, for any given year,
    on what day of the week does the 1st of January fall. Also, what if you want to
    represent the months and days of the week in a language and format acceptable
    to a specific locale? As you have probably guessed, we will build a solution using
    the previously discussed `Application\I18n\Locale` class.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个显示日历的程序是你在中学时最有可能做的事情。一个嵌套的`for()`循环，内部循环生成一个七天的列表，通常就足够了。甚至每个月有多少天这个问题也很容易通过一个简单的数组解决。当你需要弄清楚，在任何给定的年份，1月1日是星期几时，情况就会变得棘手起来。还有，如果你想用特定语言和格式表示月份和星期几，符合特定区域设置的话，会怎么样？正如你可能已经猜到的那样，我们将使用之前讨论过的`Application\I18n\Locale`类构建一个解决方案。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'First we need to create a generic class that will hold information for a single
    day. Initially it will only hold an integer value, `$dayOfMonth`. Later, in the
    next recipe, we''ll expand it to include events. As the primary purpose of this
    class will be to yield `$dayOfMonth`, we''ll incorporate this value into its constructor,
    and define `__invoke()` to return this value as well:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个通用类，用于保存单日的信息。最初，它只会保存一个整数值`$dayOfMonth`。稍后，在下一个示例中，我们将扩展它以包括事件。由于这个类的主要目的是产生`$dayOfMonth`，我们将把这个值纳入它的构造函数，并定义`__invoke()`来返回这个值：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a new class that will hold the appropriate calendar-generation methods.
    It will accept an instance of `Application\I18n\Locale`, and will define a couple
    of class constants and properties. The format codes, such as `EEEEE` and `MMMM`,
    are drawn from ICU date formats:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的类，它将保存适当的日历生成方法。它将接受一个`Application\I18n\Locale`的实例，并定义一些类常量和属性。格式代码，如`EEEEE`和`MMMM`，是从ICU日期格式中提取的：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then we define a method that returns an `IntlDateFormatter` instance from our
    `locale` class. This is stored in a class property, as it will be used frequently:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个方法，从我们的`locale`类中返回一个`IntlDateFormatter`实例。这将存储在一个类属性中，因为它将经常被使用：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next we define a core method, `buildMonthArray()`, which creates a multi-dimensional
    array where the outer key is the week of the year, and the inner array is seven
    elements representing the days of the week. We accept the year, month, and optional
    time zone as arguments. Note, as part of variable initialization, we subtract
    1 from the month. This is because the `IntlCalendar::set()` method expects a 0-based
    value for the month, where 0 represents January, 1 is February, and so on:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个核心方法`buildMonthArray()`，它创建一个多维数组，其中外部键是一年中的周数，内部数组是表示一周的七个元素的天。我们接受年份、月份和可选的时区作为参数。请注意，在变量初始化的一部分中，我们从月份中减去1。这是因为`IntlCalendar::set()`方法期望月份的基于0的值，其中0代表一月，1代表二月，依此类推：
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We then create an `IntlCalendar` instance, and use it to determine how many
    days are in this month:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`IntlCalendar`实例，并使用它来确定这个月有多少天：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'After that we use our `IntlDateFormatter` instance to determine what day of
    the week equates to the 1st of this month. After that, we set the pattern to `w`,
    which will subsequently give us the week number:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们使用我们的`IntlDateFormatter`实例来确定这个月的第一天是星期几。之后，我们将模式设置为`w`，随后将给出周数：
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We are now ready to loop through all days in the month with nested loops. An
    outer `while()` loop ensures we don''t go past the end of the month. The inner
    loop represents the days of the week. You will note that we take advantage of
    `IntlCalendar::get()`, which allows us to retrieve values from a wide range of
    predefined fields. We also adjust the week of the year value to 0 if it exceeds
    52:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备通过嵌套循环遍历该月的所有天。外部的`while()`循环确保我们不会超过月份的末尾。内部循环表示一周中的天。您会注意到我们利用`IntlCalendar::get()`，它允许我们从各种预定义字段中检索值。如果一年中的周数超过52，我们还会将周数值调整为0：
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We then check to see whether `$first` is still set `TRUE`. If so, we start adding
    day numbers to the array. Otherwise, the array value is set to `NULL`. We then
    close all open statements and return the array. Note that we also need to make
    sure the inner loop doesn't go past the number of days in the month, hence the
    extra `if()` statement in the outer `else` clause.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查`$first`是否仍然设置为`TRUE`。如果是，我们开始向数组添加日期。否则，数组值设置为`NULL`。然后，我们关闭所有打开的语句并返回数组。请注意，我们还需要确保内部循环不会超过月份的天数，因此在外部`else`子句中有额外的`if()`语句。
- en: Note
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that instead of just storing the value for the day of the month, we use
    the newly defined `Application\I18n\Day` class.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不仅存储月份的值，还使用新定义的`Application\I18n\Day`类。
- en: '[PRE60]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Refining internationalized output
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完善国际化输出
- en: 'First, a series of small methods, starting with one that extracts the internationally
    formatted day based on type. The type determines whether we deliver the full name
    of the day, an abbreviation, or just a single letter, all appropriate for that
    locale:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，一系列小方法，从提取基于类型的国际格式化日期开始。类型决定我们是否提供星期几的全名、缩写，或者只是一个字母，都适合该区域设置：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next we need a method that returns an HTML row of day names, calling the newly
    defined `getDay()` method. As mentioned previous, the type dictates the appearance
    of the days:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个方法来返回一个星期几的HTML行，调用新定义的`getDay()`方法。如前所述，类型决定了日期的外观：
- en: '[PRE62]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'After that, we define a very simple method to return a row of week dates. Note
    that we take advantage of `Day::__invoke()` using: `$day()`:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们定义一个非常简单的方法来返回一行星期日期。请注意，我们利用`Day::__invoke()`使用：`$day()`：
- en: '[PRE63]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'And finally, a method that puts the smaller methods together to generate a
    calendar for a single month. First we build the month array, but only if `$yearArray`
    is not already available:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一个将较小方法组合在一起生成单个月份日历的方法。首先我们构建月份数组，但只有在`$yearArray`尚不可用时才这样做：
- en: '[PRE64]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The month needs to be decremented by `1` as `IntlCalendar` months are 0-based:
    Jan = 0, Feb = 1, and so on. We then build an `IntlCalendar` instance using the
    time zone (if any), and the locale. We next create a `IntlDateFormatter` instance
    to retrieve the month name and other information according to locale:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 月份需要减去`1`，因为`IntlCalendar`的月份是基于0的：1月= 0，2月= 1，依此类推。然后，我们使用时区（如果有的话）和区域设置构建一个`IntlCalendar`实例。接下来，我们创建一个`IntlDateFormatter`实例，根据区域设置检索月份名称和其他信息：
- en: '[PRE65]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We then loop through the month array, and call the smaller methods just mentioned
    to build the final output:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们循环遍历月份数组，并调用刚才提到的较小方法来构建最终的输出：
- en: '[PRE66]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In order to generate a calendar for the entire year, it''s a simple matter
    of looping through months 1 to 12\. To facilitate outside access, we first define
    a method that builds a year array:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了生成整年的日历，只需循环遍历1到12月。为了方便外部访问，我们首先定义一个构建年份数组的方法：
- en: '[PRE67]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To generate a calendar for a year, we define a method, `calendarForYear()`.
    If the year array has not been build, we call `buildYearArray()`. We take into
    account how many monthly calendars we wish to display across and then call `calendarForMonth()`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为一年生成日历，我们定义一个方法`calendarForYear()`。如果年份数组尚未构建，我们调用`buildYearArray()`。我们考虑要显示多少个月份的日历，然后调用`calendarForMonth()`：
- en: '[PRE68]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First of all, make sure you build the `Application\I18n\Locale` class as defined
    in the previous recipe. After that, create a new file, `Calendar.php`, in the
    `Application\I18n` folder, with all the methods described in this recipe.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保按照前面的示例构建`Application\I18n\Locale`类。之后，在`Application\I18n`文件夹中创建一个名为`Calendar.php`的新文件，其中包含本示例中描述的所有方法。
- en: 'Next, define a calling program, `chap_08_html_calendar.php`, which sets up
    autoloading and creates `Locale` and `Calendar` instances. Also be sure to define
    the year and month:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个调用程序`chap_08_html_calendar.php`，设置自动加载并创建`Locale`和`Calendar`实例。还要确保定义年份和月份：
- en: '[PRE69]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You can then develop appropriate view logic to display the different calendars.
    For example, you can include parameters to display the full month and day names:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以开发适当的视图逻辑来显示不同的日历。例如，您可以包括参数来显示完整的月份和日期名称：
- en: '[PRE70]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '![How it works...](graphics/B05314_08_07.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_08_07.jpg)'
- en: 'With a couple of modifications, you can also display a calendar for the entire
    year:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行一些修改，您还可以显示整年的日历：
- en: '[PRE71]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here is the browser output showing a full year calendar in Spanish:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是浏览器输出，显示了一个完整的西班牙语年历：
- en: '![How it works...](graphics/B05314_08_08.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_08_08.jpg)'
- en: See also
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information on codes used by `IntlDateFormatter::setPattern()`, see
    this article: [http://userguide.icu-project.org/formatparse/datetime](http://userguide.icu-project.org/formatparse/datetime)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`IntlDateFormatter::setPattern()`使用的代码的更多信息，请参阅本文：[http://userguide.icu-project.org/formatparse/datetime](http://userguide.icu-project.org/formatparse/datetime)
- en: Building a recurring events generator
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个重复事件生成器
- en: A very common need related to generating a calendar is the scheduling of events.
    Events can be in the form of *one-off* events, which take place on one day, or
    on a weekend. There is a much greater need, however, to track events that are
    *recurring*. We need to account for the start date, the recurring interval (daily,
    weekly, monthly), and the number of occurrences or a specific end date.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与生成日历相关的一个非常普遍的需求是安排事件。事件可以是*一次性*事件，发生在一天，或者在周末。然而，更需要跟踪*重复*事件。我们需要考虑开始日期、重复间隔（每天、每周、每月）以及发生次数或特定的结束日期。
- en: How to do it...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Before anything else, it would be an excellent idea to create a class that
    represents an event. Ultimately you''ll probably end up storing the data in such
    a class in a database. For this illustration, however, we will simply define the
    class, and leave the database aspect to your imagination. You will notice that
    we will use a number of classes included in the `DateTime` extension admirably
    suited to event generation:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何其他事情之前，创建一个表示事件的类将是一个绝妙的主意。最终，您可能会将数据存储在数据库中的这样一个类中。然而，在本示例中，我们将简单地定义类，并将数据库方面留给您的想象力。您会注意到我们将使用`DateTime`扩展中包含的许多类，这些类非常适合事件生成：
- en: '[PRE72]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, we define a series of useful class constants and properties. You will
    notice that we defined most of the properties `public` in order to economize on
    the number of getters and setters needed. The intervals are defined as `sprintf()`
    format strings; `%d` will be substituted for a value:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一系列有用的类常量和属性。您会注意到，我们将大多数属性定义为`public`，以节省所需的 getter 和 setter 的数量。间隔被定义为`sprintf()`格式字符串；`%d`将被替换为一个值：
- en: '[PRE73]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Next we turn our attention to the constructor. We need to collect and set all
    information pertinent to an event. The variable names are self-explanatory.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将注意力转向构造函数。我们需要收集和设置与事件相关的所有信息。变量名不言自明。
- en: Note
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`$value` is not quite so clear. This parameter will ultimately be substituted
    for the value in the interval format string. So, for example, if the user selects
    `$interval` as `INTERVAL_DAY`, and `$value` as `2`, the resulting interval string
    will be `P2D`, which means every other day (or every 2nd day).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`$value`并不是那么清晰。这个参数最终将被替换为间隔格式字符串中的值。因此，例如，如果用户选择`$interval`为`INTERVAL_DAY`，并且`$value`为`2`，则生成的间隔字符串将是`P2D`，这意味着每隔一天（或每隔2天）。'
- en: '[PRE74]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We then initialize variables. Note that the ID is pseudo-randomly generated,
    but might ultimately end up being the primary key in a database `events` table.
    Here we use `md5()` not for security purposes, but rather to quickly generate
    a hash so that IDs have a consistent appearance:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们初始化变量。请注意，ID 是伪随机生成的，但最终可能成为数据库`events`表中的主键。在这里，我们使用`md5()`不是出于安全目的，而是为了快速生成哈希，以便
    ID 具有一致的外观：
- en: '[PRE75]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'As mentioned previously, the interval parameter is a `sprintf()` pattern used
    to construct a proper `DateInterval` instance:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，间隔参数是一个`sprintf()`模式，用于构造适当的`DateInterval`实例：
- en: '[PRE76]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To initialize `$startDate`, we call `stringOrDate()`. We then attempt to generate
    a value for `$endDate` by calling either `stringOrDate()` or `calcEndDateFromOccurrences()`.
    If we have neither an end date nor a number of occurrences, an exception is thrown:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要初始化`$startDate`，我们调用`stringOrDate()`。然后，我们尝试通过调用`stringOrDate()`或`calcEndDateFromOccurrences()`来生成`$endDate`的值。如果我们既没有结束日期也没有发生次数，就会抛出异常：
- en: '[PRE77]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `stringOrDate()` method consists of a few lines of code that check the
    data type of the date variable, and return a `DateTime` instance or `NULL`:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`stringOrDate()`方法由几行代码组成，用于检查日期变量的数据类型，并返回`DateTime`实例或`NULL`：'
- en: '[PRE78]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We call the `calcEndDateFromOccurrences()` method from the constructor if `$occurrences`
    is set so that we''ll know the end date for this event. We take advantage of the
    `DatePeriod` class, which provides an iteration based on a start date, `DateInterval`,
    and number of occurrences:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果设置了`$occurrences`，我们将从构造函数中调用`calcEndDateFromOccurrences()`方法，以便我们知道此事件的结束日期。我们利用`DatePeriod`类，它提供了基于开始日期、`DateInterval`和发生次数的迭代：
- en: '[PRE79]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next we throw in a `__toString()` magic method, which simple echoes the title
    of the event:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们加入一个`__toString()`魔术方法，它简单地回显事件的标题：
- en: '[PRE80]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The last method we need to define for our `Event` class is `getNextDate()`,
    which is used when generating a calendar:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为我们的`Event`类定义的最后一个方法是`getNextDate()`，在生成日历时使用：
- en: '[PRE81]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Next we turn our attention to the `Application\I18n\Calendar` class described
    in the previous recipe. With a bit of minor surgery, we are ready to tie our newly
    defined `Event` class into the calendar. First we add a new property, `$events`,
    and a method to add events in the form of an array. We use the `Event::$id` property
    to make sure events are merged and not overwritten:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将注意力转向上一篇食谱中描述的`Application\I18n\Calendar`类。通过进行一些小的修改，我们准备好将我们新定义的`Event`类与日历联系起来。首先，我们添加一个新属性`$events`，以及一个用于以数组形式添加事件的方法。我们使用`Event::$id`属性来确保事件被合并而不是被覆盖：
- en: '[PRE82]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Next we add a method, `processEvents()`, which adds an `Event` instance to
    a `Day` object when building the year calendar. First we check to see whether
    there are any events, and whether or not the `Day` object is `NULL`. As you may
    recall, it''s likely that the first day of the month doesn''t fall on the first
    day of the week, and thus the need to set the value of a `Day` object to `NULL`.
    We certainly do not want to add events to a non-operative day! We then call `Event::getNextDate()`
    and see whether the dates match. If so, we store the `Event` into `Day::$events[]`
    and set the next date on the `Event` object:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个名为`processEvents()`的方法，该方法在构建年历时将`Event`实例添加到`Day`对象中。首先，我们检查是否有任何事件，以及`Day`对象是否为`NULL`。您可能还记得，月初可能不是星期的第一天，因此需要将`Day`对象的值设置为`NULL`。我们当然不希望将事件添加到一个无效的日期！然后，我们调用`Event::getNextDate()`并查看日期是否匹配。如果匹配，我们将`Event`存储到`Day::$events[]`中，并在`Event`对象上设置下一个日期：
- en: '[PRE83]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that we do not do a direct comparison of the two objects. Two reasons
    for this: first of all, one is a `DateTime` instance, the other is an `IntlCalendar`
    instance. The other, more compelling reason, is that it''s possible that hours:minutes:seconds
    were included when the `DateTime` instance was obtained, resulting in actual value
    differences between the two objects.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不直接比较两个对象。这样做的两个原因：首先，一个是`DateTime`实例，另一个是`IntlCalendar`实例。另一个更有说服力的原因是，当获取`DateTime`实例时可能包括小时:分钟:秒，导致两个对象之间的实际值差异。
- en: 'Now we need to add a call to `processEvents()` in the `buildMonthArray()` method
    so that it looks like this:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在`buildMonthArray()`方法中添加对`processEvents()`的调用，使其如下所示：
- en: '[PRE84]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Finally, we need to modify `getWeekDaysRow()`, adding the necessary code to
    output event information inside the box along with the date:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要修改`getWeekDaysRow()`，添加必要的代码以在框内输出事件信息以及日期：
- en: '[PRE85]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: How it works...
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To tie events to the calendar, first code the `Application\I18n\Event` class
    described in steps 1 to 10\. Next, modify `Application\I18n\Calendar` as described
    in steps 11 to 14\. You can then create a test script, `chap_08_recurring_events.php`,
    which sets up autoloading and creates `Locale` and `Calendar` instances. For the
    purposes of illustration, go ahead and use ''`es_ES`'' as a locale:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要将事件与日历关联，首先编写步骤1到10中描述的`Application\I18n\Event`类。接下来，修改`Application\I18n\Calendar`，如步骤11到14中所述。然后，您可以创建一个测试脚本`chap_08_recurring_events.php`，设置自动加载并创建`Locale`和`Calendar`实例。为了说明，继续使用'`es_ES`'作为区域设置：
- en: '[PRE86]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now we can start defining and adding events to the calendar. The first example
    adds an event that lasts 3 days and starts on 8 January 2016:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始定义并向日历添加事件。第一个示例添加了一个持续3天并从2016年1月8日开始的事件：
- en: '[PRE87]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Here is another example, an event that occurs on the first of every month until
    September 2017:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另一个示例，即每月1日直到2017年9月发生的事件：
- en: '[PRE88]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You can then add sample weekly, bi-weekly, monthly, and so on events as desired.
    You can then close the `try...catch` block, and produce suitable display logic:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以根据需要添加每周、每两周、每月等样本事件。然后关闭`try...catch`块，并生成适当的显示逻辑：
- en: '[PRE89]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here is the output showing the first few months of the year:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是显示年初几个月的输出：
- en: '![How it works...](graphics/B05314_08_09.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_08_09.jpg)'
- en: See also
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information on `IntlCalendar` field constants that can be used with
    `get()`, please refer to this page: [http://php.net/manual/en/class.intlcalendar.php#intlcalendar.constants](http://php.net/manual/en/class.intlcalendar.php#intlcalendar.constants)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关可与`get()`一起使用的`IntlCalendar`字段常量的更多信息，请参阅此页面：[http://php.net/manual/en/class.intlcalendar.php#intlcalendar.constants](http://php.net/manual/en/class.intlcalendar.php#intlcalendar.constants)
- en: Handling translation without gettext
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理翻译而不使用gettext
- en: Translation is an important part of making your website accessible to an international
    customer base. One way this is accomplished it to use the PHP `gettext` functions,
    which are based on the **GNU** `gettext` operating system tools installed on the
    local server. `gettext` is well documented and well supported, but uses a legacy
    approach and has distinct disadvantages. Accordingly, in this recipe, we present
    an alternative approach to translation where you can build your own *adapter*.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译是使您的网站对国际客户群体可访问的重要部分。实现这一目标的一种方法是使用基于本地服务器上安装的**GNU** `gettext`操作系统工具的PHP
    `gettext`函数。`gettext`有很好的文档和支持，但使用了传统的方法并具有明显的缺点。因此，在本教程中，我们提出了一种替代翻译方法，您可以构建自己的*适配器*。
- en: Something important to recognize is that the programmatic translation tools
    available to PHP are primarily designed to provide limited translation of a word
    or phrase, referred to as the **msgid** (**message ID**). The translated equivalent
    is referred to as the **msgstr** (**message string**). Accordingly, incorporating
    translation typically only involves relatively unchanging items such as menus,
    forms, error or success messages, and so on. For the purposes of this recipe,
    we will assume that you have the actual web page translations stored as blocks
    of text.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 需要认识到的一点重要的是，PHP可用的编程翻译工具主要设计为提供单词或短语的有限翻译，称为**msgid**（**消息ID**）。翻译的等效物称为**msgstr**（**消息字符串**）。因此，通常只涉及相对不变的项目，如菜单、表单、错误或成功消息等。在本教程中，我们将假设您已将实际网页翻译存储为文本块。
- en: Note
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you need to translate entire pages of content, you might consider using the
    *Google Translate API*. This is, however, a paid service. Alternatively, you could
    outsource the translation to individuals with multi-lingual skills cheaply using
    *Amazon Mechanical Turk*. See the *See Also* section at the end of this recipe
    for the URLs.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要翻译整个页面的内容，您可以考虑使用*Google翻译API*。但这是一个付费服务。或者，您可以使用*Amazon Mechanical Turk*以廉价的方式将翻译外包给具有多语言技能的个人。有关URL，请参阅本教程末尾的*另请参阅*部分。
- en: How to do it...
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will once again use the Adapter software design pattern, in this case to
    provide alternatives to the translation source. In this recipe, we will demonstrate
    adapters for `.ini` files, `.csv` files, and databases.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将再次使用适配器软件设计模式，这次是为了提供翻译源的替代方案。在这个示例中，我们将演示`.ini`文件、`.csv`文件和数据库的适配器。
- en: 'To begin, we will define an interface that will later be used to identify a
    translation adapter. The requirements for a translation adapter are quite simple,
    we only need to return a message string for a given message ID:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个接口，稍后将用于标识翻译适配器。翻译适配器的要求非常简单，我们只需要为给定的消息ID返回一个消息字符串：
- en: '[PRE90]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Next we define a trait that matches the interface. The trait will contain the
    actual code required. Note that if we fail to find the message string, we simply
    return the message ID:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个与接口匹配的特质。特质将包含实际所需的代码。请注意，如果我们未能找到消息字符串，我们只需返回消息ID：
- en: '[PRE91]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now we''re ready to define our first adapter. In this recipe, we''ll start
    with an adapter that uses an `.ini` file as the source of translations. The first
    thing you''ll notice is that we use the trait defined previously. The constructor
    method will vary between adapters. In this case, we use `parse_ini_file()` to
    produce an array of key/value pairs where the key is the message ID. Notice that
    we use the `$filePattern` parameter to substitute the locale, which then allows
    us to load the appropriate translation file:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备定义我们的第一个适配器。在这个示例中，我们将从使用`.ini`文件作为翻译源的适配器开始。您会注意到的第一件事是，我们使用了之前定义的特质。构造方法将在适配器之间有所不同。在这种情况下，我们使用`parse_ini_file()`来生成一个键/值对数组，其中键是消息ID。请注意，我们使用`$filePattern`参数来替换区域设置，然后可以加载适当的翻译文件：
- en: '[PRE92]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The next adapter, `Application\I18n\Translate\Adapter\Csv`, is identical, except
    that we open the translation file and loop through using `fgetcsv()` to retrieve
    the message ID / message string key pairs. Here we show only the difference in
    the constructor:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个适配器，“Application\I18n\Translate\Adapter\Csv”，除了打开翻译文件并使用“fgetcsv()”循环检索消息ID
    / 消息字符串键值对外，其他都相同。这里我们只展示构造函数中的区别：
- en: '[PRE93]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Note
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The big disadvantage of both of these adapters is that we need to preload the
    entire translation set, which puts a strain on memory if there is a large number
    of translations. Also, the translation file needs to be opened and parsed, which
    drags down performance.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个适配器的一个很大的缺点是，我们需要预加载整个翻译集，如果有大量的翻译，这会对内存造成压力。此外，需要打开和解析翻译文件，这会拖慢性能。
- en: 'We now present the third adapter, which performs a database lookup and avoids
    the problems of the other two adapters. We use a `PDO` prepared statement which
    is sent to the database in the beginning, and only one time. We then execute as
    many times as needed, supplying the message ID as an argument. You will also notice
    that we needed to override the `translate()` method defined in the trait. Finally,
    you might have noticed the use of `PDOStatement::fetchColumn()` as we only need
    the one value:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们介绍第三个适配器，它执行数据库查找，避免了其他两个适配器的问题。我们使用一个`PDO`准备语句，它在开始时发送到数据库，只发送一次。然后我们根据需要执行多次，提供消息ID作为参数。您还会注意到，我们需要覆盖特质中定义的`translate()`方法。最后，您可能已经注意到我们使用了`PDOStatement::fetchColumn()`，因为我们只需要一个值：
- en: '[PRE94]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We are now ready to define the core `Translation` class, which is tied to one
    (or more) adapters. We assign a class constant to represent the default locale,
    and properties for the locale, adapter, and text file pattern (explained later):'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备定义核心的“Translation”类，它与一个（或多个）适配器相关联。我们分配一个类常量来表示默认的区域设置，并为区域设置、适配器和文本文件模式（稍后解释）设置属性：
- en: '[PRE95]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In the constructor, we determine the locale, and set the initial adapter to
    this locale. In this manner, we are able to host multiple adapters:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们确定区域设置，并将初始适配器设置为此区域设置。通过这种方式，我们能够托管多个适配器：
- en: '[PRE96]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Next we define a series of setters, which gives us more flexibility:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一系列的setter，这给了我们更多的灵活性：
- en: '[PRE97]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We then define the PHP magic method `__invoke()`, which lets us make a direct
    call to the translator instance, returning the message string given the message
    ID:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了PHP魔术方法`__invoke()`，它让我们可以直接调用翻译实例，返回给定消息ID的消息字符串：
- en: '[PRE98]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Finally, we also add a method that can return translated blocks of text from
    text files. Bear in mind that this could be modified to use a database instead.
    We did not include this functionality in the adapter, as its purpose is completely
    different; we just want to return large blocks of code given a key, which could
    conceivably be the filename of the translated text file:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还添加了一个方法，可以从文本文件中返回翻译的文本块。请记住，这可以修改为使用数据库。我们没有在适配器中包含这个功能，因为它的目的完全不同；我们只想根据一个键返回大块代码，这个键可能是翻译文本文件的文件名：
- en: '[PRE99]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: How it works...
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First you will need to define a directory structure to house the translation
    files. For the purposes of this illustration, you can make a directory ,`/path/to/project/files/data/languages`.
    Under this directory structure, create sub-directories that represent different
    locales. For this illustration, you could use these: `de_DE`, `fr_FR`, `en_GB`,
    and `es_ES`, representing German, French, English, and Spanish.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要定义一个目录结构来存放翻译文件。为了说明的目的，您可以创建一个目录，“/path/to/project/files/data/languages”。在这个目录结构下，创建代表不同区域设置的子目录。对于这个示例，您可以使用这些：`de_DE`，`fr_FR`，`en_GB`和`es_ES`，分别代表德语、法语、英语和西班牙语。
- en: 'Next you will need to create the different translation files. As an example,
    here is a representative `data/languages/es_ES/translation.ini` file in Spanish:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要创建不同的翻译文件。例如，这是一个代表西班牙语的“data/languages/es_ES/translation.ini”文件：
- en: '[PRE100]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Likewise, to demonstrate the CSV adapter, create the same thing as a CSV file,
    `data/languages/es_ES/translation.csv`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了演示CSV适配器，创建一个相同的CSV文件，`data/languages/es_ES/translation.csv`：
- en: '[PRE101]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Finally, create a database table, `translation`, and populate it with the same
    data. The main difference is that the database table will have three fields: `msgid`,
    `msgstr`, and `locale_code`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建一个名为`translation`的数据库表，并用相同的数据填充它。主要区别在于数据库表将具有三个字段：`msgid`，`msgstr`和`locale_code`。
- en: '[PRE102]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Next, define the classes mentioned previously, using the code shown in this
    recipe:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用本教程中显示的代码定义先前提到的类：
- en: '`Application\I18n\Translate\Adapter\TranslateAdapterInterface`'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\I18n\Translate\Adapter\TranslateAdapterInterface`'
- en: '`Application\I18n\Translate\Adapter\TranslateAdapterTrait`'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\I18n\Translate\Adapter\TranslateAdapterTrait`'
- en: '`Application\I18n\Translate\Adapter\Ini`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\I18n\Translate\Adapter\Ini`'
- en: '`Application\I18n\Translate\Adapter\Csv`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\I18n\Translate\Adapter\Csv`'
- en: '`Application\I18n\Translate\Adapter\Database`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\I18n\Translate\Adapter\Database`'
- en: '`Application\I18n\Translate\Translation`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\I18n\Translate\Translation`'
- en: 'Now you can create a test file, `chap_08_translation_database.php`, to test
    the database translation adapter. It should implement autoloading, use the appropriate
    classes, and create a `Locale` and `Connection` instance. Note that the `TEXT_FILE_PATTERN`
    constant is a `sprintf()` pattern in which the locale code and filename are substituted:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以创建一个名为`chap_08_translation_database.php`的测试文件，以测试数据库翻译适配器。它应该实现自动加载，使用适当的类，并创建`Locale`和`Connection`实例。请注意，`TEXT_FILE_PATTERN`常量是一个`sprintf()`模式，其中区域代码和文件名被替换：
- en: '[PRE103]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Next, create a translation adapter instance and use that to create a `Translation`
    instance:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个翻译适配器实例，并使用它来创建一个`Translation`实例：
- en: '[PRE104]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Finally, create display logic that uses the `$translate` instance:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建使用`$translate`实例的显示逻辑：
- en: '[PRE105]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'You can then perform additional similar tests, substituting a new locale to
    get a different language, or using another adapter to test a different data source.
    Here is an example of output using a locale of `fr_FR` and the database translation
    adapter:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以执行其他类似的测试，替换新的区域设置以获得不同的语言，或者使用另一个适配器来测试不同的数据源。以下是使用`fr_FR`区域设置和数据库翻译适配器的输出示例：
- en: '![How it works...](graphics/B05314_08_10.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_08_10.jpg)'
- en: See also
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information on the Google Translation API, see [https://cloud.google.com/translate/v2/translating-text-with-rest](https://cloud.google.com/translate/v2/translating-text-with-rest).
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Google翻译API的更多信息，请参阅[https://cloud.google.com/translate/v2/translating-text-with-rest](https://cloud.google.com/translate/v2/translating-text-with-rest)。
- en: For more information on Amazon Mechanical Turk, see [https://www.mturk.com/mturk/welcome](https://www.mturk.com/mturk/welcome).
    For more information on `gettext`, see [http://www.gnu.org/software/gettext/manual/gettext.html](http://www.gnu.org/software/gettext/manual/gettext.html).
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Amazon Mechanical Turk的更多信息，请参阅[https://www.mturk.com/mturk/welcome](https://www.mturk.com/mturk/welcome)。有关`gettext`的更多信息，请参阅[http://www.gnu.org/software/gettext/manual/gettext.html](http://www.gnu.org/software/gettext/manual/gettext.html)。
