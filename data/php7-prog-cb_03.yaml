- en: Chapter 3. Working with PHP Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用PHP函数式编程
- en: 'In this chapter we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Developing functions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发函数
- en: Hinting at data types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型提示
- en: Using return value data typing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用返回值数据类型
- en: Using iterators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器
- en: Writing your own iterator using generators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成器编写自己的迭代器
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter we will consider recipes that take advantage of PHP's **functional
    programming** capabilities. Functional, or **procedural**, programming is the
    traditional way PHP code was written prior to the introduction of the first implementation
    of **object-oriented programming** (**OOP**) in PHP version 4\. Functional programming
    is where program logic is encapsulated into a series of discreet **functions**,
    which are generally stored in a separate PHP file. This file can then be included
    in any future scripts, allowing the functions that are defined to be called at
    will.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将考虑利用PHP的**函数式编程**能力的方法。函数式或**过程式**编程是在PHP版本4引入**面向对象编程**（**OOP**）之前编写PHP代码的传统方式。函数式编程是将程序逻辑封装到一系列离散的**函数**中，这些函数通常存储在单独的PHP文件中。然后可以在任何未来的脚本中包含此文件，从而允许随意调用定义的函数。
- en: Developing functions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发函数
- en: The most difficult aspect is deciding how to break up programming logic into
    functions. The mechanics of developing a function in PHP, on the other hand, are
    quite easy. Just use the `function` keyword, give it a name, and follow it with
    parentheses.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最困难的部分是决定如何将编程逻辑分解为函数。另一方面，在PHP中开发函数的机制非常简单。只需使用`function`关键字，给它一个名称，然后跟着括号。
- en: How to do it...
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The code itself goes inside curly braces as follows:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码本身放在大括号中，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can define one or more **parameters**. To make one of them optional, simply
    assign a default value. If you are not sure what default value to assign, use
    `NULL`:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以定义一个或多个**参数**。要使其中一个参数变为可选，只需分配一个默认值。如果不确定要分配什么默认值，请使用`NULL`：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You cannot redefine functions. The only exception is when duplicate functions
    are defined in separate namespaces. This definition would generate an error:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能重新定义函数。唯一的例外是在不同的命名空间中定义重复的函数。这个定义会生成一个错误：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you don''t know how many parameters will be supplied to your function, or
    if you want to allow for an infinite number of parameters, use `...` followed
    by a variable name. All parameters supplied will appear as an array in the variable:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不知道将向函数提供多少参数，或者想要允许无限数量的参数，请使用`...`后跟一个变量名。提供的所有参数将出现在变量中的数组中：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A function can call itself. This is referred to as **recursion**. The following
    function performs a recursive directory scan:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数可以调用自身。这被称为**递归**。以下函数执行递归目录扫描：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Usage of the `static` keyword inside functions has been in the language for
    more than 12 years. What `static` does is to initialize the variable once (that
    is, at the time `static` is declared), and then retain the value between function
    calls within the same request.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内使用`static`关键字已经有12年以上的历史了。`static`的作用是在函数调用之间保留变量的值。
- en: If you need to retain the value of a variable between HTTP requests, make sure
    the PHP session has been started and store the value in `$_SESSION`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在HTTP请求之间保留变量的值，请确保已启动PHP会话并将值存储在`$_SESSION`中。
- en: Functions are constrained when defined within a PHP **namespace**. This characteristic
    can be used to your advantage to provide additional logical separation between
    libraries of functions. In order to *anchor* the namespace, you need to add the
    `use` keyword. The following examples are placed in separate namespaces. Notice
    that even though the function name is the same, there is no conflict as they are
    not visible to each other.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PHP **命名空间**中定义函数时受到限制。这个特性可以用来为函数库之间提供额外的逻辑分离。为了*锚定*命名空间，您需要添加`use`关键字。以下示例放置在单独的命名空间中。请注意，即使函数名称相同，它们也不会发生冲突，因为它们彼此之间不可见。
- en: 'We define `someFunction()` in namespace `Alpha`. We save this to a separate
    PHP file, `chap_03_developing_functions_namespace_alpha.php`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在命名空间`Alpha`中定义了`someFunction()`。我们将其保存到一个单独的PHP文件`chap_03_developing_functions_namespace_alpha.php`中：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We then define `someFunction()` in namespace `Beta`. We save this to a separate
    PHP file, `chap_03_developing_functions_namespace_beta.php`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在命名空间`Beta`中定义了`someFunction()`。我们将其保存到一个单独的PHP文件`chap_03_developing_functions_namespace_beta.php`中：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can then call `someFunction()` by prefixing the function name with the namespace
    name:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以通过在函数名前加上命名空间名称来调用`someFunction()`：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: 'It is considered best practice to place function libraries (and classes too!)
    into separate files: one file per namespace, and one class or function library
    per file.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是将函数库（以及类！）放入单独的文件中：一个命名空间一个文件，一个类或函数库一个文件。
- en: It is possible to define many classes or function libraries in a single namespace.
    The only reason you would develop into a separate namespace is if you want to
    foster logical separation of functionality.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在单个命名空间中定义许多类或函数库。将开发到单独的命名空间的唯一原因是如果要促进功能的逻辑分离。
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'It is considered best practice to place all logically related functions into
    a separate PHP file. Create a file called `chap_03_developing_functions_library.php`
    and place these functions (described previously) inside:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是将所有逻辑相关的函数放入一个单独的PHP文件中。创建一个名为`chap_03_developing_functions_library.php`的文件，并将这些函数（前面描述的）放入其中。
- en: '`someName()`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`someName()`'
- en: '`someOtherName()`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`someOtherName()`'
- en: '`someInfinite()`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`someInfinite()`'
- en: '`someDirScan()`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`someDirScan()`'
- en: '`someTypeHint()`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`someTypeHint()`'
- en: This file is then included in the code that uses these functions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将此文件包含在使用这些函数的代码中。
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To call the `someName()` function, use the name and supply the parameter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用`someName()`函数，请使用名称并提供参数。
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can call the `someOtherName()` function using one or two parameters, as
    shown here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样调用`someOtherName()`函数使用一个或两个参数：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `someInfinite()` function accepts an infinite (or variable) number of parameters.
    Here are a couple of examples calling this function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`someInfinite()`函数接受无限（或可变）数量的参数。以下是调用这个函数的一些例子：'
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![How it works...](graphics/B05314_03_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_03_01.jpg)'
- en: 'We can call `someDirScan()` as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样调用`someDirScan()`：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output looks like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![How it works...](graphics/B05314_03_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_03_02.jpg)'
- en: Hinting at data types
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型提示
- en: In many cases when developing functions, you might reuse the same library of
    functions in other projects. Also, if you work with a team, your code might be
    used by other developers. In order to control the use of your code, it might be
    appropriate to make use of a **type hint**. This involves specifying the data
    type your function expects for that particular parameter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发函数时，许多情况下你可能会在其他项目中重用相同的函数库。此外，如果你与团队合作，你的代码可能会被其他开发人员使用。为了控制你的代码的使用，使用**类型提示**可能是合适的。这涉及到指定函数对于特定参数期望的数据类型。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Parameters in functions can be prefixed by a type hint. The following type
    hints are available in both PHP 5 and PHP 7:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数中的参数可以加上类型提示。以下类型提示在PHP 5和PHP 7中都可用：
- en: Array
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Class
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Callable
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可调用的
- en: 'If a call to the function is made, and the wrong parameter type is passed,
    a `TypeError` is thrown. The following example requires an array, an instance
    of `DateTime`, and an anonymous function:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果调用函数，并传递了错误的参数类型，将抛出`TypeError`。以下示例需要一个数组、一个`DateTime`的实例和一个匿名函数：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You don't have to provide a type hint for every single parameter. Use this technique
    only where supplying a different data type would have a negative effect on the
    processing of your function. As an example, if your function uses a `foreach()`
    loop, if you do not supply an array, or something which implements `Traversable`,
    an error will be generated.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必为每个参数提供类型提示。只有在提供不同的数据类型会对函数处理产生负面影响时才使用这种技术。例如，如果你的函数使用`foreach()`循环，如果你没有提供一个数组，或者实现了`Traversable`的东西，就会产生一个错误。
- en: 'In PHP 7, presuming the appropriate `declare()` directive is made, **scalar**
    (that is, integer, float, boolean, and string) type hints are allowed. Another
    function demonstrates how this is accomplished. At the top of the code library
    file which contains the function in which you wish to use scalar type hinting,
    add this `declare()` directive just after the opening PHP tag:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PHP 7中，假设适当的`declare()`指令已经被声明，**标量**（即整数、浮点数、布尔值和字符串）类型提示是允许的。另一个函数演示了如何实现这一点。在包含你希望使用标量类型提示的函数的代码库文件的顶部，在开头的PHP标记之后添加这个`declare()`指令：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now you can define a function that includes scalar type hints:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以定义一个包含标量类型提示的函数：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In PHP 7, assuming strict type hinting has been declared, boolean type hinting
    works a bit differently from the other three scalar types (that is, integer, float,
    and string). You can supply any scalar as an argument and no `TypeError` will
    be thrown! However, the incoming value will automatically be converted to the
    boolean data type once passed into the function. If you pass any data type other
    than scalar (that is, array or object) a `TypeError` will be thrown. Here is an
    example of a function that defines a `boolean` data type. Note that the return
    value will be automatically converted to a `boolean`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PHP 7中，假设已经声明了严格的类型提示，布尔类型提示与其他三种标量类型（即整数、浮点数和字符串）有些不同。你可以提供任何标量作为参数，不会抛出`TypeError`！然而，一旦传递到函数中，传入的值将自动转换为布尔数据类型。如果传递的数据类型不是标量（即数组或对象），将抛出`TypeError`。这是一个定义`boolean`数据类型的函数的例子。请注意，返回值将自动转换为`boolean`：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First of all, you can place the three functions, `someTypeHint()`, `someScalarHint()`,
    and `someBoolHint()`, into a separate file to be included. For this example, we
    will name the file `chap_03_developing_functions_type_hints_library.php`. Don't
    forget to add `declare(strict_types=1)` at the top!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以将`someTypeHint()`、`someScalarHint()`和`someBoolHint()`这三个函数放在一个单独的文件中以供包含。在这个例子中，我们将文件命名为`chap_03_developing_functions_type_hints_library.php`。不要忘记在顶部添加`declare(strict_types=1)`！
- en: 'In our calling code, you would then include the file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的调用代码中，你需要包含这个文件：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To test `someTypeHint()`, call the function twice, once with the correct data
    types, and the second time with incorrect types. This will throw a `TypeError`,
    however, so you will need to wrap the function calls in a `try { ... } catch ()
    { ...}` block:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`someTypeHint()`，调用函数两次，一次使用正确的数据类型，第二次使用不正确的类型。这将抛出一个`TypeError`，因此你需要将函数调用包装在`try
    { ... } catch () { ...}`块中：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see from the output shown at the end of this sub-section, when passing
    the correct data types there is no problem. When passing the incorrect types,
    a `TypeError` is thrown.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个子部分末尾显示的输出中可以看出，当传递正确的数据类型时没有问题。当传递不正确的类型时，将抛出`TypeError`。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In PHP 7, certain errors have been converted into an `Error` class, which is
    processed in a somewhat similar manner to an `Exception`. This means you can catch
    an `Error`. `TypeError` is a specific descendant of `Error` that is thrown when
    incorrect data types are passed to functions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中，某些错误已经转换为`Error`类，这与`Exception`的处理方式有些相似。这意味着你可以捕获`Error`。`TypeError`是`Error`的一个特定子类，当向函数传递不正确的数据类型时抛出。
- en: All PHP 7 `Error` classes implement the `Throwable` interface, as does the `Exception`
    class. If you are not sure if you need to catch an `Error` or an `Exception`,
    you can add a block which catches `Throwable`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有PHP 7的`Error`类都实现了`Throwable`接口，`Exception`类也是如此。如果你不确定是否需要捕获`Error`还是`Exception`，你可以添加一个捕获`Throwable`的块。
- en: 'Next you can test `someScalarHint()`, calling it twice with correct and incorrect
    values, wrapping the calls in a `try { ... } catch () { ...}` block:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以测试`someScalarHint()`，用正确和不正确的值调用它，将调用包装在`try { ... } catch () { ...}`块中：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As expected, the first call to the function works, and the second throws a `TypeError`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，对该函数的第一次调用有效，而第二次调用会抛出`TypeError`。
- en: When type hinting for boolean values, any scalar value passed will *not* cause
    a `TypeError` to be thrown! Instead, the value will be interpreted into its boolean
    equivalent. If you subsequently return this value, the data type will be changed
    to boolean.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当对布尔值进行类型提示时，传递的任何标量值都*不会*导致抛出`TypeError`！相反，该值将被解释为其布尔等价值。如果随后返回此值，则数据类型将更改为布尔值。
- en: 'To test this, call the `someBoolHint()` function defined previously, and pass
    any scalar value in as an argument. The `var_dump()` method reveals that the data
    type is always boolean:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这一点，调用之前定义的`someBoolHint()`函数，并将任何标量值作为参数传入。`var_dump()`方法显示数据类型始终是布尔值：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you now try the same function call, but pass in a non-scalar data type,
    a `TypeError` is thrown:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在尝试相同的函数调用，但传入非标量数据类型，则会抛出`TypeError`：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is the overall output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整体输出：
- en: '![How it works...](graphics/B05314_03_03.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_03_03.jpg)'
- en: See also
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'PHP 7.1 introduced a new type hint `iterable` which allows arrays, `Iterators`
    or `Generators` as arguments. See this for more information:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7.1引入了一个新的类型提示`iterable`，它允许数组、`Iterators`或`Generators`作为参数。有关更多信息，请参阅：
- en: '[https://wiki.php.net/rfc/iterable](https://wiki.php.net/rfc/iterable)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://wiki.php.net/rfc/iterable](https://wiki.php.net/rfc/iterable)'
- en: 'For a background discussion on the rationale behind the implementation of scalar
    type hinting, have a look at this article:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有关标量类型提示实现背后的原理的背景讨论，请参阅本文：
- en: '[https://wiki.php.net/rfc/scalar_type_hints_v5](https://wiki.php.net/rfc/scalar_type_hints_v5)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://wiki.php.net/rfc/scalar_type_hints_v5](https://wiki.php.net/rfc/scalar_type_hints_v5)'
- en: Using return value data typing
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用返回值数据类型
- en: PHP 7 allows you to specify a data type for the return value of a function.
    Unlike scalar type hinting, however, you don't need to add any special declarations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7允许您为函数的返回值指定数据类型。然而，与标量类型提示不同，您不需要添加任何特殊声明。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This example shows you how to assign a data type to a function return value.
    To assign a return data type, first define the function as you would normally.
    After the closing parenthesis, add a space, followed by the data type and a colon:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个例子向您展示了如何为函数返回值分配数据类型。要分配返回数据类型，首先像通常一样定义函数。在右括号后面，加一个空格，然后是数据类型和一个冒号：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PHP 7.1 introduced a variation on return data typing called **nullable types**.
    All you need to do is to change `string` to `?string`. This allows the function
    to return either `string` or `NULL`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7.1引入了一种称为**可空类型**的返回数据类型的变体。您需要做的就是将`string`更改为`?string`。这允许函数返回`string`或`NULL`。
- en: 'Anything returned by the function, regardless of its data type inside the function,
    will be converted to the declared data type as a return value. Notice, in this
    example, the values of `$a`, `$b`, and `$c` are added together to produce a single
    sum, which is returned. Normally you would expect the return value to be a numeric
    data type. In this case, however, the return data type is declared as `string`,
    which overrides PHP''s type-juggling process:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数返回的任何东西，无论在函数内部的数据类型如何，都将被转换为声明的数据类型作为返回值。请注意，在这个例子中，将`$a`、`$b`和`$c`的值相加以产生一个单一的总和，然后返回。通常您会期望返回值是一个数字数据类型。然而，在这种情况下，返回数据类型被声明为`string`，这将覆盖PHP的类型转换过程：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can also assign classes as a return data type. In this example, we assign
    a return type of `DateTime`, part of the PHP `DateTime` extension:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以将类分配为返回数据类型。在这个例子中，我们将返回类型分配为PHP `DateTime`扩展的一部分的`DateTime`：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `makesDateTime()` function would be a potential candidate for scalar type
    hinting. If `$year`, `$month`, or `$day` are not integers, a `Warning` is generated
    when `setDate()` is called. If you use scalar type hinting, and the wrong data
    types are passed, a `TypeError` is thrown. Although it really doesn't matter whether
    a warning is generated or a `TypeError` is thrown, at least the `TypeError` will
    cause the errant developer who is misusing your code to sit up and take notice!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`makesDateTime()`函数将是标量类型提示的一个潜在候选。如果`$year`、`$month`或`$day`不是整数，在调用`setDate()`时会生成一个`Warning`。如果您使用标量类型提示，并且传递了错误的数据类型，将抛出`TypeError`。虽然生成警告或抛出`TypeError`并不重要，但至少`TypeError`会导致错误使用您的代码的开发人员警觉起来！'
- en: 'If a function has a return data type, and you return the wrong data type in
    your function code, a `TypeError` will be thrown at runtime. This function assigns
    a return type of `DateTime`, but returns a string instead. A `TypeError` will
    be thrown, but not until runtime, when the PHP engine detects the discrepancy:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个函数有一个返回数据类型，并且您在函数代码中返回了错误的数据类型，那么在运行时会抛出`TypeError`。这个函数分配了一个`DateTime`的返回类型，但返回了一个字符串。会抛出`TypeError`，但直到运行时，当PHP引擎检测到不一致时才会抛出：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the return data type class is not one of the built-in PHP classes (that is,
    a class that is part of the SPL), you will need to make sure the class has been
    auto-loaded, or included.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回数据类型类不是内置的PHP类之一（即SPL的一部分），则需要确保已自动加载或包含该类。
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, place the functions mentioned previously into a library file called
    `chap_03_developing_functions_return_types_library.php`. This file needs to be
    included in the `chap_03_developing_functions_return_types.php` script that calls
    these functions:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将前面提到的函数放入名为`chap_03_developing_functions_return_types_library.php`的库文件中。这个文件需要包含在调用这些函数的`chap_03_developing_functions_return_types.php`脚本中：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now you can call `returnsString()`, supplying a `DateTime` instance and a format
    string:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以调用`returnsString()`，提供一个`DateTime`实例和一个格式字符串：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As expected, the output is a string:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，输出是一个字符串：
- en: '![How it works...](graphics/B05314_03_07.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_03_07.jpg)'
- en: 'Now you can call `convertsToString()` and supply three integers as arguments.
    Notice that the return type is string:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以调用`convertsToString()`并提供三个整数作为参数。注意返回类型是字符串：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![How it works...](graphics/B05314_03_08.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_03_08.jpg)'
- en: 'To demonstrate that, you can assign a class as a return value, call `makesDateTime()`
    with three integer parameters:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，您可以将一个类分配为返回值，使用三个整数参数调用`makesDateTime()`：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![How it works...](graphics/B05314_03_09.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_03_09.jpg)'
- en: 'Finally, call `wrongDateTime()` with three integer parameters:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用三个整数参数调用`wrongDateTime()`：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Notice that a `TypeError` is thrown at runtime:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在运行时抛出了`TypeError`：
- en: '![How it works...](graphics/B05314_03_10.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_03_10.jpg)'
- en: There's more...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: PHP 7.1 adds a new return value type, `void`. This is used when you do not wish
    to return any value from the function. For more information, please refer to [https://wiki.php.net/rfc/void_return_type](https://wiki.php.net/rfc/void_return_type).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7.1添加了一个新的返回值类型，`void`。当您不希望从函数中返回任何值时使用。有关更多信息，请参阅[https://wiki.php.net/rfc/void_return_type](https://wiki.php.net/rfc/void_return_type)。
- en: See also
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information on return type declarations, see the following articles:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有关返回类型声明的更多信息，请参阅以下文章：
- en: '[http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration.strict](http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration.strict)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration.strict](http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration.strict)'
- en: '[https://wiki.php.net/rfc/return_types](https://wiki.php.net/rfc/return_types)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://wiki.php.net/rfc/return_types](https://wiki.php.net/rfc/return_types)'
- en: 'For information on nullable types, please refer to this article:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可空类型的信息，请参阅本文：
- en: '[https://wiki.php.net/rfc/nullable_types](https://wiki.php.net/rfc/nullable_types)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://wiki.php.net/rfc/nullable_types](https://wiki.php.net/rfc/nullable_types)'
- en: Using iterators
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迭代器
- en: An **iterator** is a special type of class that allows you to **traverse** a
    *container* or list. The keyword here is *traverse*. What this means is that the
    iterator provides the means to go through a list, but it does not perform the
    traversal itself.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代器**是一种特殊类型的类，允许您**遍历**一个*容器*或列表。关键词在于*遍历*。这意味着迭代器提供了浏览列表的方法，但它本身不执行遍历。'
- en: The SPL provides a rich assortment of generic and specialized iterators designed
    for different contexts. The `ArrayIterator`, for example, is designed to allow
    object-oriented traversal of arrays. The `DirectoryIterator` is designed for filesystem
    scanning.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: SPL提供了丰富的通用和专门设计用于不同上下文的迭代器。例如，`ArrayIterator`被设计用于允许面向对象遍历数组。`DirectoryIterator`被设计用于文件系统扫描。
- en: Certain SPL iterators are designed to work with others, and add value. Examples
    include `FilterIterator` and `LimitIterator`. The former gives you the ability
    to remove unwanted values from the parent iterator. The latter provides a pagination
    capability whereby you can designate how many items to traverse along with an
    offset that determines where to start.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 某些SPL迭代器被设计用于与其他迭代器一起工作，并增加价值。示例包括`FilterIterator`和`LimitIterator`。前者使您能够从父迭代器中删除不需要的值。后者提供了分页功能，您可以指定要遍历多少项以及确定从何处开始的偏移量。
- en: Finally, there are a series of *recursive* iterators, which allow you to repeatedly
    call the parent iterator. An example would be `RecursiveDirectoryIterator` which
    scans a directory tree all the way from a starting point to the last possible
    subdirectory.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一系列*递归*迭代器，允许您重复调用父迭代器。一个例子是`RecursiveDirectoryIterator`，它从起始点扫描整个目录树，直到最后一个可能的子目录。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We first examine the `ArrayIterator` class. It's extremely easy to use. All
    you need to do is to supply an array as an argument to the constructor. After
    that you can use any of the methods that are standard to all SPL-based iterators,
    such as `current()`, `next()`, and so on.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先检查`ArrayIterator`类。它非常容易使用。您只需要将数组作为参数提供给构造函数。之后，您可以使用所有基于SPL的迭代器标准的方法，例如`current()`，`next()`等。
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using `ArrayIterator` converts a standard PHP array into an iterator. In a certain
    sense, this provides a bridge between procedural programming and OOP.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ArrayIterator`将标准PHP数组转换为迭代器。在某种意义上，这提供了过程式编程和面向对象编程之间的桥梁。
- en: 'As an example of a practical use for the iterator, have a look at this example.
    It takes an iterator and produces a series of HTML `<ul>` and `<li>` tags:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为迭代器的实际用途的一个例子，请查看这个例子。它接受一个迭代器并生成一系列HTML`<ul>`和`<li>`标签：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Alternatively, you can simply wrap the `ArrayIterator` instance into a simple
    `foreach()` loop:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您可以简单地将`ArrayIterator`实例包装到一个简单的`foreach()`循环中：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`CallbackFilterIterator` is a great way to add value to any existing iterator
    you might be using. It allows you to wrap any existing iterator and screen the
    output. In this example we''ll define `fetchCountryName()`, which iterates through
    a database query which produces a list of country names. First, we define an `ArrayIterator`
    instance from a query that uses the `Application\Database\Connection` class defined
    in [Chapter 1](ch01.html "Chapter 1. Building a Foundation"), *Building a Foundation*:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CallbackFilterIterator`是一种很好的方式，可以为您可能正在使用的任何现有迭代器增加价值。它允许您包装任何现有迭代器并筛选输出。在这个例子中，我们将定义`fetchCountryName()`，它遍历生成国家名称列表的数据库查询。首先，我们从使用[第1章](ch01.html
    "第1章。建立基础")中定义的`Application\Database\Connection`类的查询中定义一个`ArrayIterator`实例，*建立基础*：'
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we define a filter method, `nameFilterIterator()`, which accepts a partial
    country name as an argument along with the `ArrayIterator` instance:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个过滤方法`nameFilterIterator()`，它接受部分国家名称作为参数，以及`ArrayIterator`实例：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`LimitIterator` adds a basic pagination aspect to your applications. To use
    this iterator, you only need to supply the parent iterator, an offset, and a limit.
    `LimitIterator` will then only produce a subset of the entire data set starting
    at the offset. Taking the same example mentioned in step 2, we''ll paginate the
    results coming from our database query. We can do this quite simply by wrapping
    the iterator produced by the `fetchCountryName()` method inside a `LimitIterator`
    instance:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LimitIterator` 为您的应用程序添加了基本的分页功能。要使用此迭代器，您只需要提供父迭代器、偏移量和限制。`LimitIterator`
    将只产生从偏移量开始的整个数据集的子集。以步骤2中提到的相同示例为例，我们将对来自数据库查询的结果进行分页。我们可以通过简单地将`fetchCountryName()`方法生成的迭代器包装在`LimitIterator`实例中来实现这一点：'
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful when using `LimitIterator`. It needs to have the *entire* data set
    in memory in order to effect a limit. Accordingly, this would not be a good tool
    to use when iterating through large data sets.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`LimitIterator`时要小心。为了实现限制，它需要将*整个*数据集保存在内存中。因此，在迭代大型数据集时，这不是一个好工具。
- en: 'Iterators can be *stacked*. In this simple example, an `ArrayIterator` is processed
    by a `FilterIterator`, which in turn is limited by a `LimitIterator`. First we
    set up an instance of `ArrayIterator`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代器可以*堆叠*。在这个简单的例子中，`ArrayIterator`由`FilterIterator`处理，然后由`LimitIterator`限制。首先，我们设置一个`ArrayIterator`实例：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we plug the `ArrayIterator` into a `FilterIterator` instance. Note that
    we are using the new PHP 7 anonymous class feature. In this case the anonymous
    class extends `FilterIterator` and overrides the `accept()` method, allowing only
    letters with even-numbered ASCII codes:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将`ArrayIterator`插入`FilterIterator`实例中。请注意，我们正在使用新的PHP 7匿名类特性。在这种情况下，匿名类扩展了`FilterIterator`并覆盖了`accept()`方法，只允许具有偶数ASCII代码的字母：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, we supply the `FilterIterator` instance as an argument to `LimitIterator`,
    and provide an offset (`2` in this example) and a limit (`6` in this example):'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`FilterIterator`实例作为参数提供给`LimitIterator`，并提供偏移量（在本例中为`2`）和限制（在本例中为`6`）：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We could then define a simple function to display output, and call each iterator
    in turn to see the results on a simple array produced by `range(''A'', ''Z'')`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以定义一个简单的函数来显示输出，并依次调用每个迭代器，以查看由`range('A', 'Z')`生成的简单数组的结果：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here is a variation that produces every other letter by stacking a `FilterIterator`
    on top of an `ArrayIterator`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个变体，通过在`ArrayIterator`上堆叠`FilterIterator`来产生每隔一个字母：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And here''s yet another variation that only produces `F H J L N P`, which demonstrates
    a `LimitIterator` that consumes a `FilterIterator`, which in turn consumes an
    `ArrayIterator`. The output of these three examples is as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里还有另一个变体，它只产生`F H J L N P`，这演示了一个消耗`FilterIterator`的`LimitIterator`，而`FilterIterator`又消耗`ArrayIterator`。这三个示例的输出如下：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![How to do it...](graphics/B05314_03_12.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B05314_03_12.jpg)'
- en: Returning to our example that produces a list of country names, suppose, instead
    of only the country name, we wished to iterate through a multi-dimensional array
    consisting of country names and ISO codes. The simple iterators mentioned so far
    would not be sufficient. Instead, we will use what are known as **recursive**
    iterators.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到我们的例子，它产生了一个国家名称列表，假设我们希望迭代一个由国家名称和ISO代码组成的多维数组，而不仅仅是国家名称。到目前为止提到的简单迭代器是不够的。相反，我们将使用所谓的**递归**迭代器。
- en: 'First of all, we need to define a method that uses the database connection
    class mentioned previously to pull all columns from the database. As before, we
    return an `ArrayIterator` instance populated with data from the query:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要定义一个方法，该方法使用先前提到的数据库连接类从数据库中提取所有列。与以前一样，我们返回一个由查询数据填充的`ArrayIterator`实例：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'At first glance one would be tempted to simply wrap a standard `ArrayIterator`
    instance inside `RecursiveArrayIterator`. Unfortunately, this approach only performs
    a **shallow** iteration, and doesn''t give us what we want: an iteration through
    all elements of the multi-dimensional array that is returned from a database query:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 乍一看，人们可能会简单地将标准的`ArrayIterator`实例包装在`RecursiveArrayIterator`中。不幸的是，这种方法只执行**浅**迭代，并且不能给我们想要的：对从数据库查询返回的多维数组的所有元素进行迭代：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Although this returns an iteration where each item represents a row from the
    database query, in this case we wish to provide an iteration that will iterate
    through all columns of all rows returned by the query. In order to accomplish
    this, we'll need to roll out the big brass by way of a `RecursiveIteratorIterator`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然这返回一个迭代，其中每个项表示数据库查询的一行，但在这种情况下，我们希望提供一个迭代，该迭代将遍历查询返回的所有行的所有列。为了实现这一点，我们需要通过`RecursiveIteratorIterator`来展开大规模的操作。
- en: 'Monty Python fans will revel in the rich irony of this class name as it brings
    back fond memories of the *The Department of Redundancy Department*. Fittingly,
    this class causes our old friend the `RecursiveArrayIterator` class to work overtime
    and perform a **deep** iteration through all levels of the array:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 蒙提·派森的粉丝将沉浸在这个类名的丰富讽刺之中，因为它让人回忆起*多余部门*。恰当地，这个类让我们的老朋友`RecursiveArrayIterator`类加班工作，并对数组的所有级别进行**深度**迭代：
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As a practical example, you can develop a test script which implements filtering
    and pagination using iterators. For this illustration, you could call the `chap_03_developing_functions_filtered_and_paginated.php`
    test code file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个实际的例子，您可以开发一个测试脚本，使用迭代器实现过滤和分页。对于这个示例，您可以调用`chap_03_developing_functions_filtered_and_paginated.php`测试代码文件。
- en: First of all, following best practices, place the functions described above
    into an include file called `chap_03_developing_functions_iterators_library.php`.
    In the test script, be sure to include this file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照最佳实践，将上述描述的函数放入名为`chap_03_developing_functions_iterators_library.php`的包含文件中。在测试脚本中，确保包含此文件。
- en: 'The data source is a table called `iso_country_codes`, which contains ISO2,
    ISO3, and country names. The database connection could be in a `config/db.config.php`
    file. You could also include the `Application\Database\Connection` class discussed
    in the previous chapter:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源是一个名为`iso_country_codes`的表，其中包含ISO2、ISO3和国家名称。数据库连接可以在一个`config/db.config.php`文件中。您还可以包括在前一章中讨论的`Application\Database\Connection`类：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In PHP 7 you can define constants as arrays. In this example, `ITEMS_PER_PAGE`
    was defined as an array, and used to generate an HTML `SELECT` element.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中，您可以将常量定义为数组。在本例中，`ITEMS_PER_PAGE`被定义为一个数组，并用于生成HTML`SELECT`元素。
- en: 'Next, you can process input parameters for the country name and the number
    of items per page. The current page number will start at `0` and can be incremented
    (next page) or decremented (previous page):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以处理国家名称和每页项目数的输入参数。当前页码将从`0`开始，并且可以递增（下一页）或递减（上一页）：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now you''re ready to fire up the database connection and run a simple `SELECT`
    query. This should be placed in a `try {} catch {}` block. You can then place
    the iterators to be stacked inside the `try {}` block:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好启动数据库连接并运行一个简单的`SELECT`查询。这应该放在`try {} catch {}`块中。然后，您可以将要堆叠的迭代器放在`try
    {}`块内：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we''re ready for the HTML. In this simple example we present a form that
    lets the user select the number of items per page and the country name:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好进行HTML编写。在这个简单的例子中，我们提供一个表单，让用户选择每页的项目数和国家名称：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output will look something like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将看起来像这样：
- en: '![How it works...](graphics/B05314_03_13.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_03_13.jpg)'
- en: 'Finally, in order to test the recursive iteration of the country database lookup,
    you will need to include the iterator''s library file, as well as the `Application\Database\Connection`
    class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了测试国家数据库查找的递归迭代，您需要包括迭代器的库文件，以及`Application\Database\Connection`类：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As before, you should wrap your database query in a `try {} catch {}` block.
    You can then place the code to test the recursive iteration inside the `try {}`
    block:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，您应该将数据库查询放在`try {} catch {}`块中。然后，您可以将用于测试递归迭代的代码放在`try {}`块内：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here is what you can expect to see in terms of output from `RecursiveArrayIterator`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以期望从`RecursiveArrayIterator`输出的内容：
- en: '![How it works...](graphics/B05314_03_14.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_03_14.jpg)'
- en: 'Here is the output after using `RecursiveIteratorIterator`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`RecursiveIteratorIterator`后的输出如下：
- en: '![How it works...](graphics/B05314_03_15.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_03_15.jpg)'
- en: Writing your own iterator using generators
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用生成器编写自己的迭代器
- en: In the preceding set of recipes we demonstrated the use of iterators provided
    in the PHP 7 SPL. But what if this set doesn't provide you with what is needed
    for a given project? One solution would be to develop a function that, instead
    of building an array that is then returned, uses the `yield` keyword to return
    values progressively by way of iteration. Such a function is referred to as a
    **generator**. In fact, in the background, the PHP engine will automatically convert
    your function into a special built-in class called `Generator`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的一系列示例中，我们演示了PHP 7 SPL中提供的迭代器的使用。但是，如果这个集合不能满足给定项目的需求，该怎么办？一个解决方案是开发一个函数，该函数不是构建一个然后返回的数组，而是使用`yield`关键字通过迭代逐步返回值。这样的函数被称为**生成器**。实际上，在后台，PHP引擎将自动将您的函数转换为一个称为`Generator`的特殊内置类。
- en: There are several advantages to this approach. The main benefit is seen when
    you have a large container to traverse (that is, parsing a massive file). The
    traditional approach has been to build up an array, and then return that array.
    The problem with this is that you are effectively doubling the amount of memory
    required! Also, performance is affected in that results are only achieved once
    the final array has been returned.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有几个优点。主要好处在于当您有一个大容器要遍历时（即解析一个大文件），可以看到。传统的方法是构建一个数组，然后返回该数组。这样做的问题是您实际上需要的内存量翻倍！此外，性能受到影响，因为只有在最终数组被返回后才能实现结果。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this example we build on the library of iterator-based functions, adding
    a generator of our own design. In this case we will duplicate the functionality
    described in the section above on iterators where we stacked an `ArrayIterator`,
    `FilterIterator`, and `LimitIterator`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在基于迭代器的函数库上构建了一个我们自己设计的生成器。在这种情况下，我们将复制上面关于迭代器的部分中描述的功能，其中我们堆叠了`ArrayIterator`，`FilterIterator`和`LimitIterator`。
- en: 'Because we need access to the source array, the desired filter, page number,
    and number of items per page, we include the appropriate parameters into a single
    `filteredResultsGenerator()` function. We then calculate the offset based on the
    page number and limit (that is, number of items per page). Next, we loop through
    the array, apply the filter, and continue the loop if the offset has not yet been
    reached, or break if the limit has been reached:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们需要访问源数组、所需的过滤器、页码和每页项目数，所以我们将适当的参数包含到一个单独的`filteredResultsGenerator()`函数中。然后，我们根据页码和限制（即每页项目数）计算偏移量。接下来，我们循环遍历数组，应用过滤器，并在偏移量尚未达到时继续循环，或者在达到限制时中断：
- en: '[PRE52]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You'll notice the primary difference between this function and others is the
    `yield` keyword. The effect of this keyword is to signal the PHP engine to produce
    a `Generator` instance and encapsulate the code.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到这个函数和其他函数之间的主要区别是`yield`关键字。这个关键字的作用是向PHP引擎发出信号，产生一个`Generator`实例并封装代码。
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To demonstrate the use of the `filteredResultsGenerator()` function we'll have
    you implement a web application that scans a web page and produces a filtered
    and paginated list of URLs hoovered from `HREF` attributes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`filteredResultsGenerator()`函数的使用，我们将让您实现一个Web应用程序，该应用程序扫描一个网页并生成一个经过过滤和分页的URL列表，这些URL列表是从`HREF`属性中获取的。
- en: First you need to add the code for the `filteredResultsGenerator()` function
    to the library file used in the previous recipe, then place the functions described
    previously into an include file, `chap_03_developing_functions_iterators_library.php`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要将`filteredResultsGenerator()`函数的代码添加到先前配方中使用的库文件中，然后将先前描述的函数放入一个包含文件`chap_03_developing_functions_iterators_library.php`中。
- en: 'Next, define a test script, `chap_03_developing_functions_using_generator.php`,
    that includes both the function library as well as the file that defines `Application\Web\Hoover`,
    described in [Chapter 1](ch01.html "Chapter 1. Building a Foundation"), *Building
    a Foundation*:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个测试脚本`chap_03_developing_functions_using_generator.php`，其中包括函数库以及定义在[第1章](ch01.html
    "第1章。构建基础")中描述的`Application\Web\Hoover`文件，*构建基础*：
- en: '[PRE53]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You will then need to gather input from the user regarding which URL to scan,
    what string to use as a filter, how many items per page, and the current page
    number.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要从用户那里收集关于要扫描的URL，要用作过滤器的字符串，每页多少项以及当前页码的输入。
- en: Note
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **null coalesce** operator (`??`) is ideal for getting input from the Web.
    It does not generate any notices if not defined. If the parameter is not received
    from user input, you can supply a default.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**null coalesce**运算符(`??`)非常适合从Web获取输入。如果未定义，它不会生成任何通知。如果未从用户输入接收参数，则可以提供默认值。'
- en: '[PRE54]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Web security should always be a priority consideration. In this example you
    can use `strip_tags()` and also force the data type to integer `(int)` as measures
    to sanitize user input.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Web安全性应始终是优先考虑的。在此示例中，您可以使用`strip_tags()`，并将数据类型强制转换为整数`(int)`来消毒用户输入。
- en: 'You are then in a position to define variables used in links for previous and
    next pages in the paginated list. Note that you could also apply a *sanity check*
    to make sure the next page doesn''t go off the end of the result set. For the
    sake of brevity, such a sanity check was not applied in this example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以定义用于分页列表中上一页和下一页链接的变量。请注意，您还可以应用*健全性检查*，以确保下一页不会超出结果集的末尾。为简洁起见，本示例中未应用此类健全性检查：
- en: '[PRE55]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We then need to create an `Application\Web\Hoover` instance and grab `HREF`
    attributes from the target URL:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建一个`Application\Web\Hoover`实例，并从目标URL中获取`HREF`属性：
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, we define HTML output that renders an input form and runs our generator
    through the `htmlList()` function described previously:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了HTML输出，通过先前描述的`htmlList()`函数渲染输入表单并运行我们的生成器：
- en: '[PRE57]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here is an example of the output:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个输出的例子：
- en: '![How it works...](graphics/B05314_03_16.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_03_16.jpg)'
