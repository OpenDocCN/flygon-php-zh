- en: Working with Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数据库一起工作
- en: The PHP language has a pretty good support for several different databases. MySQL
    has been embraced by PHP developers as the go-to database ever since the early
    days of the PHP language. While the initial emphasis was mostly on **relational
    database management systems** (**RDBMS**), other types of databases proved to
    be equally (or more) important for modern applications. The document and data
    key-value databases have been growing in popularity ever since.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PHP语言对多种不同的数据库有很好的支持。自PHP语言早期以来，MySQL一直被PHP开发人员视为首选数据库。虽然最初的重点主要是**关系型数据库管理系统**（**RDBMS**），但其他类型的数据库在现代应用程序中同样（或更）重要。自文档和数据键值数据库以来，它们的受欢迎程度一直在增长。
- en: Nowadays, it is not uncommon to see a PHP application making use of MySQL, Mongo,
    Redis, and possibly a few more databases or data stores all at once.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，看到一个PHP应用程序同时使用MySQL、Mongo、Redis，可能还有其他几个数据库或数据存储是很常见的。
- en: The NoSQL ("non SQL", "non relational" or "not only SQL") nature of Mongo allows
    building applications that generate massive volumes of new and possibly rapidly
    changing data types. Relieved from the strictness of **SQL** (**Structured Query
    Language**), working with structured, semi-structured, unstructured, and polymorphic
    data becomes a whole new experience with the Mongo database. The in-memory data
    structure stores such as Redis strive on speed, which makes them great to cache
    and message broker systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Mongo的NoSQL（“非SQL”，“非关系”或“不仅仅是SQL”）特性允许构建生成大量新数据类型的应用程序，这些数据类型可能会迅速变化。摆脱了**SQL**（**结构化查询语言**）的严格性，使用结构化、半结构化、非结构化和多态数据与Mongo数据库一起成为全新的体验。像Redis这样的内存数据结构存储器以速度为目标，这使它们非常适合缓存和消息代理系统。
- en: 'In this chapter, we will take a closer look at MySQL, Mongo, and Redis through
    the following sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过以下部分更详细地了解MySQL、Mongo和Redis：
- en: Working with MySQL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MySQL
- en: Installing MySQL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装MySQL
- en: Setting up sample data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置示例数据
- en: Querying via the mysqli driver extension
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过mysqli驱动程序扩展进行查询
- en: Querying via the PHP Data Objects driver extension
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过PHP数据对象驱动程序扩展进行查询
- en: Working with MongoDB
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MongoDB
- en: Installing MongoDB
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装MongoDB
- en: Setting up sample data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置示例数据
- en: Querying via the MongoDB driver extension
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过MongoDB驱动程序扩展进行查询
- en: Working with Redis
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redis
- en: Installing Redis
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Redis
- en: Setting up sample data
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置示例数据
- en: Querying via the phpredis driver extension
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过phpredis驱动程序扩展进行查询
- en: Throughout this chapter, we provide quick installation instructions for each
    of the three database servers. These instructions are given on a relatively basic
    level, without any post-installation configuration or tuning that is usually done
    on production-type machines. The general idea here was to merely get the developer
    machine up and running with each of the database servers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为三个数据库服务器提供了快速安装说明。这些说明在相对基本的水平上给出，没有进行通常在生产类型机器上进行的任何后安装配置或调整。这里的一般想法只是让开发者的机器能够运行每个数据库服务器。
- en: Working with MySQL
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MySQL
- en: MySQL is an open source RDBMS that has been around for over 20 years now. Originally
    developed and owned by the Swedish company MySQL AB, it is now owned by Oracle
    Corporation. The current stable version of MySQL is 5.7.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL是一个开源的关系型数据库管理系统，已经存在了20多年。最初由瑞典公司MySQL AB开发和拥有，现在由Oracle Corporation拥有。MySQL的当前稳定版本是5.7。
- en: 'Some of the key strengths of MySQL can be outlined as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL的一些关键优势可以概括如下：
- en: Cross-platform, runs on server
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨平台，在服务器上运行
- en: Can be used for desktop and web applications
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于桌面和Web应用程序
- en: Fast, reliable, and easy to use
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速、可靠且易于使用
- en: Good for small and large applications
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于小型和大型应用程序
- en: Uses standard SQL
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准SQL
- en: Supports query caching
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持查询缓存
- en: Supports Unicode
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持Unicode
- en: ACID compliance when using InnoDB
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用InnoDB时的ACID兼容性
- en: Transactions when using InnoDB
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用InnoDB时的事务
- en: Installing MySQL
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装MySQL
- en: 'Assuming we are using the fresh Ubuntu 16.10 (Yakkety Yak) installation, the
    following steps outline how we can set up MySQL:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用的是新的Ubuntu 16.10（Yakkety Yak）安装，以下步骤概述了我们如何设置MySQL：
- en: 'To install MySQL, we execute the following console commands:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装MySQL，我们执行以下控制台命令：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The installation process triggers a console GUI interface that asks us to enter
    a `root` user password:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装过程会触发一个控制台GUI界面，要求我们输入`root`用户密码：
- en: '![](assets/7f664b9e-a662-4d17-9720-59a7faa92dcf.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7f664b9e-a662-4d17-9720-59a7faa92dcf.png)'
- en: 'The provided password needs to be repeated for confirmation purposes:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供的密码需要重复以确认：
- en: '![](assets/15b71313-29a0-484f-a4dd-dfe8720e51b7.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/15b71313-29a0-484f-a4dd-dfe8720e51b7.png)'
- en: 'Once the installation is done, we can execute the following `mysql --version`
    command to confirm if the MySQL server is up and running:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以执行以下`mysql --version`命令来确认MySQL服务器是否正在运行：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the server is running, we need to secure the installation. This is done
    by running the following command:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器运行后，我们需要保护安装。通过运行以下命令来完成：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The secure installation process triggers an interactive shell with several
    prompts, asking for the following information:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全安装过程会触发一个交互式shell，要求提供以下信息：
- en: 'Enter password for user root:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入root用户的密码：
- en: Would you like to setup VALIDATE PASSWORD plugin?
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否要设置VALIDATE PASSWORD插件？
- en: 'Please enter 0 = LOW, 1 = MEDIUM and 2 = STRONG:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请输入0 = 低，1 = 中等和2 = 强：
- en: 'New password:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新密码：
- en: 'Re-enter new password:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新输入新密码：
- en: Remove anonymous users?
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除匿名用户？
- en: Disallow root login remotely?
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁止远程root登录？
- en: Remove test database and access to it?
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除测试数据库和对其的访问？
- en: Reload privilege tables now?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在重新加载权限表？
- en: 'The following screenshot depicts this process:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图描述了这个过程：
- en: '![](assets/d8d43bee-0866-40bc-833e-396789e3bab1.png)Check out [https://dev.mysql.com/doc/refman/5.7/en/validate-password-plugin.html](https://dev.mysql.com/doc/refman/5.7/en/validate-password-plugin.html)
    for more information about the password validation plugin.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/d8d43bee-0866-40bc-833e-396789e3bab1.png)查看[https://dev.mysql.com/doc/refman/5.7/en/validate-password-plugin.html](https://dev.mysql.com/doc/refman/5.7/en/validate-password-plugin.html)获取有关密码验证插件的更多信息。'
- en: 'Once the secure installation process is done, we can go ahead and connect to
    MySQL using the `mysql` console tool, as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装安全完成后，我们可以继续并使用`mysql`控制台工具连接到MySQL，如下所示：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice the use of the single quote character (`''`) around the password. While
    normally we could use the `"` or `''` quotes, the `!` char used in password forces
    us to use `''`. Without wrapping the password in a single quote, in this case,
    we will be seeing an error like !Tq: event not found. This is because the exclamation
    mark (`!`) is a part of the history expansion in bash. To use it as a part of
    the password, we need to enclose it in single quotes. Furthermore, our passwords
    can contain the `''` or `"` characters. To escape these quotes in the password,
    we can either use a leading backslash (), or enclose the entire argument in the
    opposite style of quotes. However, the simplest and safest way to get around quirky
    password characters is to avoid assigning the password value with `-p` or `--password`
    arguments, and provide the password through the Enter password: prompt.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意在密码周围使用单引号字符（`''`）。虽然通常我们可以使用`"`或`''`引号，但密码中使用的`!`字符强制我们使用`''`。在这种情况下，如果不用单引号括起密码，我们将看到类似于!Tq:
    event not found的错误。这是因为感叹号（`!`）是bash中的历史扩展的一部分。为了将其用作密码的一部分，我们需要将其括在单引号中。此外，我们的密码可以包含`''`或`"`字符。为了转义密码中的这些引号，我们可以使用前导反斜杠（\），或者用相反样式的引号将整个参数括起来。然而，解决古怪密码字符的最简单和最安全的方法是避免使用`-p`或`--password`参数分配密码值，并通过`输入密码：`提示提供密码。'
- en: 'This should give us the following output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们以下输出：
- en: '![](assets/ace8ab7e-822e-4aa2-aeee-6539546b5240.png)Check out [https://dev.mysql.com/doc/refman/5.7/en/mysql-shell.html](https://dev.mysql.com/doc/refman/5.7/en/mysql-shell.html)
    for more information about the MySQL shell.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/ace8ab7e-822e-4aa2-aeee-6539546b5240.png)查看[https://dev.mysql.com/doc/refman/5.7/en/mysql-shell.html](https://dev.mysql.com/doc/refman/5.7/en/mysql-shell.html)获取有关MySQL
    shell的更多信息。'
- en: Setting up sample data
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置示例数据
- en: 'Before we move onto querying MySQL, let''s go ahead and set up some sample
    data. MySQL provides a sample database called Sakila, which we can download from
    the official MySQL site, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续查询MySQL之前，让我们先设置一些示例数据。MySQL提供了一个名为Sakila的示例数据库，我们可以从官方MySQL网站下载，如下所示：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once downloaded and unpacked, this should give us the following three files:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并解压缩后，这应该给我们以下三个文件：
- en: '![](assets/ea9fa1b3-cc77-4f8b-be21-392a783d5243.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ea9fa1b3-cc77-4f8b-be21-392a783d5243.png)'
- en: 'Moving forward, we need to see how we can import `sakila-schema.sql` and `sakila-data.sql`.
    Luckily, MySQL provides several ways to do this. A quick look at the `sakila-schema.sql`
    file shows the following entries at the top of the file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要看看如何导入`sakila-schema.sql`和`sakila-data.sql`。幸运的是，MySQL提供了几种方法来做到这一点。快速查看`sakila-schema.sql`文件显示了文件顶部的以下条目：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This means that the `sakila-schema.sql` file will create a schema (database)
    for us, as well as set it as currently used database. This is an important bit
    to understand, as not all of the `.sql` / backup files will have this, and we
    will be forced to do this part manually. Knowing how `sakila-schema.sql` handles
    everything we need to import it, the following commands show three different approaches
    we can use:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`sakila-schema.sql`文件将为我们创建一个模式（数据库），并将其设置为当前使用的数据库。这是一个重要的部分需要理解，因为并非所有的`.sql`
    / 备份文件都会有这个，我们将被迫手动执行这一部分。了解`sakila-schema.sql`如何处理我们需要导入的所有内容后，以下命令显示了我们可以使用的三种不同方法：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second command uses the `-e` (`--execute`)  argument to pass SQL statements
    to the server. We could have easily used the `mysql` tool interactively and then executed `SOURCE
    sakila-schema.sql` within it. With the schema in place, we can go ahead and import
    the actual data:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令使用`-e` (`--execute`)参数将SQL语句传递给服务器。我们本可以轻松地在交互式中使用`mysql`工具，然后在其中执行`SOURCE
    sakila-schema.sql`。有了架构，我们可以继续导入实际数据：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we now use the `mysql` tool interactively, we can check if the database
    is imported successfully:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在交互式使用`mysql`工具，我们可以检查数据库是否成功导入：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This should give us the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们以下输出：
- en: '![](assets/2b3df6df-212e-4f2d-919f-029daa68b9c7.png)Check out [https://dev.mysql.com/doc/sakila/en/](https://dev.mysql.com/doc/sakila/en/)
    for more information about the Sakila sample database.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2b3df6df-212e-4f2d-919f-029daa68b9c7.png)查看[https://dev.mysql.com/doc/sakila/en/](https://dev.mysql.com/doc/sakila/en/)获取有关Sakila示例数据库的更多信息。'
- en: Querying via the MySQLi driver extension
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过MySQLi驱动程序扩展查询
- en: 'There are several driver extensions that allow us to query MySQL. MySQLi is
    one of them. In order to use MySQLi on the console, we need to ensure that we
    have the PHP CLI and `mysql` driver extension installed:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个驱动程序扩展允许我们查询MySQL。MySQLi是其中之一。为了在控制台上使用MySQLi，我们需要确保已安装PHP CLI和`mysql`驱动程序扩展：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the name of the extension lacks the `i` suffix. Once the `mysql` driver
    extension is installed, we can go ahead and start querying the MySQL server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意扩展名缺少`i`后缀。安装了`mysql`驱动程序扩展后，我们可以继续并开始查询MySQL服务器。
- en: Connecting
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接
- en: 'We can either use the MySQLi functions or classes to interact with MySQL. In
    the spirit of OOP, we will use the class approach for all of our examples. Using
    the `mysqli` class, we can establish a MySQL connection from PHP, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用MySQLi函数或类与MySQL交互。为了面向对象编程，我们将在所有示例中使用类方法。使用`mysqli`类，我们可以从PHP建立与MySQL的连接，如下所示：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This single line expression will look for MySQL on the `127.0.0.1` host and
    try to connect to its `sakila` database using the `root` username and `mL08e!Tq` as
    its password.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行表达式将在`127.0.0.1`主机上查找MySQL，并尝试使用`root`用户名和`mL08e!Tq`作为密码连接到其`sakila`数据库。
- en: Error handling
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'Handling errors around `mysqli` is relatively easy as we can use a simple `try...catch`
    block, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理`mysqli`的错误时相对容易，因为我们可以使用简单的`try...catch`块，如下所示：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Ideally, we would want to use `mysqli_sql_exception` for more targeted MySQL
    exceptions-only handling:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望只针对MySQL异常使用`mysqli_sql_exception`进行处理：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can pass one of the following report levels to the `mysqli_report()` function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将以下报告级别之一传递给`mysqli_report()`函数：
- en: '`MYSQLI_REPORT_INDEX`: This reports if a bad index or no index at all was used
    in a query'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MYSQLI_REPORT_INDEX`: 这报告查询中是否使用了错误的索引或根本没有使用索引'
- en: '`MYSQLI_REPORT_ERROR`: This reports errors from the MySQL function calls'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MYSQLI_REPORT_ERROR`: 这报告来自MySQL函数调用的错误'
- en: '`MYSQLI_REPORT_STRICT`: This reports `mysqli_sql_exception` instead of possible
    warnings'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MYSQLI_REPORT_STRICT`: 这报告`mysqli_sql_exception`而不是可能的警告'
- en: '`MYSQLI_REPORT_ALL`: This reports everything'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MYSQLI_REPORT_ALL`: 这报告所有内容'
- en: '`MYSQLI_REPORT_OFF`: This reports nothing'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MYSQLI_REPORT_OFF`: 这不报告任何内容'
- en: While `MYSQLI_REPORT_ALL` may seem like an overkill, using it may pinpoint MySQL
    errors that are not obvious on the application level, such as the lack of an index
    on a column.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`MYSQLI_REPORT_ALL`可能看起来有些过度，但使用它可以准确定位应用程序级别不明显的MySQL错误，比如某列缺乏索引。
- en: Selecting
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择
- en: 'We can select data from MySQL using the `query()` method of a `mysqli` instance,
    as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`mysqli`实例的`query()`方法从MySQL中选择数据，如下所示：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding example gives the following error:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子会产生以下错误：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we have used `MYSQLI_REPORT_STRICT` instead of `MYSQLI_REPORT_ALL`, we would
    not have got the error. However, using less restrictive error reporting is not
    a solution for mitigating the error. Even though we might not be in charge of
    the database architecture and maintenance, it is our duty as a developer to report
    overlooks like these as they will most definitely affect our application performance.
    A solution, in this case, is to actually create an index on the email column.
    We can do so easily via the following query:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`MYSQLI_REPORT_STRICT`而不是`MYSQLI_REPORT_ALL`，我们就不会得到错误。然而，使用较少限制的错误报告并不是解决错误的办法。即使我们可能不负责数据库架构和维护，作为开发人员，我们有责任报告这些问题，因为它们肯定会影响我们应用程序的性能。在这种情况下，解决方案是实际上在email列上创建一个索引。我们可以通过以下查询轻松实现：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](assets/03089aff-be4e-4585-965d-fe41c12c0b33.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/03089aff-be4e-4585-965d-fe41c12c0b33.png)'
- en: '`idx_email` is the freely given name of the index we are creating, while `email`
    is the column for which we are creating an index. The `idx_` prefix is merely
    a matter of convention some developers use; the index can easily be named `xyz`
    or just `email`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`idx_email`是我们要创建的索引的自由给定名称，而`email`是我们要创建索引的列。`idx_`前缀只是一些开发人员使用的约定，索引可以轻松地命名为`xyz`或只是`email`。'
- en: 'With the index in place, if we now try to execute the previous code, it should
    output MARIA MILLER, as shown in the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有了索引之后，如果我们现在尝试执行之前的代码，它应该输出MARIA MILLER，如下面的屏幕截图所示：
- en: '![](assets/80f364e5-0d24-403b-85d8-5184b001d2f7.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/80f364e5-0d24-403b-85d8-5184b001d2f7.png)'
- en: 'The `query()` method returns either the `mysqli_result` object or the `True`
    and `False` Boolean value, based on the following type:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`query()`方法根据以下类型返回`mysqli_result`对象或`True`和`False`布尔值：'
- en: '`SELECT` type of query - `mysqli_result` object or Boolean `False`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT`类型的查询 - `mysqli_result`对象或布尔值`False`'
- en: '`SHOW` type of query - `mysqli_result` object or Boolean `False`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHOW`类型的查询 - `mysqli_result`对象或布尔值`False`'
- en: '`DESCRIBE` type of query - `mysqli_result` object or Boolean `False`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DESCRIBE`类型的查询 - `mysqli_result`对象或布尔值`False`'
- en: '`EXPLAIN` type of query - `mysqli_result` object or Boolean `False`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPLAIN`类型的查询 - `mysqli_result`对象或布尔值`False`'
- en: other types of queries - Boolean `True` or `False`
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他类型的查询 - 布尔值`True`或`False`
- en: 'The instance of the `mysqli_result` object has several different result fetching
    methods:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysqli_result`对象的实例有几种不同的结果获取方法：'
- en: '`fetch_object()`: This fetches the current row of a result set as an object,
    and allows being called repeatedly'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_object()`: 这将结果集的当前行作为对象获取，并允许重复调用'
- en: '`fetch_all()`: This fetches all result rows as either `MYSQLI_ASSOC`, `MYSQLI_NUM`,
    or `MYSQLI_BOTH`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_all()`: 这将以`MYSQLI_ASSOC`、`MYSQLI_NUM`或`MYSQLI_BOTH`的形式获取所有结果行'
- en: '`fetch_array()`: This fetches a single result row as either `MYSQLI_ASSOC`,
    `MYSQLI_NUM`, or `MYSQLI_BOTH`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_array()`: 这将以`MYSQLI_ASSOC`、`MYSQLI_NUM`或`MYSQLI_BOTH`的形式获取单个结果行'
- en: '`fetch_assoc()`: This fetches a single result row as an associative array,
    and allows being called repeatedly'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_assoc()`: 这将以关联数组的形式获取单个结果行，并允许重复调用'
- en: '`fetch_field()`: This fetches the next field in the result set, and allows
    being called repeatedly'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_field()`: 这获取结果集中的下一个字段，并允许重复调用'
- en: '`fetch_field_direct()`: This fetches meta-data for a single field'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_field_direct()`: 这获取单个字段的元数据'
- en: '`fetch_fields()`: This fetches meta-data for fields in an entire result set'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_fields()`: 这获取整个结果集中字段的元数据'
- en: '`fetch_row()`: This fetches a single result row as an enumerated array and allows
    being called repeatedly'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_row()`: 这以枚举数组的形式获取单个结果行，并允许重复调用'
- en: Binding parameters
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定参数
- en: 'More often than not, querying data comes with data binding. Security-wise,
    data binding is the way to go, as we should never concatenate query string with
    variables on our own. This leads to SQL injection attacks. We can bind data into
    a query using the `prepare()` and `bind_param()` methods of the respective `mysqli`
    and `mysqli_stmt` instances, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 更多时候，查询数据都伴随着数据绑定。从安全角度来看，数据绑定是正确的做法，因为我们不应该自己将查询字符串与变量连接起来。这会导致SQL注入攻击。我们可以使用相应的`mysqli`和`mysqli_stmt`实例的`prepare()`和`bind_param()`方法将数据绑定到查询中，如下所示：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This should give us the following output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们以下输出：
- en: '![](assets/f135143d-8a93-4901-9830-db2de28fa206.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f135143d-8a93-4901-9830-db2de28fa206.png)'
- en: 'The `bind_param()` method has an interesting syntax. It accepts two or more
    parameters. The first parameter--the `$types` string--contains one or more characters.
    These characters specify the types for the corresponding bind variables:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind_param()`方法有一个有趣的语法。它接受两个或更多参数。第一个参数——`$types`字符串——包含一个或多个字符。这些字符指定了相应绑定变量的类型：'
- en: '`i`: This is the variable of a type integer'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`：这是一个整数类型的变量'
- en: '`d`: This is the variable of a type double'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`：这是一个双精度类型的变量'
- en: '`s`: This is the variable of a type string'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`：这是一个字符串类型的变量'
- en: '`b`: This is the variable of a type blob'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`：这是一个blob类型的变量'
- en: 'The second and all of the following parameters represent the binding variables.
    Our example uses `''iis''` for the `$types` parameter, which basically reads the
    `bind_param()` method and its parameters as: bind integer type (`$customerIdGt`), integer
    type (`$storeId`), and string type (`$email`).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个及其后的所有参数代表绑定变量。我们的示例使用`'iis'`作为`$types`参数，基本上读取`bind_param()`方法及其参数为：绑定整数类型（`$customerIdGt`）、整数类型（`$storeId`）和字符串类型（`$email`）。
- en: Inserting
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入
- en: 'Now that we have learned how to prepare a query and bind data to it, inserting
    new records becomes pretty easy:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何准备查询并将数据绑定到它，插入新记录变得非常容易：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The example here pretty much follows the previous one where we introduced binding.
    The obvious difference merely lies in the actual `INSERT INTO` SQL expression.
    It goes without saying that `mysqli` does not have separate PHP classes or methods
    to handle selecting, inserting, or any other action.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的示例基本上遵循了之前介绍的绑定。明显的区别仅在于实际的`INSERT INTO` SQL表达式。不用说，`mysqli`没有单独的PHP类或方法来处理选择、插入或任何其他操作。
- en: Updating
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新
- en: 'Much like selecting and inserting, we can also use the `prepare()`, `bind_param()`,
    and `execute()` methods to handle record updating, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与选择和插入类似，我们也可以使用`prepare()`、`bind_param()`和`execute()`方法来处理记录更新，如下所示：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Deleting
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除
- en: 'Again, we can use the `prepare()`, `bind_param()`, and `execute()` methods
    to handle record deleting, as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`prepare()`、`bind_param()`和`execute()`方法来处理记录删除，如下所示：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Transactions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务
- en: 'While the `SELECT`, `INSERT`, `UPDATE`, and `DELETE` methods allow us to manipulate
    data in a step-by-step manner, the real strength of MySQL lies in transactions.
    Using the `begin_transaction()`, `commit()`, `commit()`, and `rollback()` methods
    of an `mysqli` instance, we are able to control the transaction features of MySQL:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`SELECT`、`INSERT`、`UPDATE`和`DELETE`方法允许我们逐步操纵数据，但MySQL的真正优势在于事务。使用`mysqli`实例的`begin_transaction()`、`commit()`、`commit()`和`rollback()`方法，我们能够控制MySQL的事务特性：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The valid transaction flags are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的事务标志如下：
- en: '`MYSQLI_TRANS_START_READ_ONLY`: This matches the MySQL `START TRANSACTION READ
    ONLY` query'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MYSQLI_TRANS_START_READ_ONLY`：这与MySQL的`START TRANSACTION READ ONLY`查询相匹配'
- en: '`MYSQLI_TRANS_START_READ_WRITE`: This matches the MySQL `START TRANSACTION
    READ WRITE` query'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MYSQLI_TRANS_START_READ_WRITE`：这与MySQL的`START TRANSACTION READ WRITE`查询相匹配'
- en: '`MYSQLI_TRANS_START_WITH_CONSISTENT_SNAPSHOT`: This matches the MySQL `START
    TRANSACTION WITH CONSISTENT SNAPSHOT` query'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MYSQLI_TRANS_START_WITH_CONSISTENT_SNAPSHOT`：这与MySQL的`START TRANSACTION WITH
    CONSISTENT SNAPSHOT`查询相匹配'
- en: Check out [https://dev.mysql.com/doc/refman/5.7/en/commit.html](https://dev.mysql.com/doc/refman/5.7/en/commit.html)
    for more information about the MySQL transaction syntax and meaning.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[https://dev.mysql.com/doc/refman/5.7/en/commit.html](https://dev.mysql.com/doc/refman/5.7/en/commit.html)以获取有关MySQL事务语法和含义的更多信息。
- en: Querying via the PHP Data Objects driver extension
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过PHP数据对象驱动扩展进行查询
- en: The **PHP Data Objects** (**PDO**) driver extension comes with PHP by default,
    ever since PHP 5.1.0.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**PHP数据对象**（**PDO**）驱动扩展自PHP 5.1.0以来就默认包含在PHP中。'
- en: Connecting
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接
- en: 'Using the PDO driver extension, we can connect to a MySQL database from PHP
    using the `PDO` class, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PDO驱动扩展，我们可以使用`PDO`类从PHP连接到MySQL数据库，如下所示：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This simple multiline expression will look for MySQL on the `127.0.0.1` host
    and try to connect to its `sakila` database using the `root` username and `mL08e!Tq`
    password.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的多行表达式将在`127.0.0.1`主机上查找MySQL，并尝试使用`root`用户名和`mL08e!Tq`密码连接到其`sakila`数据库。
- en: Error handling
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'Handling errors around PDO can be done using the special `PDOException` class,
    as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在PDO周围处理错误可以使用特殊的`PDOException`类，如下所示：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There are three different error modes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种不同的错误模式：
- en: '`ERRMODE_SILENT`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERRMODE_SILENT`'
- en: '`ERRMODE_WARNING`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERRMODE_WARNING`'
- en: '`ERRMODE_EXCEPTION`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERRMODE_EXCEPTION`'
- en: Here, we are using `ERRMODE_EXCEPTION` in order to utilize the `try...catch`
    blocks.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`ERRMODE_EXCEPTION`来利用`try...catch`块。
- en: Selecting
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择
- en: 'Querying for records with `PDO` is somewhat similar to querying for records
    with `mysqli`. We use raw SQL statements in both cases. The difference lies in
    the convenience of PHP methods and the subtle differences they provide. The following
    example demonstrates how we can select records from a MySQL table:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`PDO`查询记录与通过`mysqli`查询记录有些类似。在两种情况下，我们都使用原始的SQL语句。区别在于PHP方法的便利性和它们提供的微妙差异。以下示例演示了我们如何从MySQL表中选择记录：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This gives the following output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](assets/ba1f9b0a-105f-4977-9655-96ca820db1b1.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ba1f9b0a-105f-4977-9655-96ca820db1b1.png)'
- en: 'The instance of the `PDOStatement` and `$result` object has several different
    result-fetching methods:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`PDOStatement`实例和`$result`对象有几种不同的结果提取方法：'
- en: '`fetch()`: This fetches the next row from a result set, allows being called repeatedly,
    and returns a value depending on the fetch style'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch()`：这从结果集中提取下一行，允许重复调用，并根据提取样式返回一个值'
- en: '`fetchAll()`: This fetches all of the result set rows as an array, and returns
    a value depending on the fetch style'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchAll()`：这将结果集中的所有行作为数组提取出来，并根据提取样式返回一个值'
- en: '`fetchObject()`: This fetches the next row from a result set as an object,
    and allows being called repeatedly'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchObject()`：这从结果集中提取下一行作为对象，并允许重复调用'
- en: '`fetchColumn()`: This fetches a single column from the next row of a result
    set, and allows being called repeatedly'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchColumn()`：这从结果集的下一行中提取单个列，并允许重复调用'
- en: 'The following list shows available PDO fetch styles:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了可用的PDO获取样式：
- en: '`PDO::FETCH_LAZY`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_LAZY`'
- en: '`PDO::FETCH_ASSOC`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_ASSOC`'
- en: '`PDO::FETCH_NUM`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_NUM`'
- en: '`PDO::FETCH_BOTH`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_BOTH`'
- en: '`PDO::FETCH_OBJ`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_OBJ`'
- en: '`PDO::FETCH_BOUND`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_BOUND`'
- en: '`PDO::FETCH_COLUMN`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_COLUMN`'
- en: '`PDO::FETCH_CLASS`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_CLASS`'
- en: '`PDO::FETCH_INTO`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_INTO`'
- en: '`PDO::FETCH_FUNC`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_FUNC`'
- en: '`PDO::FETCH_GROUP`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_GROUP`'
- en: '`PDO::FETCH_UNIQUE`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_UNIQUE`'
- en: '`PDO::FETCH_KEY_PAIR`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_KEY_PAIR`'
- en: '`PDO::FETCH_CLASSTYPE`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_CLASSTYPE`'
- en: '`PDO::FETCH_SERIALIZE`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_SERIALIZE`'
- en: '`PDO::FETCH_PROPS_LATE`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_PROPS_LATE`'
- en: '`PDO::FETCH_NAMED`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_NAMED`'
- en: While most of these fetch styles are quite self-explanatory, we can consult [http://php.net/manual/en/pdo.constants.php](http://php.net/manual/en/pdo.constants.php) for
    further details.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数这些获取样式都相当不言自明，我们可以查阅[http://php.net/manual/en/pdo.constants.php](http://php.net/manual/en/pdo.constants.php)以获取更多细节。
- en: 'The following example demonstrates a more elaborate select approach, one with
    parameter binding in the mix:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了更为详细的选择方法，其中包含参数绑定：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This gives the following output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '![](assets/083fe023-37f4-4e94-b8c7-a181425e22ef.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/083fe023-37f4-4e94-b8c7-a181425e22ef.png)'
- en: The most obvious difference between binding with `PDO` and binding with `mysqli`
    is that `PDO` allows named parameter binding. This makes for much more readable
    queries.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PDO`和`mysqli`绑定的最明显区别是`PDO`允许命名参数绑定。这使得查询更加可读。
- en: Inserting
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入
- en: 'Much like selecting, inserting involves the same set of PDO methods wrapped
    around the `INSERT INTO` SQL statement:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 就像选择一样，插入涉及相同一组包裹在`INSERT INTO` SQL语句周围的PDO方法：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Updating
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新
- en: 'Much like selecting and inserting, updating involves the same set of PDO methods
    wrapped around the `UPDATE` SQL statement:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 就像选择和插入一样，更新涉及相同一组包裹在`UPDATE` SQL语句周围的PDO方法：
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Deleting
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除
- en: 'Much like selecting, inserting, and updating, deleting involves the same set
    of PDO methods wrapped around the `DELETE FROM` SQL statement:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 就像选择、插入和更新一样，删除涉及相同一组包裹在`DELETE FROM` SQL语句周围的PDO方法：
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Transactions
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务
- en: 'Transactions with PDO are not much different from those with MySQLi. Utilizing
    the `beginTransaction()`, `commit()`, and `rollback()` methods of the `PDO` instance,
    we are able to control the transaction features of MySQLi:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与MySQLi一样，PDO的事务与MySQLi的事务并没有太大不同。通过利用`PDO`实例的`beginTransaction()`、`commit()`和`rollback()`方法，我们能够控制MySQLi的事务特性：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Working with MongoDB
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB
- en: MongoDB is a free and open source NoSQL database developed by MongoDB Inc.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是由MongoDB Inc.开发的免费开源NoSQL数据库。
- en: 'Some of the key strengths of MongoDB can be outlined as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的一些关键优势可以概括如下：
- en: It is a document-based database
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个基于文档的数据库
- en: It is cross-platform
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是跨平台的
- en: It runs on a single server as well as on distributed architectures
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它既可以在单个服务器上运行，也可以在分布式架构上运行
- en: It can be used for desktop and web applications
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以用于桌面和Web应用程序
- en: It uses JSON objects to store data
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用JSON对象来存储数据
- en: It can use JavaScript map-reduce for information processing at the server side
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在服务器端使用JavaScript map-reduce进行信息处理
- en: It processes large volumes of data
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它处理大量数据
- en: It aggregates calculations
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它聚合计算
- en: It supports fields, range queries, and regular expression searches
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持字段、范围查询和正则表达式搜索
- en: It is a native replication
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是本地复制
- en: Installing MongoDB
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装MongoDB
- en: 'Assuming we are using the fresh Ubuntu 16.10 (Yakkety Yak) installation, the
    following steps outline how we can setup MongoDB:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在使用全新的Ubuntu 16.10（Yakkety Yak）安装，以下步骤概述了我们如何设置MongoDB：
- en: 'We will install MongoDB using the following console command:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用以下控制台命令安装MongoDB：
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To further check that MongoDB is successfully installed and running, we can
    execute the following command:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进一步检查MongoDB是否成功安装和运行，我们可以执行以下命令：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This should give us the following output:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该给我们以下输出：
- en: '![](assets/c1e47bda-507b-4206-bfcc-d595cda6935e.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c1e47bda-507b-4206-bfcc-d595cda6935e.png)'
- en: Setting up sample data
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置示例数据
- en: 'Running the `mongo` command on the Ubuntu terminal gets us into a mongo interactive
    shell. From here on, with a simple few commands, we can add the sample data:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu终端上运行`mongo`命令可以进入mongo交互式shell。从这里开始，只需简单的几个命令，我们就可以添加示例数据：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This should give us an output much like the following screenshot:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们一个与以下截图类似的输出：
- en: '![](assets/f83de627-4f06-4e31-acf9-62d4bf809f6f.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f83de627-4f06-4e31-acf9-62d4bf809f6f.png)'
- en: 'Using `use foggyline` and `db.products.find()`, we are able to now list all
    the entries added to the `products` collection:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`use foggyline`和`db.products.find()`，我们现在可以列出添加到`products`集合中的所有条目：
- en: '![](assets/f077bd4e-6193-4bee-a8d0-2b4324c8b276.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f077bd4e-6193-4bee-a8d0-2b4324c8b276.png)'
- en: Querying via the MongoDB driver extension
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过MongoDB驱动程序扩展查询
- en: 'We need to make sure we have the PHP CLI and MongoDB driver extension installed:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保已安装PHP CLI和MongoDB驱动程序扩展：
- en: '[PRE32]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Upon successful execution of these commands, we can confirm that the `mongodb` driver
    extension is installed, as shown in the following screenshot:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 成功执行这些命令后，我们可以确认`mongodb`驱动程序扩展已安装，如下截图所示：
- en: '![](assets/7f71d7c9-2572-404e-8bae-5b02547f3110.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7f71d7c9-2572-404e-8bae-5b02547f3110.png)'
- en: 'Aside from the driver extension, we also need a `mongodb/mongodb` composer
    package added to our project directory. We can do so by running the following
    console command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 除了驱动程序扩展，我们还需要在项目目录中添加`mongodb/mongodb`composer包。我们可以通过运行以下控制台命令来实现：
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Assuming we have the `mongo.php` file within our project directory, all it
    takes is to load the MongoDB library, and start working with Mongo database:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的项目目录中有`mongo.php`文件，只需加载MongoDB库，就可以开始使用Mongo数据库：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Connecting
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接
- en: 'Using the `mongodb` driver extension and the `mongodb/mongodb` PHP library,
    we can connect to the Mongo database from PHP using the `MongoDBDriverManager`
    class, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mongodb`驱动程序扩展和`mongodb/mongodb` PHP库，我们可以使用`MongoDBDriverManager`类从PHP连接到Mongo数据库，如下所示：
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This single-line expression will look for MongoDB on `localhost` under port
    `27017`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行表达式将在`localhost`的端口`27017`下寻找MongoDB。
- en: Error handling
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'Handling errors is pretty straightforward with the `try...catch` blocks, as `MongoDBDriverExceptionException`
    is being thrown whenever an error occurs:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`try...catch`块处理错误非常简单，因为每当发生错误时，都会抛出`MongoDBDriverExceptionException`：
- en: '[PRE36]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Selecting
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择
- en: 'Fetching data with MongoDB comes down to working with three different classes,
    `MongoDBDriverManager`, `MongoDBDriverQuery`, and `MongoDBDriverReadPreference`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MongoDB获取数据涉及与三个不同类的工作，`MongoDBDriverManager`，`MongoDBDriverQuery`和`MongoDBDriverReadPreference`：
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This gives the following output:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '![](assets/8dc9e943-de05-44f8-8ddf-0a23749090bc.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8dc9e943-de05-44f8-8ddf-0a23749090bc.png)'
- en: 'The list of query operators we can pass onto `$filter` is quite an extensive one,
    but the following comparison operators may be the most interesting ones:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以传递给`$filter`的查询运算符列表非常广泛，但以下比较运算符可能是最有趣的：
- en: '`$eq`: These match all values that are equal to a specified value'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$eq`: 这些匹配所有等于指定值的值'
- en: '`$gt`: These match all values that are greater than a specified value'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$gt`: 这些匹配所有大于指定值的值'
- en: '`$gte`: These match all values that are greater than or equal to a specified
    value'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$gte`: 这些匹配所有大于或等于指定值的值'
- en: '`$lt`: These match all values that are less than a specified value'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$lt`: 这些匹配所有小于指定值的值'
- en: '`$lte`: These match all values that are less than or equal to a specified value'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$lte`: 这些匹配所有小于或等于指定值的值'
- en: '`$ne`: These match all values that are not equal to a specified value'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ne`: 这些匹配所有不等于指定值的值'
- en: '`$in`: These match all values that are specified in an array'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$in`: 这些匹配数组中指定的所有值'
- en: '`$nin`: These match the none values that are specified in an array'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$nin`: 这些匹配数组中指定的无值'
- en: Check out [ttps://docs.mongodb.com/manual/reference/operator/query/](https://docs.mongodb.com/manual/reference/operator/query/) for
    a full list of MongoDB query and projection operators.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[ttps://docs.mongodb.com/manual/reference/operator/query/](https://docs.mongodb.com/manual/reference/operator/query/)，了解MongoDB查询和投影运算符的完整列表。
- en: 'The list of query options we can pass onto `$queryOptions` is equally impressive,
    but the following options may be the essential ones:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以传递给`$queryOptions`的查询选项列表同样令人印象深刻，但以下选项可能是最重要的选项：
- en: '`collation`: These allow specifying language-specific rules for string comparison'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collation`: 这些允许指定字符串比较的语言特定规则'
- en: '`limit`: These allow specifying the maximum number of documents to return'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit`: 这些允许指定要返回的文档的最大数量'
- en: '`maxTimeMS`: These set the processing operations time limit in milliseconds'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxTimeMS`: 这些以毫秒为单位设置处理操作的时间限制'
- en: '`projection`: These allow specifying which fields to include in the returned
    documents'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`projection`: 这些允许指定返回文档中包含哪些字段'
- en: '`sort`: These allow specifying sort ordering of the results'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort`: 这些允许指定结果的排序顺序'
- en: Check out [http://php.net/manual/en/mongodb-driver-query.construct.php](http://php.net/manual/en/mongodb-driver-query.construct.php) for
    a full list of the `MongoDBDriverQuery` query options.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[http://php.net/manual/en/mongodb-driver-query.construct.php](http://php.net/manual/en/mongodb-driver-query.construct.php)，了解`MongoDBDriverQuery`查询选项的完整列表。
- en: Inserting
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入
- en: 'Writing new data with MongoDB comes down to working with three different classes,
    `MongoDBDriverManager`, `MongoDBDriverBulkWrite`, and `MongoDBDriverWriteConcern`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MongoDB编写新数据涉及与三个不同类的工作，`MongoDBDriverManager`，`MongoDBDriverBulkWrite`和`MongoDBDriverWriteConcern`：
- en: '[PRE38]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The instance of `BulkWrite` can store one or more insert statements through
    the `insert()` method. We then simply pass `$bulkWrite` and `$writeConcern` to
    `executeBulkWrite()` on the `$manager` instance. Once executed, we can observe
    the newly added records through the `mongo` shell:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`BulkWrite`的实例可以通过`insert()`方法存储一个或多个插入语句。然后我们简单地将`$bulkWrite`和`$writeConcern`传递给`$manager`实例上的`executeBulkWrite()`。执行后，我们可以通过`mongo`
    shell观察到新添加的记录：'
- en: '![](assets/dca64ccf-a77c-4baf-8350-0a99565ef598.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dca64ccf-a77c-4baf-8350-0a99565ef598.png)'
- en: Updating
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新
- en: 'Updating existing data is a nearly identical process as writing new data. The
    obvious difference being the use of the `update()` method on the `MongoDBDriverBulkWrite`
    instance:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 更新现有数据几乎与编写新数据的过程相同。明显的区别在于在`MongoDBDriverBulkWrite`实例上使用`update()`方法：
- en: '[PRE39]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `update()` method accepts three different parameters: filter, a new object, and update
    options. The `multi` option passed under update options, tells if all documents''
    matching criteria will be updated. The `upsert` option passed under update options,
    controls the creation of a new record if the existing record is not found. The
    resulting change can be observed through the `mongo` shell:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`方法接受三个不同的参数：过滤器，新对象和更新选项。在更新选项下传递的`multi`选项告诉是否将更新所有文档的匹配条件。在更新选项下传递的`upsert`选项控制如果找不到现有记录，则创建新记录。通过`mongo`
    shell可以观察到结果的更改：'
- en: '![](assets/bef46af0-ec27-46f9-9912-9215f17ee3c7.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bef46af0-ec27-46f9-9912-9215f17ee3c7.png)'
- en: Deleting
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除
- en: 'Deletion is done in a manner similar to write and update, in that it uses an
    instance of the `MongoDBDriverBulkWrite` object. This time, we are using the instance
    `delete()` method, which accepts filter and delete options:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 删除类似于写入和更新的方式进行，它使用`MongoDBDriverBulkWrite`对象的实例。这次，我们使用`delete()`方法的实例，它接受过滤器和删除选项：
- en: '[PRE40]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Using the `false` value for the `limit` option, we are effectively asking to
    delete all matching documents. Using the `mongo` shell, we can observe the changes
    shown in the following  screenshot:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`false`值作为`limit`选项，我们实际上要求删除所有匹配的文档。使用`mongo` shell，我们可以观察到以下截图中显示的更改：
- en: '![](assets/75596302-1926-4aa5-a7ad-a598e97a3dde.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/75596302-1926-4aa5-a7ad-a598e97a3dde.png)'
- en: Transactions
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易
- en: MongoDB does not have a full **ACID** (**Atomicity, Consistency, Isolation,
    Durability**) support in a sense that MySQL has. It supports ACID transactions
    only at the document level. The multi-document transactions are not supported. The
    lack of ACID compliance certainly limits its use with platforms that depend on
    this feature. This is not to say that MongoDB cannot be used with such platforms.
    Let's consider a popular Magento e-commerce platform. There is nothing preventing
    Magento from adding MongoDB to the mix. While the MySQL features can guarantee
    ACID compliance around sales-related functionality, MongoDB can be used within
    the conjunction to cover bits around catalog functionality. This type of symbiosis can
    then easily bring the best of both database features to our platform.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB在某种意义上不具有与MySQL相同的完整**ACID**（原子性、一致性、隔离性、持久性）支持。它仅在文档级别支持ACID事务。不支持多文档事务。ACID合规性的缺失确实限制了它在依赖于此功能的平台上的使用。这并不是说MongoDB不能与这些平台一起使用。让我们考虑一个流行的Magento电子商务平台。没有什么可以阻止Magento将MongoDB添加到混合中。虽然MySQL功能可以保证与销售相关功能的ACID合规性，但MongoDB可以在其中使用以覆盖目录功能的部分。这种共生关系可以轻松地将两种数据库功能的最佳部分带到我们的平台上。
- en: Working with Redis
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redis
- en: Redis is an open source, in-memory data structure store, whose development is
    sponsored by Redis Labs. The name originated from **REmote DIctionary Server**.
    It currently ranks as one of the most popular key-value databases.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是一个开源的内存数据结构存储，由Redis Labs赞助开发。其名称源自**REmote DIctionary Server**。它目前是最受欢迎的键值数据库之一。
- en: 'Some of the key strengths of Redis can be outlined as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Redis的一些关键优势可以概括如下：
- en: In-memory data structure store
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存数据结构存储
- en: Key-value data store
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值数据存储
- en: Keys with a limited time-to-live
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有有限生存时间的键
- en: Publish/subscribe messaging
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布/订阅消息
- en: It can be used for cache data stores
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以用于缓存数据存储
- en: Transactions
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务
- en: Master-slave replication
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主从复制
- en: Installing Redis
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Redis
- en: 'Assuming we are using the fresh Ubuntu 16.10 (Yakkety Yak) installation, the
    following steps outline how we can setup the Redis server:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在使用全新的Ubuntu 16.10（Yakkety Yak）安装，以下步骤概述了我们如何设置Redis服务器：
- en: 'We can install the Redis server using the following console commands:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下控制台命令安装Redis服务器：
- en: '[PRE41]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This should give us the following output:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该给我们以下输出：
- en: '![](assets/e171ce49-e5c7-4be9-9cef-c9d54b12f95e.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e171ce49-e5c7-4be9-9cef-c9d54b12f95e.png)'
- en: Setting up sample data
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置示例数据
- en: 'Running the `redis-cli` command on the Ubuntu terminal gets us into the Redis interactive
    shell. From here on, with a simple few commands, we can add the following sample
    data:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu终端上运行`redis-cli`命令可以进入Redis交互式shell。从这里开始，通过简单的几个命令，我们可以添加以下示例数据：
- en: '[PRE42]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This should give us the following output:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们以下输出：
- en: '![](assets/d182d03c-9f1a-4e64-a1c7-b1187fa08bbf.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d182d03c-9f1a-4e64-a1c7-b1187fa08bbf.png)'
- en: 'Using the `KEYS *` command within the `redis-cli` shell, we are able to now
    list all the entries added by Redis:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`redis-cli` shell中的`KEYS *`命令，我们现在可以列出Redis添加的所有条目：
- en: '![](assets/2264aaab-0740-45d0-b8d6-96a37f4e7146.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2264aaab-0740-45d0-b8d6-96a37f4e7146.png)'
- en: Querying via the phpredis driver extension
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过phpredis驱动程序扩展进行查询
- en: 'Before we start querying, we need to ensure that we have the PHP CLI and `phpredis` driver
    extension installed:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始查询之前，我们需要确保已安装PHP CLI和`phpredis`驱动程序扩展：
- en: '[PRE43]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Upon successful execution of these commands, we can confirm that the `phpredis` driver
    extension is installed as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些命令后，我们可以确认`phpredis`驱动程序扩展已安装如下：
- en: '![](assets/6bcd8954-b17a-4e94-94cc-e53c94316c88.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6bcd8954-b17a-4e94-94cc-e53c94316c88.png)'
- en: Connecting
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接
- en: 'Using the `phpredis` driver extension, we can connect to Redis from PHP using
    the `Redis` class, as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`phpredis`驱动程序扩展，我们可以使用`Redis`类从PHP连接到Redis，如下所示：
- en: '[PRE44]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This single-line expression will look for Redis on localhost under port `6379`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行表达式将在本地主机的端口`6379`下查找Redis。
- en: Error handling
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'The `phpredis` driver extension throws `RedisException` for every error that
    occurs using the `Redis` class. This makes it easy to handle errors via simple `try...catch`
    blocks:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`phpredis`驱动程序扩展对使用`Redis`类时发生的每个错误都会抛出`RedisException`。这使得通过简单的`try...catch`块轻松处理错误：'
- en: '[PRE45]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Selecting
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择
- en: 'Given that Redis is a key value store, selecting keys is as easy as using a
    single `get()` method of the `Redis` instance:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于Redis是一个键值存储，选择键就像使用`Redis`实例的单个`get()`方法一样容易：
- en: '[PRE46]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This should give us the following output:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们以下输出：
- en: '![](assets/61576137-5dfa-4782-8aa2-c02a063425cd.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/61576137-5dfa-4782-8aa2-c02a063425cd.png)'
- en: 'The `Redis` client class also provides the `mget()` method, which is able to
    fetch more than one key value at a time:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`Redis`客户端类还提供了`mget()`方法，可以一次获取多个键值：'
- en: '[PRE47]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This should give us the following output:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们以下输出：
- en: '![](assets/82bc6db8-3fc6-4983-ac5b-7045e0e301c4.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/82bc6db8-3fc6-4983-ac5b-7045e0e301c4.png)'
- en: Inserting
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入
- en: 'The simplicity behind the Redis key-value mechanism makes for a simple and
    straightforward `set()` method, through which we insert new entries, as shown
    in the following example:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Redis键值机制背后的简单性使得`set()`方法简单直接，通过它我们可以插入新条目，如下例所示：
- en: '[PRE48]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This should give us the following output:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们以下输出：
- en: '![](assets/50b0a300-61e0-4d2f-b323-84dc6a9ca282.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/50b0a300-61e0-4d2f-b323-84dc6a9ca282.png)'
- en: We should be careful when using the set methods with non-string like structures.
    The `user` key value resulted in the Array string being stored in Redis, and not
    the actual array structure. This is easily sorted by converting our array structure
    to JSON using `json_encode()`, right before we pass it onto the `set()` method.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用非字符串结构的set方法时，我们需要小心。`user`键值导致存储在Redis中的是数组字符串，而不是实际的数组结构。通过在传递给`set()`方法之前使用`json_encode()`将数组结构转换为JSON，可以轻松解决这个问题。
- en: 'One great benefit of the `set()` method is that it supports the timeout in
    seconds, so we can easily write expressions such as the following:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`set()`方法的一个很大的好处是它支持以秒为单位的超时，因此我们可以轻松地编写以下表达式：'
- en: '[PRE49]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Although, calling the `setex()` method is the preferred way for when we want
    to add a timeout to our keys:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然调用`setex()`方法是我们想要为键添加超时的首选方式：
- en: '[PRE50]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Timeouts are a great feature to use when using Redis as a cache database. They basically
    automate the cache lifetime for us.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Redis作为缓存数据库时，超时是一个很好的功能。它们基本上为我们自动设置了缓存的生命周期。
- en: Updating
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新
- en: 'Updating a value via the Redis client is the same as inserting it. We use the
    same `set()` method, with the same key. The new value simply overwrites the previous
    one, if any exists:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Redis客户端更新值与插入值相同。我们使用相同的`set()`方法，使用相同的键。如果存在先前的值，新值将简单地覆盖它：
- en: '[PRE51]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Deleting
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除
- en: 'Removing records from Redis is as easy as calling the Redis client `del()`
    method and passing it the key that we want to delete:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 从Redis中删除记录就像调用Redis客户端的`del()`方法并传递要删除的键一样简单：
- en: '[PRE52]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Transactions
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务
- en: 'Much like MongoDB, Redis also does not have ACID support in a sense that MySQL
    has, which is alright really, as Redis is just a key/value store and not a relational
    database. Redis, however, provides a level of atomicity. Using `MULTI`, `EXEC`,
    `DISCARD`, and `WATCH`, we are able to execute a group of commands within a single
    step, during which Redis makes the following two guarantees:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 与MongoDB类似，Redis在某种意义上也没有像MySQL那样的ACID支持，这其实没关系，因为Redis只是一个键/值存储，而不是关系数据库。然而，Redis提供了一定程度的原子性。使用`MULTI`、`EXEC`、`DISCARD`和`WATCH`，我们能够在单个步骤中执行一组命令，Redis在此期间提供以下两项保证：
- en: Another client request can never be served in the middle of our group-commands
    execution
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个客户端请求永远不会在我们的组命令执行过程中被服务
- en: Either all or none of the commands are processed
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有命令要么全部执行，要么全部不执行
- en: 'Let''s take a look at the following example:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下示例：
- en: '[PRE53]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `$result2`  value comes out as `false`, which triggers `$client->discard();`.
    Although, `result1` is a valid expression, it came after the `$client->multi();`
    call, which means that its command is not really processed; so, we don't get to
    see the `Test#1` value stored in Redis. Although there is no classically looking
    rollback mechanism, like we had with MySQL, this makes for a nice transaction
    model.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`$result2`的值为`false`，触发了`$client->discard();`。虽然`result1`是一个有效的表达式，但它是在`$client->multi();`调用之后出现的，这意味着它的命令实际上并没有被处理；因此，我们看不到存储在Redis中的`Test#1`的值。虽然没有经典的回滚机制，就像我们在MySQL中看到的那样，但这为一个良好的事务模型。'
- en: Summary
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Throughout this chapter, we touched upon the basics of querying three very different
    database systems.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涉及了查询三种非常不同的数据库系统的基础知识。
- en: The MySQL database has been around for a very long time, and is likely the number
    one database for most PHP applications. Its ACID compliance makes it irreplaceable
    for applications dealing with financial or other sensitive data where atomicity,
    consistency, isolation, and durability are key factors.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL数据库已经存在很长时间，很可能是大多数PHP应用程序的第一个数据库。其ACID兼容性使其在处理财务或其他敏感数据的应用程序中不可替代，其中原子性、一致性、隔离性和耐久性是关键因素。
- en: Mongo, on the other hand, tackles data storage through a schema-less approach.
    This makes it much easier for developers to pace up application development, although
    the lack of ACID compliance across documents limits its use in certain types of
    applications.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Mongo通过无模式的方法处理数据存储。这使开发人员更容易加快应用程序的开发速度，尽管文档之间缺乏ACID兼容性限制了它在某些类型的应用程序中的使用。
- en: Finally, the Redis data store serves as a great caching, or even a session-storing
    solution for our applications.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Redis数据存储作为我们应用程序的一个很好的缓存，甚至是会话存储解决方案。
- en: Moving forward, we will take a closer look at dependency injection, what it
    is, and what role does it have within modular applications.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更仔细地看一下依赖注入，它是什么，以及在模块化应用程序中扮演什么角色。
