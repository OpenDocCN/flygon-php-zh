- en: Chapter 5. Behavioral Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 行为设计模式
- en: Behavioral design patterns are all about the communication between objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 行为设计模式关乎对象之间的通信。
- en: Bearing in mind the Single Responsibility Principle, it is vital that classes
    only encapsulate one responsibility. Given this, there is clearly a necessity
    to allow objects to communicate.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记单一责任原则，类只封装一个责任是至关重要的。鉴于此，显然有必要允许对象进行通信。
- en: By using Behavioral design patterns, we are able to increase the flexibility
    by which we conduct these communications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用行为设计模式，我们能够增加进行这些通信的灵活性。
- en: 'In this chapter, we''ll cover the following patterns:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下模式：
- en: Observer pattern (SplObserver/SplSubject)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式（SplObserver/SplSubject）
- en: Iterator
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: The many Iterators of PHP
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP的许多迭代器
- en: Generators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: Template pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板模式
- en: Chain of Responsibility pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链模式
- en: Strategy pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式
- en: Specification pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范模式
- en: Scheduled Task pattern
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时任务模式
- en: Personality traits for passionate programmers
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热情程序员的个性特征
- en: Before we start talking about Behavioral design patterns, let's talk about your
    behavior as a developer. Earlier in this book I've talked about how often development
    failures emerge as a result of bad management practices.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论行为设计模式之前，让我们先谈谈你作为开发人员的行为。在本书的早些时候，我已经谈到开发失败经常是由于糟糕的管理实践而出现的。
- en: 'Let''s imagine two scenarios:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象两种情景：
- en: A company introduces Scrum as a methodology (or another *Agile* methodology
    that is lacking in technical knowledge), without their code being agile enough
    to withstand code. In these scenarios, when a code is added, it is often botched
    into place and it will almost certainly be the case that the code takes far longer
    to implement than it would without technical debt. This leads to a slow development
    speed.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一家公司引入Scrum作为一种方法论（或者另一种缺乏技术知识的“敏捷”方法论），而他们的代码并不足够灵活以承受代码。在这些情况下，当代码被添加时，它经常被拼凑在一起，几乎可以肯定的是，代码的实现时间比没有技术债务时要长得多。这导致开发速度缓慢。
- en: Alternatively, a company follows a strictly pre-defined process and that methodology
    is set in stone. These processes are often unjustifiable but developers often
    follow them as they aren't educated in better processes, don't want to enter a
    bureaucratic dispute to alter them, or may even fear disciplinary action for attempting
    to improve a process.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，一个公司遵循严格预定义的流程，而这种方法论是一成不变的。这些流程通常是不合理的，但开发人员经常遵循它们，因为他们没有接受更好流程的教育，不想卷入官僚纠纷来改变它们，甚至可能因试图改进流程而担心受到纪律处分。
- en: In both these scenarios, a poor process is at the heart of the problem. Even
    when you're not dealing with a legacy project, this can become a problem due to
    the change of requirements throughout a property. A good property of software
    is the ability to change and, indeed, change the design of the software itself
    (we'll discuss this in the final chapter on refactoring).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，一个糟糕的流程是问题的核心。即使你没有处理遗留项目，由于财产要求的变化，这也可能成为一个问题。软件的一个好特性是能够改变，甚至改变软件本身的设计（我们将在重构的最后一章讨论这个问题）。
- en: Alastair Cockburn identified that software developers don't often fit into a
    pre-defined production-line process. Humans are unpredictable, and when they are
    the key actor in any given process, the process also becomes unpredictable. Humans
    are open to error and don't act perfectly in a pre-defined process when there
    is as much room for error as there is in software development. Fundamentally,
    this is why people must come before processes, as stated in the Agile manifesto.
    The developers must come before the process.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Alastair Cockburn指出，软件开发人员通常不适合预定义的生产线流程。人类是不可预测的，当他们是任何给定流程中的关键行为者时，流程也变得不可预测。人类容易出错，在软件开发中有很多错误的空间，他们在预定义流程中不会完美地行事。基本上，这就是为什么人必须高于流程，正如敏捷宣言中所述。开发人员必须高于流程。
- en: Some of those in management positions want to buy something called Agile. They'll
    hire a consultant who fails to understand how software development can really
    be made a success, and instead, implements a ridiculous process as part of a cash
    cow operation to sell Agile. I believe that Scrum is the worst example of this
    (in part because of the number of inaccurate courses and pseudo-qualifications),
    but no doubt other Agile processes can be used as cash cows.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些管理职位的人想要购买所谓的敏捷。他们会雇佣一个不了解软件开发如何真正取得成功的顾问，而是作为销售敏捷的摇钱树运营实施一个荒谬的流程。我认为Scrum是这种情况的最糟糕的例子（部分原因是因为不准确的课程和伪资格的数量），但毫无疑问其他敏捷流程也可以被用作摇钱树。
- en: I have repeatedly come into contact with managers or **Scrum Masters** who claim
    that *Scrum says we should do ...* or *Agile says we should do ...*. This is mentally
    illogical and should be avoided. When you make this statement you are fundamentally
    not understanding that an Agile methodology is based on the principle of agility,
    and as such, people must come above processes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾多次接触到声称“Scrum说我们应该做…”或“敏捷说我们应该做…”的经理或Scrum大师。这在心理上是不合逻辑的，应该避免。当你说这句话时，你基本上没有理解敏捷方法论是基于灵活性原则的，因此，人必须高于流程。
- en: Let's review the first scenario again. Note that the dispute largely emerges
    from a lack of development quality instead of project management processes. Scrum
    fails to implement development processes and as a result, projects attempted through
    Scrum may often fail.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回顾第一个情景。请注意，争议主要是由于开发质量的缺乏而不是项目管理流程。Scrum未能实施开发流程，因此，通过Scrum尝试的项目往往会失败。
- en: 'Extreme Programming (XP) contains these development rules, which Scrum lacks.
    Here are some examples:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 极限编程（XP）包含这些开发规则，Scrum缺乏这些规则。以下是一些例子：
- en: Coding standards (in PHP, you may choose the PSR standards we discussed in earlier
    chapters)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码标准（在PHP中，你可以选择我们在前几章讨论过的PSR标准）
- en: Write the unit test first and the code should be written so it passes the test
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先编写单元测试，然后编写代码使其通过测试
- en: All production code is pair-programmed
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的生产代码都是成对编程的
- en: A dedicated integration server with only one pair integration code at a time
    with code being integrated frequently
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个专用的集成服务器一次只集成一对代码，代码被频繁地集成
- en: Use collective ownership; no part of the codebase is off limits to another developer
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集体所有权；代码库的任何部分都不会对其他开发人员限制
- en: This is all completed against a backdrop of fixing XP when it breaks, making
    improving the process a regular part of development.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是在修复XP的背景下完成的，使改进过程成为开发的常规部分。
- en: Introducing technical standards and development rules requires both a pre-existing
    knowledge of development with a passion for learning more; for this, a logical
    and evidence-driven thought process is vital. These are all critical elements
    of being a great software engineer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 引入技术标准和开发规则需要对开发有先验知识并对学习有热情；因此，逻辑和以证据为基础的思维过程至关重要。这些都是成为优秀软件工程师的关键要素。
- en: Pair-programming must not become an effort in mentoring, it mustn't be a student-teacher
    relationship; both developers must be willing to put forward ideas and have such
    ideas criticized. Indeed, it is vital to be able to learn from each other.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 配对编程不能成为辅导的一种努力，也不能成为学生和老师之间的关系；两个开发人员都必须愿意提出想法并接受这些想法的批评。事实上，能够互相学习是至关重要的。
- en: In an Agile relationship, everyone must be willing to understand and contribute
    to the planning process, as such communication is a vital skill. Similarly, respect
    for each other is key; everyone from customers to developers deserves respect.
    Developers must be courageous in many ways, not least being truthful about progress
    and estimation while crucially also adapting to change. We must seek to understand
    the feedback we receive before addressing or dismissing it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷关系中，每个人都必须愿意理解和贡献规划过程，因此沟通是一项至关重要的技能。同样，彼此尊重是关键；从客户到开发人员，每个人都应该受到尊重。开发人员在许多方面都必须勇敢，尤其是在关于进展和估计的真实性方面，同时也必须适应变化。我们必须在处理或拒绝反馈之前努力理解我们收到的反馈。
- en: These skills aren't merely toggles or switches, they are open-ended skills and
    knowledge bases that we must seek to maintain and exercise. Things go wrong; through
    the use of feedback, we are able to ensure our code is of a sufficiently high
    quality before it is deployed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技能不仅仅是开关，它们是开放式的技能和知识基础，我们必须努力维护和运用。事情会出错；通过使用反馈，我们能够确保我们的代码在部署之前具有足够高的质量。
- en: Observer pattern (SplObserver/SplSubject)
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式（SplObserver/SplSubject）
- en: The Observer design pattern essentially allows an object (the subject) to maintain
    a list of observers that are automatically notified when the state of the that
    object changes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者设计模式本质上允许一个对象（主题）维护一个观察者列表，当该对象的状态发生变化时，这些观察者会自动收到通知。
- en: This pattern applies a one-to-many dependency between objects; there is always
    one subject that updates many observers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式应用于对象之间的一对多依赖关系；总是有一个主题更新多个观察者。
- en: The Gang of Four originally identified that this pattern was particularly applicable
    in cases where an abstraction has two aspects, with one dependent on the other.
    In addition to this, it is very useful when a change to object requires changes
    to the others and you don't know how many other objects need to be changed. Finally,
    this pattern is also incredibly useful when an object should notify other objects
    without making assumptions about what those objects are, thus making this pattern
    great for loosely coupling this relationship.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 四人帮最初确定这种模式特别适用于抽象有两个方面，其中一个依赖于另一个的情况。除此之外，当对象的更改需要对其他对象进行更改，而你不知道需要更改多少其他对象时，这种模式也非常有用。最后，当一个对象应该通知其他对象而不做出关于这些对象是什么的假设时，这种模式也非常有用，因此这种模式非常适用于松散耦合的关系。
- en: PHP provides a very useful interface called `SplObserver` and `SplSubject`.
    These interfaces provide the template for implementing the Observer design pattern
    while not actually implementing any functionality.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: PHP提供了一个非常有用的接口，称为`SplObserver`和`SplSubject`。这些接口提供了实现观察者设计模式的模板，但实际上并没有实现任何功能。
- en: In essence, when we implement this pattern we allow an unlimited amount of objects
    to observe events in the subjects.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，当我们实现这种模式时，我们允许无限数量的对象观察主题中的事件。
- en: By calling an `attach` method in the `subject` object, we can attach an observer
    to the subject. When a change occurs in the subject, the subject's `notify` method
    can iterate through the observers and call their `update` method polymorphically.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`subject`对象中调用`attach`方法，我们可以将观察者附加到主题上。当主题发生变化时，主题的`notify`方法可以遍历观察者并多态地调用它们的`update`方法。
- en: We are also able to call an un-notify method in the subject which will allow
    us to stop an `observer` object from observing a `subject` object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在主题中调用一个未通知的方法，这将允许我们停止一个`观察者`对象观察一个`主题`对象。
- en: 'Given this, the `Subject` class contains methods to attach and detach observers
    from itself, the class also contains a `notify` method to update the observers
    that are looking at it. Therefore, PHP''s `SplSubject` interface is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，`Subject`类包含了将观察者附加到自身和从自身分离的方法，该类还包含了一个`notify`方法来更新正在观察它的观察者。因此，PHP的`SplSubject`接口如下：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Compared to this, our `SplObserver` interface looks even more simple; it merely
    needs to implement a single method that allows the subjects to update the observers:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相比，我们的`SplObserver`接口看起来更简单；它只需要实现一个允许主题更新观察者的方法：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let's see how we can implement these two interfaces to implement this design
    pattern. In this example, we will have a news feed class that will update various
    readers that are reading the classes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何实现这两个接口来实现这个设计模式。在这个例子中，我们将有一个新闻订阅类，它将更新正在阅读这些类的各种读者。
- en: 'Let''s define our `Feed` class, which will implement the `SplSubject` interface:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义我们的`Feed`类，它将实现`SplSubject`接口：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The implementation we covered is, overall, quite simple. Notice how it's using
    the `spl_object_hash` function that we explored previously in this book to allow
    us to easily detach objects. By using the hash as the key for the array we are
    able to rapidly find a given object without needing to do it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的实现总体上相当简单。请注意，它使用了我们在本书中之前探讨过的`spl_object_hash`函数，以便让我们轻松地分离对象。通过使用哈希作为数组的键，我们能够快速找到给定的对象，而无需进行其他操作。
- en: 'Now we can define our `Reader` class, which will implement the `SplObserver`
    interface:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义我们的`Reader`类，它将实现`SplObserver`接口：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s wrap all this together in our `index.php` file as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将所有这些内容放在我们的`index.php`文件中：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this script, we firstly instantiate a feed with three readers. We attach
    all of them, then detach one. Finally, we send a new alert, which produces the
    following output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们首先用三个读者实例化一个订阅源。我们将它们全部附加，然后分离一个。最后，我们发送一个新的警报，产生以下输出：
- en: '![Observer pattern (SplObserver/SplSubject)](graphics/image_05_001.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![观察者模式（SplObserver/SplSubject）](graphics/image_05_001.jpg)'
- en: The main advantage of this design pattern surrounds the loosely coupled nature
    of the relationships between the observers and the subjects. There is greater
    modularity, as subjects and observers can independently vary. In addition to this,
    we can add as many observers as we want, providing as many pieces of functionality
    as we're after. This extensibility and customization is often the reason this
    design pattern is applied in the context of view for an application and is also
    often implemented in **Model-View-Controller** (**MVC**) frameworks.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式的主要优势在于观察者和主题之间关系的松散耦合性。有更大的模块化，因为主题和观察者可以独立变化。除此之外，我们可以添加任意多的观察者，提供我们想要的任意多的功能。这种可扩展性和定制性通常是这种设计模式应用于应用程序视图上下文的原因，也经常在**模型-视图-控制器**（**MVC**）框架中实现。
- en: The disadvantages of using this pattern come when we need to debug this whole
    thing; flow control can become difficult as observers don't know about each other.
    In addition to this, there is an update overhead, which can make memory management
    difficult when dealing with particularly large observers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式的缺点在于当我们需要调试整个过程时会出现问题；流程控制可能会变得困难，因为观察者彼此之间并不知道对方的存在。除此之外，还存在更新开销，当处理特别大的观察者时，可能会使内存管理变得困难。
- en: Remember that this design pattern is solely for use within one program, it's
    not designed for inter-process communication or a messaging system. Later in this
    book, we'll cover how you can use Messaging patterns to describe how different
    parts of a message parsing system interconnect when we want to allow intercommunication
    between different processes, and not just different classes within one process.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这种设计模式仅用于一个程序内部，不适用于进程间通信或消息系统。本书后面，我们将介绍如何使用消息模式来描述消息解析系统的不同部分如何相互连接，当我们想要允许不同进程之间的互通，而不仅仅是一个进程内的不同类时。
- en: Iterators
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: The Iterator design pattern is where an iterator is used to traverse a container.
    In PHP, a class is traversable using the `foreach` construct if it ultimately
    inherits the Traversable interface. Unfortunately, this is an abstract base interface,
    you can't implement it alone (unless you're writing in the PHP core itself). Instead,
    you must instead implement interfaces called `Iterator` or `IteratorAggregate`.
    By implementing either of these interfaces you make a class iterable and traversable
    using `foreach`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器设计模式是使用迭代器遍历容器的地方。在PHP中，如果最终继承了可遍历接口，类就可以使用`foreach`构造进行遍历。不幸的是，这是一个抽象基础接口，你不能单独实现它（除非你是在PHP核心中编写）。相反，你必须实现称为`Iterator`或`IteratorAggregate`的接口。通过实现这些接口中的任何一个，你可以使一个类可迭代，并可以使用`foreach`进行遍历。
- en: '`Iterator` and `IteratorAggregate` interfaces are very similar, except the
    `IteratorAggregate` interface creates an external iterator. `IteratorAggregate`
    as an interface only requires outlines one method, `getIterator`. This method
    has to return an instance of the `ArrayIterator` interface.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator`和`IteratorAggregate`接口非常相似，除了`IteratorAggregate`接口创建一个外部迭代器。`IteratorAggregate`作为一个接口只需要定义一个方法`getIterator`。这个方法必须返回`ArrayIterator`接口的一个实例。'
- en: IteratorAggregate
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IteratorAggregate
- en: Let's suppose we want to create an implementation of this interface, which will
    iterate through various times.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个实现这个接口的实现，它将遍历各种时间。
- en: 'Firstly, let''s start off with a basic implementation of the `IternatorAggregate`
    class to understand how it works:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从一个`IternatorAggregate`类的基本实现开始，以了解它是如何工作的：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can iterate through this class as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式遍历这个类：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of this is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出如下：
- en: '![IteratorAggregate](graphics/image_05_002.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![IteratorAggregate](graphics/image_05_002.jpg)'
- en: 'I''ve modified this script so that it takes a `time` value and calculates various
    values either side and makes them iterable:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我修改了这个脚本，使它接受一个`time`值，并计算两侧的各种值，并使它们可迭代：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of this script is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的输出如下：
- en: '![IteratorAggregate](graphics/image_05_003.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![IteratorAggregate](graphics/image_05_003.jpg)'
- en: Iterator
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器
- en: Let's suppose we want to create an implementation of this interface that will
    iterate through various times.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个实现这个接口的实现，它将遍历各种时间。
- en: The many iterators of PHP
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP的许多迭代器
- en: Previously, we've explored some functions in the **SPL (Standard PHP Library)**,
    which is a collection of interfaces and classes that exist to solve common problems.
    Given this aim, they share a common aim with design patterns, but they both aim
    to solve these problems in different ways. No external libraries are needed to
    build this extension and compile in PHP 7; indeed, you can't even disable it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们已经探讨了**SPL（标准PHP库）**中的一些函数，这是一个解决常见问题的接口和类的集合。鉴于这个目标，它们与设计模式有着共同的目标，但它们都以不同的方式解决这些问题。构建这个扩展和在PHP
    7中编译不需要外部库；事实上，你甚至不能禁用它。
- en: As part of this library, there are a lot of iterators in the SPL. You can find
    a list of them in the documentation at [http://php.net/manual/en/spl.iterators.php](http://php.net/manual/en/spl.iterators.php).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个库的一部分，在SPL中有很多迭代器。您可以在文档中找到它们的列表[http://php.net/manual/en/spl.iterators.php](http://php.net/manual/en/spl.iterators.php)。
- en: 'Here''s a list of some of these iterators to give you an idea of what you can
    utilize them for:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些这些迭代器的列表，以便让您了解您可以利用它们的用途：
- en: AppendIterator
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追加迭代器
- en: ArrayIterator
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组迭代器
- en: CachingIterator
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存迭代器
- en: CallbackFilterIterator
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调过滤迭代器
- en: DirectoryIterator
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录迭代器
- en: EmptyIterator
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空迭代器
- en: FilesystemIterator
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统迭代器
- en: FilterIterator
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤迭代器
- en: GlobIterator
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Glob迭代器
- en: InfiniteIterator
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无限迭代器
- en: IteratorIterator
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器迭代器
- en: LimitIterator
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制迭代器
- en: MultipleIterator
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重迭代器
- en: NoRewindIterator
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需倒带迭代器
- en: ParentIterator
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父迭代器
- en: RecursiveArrayIterator
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归数组迭代器
- en: RecursiveCachingIterator
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归缓存迭代器
- en: RecursiveCallbackFilterIterator
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归回调过滤迭代器
- en: RecursiveDirectoryIterator
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归目录迭代器
- en: RecursiveFilterIterator
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归过滤迭代器
- en: RecursiveIteratorIterator
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归迭代器迭代器
- en: RecursiveRegexIterator
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归正则表达式迭代器
- en: RecursiveTreeIterator
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归树迭代器
- en: RegexIterator
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式迭代器
- en: Generators
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: PHP has a great mechanism to create iterators in a compact fashion. This type
    of iterator comes with some severe limitations; they are forward only and cannot
    be rewound. Indeed, even to simply start an iterator from the start, you must
    rebuild the generator. In essence, this is a forward-only iterator.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: PHP有一个很好的机制来以紧凑的方式创建迭代器。这种类型的迭代器有一些严重的限制；它们只能向前，不能倒带。事实上，即使只是从头开始一个迭代器，你也必须重新构建生成器。本质上，这是一个只能向前的迭代器。
- en: A function that uses the `yield` keyword instead of the `return` keyword. This
    will act in the same way as a `return` statement, but it will not stop the execution
    of that function. A generator function can `yield` data as many times as you please.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用`yield`关键字而不是`return`关键字的函数。这将像`return`语句一样工作，但不会停止该函数的执行。生成器函数可以`yield`数据，只要你愿意。
- en: When you populate an array with values, those values must be stored in memory
    which can cause you to exceed your PHP memory limit or require a significant amount
    of processing time for the generator. When you put the logic in a generator function,
    that overhead does not exist. The generator function may merely yield as many
    results as it needs; there's no need to prepopulate an array first.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当您用值填充一个数组时，这些值必须存储在内存中，这可能导致您超出PHP内存限制，或者需要大量的处理时间来生成器。当您将逻辑放在生成器函数中时，这种开销就不存在了。生成器函数可能只产生它需要的结果；不需要先预先填充一个数组。
- en: 'Here is a simple generator that will `var_dump` a string stating, the generator
    has started. The function will then generate the first five square numbers while
    also outputting their place in the series with `var_dump` . It will then finally
    indicate the generator has ended:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的生成器，将`var_dump`一个声明字符串，生成器已经启动。该函数将生成前五个平方数，同时输出它们在序列中的位置。然后最后指示生成器已结束：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The second part of this script loops through this function and runs a `var_dump`
    string on each number. The output of this is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的第二部分循环运行这个函数，并对每个数字运行一个`var_dump`字符串。这个输出如下：
- en: '![Generators](graphics/image_05_004.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![生成器](graphics/image_05_004.jpg)'
- en: Let's amend this function slightly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微修改这个函数。
- en: It is very important to note that if you add a return type to the variable,
    you can only declare a return type of `Generator`, `Iterator` or `Traversable`,
    `integer`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的一点是，如果你给变量添加了返回类型，你只能声明`Generator`，`Iterator`或`Traversable`，`integer`的返回类型。
- en: 'Here is the code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The result of this is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果如下：
- en: '![Generators](graphics/image_05_005.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![生成器](graphics/image_05_005.jpg)'
- en: What if we want to yield a key as well as a value? Well, this is fairly easy.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要产生一个键和一个值，那么这是相当容易的。
- en: 'There''s something else to mention about generators to those who used them
    in PHP 5: in PHP 5, when you want to simultaneously yield a variable while setting
    it to a variable, you must wrap the yield statement in brackets. This restriction
    does not exist in PHP 7.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些关于在PHP 5中使用生成器的事情要提及：在PHP 5中，当您想要同时产生一个变量并将其设置为一个变量时，必须将yield语句包装在括号中。这个限制在PHP
    7中不存在。
- en: 'This works in PHP 5 and 7:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这在PHP 5和7中有效：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This only works in PHP 7:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这只在PHP 7中有效：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s suppose we want to amend our generator so that it yields a key-value
    result. Here''s what the code looks like:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想修改我们的生成器，使其产生一个键值结果。代码如下：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When we test this, we will `var_dump` a two-dimensional array containing a key-value
    store of whatever the generator has yielded in a given iteration.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们测试这个时，我们将`var_dump`一个包含键值存储的二维数组，这个数组包含了生成器在给定迭代中产生的任何值。
- en: 'Here is the output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '![Generators](graphics/image_05_006.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![生成器](graphics/image_05_006.jpg)'
- en: 'Just a few other tips, a yield statement with no variable (like the one shown
    in the succeding command) will simply yield `null`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他提示，一个没有变量的yield语句（就像在下面的命令中所示的那样）将简单地产生`null`：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You may also use `yield from` which will yield the inner values of any given
    generator.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`yield from`，它将产生任何给定生成器的内部值。
- en: 'Let''s suppose we have an array of two values:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含两个值的数组：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we use `yield from` to yield an array of two values we get the inner values
    of the array. Let me demonstrate this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`yield from`来产生一个包含两个值的数组时，我们得到了数组的内部值。让我演示一下：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will display the following output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下输出：
- en: '![Generators](graphics/image_05_007.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![生成器](graphics/image_05_007.jpg)'
- en: 'However, now let''s alter this script so that it uses `yield` instead of `yield
    from`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在让我们修改这个脚本，使其使用`yield`而不是`yield from`：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will now see that instead of merely just the inner values of the array,
    we get the outer container too:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到，我们不仅仅得到了数组的内部值，还得到了外部容器：
- en: '![Generators](graphics/image_05_008.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![生成器](graphics/image_05_008.jpg)'
- en: Template Method design pattern
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法设计模式
- en: The Template Method design pattern is used to create a group of subclasses that
    have to execute a similar group of behaviors.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法设计模式用于创建一组必须执行类似行为的子类。
- en: This design pattern consists of a Template Method, which is an abstract class.
    Concrete subclasses can override the methods within the abstract class. The Template
    Method consists of a skeleton of an algorithm; the subclasses can use overriding
    to change the concrete behavior of the algorithm.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式由模板方法组成，它是一个抽象类。具体的子类可以重写抽象类中的方法。模板方法包含算法的骨架；子类可以使用重写来改变算法的具体行为。
- en: As such, this is an incredibly simple design pattern to use; it encourages loose
    coupling while also controlling at what points subclassing is permitted. Thus,
    it is more fine-grained than simple polymorphic behavior.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是一个非常简单的设计模式；它鼓励松散耦合，同时控制子类化的点。因此，它比简单的多态行为更精细。
- en: 'Consider the following abstraction of a `Pasta` class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个`Pasta`类的抽象：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There is a simple constructor for whether the pasta should contain cheese or
    not, and a `cook` function that runs the cooking algorithm.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的构造函数，用于确定意大利面是否应该包含奶酪，以及一个运行烹饪算法的`cook`函数。
- en: Note that the functions to add various ingredients are abstracted away; in subclasses,
    we implement these methods with the required behavior.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，添加各种配料的函数被抽象掉了；在子类中，我们使用所需的行为来实现这些方法。
- en: 'Suppose we want to make meatball pasta. We can implement this abstract class
    as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想做肉丸意大利面。我们可以按照以下方式实现这个抽象类：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can sample this code using the following script in our `index.php` file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下脚本在我们的`index.php`文件中对这段代码进行测试：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Thanks to all the `var_dump` variables in the various functions displaying
    various status messages, we can see an output like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢各种函数中的`var_dump`变量显示各种状态消息，我们可以看到如下输出：
- en: '![Template Method design pattern](graphics/image_05_009.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![模板方法设计模式](graphics/image_05_009.jpg)'
- en: Now, suppose we want to make a vegan recipe instead. We can utilize the same
    abstraction in a different context.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要制作一个素食食谱。我们可以在不同的上下文中利用相同的抽象。
- en: 'This time when it comes to adding meat or cheese, those functions do nothing;
    they can return `false` or a `null` value:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，在添加肉或奶酪时，这些函数什么也不做；它们可以返回`false`或`null`值：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s amend our `index.php` file to represent this behavior:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的`index.php`文件以表示这种行为：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Template Method design pattern](graphics/image_05_010.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![模板方法设计模式](graphics/image_05_010.jpg)'
- en: This design pattern is simple and easy to work with, but it fundamentally allows
    you to abstract your algorithm design and delegate that responsibility to subclasses
    where you want to.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式简单易用，但基本上允许您抽象化您的算法设计，并将责任委托给您想要的子类。
- en: Chain of Responsibility
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链
- en: Suppose we have a group of objects that together are meant to solve a problem.
    When one object can't solve a problem, we want the object to send the task to
    a different object in a given chain. This is what the Chain of Responsibility
    design pattern is used for.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一组对象，它们一起解决问题。当一个对象无法解决问题时，我们希望对象将任务发送给链中的另一个对象。这就是责任链设计模式的用途。
- en: In order to get this to work, we need a handler, which will be our `Chain` interface.
    The various objects in the chain will all implement this `Chain` interface.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个工作起来，我们需要一个处理程序，这将是我们的`Chain`接口。链中的各个对象都将实现这个`Chain`接口。
- en: Let's start with a simple example; an associate can purchase an asset for less
    than $100, a manager can purchase something for less than $500.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始；一个助理可以为少于100美元购买资产，一个经理可以为少于500美元购买东西。
- en: 'Our abstraction for the `Purchaser` interface looks like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Purchaser`接口的抽象如下：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our first implementation is the `Associate` class. Quite simply, we implement
    the `setNextPurchaser` function so that it will set the `nextPurchaser` class
    property to the next object in the chain.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个实现是`Associate`类。非常简单，我们实现`setNextPurchaser`函数，以便将`nextPurchaser`类属性设置为链中的下一个对象。
- en: 'When we call the `buy` function, if the price is within range, the associate
    will purchase it. If not, the next purchaser in the chain will purchase it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`buy`函数时，如果价格在范围内，助理将购买它。如果不是，链中的下一个购买者将购买它：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our `Manager` class is exactly the same; we just allow the manager to purchase
    assets which are under $500\. In reality, when you apply this pattern you wouldn't
    just duplicate a class as your class would have different logic; this example
    is just an incredibly simple implementation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Manager`类完全相同；我们只允许经理购买低于500美元的资产。实际上，当您应用这种模式时，您不会只是复制一个类，因为您的类会有不同的逻辑；这个例子只是一个非常简单的实现。
- en: 'Here''s the code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let's run a basic purchase from an associate in our `index.php` file.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`index.php`文件中运行一个来自助理的基本购买。
- en: 'Firstly, here''s the code we put in our `index.php` file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是我们放在`index.php`文件中的代码：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of all of this is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的输出如下：
- en: '![Chain of Responsibility](graphics/image_05_011.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![责任链](graphics/image_05_011.jpg)'
- en: Next, let's test our `Manager` class. We'll amend our purchase price in our
    `index.php` file and also add our `Manager` class to the chain.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们测试我们的`Manager`类。我们将在我们的`index.php`文件中修改购买价格，并将我们的`Manager`类添加到链中。
- en: 'Here''s our amended `index.php`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们修改后的`index.php`：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This has the following output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这有以下输出：
- en: '![Chain of Responsibility](graphics/image_05_012.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![责任链](graphics/image_05_012.jpg)'
- en: Let's see what happens if we alter the price such that the purchase will fail.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果改变价格会发生什么导致购买失败。
- en: 'We change the final line on our `index.php` file so the purchase price is now
    $600:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的`index.php`文件的最后一行进行更改，使购买价格现在为600美元：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This has the following output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这有以下输出：
- en: '![Chain of Responsibility](graphics/image_05_013.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![责任链](graphics/image_05_013.jpg)'
- en: We can now extend this script. Let's add `DirectorPurchaser` and `BoardPurchaser`
    so we can make purchases at a higher cost.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以扩展这个脚本。让我们添加`DirectorPurchaser`和`BoardPurchaser`，这样我们就可以以更高的成本进行购买。
- en: We'll create a `DirectorPurchaser` who can buy under $10,000.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`DirectorPurchaser`，他可以在10,000美元以下购买。
- en: 'This class is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类如下：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s do the same for a `BoardPurchaser` class who can purchase below $100,000:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`BoardPurchaser`类做同样的事情，他可以在10万美元以下购买：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now we can update our `index.php` script to require the new classes, instantiate
    them, and then bind everything together in a chain. Finally, we'll attempt to
    run a purchase by calling the first in the chain.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更新我们的`index.php`脚本，需要新的类，实例化它们，然后将所有内容绑定在一起。最后，我们将尝试通过调用链中的第一个来运行购买。
- en: 'Here''s the script:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是脚本：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here''s the output of this script:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此脚本的输出：
- en: '![Chain of Responsibility](graphics/image_05_014.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![责任链](graphics/image_05_014.jpg)'
- en: This allows us to traverse a chain of objects to process data. This is particularly
    useful when dealing with tree data structures (for example, an XML tree). This
    can act in a launch-and-leave manner where we can lower the overhead of handling
    iterating through the chain.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够遍历一系列对象来处理数据。当处理树数据结构（例如，XML树）时，这是特别有用的。这可以以启动并离开的方式工作，我们可以降低处理遍历链的开销。
- en: Moreover, the chain is loosely coupled, data is passed through a chain until
    it is processed. Any object can be chained to any other object in any order.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，链是松散耦合的，数据通过链传递直到被处理。任何对象都可以链接到任何其他对象，任何顺序。
- en: Strategy design pattern
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略设计模式
- en: The Strategy design pattern exists to allow us to alter the behavior of an object
    at runtime.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 策略设计模式存在是为了允许我们在运行时改变对象的行为。
- en: Let's suppose we have a class that will raise a number to a power, but at runtime
    we want to alter whether we square or cube a number.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个类，将一个数字提高到一个幂，但在运行时我们想要改变是否平方或立方一个数字。
- en: 'Let''s start off by defining an interface a function that will raise a number
    to a given power:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义一个接口，一个将数字提高到给定幂的函数：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can accordingly define classes to `Square` and also `Cube` a given number
    by implementing the interface.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以相应地定义`Square`和`Cube`一个给定数字的类，通过实现接口。
- en: 'Here''s our `Square` class:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`Square`类：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And let''s define our `Cube` class:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义我们的`Cube`类：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can now build a class that will essentially use one of these classes to process
    a number.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以构建一个类，它将基本上使用其中一个这些类来处理一个数字。
- en: 'Here''s the class:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个类：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we can demonstrate this whole setup using an `index.php` file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`index.php`文件来演示整个设置：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The output is as expected, 5² is `25`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如预期，5²是`25`。
- en: 'Here''s the output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Strategy design pattern](graphics/image_05_015.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![策略设计模式](graphics/image_05_015.jpg)'
- en: 'We can swap the `Square` object with the `Cube` object in our `index.php` file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的`index.php`文件中用`Cube`对象替换`Square`对象：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here''s the output of the updated script:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更新脚本的输出：
- en: '![Strategy design pattern](graphics/image_05_016.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![策略设计模式](graphics/image_05_016.jpg)'
- en: So far so good; but the reason that this is great is the fact that we can dynamically
    add logic that actually changes the operation of the class.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利；但之所以伟大的原因是我们可以动态添加实际改变类操作的逻辑。
- en: 'Here''s a rather crude demonstration of all this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是所有这些的一个相当粗糙的演示：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'So just to demonstrate this, let''s run the script with the *n*`GET` variable
    set to `4`, which should cube the number `4`, giving an output of `64`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 所以为了演示这一点，让我们运行脚本，将*n*`GET`变量设置为`4`，这应该将数字`4`立方，得到一个输出`64`：
- en: '![Strategy design pattern](graphics/image_05_017.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![策略设计模式](graphics/image_05_017.jpg)'
- en: 'Now if we pass through the number `6`, we expect the script to square the number
    `6`, giving an output of `36`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们通过数字`6`，我们期望脚本将数字`6`平方，得到一个输出`36`：
- en: '![Strategy design pattern](graphics/image_05_018.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![策略设计模式](graphics/image_05_018.jpg)'
- en: 'In this design pattern, we have done a lot:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种设计模式中，我们已经做了很多：
- en: We defined a family of algorithms, bound by one common interface
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一系列算法，它们都有一个共同的接口
- en: These algorithms are interchangeable; they can be swapped in and out without
    affecting the client implementation
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些算法是可以互换的；它们可以在不影响客户端实现的情况下进行交换
- en: We encapsulated each algorithm within a class
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在一个类中封装了每个算法
- en: Now we can vary the algorithm independently from the clients that use it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以独立于使用它的客户端来变化算法。
- en: Specification design pattern
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范设计模式
- en: The Specification design pattern is incredibly powerful. Here, I will attempt
    to provide a high-level overview of it, but there is plenty to explore; I highly
    recommend the paper *Specifications* by *Eric Evans* and *Martin Fowler* if you
    are interested in learning more.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 规范设计模式非常强大。在这里，我将尝试对其进行高层概述，但还有很多可以探索；如果您有兴趣了解更多，我强烈推荐*Eric Evans*和*Martin Fowler*的论文*Specifications*。
- en: This design pattern is used to codify business rules that state something about
    an object. They tell us whether an object satisfies some business criteria or
    not.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式用于编码关于对象的业务规则。它们告诉我们一个对象是否满足某些业务标准。
- en: 'We can use them in the following ways:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以以下方式使用它们：
- en: To make assertions about an object, for *validation*
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于*验证*一个对象，我们可以做出断言
- en: To fetch a *selection* of objects from a given collection
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从给定集合中获取*选择*的对象
- en: To specify how an object can be created by *building to order*
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了指定如何通过*按订单制造*来创建对象
- en: In this example, we're going to build Specification to query
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将构建规范来查询
- en: 'Let''s take the following objects:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下对象：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let's kick things off with an `EmployeeSpecification` interface; this is the
    interface that all our specifications will need to implement. Be sure to replace
    `StdClass` with the type of object you're dealing with (for example, employee,
    or the name of the class you instantiated the object from).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个`EmployeeSpecification`接口开始；这是我们所有规范都需要实现的接口。确保用您处理的对象类型（例如，员工，或您从实例化对象的类的名称）替换`StdClass`。
- en: 'Here''s the code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It''s time to write an implementation called `EmployeeIsEngineer`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写一个名为`EmployeeIsEngineer`的实现了：
- en: '[PRE40]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can then iterate through our workers to check which ones meet the criteria
    we outlined:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以遍历我们的工作人员，检查哪些符合我们制定的标准：
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s put this all together in our `index.php` file:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这一切放在我们的`index.php`文件中：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here''s the output of this script:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此脚本的输出：
- en: '![Specification design pattern](graphics/image_05_019.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![规范设计模式](graphics/image_05_019.jpg)'
- en: Composite Specifications allow you to combine specifications. By using the `AND`,
    `NOT`, `OR` and  `NOR` operators you are able to build their respective functions
    into different specification classes.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 组合规范允许您组合规范。通过使用`AND`、`NOT`、`OR`和`NOR`运算符，您可以将它们的各自功能构建到不同的规范类中。
- en: Similarly, you can also fetch objects using a specification.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您也可以使用规范来获取对象。
- en: This code gets more complicated as you go further, but you understand the gist.
    Indeed, the paper by Eric Evans and Martin Fowler I mentioned at the start of
    the section goes into some far more complicated arrangements.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 随着代码的进一步复杂化，这段代码变得更加复杂，但是您理解了要点。事实上，我在本节开头提到的Eric Evans和Martin Fowler的论文涉及了一些更加复杂的安排。
- en: Either way, this design pattern fundamentally allows us to encapsulate business
    logic to state something about an object. It is an incredibly powerful design
    pattern and I would highly encourage studying it more deeply.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这种设计模式基本上允许我们封装业务逻辑以陈述关于对象的某些事情。这是一种非常强大的设计模式，我强烈鼓励更深入地研究它。
- en: Scheduled Task pattern
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定期任务模式
- en: 'A scheduled task fundamentally consists of three things: the task itself, the
    jobs that do the scheduling by defining when the task that is being run and when
    it is permitted to run, and finally, the job registry that executes this job.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 定期任务基本上由三个部分组成：任务本身，通过定义任务运行的时间和允许运行的时间来进行调度的作业，最后是执行此作业的作业注册表。
- en: 'Commonly, these are implemented by using cron on Linux servers. You add a line
    to the `configuration` file using the following configuration syntax:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些是通过在Linux服务器上使用cron来实现的。您可以使用以下配置语法向“配置”文件添加一行：
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can ordinarily edit the `cron` file by running `crontab -e` in the command
    line. You can schedule any Linux command using this pattern. Here''s a cronjob
    that will run a PHP script at 20:00 (8 PM) every day:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以通过在命令行中运行`crontab -e`来编辑`cron`文件。您可以使用此模式安排任何Linux命令。以下是一个cron作业，将在每天20:00（晚上8点）运行一个PHP脚本：
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'These are very simple to run to implement, but here are some guidelines to
    help guide you when you create them:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实现起来非常简单，但是在创建它们时，以下是一些指导方针可以帮助您：
- en: Don't expose your cronjobs to the Internet.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将您的cron作业暴露给互联网。
- en: When you run the task, the task shouldn't check the criteria as to whether it
    needs to run or not. This test should be outside the task.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当运行任务时，任务不应检查是否需要运行的标准。这个测试应该在任务之外。
- en: The task should only do the scheduled activity it's intended to do and not perform
    any other purpose.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务应该只执行其预期执行的计划活动，而不执行任何其他目的。
- en: Beware of the Database-as-IPC pattern we discussed in [Chapter 7](ch07.html
    "Chapter 7. Refactoring"), Refactoring.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谨防我们在[第7章](ch07.html "第7章。重构")中讨论的数据库作为IPC模式，重构。
- en: You can put whatever you want in the task (within reason). You may find an asynchronous
    execution the best route. Icicle is a great PHP library for performing async behavior.
    You can find the documentation online at [https://icicle.io/](https://icicle.io/).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在任务中放入任何您想要的东西（在合理范围内）。您可能会发现异步执行是最佳路线。Icicle是一个执行异步行为的出色的PHP库。您可以在[https://icicle.io/](https://icicle.io/)上找到在线文档。
- en: Where our task needs several tasks to be done in a specific order, you may benefit
    from using the Composite design pattern we discussed in the Structural design
    patterns section and calling a single task that uses this pattern to call other
    tasks using this pattern.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的任务需要按特定顺序完成几项任务时，您可能会从使用我们在结构设计模式部分讨论的组合设计模式中受益，并调用使用此模式调用其他任务的单个任务。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've covered some patterns that identify common communication
    patterns between objects.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了一些识别对象之间常见通信模式的模式。
- en: We covered how the Observer pattern can be used to update observers on the status
    of a given subject. Additionally, we learned how the standard PHP library contains
    functionality that can help us with this.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了观察者模式如何用于更新观察者关于给定主题状态的。此外，我们还了解了标准PHP库包含的功能可以帮助我们实现这一点。
- en: We then went on to cover how we can implement iterators in many different ways
    in PHP, using various interfaces in the PHP core alongside utilizing the generator
    function.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续讨论了如何在PHP中以许多不同的方式实现迭代器，使用PHP核心中的各种接口以及利用生成器函数。
- en: We went on to discuss how the Template pattern can define an algorithm skeleton
    that we can dynamically adapt in a more stringent way than standard polymorphism.
    We covered the Chain of Responsibility pattern, which allows us link together
    objects in a chain to execute various functionality. The Strategy pattern taught
    us how we can alter behavior of code at runtime. I then introduced the basics
    of the Specification pattern and how advanced the functionality in it is. Finally,
    we revised the Scheduled Task pattern and how it can be implemented using cron
    on Linux.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续讨论了模板模式如何定义算法骨架，我们可以以比标准多态性更严格的方式动态调整它。我们讨论了责任链模式，它允许我们将对象链接在一起以执行各种功能。策略模式教会了我们如何在运行时改变代码的行为。然后我介绍了规范模式的基础知识以及其中的高级功能。最后，我们复习了定期任务模式以及如何使用Linux上的cron来实现它。
- en: These design patterns are some of the most critical ones for developers. Communication
    between objects is vital in many projects and these patterns can really aid us
    in this communication.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设计模式对开发人员来说是一些最关键的设计模式。对象之间的通信在许多项目中至关重要，而这些模式确实可以帮助我们进行这种通信。
- en: In the next chapter, we'll look at Architectural patterns and how these can
    help you with the software architecture tasks that arise and how these can help
    you address the broader software engineering challenges you may face (though they
    may not be technically considered design patterns themselves).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论架构模式以及这些模式如何帮助您处理出现的软件架构任务，以及如何帮助您解决可能面临的更广泛的软件工程挑战（尽管它们在技术上可能不被认为是设计模式本身）。
