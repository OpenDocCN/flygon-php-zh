- en: Chapter 2. Development Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。开发环境
- en: In this chapter, we will start building our application based on microservices
    now that we know why microservices are necessary for the development of our application
    and the advantages we can enjoy if we base the application on microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始构建基于微服务的应用程序，现在我们知道为什么微服务对于应用程序的开发是必要的，以及如果我们基于微服务构建应用程序可以享受到的优势。
- en: The application that we will develop in this book (which is similar to Pokemon
    GO) is called *Finding secrets*. This application will be like a game using geolocation
    to find different secrets around the world. The entire world keeps a lot of hidden
    secrets and the players will have to find them as soon as possible. There are
    100 different kinds of secrets, and they will generate and appear in different
    parts of the world every day, so the players will be able to find them by walking
    around different areas and checking to see if there are any kind of secrets nearby.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中开发的应用程序（类似于Pokemon GO）被称为“寻找秘密”。这个应用程序将像一个使用地理位置信息来寻找世界各地不同秘密的游戏。整个世界都隐藏着许多秘密，玩家们必须尽快找到它们。有100种不同类型的秘密，它们每天会在世界的不同地方生成和出现，因此玩家可以通过在不同地区四处走动并检查附近是否有任何类型的秘密来找到它们。
- en: The secrets will be saved in the application wallet and if the player finds
    a secret that they already have in their wallet, they will not be able to collect
    it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密将保存在应用程序钱包中，如果玩家发现他们已经拥有的秘密，他们将无法收集它。
- en: The players will be able to duel against other players if they are close. The
    duel consists of throwing a dice to get the highest number, and the player who
    loses will give a random secret to the other player.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以在附近与其他玩家进行决斗。决斗包括掷骰子以获得最高点数，输掉的玩家将向另一名玩家随机透露一个秘密。
- en: In the subsequent chapters, the specific functions will be more detailed, but
    in this chapter, we only need to know how the applications works in order to have
    a general overview of the entire application to start building the basic platform
    based on microservices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，具体功能将更加详细，但在本章中，我们只需要了解应用程序的工作方式，以便对整个应用程序有一个总体概述，从而开始构建基于微服务的基本平台。
- en: Design and architecture to build the basic platform for microservices
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于构建微服务基本平台的设计和架构
- en: Creating an application based on microservices is not like a monolithic application.
    For this reason, we have to divide our functionalities into different services.
    To do this, it is important to follow an adequate design and structure each of
    the microservices according to its requirements.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 创建基于微服务的应用程序不像单片应用程序。因此，我们必须将功能划分为不同的服务。为此，根据其要求，按照适当的设计和结构每个微服务是很重要的。
- en: The design takes care of dividing the application into logical parts and groups
    them according to their existing relationship. The architecture takes care of
    defining which concrete elements support each of the microservices, for example,
    where the data is stored or the communication between the services.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 设计负责将应用程序分成逻辑部分，并根据它们的现有关系对它们进行分组。架构负责定义哪些具体元素支持每个微服务，例如数据存储位置或服务之间的通信。
- en: 'Throughout the book, we will follow the given structure for each microservice.
    In the following image, you will see the structure of one of the microservices,
    the rest of them are similar; however, some parts are optional:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将遵循每个微服务的给定结构。在下图中，您将看到一个微服务的结构，其余的微服务类似；但是，有些部分是可选的：
- en: '![Design and architecture to build the basic platform for microservices](graphics/B06142_02_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![用于构建微服务基本平台的设计和架构](graphics/B06142_02_01.jpg)'
- en: All the requests for our microservices come from a **REVERSE PROXY** as this
    allows us to balance the load. Also, we use **NGINX** as a gateway for the **API**
    built in PHP. To reduce the load and increase the performance of PHP and **NGINX**,
    we can use a **CACHE** layer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有微服务的请求都来自反向代理，因为这样可以平衡负载。此外，我们使用NGINX作为PHP构建的API的网关。为了减少负载并提高PHP和NGINX的性能，我们可以使用缓存层。
- en: In case we need to execute big, resource consuming tasks, or the tasks do not
    need to be executed in a concrete time window, our **API** can use a **QUEUE** system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要执行大型、消耗资源的任务，或者任务不需要在具体时间窗口内执行，我们的API可以使用队列系统。
- en: In case we need to store some data, our **API** is responsible for managing
    the access and saving the data in our **DATA STORE**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要存储一些数据，我们的API负责管理访问并将数据保存在我们的数据存储中。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, we will be using containerization, a new virtualization method
    which spins ups containers instead of full virtual machines. Each container will
    have only the minimum resources and software installed to run your application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用容器化，这是一种新的虚拟化方法，它会启动容器而不是完整的虚拟机。每个容器只会安装运行应用程序所需的最低资源和软件。
- en: We can use Telemetry (it is a system that gets the stats from the container)
    and autodiscovery (it is a system that helps us to see which containers are working
    properly) to supervise the container ecosystem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用遥测（它是一个从容器获取统计数据的系统）和自动发现（它是一个帮助我们查看哪些容器正常工作的系统）来监督容器生态系统。
- en: Requirements to start working on microservices
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用微服务的要求
- en: Now that you understand why you can use PHP (especially the latest release,
    version 7) for your next project, it is time to talk about other requirements
    for the success of your microservices project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了为什么可以使用PHP（特别是最新版本7）来进行下一个项目，是时候谈谈您的微服务项目成功的其他要求了。
- en: You probably have the importance of the scalability of your application in mind,
    but how can you do it within a budget? The response is virtualization. With this
    technology, you will be wasting less resources. In the past, only one **Operating
    System** (**OS**) could be executed at a time on the same hardware, but with the
    birth of virtualization, you can have multiple OSes running concurrently. The
    greatest achievement in your project will be that you will be running more servers
    dedicated to your microservices but using less hardware.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经意识到应用程序的可扩展性的重要性，但如何在预算内实现呢？答案是虚拟化。使用这项技术，您将浪费更少的资源。过去，同一硬件上一次只能执行一个**操作系统**（**OS**），但随着虚拟化的诞生，您可以同时运行多个操作系统。您的项目最大的成就将是，您将运行更多专用于您的微服务的服务器，但使用更少的硬件。
- en: Given the advantages provided by the virtualization and containerization, nowadays
    using containers in the development of an application based on microservices is
    a default standard. There are multiple containerization projects, but the most
    used and supported is Docker. For this reason, this is the main requirement to
    start working with microservices.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于虚拟化和容器化提供的优势，如今在基于微服务的应用程序开发中使用容器已成为默认标准。有多个容器化项目，但最常用和受支持的是Docker。因此，这是开始使用微服务的主要要求。
- en: 'The following are the different tools/software that we will be using in our
    Docker environment:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在Docker环境中使用的不同工具/软件：
- en: PHP 7
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 7
- en: 'Data storage: Percona, MySQL, PostgreSQL'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储：Percona，MySQL，PostgreSQL
- en: 'Reverse proxy: NGINX, Fabio, Traefik,'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向代理：NGINX，Fabio，Traefik
- en: 'Dependency management: composer'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖管理：composer
- en: 'Testing tools: PHPUnit, Behat, Selenium'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试工具：PHPUnit，Behat，Selenium
- en: 'Version control: Git'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制：Git
- en: In [Chapter 5](ch05.html "Chapter 5. Microservices Development"), *Microservices
    Development*, we will explain how to add each one to our project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章 微服务开发")中，*微服务开发*，我们将解释如何将它们添加到我们的项目中。
- en: Due to the fact that our main requirement is a containerization suite, we will
    explain how to install and test Docker in the following sections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的主要要求是容器化套件，我们将在接下来的章节中解释如何安装和测试Docker。
- en: Docker installation
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker安装
- en: 'Docker can be installed from two different channels, each one with advantages
    and disadvantages:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Docker可以从两个不同的渠道安装，各有优缺点：
- en: '**Stable channel**: As the name indicates, everything you install from this
    channel is fully tested and you will have the latest GA version of the Docker
    engine. This is the most reliable platform and therefore, suitable for production
    environments. Through this channel, the releases follow a version schedule with
    long testing and beta times, only to ensure that everything should work as expected.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳定渠道**：顾名思义，您从该渠道安装的所有内容都经过充分测试，您将获得Docker引擎的最新GA版本。这是最可靠的平台，因此适用于生产环境。通过该渠道，发布遵循版本计划，经过长时间的测试和beta时间，只是为了确保一切都应该按预期工作。'
- en: '**Beta channel**: If you need to have the latest features, this is your channel.
    All the installers come with the experimental version of the Docker engine where
    bugs can be found, so it is not recommended for production environments. This
    channel is a continuation of the Docker beta program where you can provide feedback
    and there is no version schedule, so you will have more frequent releases.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Beta channel**: 如果您需要拥有最新功能，这是您的渠道。所有安装程序都配备了Docker引擎的实验版本，可能会出现错误，因此不建议用于生产环境。该渠道是Docker
    beta计划的延续，您可以提供反馈，没有版本计划，因此会有更频繁的发布。'
- en: We will be developing for a stable production environment, so you can forget
    about the beta channel for now as all you need is on the stable releases.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个稳定的生产环境，所以现在您可以忘记beta渠道，因为您所需的一切都在稳定版本中。
- en: 'Docker was born in Linux, so the best implementation was done for this OS.
    With other OSes, such as Windows or macOS, you have two options: a native implementation
    and a toolbox installation if you cannot use the native implementation.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Docker诞生于Linux，因此最佳实现是针对该操作系统完成的。对于其他操作系统，如Windows或macOS，您有两个选择：本机实现和如果无法使用本机实现，则进行工具箱安装。
- en: Installing Docker on macOS
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在macOS上安装Docker
- en: On macOS, you have two options to install Docker depending on whether your machine
    matches the minimum requirements or not. With relatively new machines (OS X 10.10
    Yosemite and higher), you can install the native implementation that uses Hyperkit,
    a lightweight OS X virtualization solution built on top of **Hypervisor.Framework**.
    If you have an older machine that does not match the minimum requirements, you
    can install the Docker Toolbox.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，您有两种安装Docker的选择，取决于您的机器是否符合最低要求。对于相对较新的机器（OS X 10.10 Yosemite及更高版本），您可以安装使用Hyperkit的本机实现，这是一个轻量级的OS
    X虚拟化解决方案，构建在**Hypervisor.Framework**之上。如果您有一台不符合最低要求的旧机器，您可以安装Docker工具箱。
- en: Docker for Mac (alias, native implementation) versus Docker toolbox
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Docker for Mac（别名，本机实现）与Docker工具箱
- en: The Docker Toolbox was the first implementation of Docker on macOS and it does
    not have a deep OS integration. It uses VirtualBox to spin a Linux virtual machine
    where Docker will be running. Using a **Virtual Machine** (**VM**) where you will
    be running all your containers has numerous problems, the most noticeable being
    the poor performance. However, it is the desired choice if your machine does not
    match the requirements for the native implementation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Docker工具箱是macOS上Docker的第一个实现，它没有深度的操作系统集成。它使用VirtualBox来启动一个Linux虚拟机，Docker将在其中运行。在虚拟机中运行所有容器会有很多问题，最明显的是性能不佳。但是，如果您的机器不符合本机实现的要求，这是理想的选择。
- en: Docker for Mac is a native Mac application with a native user interface and
    auto-update capability, and it is deeply integrated with OS X native virtualization
    (Hypervisor.Framework), networking, and filesystem. This version is faster, easier
    to use, and more reliable than the Docker Toolbox.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Mac上的Docker是一个本地Mac应用程序，具有本地用户界面和自动更新功能，并且与OS X本地虚拟化（Hypervisor.Framework）、网络和文件系统深度集成。这个版本比Docker
    Toolbox更快、更易于使用，更可靠。
- en: Minimum requirements
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最低要求
- en: Mac must be a 2010 or newer model, with Intel's hardware support for **Memory
    Management Unit** (**MMU**) virtualization; that is, **Extended Page Tables**
    (**EPT**)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mac必须是2010年或更新的型号，具有英特尔硬件对**内存管理单元**（**MMU**）虚拟化的支持；也就是**扩展页表**（**EPT**）。
- en: OS X 10.10.3 Yosemite or newer
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OS X 10.10.3 Yosemite或更新版本
- en: At least 4 GB of RAM
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少4GB的RAM
- en: VirtualBox prior to version 4.3.30 must not be installed (it is incompatible
    with Docker for Mac)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在安装Docker for Mac之前，不能安装VirtualBox 4.3.30之前的版本（它与Mac上的Docker不兼容）
- en: Docker for Mac installation process
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Mac上的Docker安装过程
- en: If your machine passes the requirements, you can download the Docker for Mac
    from the official page, that is [https://www.docker.com/products/docker](https://www.docker.com/products/docker).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的机器符合要求，你可以从官方页面下载Mac上的Docker，即[https://www.docker.com/products/docker](https://www.docker.com/products/docker)。
- en: 'Once you have the image downloaded on your machine, you can carry out the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在你的机器上下载了镜像，你可以执行以下步骤：
- en: Double-click on the downloaded image (called `Docker.dmg`) to open the installer.
    Once the image is mounted, you need to drag and drop the Docker app into the `Applications`
    folder:![Docker for Mac installation process](graphics/B06142_02_02.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击下载的镜像（名为`Docker.dmg`）以打开安装程序。一旦镜像被挂载，你需要将Docker应用程序拖放到`Applications`文件夹中：![Mac上的Docker安装过程](graphics/B06142_02_02.jpg)
- en: The `Docker.app` may ask you for your password during the installation process
    to install and set up network components in the privileged mode.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Docker.app`在安装过程中可能会要求你输入密码，以特权模式安装和设置网络组件。'
- en: Once the installation is complete, Docker will be available on your Launchpad and
    in your `Applications` folder. Execute the application to start Docker. Once Docker
    starts up, you will see the whale icon in your toolbar. This will be your quick
    access to settings.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，Docker将出现在你的Launchpad和`Applications`文件夹中。执行该应用程序以启动Docker。一旦Docker启动，你将在工具栏中看到鲸鱼图标。这将是你快速访问设置的方式。
- en: Click on the toolbar whale for **Preferences...** and other options:![Docker
    for Mac installation process](graphics/B06142_02_03.jpg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击工具栏上的鲸鱼图标以获取**首选项...**和其他选项：![Mac上的Docker安装过程](graphics/B06142_02_03.jpg)
- en: Click on **About Docker** to find out if you are running the latest version.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**关于Docker**以查看你是否在运行最新版本。
- en: Installing Docker on Linux
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Linux上安装Docker
- en: The Docker ecosystem was developed on top of Linux, so the installation process
    on this OS is easier. In the following pages, we will only cover the installation
    on **Community ENTerprise Operating System** (**CentOS**)/**Red Hat Enterprise
    Linux** (**RHEL**) (they use yum as the package manager) and Ubuntu (uses apt
    as the package manager).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Docker生态系统是在Linux上开发的，因此在这个操作系统上的安装过程更容易。在接下来的页面中，我们将只涵盖在**Community ENTerprise
    Operating System**（**CentOS**）/**Red Hat Enterprise Linux**（**RHEL**）（它们使用yum作为包管理器）和Ubuntu（使用apt作为包管理器）上的安装。
- en: CentOS/RHEL
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CentOS/RHEL
- en: Docker can be executed on CentOS 7 and on any other binary compatible EL7 distribution
    but Docker is not tested or supported on these compatible distributions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Docker可以在CentOS 7上执行，也可以在任何其他二进制兼容的EL7发行版上执行，但Docker在这些兼容的发行版上没有经过测试或支持。
- en: Minimum requirements
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最低要求
- en: 'The minimum requirement to install and execute Docker is to have a 64-bit OS
    and a kernel version 3.10 or higher. If you need to know your current version,
    you can open a terminal and execute the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和执行Docker的最低要求是拥有64位操作系统和3.10或更高版本的内核。如果你需要知道你当前的版本，你可以打开终端并执行以下命令：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that it's recommended to have your OS up to date as it will avoid any potential
    kernel bugs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，建议你的操作系统保持最新，以避免任何潜在的内核错误。
- en: Installing Docker using yum
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用yum安装Docker
- en: First of all, you need to have a user with root privileges; you can log in on
    your machine as this user or use a `sudo` command on the terminal of your choice.
    In the following steps, we assume that you are using a root or privileged user
    (add sudo to the commands if you are not using a root user).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要有一个具有root权限的用户；你可以以这个用户登录你的机器，或者在你选择的终端上使用`sudo`命令。在接下来的步骤中，我们假设你正在使用一个root或特权用户（如果你没有使用root用户，请在命令中添加sudo）。
- en: 'First of all, ensure that all your existing packages are up to date:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先确保你所有现有的包都是最新的：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that your machine has the latest packages available, you need to add the
    official Docker `yum` repository:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的机器已经有了最新的可用包，你需要添加官方Docker `yum`存储库：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After adding the yum repository to your CentOS/RHEL, you can easily install
    the Docker package with the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在将yum存储库添加到你的CentOS/RHEL之后，你可以使用以下命令轻松安装Docker包：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can add the Docker service to the startup of your OS with the `systemctl` command
    (this step is optional):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`systemctl`命令将Docker服务添加到你的操作系统的启动中（这一步是可选的）：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The same `systemctl` command can be used to start the service:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的`systemctl`命令可以用来启动服务：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now you have everything installed and running, so you can start testing and
    playing with Docker.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装并运行了所有东西，所以你可以开始测试和玩Docker了。
- en: Post-install setup - creating a Docker group
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装后设置 - 创建Docker组
- en: Docker is executed as a daemon that binds to a Unix socket. This socket is owned
    by root, so the only way for other users to access it is with the `sudo` command.
    Using the `sudo` command every time you use any Docker command can be painful,
    but you can create a Unix group, called `docker`, and assign users to this group.
    By making this small change, the Docker daemon will start and assign the ownership
    of the Unix socket to this new group.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Docker作为绑定到Unix套接字的守护程序执行。此套接字由root拥有，因此其他用户访问它的唯一方式是使用`sudo`命令。每次使用任何Docker命令都要使用`sudo`命令可能很痛苦，但您可以创建一个名为`docker`的Unix组，并将用户分配给该组。通过进行这个小改变，Docker守护程序将启动并将Unix套接字的所有权分配给这个新组。
- en: 'Listed are the commands to create a Docker group:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建Docker组的命令：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After these commands, you need to log out and log in again to refresh your permissions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完这些命令后，您需要注销并重新登录以刷新权限。
- en: Installing Docker on Ubuntu
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Ubuntu上安装Docker
- en: 'Ubuntu is officially supported and the main recommendation is to use an LTS
    (the last version is always recommended):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu得到官方支持，主要建议使用LTS（始终建议使用最新版本）：
- en: Ubuntu Xenial 16.04 (LTS)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu Xenial 16.04（LTS）
- en: Ubuntu Trusty 14.04 (LTS)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu Trusty 14.04（LTS）
- en: Ubuntu Precise 12.04 (LTS)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu Precise 12.04（LTS）
- en: Just as in the previous Linux installation steps, we are assuming that you are
    using a root or privileged user to install and set up Docker.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的Linux安装步骤一样，我们假设您是使用root或特权用户来安装和设置Docker。
- en: Minimum requirements
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最低要求
- en: As with other Linux distributions, a 64-bit version is required and your kernel
    version needs to be at least a 3.10\. Older kernel versions have known bugs that cause
    data loss and frequent kernel panics.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他Linux发行版一样，需要64位版本，并且您的内核版本至少需要3.10。较旧的内核版本存在已知的错误，会导致数据丢失和频繁的内核崩溃。
- en: 'To check your current kernel version, open your favorite terminal and run:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查当前的内核版本，请打开您喜欢的终端并运行：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Installing Docker using apt
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用apt安装Docker
- en: 'First of all, ensure that you have your apt sources pointing to the Docker
    repository, especially if you have previously installed Docker from the apt. In
    addition to this, update your system:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先确保您的apt源指向Docker存储库，特别是如果您之前是通过apt安装Docker。另外，更新您的系统：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that you have your system up to date, it is time to install some required
    packages and the new GPG key:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的系统已经更新，是时候安装一些必需的软件包和新的GPG密钥了：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With Ubuntu, it is very easy to add the official Docker repository; you only
    need to create (or edit) the `/etc/apt/sources.list.d/docker.list` file in your
    favorite editor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu上，很容易添加官方Docker存储库；您只需要在您喜欢的编辑器中创建（或编辑）`/etc/apt/sources.list.d/docker.list`文件。
- en: 'In the case of having the previous lines from old repositories, delete all
    the content and add one of the following entries. Ensure that you match your current
    Ubuntu version:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的旧存储库中有上述行，请删除所有内容并添加以下条目之一。确保与您当前的Ubuntu版本匹配：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After saving the file, you need to update the `apt` package index:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，您需要更新`apt`软件包索引：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the case of having a previous Docker repo on your Ubuntu, you need to purge
    the old repo:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Ubuntu上有以前的Docker存储库，则需要清除旧存储库：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On Trusty and Xenial, it is recommended that you install the `linux-image-extra-*`
    kernel package that allows you to use the AFUS storage driver. To install them,
    run the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Trusty和Xenial上，建议安装`linux-image-extra-*`内核包，允许您使用AFUS存储驱动程序。要安装它们，请运行以下命令：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: On Precise, Docker requires a 3.13 kernel version, so ensure that you have the
    correct kernel; if your version is older, you must upgrade it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Precise上，Docker需要3.13内核版本，因此请确保您有正确的内核；如果您的版本较旧，则必须升级。
- en: 'At this point, your machine will be more than ready to install Docker. It can
    be done with a single command, as with `yum`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的机器将准备好安装Docker。可以使用单个命令，如`yum`：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that you have everything installed and running, you can start playing and
    testing Docker.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装并运行了所有内容，可以开始使用和测试Docker。
- en: Common issues on Ubuntu
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Ubuntu上的常见问题
- en: 'If you see errors related to swap limits while you are using Docker, you need
    to enable memory and swap on your system. It can be done on GNU GRUB by following
    the given steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在使用Docker时看到与交换限制相关的错误，则需要在系统上启用内存和交换。可以通过GNU GRUB按照给定的步骤完成：
- en: Edit the `/etc/default/grub` file.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`/etc/default/grub`文件。
- en: 'Set the `GRUB_CMDLINE_LINUX` as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`GRUB_CMDLINE_LINUX`设置如下：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Update grub:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新grub：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Reboot the system.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动系统。
- en: UFW forwarding
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: UFW转发
- en: Ubuntu comes with **Uncomplicated Firewall** (**UFW**) and if it is enabled
    on the same host as the one where you run Docker, you will need to make some adjustments
    because, by default, UFW will drop any forwarding traffic. Also, UFW will deny
    any incoming traffic, making the reach of your containers from a different host
    impossible. The Docker default port is 2376 when TLS is enabled and 2375 in other
    cases. On a clean installation, Docker runs without TLS enabled. Let's configure
    UFW!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu配备了**简化防火墙**（**UFW**），如果在运行Docker的同一主机上启用了它，您需要进行一些调整，因为默认情况下，UFW将丢弃任何转发流量。此外，UFW将拒绝任何传入流量，使得无法从不同主机访问您的容器。在干净的安装中，Docker在未启用TLS的情况下运行时，Docker默认端口为2376。让我们配置UFW！
- en: 'First, you can check if UFW is installed and enabled:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以检查UFW是否已安装并启用：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that you are sure that UFW is installed and running, you can edit the `config`
    file, `/etc/default/ufw`, with your favorite editor and set up the `DEFAULT_FORWARD_POLICY`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您确定UFW已安装并运行，可以使用您喜欢的编辑器编辑`config`文件`/etc/default/ufw`，并设置`DEFAULT_FORWARD_POLICY`：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can now save and close the `config` file and, after the restart of the
    UFW, your changes will be available:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以保存并关闭`config`文件，在重新启动UFW后，您的更改将生效：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Allowing incoming connections to the Docker port can be done with the `ufw`
    command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 允许传入连接到Docker端口可以使用`ufw`命令完成：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: DNS server
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DNS服务器
- en: Ubuntu and its derivatives use 127.0.0.1 as the default name server in the `/etc/resolv.conf`
    file, so when you start containers with this configuration, you will see warnings
    because Docker can't use the local DNS nameserver.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu及其衍生产品在`/etc/resolv.conf`文件中使用127.0.0.1作为默认名称服务器，因此当您使用此配置启动容器时，您将看到警告，因为Docker无法使用本地DNS名称服务器。
- en: If you want to avoid these warnings you need to specify a DNS server to be used
    by Docker or disable `dnsmasq` in the `NetworkManager`. Note that disabling `dnsmasq`
    will make DNS resolutions a little bit slower.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要避免这些警告，您需要指定一个DNS服务器供Docker使用，或者在`NetworkManager`中禁用`dnsmasq`。请注意，禁用`dnsmasq`会使DNS解析变慢一点。
- en: 'To specify a DNS server, you can open the `/etc/default/docker` file with your
    favorite editor and add the following setting:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定DNS服务器，您可以使用您喜欢的编辑器打开`/etc/default/docker`文件，并添加以下设置：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Replace `8.8.8.8` with your local DNS server. If you have multiple DNS servers,
    you can add multiple `--dns` records separated with spaces. Consider the following
    example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将`8.8.8.8`替换为您的本地DNS服务器。如果您有多个DNS服务器，可以添加多个`--dns`记录，用空格分隔。考虑以下示例：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As soon as you have your changes saved, you need to restart the Docker daemon:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您保存了更改，您需要重新启动Docker守护程序：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you don''t have a local DNS server and you want to disable `dnsmasq`, open
    the `/etc/NetworkManager/NetworkManager.conf` file with your editor and comment
    out the following line:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有本地DNS服务器，并且想要禁用`dnsmasq`，请使用您的编辑器打开`/etc/NetworkManager/NetworkManager.conf`文件，并注释掉以下行：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Save the changes and restart the NetworkManager and Docker:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 保存更改并重新启动NetworkManager和Docker：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Post-install setup – creating a Docker group
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装后设置-创建Docker组
- en: Docker is executed as a daemon that binds to a Unix socket. This socket is owned
    by root, so the only way for other users to access it is with the `sudo` command.
    Using the `sudo` command every time you use any docker command can be painful,
    but you can create a Unix group, called `docker`, and assign users to this group.
    Making this small change, the Docker daemon will start and assign the ownership
    of the Unix socket to this new group.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Docker作为绑定到Unix套接字的守护程序执行。此套接字由root拥有，因此其他用户访问它的唯一方法是使用`sudo`命令。每次使用任何docker命令都使用`sudo`命令可能会很痛苦，但是您可以创建一个名为`docker`的Unix组，并将用户分配给此组。通过进行这个小改变，Docker守护程序将启动并将Unix套接字的所有权分配给这个新组。
- en: 'Perform the following steps to create a Docker group:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤创建一个Docker组：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After these steps, you need to log out and log in again to refresh your permissions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，您需要注销并重新登录以刷新权限。
- en: Starting Docker on boot
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启动时启动Docker
- en: Ubuntu 15.04 onwards uses the `systemd` system as its boot and service manager,
    while for versions 14.10 and the previous ones, it uses the `upstart` system.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从Ubuntu 15.04开始，使用`systemd`系统作为其引导和服务管理器，而对于14.10版本和之前的版本，则使用`upstart`系统。
- en: 'For the 15.04 and up systems, you can configure the Docker daemon to start
    on boot by running the given command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于15.04及更高版本的系统，您可以通过运行给定的命令将Docker守护程序配置为在启动时启动：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the case of using older versions, the installation method automatically configures
    upstart to start the Docker daemon on boot.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用旧版本的情况，安装方法会自动配置upstart以在启动时启动Docker守护程序。
- en: Installing Docker on Windows
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Windows上安装Docker
- en: 'The Docker team has made a huge effort to bring their entire ecosystem to any
    OS and they didn''t forget about Windows. As on macOS, you have two options to
    install Docker on this OS: a toolbox and a more native option.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Docker团队为将他们的整个生态系统带到任何操作系统做出了巨大的努力，他们没有忘记Windows。与macOS一样，您在此操作系统上安装Docker有两个选项：工具箱和更本地的选项。
- en: Minimum requirements
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最低要求
- en: Docker for Windows requires a 64-bit Windows 10 Pro, Enterprise, and Education
    (1511 November update, Build 10586 or later), and the `Hyper-V` package must be
    enabled.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Windows版的Docker需要64位的Windows 10专业版、企业版和教育版（1511年11月更新，版本10586或更高），并且必须启用`Hyper-V`包。
- en: In case your machine is running a different version, you can install the Toolbox
    that requires a 64-bit OS running at least Windows 7 and with virtualization enabled
    on the machine. As you can see, it has lighter requirements.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的计算机运行的是不同版本，您可以安装需要64位操作系统的工具箱，至少在Windows 7上运行，并且在计算机上启用了虚拟化。如您所见，它的要求更轻。
- en: Due to the fact that Docker for Windows requires at least a Pro/Enterprise/Education
    version and the majority of computers are sold with a different version, we will explain
    how to install Docker with the toolbox.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker for Windows至少需要专业/企业/教育版本，而大多数计算机都是使用不同版本出售的，我们将解释如何使用工具箱安装Docker。
- en: Installing the Docker tools
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装Docker工具
- en: The Docker tools use VirtualBox to spin a virtual machine that will run the
    Docker engine. The installation package can be downloaded from `https://www.docker.com/products/docker-toolbox`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Docker工具使用VirtualBox来启动运行Docker引擎的虚拟机。安装包可以从`https://www.docker.com/products/docker-toolbox`下载。
- en: Once you have the installer, you only need to double-click on the downloaded
    executable to start the installation process.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得安装程序，您只需要双击下载的可执行文件即可开始安装过程。
- en: 'The first window shown by the installer allows you to send debug information
    to Docker to improve the ecosystem. Allowing the Docker engine to send debug information
    from your development environment can help the community to find bugs and improve
    the ecosystem. The recommendation on this option is to have it enabled at least
    in your development environment:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序显示的第一个窗口允许您将调试信息发送到Docker，以改善生态系统。允许Docker引擎从您的开发环境发送调试信息可以帮助社区找到错误并改善生态系统。建议在开发环境中至少启用此选项：
- en: '![Installing the Docker tools](graphics/B06142_02_04.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![安装Docker工具](graphics/B06142_02_04.jpg)'
- en: Just like any other Windows installer, you can choose where it will be installed.
    In most cases, the default will be fine for your development environment.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他Windows安装程序一样，您可以选择安装的位置。在大多数情况下，默认设置对于您的开发环境来说是可以的。
- en: 'By default, the installer will add all the required packages and some extras
    to your machine. In this step of the installation, you can purge some non-required
    software. Some of the optional packages are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，安装程序将向您的计算机添加所有必需的软件包和一些额外的软件。在安装的这一步，您可以清除一些不必要的软件。以下是一些可选软件包：
- en: '**Docker compose for Windows**:In our opinion, this is a must as we will be
    using the package in our book.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows的Docker compose**：在我们看来，这是必不可少的，因为我们将在我们的书中使用这个软件包。'
- en: '**Kitematic for Windows:** This application is a GUI to manage your containers
    easily. If you are not comfortable with the command line, you can install this
    package.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows的Kitematic**：这个应用程序是一个GUI，可以轻松管理您的容器。如果您不习惯使用命令行，可以安装这个软件包。'
- en: '**Git for Windows:** This is another must-install package; we will be using
    Git to store and manage our project.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows的Git**：这是另一个必须安装的软件包；我们将使用Git来存储和管理我们的项目。'
- en: After choosing the packages we want to install, it is time for some additional
    tasks. The default selected tasks will be fine for your dev environment.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 选择要安装的软件包后，是时候进行一些额外的任务了。默认选择的任务对于您的开发环境来说是合适的。
- en: Now, you only need to confirm all the setup you have done in the previous steps
    before the installation starts.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您只需要在安装开始之前确认您在之前步骤中所做的所有设置。
- en: The installation can take several minutes to complete, so be patient.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 安装可能需要几分钟才能完成，所以请耐心等待。
- en: 'While the installation progresses, you may be alerted about the installation
    of an Oracle device. This is due to the fact that the tools are using VirtualBox
    to spin up a virtual machine to run the Docker engine. Install this device to
    avoid future headaches:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中，您可能会收到有关安装Oracle设备的警报。这是因为工具正在使用VirtualBox来启动一个虚拟机来运行Docker引擎。安装此设备以避免将来的麻烦：
- en: '![Installing the Docker tools](graphics/B06142_02_05.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![安装Docker工具](graphics/B06142_02_05.jpg)'
- en: Congratulations! You have Docker installed on your Windows machine. Don't waste
    another minute and start testing and playing with your Docker ecosystem.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经在Windows机器上安装了Docker。别浪费时间，开始测试和玩弄您的Docker生态系统。
- en: How to check your Docker engine, compose, and machine versions
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何检查您的Docker引擎、compose和machine版本
- en: 'Now that you have Docker installed, you only need to open your favorite terminal
    and type in the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了Docker，您只需要打开您喜欢的终端，并输入以下命令：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Quick example to check your Docker installation
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速检查Docker安装的示例
- en: 'You should have the Docker running and execute the following command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经运行Docker并执行以下命令：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding command will do the following things:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将执行以下操作：
- en: Execute the container in the background with `-d`
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-d`在后台执行容器
- en: Map the 8080 port of your machine to the 80 port of the container with `-p 8080:80`
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-p 8080:80`将您机器的8080端口映射到容器的80端口
- en: Assign a name to your container with `--name webserver-test`
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--name webserver-test`为您的容器分配一个名称
- en: Get the NGINX Docker image and make the container to run this image.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取NGINX Docker镜像并使容器运行此镜像。
- en: Now, open your favorite browser and navigate to `http://localhost:8080`, where
    you will see a default NGINX page.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开您喜欢的浏览器，导航到`http://localhost:8080`，您将看到一个默认的NGINX页面。
- en: Common management tasks
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见的管理任务
- en: By executing `docker ps` on your terminal, you can see the running containers.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在终端上执行`docker ps`，您可以查看正在运行的容器。
- en: The preceding command gives us a deeper view of the containers that are running
    on your machine, the image they are using, when they were created, the status,
    and the port mapping or the assigned name.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令让我们更深入地了解了在您的机器上运行的容器，它们正在使用的镜像，它们的创建时间，状态以及端口映射或分配的名称。
- en: Once you finish playing with your container, it's time to stop it. Execute `docker
    stop webserver-test` and the container will end its life.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 玩完容器后，是时候停止它了。执行`docker stop webserver-test`，容器将结束它的生命周期。
- en: Oops! You need the same container again. No problem, because a simple `docker
    start webserver-test` will again spin up the container for you.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！您需要再次使用相同的容器。没问题，因为简单的`docker start webserver-test`将再次为您启动容器。
- en: Now, it is time to stop and remove the container because you are not going to
    use it anymore. Executing `docker rm -f webserver-test` on your terminal will
    do the trick. Note that this command will remove the container but not the downloaded
    image we have used. For this last step, you can do a `docker rmi nginx`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候停止并删除容器了，因为您不再需要它。在您的终端上执行`docker rm -f webserver-test`就可以了。请注意，此命令将删除容器，但不会删除我们使用过的下载的镜像。对于最后一步，您可以执行`docker
    rmi nginx`。
- en: Version control – Git versus SVN
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制 - Git与SVN
- en: Version control is a tool that helps you recall the previous versions of your
    source code to check them and work with them; it is agnostic of the language or
    technology used and it is possible to use a version control in all softwares developed
    in plain text.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制是一种工具，它可以帮助您回顾以前的源代码版本，以便检查和处理它们；它与使用的语言或技术无关，并且可以在所有以纯文本开发的软件中使用版本控制。
- en: 'We can categorize the versioning control tools into the following categories:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将版本控制工具分类为以下几类：
- en: '**Centralized version**: Control system needs a centralized server to work
    and all developers need to be connected to it so that they synchronize and download
    the changes from it.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中式版本**：控制系统需要一个集中的服务器来工作，所有开发人员都需要连接到它，以便从中同步和下载更改。'
- en: '**Distributed version**: Control system is not centralized; in other words,
    each developer has the entire management version control system on their own machine,
    so it is possible to work locally and then synchronize it with a common server
    or with each developer. **Distributed Version Control Systems** (**DVCS**) are
    faster because they need less changes on the centralized or shared server.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式版本**：控制系统不是集中的；换句话说，每个开发人员在自己的机器上拥有整个管理版本控制系统，因此可以在本地工作，然后与公共服务器或每个开发人员同步。**分布式版本控制系统**（**DVCS**）更快，因为它们在集中或共享服务器上需要更少的更改。'
- en: Subversion (SVN) is a centralized version control system and, for this reason,
    some developers think that it is the best way to work respecting the entire project,
    so the developer just needs to write and read the access controllers in one place.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Subversion（SVN）是一个集中式版本控制系统，因此一些开发人员认为这是尊重整个项目工作的最佳方式，因此开发人员只需在一个地方编写和读取访问控制器。
- en: The entire code is hosted in one place, so it is possible to think that this
    way, it is easier to understand SVN better than Git. The truth is that the SVN
    command line is easier and there are more GUIs available for SVN. The reason is
    clear: SVN has existed since the year 2000, and Git came 5 years later.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 整个代码都托管在一个地方，因此可能认为这样更容易理解SVN而不是Git。事实是SVN命令行更简单，而且有更多的GUI可用于SVN。原因很明显：SVN自2000年以来就存在，而Git是5年后才出现的。
- en: Another advantage of SVN is that the system to number the versions is clearer;
    it uses a sequential number system (1,2,3,4...) and Git uses SHA-1 codes, which
    are more difficult to read and understand.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: SVN的另一个优点是版本编号系统更清晰；它使用顺序编号系统（1,2,3,4...），而Git使用更难以阅读和理解的SHA-1代码。
- en: Finally, with SVN, it is possible to get a subdirectory to work with it without
    the need of having the entire project. This is not a problem for small projects,
    but it can be difficult when you have a large project.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用SVN可以获得一个子目录来处理它，而无需拥有整个项目。对于小项目来说，这不是问题，但对于大项目来说可能会很困难。
- en: Git
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git
- en: In this book, we will use Git for our version control. We made this decision
    because Git is definitely faster and more lightweight (it takes up 30 times less
    disk space than SVN). Also, Git became the standard version control on web development
    version control and our goal is to create an application based on microservices
    using PHP, so Git is a great solution for the project.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用Git进行版本控制。我们做出这个决定是因为Git绝对更快，更轻量级（占用的磁盘空间比SVN少30倍）。此外，Git已成为Web开发版本控制的标准，我们的目标是基于PHP创建一个基于微服务的应用程序，因此Git是该项目的一个很好的解决方案。
- en: 'The advantages of Git are as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Git的优点如下：
- en: The branches are more lightweight than SVN
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支比SVN更轻量级
- en: Git is a lot of faster than SVN
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git比SVN快得多
- en: Git is a DVCS from the start, so the developer has total control of its local
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git从一开始就是一个分布式版本控制系统，因此开发人员对其本地拥有完全控制权
- en: Git provides better auditory in branching and merging
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git在分支和合并方面提供更好的审计
- en: 'In the subsequent chapters, we will use Git commands on our project, explaining
    each one and giving examples, but until then, let''s take a look at the basic
    ones:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的章节中，我们将在我们的项目中使用Git命令，解释每一个并给出示例，但在那之前，让我们先看一下基本的命令：
- en: '**How to create a new repository**: Create a new folder, open it, and execute
    Git in it to create a new Git repository.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何创建一个新存储库**：创建一个新文件夹，打开它，并在其中执行Git来创建一个新的Git存储库。'
- en: '**How to checkout an existing repository**: Create a local copy from the repository
    executing Git clone `/path/to/repository`. If you are using a remote server (hosting
    centralized servers will be explained in the following lines), execute Git clone
    `username@host:/path/to/repository` .'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何检出现有存储库**：通过执行Git clone `/path/to/repository`从存储库创建一个本地副本。如果您正在使用远程服务器（托管集中式服务器将在以下行中解释），则执行Git
    clone `username@host:/path/to/repository`。'
- en: 'To understand the Git workflow, it is necessary to know that there are three
    different trees:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Git的工作流程，有必要知道有三种不同的树：
- en: '![Git](graphics/B06142_02_06.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![Git](graphics/B06142_02_06.jpg)'
- en: '**WORKING DIRECTORY**: This contains the files of your project'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作目录**：包含您的项目文件'
- en: '**INDEX**: This works as the intermediate area; files will be here until they
    are committed'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**INDEX**：这起到中间区域的作用；文件将在此处，直到它们被提交'
- en: '**HEAD**: This points to the last commit done'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HEAD**：指向最后一次提交'
- en: 'Adding files to the INDEX and committing them are easy tasks. After working
    with files on your project and changing them, you have to add them to the index:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件添加到索引并提交它们是简单的任务。在项目中使用文件并对其进行更改后，您必须将它们添加到索引：
- en: '**How to add files to the INDEX**: Checking the files before adding them to
    the INDEX is recommended. You can do this by executing `git diff <file>`. It will
    show you the added and deleted lines, and some more interesting information about
    the file you modified. Once you are happy with the changes made, you can execute
    `git add <filename>` to add a specific file or add Git to all the files you have
    modified.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何将文件添加到索引**：建议在将文件添加到索引之前检查文件。您可以通过执行`git diff <file>`来做到这一点。它会显示您添加和删除的行，以及有关您修改的文件的一些更有趣的信息。一旦您对所做的更改满意，可以执行`git
    add <filename>`来添加特定文件，或者将Git添加到您修改过的所有文件中。'
- en: '**How to add files to the HEAD**: Once you have included all the necessary
    files in the INDEX, you have to commit them. You can do this by executing `git
    commit -m "Commit message"` . Now the files are included in the HEAD in your local
    copy, but they are still not in the remote repository.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何将文件添加到HEAD**：一旦您在索引中包含了所有必要的文件，您必须提交它们。您可以通过执行`git commit -m "提交消息"`来做到这一点。现在文件已经包含在您的本地副本的HEAD中，但它们仍未在远程存储库中。'
- en: '**How to send changes to the remote repository**:To send the changes included
    in your HEAD local copy to the remote repository, execute `git push origin <branch
    name>;` you can choose the branch where you want to include the changes, for example,
    master. If you did not clone an existing repository and you want to connect your
    local repository to a remote one, execute `git remote add origin <server>`.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何将更改发送到远程存储库**：要将包含在您的本地副本的HEAD中的更改发送到远程存储库，执行`git push origin <branch name>;`您可以选择要包含更改的分支，例如master。如果您没有克隆现有存储库，并且想要将本地存储库连接到远程存储库，执行`git
    remote add origin <server>`。'
- en: 'The branches are used to develop isolated functions and can be merged with
    the main branch in the future. The default branch when a new repository is created
    is called master. The workflow overview will be something like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 分支用于开发隔离的功能，并且可以在将来与主分支合并。创建新存储库时的默认分支称为master。工作流程概述将如下所示：
- en: '![Git](graphics/B06142_02_07.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![Git](graphics/B06142_02_07.jpg)'
- en: '**How to create a new branch**:Once you are in the branch from where you want
    to create a new one, execute `git checkout -b new_feature`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何创建新分支**：一旦您在要创建新分支的分支中，执行`git checkout -b new_feature`'
- en: '**How to change the branch**:You can navigate through the branches by executing
    `git checkout <branch name>`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何更改分支**：您可以通过执行`git checkout <branch name>`来浏览分支。'
- en: '**How to delete a branch**: You can delete a branch by executing `git branch
    -d new_feature`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何删除分支**：您可以通过执行`git branch -d new_feature`来删除分支'
- en: '**How to make your branch available to everyone**: A branch will not be available
    to the rest of developers until you upload your branch to the remote repository
    by executing `git push origin <branch>`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何使您的分支对所有人可用**：在将您的分支上传到远程存储库之前，分支将不会对其他开发人员可用，执行`git push origin <branch>`'
- en: If you want to update your local copy with the changes made on the remote repository,
    you can execute `git fetch` to check if there are any new updates and then `git
    pull` to get that update.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要将本地副本更新为远程存储库上的更改，您可以执行`git fetch`来检查是否有任何新的更新，然后执行`git pull`来获取该更新。
- en: To merge your active branch with a different branch, execute `git merge <branch>`
    and Git will attempt to fuse both branches but, sometimes, if two or more developers
    changed the same file, there could be conflicts and you will need to solve those
    conflicts manually before the merge and then put the modified files into the INDEX
    again.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要将您的活动分支与不同的分支合并，执行`git merge <branch>`，Git将尝试融合两个分支，但有时，如果两个或更多的开发人员更改了相同的文件，可能会出现冲突，您需要在合并之前手动解决这些冲突，然后再次将修改后的文件放入INDEX中。
- en: If you fail, maybe you want to trash your local changes and get the ones from
    the repository again. You can do this by executing `git checkout -- <filename>`
    . In case you want to trash all your local changes and commits, execute `git fetch
    origin and git reset --hard origin/master`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果失败，也许您想要丢弃本地更改并再次从存储库获取更改。您可以通过执行`git checkout -- <filename>`来做到这一点。如果您想要丢弃所有本地更改和提交，执行`git
    fetch origin`和`git reset --hard origin/master`。
- en: Hosting
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 托管
- en: When we are working in a team, maybe we want to have a common repository with
    a centralized server. Remember that Git is a DVCS and it is not necessary to use
    a place to have the code centralized, but in case you want to use it for different
    reasons, we will look at the two famous ones.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在团队中工作时，也许我们希望有一个带有集中式服务器的公共存储库。请记住，Git是一个分布式版本控制系统，不需要使用一个地方来集中存储代码，但是如果出于不同的原因想要使用它，我们将看看两个著名的地方。
- en: The hostings provide you with a better way to manage your repository using a
    web interface.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 托管为您提供了使用Web界面更好地管理存储库的方式。
- en: GitHub
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GitHub
- en: GitHub is the place to host the code chosen by a majority of developers. It
    is based on Git, and companies, such as Twitter and Facebook, use this service
    to put their open source projects. GitHub became the most famous source host in
    just a few years and currently, many companies ask for a candidate's GitHub repository
    before their technical interview.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub是大多数开发人员选择托管代码的地方。它基于Git，像Twitter和Facebook这样的公司使用这项服务来发布他们的开源项目。GitHub在短短几年内成为最著名的源代码托管地，并且目前，许多公司在技术面试之前要求候选人提供他们的GitHub存储库。
- en: This hosting is free for all developers; they can create unlimited projects
    with unlimited collaborators and only one condition; the project needs to be open
    source and public. If you want to have a private project, you will have to pay.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个托管对所有开发人员免费；他们可以创建无限的项目，有无限的合作者，唯一的条件是项目需要是开源和公共的。如果您想要一个私有项目，您将不得不付费。
- en: Having your project as public on GitHub is a good opportunity to show your project
    to the world and take advantage of the big GitHub community. It is possible to
    ask for help because there are many registered and active developers.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub上将您的项目公开是向世界展示您的项目并利用庞大的GitHub社区的好机会。可以寻求帮助，因为有许多注册和活跃的开发人员。
- en: You can visit the official website at [https://github.com/](https://github.com/).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问官方网站[https://github.com/](https://github.com/)。
- en: BitBucket
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BitBucket
- en: BitBucket is an alternative place to host your project. It uses Git, but you
    can use Mercurial too. The interface is pretty similar to GitHub. A great advantage
    of BitBucket is the company that makes it possible--Atlassian. It has many functionalities
    for developers included in their hosting, for example, the possibility of integrating
    other Atlassian tools or a small continuous delivery tool which allows you to
    build, test, and deploy your application.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: BitBucket是托管项目的另一个选择。它使用Git，但您也可以使用Mercurial。界面与GitHub非常相似。BitBucket的一个巨大优势是Atlassian公司使其成为可能。它在其托管中包含许多开发人员的功能，例如集成其他Atlassian工具的可能性或一个小型的持续交付工具，允许您构建，测试和部署应用程序。
- en: 'This one is free regardless of the project you want: public or private. The
    only limitation is that it only allows five collaborators for each project; if
    you need more people working on your project you will have to pay.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个地方是免费的，无论您想要的项目是公共的还是私有的。唯一的限制是每个项目只允许五个合作者；如果您需要更多人参与您的项目，您将不得不付费。
- en: '**Official website**: [https://bitbucket.org/](https://bitbucket.org/).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**官方网站**：[https://bitbucket.org/](https://bitbucket.org/)。'
- en: Version control strategies
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制策略
- en: When you are developing an application, it is important to keep your code nice
    and clean, but it is even more important when you work with other developers.
    In this section, we will give you a small introduction to the most known version
    control strategies you can use in your project.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开发应用程序时，保持代码整洁是很重要的，但当您与其他开发人员一起工作时更重要。在本节中，我们将为您介绍一些最常见的版本控制策略，您可以在项目中使用。
- en: Centralized work
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集中式工作
- en: This strategy is the most common for developers who were previously using SVN
    (old school) or similar version controls. Like Subversion, the project is hosted
    in a central repository with a unique point of entry. This strategy does not need
    more branches except master (trunk in SVN).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略对于以前使用 SVN（老派）或类似版本控制的开发人员来说是最常见的。与 Subversion 一样，项目托管在一个具有唯一入口点的中央存储库中。除了主分支（在
    SVN 中为主干）之外，这种策略不需要更多的分支。
- en: Developers clone the entire project on their local machines, work on the project,
    and then they commit the changes. When they want to publish the changes, they
    execute push.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员在本地机器上克隆整个项目，对项目进行工作，然后提交更改。当他们想要发布更改时，他们执行推送。
- en: Feature branch workflow
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能分支工作流
- en: This is the next step from centralized work. It works with a centralized repository
    also, but developers create a local feature branch in their copy and this one
    is published on the centralized repository too, so all the developers have the
    chance to participate in that feature. The branches will have descriptive names
    or number of issues.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从集中式工作的下一步。它也与中央存储库一起工作，但开发人员在其副本中创建一个本地功能分支，并且这个分支也会发布到中央存储库，因此所有开发人员都有机会参与该功能。分支将具有描述性名称或问题编号。
- en: In this strategy, the master never contains errors, so this is a great improvement
    for continuous integration. Also, having specific branches for each feature is
    a good encapsulation to not disturb the main code base.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种策略中，主分支永远不包含错误，因此这对于持续集成是一个很大的改进。此外，为每个功能设置特定的分支是一个很好的封装，以免干扰主代码库。
- en: Gitflow workflow
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gitflow 工作流
- en: Gitflow workflow does not add more new concepts than feature branch workflow.
    It just assigns different roles for each branch. Gitflow workflow works with a
    centralized repository too, and developers create branches on it, such as feature
    branch workflow. However, the branches have a specific function, for example,
    development, release, or feature. So, the feature branches will be merged with
    a specific release and then with master. This way, it is possible to have different
    releases for the same project.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Gitflow 工作流不会添加比功能分支工作流更多的新概念。它只为每个分支分配不同的角色。Gitflow 工作流也与中央存储库一起工作，开发人员在其中创建分支，就像功能分支工作流一样。然而，这些分支有特定的功能，例如开发、发布或功能。因此，功能分支将与特定发布合并，然后与主分支合并。这样，同一个项目可以有不同的发布版本。
- en: This strategy is used for large projects or projects that need releases.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略适用于大型项目或需要发布的项目。
- en: Forking workflow
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分支工作流
- en: 'The last strategy is quite different to others that we have looked at in this
    chapter. Instead of cloning a copy from the centralized server and working on
    it, this one gives a fork of that to every developer. This means that every developer
    has two copies of the project: a *private* one and the *server-side*.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种策略与本章中我们看过的其他策略非常不同。与从集中服务器克隆副本并在其上工作不同，这种策略为每个开发人员提供了一个分支。这意味着每个开发人员都有项目的两个副本：一个*私有*副本和一个*服务器端*副本。
- en: Once the developer makes the changes they want, they are sent to the project
    maintainer to be reviewed and checked so that they do not break the project and
    then they are merged with the main repository.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开发人员做出他们想要的更改，它们将被发送给项目维护者进行审查和检查，以确保它们不会破坏项目，然后它们将被合并到主存储库中。
- en: This strategy is used in open source projects, so the developers cannot break
    the current project.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略适用于开源项目，因此开发人员不能破坏当前项目。
- en: Semantic versioning
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语义化版本控制
- en: It is really important to have a versioning system in our microservice or API.
    This allows the consumers and yourself to have a coherent system of versioning
    so that everyone can know the importance of a release or feature.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的微服务或 API 中拥有一个版本控制系统非常重要。这使得消费者和您自己都能够拥有一个一致的版本控制系统，以便每个人都能知道发布或功能的重要性。
- en: 'Set the version number as `MAJOR.MINOR.PATCH`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将版本号设置为 `MAJOR.MINOR.PATCH`：
- en: '`MAJOR` will be incremented when incompatible API changes are made, so developers
    need to trash the current API version and use the new one.'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MAJOR` 在不兼容的 API 更改时会增加，因此开发人员需要废弃当前的 API 版本并使用新版本。'
- en: '`MINOR` will be incremented when a new feature is added and it is compatible
    with the current code. The developer, therefore, does not need to change the entire
    API just to update the current one.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MINOR` 在添加新功能并且与当前代码兼容时会增加。因此，开发人员不需要改变整个 API 来更新当前版本。'
- en: '`PATCH` will be incremented when a new bug fix for the current version is done.'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PATCH` 在对当前版本进行新的错误修复时会增加。'
- en: This is a summary of semantic versioning, but you can find more information
    at [http://semver.org/](http://semver.org/).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是语义化版本控制的摘要，但您可以在 [http://semver.org/](http://semver.org/) 找到更多信息。
- en: Setting up a development environment for microservices
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为微服务设置开发环境
- en: One of the greatest benefits of using Docker and its container ecosystem is
    that you don't need to install anything else on your machine. For example, if
    you need a MySQL database, you don't need to install anything on your local dev;
    it is easier to spin a container with the version you want and start using it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 及其容器生态系统的最大好处之一是您不需要在计算机上安装任何其他东西。例如，如果您需要一个 MySQL 数据库，您不需要在本地开发环境上安装任何东西；只需轻松创建一个包含所需版本的容器并开始使用它。
- en: This way of developing is more flexible, therefore we will be working with Docker
    containers throughout the whole book. In this section, we will learn how to build
    a basic Docker environment; it will be our foundation and we will be improving
    and adapting this base to each of our microservices in the subsequent chapters.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这种开发方式更加灵活，因此我们将在整本书中都使用 Docker 容器。在本节中，我们将学习如何构建一个基本的 Docker 环境；这将是我们的基础，并且我们将在随后的章节中改进和调整这个基础以适应我们的每个微服务。
- en: 'To simplify the folder structure of our project, we will have some root folders
    on our development machine:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们项目的文件夹结构，我们将在开发机器上有一些根文件夹：
- en: '`Docker`: This folder will contain all the Docker environment'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Docker`：此文件夹将包含所有 Docker 环境。'
- en: '`Source`: This folder will have the source of each of our microservices![Setting
    up a development environment for microservices](graphics/B06142_02_08.jpg)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Source`：这个文件夹将包含我们每个微服务的源代码！[为微服务设置开发环境](graphics/B06142_02_08.jpg)'
- en: Note that this structure is flexible and can be changed and adapted to your
    specific requirements without any problems.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个结构是灵活的，可以根据您的具体要求进行更改和调整，而不会出现任何问题。
- en: All the required files are available on our GitHub repository, at [https://github.com/php-microservices/docker](https://github.com/php-microservices/docker),
    on the master branch with the `chapter-02` tag.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 所有所需的文件都可以在我们的GitHub存储库上找到，位于`chapter-02`标签的主分支上，网址为[https://github.com/php-microservices/docker](https://github.com/php-microservices/docker)。
- en: 'Let''s dig deeper into the Docker setup. Open your docker folder and create
    a file called `docker-compose.yml` with the following content:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解Docker设置。打开您的docker文件夹，并创建一个名为`docker-compose.yml`的文件，内容如下：
- en: '[PRE30]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These two lines indicate that we are using the latest syntax for Docker compose
    and they define a list of services that we will be spinning every time we do a
    `docker-compose up`. All our services will be added after the `services` declaration.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行表示我们正在使用Docker compose的最新语法，并且它们定义了我们每次执行`docker-compose up`时将会启动的服务列表。我们所有的服务都将在`services`声明之后添加。
- en: Autodiscovery service
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动发现服务
- en: Autodiscovery is a mechanism in which we don't specify the endpoints of each
    of our microservices. Each one of our services use a shared registry in which
    they say that they are available. When a microservice needs to know the location
    of another microservice, it can consult our autodiscovery registry to know the
    required endpoint.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 自动发现是一种机制，我们不指定每个微服务的端点。我们的每个服务都使用一个共享注册表，它们在其中声明自己是可用的。当一个微服务需要知道另一个微服务的位置时，它可以查询我们的自动发现注册表以了解所需的端点。
- en: For our application, we will be using an autodiscovery mechanism to ensure that
    our microservices can be scaled easily and if a node is not healthy, we stop sending
    requests to it. Our choice for this purpose is to use Consul (by HashiCorp), a
    very small application that we can add to our project. The main role for our Consul
    container is to keep everything in order, keeping a list of the available and
    healthy services.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将使用自动发现机制来确保我们的微服务可以轻松扩展，如果一个节点不健康，我们将停止向其发送请求。我们选择使用Consul（由HashiCorp提供），这是一个非常小的应用程序，我们可以将其添加到我们的项目中。我们的Consul容器的主要作用是保持一切井然有序，保持可用和健康服务的列表。
- en: 'Let''s start the project by opening your `docker-compose.yml` file with your
    favorite IDE/editor and adding the next piece of code just after the `services:`
    line:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过打开您喜欢的IDE/editor的`docker-compose.yml`文件并在`services:`行之后添加下一段代码来开始项目：
- en: '[PRE31]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In a Docker compose file, the syntax is very easy to understand and always follows
    the same flow. The first line defines a container type (it is like a class name
    for devs); in our case it is `autodiscovery`, and inside this container type we
    can specify several options to adapt the container to our requirements.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker compose文件中，语法非常容易理解，并且始终遵循相同的流程。第一行定义了一个容器类型（对于开发人员来说，它就像一个类名）；在我们的情况下，它是`autodiscovery`，在这个容器类型内部，我们可以指定几个选项，以适应我们的要求。
- en: 'With `build: ./autodiscovery/`, we are telling Docker where it can find a Dockerfile
    that describes what we want in our container in detail.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '通过`build: ./autodiscovery/`，我们告诉Docker在哪里可以找到一个描述我们容器详细信息的Dockerfile。'
- en: 'The `mem_limit: 128m` sentence will limit the memory consumption of any container
    of the `autodiscovery` type to not more than 128 Mb. Note that this instruction
    is optional.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`mem_limit: 128m`这句话将限制`autodiscovery`类型的任何容器的内存消耗不超过128 Mb。请注意，这个指令是可选的。'
- en: Each container needs different ports open and, by default, when you spin a container,
    none of them are open. For this reason, you need to specify which ports you want
    open for each container. For example, a container with a web server will need
    the `port 80` open but for a container that runs MySQL, the required port may
    be `3306`. In our case, we are opening the ports `53`, `8300`, `8301`, `8302`,
    `8400`, and `8500` for each one of our `autodiscovery` containers.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器都需要打开不同的端口，默认情况下，当您启动一个容器时，这些端口都是关闭的。因此，您需要指定每个容器要打开哪些端口。例如，一个带有Web服务器的容器将需要打开`端口80`，但对于运行MySQL的容器，所需的端口可能是`3306`。在我们的情况下，我们为我们的每个`autodiscovery`容器打开了端口`53`、`8300`、`8301`、`8302`、`8400`和`8500`。
- en: If you try to reach the container on one of the opened ports, it will not work.
    The container ecosystem resides in a separate network and you can only access
    it if you create a bridge between your environment and the Docker network. Our
    `autodiscovery` container runs Consul and it has a nice web UI on port `8500`.
    We want to be able to use this UI; so, when we use `ports`, we are mapping our
    local `8500` port to the container `8500` port.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试在打开的端口之一上访问容器，它将无法工作。容器生态系统位于一个单独的网络中，只有在您的环境和Docker网络之间创建一个桥接时，您才能访问它。我们的`autodiscovery`容器运行Consul，并且在端口`8500`上有一个很好的Web
    UI。我们希望能够使用这个UI；因此，当我们使用`ports`时，我们将我们本地的`8500`端口映射到容器的`8500`端口。
- en: 'Now, it''s time to create a new folder called `autodiscovery` in the same path
    of your `docker-compose.yml file`. Inside this new folder, place a file called
    `Dockerfile` with the following line:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在与您的`docker-compose.yml`文件相同的路径下创建一个名为`autodiscovery`的新文件夹了。在这个新文件夹中，放置一个名为`Dockerfile`的文件，内容如下：
- en: '[PRE32]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This small sentence inside the `Dockerfile` indicates that we are using a Docker
    `consul` image with tag `v0.7.0`. This image will be fetched from the official
    Docker hub, a repository for container images.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`中的这个小句子表明我们正在使用一个带有标签`v0.7.0`的Docker `consul`镜像。这个镜像将从官方Docker
    hub获取，这是一个容器镜像的存储库。'
- en: At this point, doing a `$ docker-compose up` will spin up a Consul machine,
    give it a try. Since we didn't specify the `-d` option, the Docker engine will
    output all the logs to your terminal. You can stop your container with a simple
    *CTRL*+*C*. When you add the `-d` option, the Docker compose runs as a daemon
    and returns the prompt; you can do a `$ docker-compose stop` to stop the containers.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，执行`$ docker-compose up`将启动一个Consul机器，请试一试。由于我们没有指定`-d`选项，Docker引擎将把所有日志输出到您的终端。您可以通过简单的*CTRL*+*C*来停止您的容器。当您添加`-d`选项时，Docker
    compose将作为守护进程运行并返回提示符；您可以执行`$ docker-compose stop`来停止容器。
- en: Microservice base core - NGINX and PHP-FPM
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务基础核心 - NGINX和PHP-FPM
- en: PHP-FPM is an alternative to the old way of executing PHP in our web server.
    The main benefit of using PHP-FPM is its small memory footprint and the high performance
    under hight loads. The best web server you can find nowadays to run your PHP-FPM
    is NGINX, a very light web server and reverse proxy used in the most important
    projects.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: PHP-FPM是在我们的Web服务器中执行PHP的一种替代方法。使用PHP-FPM的主要好处是其小的内存占用和在高负载下的高性能。您可以找到的最好的Web服务器来运行您的PHP-FPM是NGINX，这是一个非常轻量级的Web服务器和反向代理，用于最重要的项目。
- en: Since our application will be using an autodiscovery pattern, we need an easy
    way of dealing with the service registering, deregistering, and health check.
    One of the simplest and fastest applications you can use is ContainerPilot, a
    small micro-orchestration application created by Joyent that works with your favorite
    container scheduler, in our case Docker compose. This small app is being executed
    as PID 1 and forks the application we want to run inside the container.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序将使用自动发现模式，我们需要一种简单的方法来处理服务的注册、注销和健康检查。您可以使用的最简单和最快的应用程序之一是ContainerPilot，这是由Joyent创建的一个小型微服务编排应用程序，可以与您喜欢的容器调度程序一起使用，在我们的案例中是Docker
    compose。这个小应用程序作为PID 1执行，并在容器内部运行我们想要运行的应用程序。
- en: We will be working with ContainerPilot because it relieves the developer of
    dealing with the autodiscovery, so we need to have the latest version on each
    container we will be using.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用ContainerPilot，因为它可以减轻开发人员处理自动发现的负担，所以我们需要在我们将要使用的每个容器上都安装最新版本。
- en: 'Let''s start defining our base `php-fpm` container. Open the `docker-compose.yml`
    and add a new service for the `php-fpm`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始定义我们的基础`php-fpm`容器。打开`docker-compose.yml`，为`php-fpm`添加一个新的服务：
- en: '[PRE33]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, we are defining a new service and one interesting attribute
    is links. This attribute defines which other containers our service can see or
    connect. In our example, we want to link this type of container to any `autodiscovery` container.
    Without this explicit definition, our `fpm` container won't see the `autodiscovery`
    service.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们正在定义一个新的服务，一个有趣的属性是链接。这个属性定义了我们的服务可以看到或连接哪些其他容器。在我们的例子中，我们希望将这种类型的容器链接到任何`autodiscovery`容器。如果没有这个明确的定义，我们的`fpm`容器将看不到`autodiscovery`服务。
- en: 'Now, create the `microservices/base/php-fpm/Dockerfile` file on your IDE/editor
    with the following content:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您的IDE/编辑器中创建`microservices/base/php-fpm/Dockerfile`文件，内容如下：
- en: '[PRE34]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: What we have done on this file is tell Docker how it needs to create our `php-fpm`
    container. The first line declares the official version we want to use as a foundation
    for our container, in this case php7 fpm. Once the image is downloaded, the first
    `RUN` line will add all the extra `PHP` packages we will be using.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们告诉Docker如何创建我们的`php-fpm`容器。第一行声明了我们想要用作容器基础的官方版本，这里是php7 fpm。一旦镜像下载完成，第一个`RUN`行将添加我们将使用的所有额外的`PHP`包。
- en: The two `RUN` sentences will add bespoke PHP configurations; feel free to adapt
    these lines to your requirements.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个`RUN`语句将添加定制的PHP配置；请随时根据您的需求调整这些行。
- en: Once all the PHP tasks are done, it is time to install a small application on
    the container that will help us to deal with templates--`consul-template`. This
    application is used to build configuration templates on the fly using the information
    we have stored on our Consul service.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有的PHP任务完成，就是时候在容器上安装一个小应用程序来帮助我们处理模板--`consul-template`。这个应用程序用于使用我们在Consul服务上存储的信息动态构建配置模板。
- en: As we said before, we are using ContainerPilot. So, after the `consul-template`
    installation, we are telling Docker how to install this application.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，我们正在使用ContainerPilot。因此，在`consul-template`安装之后，我们正在告诉Docker如何安装这个应用程序。
- en: At this point, Docker finishes installing all the required packages and copies
    some configuration and shell scripts needed by ContainerPilot
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Docker完成了安装所有所需的软件包，并复制了一些ContainerPilot所需的配置和shell脚本。
- en: The last line starts ContainerPilot as PID 1 and forks `php-fpm`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行将ContainerPilot作为PID 1启动，并分叉`php-fpm`。
- en: 'Now, let''s explain the configuration file required by ContainerPilot. Open
    your IDE/editor and create the `microservices/base/php-fpm/config/containerpilot.json`
    file with the following content:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们解释ContainerPilot需要的配置文件。打开您的IDE/编辑器，并创建`microservices/base/php-fpm/config/containerpilot.json`文件，内容如下：
- en: '[PRE35]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This JSON configuration file is very easy to understand. First, it defines where
    we can find our Consul container and which command we want to run on the ContainerPilot
    preStart event. In `services`, you can define all the services you want to declare
    that the current container is running. On the `backends`, you can define all the
    services you are listening for changes. In our case, we are listening for changes
    to services called `microservice_base_nginx` (the `BACKEND` variable is defined
    on the `docker-compose.yml`). If something changes on Consul on these services,
    we will execute the `onChange` command in the container.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JSON配置文件非常容易理解。首先，它定义了我们可以在哪里找到我们的Consul容器，以及我们希望在ContainerPilot的preStart事件上运行哪个命令。在`services`中，您可以定义所有当前容器正在运行的服务。在`backends`中，您可以定义所有您正在监听更改的服务。在我们的案例中，我们正在监听名为`microservice_base_nginx`的服务的更改（`BACKEND`变量在`docker-compose.yml`中定义）。如果Consul上这些服务发生了变化，我们将在容器中执行`onChange`命令。
- en: For a more information about ContainerPilot, you can visit the official page,
    that is, [https://www.joyent.com/containerpilot](https://www.joyent.com/containerpilot).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 有关ContainerPilot的更多信息，您可以访问官方页面，即[https://www.joyent.com/containerpilot](https://www.joyent.com/containerpilot)。
- en: 'It''s time to create the `microservices/base/php-fpm/scripts/reload.sh` file
    with the following content:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建`microservices/base/php-fpm/scripts/reload.sh`文件，内容如下：
- en: '[PRE36]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we created a dummy script, but it is up to you to adapt it to your requirements.
    For example, it can be changed to `run execute consul-template` and rebuild the
    NGINX configuration once ContainerPilot fires the script. We will be explaining
    a more complex script later.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个虚拟脚本，但是你可以根据自己的需求进行调整。例如，它可以更改为`run execute consul-template`并在ContainerPilot触发脚本后重新构建NGINX配置。我们将在以后解释更复杂的脚本。
- en: We have our base `php-fpm` container ready, but our basic environment can't
    be complete without a web server. We will be using NGINX, a very light and powerful
    reverse proxy and web server.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本`php-fpm`容器已经准备就绪，但是我们的基本环境如果没有web服务器是不完整的。我们将使用NGINX，一个非常轻巧和强大的反向代理和web服务器。
- en: The way we will build our NGINX server is very similar to the `php-fpm`, so
    we will only explain the differences.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建我们的NGINX服务器的方式与`php-fpm`非常相似，因此我们只会解释其中的区别。
- en: Tip
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that all the files are available in our GitHub repository.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有文件都可以在我们的GitHub存储库中找到。
- en: 'We will add a new service definition for NGINX to the `docker-compose.yml`
    file and link it to our `autodiscovery` service and also to our `php-fpm`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`docker-compose.yml`文件中为NGINX添加一个新的服务定义，并将其链接到我们的`autodiscovery`服务以及我们的`php-fpm`：
- en: '[PRE37]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In our `microservices/base/nginx/config/containerpilot.json`, we now have a
    new option `telemetry`. This config setting allows us to specify a remote telemetry
    service used to collect stats from our service. Having this kind of service included
    in our environment allows us to see how our containers are performing:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`microservices/base/nginx/config/containerpilot.json`中，现在有一个新选项`telemetry`。此配置设置允许我们指定用于收集我们服务的统计信息的远程遥测服务。包含这种类型的服务在我们的环境中可以让我们看到我们的容器的性能如何：
- en: '[PRE38]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see, we use a bespoke bash script to obtain the container stats,
    and the content of our `microservices/base/nginx/scripts/sensor.sh` script is
    as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们使用一个定制的bash脚本来获取容器统计信息，我们的`microservices/base/nginx/scripts/sensor.sh`脚本的内容如下：
- en: '[PRE39]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This bash script gets some `nginx` stats that we will be sending to our `telemetry`
    server with ContainerPilot.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这个bash脚本获取了一些我们将使用ContainerPilot发送到我们的`telemetry`服务器的`nginx`统计信息。
- en: 'Our `microservices/base/nginx/scripts/reload.sh` is a little more complex than
    the one we created before for `php-fpm`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`microservices/base/nginx/scripts/reload.sh`比我们之前为`php-fpm`创建的要复杂一些：
- en: '[PRE40]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, we use `consul-template` to rebuild our NGINX config on the
    startup or when ContainerPilot detects a change in the list of backend services
    we will be monitoring. This behavior allows us to stop sending requests to unhealthy
    nodes.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们使用`consul-template`在启动时或当ContainerPilot检测到我们将要监视的后端服务列表中的更改时重建我们的NGINX配置。这种行为允许我们停止向不健康的节点发送请求。
- en: At this point, we have our base environment ready and we are ready to test it
    with a simple `$ docker-compose up`. We will be using all these pieces to create
    bigger and more complex services. In the upcoming chapters, we will be adding
    the telemetry service or a data storage among others.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的基本环境已经准备就绪，我们准备用一个简单的`$ docker-compose up`来测试它。我们将使用所有这些部件来创建更大更复杂的服务。在接下来的章节中，我们将添加telemetry服务或数据存储等。
- en: Frameworks for microservices
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务框架
- en: A framework is a skeleton that we can use for sofware development. Using a framework
    will help us use standard and robust patterns in our application, making it more
    stable and well known by other developers. PHP has many different frameworks you
    can use in your daily work. We will see some standards used on the most common
    frameworks so that you can pick the best for your project.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 框架是我们可以用于软件开发的骨架。使用框架将帮助我们在应用程序中使用标准和稳健的模式，使其更稳定并为其他开发人员所熟知。PHP有许多不同的框架可以在您的日常工作中使用。我们将看到一些最常见框架上使用的标准，以便您可以为您的项目选择最佳的。
- en: PHP-FIG
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP-FIG
- en: For years, the PHP community has been working on their own projects and following
    their own rules. Thousands of different projects with different developers have
    been released since the first years of PHP, and none followed any common standards.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，PHP社区一直在开发自己的项目并遵循自己的规则。自PHP最初的几年以来，已经发布了成千上万个不同的项目，由不同的开发人员开发，并且没有遵循任何共同的标准。
- en: This was a problem for PHP developers, firstly because there was no way of knowing
    if the steps they were following to build applications were the correct ones.
    Only their own experience and the Internet could help the developer guess if their
    code was written properly and if it would be readable by other developers in the
    future.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这对PHP开发人员来说是一个问题，首先是因为他们无法知道构建应用程序所遵循的步骤是否正确。只有他们自己的经验和互联网可以帮助开发人员猜测他们的代码是否正确编写，并且将来是否可读。
- en: Secondly, the developers felt that they were trying to reinvent the wheel. Developers
    were making the same existing applications for their projects because there was
    no standard to fit third-party application into their projects.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，开发人员觉得他们在试图重复造轮子。由于没有标准适应第三方应用程序到他们的项目中，开发人员为他们的项目制作了相同的现有应用程序。
- en: In 2009, the **PHP Framework Interoperability Group** (**PHP-FIG**) was born
    with the main goal of creating a unique standard for development in PHP. PHP-FIG
    is a big community of members that works on the **PHP Standards Recommendation **(**PSR**),
    discussing what the best way to use the PHP language is.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 2009年，**PHP框架互操作性组**（**PHP-FIG**）诞生，其主要目标是为PHP开发创建一个统一的标准。PHP-FIG是一个由成员组成的大社区，致力于**PHP标准推荐**（**PSR**），讨论如何最好地使用PHP语言。
- en: PHP-FIG is supported by big projects such as Drupal, Magento, Joomla!, Phalcon,
    CakePHP, Yii, Zend, and Symfony and that is the reason the PSRs they propose are
    implemented by the PHP frameworks.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: PHP-FIG得到大型项目的支持，如Drupal，Magento，Joomla！，Phalcon，CakePHP，Yii，Zend和Symfony，这就是为什么它们提出的PSR被PHP框架实现的原因。
- en: Some standards, such as PSR-1 and PSR-2, are about the use of code and its style
    (using tabs or spaces, opening tags of PHP, using camelCasing or filenames) and
    others are about the autoloading (PSR-0 and then PSR-4). Since PHP 5.3, namespaces
    were included and it was the most important thing to implement `autoloading`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 一些标准，如PSR-1和PSR-2，涉及代码的使用和样式（使用制表符或空格，PHP的开放标签，使用驼峰命名法或文件名），其他标准涉及自动加载（PSR-0然后PSR-4）。自PHP
    5.3以来，命名空间已经包含，并且实现`自动加载`是最重要的事情。
- en: The `autoloading` was possibly one of the most important improvements to PHP.
    Before PHP-FIG, frameworks had their own methods to implement the autoloading,
    their own way to format them, initialize them, and name them, and each one was
    different, so it was a disaster (Java already solved this problem using its beans
    system).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`自动加载`可能是PHP中最重要的改进之一。在PHP-FIG之前，框架有它们自己的方法来实现自动加载，它们自己的格式化方式，初始化方式和命名方式，每个都不同，所以这是一场灾难（Java已经通过其bean系统解决了这个问题）。'
- en: Finally, Composer implemented autoloading, which was written by PHP-FIG. So,
    developers don't need to worry about `require_once()`, `include_once()`, `require()`,
    or `include()` anymore.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Composer实现了自动加载，这是由PHP-FIG编写的。因此，开发人员不再需要担心`require_once()`，`include_once()`，`require()`或`include()`。
- en: You can find more information about PHP-FIG at [http://www.php-fig.org/](http://www.php-fig.org/).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://www.php-fig.org/](http://www.php-fig.org/)找到有关PHP-FIG的更多信息。
- en: PSR-7
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PSR-7
- en: In this book, we will use the **PHP Standard Recommendation 7** (**PSR-7**).
    It is about the HTTP messages interfaces. This is the essence of web development;
    it is the way to communicate with a server. An HTTP client or web browser sends
    an HTTP request message to a server and it replies with an HTTP response message.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用**PHP标准推荐7**（**PSR-7**）。它涉及HTTP消息接口。这是Web开发的本质；这是与服务器通信的方式。HTTP客户端或Web浏览器向服务器发送HTTP请求消息，服务器会回复一个HTTP响应消息。
- en: These kinds of messages are hidden from normal users, but developers need to
    know the structure to manipulate them. The PSR-7 talks about the recommended ways
    to manipulate them, doing it simply and clearly.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的消息对普通用户是隐藏的，但开发人员需要了解结构以操纵它们。PSR-7讨论了推荐的操纵方式，简单明了地进行操作。
- en: We will use HTTP messages to communicate with microservices, so it is necessary
    to know how they work and what their structure is.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用HTTP消息与微服务进行通信，因此有必要了解它们的工作原理和结构。
- en: 'An HTTP request has the following structure:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求具有以下结构：
- en: '[PRE41]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the request, there are all the necessary things to allow the server to understand
    the request message and to be able to reply with a response. In the first line,
    we can see the method used for the request (`GET`, `POST`, `PUT`, `DELETE`), the
    request target, and the HTTP protocol version, and then one or more HTTP headers,
    an empty line, and the body.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求中，有所有必要的东西让服务器理解请求消息并能够回复。在第一行中，我们可以看到用于请求的方法（`GET`，`POST`，`PUT`，`DELETE`），请求目标和HTTP协议版本，然后是一个或多个HTTP头部，一个空行和主体。
- en: 'And the HTTP response will look like this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应将如下所示：
- en: '[PRE42]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is the response body. The response has the HTTP protocol version, such
    as the request and the HTTP status code, followed by a text to describe the code.
    You will find all the available status codes in the next chapters. The rest of
    the lines are like the request: one or more HTTP headers, an empty line, and then
    the body.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这是响应主体。响应包含HTTP协议版本，例如请求和HTTP状态代码，后面跟着一个描述代码的文本。您将在接下来的章节中找到所有可用的状态代码。其余的行与请求类似：一个或多个HTTP头部，一个空行，然后是主体。
- en: Once we know the structure of HTTP request messages and HTTP response messages,
    we will understand what the recommendations of PHP-FIG on PSR-7 are.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了HTTP请求消息和HTTP响应消息的结构，我们将了解PHP-FIG关于PSR-7的建议。
- en: Messages
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息
- en: Any message is an HTTP request message (RequestInterface) or an HTTP response
    message (ResponseInterface). They extend MessageInterface and may be implemented
    directly. Implementors should implement RequestInterface and ResponseInterface.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 任何消息都是HTTP请求消息（RequestInterface）或HTTP响应消息（ResponseInterface）。它们扩展了MessageInterface并且可以直接实现。实现者应该实现RequestInterface和ResponseInterface。
- en: Headers
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 头部
- en: 'Case-insensitive for header field names:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 标题字段名称不区分大小写：
- en: '[PRE43]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Headers with multiple values:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 具有多个值的标题：
- en: '[PRE44]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Host header
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主机头
- en: Usually, the host header is the same as the host component of the URI and the
    host used when establishing the TCP connection, but it can be modified.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，主机头与URI的主机组件相同，并且在建立TCP连接时使用的主机相同，但可以进行修改。
- en: '`RequestInterface::withUri()` will replace the request host header.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestInterface::withUri()`将替换请求主机头。'
- en: You can keep the original state of the host by passing true for the second argument;
    it will keep the host header unless the message does not have a host header.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递第二个参数为true，您可以保持主机的原始状态；它将保留主机头，除非消息没有主机头。
- en: Streams
  id: totrans-356
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 流
- en: StreamInterface is used to hide the implementation details when a stream of
    data is read or written.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取或写入数据流时，StreamInterface用于隐藏实现细节。
- en: 'Streams expose their capabilities using the following three methods:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 流使用以下三种方法公开其功能：
- en: '[PRE45]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Request targets and URIs
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 请求目标和URI
- en: 'A request target is in the second segment of the request line:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 请求目标位于请求行的第二部分：
- en: '[PRE46]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `getRequestTarget()` method will use the URI object to make the origin-form
    (the most common request-target).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRequestTarget()`方法将使用URI对象来生成原始形式（最常见的请求目标）。'
- en: 'Using `withRequestTarget()`, the user can use the other three options. For
    example, an asterisk-form, as illustrated:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`withRequestTarget()`，用户可以使用其他三个选项。例如，星号形式，如下所示：
- en: '[PRE47]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The HTTP request will be as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求将如下所示：
- en: '[PRE48]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Server-side requests
  id: totrans-368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 服务器端请求
- en: 'RequestInterface gives the general representation for an HTTP request, but
    the server-side requests needs to be processed into an account **Common Gateway
    Interface** (**CGI**). PHP provides simplification via its superglobals:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: RequestInterface为HTTP请求提供了一般表示，但服务器端请求需要被处理成**通用网关接口**（**CGI**）。PHP通过其超全局变量提供了简化：
- en: '[PRE49]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ServerRequestInterface provides an abstraction around these superglobals to
    reduce coupling to the superglobals by consumers.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ServerRequestInterface提供了对这些超全局变量的抽象，以减少对超全局变量的消费者的耦合。
- en: Uploaded files
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 上传的文件
- en: 'The `$_FILES` superglobal has some well-known problems when working with arrays
    or file inputs. For example, with the input name `files`, submitting files[`0`]
    and files[`1`], PHP will be represented like this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`$_FILES`超全局变量在处理数组或文件输入时存在一些众所周知的问题。例如，使用输入名称`files`，提交files[`0`]和files[`1`]，PHP将表示如下：'
- en: '[PRE50]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The expected representation is as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的表示如下：
- en: '[PRE51]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: So, the customers need to know these kinds of problems and write code to fix
    the given data.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，客户需要了解这些问题，并编写代码来修复给定的数据。
- en: '`getUploadedFiles()` provides the normalized structure for consumers.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`getUploadedFiles()`为消费者提供了规范化的结构。'
- en: You can find more detailed information and the interfaces and classes that we
    discussed at [http://www.php-fig.org/psr/psr-7/](http://www.php-fig.org/psr/psr-7/).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://www.php-fig.org/psr/psr-7/](http://www.php-fig.org/psr/psr-7/)找到更详细的信息和我们讨论的接口和类。
- en: Middleware
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件
- en: A middleware is a *mechanism to filter the HTTP requests on an application*;
    it allows you to add additional layers to the business logic. It executes before
    and after the piece of code we want to reach to handle input and output communication.
    The middleware uses the recommendations on PSR-7 to modify the HTTP requests.
    This is the reason PSR-7 and middleware are united.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是一种*过滤应用程序的HTTP请求的机制*；它允许您为业务逻辑添加额外的层。它在我们想要到达的代码片段之前和之后执行，以处理输入和输出通信。中间件使用PSR-7的建议来修改HTTP请求。这就是为什么PSR-7和中间件是相结合的原因。
- en: 'The most common example of middleware is on the authentication. In an application
    where it is necessary to log in to get user privileges, the middleware will decide
    if the user can see specific content of the application:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件的最常见示例是在身份验证中。在需要登录以获取用户权限的应用程序中，中间件将决定用户是否可以查看应用程序的特定内容：
- en: '![Middleware](graphics/B06142_02_09.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![中间件](graphics/B06142_02_09.jpg)'
- en: In the preceding image, we can see a typical PSR-7 HTTP **REQUEST** and **RESPONSE** with
    two **MIDDLEWARE**. Usually, you will see the middleware implementations as lambda
    (λ).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图片中，我们可以看到一个典型的PSR-7 HTTP **请求**和**响应**，带有两个**中间件**。通常，您会将中间件实现为lambda（λ）。
- en: 'Now, we will take a look at some examples of typical implementations of middlewares:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看一些典型中间件实现的示例：
- en: '[PRE52]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `request` and `response` are the objects, and the last param `$next` is
    the name of the next middleware to call. If the middleware is the last one, you
    can leave it empty. In the code, we can see three different parts: the first one
    is to modify and do things before the next middleware, in the second one the middleware
    calls the next middleware (if it exists), and the third one is to modify and do
    things after the previous middleware.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`request`和`response`是对象，最后一个参数`$next`是要调用的下一个中间件的名称。如果中间件是最后一个，可以将其留空。在代码中，我们可以看到三个不同的部分：第一部分是在下一个中间件之前修改和执行操作，第二部分是中间件调用下一个中间件（如果存在），第三部分是在上一个中间件之后修改和执行操作。'
- en: It is a good practice to see the code before and after the `$next`(`$request`,
    `$response`) form as onion layers around the middleware, but it is necessary to
    be on the ball regarding the order of execution of the middlewares.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到`$next`（`$request`，`$response`）形式之前和之后的代码是一种良好的实践，就像中间件周围的洋葱层一样，但是必须对中间件的执行顺序保持警惕。
- en: Another good practice is looking at the real application (the part of code the
    middlewares reach, usually a controller function) as a middleware too, because
    it receives a request and a response and it has to return a response, but this
    time without the next param because it is the last one; however, the execution
    continues after this. This is the reason we have to look at the end code in the
    same way as the last middleware.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个良好的实践是将真实应用程序（通常是中间件到达的代码部分，通常是控制器函数）也视为中间件，因为它接收请求和响应，并且必须返回响应，但这次没有下一个参数，因为它是最后一个；然而，执行在此之后继续。这就是我们必须以与最后一个中间件相同的方式查看最终代码的原因。
- en: 'We will see a complete example to understand how you can use it on your application
    based on microservices. As we saw in the preceding image, there were two middlewares,
    we will call them first and second, and then the end function will be called endfunction:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一个完整的示例，以了解如何在基于微服务的应用程序中使用它。正如我们在前面的图片中看到的，有两个中间件，我们将称它们为第一个和第二个，然后结束函数将被调用endfunction：
- en: '[PRE53]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Every framework has its own middleware handler, but each one works very similarly.
    The middleware handler is used to manage the stack, so you can add more middleware
    on it and they will be called sequentially. This is a generic middleware handler:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 每个框架都有自己的中间件处理程序，但每个处理程序的工作方式都非常相似。中间件处理程序用于管理堆栈，因此您可以在其上添加更多中间件，并且它们将按顺序调用。这是一个通用的中间件处理程序：
- en: '[PRE54]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The execution track will be something like this:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 执行轨迹将是这样的：
- en: The user requests a specific path to the server. For example, `/`.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户向服务器请求特定路径。例如，`/`。
- en: The `first` middleware is executed adding `word` equals to `hello`.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`first`中间件，添加`word`等于`hello`。
- en: The `first` middleware sends the execution to `second`.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`first`中间件将执行发送到`second`。'
- en: 'The `second` middleware adds the sentence `word: hello`.'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`second`中间件添加句子`word: hello`。'
- en: The `second` middleware sends the execution to the `end` function.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`second`中间件将执行发送到`end`函数。'
- en: The `end` function adds the sentence `function reached` and finishes its own
    job.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`end`函数添加句子`function reached`并完成自己的工作。'
- en: The execution continues by the `second` middleware and this one sets the HTTP
    status 200 to response.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行将继续由`second`中间件进行，这个中间件会将HTTP状态设置为200以响应。
- en: The execution continues by the `first` middleware and this one adds a custom
    header.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行将继续由`first`中间件进行，这个中间件会添加一个自定义标头。
- en: The response is returned to the user.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应将返回给用户。
- en: 'Of course, if you get an error during the middleware execution, you can manage
    it using the following common code:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果在中间件执行期间出现错误，您可以使用以下常见代码进行管理：
- en: '[PRE55]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The response will be sent immediately to the user without ending the entire
    execution.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将立即发送给用户，而不会结束整个执行。
- en: Available frameworks
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用的框架
- en: 'There are hundreds of frameworks available to develop your application, but
    when you need one to be used to make microframeworks, it is necessary to look
    for some characteristics:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 有数百个可用于开发应用程序的框架，但当您需要一个用于制作微框架的框架时，有必要寻找一些特点：
- en: A microframework able to process the maximum requests per second
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个能够处理最大请求数的微框架
- en: Lightweight in terms of memory
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存方面轻量级
- en: If it is possible, with a great community developing applications for that framework
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，有一个伟大的社区为该框架开发应用程序
- en: 'Now we will look at possibly the five most-used frameworks at the moment. Finding
    the best framework is not a unique opinion, every developer has their own opinion,
    so let me introduce you to the following ones:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一下可能是目前使用最多的五个框架。找到最好的框架不是一个独特的观点，每个开发者都有自己的观点，所以让我向您介绍以下几个：
- en: '| **Framework** | **Request per second** | **Peak memory** |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| **框架** | **每秒请求** | **峰值内存** |'
- en: '| Phalcon 2.0 | 1,746.90 | 0.27 |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| Phalcon 2.0 | 1,746.90 | 0.27 |'
- en: '| Slim 2.6 | 880.24 | 0.47 |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| Slim 2.6 | 880.24 | 0.47 |'
- en: '| Lumen 5.1 | 412.36 | 0.95 |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| Lumen 5.1 | 412.36 | 0.95 |'
- en: '| Zend Expressive 1.0 | 391.97 | 0.80 |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| Zend Expressive 1.0 | 391.97 | 0.80 |'
- en: '| Silex 1.3 | 383.66 | 0.86 |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| Silex 1.3 | 383.66 | 0.86 |'
- en: '**Source**: *PHP Framework Benchmark*. The project attempts to measure minimum
    overhead PHP frameworks in the real world.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源**：*PHP框架基准测试*。该项目试图在现实世界中测量PHP框架的最小开销。'
- en: Phalcon
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Phalcon
- en: Phalcon is a popular framework, it gained fame because its speed made it the
    fastest framework. Phalcon is very optimized and modular; in other words, it only
    uses the things that you need or want, without adding extra things that you won't use.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Phalcon是一个流行的框架，它因其速度而闻名。Phalcon非常优化和模块化；换句话说，它只使用您需要或想要的东西，而不会添加您不会使用的额外东西。
- en: The documentation is excellent, but its disadvantage is that the community is
    not as big as Silex or Slim, so the third-parties' community is small and it is
    sometimes a little difficult to find fast solutions when you have issues.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 文档非常好，但它的缺点是社区没有Silex或Slim那么大，所以第三方社区很小，有时在出现问题时很难找到快速解决方案。
- en: Phalcon ORM is based on the C language. This is really important if you are
    developing a microservice based on databases.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: Phalcon ORM基于C语言。如果您正在开发基于数据库的微服务，这一点非常重要。
- en: To sum up, it is the best framework; however, it is not recommended for beginners.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这是最好的框架；但是，不建议初学者使用。
- en: You can visit the official website at [https://phalconphp.com](https://phalconphp.com/).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问官方网站[https://phalconphp.com](https://phalconphp.com/)。
- en: Slim framework
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Slim框架
- en: 'Slim is one of the fastest micro RESTful frameworks available. It provides
    you with every feature that a framework should have. Also, Slim framework has
    a very big community: you can find a lot of resources, tutorials, and documentation
    on the Internet because there are a lot of developers using it.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Slim是目前可用的最快的微型RESTful框架之一。它为您提供了框架应该具有的每个功能。此外，Slim框架有一个非常庞大的社区：您可以在互联网上找到很多资源、教程和文档，因为有很多开发者在使用它。
- en: Since the release of version 3, the framework has a better architecture, making
    it better in terms of overall architecture and security. This new version is a
    little slower than version 2, but all the introduced changes make this framework
    suitable for projects of all sizes.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本3发布以来，该框架具有更好的架构，从整体架构和安全性方面来看更好。这个新版本比版本2慢一点，但所有引入的更改使得这个框架适用于各种规模的项目。
- en: The documentation is not bad, but it could be better. It is too short.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 文档不错，但可以更好。它太短了。
- en: It is a good microframework for beginners.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个适合初学者的微框架。
- en: Refer to the official website at [http://www.slimframework.com/](http://www.slimframework.com/).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅官方网站[http://www.slimframework.com/](http://www.slimframework.com/)。
- en: Lumen
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lumen
- en: Lumen is one of the fastest micro RESTful frameworks made by Laravel. This microframework
    was specially made to work with ultra fast microservices and APIs. Lumen is really
    fast, but there are some microframeworks that are faster, such as Slim, Silex,
    and Phalcon.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen是由Laravel制作的最快的微型RESTful框架之一。这个微框架是专门为超快的微服务和API而设计的。Lumen确实很快，但有一些微框架更快，比如Slim、Silex和Phalcon。
- en: This framework became famous because it was pretty similar to CodeIgniter syntax,
    and it is very easy to use, so maybe this is why Lumen is the best microframework
    to start working with microservices using a microframework. Also, Lumen has very
    good and clear documentation; you can find it at [https://lumen.laravel.com/docs](https://lumen.laravel.com/docs).
    If you use this framework, you can start to work in little time as the setup is
    really fast.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架因为它与CodeIgniter语法非常相似而变得很有名，而且非常容易使用，所以也许这就是为什么Lumen是使用微框架开始使用微服务的最佳微框架。此外，Lumen有非常好和清晰的文档；您可以在[https://lumen.laravel.com/docs](https://lumen.laravel.com/docs)找到它。如果您使用这个框架，您可以在很短的时间内开始工作，因为设置非常快。
- en: Another advantages of Lumen is that you can start working with it and then,
    if you need the complete Laravel in the future, it is very easy to transform and
    update the framework into Laravel.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen的另一个优点是您可以开始使用它，然后，如果将来需要完整的Laravel，将框架转换和更新为Laravel非常容易。
- en: Please note that Lumen still enforces an application structure (convention over
    configuration) that might limit your options when you design your application.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Lumen仍然强制执行应用程序结构（约定优于配置），这可能会在设计应用程序时限制您的选项。
- en: If you are going to use Lumen, it is because you have used Laravel and you liked
    it; if you do not like Laravel, Lumen is not the best solution for you.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要使用Lumen，那是因为您已经使用过Laravel并且喜欢它；如果您不喜欢Laravel，Lumen不是最好的解决方案。
- en: You can visit the official website at [https://lumen.laravel.com/](https://lumen.laravel.com/).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问官方网站[https://lumen.laravel.com/](https://lumen.laravel.com/)。
- en: Zend Expressive
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Zend Expressive
- en: Lumen is the equivalent of Laravel and Zend Expressive is for Zend Framework.
    It is a microframework built to make microservices and is prepared to be used
    exclusively following PSR-7 and based on middleware.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen相当于Laravel，Zend Expressive相当于Zend Framework。它是一个用于制作微服务的微框架，并且准备根据PSR-7进行专门使用，并基于中间件。
- en: It is possible to set it up in a few minutes and you have all the advantages
    of Zend Framework on it in terms of community. Also, being a product of Zend is
    a synonym of quality and security.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在几分钟内设置它，并且在社区方面具有Zend Framework的所有优势。此外，作为Zend的产品是质量和安全的代名词。
- en: It comes with a minimal core and you can choose what components you want to
    include. It has very good flexibility and ability to extend it too.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有最小的核心，您可以选择要包含的组件。它具有非常好的灵活性和扩展能力。
- en: Visit the official website at [https://zendframework.github.io/zend-expressive/](https://zendframework.github.io/zend-expressive/).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 访问官方网站[https://zendframework.github.io/zend-expressive/](https://zendframework.github.io/zend-expressive/)。
- en: Silex (based on Symfony)
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Silex（基于Symfony）
- en: Silex is also a very good micro RESTful PHP framework. It is one of the five fastest
    microframeworks and currently, it is one of the best known because the Silex community
    is one of the bigger ones and they develop really good third parties, so developers
    have many solutions for their projects.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: Silex也是一个非常好的微型RESTful PHP框架。它是五个最快的微框架之一，目前它是最知名的之一，因为Silex社区是最大的之一，他们开发了非常好的第三方，因此开发人员对其项目有许多解决方案。
- en: The community and its connection to Symfony guarantee stable implementation
    with many available resources. Also, the documentation is really good, and this
    microframework is specially good for large projects.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 社区及其与Symfony的连接保证了稳定的实现和许多可用资源。此外，文档真的很好，这个微框架特别适合大型项目。
- en: The advantages of Silex and Slim Framework are pretty similar; maybe the competition
    made them better.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: Silex和Slim Framework的优势非常相似；也许是竞争使它们变得更好。
- en: Refer to the official website at [http://silex.sensiolabs.org/](http://silex.sensiolabs.org/).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅官方网站[http://silex.sensiolabs.org/](http://silex.sensiolabs.org/)。
- en: Summary
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we talked about what we are going to build in this book as an
    example application. We also showed you how you can set up your development machine
    using Docker, and we even talked about the different microframeworks you can use
    .In the next chapter, we will learn how to go about designing our application
    and different types of microservices patterns.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了本书中要构建的示例应用程序。我们还向您展示了如何使用Docker设置开发机器，甚至谈到了您可以使用的不同微框架。在下一章中，我们将学习如何设计我们的应用程序以及不同类型的微服务模式。
