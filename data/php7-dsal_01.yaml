- en: Introduction to Data Structures and Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构和算法简介
- en: We are living in a digital era. In every segment of our life and daily needs,
    we have a significant use of technology. Without technology, the world will virtually
    stand still. Have you ever tried to find what it takes to prepare a simple weather
    forecast? Lots of data are analyzed to prepare simple information, which is delivered
    to us in real time. Computers are the most important find of the technology revolution
    and they have changed the world drastically in the last few decades. Computers
    process these large sets of data and helps us in every technology-dependent task
    and need. In order to make computer operation efficient, we represent data in
    different formats or we can call in different structures, which are known as data
    structures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个数字时代。在我们生活和日常需求的每个领域，我们都有重要的技术应用。没有技术，世界将几乎停滞不前。你是否曾经尝试过准备简单的天气预报需要什么？大量的数据被分析以准备简单的信息，这些信息实时传递给我们。计算机是技术革命中最重要的发现，它们在过去几十年里彻底改变了世界。计算机处理这些大量的数据，并在每个依赖技术的任务和需求中帮助我们。为了使计算机操作高效，我们以不同的格式或不同的结构来表示数据，这就是所谓的数据结构。
- en: Data structures are very important components for computers and programming
    languages. Along with data structures, it is also very important to know how to
    solve a problem or find a solution using these data structures. From our simple
    mobile phone contact book to complex DNA profile matching systems, the use of
    data structures and algorithms is everywhere.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是计算机和编程语言的非常重要的组成部分。除了数据结构之外，了解如何使用这些数据结构解决问题或找到解决方案也非常重要。从我们简单的手机联系人名单到复杂的DNA个人资料匹配系统，数据结构和算法的使用无处不在。
- en: Have we ever thought that standing in a superstore queue to payout can be a
    representation of data structure? Or taking out a bill from a pile of papers can
    be another use of data structure? In fact, we are following data structure concepts
    almost everywhere in our lives. Whether we are managing the queue to pay the bill
    or to get to the transportation, or maintaining a stack for a pile of books or
    papers for daily works, data structures are everywhere and impacting our lives.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否曾想过在超市排队结账可以代表数据结构？或者从一堆文件中取出一张账单可以是数据结构的另一种用途？事实上，我们几乎在生活中的每个地方都在遵循数据结构的概念。无论是管理支付账单的队列还是乘坐交通工具，或者为日常工作维护一堆书或文件的堆栈，数据结构无处不在，影响着我们的生活。
- en: PHP is a very popular scripting language and billions of websites and applications
    are built using it. People use **Hypertext Preprocessor** (**PHP** ) for simple
    applications to very complex ones and some are very data intensive. The big question
    is--should we use PHP for any data intensive application or algorithmic solutions?
    Of course we should. With the new release of PHP 7, PHP has entered into new possibilities
    of efficient and robust application development. Our mission will be to show and
    prepare ourselves to understand the power of data structures and algorithms using
    PHP 7, so that we can utilize it in our applications and programs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: PHP是一种非常流行的脚本语言，数十亿的网站和应用程序都是使用它构建的。人们使用**超文本预处理器**（**PHP**）来开发简单的应用程序到非常复杂的应用程序，有些应用程序非常数据密集。一个重要的问题是-我们是否应该为任何数据密集型应用程序或算法解决方案使用PHP？当然应该。随着PHP
    7的新版本发布，PHP已经进入了高效和健壮应用程序开发的新可能性。我们的任务将是展示并准备自己了解使用PHP 7的数据结构和算法的力量，以便我们可以在我们的应用程序和程序中利用它。
- en: Importance of data structures and algorithms
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构和算法的重要性
- en: 'If we consider our real-life situation with computers, we also use different
    sorts of arrangements of our belongings and data so that we can use them efficiently
    or find them easily when needed. What if we enter our phone contact book in a
    random order? Will we be able to find a contact easily? We might end up searching
    each and every contact in the book as the contacts are not arranged in a particular
    order. Just consider the following two images:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑现实生活中与计算机的情况，我们也会使用不同的方式来安排我们的物品和数据，以便在需要时能够高效地使用它们或轻松找到它们。如果我们以随机顺序输入我们的电话联系人名单会怎么样？我们能轻松找到联系人吗？由于联系人没有按特定顺序排列，我们可能最终会在通讯录中搜索每个联系人。只需考虑以下两幅图像：
- en: '![](Image00004.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00004.jpg)'
- en: One shows that the books are scattered and finding a particular book will take
    time as the books are not organized. The other one shows that the books are organized
    in a stack. Not only does the second image show that we are using the space smartly,
    but also the searching of books becomes easier.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一幅图表明书籍是零散的，找到特定的书籍将需要时间，因为书籍没有组织。另一幅图表明书籍是按照堆栈组织的。第二幅图不仅显示我们聪明地利用了空间，而且书籍的搜索变得更容易了。
- en: 'Let us consider another example. We are going to buy tickets for an important
    football match. There are thousands of people waiting for the ticket booth to
    open. Tickets are going to be distributed on a first come first served basis.
    If we consider the following two images, which one is the best way of handling
    such a big crowd?:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子。我们要为一场重要的足球比赛买票。成千上万的人在等待售票亭开放。票将按先到先得的原则分发。如果我们考虑以下两幅图像，哪一种是处理如此庞大人群的最佳方式？：
- en: '![](Image00005.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00005.jpg)'
- en: The left image clearly shows that there is no proper order and there is no way
    to know who came first to get the tickets. But if we knew that people were waiting
    in a structured way, in a line, or queue, then it will be easier to handle the
    crowd and we will hand over the tickets to whoever came first. This is a common
    phenomenon known as a *queue* which is heavily used in the programming world.
    Programming terms are not generated from outside the world. In fact, the majority
    of the data structures are inspired from real life and they use the same terms
    most of the times. Whether we are preparing our task list, contact list, book
    piles, diet charting, preparing a family tree, or organization hierarchy, we are
    basically using different arrangement techniques which are known as data structures
    in the computing world.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的图片清楚地显示了没有适当的顺序，也没有办法知道谁先来拿票。但是如果我们知道人们是按照有序的方式排队等候，那么处理人群将更容易，我们将把票交给先来的人。这是一个被称为*队列*的常见现象，在编程世界中被广泛使用。编程术语并不是从外部世界产生的。事实上，大多数数据结构都受到现实生活的启发，它们大多数时候使用相同的术语。无论我们是在准备任务清单、联系人清单、书堆、饮食图表、家谱，还是组织层次结构，我们基本上都在使用计算世界中被称为数据结构的不同排列技术。
- en: 'We have talked a little about data structures so far but what about algorithms?
    Don''t we use any algorithms in our daily lives? Definitely we do. Whenever we
    are searching for a contact from our old phone book, we are definitely not searching
    from the beginning. If we are searching for *Tom* , we will not search the page
    where it says *A* , *B,* or *C* . We are directly going to the page *T* and will
    find if *Tom* is listed there or not. Or, if we need to find a doctor from a telephone
    directory, we will definitely not search in the foods section. If we consider
    the phone book or telephone directory as data structures, then the way we search
    for particular information is known as algorithms. While data structures help
    us to use data efficiently, algorithms help us to perform different operations
    on those data efficiently.For example, if we have 100,000 entries in our phone
    directory, searching a particular entry from the beginning might take a long time.
    But, if we know the doctors are listed from page 200 to 220, we can search only
    those pages to save our time by searching a small section rather than the full
    directory:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经谈到了一些数据结构，但是算法呢？我们日常生活中难道不使用任何算法吗？当然我们会。每当我们从旧电话簿中搜索联系人时，肯定不是从头开始搜索。如果我们要搜索*TOM*，我们不会搜索写有*A*、*B*或*C*的页面。我们直接去*T*页面，然后查找*TOM*是否在那里列出。或者，如果我们需要从电话簿中找到一位医生，我们肯定不会在食品部分搜索。如果我们把电话簿或电话目录视为数据结构，那么我们搜索特定信息的方式就被称为算法。数据结构帮助我们高效地使用数据，而算法帮助我们高效地对这些数据执行不同的操作。
- en: '![](Image00006.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: 例如，如果我们的电话目录中有10万条记录，从头开始搜索特定条目可能需要很长时间。但是，如果我们知道医生的名字在第200页到第220页，我们可以只搜索这些页面来节省时间，而不是搜索整个目录。
- en: We can also consider a different way of searching for a doctor. While the previous
    paragraph takes the approach of searching a particular section of the directory,
    we can even search alphabetically within the directory, like the way we search
    a dictionary for a word. That might even reduce the time and entries for our searching.
    There can be many different approaches to find solutions of a problem, and each
    of the approaches can be named as algorithms. From the earlier discussion we can
    say that for a particular problem or task, there can be multiple ways or algorithms
    to perform. Then which one should we consider to use? We are going to discuss
    that very soon. Before moving to that point, we are going to focus on **PHP data
    types** and **Abstract Data Types** (**ADT** ). In order to grasp the data structure
    concept, we must have a strong understanding of PHP data types and ADT.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以考虑另一种寻找医生的方法。前面的段落是搜索目录中的特定部分，我们甚至可以按字母顺序在目录中搜索，就像我们在字典中搜索单词一样。这可能会减少我们搜索的时间和条目。寻找问题的解决方案可能有许多不同的方法，每种方法都可以称为算法。从前面的讨论中，我们可以说对于特定的问题或任务，可能有多种方法或算法可供执行。那么我们应该考虑使用哪一种？我们很快就会讨论这个问题。在讨论这一点之前，我们将专注于**PHP数据类型**和**抽象数据类型**（**ADT**）。为了理解数据结构的概念，我们必须对PHP数据类型和ADT有深入的理解。
- en: Understanding Abstract Data Type (ADT)
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解抽象数据类型（ADT）
- en: PHP has eight primitive data types and those are booleans, integer, float, string,
    array, object, resource, and null. Also, we have to remember that PHP is a weakly
    typed language and that we are not bothered about the data type declaration while
    creating those. Though PHP has some static type features, PHP is predominantly
    a dynamically typed language which means variables are not required to be declared
    before using it. We can assign a value to a new variable and use it instantly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: PHP有八种原始数据类型，分别是布尔值、整数、浮点数、字符串、数组、对象、资源和空值。此外，我们必须记住PHP是一种弱类型语言，我们在创建这些数据时不需要关心数据类型声明。虽然PHP具有一些静态类型特性，但PHP主要是一种动态类型语言，这意味着在使用变量之前不需要声明。我们可以为新变量赋值并立即使用它。
- en: 'For the examples of data structures we have discussed so far can we use any
    of the primitive data types to represent those structures? Maybe we can or maybe
    not. Our primitive data types have one particular objective: storing data. In
    order to achieve some flexibility in performing operations on those data, we will
    require using the data types in such a way so that we can use them as a particular
    model and perform some operations. This particular way of handling data through
    a conceptual model is known as Abstract Data Type, or ADT. ADT also defines a
    set of possible operations for the data.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们讨论的数据结构的例子，我们可以使用原始数据类型中的任何一个来表示这些结构吗？也许可以，也许不行。我们的原始数据类型有一个特定的目标：存储数据。为了在这些数据上执行一些灵活的操作，我们需要以一种特定的方式使用数据类型，以便我们可以将它们用作特定的模型并执行一些操作。通过概念模型处理数据的这种特定方式被称为抽象数据类型，或ADT。ADT还定义了数据的一组可能操作。
- en: We need to understand that ADTs are mainly theoretical concepts which are used
    in design and analysis of algorithms, data structures, and software design. In
    contrast, data structures are concrete representations. In order to implement
    an ADT, we might need to use data types or data structures or both. The most common
    example of ADTs is s*tack* and *queue:*
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要理解ADT主要是理论概念，用于算法、数据结构和软件设计的设计和分析。相比之下，数据结构是具体的表示。为了实现ADT，我们可能需要使用数据类型或数据结构，或者两者兼而有之。ADT的最常见例子是栈和队列。
- en: '![](Image00007.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00007.jpg)'
- en: 'Considering the stack as ADT, it is not only a collection of data but also
    two important operations called push and pop. Usually, we put a new entry at the
    top of the stack which is known as *push* and when we want to take an item, we
    take from the top which is also known as *pop* . If we consider PHP array as a
    stack, we will require additional functionality to achieve these push and pop
    operations to consider it as stack ADT. Similarly, a queue is also an ADT with
    two required operations: to add an item at the end of the queue also known as
    *enqueue* and remove an item from the beginning of the queue, also known as *dequeue*
    . Both sound similar but if we give a close observation we will see that a stack
    works as a **Last-In, First-Out** (**LIFO** ) model whereas a queue works as a
    **First-In, First-Out** (**FIFO** ) model. These two different mathematical models
    make them two different ADTs.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑栈作为ADT，它不仅是数据的集合，还有两个重要的操作称为推入和弹出。通常，我们将一个新条目放在栈的顶部，这被称为*push*，当我们想要取一个项目时，我们从顶部取出，这也被称为*pop*。如果我们将PHP数组视为栈，我们将需要额外的功能来实现这些推入和弹出操作，以将其视为栈ADT。同样，队列也是一个ADT，有两个必需的操作：在队列的末尾添加一个项目，也称为*enqueue*，从队列的开头移除一个项目，也称为*dequeue*。两者听起来很相似，但如果我们仔细观察，我们会发现栈作为**后进先出**（**LIFO**）模型，而队列作为**先进先出**（**FIFO**）模型。这两种不同的数学模型使它们成为两种不同的ADT。
- en: 'Here are some common ADTs:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见的ADT：
- en: List
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: Map
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: Set
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Stack
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈
- en: Queue
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列
- en: Priority queue
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先队列
- en: Graph
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图
- en: Tree
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树
- en: In coming chapters, we will explore more ADTs and implement them as data structures
    using PHP.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探索更多的ADT，并使用PHP将它们实现为数据结构。
- en: Different data structures
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的数据结构
- en: 'We can categorize data structures in to two different groups:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将数据结构分类为两种不同的组：
- en: Linear data structures
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性数据结构
- en: Nonlinear data structures
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非线性数据结构
- en: In linear data structures, items are structured in a linear or sequential manner.
    Array, list, stack, and queue are examples of linear structures. In nonlinear
    structures, data are not structured in a sequential way. Graph and tree are the
    most common examples of nonlinear data structures.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性数据结构中，项目以线性或顺序方式结构化。数组、列表、栈和队列是线性结构的例子。在非线性结构中，数据不是以顺序方式结构化的。图和树是非线性数据结构的最常见例子。
- en: Let us now explore the world of data structures, with different types of data
    structures and their purposes in a summarized way. Later on, we will explore each
    of the data structures in details.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们以一种总结的方式探索数据结构的世界，包括不同类型的数据结构及其目的。稍后，我们将详细探索每种数据结构。
- en: 'There are many different types of data structures that exist in the programming
    world. Out of them, following are the most used ones:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程世界中存在许多不同类型的数据结构。其中，以下是最常用的：
- en: Struct
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构
- en: Array
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Linked list
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表
- en: Doubly linked list
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向链表
- en: Stack
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈
- en: Queue
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列
- en: Priority queue
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先队列
- en: Set
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Map
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: Tree
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树
- en: Graph
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图
- en: Heap
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆
- en: Struct
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构
- en: Usually, a variable can store a single data type and a single scalar data type
    can only store a single value. There are many situations where we might need to
    group some data types together as a single complex data type. For example, we
    want to store some student information together in a student data type. We need
    the student name, address, phone number, email, date of birth, current class,
    and so on. In order to store each student record to a unique student data type,
    we will need a special structure which will allow us to do that. This can be easily
    achieved by *struct* . In other words, a struct is a container of values which
    is typically accessed using names. Though structs are very popular in C programming
    language, we can use a similar concept in PHP as well. We are going to explore
    that in coming chapters.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个变量只能存储一个数据类型，一个标量数据类型只能存储一个值。有许多情况下，我们可能需要将一些数据类型组合在一起作为一个复杂的数据类型。例如，我们想要将一些学生信息一起存储在一个学生数据类型中。我们需要学生的姓名、地址、电话号码、电子邮件、出生日期、当前班级等信息。为了将每个学生记录存储到一个独特的学生数据类型中，我们将需要一个特殊的结构来允许我们这样做。这可以很容易地通过*struct*实现。换句话说，结构是一个值的容器，通常使用名称访问。虽然结构在C编程语言中非常流行，但我们也可以在PHP中使用类似的概念。我们将在接下来的章节中探索这一点。
- en: Array
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Though an array is considered to be a data type in PHP, an array is actually
    a data structure which is mostly used in all programming platforms. In PHP, the
    array is actually an ordered map (we are going to know about maps after a few
    more sections). We can store multiple values in a single array as a single variable.
    Matrix type data are easy to store in an array and hence it is used widely in
    all programming platforms. Usually arrays are a fixed size collection which is
    accessed by sequential numeric indexes. In PHP, arrays are implemented differently
    and you can define dynamic arrays without defining any fixed size of the array.
    We will explore more about PHP arrays in the next chapter. Arrays can have different
    dimensions. If an array has only one index to access an element, we call it a
    single dimension array. But if it requires two or more indexes to access an element,
    we call it two dimensional or multidimensional arrays respectively. Here are two
    diagrams of array data structures:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数组被认为是PHP中的一种数据类型，但数组实际上是一种在所有编程平台上广泛使用的数据结构。在PHP中，数组实际上是一个有序映射（我们将在几节后了解映射）。我们可以将多个值存储在单个数组中作为单个变量。矩阵类型的数据在数组中易于存储，因此它在所有编程平台上被广泛使用。通常数组是一个固定大小的集合，通过顺序数字索引访问。在PHP中，数组的实现方式不同，您可以定义动态数组而不定义数组的固定大小。我们将在下一章中更多地探讨PHP数组。数组可以有不同的维度。如果一个数组只有一个索引来访问元素，我们称之为单维数组。但如果需要两个或更多索引来访问元素，我们分别称之为二维或多维数组。以下是两个数组数据结构的图示：
- en: '![](Image00008.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00008.jpg)'
- en: Linked list
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表
- en: 'A linked list is a linear data structure which is a collection of data elements
    also known as nodes and can have varying sizes. Usually, listed items are connected
    through a pointer which is known as a link and hence it is known as a **linked
    list** . In a linked list, one list element links to the next element through
    a pointer. From the following diagram, we can see that the linked list actually
    maintains an ordered collection. Linked lists are the most common and simplest
    form of data structures used by programming languages. In a single linked list,
    we can only go forward. In [Chapter 3](text00065.html) , *Using Linked Lists*
    we are going to dive deep inside the linked list concepts and implementations:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 链表是一种线性数据结构，是数据元素的集合，也称为节点，并且可以具有不同的大小。通常，列出的项目通过一个指针连接，称为链接，因此它被称为**链表**。在链表中，一个列表元素通过指针链接到下一个元素。从下图中，我们可以看到链表实际上维护了一个有序集合。链表是编程语言中使用的最常见和最简单的数据结构形式。在单链表中，我们只能向前移动。在[第3章](text00065.html)中，*使用链表*，我们将深入探讨链表的概念和实现：
- en: '![](Image00009.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00009.jpg)'
- en: Doubly linked list
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表
- en: 'A doubly linked list is a special type of linked list where we not only store
    what is the next node, but we also store the previous node inside the node structure.
    As a result, it can move forward and backward within the list. It gives more flexibility
    than a single linked list or linked list by having both the previous and next
    pointers. We are going to explore more about these in [Chapter 3](text00065.html)
    , *Using Linked Lists* . The following diagram depicts a doubly linked list:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表是一种特殊类型的链表，我们不仅存储下一个节点是什么，还在节点结构中存储了前一个节点。因此，它可以在列表内前后移动。它比单链表或链表具有更多的灵活性，因为它同时具有前一个和后一个指针。我们将在[第3章](text00065.html)中更多地探讨这些内容，*使用链表*。以下图示了双向链表：
- en: '![](Image00010.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00010.jpg)'
- en: Stack
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈
- en: As we talked about the stack in previous pages, we already know that stack is
    a linear data structure with the LIFO principle. As a result, stacks have only
    one end to add a new item or remove an item. It is one of the oldest and most
    used data structures in computer technology. We always add or remove an item from
    a stack using the single point named *top.* The term push is used to indicate
    an item to be added on top of the stack and pop to remove an item from the top;
    this is shown in the following diagram. We will discuss more about stacks in [Chapter
    4](text00098.html) , *Constructing Stacks and Queues* .
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的页面中讨论过的堆栈，我们已经知道堆栈是具有LIFO原则的线性数据结构。因此，堆栈只有一个端口用于添加新项目或移除项目。它是计算机技术中最古老和最常用的数据结构之一。我们总是使用名为*top*的单点从堆栈中添加或移除项目。术语push用于指示要添加到堆栈顶部的项目，pop用于从顶部移除项目；这在下图中显示。我们将在[第4章](text00098.html)中更多地讨论堆栈和队列的内容。
- en: '![](Image00011.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00011.jpg)'
- en: Queue
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: A queue is another linear data structure which follows the FIFO principle. A
    queue allows two basic operations on the collection. The first one is *enqueue*
    which allows us to add an item to the back of the queue. The second one is *dequeue*
    which allows us to remove an item from the front of the queue. A queue is another
    of the most used data structures in computer technology. We will learn details
    about queues in [Chapter 4](text00098.html) , *Consrtucting Stacks and Queues*
    .
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是另一种遵循FIFO原则的线性数据结构。队列允许对集合进行两种基本操作。第一种是*enqueue*，它允许我们将项目添加到队列的后面。第二种是*dequeue*，它允许我们从队列的前面移除项目。队列是计算机技术中最常用的数据结构之一。我们将在[第4章](text00098.html)中学习有关队列的详细信息，*构建堆栈和队列*。
- en: '![](Image00012.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00012.jpg)'
- en: Set
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: A set is an abstract data type which is used to store certain values. These
    values are not stored in any particular order but there should not be any repeated
    values in the set. Set is not used like a collection where we retrieve a specific
    value from it; a set is used to check the existence of a value inside it. Sometimes
    a set data structure can be sorted and we call it an ordered set.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一种抽象数据类型，用于存储特定的值。这些值不以任何特定顺序存储，但集合中不应该有重复的值。集合不像集合那样用于检索特定值；集合用于检查其中是否存在某个值。有时，集合数据结构可以被排序，我们称之为有序集。
- en: Map
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: A map is a collection of key and value pairs where all the keys are unique.
    We can consider a map as an associative array where all keys are unique. We can
    add and remove using key and value pairs along with update and look up from a
    map using a key. In fact, PHP arrays are ordered map implementations. We are going
    to explore that in the next chapter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 地图是一个键值对的集合，其中所有键都是唯一的。我们可以将地图视为一个关联数组，其中所有键都是唯一的。我们可以使用键和值对添加和删除，以及使用键更新和查找地图。事实上，PHP数组是有序地图实现。我们将在下一章中探讨这一点。
- en: Tree
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树
- en: A tree is the most widely used nonlinear data structure in the computing world.
    It is highly used for hierarchical data structures. A tree consists of nodes and
    there is a special node which is known as the *root* of the tree which starts
    the tree structure. Other nodes descend from the root node. Tree data structure
    is recursive which means a tree can contain many subtrees. Nodes are connected
    with each other through edges. We are going to discuss different types of trees,
    their operations, and purposes in [Chapter 6](text00138.html) , *Understanding
    and Implementing Trees* .
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 树是计算世界中最广泛使用的非线性数据结构。它在分层数据结构中被广泛使用。树由节点组成，有一个特殊的节点被称为树的*根*，它开始了树结构。其他节点从根节点下降。树数据结构是递归的，这意味着树可以包含许多子树。节点通过边连接在一起。我们将在[第6章](text00138.html)中讨论不同类型的树，它们的操作和目的，*理解和实现树*。
- en: '![](Image00013.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00013.jpg)'
- en: Graph
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图
- en: 'A graph data structure is a special type of nonlinear data structure which
    consists of a finite number of vertices or nodes, and edges or arcs. A graph can
    be both directed and undirected. A directed graph clearly indicates the direction
    of the edges, while an undirected graph mentions the edges, not the direction.
    As a result, in an undirected graph, both directions of edge are considered as
    a single edge. In other words, we can say a graph is a pair of sets (*V, E* ),
    where *V* is the set of vertices and *E* is the set of edges:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据结构是一种特殊类型的非线性数据结构，由有限数量的顶点或节点和边或弧组成。图可以是有向的也可以是无向的。有向图清楚地指示边的方向，而无向图提到边，而不是方向。因此，在无向图中，边的两个方向被视为单个边。换句话说，我们可以说图是一对集合（*V，E*），其中*V*是顶点的集合，*E*是边的集合：
- en: '*V = {A, B, C, D, E, F}*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*V = {A, B, C, D, E, F}*'
- en: '*E = {AB, BC, CE, ED, EF, DB}*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*E = {AB, BC, CE, ED, EF, DB}*'
- en: 'In a directed graph, an edge *AB* is different from an edge *BA* while in an
    undirected graph, both *AB* and *BA* are the same. Graphs are handy to solve lots
    of complex problems in the programming world. We are going to continue our discussion
    of graph data structures in [Chapter 9](text00202.html) , *Putting Graphs into
    Action* . In the following diagram, we have:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在有向图中，边*AB*与边*BA*不同，而在无向图中，*AB*和*BA*都是相同的。图在编程世界中解决许多复杂问题。我们将在[第9章](text00202.html)中继续讨论图数据结构，*将图形投入实践*。在下图中，我们有：
- en: '![](Image00014.gif)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00014.gif)'
- en: Heap
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆
- en: A heap is a special tree-based data structure which satisfies the heap properties.
    The largest key is the root and smaller keys are leaves, which is known as **max
    heap** . Or, the smallest key is the root and larger keys are leaves, which is
    known as **min heap** . Though the root of a heap structure is either the largest
    or smallest key of the tree, it is not necessarily a sorted structure. A heap
    is used for solving graph algorithms with efficiency and also in sorting. We are
    going to explore heap data structures in [Chapter 10](text00229.html) , *Understanding
    and Using Heaps* .
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是一种特殊的基于树的数据结构，满足堆属性。最大键是根，较小的键是叶子，这被称为**最大堆**。或者，最小键是根，较大的键是叶子，这被称为**最小堆**。尽管堆结构的根是树的最大或最小键，但它不一定是一个排序结构。堆用于以高效方式解决图算法以及排序。我们将在[第10章](text00229.html)中探讨堆数据结构，*理解和使用堆*。
- en: '![](Image00015.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00015.jpg)'
- en: Solving a problem - algorithmic approach
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决问题 - 算法方法
- en: So far we have discussed different types of data structures and their usage.
    But, one thing we have to remember is that just putting data in a proper structure
    might not solve our problems. We need to find solutions to our problems using
    the help of data structures or, in other words, we are going to solve problems
    using data structures. We need algorithms to solve our problem.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了不同类型的数据结构及其用途。但是，我们必须记住的一件事是，仅仅将数据放入适当的结构中可能并不能解决我们的问题。我们需要利用数据结构来解决问题，换句话说，我们将使用数据结构来解决问题。我们需要算法来解决问题。
- en: 'An algorithm is a step by step process which defines the set of instructions
    to be executed in a certain order to get a desired output. In general, algorithms
    are not limited to any programming language or platform. They are independent
    of programming languages. An algorithm must have the following characteristics:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 算法是一种逐步过程，它定义了一组指令，按照特定顺序执行以获得期望的输出。一般来说，算法不限于任何编程语言或平台。它们独立于编程语言。算法必须具有以下特征：
- en: '**Input** : An algorithm must have well-defined input. It can be 0 or more
    inputs.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入**：算法必须有明确定义的输入。可以是0个或多个输入。'
- en: '**Output** : An algorithm must have well-defined output. It must match the
    desired output.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出**：算法必须有明确定义的输出。它必须与期望的输出匹配。'
- en: '**Precision** : All steps are precisely defined.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精确性**：所有步骤都被精确定义。'
- en: '**Finiteness** : An algorithm must stop after a certain number of steps. It
    should not run indefinitely.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限性**：算法必须在一定数量的步骤之后停止。它不应该无限期运行。'
- en: '**Unambiguous** : An algorithm should be clear and should not have any ambiguity
    in any of the steps.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无歧义**：算法应该清晰，任何步骤都不应该有任何歧义。'
- en: '**Independent** : An algorithm should be independent of any programming language
    or platforms.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立性**：算法应该独立于任何编程语言或平台。'
- en: Let us now create an algorithm. But in order to do that, we need a problem statement.
    So let us assume that we have a new shipment of books for our library. There are
    1000 books and they are not sorted in any particular order. We need to find books
    as per the list and store them in their designated shelves. How do we find them
    from the pile of books?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个算法。但是为了做到这一点，我们需要一个问题陈述。所以让我们假设我们的图书馆有一批新书。有1000本书，它们没有按任何特定顺序排序。我们需要按照列表找到书，并将它们存放在指定的书架上。我们如何从一堆书中找到它们呢？
- en: Now, we can solve the problem in different ways. Each way has a different approach
    to find out a solution for the problem. We call these approaches algorithms. To
    keep the discussion short and precise, we are going to only consider two approaches
    to solve the problem. We know there are several other ways as well but for simplicity
    let us keep our discussion only for one algorithm.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以以不同的方式解决问题。每种方式都有不同的解决问题的方法。我们称这些方法为算法。为了简洁明了地讨论，我们将只考虑两种解决问题的方法。我们知道还有其他几种方法，但为了简单起见，让我们只讨论一种算法。
- en: We are going to store the books in a simple row so that we can see the book
    names. Now, we will pick a book name from the list and search from one end of
    the row to the other end till we find the book. So basically, we are going to
    follow a sequential search for each of the books. We will repeat these steps until
    we place all books in their designated places.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把书籍存放在一个简单的行中，以便我们可以看到书名。现在，我们将从列表中挑选一本书名，并从一端到另一端搜索，直到找到这本书。所以基本上，我们将为每本书进行顺序搜索。我们将重复这些步骤，直到将所有书放在指定的位置。
- en: Writing pseudocode
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写伪代码
- en: Computer programs are written for machine reading. We have to write them in
    a certain format which will be compiled for the machine to understand. But often
    those written codes are not easy to follow for people other than programmers.
    In order to show those codes in an informal way so that humans can also understand,
    we prepare **pseudocode** . Though it is not an actual programming language code,
    pseudocode has similar structural conventions of a programming language. Since
    pseudocode does not run as a real program, there is no standard way of writing
    a pseudocode. We can follow our own way of writing a pseudocode.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序是为了机器阅读而编写的。我们必须以一定的格式编写它们，以便为机器理解而进行编译。但是，通常这些编写的代码对于程序员以外的人来说并不容易理解。为了以一种非正式的方式展示这些代码，以便人类也能理解，我们准备**伪代码**。虽然它不是实际的编程语言代码，但伪代码具有编程语言的类似结构约定。由于伪代码不能像真正的程序一样运行，因此没有标准的伪代码编写方式。我们可以按照自己的方式编写伪代码。
- en: 'Here is the pseudocode for our algorithm to find a book:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们用于查找书籍的算法的伪代码：
- en: '[PRE0]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let us examine the pseudocode we have written. We are supplying a list
    of books and a name that we are searching. We are running a `foreach` loop to
    iterate each of the books and matching with the book name we are searching. If
    it is found, we are returning the position of the book where we found it, `false`
    otherwise. So, we have written a pseudocode to find a book name from our book
    list. But what about the other remaining books? How do we continue our search
    till all books are found and placed on the right shelf?:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查我们写的伪代码。我们提供了一份书籍清单和一个我们正在搜索的名字。我们正在运行一个`foreach`循环，以迭代每一本书，并与我们正在搜索的书名进行匹配。如果找到了，我们将返回我们找到它的位置，否则返回`false`。因此，我们编写了一份伪代码来查找书名。但是其他剩下的书呢？我们如何继续搜索，直到所有书都找到并放在正确的书架上呢？
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we have the complete pseudocode for our algorithm of solving the book organization
    problem. Here, we are going through the list of ordered books and finding the
    book in the delivered section. If the book is found, we are removing it from the
    list and placing it to the right shelf.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了解决书籍组织问题的算法的完整伪代码。在这里，我们正在浏览有序书籍列表，并在交付部分找到书籍。如果找到书籍，我们将其从列表中删除，并将其放到正确的书架上。
- en: This simple approach of writing pseudocode can help us solve more complex problems
    in a structured manner. Since pseudocodes are independent of programming languages
    and platforms, algorithms are expressed as pseudocode most of the time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 编写伪代码的这种简单方法可以帮助我们以结构化的方式解决更复杂的问题。由于伪代码独立于编程语言和平台，因此大多数时间算法都以伪代码的形式表达。
- en: Converting pseudocode to actual code
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将伪代码转换为实际代码
- en: 'We are now going to convert our pseudocodes to actual PHP 7 codes as shown:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将把我们的伪代码转换为实际的PHP 7代码，如下所示：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let us now understand what is happening in the preceding code. First we have
    defined a new function, `findABook` at the beginning of the code. The function
    is defined with two parameters. One is `Array $bookList` and the other is `String
    $bookName` . At the beginning of the function we are initializing the `$found`
    to `FALSE` , which means nothing has been found yet. The `foreach` loop iterates
    through the book list array `$bookList` and for each book, it matches with our
    provided book name `$bookName` . If the book name that we are looking for matches
    with the book in the `$bookList` , we are assigning the index (where we found
    the match) to our `$found` variable. Since we have found it, there is no point
    in continuing the loop. So, we have used the `break` command to get out of the
    loop. Just out of the loop we are returning our `$found` variable. If the book
    was found, usually `$found` will return any integer value greater than 0, else
    it will return `false` :'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们理解前面的代码发生了什么。首先，我们在代码开头定义了一个新函数`findABook`。该函数定义了两个参数。一个是`Array $bookList`，另一个是`String
    $bookName`。在函数的开头，我们将`$found`初始化为`FALSE`，这意味着还没有找到任何东西。`foreach`循环遍历书籍列表数组`$bookList`，对于每本书，它与我们提供的书名`$bookName`进行匹配。如果我们正在寻找的书名与`$bookList`中的书名匹配，我们将匹配的索引（我们找到匹配的地方）赋给我们的`$found`变量。既然我们找到了，继续循环就没有意义了。因此，我们使用`break`命令来跳出循环。刚刚跳出循环，我们返回我们的`$found`变量。如果找到了书，通常`$found`将返回大于0的任何整数值，否则将返回`false`：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This particular function `placeAllBooks` actually iterates through our ordered
    books `$orderedBooks` . We are iterating our ordered book list and searching each
    book in our delivered list using the `findABook` function. If the book is found
    in the ordered list (`$bookFound !== FALSE` ), we are removing that book from
    the delivered book list using the `array_splice()` function of PHP:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的函数`placeAllBooks`实际上遍历了我们的有序书籍`$orderedBooks`。我们正在遍历我们的有序书籍列表，并使用`findABook`函数在我们的交付列表中搜索每本书。如果在有序列表中找到了这本书（`$bookFound
    !== FALSE`），我们将使用PHP的`array_splice()`函数从交付书籍列表中移除该书：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These two lines actually shows two PHP arrays which are used for the list of
    books we have received, `$bookList` and the list of books we have actually ordered
    `$orderedBooks` . We are just using some dummy data to test our implemented code
    as shown:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行实际上显示了两个PHP数组，用于我们收到的书籍列表`$bookList`和我们实际订购的书籍列表`$orderedBooks`。我们只是使用一些虚拟数据来测试我们实现的代码，如下所示：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The last part of our code actually calls the function `placeAllBooks` to perform
    the whole operation of checking each book searching for it in our received books
    and removing it, if it is in the list. So basically, we have implemented our pseudocode
    to an actual PHP code which we can use to solve our problem.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码的最后一部分实际上调用函数`placeAllBooks`来执行整个操作，检查每本书在我们收到的书中的位置并将其移除，如果它在列表中。所以基本上，我们已经将我们的伪代码实现为实际的PHP代码，我们可以用它来解决我们的问题。
- en: Algorithm analysis
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法分析
- en: We have completed our algorithm in the previous section. But one thing we have
    not done yet is the analysis of our algorithm. A valid question in the current
    scenario can be, why do we really need to have an analysis of our algorithm? Though
    we have written the implementation, we are not sure about how many resources our
    written code will utilize. When we say resource, we mean both time and storage
    resource utilized by the running application. We write algorithms to work with
    any length of the input. In order to understand how our algorithm behaves when
    the input grows larger and how many resources have been utilized, we usually measure
    the efficiency of an algorithm by relating the input length to the number of steps
    (time complexity) or storage (space complexity). It is very important to do the
    analysis of algorithms in order to find the most efficient algorithm to solve
    the problem.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节完成了我们的算法。但我们还没有对我们的算法进行分析。在当前情况下一个有效的问题可能是，为什么我们真的需要对我们的算法进行分析？虽然我们已经编写了实现，但我们不确定我们编写的代码将利用多少资源。当我们说资源时，我们指的是运行应用程序所利用的时间和存储资源。我们编写算法来处理任何长度的输入。为了了解当输入增长时我们的算法的行为以及利用了多少资源，我们通常通过将输入长度与步骤数（时间复杂度）或存储空间（空间复杂度）相关联来衡量算法的效率。对于找到解决问题的最有效算法，进行算法分析非常重要。
- en: We can do algorithm analysis in two different stages. One is done before implementation
    and one after the implementation. The analysis we do before implementation is
    also known as *theoretical analysis* and we assume that other factors such as
    processing power and spaces are going to be constant. The after implementation
    analysis is known as *empirical analysis* of an algorithm which can vary from
    platform to platform or from language to language. In empirical analysis, we can
    get solid statistics from the system regarding time and space utilization.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在两个不同的阶段进行算法分析。一个是在实施之前完成的，另一个是在实施之后完成的。我们在实施之前进行的分析也被称为*理论分析*，我们假设其他因素如处理能力和空间将保持不变。实施后的分析被称为算法的*经验分析*，它可以因平台或语言而异。在经验分析中，我们可以从系统中获得关于时间和空间利用的可靠统计数据。
- en: For our algorithm to place the books and finding the books from purchased items,
    we can perform a similar analysis. At this time, we will be more concerned about
    the time complexity rather than the space complexity. We will explore space complexity
    in coming chapters.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的放置书籍和从购买物品中找到书籍的算法，我们可以进行类似的分析。这次，我们将更关注时间复杂度而不是空间复杂度。我们将在接下来的章节中探讨空间复杂度。
- en: Calculating the complexity
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算复杂度
- en: 'There are two types of complexity we measure in algorithmic analysis:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法分析中，我们测量两种复杂度：
- en: '**Time complexity** : Time complexity is measured by the number of key operations
    in the algorithm. In other words, time complexity quantifies the amount of time
    taken by an algorithm from start to finish.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间复杂度**：时间复杂度是算法中关键操作的数量。换句话说，时间复杂度量化了算法从开始到结束所花费的时间量。'
- en: '**Space complexity** : Space complexity defines the amount of space (in memory)
    required by the algorithm in its life cycle. It depends on the choice of data
    structures and platforms.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空间复杂度**：空间复杂度定义了算法在其生命周期中所需的空间（内存）量。它取决于数据结构和平台的选择。'
- en: Now let us focus on our implemented algorithm and find about the operations
    we are doing for the algorithm. In our `placeAllBooks` function, we are searching
    for each of our ordered books. So if we have 10 books, we are doing the search
    10 times. If the number is 1000, we are doing the search 1000 times. So simply,
    we can say if there is *n* number of books, we are going to search it *n* number
    of times. In algorithm analysis, input number is mostly represented by *n* .
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们专注于我们实现的算法，并了解我们为算法执行的操作。在我们的`placeAllBooks`函数中，我们正在搜索我们的每一本订购的书。所以如果我们有10本书，我们会搜索10次。如果数量是1000，我们会搜索1000次。所以简单地说，如果有*n*本书，我们将搜索*n*次。在算法分析中，输入数量通常用*n*表示。
- en: For each item in our ordered books, we are doing a search using the `findABook`
    function. Inside the function, we are again searching through each of the received
    books with a name we received from the `placeAllBooks` function. Now if we are
    lucky enough, we can find the name of the book at the beginning of the list of
    received books. In that case, we do not have to search the remaining items. But
    what if we are very unlucky and the book we are searching for is at the end of
    the list? We then have to search each of the books and, at the end, we find it.
    If the number of received books is also *n* , then we have to run the comparison
    *n* times.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们有序书籍中的每一项，我们都在使用`findABook`函数进行搜索。在函数内部，我们再次搜索从`placeAllBooks`函数接收到的每一本书的名称。现在，如果我们足够幸运，我们可以在接收到的书籍列表的开头找到书的名称。在这种情况下，我们就不必搜索剩下的项目。但是如果我们非常不幸，我们搜索的书在列表的末尾怎么办？那么我们必须搜索每一本书，最后找到它。如果接收到的书籍数量也是*n*，那么我们必须进行*n*次比较。
- en: 'If we assume that other operations are fixed, the only variable should be the
    input size. We can then define a boundary or mathematical equation to define the
    situation to calculate its runtime performance. We call it *asymptotical analysis*
    . Asymptotical analysis is input bound which means if there is no input, other
    factors are constant. We use asymptotical analysis to find out the best case,
    worst case, and average case scenario of algorithms:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设其他操作是固定的，唯一的变量应该是输入大小。然后我们可以定义一个边界或数学方程来定义计算其运行时性能的情况。我们称之为*渐近分析*。渐近分析是输入边界，这意味着如果没有输入，其他因素是恒定的。我们使用渐近分析来找出算法的最佳情况、最坏情况和平均情况：
- en: '**Best case** : Best case indicates the minimum time required to execute the
    program. For our example algorithm, the best case can be that, for each book,
    we are only searching the first item. So, we end up searching for a very little
    amount of time. We use **Ω** notation (Sigma notation) to indicate the best case
    scenario.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最佳情况**：最佳情况表示执行程序所需的最短时间。对于我们的示例算法，最佳情况可能是，对于每本书，我们只搜索第一项。因此，我们最终搜索的时间非常短。我们使用**Ω**符号（Σ符号）来表示最佳情况。'
- en: '**Average case** : It indicates the average time required to execute a program.
    For our algorithm the average case will be finding the books around the middle
    of the list most of the time, or half of the time they are at the beginning of
    the list and the remaining half are at the end of the list.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平均情况**：它表示执行程序所需的平均时间。对于我们的算法，平均情况将是大部分时间在列表中间找到书，或者一半时间在列表开头，剩下一半在列表末尾。'
- en: '**Worst case** : It indicates the maximum running time for a program. The worst
    case example will be finding the books at the end of the list all the time. We
    use the **O** (big oh) notation to describe the worst case scenario. For each
    book searching in our algorithm, it can take **O(n)** running time. From now on,
    we will use this notation to express the complexity of our algorithm.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最坏情况**：它表示程序的最大运行时间。最坏情况的例子将是一直在列表末尾找书。我们使用**O**（大O）符号来描述最坏情况。对于我们的算法中的每本书搜索，它可能需要**O(n)**的运行时间。从现在开始，我们将使用这个符号来表示我们算法的复杂性。'
- en: Understanding the big O (big oh) notation
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解大O（大O）符号
- en: The big O notation is very important for the analysis of algorithms. We need
    to have a solid understanding of this notation and how to use this in the future.
    We are going to discuss the big O notation throughout this section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '大O符号对于算法分析非常重要。我们需要对这个符号有扎实的理解，并且知道如何在将来使用它。我们将在本节中讨论大O符号。 '
- en: 'Our algorithm for finding the books and placing them has *n* number of items.
    For the first book search, it will compare *n* number of books for the worst case
    situation. If we say time complexity is *T* , then for the first book the time
    complexity will be:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于查找书籍并放置它们的算法有*n*个项目。对于第一本书的搜索，它将在最坏情况下比较*n*本书。如果我们说时间复杂度是*T*，那么对于第一本书，时间复杂度将是：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we are removing the founded book from the list, the size of the list is
    now *n-1* . For the second book search, it will compare *n-1* number of books
    for the worst case situation. Then for the second book, the time complexity will
    be *n-1* . Combining the both time complexities, for first two books it will be:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从列表中删除找到的书时，列表的大小现在是*n-1*。对于第二本书的搜索，它将在最坏情况下比较*n-1*本书。然后对于第二本书，时间复杂度将是*n-1*。结合这两个时间复杂度，对于前两本书，它将是：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we continue like this, after the *n-1* steps the last book search will only
    have *1* book left to compare. So, the total complexity will look like:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像这样继续下去，经过*n-1*步后，最后一本书的搜索将只剩下*1*本书需要比较。因此，总复杂度看起来像：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now if we look at the preceding series, doesn''t it look familiar? It is also
    known as the **sum of n numbers** equation as shown:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们看一下前面的系列，它不是很熟悉吗？它也被称为**n个数字的和**方程，如下所示：
- en: '![](Image00016.gif)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00016.gif)'
- en: 'So we can write:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们可以写成：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For asymptotic analysis, we ignore low order terms and constant multipliers.
    Since we have *n2* , we can easily ignore the *n* here. Also, the 1/2 constant
    multiplier can also be ignored. Now we can express the time complexity with the
    big O notation as the order of *n* squared:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于渐近分析，我们忽略低阶项和常数乘数。由于我们有*n2*，我们可以轻松地忽略这里的*n*。此外，1/2的常数乘数也可以被忽略。现在我们可以用大O符号表示时间复杂度为*n*的平方：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Throughout the book, we will be using this big **O** notation to describe complexity
    of the algorithms or operations. Here are some common big **O** notations:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用这个大**O**符号来描述算法或操作的复杂性。以下是一些常见的大**O**符号：
- en: '| **Type** | **Notation** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '**类型** | **符号** |'
- en: '| Constant | **O (1)** |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 常数 | **O (1)** |'
- en: '| Linear | **O (n)** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: 线性 | **O (n)** |
- en: '| Logarithmic | **O (log n)** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: 对数 | **O (log n)** |
- en: '| n log n | **O (n log n)** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| n log n | **O (n log n)** |'
- en: '| Quadratic | **O (n² )** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: 二次 | **O (n² )** |
- en: '| Cubic | **O (n³ )** |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: 立方 | **O (n³ )** |
- en: '| Exponential | **O (2^n )** |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: 指数 | **O (2^n )** |
- en: Standard PHP Library (SPL) and data structures
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准PHP库（SPL）和数据结构
- en: The **Standard PHP Library** (**SPL** ), is one of the best possible features
    of the PHP language in last few years. SPL was created to solve common problems
    which were lacking in PHP. SPL extended the language in many ways but one of the
    striking features of SPL is its support of data structures. Though SPL is used
    for many other purposes, we are going to focus on the data structure part of SPL.
    SPL comes with core PHP installations and does not require any extension or change
    in configurations to enable it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**标准PHP库**（**SPL**）是PHP语言近年来可能的最佳功能之一。SPL被创建用来解决PHP中缺乏的常见问题。SPL在许多方面扩展了语言，但SPL引人注目的特点之一是它对数据结构的支持。虽然SPL用于许多其他目的，但我们将专注于SPL的数据结构部分。SPL随着核心PHP安装而提供，并不需要任何扩展或更改配置来启用它。'
- en: 'SPL provides a set of standard data structures through Object-Oriented Programming
    in PHP. The supported data structures are:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: SPL通过PHP中的面向对象编程提供了一组标准数据结构。支持的数据结构有：
- en: '**Doubly linked lists** : It is implemented in `SplDoublyLinkedList` .'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向链表**：它是在`SplDoublyLinkedList`中实现的。'
- en: '**Stack** : It is implemented in `SplStack` by using `SplDoublyLinkedList`
    .'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栈**：它是通过使用`SplDoublyLinkedList`在`SplStack`中实现的。'
- en: '**Queue** : It is implemented in `SplQueue` by using `SplDoublyLinkedList`
    .'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列**：它是通过使用`SplDoublyLinkedList`在`SplQueue`中实现的。'
- en: '**Heaps** : It is implemented in `SplHeap` . It also supports max heap in `SplMaxHeap`
    and min heap in `SplMinHeap` .'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆**：它是在`SplHeap`中实现的。它还支持`SplMaxHeap`中的最大堆和`SplMinHeap`中的最小堆。'
- en: '**Priority queue** : It is implemented in `SplPriorityQueue` by using `SplHeap`
    .'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先队列**：它是通过使用`SplHeap`在`SplPriorityQueue`中实现的。'
- en: '**Arrays** : It is implemented in `SplFixedArray` for a fixed size array.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组**：它是在`SplFixedArray`中实现的，用于固定大小的数组。'
- en: '**Map** : It is implemented in `SplObjectStorage` .'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**：它是在`SplObjectStorage`中实现的。'
- en: In coming chapters, we are going to explore each of the SPL data structure implementations
    and know their pros and cons, along with their performance analysis with our implementation
    of corresponding data structures. But as these data structures are already built
    in, we can use them for a quick turnaround of features and applications.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探索SPL数据结构的每个实现，并了解它们的优缺点，以及与我们相应数据结构的实现的性能分析。但由于这些数据结构已经内置，我们可以用它们来快速实现功能和应用程序。
- en: After the release of PHP 7, everyone was happy with the performance boost of
    the PHP application in general. PHP SPL is not having the similar performance
    boost in many cases, but we are going to analyze those in upcoming chapters.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7发布后，人们对PHP应用程序的性能提升感到高兴。在许多情况下，PHP SPL并没有类似的性能提升，但我们将在即将到来的章节中对其进行分析。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have focused our discussion on basic data structures and
    their names. We have also learned about solving problems with defined steps, known
    as algorithms. We have also learned about analyzing the algorithms and the big
    **O** notation along with how to calculate the complexity. We had a simple brief
    about the built-in data structures in PHP in the form of SPL.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于基本数据结构及其名称的讨论。我们还学习了解决问题的定义步骤，即算法。我们还学习了分析算法和大**O**符号，以及如何计算复杂性。我们简要介绍了PHP中内置数据结构的SPL形式。
- en: In the next chapter, we are going to focus on the PHP array, one of the most
    powerful, flexible data types in PHP. We are going to explore different uses of
    the PHP array to implement different data structures such as hash table, map,
    structs, and so on.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于PHP数组，这是PHP中最强大、灵活的数据类型之一。我们将探索PHP数组的不同用途，以实现不同的数据结构，如哈希表、映射、结构等。
