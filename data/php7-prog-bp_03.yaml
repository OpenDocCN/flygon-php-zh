- en: Chapter 3.  Building a Social Newsletter Service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。构建社交通讯服务
- en: According to a reliable dictionary, a newsletter is a bulletin issued periodically
    to the members of a society, business, or organization.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 根据可靠的词典，通讯是定期发布给社会、企业或组织成员的公告。
- en: In this chapter, we will be building an e-mail newsletter, that allows members
    to subscribe and unsubscribe, receive updates on certain categories, and also
    allows a marketer to check how many people visited a certain link.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个电子邮件通讯，允许会员订阅和取消订阅，接收特定类别的更新，并允许营销人员检查有多少人访问了某个链接。
- en: We'll be building an authentication system for our users to log in and log out
    of the newsletter management system, which is a social login system for subscribed
    members to easily check their subscriptions, and simple dashboards for subscribers
    and administrators.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为用户构建一个身份验证系统，以便登录和退出通讯管理系统，这是一个社交登录系统，供订阅会员轻松检查其订阅以及为订阅者和管理员提供简单的仪表板。
- en: Authentication system
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证系统
- en: In this chapter, we will implement a new authentication system in order to allow
    administrators of the newsletter to be authenticated. Since PHP5, PHP has improved
    and added a feature that object-oriented developers have used to separate namespaces.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现一个新的身份验证系统，以允许通讯通讯的管理员进行身份验证。自PHP5以来，PHP已经改进并添加了一个功能，面向对象的开发人员已经用来分隔命名空间。
- en: 'Let''s start by defining a namespace named `Newsletter` as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义一个名为`Newsletter`的命名空间，如下所示：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding example, our `Newsletter` namespace will have an `Authentication` class.
    When other classes or PHP scripts need to use `Newsletter`''s `Authentication`
    class, they can simple declare it using the following code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们的`Newsletter`命名空间将有一个`Authentication`类。当其他类或PHP脚本需要使用`Newsletter`的`Authentication`类时，他们可以简单地使用以下代码声明它：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inside our `Newsletter` class, let's create a simple check for the user using  **bcrypt**,
    which is a popular and secure way of creating and storing hashed passwords.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Newsletter`类中，让我们使用**bcrypt**创建一个简单的用户检查，这是一种流行且安全的创建和存储散列密码的方法。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since PHP 5.5, bcrypt is built into the `password_hash()` PHP function. PHP's
    `password_hash()` function allows a password to become a hash. In reverse, when
    you need to verify that hash matches the original password, you can use the `password_verify()`
    function.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 自PHP 5.5以来，bcrypt已内置到`password_hash()` PHP函数中。PHP的`password_hash()`函数允许密码成为散列。相反，当您需要验证散列是否与原始密码匹配时，可以使用`password_verify()`函数。
- en: 'Our class will be fairly simple-it will have one function used to verify if
    an e-mail address, and the hashed password that was entered is the same as the
    one in the database. We have to create a simple class that has only one method,
    `verify()`, which accepts the e-mail and the password of the user. We will use
    `bcrypt` to verify that the hashed password is the same as the one in our database:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类将非常简单-它将有一个用于验证输入的电子邮件地址和散列密码是否与数据库中的相同的函数。我们必须创建一个只有一个方法`verify()`的简单类，该方法接受用户的电子邮件和密码。我们将使用`bcrypt`来验证散列密码是否与我们数据库中的相同：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We, however, need to get the `DB` class to be able to do a simple query with
    our database. For this simple one-off project, we can simply use the concept of
    dependency injection in our `Authentication` class.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要让`DB`类能够在我们的数据库中执行简单的查询。对于这个简单的一次性项目，我们可以在我们的`Authentication`类中简单使用依赖注入的概念。
- en: We should create a fairly trivial IOC container class, which allows us to instantiate
    the database along with it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该创建一个相当简单的IOC容器类，它允许我们实例化数据库。
- en: 'Let''s call it `DbContainer`, which allows us to connect a class, such as `Authentication`,
    to the `DB` class:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称之为`DbContainer`，它允许我们将类（例如`Authentication`）连接到`DB`类：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, if you use this function right away, an error will state that the file
    could not find and will load the `DB` class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您立即使用此函数，将会出现一个错误，指出找不到文件并将加载`DB`类。
- en: Previously, we used the `use` system of requiring classes. In order for this
    to work, we need to create an autoloader function to load our `DB` class without
    having to use `require` statements.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们使用了`use`系统来要求类。为了使其工作，我们需要创建一个自动加载程序函数来加载我们的`DB`类，而无需使用`require`语句。
- en: In PHP, there is the `spl_autoload_register` function we can create, which will
    take care of requiring the files needed automatically.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，我们可以创建`spl_autoload_register`函数，它将自动处理所需的文件。
- en: 'Following is the example implementation based on the example that can be found
    in the PHP manual:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于PHP手册中的示例的示例实现：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With the preceding code, we would now need to create a `src` directory and use
    this separator `\\` convention in separating the folder structure within your
    application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述代码，我们现在需要创建一个`src`目录，并在应用程序中使用此分隔符`\\`约定来分隔文件夹结构。
- en: Using this example means we'll need to put the database class file `DB.class.php`
    inside the `src` folder and rename the filename to just `DB.php`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此示例意味着我们需要将数据库类文件`DB.class.php`放在`src`文件夹中，并将文件名重命名为`DB.php`。
- en: This was done so that when you specify that you want to use `DB` class in another
    PHP script, PHP will simply perform a `require src/DB.php` behind the scenes automatically.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了当您在另一个PHP脚本中指定要使用`DB`类时，PHP将在后台自动执行`require src/DB.php`。
- en: Continuing with our example `DbContainer`, we'll need to somehow pass all our
    configuration information (that is, name of the database, username, and password
    to the MySQL database) inside the `DbContainer`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用我们的示例`DbContainer`，我们需要以某种方式将所有配置信息（即数据库名称、用户名和密码）传递到`DbContainer`中。
- en: 'Let''s simply create a file `dbconfig.php` that has the database details and
    returns it as an object, and require it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简单地创建一个名为`dbconfig.php`的文件，其中包含数据库详细信息并将其作为对象返回，并要求它：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In our `DbContainer` class, let''s create a `loadConfig()` function that reads
    from the `dbconfig.php` file and instantiates a database connection:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`DbContainer`类中，让我们创建一个`loadConfig()`函数，从`dbconfig.php`文件中读取，并实例化一个数据库连接：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we need to create a `connect()` method, which will enable us to simply
    connect to a MySQL database and only return the connection:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个`connect()`方法，这将使我们能够简单地连接到MySQL数据库并仅返回连接：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We made our function flexible by not hard-coding the filename into our function.
    When calling `loadConfig()`, we need to put the path to the `config` file to load.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不将文件名硬编码到我们的函数中，我们使我们的函数更加灵活。在调用`loadConfig()`时，我们需要将`config`文件的路径放入。
- en: We also use the `$this` keyword so that any time we need to refer to other functions
    within the `DB` class, we just have to call `$DB->nameOfMethod(someParams)` after
    the autoloader loads and instantiates the `DB` class automatically when you call
    `$DB = new \DB()`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`$this`关键字，这样每当我们需要引用`DB`类中的其他函数时，我们只需在自动加载程序加载并实例化`DB`类后调用`$DB->nameOfMethod(someParams)`。
- en: With this, we now have the flexibility to easily change the `config` file's
    path in case we move the `config` file to other paths, for example, to a folder
    that is not directly accessible through the Web.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以轻松地更改`config`文件的路径，以防我们将`config`文件移动到其他路径，例如，到一个通过Web直接访问的文件夹。
- en: Then, we can easily use this function and generate a database instance in a
    separate class, for example, in our `Newsletter` class, we can now make a reference
    to an instance of the `DB` class connection and instantiate it within the `Newsletter`
    class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以轻松地使用这个函数，并在一个单独的类中生成一个数据库实例，例如，在我们的`Newsletter`类中，我们现在可以引用`DB`类连接的一个实例，并在`Newsletter`类中实例化它。
- en: 'Now that we''re done with this, we should simply create a Bootstrap file that
    loads the `spl_autoload_register` function and the connection to the database
    using the `dbContainer` all together. Let''s name the file `bootstrap.php`, and
    it should contain the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了这一步，我们应该简单地创建一个Bootstrap文件，加载`spl_autoload_register`函数和使用`dbContainer`连接到数据库。让我们将文件命名为`bootstrap.php`，它应该包含以下内容：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next step is to connect to the database with the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用以下代码连接到数据库：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After we've all connected to the database, we need to rewrite our authorization
    query to use the new initialized classes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们都连接到数据库之后，我们需要重写我们的授权查询，以使用新初始化的类。
- en: 'Let''s create a simple `select_where` method in our `DB` class and then call
    it from the `Authorization` class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`DB`类中创建一个简单的`select_where`方法，然后从`Authorization`类中调用它：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `Authorization` class now looks as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Authorization`类现在如下所示：'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating a social login for members
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为会员创建社交登录
- en: For us to have more people subscribing easily, we will implement a way for Facebook
    users to simply log in and subscribe to our newsletter without having to type
    their e-mail address.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让更多人轻松订阅，我们将实现一种方式，让Facebook用户可以简单地登录并订阅我们的通讯，而无需输入他们的电子邮件地址。
- en: Login via Facebook works through  **Oauth**. The first step is to generate app
    authentication tokens by going to [https://developers.facebook.com/](https://developers.facebook.com/)
    .
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**Oauth**登录Facebook通过生成应用程序认证令牌开始。第一步是转到[https://developers.facebook.com/](https://developers.facebook.com/)。
- en: 'You should see your list of apps or click on the apps to create. You should
    see something similar to the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到您的应用程序列表，或者点击应用程序进行创建。您应该看到类似以下截图的内容：
- en: '![Creating a social login for members](graphics/image_03_001.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![为会员创建社交登录](graphics/image_03_001.jpg)'
- en: 'You should create an app first and be able to obtain your app ID and app secret
    by visiting the app creation page, similar to the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该首先创建一个应用程序，并且可以通过访问应用程序创建页面来获取您的应用程序ID和应用程序密钥，类似于以下截图：
- en: '![Creating a social login for members](graphics/image_03_002.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![为会员创建社交登录](graphics/image_03_002.jpg)'
- en: When creating the new app, Facebook now includes a way for you to test that
    app ID.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新应用程序时，Facebook现在包括了一种测试应用程序ID的方法。
- en: 'This is what it looks like:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样：
- en: '![Creating a social login for members](graphics/image_03_003.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![为会员创建社交登录](graphics/image_03_003.jpg)'
- en: This is for you to test that the app ID actually works. It is optional and you
    may skip that step and just plug in the values for your app ID and app secret
    into the code shown in the preceding screenshot.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了测试应用程序ID是否有效。这是可选的，您可以跳过这一步，只需将应用程序ID和应用程序密钥的值插入到前面截图中显示的代码中。
- en: Now let's create the `fbconfig.php` file, which will contain a way for us to
    use the Facebook SDK library to enable the session.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建`fbconfig.php`文件，其中将包含一种使用Facebook SDK库启用会话的方法。
- en: 'The `fbconfig.php` script will contain the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`fbconfig.php`脚本将包含以下内容：'
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we basically start a session with `session_start()` and set up the domain
    of our website by saving it into a variable. We then autoload the FB SDK, which
    will require the files and classes needed by Facebook to access its API for logging
    in.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们基本上通过`session_start()`开始一个会话，并通过将其保存到一个变量中设置我们网站的域。然后自动加载FB SDK，这将需要Facebook访问其API所需的文件和类来访问。
- en: We then set up several dependencies on other Facebook SDK classes by using the
    `use` keyword. We set up the `facebookSession` class with our app ID and app secret
    and then attempt to get a session started by calling the `getSessionfromRedirect()`method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`use`关键字在其他Facebook SDK类上设置了几个依赖项。我们使用我们的应用程序ID和应用程序密钥设置了`facebookSession`类，然后尝试通过调用`getSessionfromRedirect()`方法启动会话。
- en: If there are any errors that get caught from trying to start the session, we
    simply let the user know that we could not log him in, but if everything proceeds
    successfully, we start a graph object with the e-mail of the user.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何错误被捕获尝试启动会话，我们只需让用户知道我们无法登录他，但如果一切顺利进行，我们将以用户的电子邮件开始一个图形对象。
- en: For our demonstration purposes, we save a username that is actually the e-mail
    address of the user once we get the e-mail by using the Facebook graph.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们保存一个用户名，实际上是用户的电子邮件地址，一旦我们通过Facebook图表获取了电子邮件。
- en: We will authenticate everyone by checking their e-mail addresses anyway, and
    to make it easier for a user to login, let's just store their e-mail as the username.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们将通过检查他们的电子邮件地址对每个人进行身份验证，并且为了让用户更容易登录，让我们只将他们的电子邮件存储为用户名。
- en: We'll need to finish up our site with `index.php` that shows the user what's
    inside our site. We get there after the login from Facebook page redirects the
    user to the `index.php` page.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用`index.php`完成我们的网站，向用户展示我们网站内部的内容。我们在从Facebook页面登录后，将用户重定向到`index.php`页面。
- en: 'We''ll keep it simple for now and display the full name from the Facebook profile
    of the user who logged in. We''ll add a logout link to give the user an option
    to logout:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将保持简单，并从登录的用户的Facebook个人资料中显示全名。我们将添加一个注销链接，以便用户有注销的选项：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After logging in, we just have to display the dashboard for the user. We will
    discuss how to create a basic dashboard for the user in the next section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，我们只需为用户显示仪表板。我们将在下一节讨论如何为用户创建基本仪表板。
- en: Member dashboard
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会员仪表板
- en: 'Finally, when the member has logged in our app, they can now subscribe to newsletters
    using the member subscription page. Let''s first build out the databases that
    will be used to store member details and their subscriptions. The `member_details`
    table will include the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当会员登录我们的应用程序时，他们现在可以使用会员订阅页面订阅通讯。让我们首先构建用于存储会员详细信息和他们订阅的数据库。`member_details`表将包括以下内容：
- en: '`firstname` and `lastname`: The real name of the user'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firstname`和`lastname`：用户的真实姓名'
- en: '`email`: To be able to e-mail the user'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`：能够给用户发送电子邮件'
- en: '`canNotify`: Boolean (true or false), if they accept being e-mailed notifications
    about other offers'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canNotify`：布尔值（true或false），如果他们同意通过电子邮件接收有关其他优惠的通知'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Here's something that's interesting about the boolean type in MySQL. When you
    create a field that uses boolean (true or false), MySQL actually just aliases
    it to `TINYINT(1)`. Boolean is basically 0 for false and 1 for true. For more
    info, refer to [http://dev.mysql.com/doc/refman/5.7/en/numeric-type-overview.html](http://dev.mysql.com/doc/refman/5.7/en/numeric-type-overview.html)
    .
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于MySQL中的布尔类型有趣的是，当您创建使用布尔值（true或false）的字段时，MySQL实际上只将其别名为`TINYINT(1)`。布尔基本上是0表示false，1表示true。有关更多信息，请参阅[http://dev.mysql.com/doc/refman/5.7/en/numeric-type-overview.html](http://dev.mysql.com/doc/refman/5.7/en/numeric-type-overview.html)。
- en: 'The `member_details` table will handle this and it will be created using the
    following SQL code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`member_details`表将处理此事，并将使用以下SQL代码创建：'
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When logging in, our members will be stored in the `users` table. Let''s create
    that with the following SQL code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 登录时，我们的会员将存储在`users`表中。让我们使用以下SQL代码创建它：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, build the view that shows our members all the different subscriptions
    we have. We do this by checking the table `subscriptions`. The `subscriptions`
    table schema is defined as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建一个视图，向我们的会员展示我们拥有的所有不同订阅。我们通过检查`subscriptions`表来实现这一点。`subscriptions`表模式定义如下：
- en: '``id` Int(11)`: This is the primary key for the `subscriptions` table and is
    set with `AUTO_INCREMENT`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id Int(11)`：这是`subscriptions`表的主键，并设置为`AUTO_INCREMENT`'
- en: '`newsletter_id Int(11)`: This is the `newsletter_id` that they are subscribed
    to'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newsletter_id Int(11)`：这是他们订阅的`newsletter_id`'
- en: '`active BOOLEAN`: This indicates whether the user is currently subscribed (default
    1)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active BOOLEAN`：这表示用户当前是否订阅（默认为1）'
- en: 'Using SQL, it will look like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQL，它将如下所示：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We will also have to create the `newsletters` table, which will hold all the
    newsletters, their template, and their content in JSON format. By using JSON as
    a storage format in our database, it should now make it simple to fetch data from
    the database and parse JSON into the proper values to insert into our template.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建`newsletters`表，其中将以JSON格式保存所有通讯、它们的模板和内容。通过在我们的数据库中使用JSON作为存储格式，现在应该很容易从数据库中获取数据并将JSON解析为适当的值插入到我们的模板中。
- en: 'Since our newsletters will be stored in the database, we need to create the
    proper SQL schema for it. This is how it will be designed:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的通讯将存储在数据库中，我们需要为其创建适当的SQL模式。设计如下：
- en: '`Id INT(11)`: To index our newsletters in the database'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id INT(11)`：在数据库中索引我们的通讯'
- en: '`newsletter_name (Text)`: The title of our newsletter'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newsletter_name（文本）`：我们通讯的标题'
- en: '`newsletter_count INT(11)`: To record the edition of our particular newsletter'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newsletter_count INT(11)`：记录我们特定通讯的版本'
- en: '`Status (String)`: To record the status of our newsletter, if it''s been published,
    unpublished, or pending publication'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Status（字符串）`：记录我们的通讯的状态，是否已发布、未发布或待发布'
- en: '`Slug (String)`: To be able to view the newsletter with the browser on our
    social newsletter''s website'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slug（字符串）`：能够在我们的社交通讯网站上使用浏览器查看通讯'
- en: '`Template (Text)`: To store the HTML template'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Template（文本）`：存储HTML模板'
- en: '`Content (Text)`: To store the data that will go into our HTML template'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content（文本）`：存储将进入我们的HTML模板的数据'
- en: '`Published_at (Date)`: To record the date of publication'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布日期（日期）：记录发布日期
- en: '`Created_at (Date)`: To record the time that the newsletter was first created'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Created_at（日期）`：记录通讯首次创建的时间'
- en: '`Updated_at (Date)`: To record when the last time that someone updated the
    newsletter'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Updated_at（日期）`：记录上次有人更新通讯的时间'
- en: 'The SQL for this is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 其SQL如下：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When user unsubscribes, this will help indicate that they were previously subscribed
    to this newsletter. This is why we'll store an `active` field so that when they
    unsubscribe, instead of deleting the record, we just set this to 0.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户取消订阅时，这将帮助指示他们先前订阅了此通讯。这就是为什么我们将存储一个`active`字段，以便当他们取消订阅时，而不是删除记录，我们只需将其设置为0。
- en: The `marketer_id` is going to be used in the future admin portion where we mention
    the person who will be in charge of the management of the newsletter subscriptions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`marketer_id`将在未来的管理部分中使用，其中我们提到将负责管理新闻通讯订阅的人员。'
- en: 'Newsletters may also have many publications, which will be the actual newsletters
    that get sent to each subscription. The following SQL code is to create publications:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 新闻通讯也可能有许多出版物，这些出版物将是实际发送给每个订阅的新闻通讯。以下SQL代码是用来创建出版物的：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now let''s build the methods in our `Newsletter` class to select logged-in
    members subscriptions for displaying into our dashboard:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在我们的`Newsletter`类中构建方法，以选择已登录会员的订阅以显示到我们的仪表板：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'From the preceding code, we simply created a function that would get the subscriptions
    for a given member ID. First, we create the `"SELECT * FROM subscriptions, newsletters
    WHERE subscriptions.member_id =''". $member_id."` query. After this, we loop through
    the query results using the `fetch_assoc()` method of the MySQLi result object.
    Now that we''ve stored it in the `$data` variable, we return the variable, and
    in the following code, we display the data in a table by invoking the following
    function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中，我们只是创建了一个函数，用于获取给定会员ID的订阅。首先，我们创建了`"SELECT * FROM subscriptions, newsletters
    WHERE subscriptions.member_id ='". $member_id."`查询。之后，我们使用MySQLi结果对象的`fetch_assoc()`方法循环遍历查询结果。现在我们已经将其存储在`$data`变量中，我们返回该变量，并在以下代码中通过调用以下函数在表中显示数据：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Marketers dashboard
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 营销人员仪表盘
- en: Our marketers, who administer each newsletter that they own, will be able log
    in to our system and be able to see how many members are subscribed and their
    e-mail addresses.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的营销人员，他们管理自己拥有的每个新闻通讯，将能够登录到我们的系统，并能够看到有多少会员订阅了他们的电子邮件地址。
- en: It is going to be an admin system that enables a marketer to update a member's
    record, view recent subscriptions, and allow a marketer to send custom e-mails
    to any member of their newsletter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个管理员系统，使营销人员能够更新会员记录，查看最近的订阅，并允许营销人员向其新闻通讯的任何会员发送自定义电子邮件。
- en: 'We''ll have a table called `marketers`, which will have the following fields:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个名为`marketers`的表，其中将包含以下字段：
- en: '`id`: To store the index'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：用于存储索引'
- en: 'Marketer''s name: To store the name of the marketer'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 营销人员的姓名：用于存储营销人员的姓名
- en: 'Marketer''s e-mail: To store the e-mail address of the marketer'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 营销人员的电子邮件：用于存储营销人员的电子邮件地址
- en: 'Marketer''s password: To store the marketer''s login password'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 营销人员的密码：用于存储营销人员的登录密码
- en: 'Our SQL for creating the preceding fields is simple:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于创建上述字段的SQL很简单：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In another table, we'll define the many-to-many relationship of marketers and
    their newsletters that they manage.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个表中，我们将定义营销人员及其管理的新闻通讯的多对多关系。
- en: We'll need an `id` to be the index, the ID of the marketer who owns the newsletter,
    and the newsletter's ID, which is owned by the marketer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`id`作为索引，拥有新闻通讯的营销人员的ID，以及营销人员拥有的新闻通讯的ID。
- en: 'The SQL to create this table is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此表的SQL如下：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now let''s build a query for fetching the admins of a newsletter that they
    own. This is going to be a simple class where we will reference all our database
    functions:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建一个查询，以获取他们拥有的新闻通讯的管理员。这将是一个简单的类，我们将引用所有我们的数据库函数：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Administration system for managing marketers
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理营销人员的管理系统
- en: We need a way for the marketers to log in and be authenticated with a password.
    We need a way for an admin to create the account and register a marketer and their
    newsletter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法让营销人员登录并通过密码进行身份验证。我们需要一种方法让管理员创建帐户并注册营销人员及其新闻通讯。
- en: Let's build that part first.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先构建这部分。
- en: In our admin view, we'll need to set a default and ask for an authenticated
    password for every action that is performed. This is something we don't need to
    store in the database since there will be only one administrator.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的管理视图中，我们将需要设置一个默认值，并要求对执行的每个操作进行身份验证密码。这是我们不需要存储在数据库中的东西，因为只会有一个管理员。
- en: 'In our `config`/`admin.php` file, we will define the username and the password
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`config`/`admin.php`文件中，我们将定义用户名和密码如下：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We then just include the file in our login page, `login.php`.We will simply
    check for it. The code for the login page is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们只需在我们的登录页面`login.php`中包含文件。我们将简单地检查它。登录页面的代码如下：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Notice that we have to set our website URL correctly, depending on where we''re
    developing it. In the preceding example, the page will redirect to [http://ourwebsite.com/admin/welcome_dashboard.php](http://ourwebsite.com/admin/welcome_dashboard.php)
    after logging in. We can create variables to store the domain and the URL fragment
    to redirect to so that this can be dynamic; see the following example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须根据我们正在开发的位置正确设置我们的网站URL。在上面的示例中，页面将在登录后重定向到[http://ourwebsite.com/admin/welcome_dashboard.php](http://ourwebsite.com/admin/welcome_dashboard.php)。我们可以创建变量来存储域和要重定向到的URL片段，以便这可以是动态的；请参阅以下示例：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once logged in, we'll need to build a simple CRUD (Create, Read, Update, Delete)
    system to manage the marketers who will be administering their newsletters.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦登录，我们将需要构建一个简单的CRUD（创建、读取、更新、删除）系统来管理将管理他们的新闻通讯的营销人员。
- en: 'The following is the code to be able to get the list of marketers and the newsletters
    they manage:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是能够获取营销人员和他们管理的新闻通讯列表的代码：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We'll need to add a way to edit, create, and delete marketers. Let's create
    a `dashboard`/`table_header.php` to include at the top of our script.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一种方法来编辑、创建和删除营销人员。让我们创建一个`dashboard`/`table_header.php`来包含在我们脚本的顶部。
- en: 'The following is what the `table_header.php` code looks like:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`table_header.php`代码的样子：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will now create a `for()` loop to loop through each of the marketer. Let''s
    create a way to select through all the marketers in our database. First, let''s
    call our function to get data:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个`for()`循环来循环遍历每个营销人员。让我们创建一种方法来选择我们数据库中的所有营销人员。首先，让我们调用我们的函数来获取数据：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then let''s use a `foreach()` loop to loop through all the marketers:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们使用`foreach()`循环来循环遍历所有营销人员：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then we end the code with a closing element for the table with `</table>`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们用`</table>`为表结束代码。
- en: 'Let''s create the `delete_marketer.php` script and the `edit_marketer.php`
    scripts. The following will be the delete script:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`delete_marketer.php`脚本和`edit_marketer.php`脚本。以下将是删除脚本：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is the edit script composed of a form that will update the data once submitted:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由一个表单组成的编辑脚本，一旦提交将更新数据：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Custom template for our newsletter
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的通讯的自定义模板
- en: 'Every marketer needs to lay out their newsletter. In our case, we can allow
    them to create a simple sidebar newsletter and a simple top-down newsletter. To
    build a simple sidebar, we can create an HTML template that looks like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个营销人员都需要制定他们的通讯。在我们的情况下，我们可以允许他们创建一个简单的侧边栏通讯和一个简单的自上而下的通讯。为了构建一个简单的侧边栏，我们可以创建一个HTML模板，看起来像下面这样：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, we style the HTML e-mail using in-line tags simply because
    some e-mail clients do not render stylesheets referenced from outside our HTML.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们使用内联标签样式化HTML电子邮件，因为一些电子邮件客户端不会渲染从我们HTML外部引用的样式表。
- en: We can use **regex** to substitute the `{{MENU}}` and `{{CONTENT}}` patterns
    with the data to populate them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**正则表达式**来替换`{{MENU}}`和`{{CONTENT}}`模式，以填充数据。
- en: Our database will store the content as JSON, and once we parse the JSON, we'll
    have the content and menu data to insert into their respective places.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库将以JSON格式存储内容，一旦解析JSON，我们将得到内容和菜单数据，然后插入到它们各自的位置。
- en: 'In our database, we need to add the `newsletter_templates` table. Here is how
    we will create it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据库中，我们需要添加`newsletter_templates`表。以下是我们将如何创建它：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With the template in place, we need a way for marketers to update the template.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有了模板之后，我们需要一种方法让营销人员更新模板。
- en: From the dashboard, we display a list of templates for the newsletter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从仪表板上，我们显示通讯的模板列表。
- en: 'Let''s create the form as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式创建表单：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We also populated the `textarea` by adding values to it. Note that in the preceding
    code, we needed to clean the HTML code for the template using `htmlentities` first.
    This is because our HTML might be interpreted as part of the web page and cause
    problems when rendered by a browser.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过向`textarea`添加值来填充它。请注意，在之前的代码中，我们需要首先使用`htmlentities`清理模板的HTML代码。这是因为我们的HTML可能被解释为网页的一部分，并在浏览器渲染时引起问题。
- en: We now have everything in place in order for our newsletter to send an actual
    newsletter. To do the sending, we'll need to create a script that will loop through
    all the members in a newsletter and then simply use the PHP mail function to send
    them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好发送实际的通讯了。为了发送通讯，我们需要创建一个脚本，循环遍历通讯中的所有成员，然后简单地使用PHP邮件功能发送给他们。
- en: Using the PHP mail function, we just have to loop through all the newsletter
    members in our database.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PHP邮件功能，我们只需要循环遍历我们数据库中的所有通讯成员。
- en: 'This is what that script looks like:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是那个脚本的样子：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We need to complete the `replace_menu` and `replace_contents` functions. Let''s
    simply build the text replace function that will replace the content we have already
    fetched in the preceding code. The data comes from the newsletter table in the
    database:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要完成`replace_menu`和`replace_contents`函数。让我们简单地构建文本替换函数，用于替换我们在之前的代码中已经获取的内容。数据来自数据库中的通讯表：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note that we modified our table to have a menu in the newsletter. This menu
    must be created by the user and with HTML markup. It will basically be an HTML
    list of links. The proper markup for the menu should be like the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们修改了我们的表，为通讯中添加了菜单。这个菜单必须由用户创建，并使用HTML标记。它基本上是一个HTML链接列表。菜单的正确标记应该如下所示：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Link tracking
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接跟踪
- en: For our link tracking system, we will need to allow a marketer to embed links,
    which actually pass through our system for us to keep track of the number of clicks
    on the link.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的链接跟踪系统，我们需要允许营销人员嵌入链接，实际上通过我们的系统传递，以便我们跟踪链接的点击次数。
- en: What we will do is actually create a service that will automatically shorten
    the links we enter to a random hash. The URL will look like `http://example.com/link/xyz123`,
    and the hash  `xyz123` will be stored in our database. When a user accesses the
    link, we'll match the link.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个服务，自动将我们输入的链接缩短为随机哈希。URL看起来像`http://example.com/link/xyz123`，哈希`xyz123`将存储在我们的数据库中。当用户访问链接时，我们将匹配链接。
- en: Let's create the links table and create a function that will help us generate
    the shortened links. At the bare minimum, we need to be able to store the title
    of the link, the actual link, the shortened link, as well as who created the link
    so that we can put it on the marketer's dashboard.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建链接表，并创建一个函数来帮助我们生成缩短链接。至少，我们需要能够存储链接的标题、实际链接、缩短链接，以及创建链接的人，以便我们可以将其放在营销人员的仪表板上。
- en: 'The SQL for the links table looks like the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 链接表的SQL如下所示：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now let''s create the following function, which will generate a random hash:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建以下函数，它将生成一个随机哈希：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We also need to store the number of hits or clicks to the link. We will use
    another table that will link `link_id` to the number of hits, and we''ll just
    update that table every time someone has used a shortened link:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要存储链接的点击次数。我们将使用另一个表，将`link_id`链接到点击次数，每当有人使用缩短链接时，我们将更新该表：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We won''t need to index the preceding SQL table because we won''t really need
    to do fast searches on it. Every time we generate a new URL, we should populate
    the table already with the `num` hits defaulting to 0:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要对之前的SQL表进行索引，因为我们不需要在其上进行快速搜索。每次生成新的URL时，我们应该将表填充为`num`默认为0：
- en: 'Add the following function in the `createShortLink` function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`createShortLink`函数中添加以下函数：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `insert_id` is the ID of the last inserted record of MySQL. It's a function
    that returns the new ID generated every time a new row is added.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert_id`是MySQL最后插入记录的ID。它是一个函数，每次添加新行时都会返回新生成的ID。'
- en: 'Let''s generate the link hit class that contains two functions, one to initialize
    the database and another that will update the `link_hits` table every time a user
    clicks on a link:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成包含两个函数的链接点击类，一个用于初始化数据库，另一个用于在用户点击链接时更新`link_hits`表：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For our marketers to view the links, we will need to display their links on
    a `links` page in our portal.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的营销人员查看链接，我们需要在我们的门户网站上的`links`页面上显示他们的链接。
- en: 'We create the function for checking the links and their hits that is attributed
    to the admin user who is logged in:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建用于检查链接及其点击次数的功能，这是归因于已登录的管理员用户：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding code, we just got the logged-in user's ID by checking the variable
    `$_SESSION['user_id']`. Then we performed an SQL query by executing the string
    variable `$SQL`. After this, we loop through the results and show the results
    into an HTML table. Note that we exit the PHP code when we display a permanent
    HTML markup such as start of the table and the headers and the ending of the `</table>`
    tag.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们只是通过检查变量`$_SESSION['user_id']`获取了已登录用户的ID。然后我们通过执行字符串变量`$SQL`执行了一个SQL查询。之后，我们循环遍历结果，并将结果显示在HTML表中。请注意，当我们显示永久的HTML标记时，例如表的开头、标题和`</table>`标记的结束时，我们退出PHP代码。
- en: PHP performs slightly better without using echo statements, and this is the
    beauty of PHP scripting, you are really allowed to go into the PHP sections and
    then into the HTML sections in your code. Your opinion may differ on the beauty
    of this idea, but we just want to show what PHP can do in this exercise.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: PHP在不使用echo语句时性能略有提高，这就是PHP脚本的美妙之处，您真的可以进入PHP部分，然后进入代码中的HTML部分。您对这个想法的美感可能有所不同，但我们只是想展示PHP在这个练习中可以做什么。
- en: AJAX socket chat for support
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持的AJAX套接字聊天
- en: This system allows the subscribers to contact the administrator of a particular
    newsletter group. It will just contain a contact form. Also, we shall need to
    implement a way to send a notification to the administrator in real time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统允许订阅者联系特定通讯组的管理员。它将只包含一个联系表单。此外，我们需要实现一种实时向管理员发送通知的方式。
- en: We will basically add a socket connection to the administrator so that when
    ever someone sends an inquiry, it will flash a notification on the marketer's
    dashboard.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基本上为管理员添加一个套接字连接，以便每当有人发送查询时，它将在营销人员的仪表板上闪烁通知。
- en: This is pretty simple with **socket.io** and a browser technology called WebSockets.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于**socket.io**和一个名为WebSockets的浏览器技术来说非常简单。
- en: Introduction to socket.io
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: socket.io简介
- en: With socket.io, we don't need to create the code for checking the server periodically
    for an event. We'll just pass through the data the user entered by using AJAX
    and trigger the listeners to the sockets by emitting the events. It offers long
    polling and communication through WebSockets and is supported by modern web browsers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用socket.io，我们不需要创建用于定期检查服务器是否有事件的代码。我们只需通过AJAX传递用户输入的数据，并通过发出事件来触发套接字的监听器。它提供了长轮询和通过WebSockets进行通信，并得到了现代Web浏览器的支持。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WebSockets extends the concept of having socket connections through a browser.
    To read more on WebSockets, please visit [http://www.html5rocks.com/en/tutorials/websockets/basics/](http://www.html5rocks.com/en/tutorials/websockets/basics/)
    .
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets扩展了通过浏览器建立套接字连接的概念。要了解有关WebSockets的更多信息，请访问[http://www.html5rocks.com/en/tutorials/websockets/basics/](http://www.html5rocks.com/en/tutorials/websockets/basics/)。
- en: 'A sample code on the socket.io site just includes the `socket.io.js` script:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: socket.io网站上的示例代码只包括`socket.io.js`脚本：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Our PHP webserver will be using something called  **Ratchet**, which has a website
    at [http://socketo.me](http://socketo.me). It basically allows us to use WebSockets
    for PHP.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的PHP Web服务器将使用一个名为**Ratchet**的东西，它在[http://socketo.me](http://socketo.me)上有一个网站。它基本上允许我们为PHP使用WebSockets。
- en: 'Here is their website:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是他们的网站：
- en: '![Introduction to socket.io](graphics/image_03_004.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![socket.io简介](graphics/image_03_004.jpg)'
- en: Ratchet is just a tool to allow PHP developers "*to create real time, bi-directional
    applications between clients over WebSockets*". By creating a bi-directional flow
    of data, it allows developers to create things such as real-time chat and other
    real-time applications.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Ratchet只是一个工具，允许PHP开发人员“*在WebSockets上创建实时的、双向的应用程序*”。通过创建双向数据流，它允许开发人员创建实时聊天和其他实时应用程序等东西。
- en: Let's get started by following their tutorial at [http://socketo.me/docs/hello-world](http://socketo.me/docs/hello-world).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过按照他们在[http://socketo.me/docs/hello-world](http://socketo.me/docs/hello-world)上的教程开始。
- en: 'With Ratchet, we have to install  **Composer** and add the following to our
    `composer.json` file in our project directory:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ratchet，我们需要安装**Composer**并将以下内容添加到我们项目目录中的`composer.json`文件中：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you've had prior experience with Composer, basically what it does is use
    the `psr-0` standard in writing the path to a script that needs autoloading. Then
    we run `composer install` in the same directory. After having Ratchet set up,
    we need to set up the proper components for handling certain events.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前有使用Composer的经验，基本上它所做的就是在编写需要自动加载的脚本的路径时使用`psr-0`标准。然后我们在同一目录中运行`composer
    install`。在设置好Ratchet之后，我们需要设置处理某些事件的适当组件。
- en: We need to create a folder labeled `SupportChat` and put `Chat.php` inside.
    This is because using psr-0 in the preceding `composer.json` file, it expects
    a directory structure inside the `src` directory.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个名为`SupportChat`的文件夹，并将`Chat.php`放在其中。这是因为在之前的`composer.json`文件中使用psr-0时，它期望`src`目录内有一个目录结构。
- en: 'Let''s create a class with the stubbed functions that we need to implement:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含我们需要实现的存根函数的类：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We need to declare the `$clients` variable to store the clients that will connect
    to our chat app.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要声明`$clients`变量来存储将连接到我们聊天应用程序的客户端。
- en: 'Let''s implement the interface for when the client opens a connection:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现客户端打开连接时的接口：
- en: '[PRE48]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now let''s create the `onMessage` and `onClose` methods as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建`onMessage`和`onClose`方法如下：
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s also create an `onError` method for handling errors as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也创建一个用于处理错误的`onError`方法如下：
- en: '[PRE50]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now we need to implement the client (browser) side of the application.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要实现应用程序的客户端（浏览器）部分。
- en: 'Create a file called `app.js` in your `htdocs` or `public` folder with the
    following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`htdocs`或`public`文件夹中创建一个名为`app.js`的文件，其中包含以下代码：
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We need to create the HTML for the preceding code to be used. We should name
    the file `app.js`. Now, let''s implement a simple input text for the user to enter
    their messages:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建用于上述代码的HTML。我们应该将文件命名为`app.js`。现在，让我们实现一个简单的输入文本，让用户输入他们的消息：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`App.js` is where the JavaScript code we wrote earlier should go. We also need
    to create a WebSocket server to handle the WebSocket on port `8088`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.js`是我们之前编写的JavaScript代码应该放置的地方。我们还需要创建一个WebSocket服务器来处理端口`8088`上的WebSocket：'
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Our chat app is now ready for public use. However, we need to start our chat
    server, which will handle WebSockets by starting it with `php bin/server.php`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天应用现在已经准备好供公众使用。但是，我们需要启动我们的聊天服务器，通过`php bin/server.php`启动它来处理WebSockets。
- en: 'Note that on Windows, it will prompt about the network being used:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Windows上，它会提示有关正在使用的网络：
- en: '![Introduction to socket.io](graphics/image_03_005.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![socket.io简介](graphics/image_03_005.jpg)'
- en: Simply click on **Allow access** and then click on **OK**.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 只需单击**允许访问**，然后单击**确定**。
- en: 'Now when we visit `http://localhost/client.html`, we should see the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们访问`http://localhost/client.html`时，我们应该看到以下内容：
- en: '![Introduction to socket.io](graphics/image_03_006.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![socket.io简介](graphics/image_03_006.jpg)'
- en: However, we need to spiff up the contact form by adding the username and e-mail
    for support to get back to him via e-mail in case no one from support is available
    to reply to the user.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们需要通过添加用户名和电子邮件来改进联系表单，以便支持人员在没有支持人员回复用户的情况下通过电子邮件回复他。
- en: 'Our form now looks as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单现在如下所示：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Since we've added those details, we need to store them in our database. We can
    do this by having all the data forwarded to another PHP script to do the sending.
    In JavaScript, the code would add to the handler a way to send to the `sendsupportmessage.php`
    the values from the form.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们添加了这些细节，我们需要将它们存储在我们的数据库中。我们可以通过将所有数据转发到另一个PHP脚本来执行发送。在JavaScript中，代码将向处理程序添加一种从表单发送到`sendsupportmessage.php`的方式。
- en: 'Here is how that JavaScript code, with jQuery, will look:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用jQuery编写的JavaScript代码的样子：
- en: '[PRE55]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the script that will receive the messages, `sendsupportmessage.php`, we''ll
    need to parse the information and create an e-mail to send to the support e-mail,
    `contact@yoursite.com`; see the following example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在将接收消息的脚本`sendsupportmessage.php`中，我们需要解析信息并创建一封发送到支持电子邮件`contact@yoursite.com`的电子邮件；请参考以下示例：
- en: '[PRE56]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The script just checks if the submitted values are not blank. By experience,
    using `!empty ()` instead of checking for a set value with the `isset()` function
    is better because an empty string (`''''`) may be evaluated by PHP to still be
    set:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本只是检查提交的值是否不为空。根据经验，使用`!empty()`而不是使用`isset()`函数检查设置的值更好，因为PHP可能会将空字符串（''）评估为已设置：
- en: '[PRE57]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We now need to display to the user, as we sent the message to the server using
    AJAX, and update the AJAX box. In the JavaScript code, we should change the `.done()`
    callback code to the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要向用户显示，因为我们使用AJAX将消息发送到服务器，并更新AJAX框。在JavaScript代码中，我们应该将`.done()`回调代码更改为以下内容：
- en: '[PRE58]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Fantastic! Notice that we changed the alert box call and instead appended the
    message `Your message was sent` back into the message list. Our support form now
    sends who the message is from and our support team can receive the message in
    their e-mails.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！请注意，我们更改了警报框的调用，而是将消息`您的消息已发送`附加回消息列表中。我们的支持表单现在发送了消息的发送者，并且我们的支持团队可以在他们的电子邮件中收到消息。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You learned a lot in this chapter. To summarize, we built a simple admin system
    to manage our marketers. After this, we also created a way for members of the
    newsletter to log in which leads the user to a home page.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学到了很多。总之，我们建立了一个简单的管理系统来管理我们的营销人员。此外，我们还为新闻通讯的成员创建了一个登录方式，这将引导用户到主页。
- en: Then we reviewed how to send an e-mail with a simple template system, which
    allowed a user to add his/her own menu and the content to the layout. We were
    also able to add Facebook social login by using the Facebook PHP SDK and its authentication
    process.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们回顾了如何使用简单的模板系统发送电子邮件，这允许用户添加自己的菜单和内容到布局中。我们还能够使用Facebook PHP SDK和其认证过程添加Facebook社交登录。
- en: In the latter part of the chapter, we built a simple chat system that will send
    an e-mail immediately to the support e-mail address of our website. We checked
    out Ratchet, a PHP library to help us work with real-time messaging in PHP, and
    used AJAX to asynchronously send the data to another script that will do the e-mailing
    to the support e-mail.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后半部分，我们建立了一个简单的聊天系统，它将立即发送电子邮件到我们网站的支持电子邮件地址。我们查看了Ratchet，这是一个PHP库，可以帮助我们在PHP中处理实时消息，并使用AJAX异步发送数据到另一个将发送电子邮件到支持电子邮件的脚本。
- en: We've now created an impressive newsletter app that is more than the regular,
    with social login features and a support chat box, and allows other newsletter
    marketers to manage their content through a website.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个令人印象深刻的新闻通讯应用程序，它不仅具有社交登录功能和支持聊天框，还允许其他新闻通讯营销人员通过网站管理其内容。
