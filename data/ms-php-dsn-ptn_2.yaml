- en: Chapter 2. Anti-Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 反模式
- en: Here's where we start on anti-patterns; before you get your hopes up thinking
    I'm about to tell you something amazing that will wonderfully streamline your
    code without using design patterns, I won't be doing that here (did I mention
    I'm great at crushing hopes and dreams?). Anti-patterns are, in short, things
    you don't want in your code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们开始讨论反模式的地方；在你满怀希望地认为我将告诉你一些了不起的东西，可以在不使用设计模式的情况下奇妙地简化你的代码之前，我在这里不会这样做（我是否提到过我擅长粉碎希望和梦想？）。简而言之，反模式是你不想在你的代码中出现的东西。
- en: Speaking of crushing hopes and dreams, should you ever have a junior developer,
    anti-patterns are also a great way of teaching methodologies that should be equally
    avoided. Learning anti-patterns also can boost the effectiveness of code reviews;
    instead of debating code quality on the basis of personal opinions, you can have
    an external source to consult on code quality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 说到粉碎希望和梦想，如果你曾经有过初级开发人员，反模式也是教授应该避免的方法论的好方法。学习反模式还可以提高代码审查的效率；你可以有一个外部来源来咨询代码质量，而不是基于个人意见来辩论代码质量。
- en: Anti-patterns constitute a terrible method of resolving a recurring problem
    that is usually ineffective and risks being highly counterproductive. They can
    then create technical debt as developers must later struggle to refactor to resolve
    the initial problems but hopefully use a more resilient design pattern.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 反模式构成了一种解决经常出现的问题的可怕方法，通常是无效的，并且有很高的反生产力风险。它们可能会产生技术债务，因为开发人员必须后来努力重构以解决最初的问题，但希望使用更具弹性的设计模式。
- en: 'We all have encountered Spaghetti Code; one contract developer I worked with
    exclaimed to an ever more demanding product owner in the face of high technical
    debt: "There is so much spaghetti I might as well open a restaurant!" Spaghetti
    Code is where the control structure of a program is barely comprehensible as it
    is so tangled and over-complicated and it may be described as an anti-pattern.
    One of the major criticisms in PHP 5.3.0 was the implementation of goto operators
    in the language. Indeed, those critiquing their implementation claimed goto operators
    would provide yet another excuse for more Spaghetti Code in PHP.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都遇到过意大利面代码；我和一个合同开发人员一起工作时，他在面对高技术债务的产品负责人时大声喊道：“意大利面太多了，我可能还不如开一家餐厅！”意大利面代码是指程序的控制结构几乎无法理解，因为它太混乱和过于复杂，可以被描述为一种反模式。在PHP
    5.3.0中的一个主要批评是语言中goto操作符的实现。事实上，批评它们的实施的人声称，goto操作符将为PHP中的意大利面代码提供另一个借口。
- en: 'Gotos were highly controversial in PHP, with someone even going as far to report
    it as a bug, stating: "PHP 5.3 includes goto. This is a problem. Seriously, PHP
    has made it this far without goto, why turn the language into a public menace?"'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，goto语句曾引起了很大的争议，甚至有人将其报告为一个bug，并表示：“PHP 5.3包括goto。这是一个问题。说真的，PHP在没有goto的情况下已经走到了这一步，为什么要把这种语言变成公共威胁呢？”
- en: 'In addition to this, the submitter of the bug report listed the expected result
    as: "the world will end" and the actual result being "the world ended". Despite
    this, goto operators in PHP are heavily restricted so you can''t just jump in
    and out of functions. Some people also argue that they are useful in finite state
    machines (essentially something with a binary output based on multiple inputs),
    but this is also controversial; so I shall allow you to make your own judgments
    about them.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，bug报告的提交者将预期结果列为：“世界将会结束”，实际结果是“世界已经结束”。尽管如此，在PHP中，goto操作符受到严格限制，因此你不能随意跳入和跳出函数。有些人还认为它们在有限状态机中很有用（基本上是基于多个输入的二进制输出），但这也是有争议的；所以我会让你自己对它们做出判断。
- en: You may well have experienced copy and paste programming, where whole blocks
    of code are copied and pasted in a program; this is yet another example of bad
    software design. In reality, developers should be designing their software to
    create generic solutions to problems instead of copying, refactoring, and pasting
    bits of code to fit a situation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也经历过复制粘贴编程，整个代码块被复制并粘贴到程序中；这是另一个糟糕软件设计的例子。实际上，开发人员应该设计他们的软件，以创造通用的解决方案来解决问题，而不是复制、重构和粘贴代码来适应某种情况。
- en: I will introduce this chapter with a section on why learning anti-patterns is
    important. During this chapter, I will discuss not only traditional anti-pattern-related
    software design but also anti-pattern-related web infrastructure and management
    styles. In addition to this, I want to discuss some PHP-specific anti-patterns,
    or flaws in PHP, which you may need to compensate for in your own code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章中介绍为什么学习反模式很重要。在本章中，我将讨论传统的与反模式相关的软件设计，还有与反模式相关的网络基础设施和管理风格。除此之外，我想讨论一些PHP特定的反模式，或者PHP中的缺陷，这可能需要你在自己的代码中进行补偿。
- en: This book contains a dedicated chapter on refactoring towards the end; if the
    process of refactoring is of interest to you, this chapter will help lay the foundations
    of the ideas you might want to start thinking about; in addition to this, the
    chapters specific to design patterns may help you realize the code you might be
    eventually aiming for. In the chapter dedicated to refactoring, we will also cover
    some code smells, which can help you discover anti-patterns in codebases you're
    maintaining.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含了一个专门的章节，讲述了重构的过程；如果重构的过程对你感兴趣，这一章将帮助你打下你可能想要开始思考的理念基础；除此之外，专门讲述设计模式的章节可能会帮助你意识到你最终可能要达到的代码。在专门讲述重构的章节中，我们还将涵盖一些代码异味，这可以帮助你发现你正在维护的代码库中的反模式。
- en: Why anti-patterns matter
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么反模式很重要
- en: Most programmers come from a background of adopting some form of anti-pattern
    until eventually realizing how it doesn't scale or doesn't work well. When I was
    17 and in my first job as an apprentice developer, I would be whisked down to
    London Monday-to-Friday, somehow compressing my suit and my totally black clothing
    into a surprisingly miniscule suitcase, and would learn about software development.
    On Fridays, we were often released for a half-day at 12:00 but I would pre-book
    my company train tickets in the afternoon so I would spend my time in fast-food
    restaurants or coffee shops working on simple projects. Every week, when I came
    back and tried to scale one of these solutions I would realize new scalability
    issues and code quality issues. Of course, I had done development before, but
    these were largely dealing with either brand new incredibly short programming
    tasks, using pre-made frameworks or dealing with legacy code where the architecture
    had already been done (or, as I now realize, butchered with a severely blunt knife).
    This learning process of scaling my own code was great; I rapidly taught myself
    how to design software better. As humans, we often don't know enough about a topic
    to know how little we know (something incredibly true I've found with those who
    manage software developers but has never written any code themselves); while bearing
    this in mind, we should remember we are never above learning from our own mistakes.
    While this is incredibly important, teaching ourselves documented anti-patterns
    is also vital in order to learn from others mistakes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员都来自采用某种反模式的背景，直到最终意识到它无法扩展或效果不佳。当我17岁时，在我的第一份学徒开发人员工作中，我会被送到伦敦，从周一到周五，以某种方式把我的西装和完全黑色的衣服压缩成一个令人惊讶的小手提箱，然后学习软件开发。周五，我们经常在中午12:00放半天假，但我会提前预订公司的火车票，所以我会在快餐店或咖啡店里工作简单的项目。每周，当我回来尝试扩展其中一个解决方案时，我会意识到新的可扩展性问题和代码质量问题。当然，我以前也做过开发，但这些主要是处理全新的、非常简短的编程任务，使用预先制作的框架，或者处理已经完成架构的遗留代码（或者，我现在意识到，是用非常迟钝的刀切割的）。扩展自己代码的这个学习过程很棒；我迅速教会自己如何更好地设计软件。作为人类，我们经常对某个主题了解不够，以至于不知道自己知道的有多少（我发现这在那些管理软件开发人员但从未自己编写过任何代码的人身上非常真实）；在牢记这一点的同时，我们应该记住，我们永远不会超越从自己的错误中学习。虽然这非常重要，但教会自己记录的反模式也是为了从他人的错误中学习至关重要。
- en: I was once the technical lead and mentor for a developer who had the most down-right
    brutal treatment from learning from his mistakes. In the first appraisal I had
    with this developer, I was told by my HR counterpart that every time he'd made
    a mistake both the previous technical and HR leads dragged him into a meeting
    room to go through a formal disciplinary process. Both of these people had incredibly
    limited technical knowledge and also were completely incompetent at managing developers
    (so much so that they were the type of people who lived in their own bubble, clueless
    of how people worked in more successful environments and largely stuck in dead-end
    careers without the knowledge to ever do anything meaningful in their careers).
    By the time they left, this poor developers confidence had been crushed to such
    a point that he had no real career ambition in web and wasn't keen to learn. There's
    nothing wrong with being happy in your position. As a former boss of mine once
    said after I told him something incredibly personal, "ultimately, all that matters
    is that you're happy". Yes, it takes a lot of people to make the world go round,
    but as soon as you put yourself in a position where you are either mentoring or
    managing other developers you have an obligation to keep yourself ahead of the
    game. If you are a manager, you should know how to do your job effectively. The
    best people managers I've had have been those that possess a wealth of knowledge,
    keeping up to date with the latest and greatest in management methodologies the
    same way I like to keep up to date with the latest and greatest in the PHP core
    and community. Throughout the course of writing this book, my knowledge of project
    and people management has improved, but it still has a long way to go, and therefore
    I'd not take a job with such line management responsibilities without educating
    myself first. At the company I worked at, where there was effectively bullying
    as a management strategy, I once mentioned this to the head of department who
    responded by saying "we're not saying it's the best way of doing it"; if that's
    true, surely something should be done to fix this, for the sake of the business!
    This wasn't true in the entire business; other departments had a very different
    attitude, and indeed, the Technical Director once gave a tech talk about this
    very topic and the importance of knowing that you don't know. The CEO of the company
    started a similar conversation with me, saying how he knew he didn't know. Old
    practices die hard, but at least they have started sailing on the winds of change.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经是一位开发人员的技术负责人和导师，他从犯错中学习受到了最严厉的对待。在我和这位开发人员的第一次评估中，我的人力资源对手告诉我，每次他犯错时，之前的技术负责人和人力资源负责人都会把他拉到会议室进行正式的纪律程序。这两个人的技术知识非常有限，而且在管理开发人员方面完全无能（以至于他们是那种生活在自己的泡泡中，对更成功的环境中人们的工作方式一无所知，基本上陷入了没有前途的职业生涯，没有知识去做任何有意义的事情）。等他们离开时，这位可怜的开发人员的自信已经被压垮到了一个程度，以至于他对网络没有真正的职业抱负，也不急于学习。在你的职位上快乐并没有错。正如我的一位前上司在我告诉他一些非常个人的事情后所说的，“最重要的是你快乐”。是的，让世界运转需要很多人，但一旦你把自己置于指导或管理其他开发人员的位置，你就有义务使自己保持在游戏的前沿。如果你是一个经理，你应该知道如何有效地做好你的工作。我遇到的最好的人事经理是那些拥有丰富知识的人，他们不断更新最新的管理方法，就像我喜欢不断更新PHP核心和社区最新最伟大的方法一样。在写这本书的过程中，我的项目和人事管理知识有所提高，但仍有很长的路要走，因此我不会在没有先教育自己的情况下接受这样的线路管理职责。在我工作的公司，实际上以恐吓作为管理策略，我曾经向部门负责人提到过这一点，他回答说“我们并不是说这是最好的做法”；如果这是真的，那么为了公司的利益，肯定应该采取一些措施来解决这个问题！这并不是整个公司都是这样；其他部门有着非常不同的态度，事实上，技术总监曾经就这个问题和知道自己不知道的重要性做了一个技术讲座。公司的CEO也和我开始了类似的对话，说他知道自己不知道。旧的做法很难改变，但至少他们已经开始迎接变革的风。
- en: 'So other than ranting (I do love a good rant), why am I talking about this?
    My point is that your attitude matters. One of my favorite quotes on this subject
    is that "if you treat your developers like idiots, they will soon become idiots".
    Let me extend upon this by saying this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所以除了发牢骚（我确实喜欢发牢骚），我为什么要谈论这个？我的观点是你的态度很重要。关于这个问题，我最喜欢的一句话是“如果你把你的开发人员当作白痴，他们很快就会变成白痴”。让我进一步说一下：
- en: Bad performance in students is often a reflection of bad performance from teachers.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学生的糟糕表现往往反映了老师的糟糕表现。
- en: Everyone makes mistakes, mistakes getting out control is the fault of idiotic
    behavior from managers, not developers.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个人都会犯错，但错误失控是管理者愚蠢行为的错，而不是开发人员的错。
- en: Idiots attract idiots. If you are an idiot in your body of subject knowledge,
    you will in turn likely recruit more idiots.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白痴会吸引白痴。如果你在自己的专业知识领域是个白痴，那么你很可能会招募更多的白痴。
- en: If you operate a regime of fear in your workplace, you are an idiot and scared
    of being found out.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在工作场所实行恐惧统治，你就是个白痴，害怕被发现。
- en: If you don't know how little you know and you don't seek to effectively cure
    your own ignorance, you are an idiot.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不知道自己知道的有多少，也不寻求有效地消除自己的无知，你就是个白痴。
- en: If you treat your developers like idiots, you are an idiot.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你把你的开发人员当作白痴，那么你就是个白痴。
- en: In short, learn how little you know and grow. It sounds brutal, but it's the
    truth. We are all ignorant, we cannot know everything. Effectively utilizing our
    own knowledge in association with the knowledge of others is vital to success.
    Recognizing our own ignorance is key to this. For example, last year I decided
    that my knowledge in fundamental computer science wasn't broad enough to cope
    with my own demand for it, or the demands of those I mentored; therefore, I decided
    to go off and do a part-time master's degree in computer science. The learning
    process has been great and taught me about fields in computer science I didn't
    know existed before.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，了解自己知道的有多少，然后成长。听起来很残酷，但这是事实。我们都是无知的，我们无法知道一切。有效地利用我们自己的知识与他人的知识是成功的关键。认识到自己的无知是关键。例如，去年我决定，我在基础计算机科学方面的知识不够广泛，无法满足自己对它的需求，也无法满足我指导的人的需求；因此，我决定去读计算机科学的兼职硕士学位。学习过程非常棒，教会了我之前不知道存在的计算机科学领域。
- en: Some software developers use other people's work, and yes, WordPress or Drupal
    development can give you a happy and productive career, but you will find the building
    and architecting things for yourself to be a great learning experience. Having
    worked in a traditional engineering environment, I have been won over to the view
    that a firm theoretical background in computer science is hugely beneficial for
    software engineers. Indeed, the body of knowledge required to understand the fundamentals
    of computer science is actually quite easy to pick up. Of course, in many ways,
    I am preaching to the converted; if you are reading this book you presumably understand
    the need for a deeper theoretical computer science knowledge base, but please
    don't read this book and stop actively learning. Continue to have a plan to progress
    your knowledge, seek to improve the information stored in that piece of protein
    that resides in our skulls.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些软件开发人员使用其他人的工作，没错，WordPress或Drupal的开发可以给你一个快乐和富有成效的职业，但你会发现为自己建立和设计东西是一次很好的学习经历。在传统的工程环境中工作过后，我已经被说服，计算机科学的坚实理论基础对软件工程师是非常有益的。事实上，理解计算机科学基本原理所需的知识体系实际上是相当容易掌握的。当然，在很多方面，我是在对已经信奉的人说教；如果你正在阅读这本书，你可能理解需要更深入的理论计算机科学知识基础，但请不要读完这本书就停止积极学习。继续制定计划来提高你的知识，努力改进我们头脑中存储的信息。
- en: It is often said that "*in the land of the blind, the one-eyed man is king*";
    smaller development teams may often lack the basics when it comes to good software
    development (perhaps out of lack of necessity), and indeed, some larger development
    environments who become stuck in the past may end up in the same situation. In
    this regard, knowledge just becomes more precious and it becomes equally important
    for developers to be educated about software development.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 经常有人说“在盲人国度，有一只眼睛的人是国王”；较小的开发团队在良好的软件开发方面可能经常缺乏基础（也许是因为没有必要），而一些陷入过去的较大的开发环境最终可能陷入同样的境地。在这方面，知识变得更加珍贵，对开发人员了解软件开发同样重要。
- en: Anti-patterns aren't just something your team can be taught to avoid; good software
    development needs a firm understanding of not only the programming language but
    also a theoretical understanding of software development is key.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 反模式不仅仅是你的团队可以学会避免的东西；良好的软件开发需要对编程语言和软件开发的理论理解有坚实的了解。
- en: 'Finally, let me just steal this quote from an article on SourceMaking:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我从SourceMaking的一篇文章中引用这句话：
- en: '*"Architecture-driven software development is the most effective approach to
    building systems. Architecture-driven approaches are superior to requirements-driven,
    document-driven, and methodology-driven approaches. Projects often succeed in
    spite of methodology, not because of it."*'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “以架构为驱动的软件开发是构建系统的最有效方法。架构驱动方法优于需求驱动、文档驱动和方法论驱动方法。项目通常成功是尽管方法论，而不是因为它。”
- en: Rant(s) over. Let's cover some anti-patterns.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 情绪发泄完毕。让我们来谈谈一些反模式。
- en: Not invented here syndrome
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非自行开发综合症
- en: 'Cryptography can teach us a very important lesson about software; this is especially
    true about Kerckhoffs''s principle. The principle states this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学可以教给我们关于软件的一个非常重要的教训；这对于克尔克霍夫原则尤其如此。该原则陈述了这一点：
- en: '*"A cryptosystem should be secure even if everything about the system, except
    the key, is public knowledge."*'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “即使系统的一切都是公开知识，一个加密系统也应该是安全的，除了密钥。”
- en: 'This was reformulated by Claude Shannon in a form known as Shannon''s Maxim:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由克劳德·香农改编的，称为香农定律：
- en: '*"One ought to design systems under the assumption that the enemy will immediately
    gain full familiarity with them".*'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “应该在假设敌人立即完全熟悉它们的情况下设计系统。”
- en: In layman's terms, in order to have a secure system, it shouldn't be secure
    just because no one knows how it's been implemented ("security through obscurity").
    If you were to secure your money through obscurity, you'd bury it under a tree
    and hope no one would find it. Whereas, when you use a real security mechanism,
    such as putting your money in a safe in a bank, you can have every detail about
    the security system as public information, but providing the security system is
    truly secure, you would really only have to keep the key to the safe secret and
    every other detail could be public knowledge. If someone was to find the key to
    your safe, you only need change the combination, whereas if someone actually found
    where your money was buried under a tree, you would actually have to dig up the
    money and find somewhere else to put it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，为了拥有一个安全的系统，它不应该只因为没有人知道它是如何实现的而被视为安全（“安全通过模糊性”）。如果你通过模糊性来保护你的钱，你会把它埋在树下，希望没有人会找到它。而当你使用真正的安全机制，比如把你的钱放在银行的保险柜里，你可以把安全系统的每一个细节都公开，只需要保密保险柜的钥匙，其他细节都可以是公开的信息。如果有人找到了你的保险柜的钥匙，你只需要改变组合，而如果有人真的找到了你的钱埋在树下，你就必须挖出钱，找别的地方放。
- en: Security that is only done through obscurity is a bad idea (that said, it's
    not always a bad idea). As you may be aware, when you store a password in a database
    you should use a one-way cryptographic algorithm known as a **hashing algorithm**
    to ensure that if the database is stolen no one can ever use the data in the database
    to find the user's original password. Of course, in reality, you shouldn't just
    hash a password, you should salt it and use an algorithm such as PBKDF2 or BCrypt,
    but this book isn't about password security.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 只通过模糊性来保护安全是一个坏主意（尽管并不总是坏主意）。正如你可能知道的，当你把密码存储在数据库中时，你应该使用一种单向的加密算法，称为**哈希算法**，以确保如果数据库被盗，没有人能够使用数据库中的数据找到用户的原始密码。当然，在现实中，你不应该只是对密码进行哈希处理，你应该对其进行盐处理，并使用诸如PBKDF2或BCrypt的算法，但本书不是关于密码安全的。
- en: The reality of the situation, however, is that sometimes, when developers actually
    do bother to hash passwords, they decide to create their own password hashing
    functions, functions that are easily reversible and are only secured by the obscurity
    of someone not knowing the algorithm. This is a perfect example of *not invented
    here* (*NIH*) syndrome; instead of a developer using a well-created password hashing
    library that is highly respected, they decide to create their own, pretending
    they are a cryptographer without understanding the security implications of such
    a decision.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，情况的现实是，有时候，当开发人员真的费心去对密码进行哈希处理时，他们决定创建自己的密码哈希函数，这些函数很容易被逆向，并且只有通过不知道算法的模糊性来保护。这是*非本地研发*（NIH）综合症的一个完美例子；开发人员没有使用备受尊重的密码哈希库，而是决定自己创建，假装自己是一个密码学家，却不理解这样的决定的安全影响。
- en: Thankfully, PHP now makes it painlessly easy to hash your passwords; the `password_hash`
    function and `password_verify` function make this really easy with the `password_needs_rehash`
    function even telling you when the hash needs to be recalculated. Nevertheless,
    I digress.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 值得庆幸的是，PHP现在让对密码进行哈希处理变得非常容易；`password_hash`函数和`password_verify`函数使这变得非常容易，而`password_needs_rehash`函数甚至可以告诉你何时需要重新计算哈希。尽管如此，我岔开了话题。
- en: So what actually is NIH syndrome? NIH syndrome is where a false sense of pride
    in an organization or individual developers own ability leads them to build their
    own solution instead of adopting superior third-party solutions. Reinventing the
    wheel isn't only costly, unnecessary, and can add needless overhead in maintenance;
    it can also be horribly insecure.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是NIH综合症？NIH综合症是指对组织或个人开发者自身能力的虚假自豪感导致他们建立自己的解决方案，而不是采用更优秀的第三方解决方案。重新发明轮子不仅成本高昂、不必要，并且会增加不必要的维护开销；它也可能非常不安全。
- en: That said, where solutions are closed source and locked down, then it might
    be a good idea to avoid them. Doing so would also avoid vendor lock-in and restrictions
    on business flexibility.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果解决方案是封闭源和封锁的，那么最好避免使用它们。这样做也可以避免供应商锁定和对业务灵活性的限制。
- en: NIH syndrome relies on the existing solutions being good and living up to expectations.
    Using third-party libraries is no excuse not to review their code quality.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: NIH综合症依赖于现有解决方案的良好性能和达到预期。使用第三方库并不是不检查其代码质量的借口。
- en: Contributing to open source solutions is a great way to alleviate these issues.
    Room for improvement on an existing library? Fork it, propose an amendment to
    be merged in. No library that does the functionality you're after? Then you might
    want to consider writing your own library and publishing it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为开源解决方案做贡献是缓解这些问题的好方法。对现有库有改进的空间？分叉它，提出合并的修改。没有符合你需求的功能的库？那么你可能需要考虑编写自己的库并发布它。
- en: I will finish this section by saying that the world has become heterogeneous;
    people are no longer looking for one technology stack to answer all their prayers;
    people are nowadays after the best tool for the job. It's worth thinking how you
    can utilize this fact for your own benefit.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以这一节结束，说世界已经变得多元化；人们不再寻求一个技术堆栈来满足他们所有的需求；如今人们追求的是最适合工作的最佳工具。值得考虑如何利用这一事实来使自己受益。
- en: Third-party dependencies with Composer
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Composer的第三方依赖
- en: Composer makes it really easy to manage third-party dependencies. In [Chapter
    1](ch01.html "Chapter 1. Why "Good PHP Developer" Isnt an Oxymoron"),  *Why "Good
    PHP Developer" Isn't an Oxymoron*, I briefly described how you can use Composer
    for autoloading. Big deal, autoloading has been supported as a core function since
    PHP 5.1.2, but the great thing about Composer is that you can also use it for
    dependency management. Composer can effectively go and fetch the dependencies
    you need using the version constraints you specify.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Composer使管理第三方依赖变得非常容易。在[第1章](ch01.html "第1章。为什么“优秀的PHP开发人员”不是一个自相矛盾的词")中，*为什么“优秀的PHP开发人员”不是一个自相矛盾的词*，我简要描述了如何使用Composer进行自动加载。自动加载从PHP
    5.1.2以来就作为核心功能得到支持，但Composer的伟大之处在于你还可以用它进行依赖管理。Composer可以根据你指定的版本约束有效地获取你需要的依赖项。
- en: 'Let''s start off the with the following `composer.json` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下`composer.json`文件开始：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So let''s pull in a dependency:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们拉取一个依赖项：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that all we've done is add a `require` parameter where we specify which
    software we want. No manually pasting files into your project or root, or using
    sub-modules in Git, for that matter!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们所做的只是添加了一个`require`参数，指定我们想要的软件。没有手动将文件粘贴到你的项目或根目录，或者使用Git中的子模块！
- en: In this case, we pulled in Guzzle, an HTTP library for PHP.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们拉取了Guzzle，一个用于PHP的HTTP库。
- en: Composer by default queries repositories from a central repository called **Packergist**,
    which aggregates packages you can install from their various version control systems
    (such as GitHub, BitBucket, or another repository host). If you like, Packergist
    acts as a kind of phone book that connects the requests for packages from Composer
    to code repositories.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Composer默认从一个名为**Packergist**的中央仓库查询仓库，该仓库汇总了你可以从各种版本控制系统（如GitHub、BitBucket或其他仓库主机）安装的软件包。如果你愿意，Packergist就像一个电话簿，将Composer对代码仓库的软件包请求连接起来。
- en: That said, it's not just Packergist repositories that Composer supports. In
    the spirit of being open source, it supports repositories from a range of VCS
    systems (such as Git/SVN) regardless of where they are hosted.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，Composer不仅支持Packergist仓库。为了支持开源精神，它支持来自各种VCS系统（如Git/SVN）的仓库，无论它们托管在何处。
- en: 'Let''s take the following `composer.json` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下`composer.json`文件：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let me demonstrate how you can include a repository from BitBucket without
    it being on Packergist:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我演示一下如何在没有在Packergist上的情况下包含一个来自BitBucket的仓库：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It''s that easy! You literally just specify the repository you want to pull
    in from and Composer does the rest. It''s just as easy with other version control
    systems:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单！你只需指定你想要从中拉取的仓库，Composer就会完成剩下的工作。使用其他版本控制系统也同样简单：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Rather cheekily, Composer can even support PEAR PHP repositories:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有点厚颜无耻，Composer甚至可以支持PEAR PHP仓库：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In order to update the dependencies after you've made changes to your `composer.json`
    file, just run `composer update`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在你对`composer.json`文件进行更改后更新依赖项的简单方法就是运行`composer update`。
- en: Note that you can't update external dependencies using just `composer dump-autoload`.
    The reason for this is that `dump-autoload` will solely update the class map of
    your autoloader. It will essentially update the list of classes it needs to autoload;
    it won't go and pull in new dependencies.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你不能仅使用`composer dump-autoload`来更新外部依赖项。原因是`dump-autoload`将仅更新你的自动加载器的类映射。它实质上是更新它需要自动加载的类的列表；它不会去拉取新的依赖项。
- en: Occasionally, when using Composer and pulling in dependencies, Git may say you
    need to generate a GitHub authentication key. This is because if you have Git
    installed on your local machine, Composer will go ahead and pull in dependencies
    by cloning then via a version control system; however, occasionally, if it's clinging
    repositories from GitHub, you might come up against its rate limit. If this happens
    there is no need to panic. Composer will give you instructions on how to actually
    go ahead and get an API key so you can proceed without rate limiting.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔在使用Composer并拉取依赖项时，Git可能会说你需要生成一个GitHub身份验证密钥。这是因为如果你在本地机器上安装了Git，Composer将会通过版本控制系统克隆依赖项；然而，偶尔，如果它从GitHub克隆仓库，你可能会遇到它的速率限制。如果发生这种情况，没有必要惊慌。Composer会给你关于如何实际获取API密钥的指示，这样你就可以在没有速率限制的情况下继续进行。
- en: An easy way to get around this issue is simply to generate a local SSH key and
    then put your public key into your GitHub account. That way, when you clone from
    GitHub to your local machine you won't face any rate limitations and you won't
    need to bother setting up an API key either.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个简单方法就是生成一个本地SSH密钥，然后将你的公钥放入你的GitHub账户。这样，当你从GitHub克隆到你的本地机器时，你就不会面临任何速率限制，也不需要设置API密钥。
- en: In order to generate an SSH key on a Linux/Mac OS X machine, you can just use
    run the `ssh-keygen` command, which will create a public and private key you can
    use for SSH authentication, including with Github or BitBucket. These keys will
    (usually) be stored in the `~/.ssh` directory, noting the tilde (`~` represents
    your home directory). Therefore, in order to get your key printed out into your
    Terminal window, run the `cat ~/.ssh/id_rsa.pub` command. Note that the `.pub`
    suffix indicates that `id_rsa.pub` is your public key that you can publically
    share. You must not share your private key, which is usually named just `id_rsa`.
    On Windows, you can use a GUI tool known as **PuttyGen** to generate public and
    private keys.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Linux/Mac OS X机器上生成SSH密钥，你可以使用`ssh-keygen`命令，它将创建一个你可以用于SSH身份验证的公钥和私钥，包括Github或BitBucket。这些密钥（通常）将存储在`~/.ssh`目录中，注意波浪号（`~`代表你的主目录）。因此，为了将你的密钥打印到你的终端窗口中，运行`cat
    ~/.ssh/id_rsa.pub`命令。注意`.pub`后缀表示`id_rsa.pub`是你可以公开分享的公钥。你不应该分享你的私钥，通常只命名为`id_rsa`。在Windows上，你可以使用一个名为**PuttyGen**的GUI工具来生成公钥和私钥。
- en: Once you've got your public and private keys, you can simply put them in GitHub
    by visiting the GitHub website and going to the SSH Keys page in the settings
    menu, paste in your key, and save it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得了公钥和私钥，您可以简单地将它们放在GitHub上，方法是访问GitHub网站，转到设置菜单中的SSH密钥页面，粘贴您的密钥，然后保存。
- en: For subsequent updates, `composer update` will update to the latest versions
    of all dependencies as defined in `composer.json`. If you don't want to do this,
    though, there is an alternative; running Composer `dump-autoload` will solely
    regenerate the list of the PSR-0/PSR-4 classes that need to be included in the
    project (for example, you add, delete, or rename some of your classes).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后续更新，`composer update`将根据`composer.json`中定义的所有依赖项的最新版本进行更新。如果您不想这样做，还有另一种选择；运行Composer
    `dump-autoload`将仅重新生成需要包含在项目中的PSR-0/PSR-4类的列表（例如，您添加、删除或重命名了一些类）。
- en: Composer also supports private repositories, allowing you to effectively manage
    code reuse across multiple projects. Another key benefit is how Composer automatically
    generates a lock file that you can commit in with your projects. This allows you
    to effectively manage exactly which precise version of a dependency was installed
    at a particular point in time when you make a commit using your version control
    system.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Composer还支持私有存储库，允许您有效地管理跨多个项目的代码重用。另一个关键好处是Composer会自动生成一个锁定文件，您可以将其与项目一起提交。这使您能够有效地管理在特定时间点安装的依赖项的确切版本。
- en: Composer makes it easy and effective to manage third-party dependencies. Some
    crucial libraries are already available via Composer, such as PHPUnit, but there
    are also some other great libraries to make your life easier. Two of my favorite
    database libraries on Composer are Eloquent (a database ORM system from Laravel
    that you can find at `illuminate`/`database`) and Phinx (a database migration/seeding
    system that you can find at `robmorgan`/`phinx`). In addition to this, there are
    some great SDKs for various APIs that are available from Packergist (Google publishes
    some of its SDKs, and there are also some more specific ones, such as the Twilio
    SDK for sending SMS messages from your PHP app).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Composer使管理第三方依赖项变得简单而有效。一些关键库已经通过Composer可用，例如PHPUnit，但还有一些其他很棒的库可以让您的生活更轻松。在Composer上，我最喜欢的两个数据库库是Eloquent（来自Laravel的数据库ORM系统，您可以在`illuminate`/`database`找到）和Phinx（一个数据库迁移/填充系统，您可以在`robmorgan`/`phinx`找到）。除此之外，还有一些来自Packergist的各种API的SDK可用（Google发布了一些其SDK，还有一些更具体的SDK，例如用于从您的PHP应用程序发送短信的Twilio
    SDK）。
- en: Composer allows you to specify dependencies for particular environments; suppose
    you only want to pull in PHPUnit on your development environments...that's not
    a problem!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Composer允许您为特定环境指定依赖项；假设您只想在开发环境中引入PHPUnit...那就没问题！
- en: God objects
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上帝对象
- en: God objects are a tempting consequence of bad software design and also badly
    implemented object orientation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上帝对象是糟糕的软件设计和糟糕的对象导向的诱人结果。
- en: Essentially, a **God object** is an object with either too many methods or too
    many properties; essentially, it's a class that knows too much or does too much.
    The God object soon becomes tightly coupled to (referenced by) lots of other bits
    of code in the application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，**上帝对象**是一个具有太多方法或太多属性的对象；本质上，它是一个知识过多或做得过多的类。上帝对象很快就会与应用程序中的许多其他代码紧密耦合。
- en: So what's actually wrong with this? Well, in short, when you have one bit of
    code tied into every single other bit of code, you quickly find a maintenance
    disaster. If you adjust the logic for a method in a God object for one use case,
    you might find it having unintended consequences for another element.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这到底有什么问题呢？简而言之，当您的一小段代码与每一小段其他代码都紧密联系在一起时，您很快就会发现维护成为一场灾难。如果您为上帝对象中的一个用例调整了方法的逻辑，您可能会发现它对另一个元素产生了意想不到的后果。
- en: In computer science, it is often a good idea to adopt a divide and conquer strategy.
    Often, big problems are just a set of little problems. By solving this set of
    little problems you can rapidly solve the overall problem. Objects should typically
    be self-contained; they should only know problems about themselves and also should
    only solve one set of problems, its own problems. Anything that isn't relevant
    to this aim doesn't belong in that class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，采用分而治之的策略通常是一个好主意。通常，大问题只是一系列小问题。通过解决这一系列小问题，您可以迅速解决整体问题。对象通常应该是自包含的；它们只应该了解自己的问题，并且只应该解决一组问题，即自己的问题。任何与此目标无关的东西都不应该属于该类。
- en: It can be argued that objects relating to physical objects should be instantiated,
    while those that don't should be abstract classes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，与物理对象相关的对象应该被实例化，而与物理对象无关的对象应该是抽象类。
- en: The flip side to God objects being an anti-pattern is when developing embedded
    systems. Embedded systems are used to process data on anything from a calculator
    to LED signage; they are small chips that are essentially self-contained computers
    and quite low cost. In this use case, with restricted computational power you
    can often find that programming elegance and maintainability become peripheral
    concerns. Slight performance increase and centralization of control can be more
    important, meaning using God objects can be somewhat sensible. Fortunately, PHP
    is incredibly seldom used to program embedded systems, so you are incredibly unlikely
    to find yourself in this particular situation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上帝对象作为反模式的反面是在开发嵌入式系统时。嵌入式系统用于处理从计算器到LED标识的任何数据；它们是基本上是自包含计算机且成本相当低的小芯片。在这种用例中，由于计算能力受限，您经常会发现编程优雅和可维护性变得边缘化。轻微的性能提升和控制的集中化可能更重要，这意味着使用上帝对象可能是合理的。幸运的是，PHP极少用于编程嵌入式系统，因此您极不可能陷入这种特殊情况。
- en: The most effective way of dealing with these classes is to split them into separate
    classes manually.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些类的最有效方法是手动将它们拆分为单独的类。
- en: Another anti-pattern, called *Fear of Adding Classes*, can also play a part
    in this, along with failing to mitigating it. This is where developers are reluctant
    to create necessary classes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个反模式，称为*害怕添加类*，也可能在其中发挥作用，以及未能加以缓解。这是开发人员不愿意创建必要的类。
- en: 'So, here''s an example of a God class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这是一个God类的例子：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, as you can see that in this class, we've basically combined lots of irrelevant
    methods. In order to fix this, we can split this class up into two sub-classes,
    one being a `Watch` class and the other being a `CacheManager` class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如你所看到的，在这个类中，我们基本上结合了许多不相关的方法。为了解决这个问题，我们可以将这个类分成两个子类，一个是`Watch`类，另一个是`CacheManager`类。
- en: 'Here is the `Watch` class; this class is simply intended to show us the time
    in various formats:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Watch`类；这个类只是用来以各种格式显示时间：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And here is the `CacheManager` class; this class separates all the cache''s
    functionality so it is entirely separate from the `Watch` class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`CacheManager`类；这个类将所有缓存功能分离出来，因此它与`Watch`类完全分离：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Environment variables in PHP source
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP源中的环境变量
- en: Far too often you come across a project on GitHub and you notice that the original
    developer has left in a `config.php` file that contains (in the best case) useless
    database information or (in the worst case) incredibly important API keys.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 经常你会在GitHub上遇到一个项目，你会注意到原始开发人员留下了一个包含（在最好的情况下）无用的数据库信息或（在最坏的情况下）非常重要的API密钥的`config.php`文件。
- en: When these files aren't accidentally versioned they are often shoved in a `.gitignore`
    file with a sample file attached for developers to amend as they need. One example
    of a platform that does this is WordPress.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些文件不小心被版本化时，它们通常会被塞进一个`.gitignore`文件中，并附上一个示例文件供开发人员根据需要修改。一个这样做的平台的例子是WordPress。
- en: There are some minor improvements to this, such as putting core configuration
    in an XML file that is buried in some obscure document with plenty of irrelevant
    configuration.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些小的改进，比如将核心配置放在一个XML文件中，这个文件被埋在一些不相关的配置中。
- en: I've found that there tend to be two good ways of managing environment variables
    in PHP. The first method involves putting them in a file on your `root` folder
    in a format such as YML and reading these variables as required.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现在PHP中管理环境变量通常有两种好方法。第一种方法是将它们放在`root`文件夹中的一个文件中，格式可以是YML，并根据需要读取这些变量。
- en: The second way, which I personally prefer, is a method implemented by a library
    known as `dotenv`. Essentially, what happens is there is a `.env` file is created
    and put in the room of your project. In order to read configuration from this
    file, you just need to call the `env()` function. You can then add this file to
    your `.gitignore` file so that when you push from your development environment
    and pull to various other server configurations this process is made easier. In
    addition to this, you can specify environment variables at the web server level,
    thus ensuring an additional level of security and also making management far easier.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法，我个人更喜欢的方法，是一个名为`dotenv`的库实现的方法。基本上，发生的情况是创建一个`.env`文件并将其放在项目的房间里。为了从这个文件中读取配置，你只需要调用`env()`函数。然后，你可以将这个文件添加到你的`.gitignore`文件中，这样当你从开发环境推送并拉到各种其他服务器配置时，这个过程会变得更容易。除此之外，你还可以在Web服务器级别指定环境变量，从而确保额外的安全级别，也使管理变得更容易。
- en: So, for example, if my .`env` file had a `DB_HOST` property, then I can access
    it using `env('DB_HOST');`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，例如，如果我的`.env`文件有一个`DB_HOST`属性，那么我可以使用`env('DB_HOST');`来访问它。
- en: If you do go down the `dotenv` route, be sure to make sure that your `.env`
    is not publically visible from the document root. Either keep it out of your public
    HTTP directory (for example, in the level above), or restrict access to it at
    a web server level (for example, restrict permissions, or if you're using Apache,
    use your `.htaccess` file to limit access to it).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了`dotenv`的路线，请确保你的`.env`文件不会从文档根目录公开可见。要么将它放在公共HTTP目录之外（例如，在上一级），要么在Web服务器级别限制对它的访问（例如，限制权限，或者如果你使用Apache，使用你的`.htaccess`文件限制对它的访问）。
- en: 'At the time of writing, you can require this library by simply running the
    following command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，你可以通过简单运行以下命令来要求这个库：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Soft Code** may often also be an anti-pattern that is adopted by using configuration
    files. This is where you start putting business logic in configuration files instead
    of source code; therefore, it is worth reminding yourself to consider when something
    really needs to be configuration oriented.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**软代码**也经常是一个反模式，通过使用配置文件来采用。这是你开始将业务逻辑放在配置文件中而不是源代码中；因此，值得提醒自己要考虑什么时候真正需要配置导向。'
- en: Singletons (and why you should be using dependency injection)
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例（以及为什么你应该使用依赖注入）
- en: Singletons are classes which can only be instantiated once. You can effectively
    only have one object per `Singleton` class in an application. If you've never
    heard of Singletons before you may jump into the air thinking "Yes! I have a million
    and one use cases for this!" Well, please don't. Singletons are just terrible
    and can be effectively avoided.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 单例是只能被实例化一次的类。在一个应用程序中，你实际上只能有一个`Singleton`类的对象。如果你以前从未听说过单例，你可能会跳起来想“是的！我有一百万个用例可以用这个！”好吧，请不要。单例只是糟糕透了，可以有效地避免使用。
- en: 'So, a `Singleton` class in PHP looks something like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在PHP中，`Singleton`类看起来像这样：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So here are the reasons why this should be avoided:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是应该避免这样做的原因：
- en: They are inherently tightly coupled meaning they are difficult to test, for
    example using unit tests. They even maintain their state throughout the life cycle
    of the application.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们本质上是紧密耦合的，这意味着它们很难进行测试，例如使用单元测试。它们甚至在应用程序的生命周期中保持它们的状态。
- en: They violate the Single Responsibility Principle by controlling their own creation
    and life cycle.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通过控制自己的创建和生命周期来违反单一责任原则。
- en: Fundamentally, it results in you hiding the dependencies of your application
    in a `global` instance. You can no longer effectively follow your dependencies
    around your code as you can't follow where they are injected as function arguments.
    They make it ineffective to find the dependency chain should you need to analyze
    it.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从根本上讲，这会导致你将应用程序的依赖关系隐藏在一个`global`实例中。你再也不能有效地跟踪你的代码中的依赖关系，因为你无法跟踪它们被注入为函数参数的位置。如果需要分析依赖链，这将使其变得无效。
- en: That said, some people argue they can be a valid solution to resource contention
    (where you need to only have a single instance of a resource and you need to manage
    that single resource).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，有些人认为它们可以是资源争用的有效解决方案（在这种情况下，你只需要一个资源的单个实例，并且需要管理该单个资源）。
- en: Dependency injection
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'Dependency injection is the antidote to Singletons. So, suppose you have a
    class that is called `Transaction`. As a constructor of the class, it accepts
    parameters called `$creditCardNumber` and `$clientID`, so therefore we can construct
    the object as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是对单例模式的解药。所以，假设你有一个名为`Transaction`的类。作为类的构造函数，它接受名为`$creditCardNumber`和`$clientID`的参数，因此我们可以构造对象如下：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using dependency injection, we would instead pass in objects of `$creditCard`
    and `$client` which would be instances of classes for the credit card and client.
    If you are using an ORM, this could be a database model class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖注入，我们将传入`$creditCard`和`$client`的对象，它们将是信用卡和客户的类的实例。如果你使用ORM，这可能是一个数据库模型类：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Database as IPC
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库作为IPC
- en: At the time of writing, I'm currently over the Atlantic, on my way from London
    to San Francisco, which is probably a good thing as it means my neck is decisively
    out of the reach of some previous developers I've worked with.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在写作时，我目前正在大西洋上空，从伦敦飞往旧金山，这可能是一件好事，因为这意味着我之前与之合作过的一些开发人员已经无法接触到我的颈部。
- en: Let me clear this up for you; your database isn't a message queuing system.
    You don't use it schedule jobs or queue up tasks to be completed. If you need
    something to do that, use a queuing system. Your database is for data...the clue
    is in the name; don't shove temporary messages in there.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我为你澄清一下；你的数据库不是一个消息队列系统。你不要用它来安排作业或排队等待完成的任务。如果你需要做这样的事情，使用一个队列系统。你的数据库是用来存储数据的...提示就在名字里；不要把临时消息塞进去。
- en: There are many reasons why this is a bad idea. One major issue is the fact that
    in databases there is no real way to not enforce a policy by which you can guarantee
    that a double-read will not occur, and that is by utilizing row locks. This in
    turn, results in processes (either incoming out outgoing) being blocked, which
    in turn results in processing only being able to be done in a serial fashion.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多原因说明这是一个坏主意。一个主要问题是，在数据库中，没有真正的方法来不执行一个策略，以确保不会发生双重读取，这是通过利用行锁来实现的。这反过来导致进程（无论是传入还是传出）被阻塞，这又导致处理只能以串行方式进行。
- en: Furthermore, in order to check if there is any work to do you end up essentially
    counting the rows of data in the database to see if there is work to do; you run
    this on a continuous basis. MySQL doesn't support push notifications; unlike PostgreSQL
    it doesn't have the `NOTIFY` command to pair with a `LISTEN` channel.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了检查是否有工作要做，你最终基本上要计算数据库中的数据行数，看是否有工作要做；你要持续进行这个操作。MySQL不支持推送通知；不像PostgreSQL那样有`NOTIFY`命令来配合`LISTEN`通道。
- en: Also note that when you merge a job queue with a database table that stores
    real data, you also invalidate the cache every time you complete a job and update
    a flag, in turn making MySQL far slower.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，当你将作业队列与存储真实数据的数据库表合并时，每次完成作业并更新标志时，都会使缓存失效，从而使MySQL变得更慢。
- en: In short, it results in your database performing worse and can force it to slow
    critical messages to a standstill. You must be careful not to turn your database
    into a job queue by having this functionality sneak up on you; instead, use the
    database exclusively for data, and bear this in mind when extending your database.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这会导致你的数据库性能变差，并可能迫使它将关键消息放缓到停滞状态。你必须小心，不要让这个功能悄悄地将你的数据库变成一个作业队列；相反，只使用数据库来存储数据，并在扩展数据库时牢记这一点。
- en: RabbitMQ provides an open source queuing system with some great PHP SDKs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ提供了一个带有一些出色的PHP SDK的开源队列系统。
- en: Auto-increment database IDs
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自增数据库ID
- en: Database auto-increment is something I find incredibly frustrating; pretty much
    every PHP/MySQL beginner tutorial teaches people to do this, but you really shouldn't.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库自增是我非常沮丧的事情；几乎每个PHP/MySQL初学者教程都教人们这样做，但你真的不应该这样做。
- en: I have got experience trying to shard auto-increment database IDs, and it's
    messy. Let's suppose you shard the database so the dataset over two database servers...how
    on earth can you expect someone to scale auto-increment IDs?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我有尝试对自增数据库ID进行分片的经验，这很混乱。假设你将数据库分片，使数据集分布在两个数据库服务器上...你怎么能指望有人来扩展自增ID呢？
- en: MySQL now even features a UUID function, allowing you to generate good IDs with
    strong entropy, meaning it also features a higher theoretical limit than auto-increment
    triggers on tables with an `int` data type.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL现在甚至提供了UUID函数，允许你生成具有强熵的良好ID，这意味着它在`int`数据类型的表上也具有更高的理论限制。
- en: In order to use the UUID function, the database table should ideally be a CHAR(20).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用UUID函数，数据库表理想上应该是CHAR(20)。
- en: Cronjob imitating service
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟服务的Cronjob
- en: This one is a personal hatred of mine. A developer needs a service to run indefinitely,
    so they just enable a cronjob that never ends, or simply have a cronjob that operates
    incredibly frequently (such as once every few seconds).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我个人的憎恶。开发人员需要一个无限运行的服务，所以他们只需启用一个永不结束的cronjob，或者只需设置一个运行非常频繁的cronjob（比如每隔几秒运行一次）。
- en: A cronjob is a scheduled job that will run at a predetermined time. It's not
    something that operates services for you. Not only is this messy from an architectural
    perspective, but it scales horribly and becomes terrible to monitor.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: cronjob是在预定时间运行的计划任务。这不仅从架构的角度看很混乱，而且扩展性很差，监控起来也很糟糕。
- en: A constantly processing task should be treated as a daemon and not as something
    that runs on the basis of a cronjob.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不断处理的任务应该被视为守护进程，而不是基于cronjob运行的东西。
- en: '**Monit** is a tool in Linux systems that allows you to imitate services.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**Monit**是Linux系统中的一个工具，允许您模拟服务。'
- en: 'You can install Monit using the `apt-get` command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`apt-get`命令安装Monit：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once Monit is installed, you can add processes to its configuration file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Monit后，您可以将进程添加到其配置文件中：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Monit can then be started by running the `monit` command. It also has a `status`
    command so you can verify it is still running:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以通过运行`monit`命令来启动Monit。它还有一个`status`命令，因此您可以验证它是否仍在运行：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can learn more about Monit and find out how to configure it at [http://www.mmonit.com](http://www.mmonit.com).
    It is a highly valuable tool for every DevOps focused developer to have in their
    armory.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://www.mmonit.com](http://www.mmonit.com)了解更多关于Monit的信息，并了解如何配置它。对于每个专注于DevOps的开发人员来说，这是一个非常有价值的工具。
- en: Software in place of architecture
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件代替架构
- en: Often, developers will seek to rectify a system's architectural issues at the
    software development level. While this has use cases, I am a huge fan of seeking
    to avoid this practice where it is not necessary. Moving issues from the software
    architecture layer to the infrastructure layer has its advantages.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开发人员会试图在软件开发层面纠正系统的架构问题。虽然这有用，但我非常赞成在不必要的情况下避免这种做法。将问题从软件架构层移至基础架构层具有其优势。
- en: For example, suppose you need to proxy a request for a particular URL endpoint
    off to another server. I believe this is best done at the web server level as
    opposed to writing a PHP proxy script. Apache and Nginx can both handle reverse
    proxying, but writing a library to do this may mean you come up against several
    unheard issues. Have you thought you that you'll handle `HTTP PUT`/`DELETE` requests?
    What about error handling? Assuming you nail your library, what about performance?
    Can a PHP proxy script really be faster than a web server level proxy, utilizing
    a web server written in a low-level systems engineering language? Surely one or
    two lines in your web server configuration is far easier to implement that an
    entire proxy script in PHP?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您需要代理特定URL端点的请求到另一台服务器。我认为最好在Web服务器级别完成这项工作，而不是编写一个PHP代理脚本。Apache和Nginx都可以处理反向代理，但编写一个库来做这个可能意味着您会遇到一些未知的问题。您有没有考虑过如何处理`HTTP
    PUT`/`DELETE`请求？错误处理呢？假设您的库很完美，性能如何？一个PHP代理脚本真的比使用低级系统工程语言编写的Web服务器级别代理更快吗？在Web服务器配置中写一两行肯定比在PHP中编写整个代理脚本更容易实现。
- en: 'Here''s an example of just how easy it is to create a proxy in a VirtualHost.
    The following configuration as an Apache VirtualHost will allow you to reroute
    everything from `test.local/api` to `api.local` (it''s even easier in Nginx):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在VirtualHost中创建代理的示例。以下配置作为Apache VirtualHost将允许您将`test.local/api`中的所有内容重定向到`api.local`（在Nginx中更容易）：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is far easier to maintain than thousands of lines of code in a PHP library
    that imitates something that is already available in the ProxyPass Apache module.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这比在PHP库中维护成千上万行代码来模拟ProxyPass Apache模块中已经可用的功能要容易得多。
- en: I've heard a criticism of microservices that they seek to move problems from
    the software development layer to the infrastructure layer, but are we really
    saying that that's always a bad thing?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我听说过对微服务的批评，认为它们试图将问题从软件开发层移至基础架构层，但我们真的在说这总是一件坏事吗？
- en: Yes, software developers have a vested interest in doing things at the software
    development layer, but it is often worth educating yourself about the functionality
    you have available higher up the chain and seeing if that can rectify any issues
    you are having.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，软件开发人员有兴趣在软件开发层面做事情，但通常值得让自己了解一下链条上更高层面可用的功能，并看看是否可以纠正您遇到的任何问题。
- en: 'Think in terms of Occam''s razor: the shortest solution is often the best,
    as it is translated literally "more things should not be used than are necessary."'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以奥卡姆剃刀的观点来思考：最简单的解决方案通常是最好的，因为它的字面意思是“不应该使用比必要更多的东西”。
- en: Interface Bloat
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 界面膨胀
- en: I have come across multiple instances of people thinking they're doing great
    architecture but it turns out their efforts turn out to be counterproductive.
    Interface Bloat is a common consequence of this.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到过多次人们认为他们在进行出色的架构，但结果证明他们的努力是适得其反。界面膨胀是这种情况的常见后果。
- en: Once, when I discussed the importance of Interfaces when doing polymorphism
    in PHP with a Scrum Master, he responded by telling me about an environment he
    once worked in where there was an engineer who spent months developing interfaces
    and thought he was doing brilliant architecture work. Unfortunately, it turns
    out he wasn't doing great infrastructure work, he was guilty of implementing Interface
    Bloat.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有一次，当我与一个Scrum Master讨论在PHP中进行多态时接口的重要性时，他告诉我他曾在一个环境中工作过，那里有一个工程师花了几个月时间开发接口，并认为自己在进行出色的架构工作。不幸的是，事实证明他并没有做出出色的基础架构工作，他实际上是在实现界面膨胀。
- en: Interface Bloat is, as the name suggests, is where an Interface is excessively
    bloated. An interface can be so bloated that it becomes practically impossible
    for a class to be implemented any other way.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 界面膨胀，正如其名，是指界面过度膨胀。界面可能膨胀到几乎不可能以其他方式实现类。
- en: Interfaces should be used sparingly; do you actually need an interface if the
    class is only ever going to be implemented once and once alone (and realistically,
    no one is never going to need to tamper with such code?). If so, you might want
    to consider avoiding an interface in such a situation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接口应该节俭使用；如果类只会被实现一次（实际上，没有人永远不需要修改这样的代码），那么你真的需要一个接口吗？如果需要，你可能要考虑在这种情况下避免使用接口。
- en: Interfaces should not be used as a means of testing unit functionality. In that
    situation you really should be using unit testing, for example, via PHPUnit. Even
    so, unit testing should test how a unit functions as opposed to being used as
    a tool to ensure no one edits your code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接口不应该被用作测试单元功能的手段。在这种情况下，你真的应该使用单元测试，例如通过PHPUnit。即使如此，单元测试应该测试一个单元的功能，而不是用作确保没有人编辑你的代码的工具。
- en: 'So, let me draw you to one implementation of Interface Bloat. Let''s take a
    look at the `Pheanstalk` interface class in the Pheanstalk open source library
    (note I have stripped the comments to make it more readable):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我给你举一个接口膨胀的实现。让我们看看Pheanstalk开源库中的`Pheanstalk`接口类（注意我已经删除了注释以使其更易读）：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Yuck! Notice how even constants have been put in the implement, the one thing
    you might actually want to change. Clearly, this is an interface for a class that
    can only be implemented one way, making the Interface useless.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 呸！注意即使常量也被放在了实现中，这可能是你真正想要更改的唯一事物。显然，这是一个只能以一种方式实现的类的接口，使接口变得无用。
- en: Interfaces provide a great degree of structure when writing object-oriented
    code; once implemented, they act as the guarantor that the methods in an interface
    have been implemented in a class that implements it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写面向对象的代码时，接口提供了很高程度的结构；一旦实现，它们作为保证，确保了实现它的类中的方法已经被实现。
- en: However, like most good things, it can be a double-edged sword. Someone once
    gave me an incredibly naive argument against architecture design; they cited one
    of their previous co-workers who spent months simply writing incredibly detailed
    Interfaces and thought it was great architecture. In fact, he was committing Interface
    Bloat.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像大多数好事一样，它可能是一把双刃剑。有人曾经用一个极其天真的论点反对架构设计；他引用了他以前的一位同事，后者花了数月时间仅仅编写了非常详细的接口，并认为这是很好的架构。事实上，他是在制造接口膨胀。
- en: Interfaces should not be a way of enforcing implementation; indeed, there are
    examples of interfaces that result in someone being faced with the problem of
    not ever actually being able to implement an interface into a class any other
    way.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接口不应该是强制实现的一种方式；事实上，有一些接口的例子导致某人面临的问题是永远无法以其他方式将接口实现到类中。
- en: Interfaces shouldn't contain thousands of methods that reference internal operations
    of the class. They should be lightweight and considered a way of guaranteeing
    that when something is queried that it is definitely there.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接口不应包含数千个引用类内部操作的方法。它们应该是轻量级的，并被视为一种保证，当查询某些内容时，它一定存在。
- en: There is an anti-pattern known as the **swiss army knife** (or **kitchen sink**)
    around the idea that people try to design interfaces to fit every possible use
    case of a class. This can cause debugging, documentation and maintenance difficulties.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个反模式被称为**瑞士军刀**（或**厨房水槽**），围绕着人们试图设计接口以适应类的每种可能的用例的想法。这可能会导致调试、文档编制和维护困难。
- en: Cart before the horse
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本末倒置
- en: Like most developers, I occasionally get bemused by some project management
    strategies; *putting the cart before the horse* is no exception.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数开发人员一样，我偶尔会对一些项目管理策略感到困惑；*本末倒置*也不例外。
- en: Putting the cart before the horse is an anti-pattern under which features that
    never need to be built are architected, thus wasting time. The particular setting
    this annoys me is in technical meetings discussing a long-term technical plan
    where a project manager will discuss a feature and immediately demand the technical
    details of how this feature could be implemented.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本末倒置是一个反模式，即被设计出来却永远不需要被构建的功能，从而浪费时间。这种情况让我感到恼火的是在技术会议上讨论长期技术计划时，项目经理会讨论一个功能，然后立即要求提供这个功能如何实现的技术细节。
- en: Firstly, it's important to note that good developers should go away and have
    research time to come up with a solution. A developer is only made stronger by
    the ability to research their intended solution, to break out with their development
    team, to look online for other people facing similar issues, and then to come
    back with a unified, well-architected solution.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是要注意，优秀的开发人员应该离开并有研究时间来提出解决方案。开发人员只有通过研究他们打算的解决方案，与开发团队一起讨论，在线查找其他人面临类似问题的情况，然后提出一个统一的、良好架构的解决方案，才能变得更加强大。
- en: 'I spoke at the inaugural Lead Developer conference in London, and there was
    one quote that stood out to me from listening to others talking at the event.
    It was reused from an African proverb, but is especially true in software engineering
    contexts:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾在伦敦的首届领导开发者大会上发言，有一句话让我印象深刻。这句话源自非洲谚语，但在软件工程环境中尤为真实：
- en: '*"If you want to go fast, go alone. If you want to go far, go together".*'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“如果你想走快，就一个人走。如果你想走远，就一起走。”*'
- en: Having spoken to managing directors and CEOs of various companies, they like
    to have a broad balance of personalities on their board of directors. A chief
    financial officer (CFO) may well be a ruthless perfectionist, only satisfied once
    all their figures are drop-dead perfect, whereas a chief operations officer may
    well be a fierce pragmatist when it comes to delivering on time. Such can be true
    in development teams; having a broad input of specialisms and personalities proposing
    ideas that are battled out to come up with a well-rounded solution can be beneficial
    for large decisions where a sole developer alone cannot be expected to make the
    decisions. Yes, you might want a filter or even say that only a small subsection
    of the development team may be relevant for one particular decision, but on the
    whole, your developers need the resources and time to make architectural decisions.
    Furthermore, the best place to make such architectural decisions is when they
    are most relevant, when it is necessary that they should be made.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经与各种公司的董事总经理和首席执行官交谈过，他们喜欢在董事会上拥有各种不同性格的人。首席财务官（CFO）可能是一个无情的完美主义者，只有在所有数字都完美无缺时才感到满意，而首席运营官可能在按时交付方面是一个强硬的实用主义者。在开发团队中也可能是如此；拥有广泛的专业知识和性格的输入，提出经过激烈讨论的想法，以得出一个全面的解决方案，对于需要做出大决策的情况是有益的，一个单独的开发人员无法期望做出决策。是的，你可能需要一个过滤器，甚至说只有开发团队的一小部分可能与某个特定决策相关，但总的来说，你的开发人员需要资源和时间来做出架构决策。此外，做出这种架构决策的最佳地点是在最相关的时候，当有必要做出这些决策时。
- en: Flat Earthers are people who believe that the earth is a flat disc. When confronted
    with the concept of gravity, they instead claim gravity doesn't exist and state
    that this flat earth is instead simply moving upwards in space at a speed of 9.8
    m/s. Confronted with further scientific theories they instead create their own
    illogically pieced together view of how the physical universe exists. Of course,
    such a theory is ridiculous. My point here is that you should base your decisions
    on sound computer science (e.g. published RFCs) instead of creating your own computer
    science on an ad-hoc basis.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 地平派是指相信地球是一个平坦圆盘的人。当他们面对重力概念时，他们宣称重力不存在，并声称这个平坦的地球实际上只是以每秒9.8米的速度在太空中上升。当面对更多的科学理论时，他们反而创造出自己的不合逻辑的物理宇宙观。当然，这样的理论是荒谬的。我在这里要说的是，你应该基于扎实的计算机科学（例如已发表的RFC）来做出决策，而不是根据临时基础上的自己的计算机科学。
- en: Separation of development and operations
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发和运营的分离
- en: I have encountered development environments where developers are expressly forbidden
    from doing anything at all operational, where traditional development structure
    is relentlessly battered by the 21st-century web environment. There were caged
    job roles; you were either a developer or you looked after hosting. They had separate
    budgets, despite the fact both departments had a clear common destiny.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经遇到过开发环境，开发人员明令禁止进行任何操作，传统的开发结构在21世纪的网络环境中受到了严重打击。有着固定的工作角色；你要么是开发人员，要么是负责托管。尽管两个部门有着明显的共同命运，但它们有着独立的预算。
- en: The result of this kind of setup was that developers and operations technicians
    never shared knowledge. By combining development and operations (DevOps, if you
    will) there is not only an effective boost in the quality of the work delivered
    through a shared knowledge base, but efficiency increases by empowering developers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置的结果是开发人员和运营技术人员从未共享知识。通过结合开发和运营（如果你愿意，就叫做DevOps），不仅可以通过共享知识库有效提高工作质量，而且通过赋予开发人员更多的权力，还可以提高效率。
- en: In the example I gave, when a site hosted on a company server was hacked or
    vandalized, all operations would do was restore from a backup. Combining development
    efforts into this mix not only resulted in vulnerabilities being patched, but
    also effective measures being put into hosting environments to rectify these issues
    (be they brute-force plugins or web application firewalls).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我提到的例子中，当公司服务器上托管的网站被黑客入侵或破坏时，所有运营部门所做的就是从备份中恢复。将开发工作整合到这一过程中不仅导致了漏洞的修补，还采取了有效措施来纠正这些问题（无论是暴力插件还是网络应用防火墙）。
- en: Excessive separation of development responsibilities
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过分分离的开发责任
- en: Development responsibilities being split too blatantly can be detrimental to
    a team.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 过分明显地分割开发责任可能对团队有害。
- en: Some separation is necessary. For example, teams working with **Internet of
    Things** (**IoT**) platforms cannot be expected to maintain a strong electronics
    engineering knowledge and a strong frontend web development knowledge. That said,
    developers should be expected to learn other skills they encounter and this can
    be assisted by encouraging knowledge sharing. Having multi-disciplined team members
    is not a business disadvantage, indeed it is an advantage.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有些分离是必要的。例如，与物联网（IoT）平台合作的团队不能指望他们既能保持强大的电子工程知识，又能保持强大的前端网页开发知识。也就是说，开发人员应该期望学习他们遇到的其他技能，并且可以通过鼓励知识共享来帮助他们。拥有多学科团队成员并不是商业劣势，事实上这是一个优势。
- en: Error suppression operator
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误抑制运算符
- en: The error suppression operator in PHP is a very dangerous tool indeed. Simply
    by putting an at symbol, `@`, in front of a statement, you can suppress any errors
    that result from it, including fatal errors that stop the execution of a script.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中的错误抑制运算符确实是一个非常危险的工具。只需在语句前面加上一个`@`符号，就可以抑制由此产生的任何错误，包括导致脚本停止执行的致命错误。
- en: Unfortunately, this cannot necessarily be deprecated yet in PHP; having spoken
    to those in the PHP internals group, it is the case that there is a whole lot
    of prerequisite work that would need to be done first as some PHP functions do
    not have companion error functions to yield the error in the execution of a PHP
    script. As a result of this, the only way to show a non-fatal error that does
    not necessarily stop the execution of a script is to catch the error that is thrown
    during the operation of that particular function
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，目前在PHP中还不能废弃这一点；与PHP内部组的成员交谈后得知，首先需要做大量的先决工作，因为一些PHP函数没有伴随的错误函数来产生在执行PHP脚本时的错误。因此，唯一的方法是捕获在特定函数操作期间抛出的非致命错误，这样就不会停止脚本的执行。
- en: The PHP core unfortunately, contains a considerable amount of technical debt
    in and of itself. Unfortunately, one thing that a good PHP developer should be
    good at is spotting technical debt in the PHP core itself. Indeed, Facebook tried
    to bypass this problem by rewriting the PHP core themselves and calling it **Hak**;
    I shall leave you to decide on whether you should consider adopting it or not.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，PHP核心本身包含相当多的技术债务。不幸的是，一个优秀的PHP开发人员应该擅长发现PHP核心中的技术债务。事实上，Facebook试图通过自己重写PHP核心并称其为**Hak**来规避这个问题；我将让你决定是否应该考虑采用它。
- en: One feature I have quite enjoyed in developing in Go (a systems language written
    by Google) is the fact you can do multiple return types (for example, you can
    return two values from one function). This has the added benefit of meaning that
    instead of having a companion function that will return the error message you
    can simply return any errors in a single function call.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中我非常喜欢的一个特性（这是Google编写的一种系统语言）是你可以进行多返回类型（例如，你可以从一个函数返回两个值）。这样做的额外好处是，你可以简单地在一个函数调用中返回任何错误，而不是需要一个返回错误消息的伴随函数。
- en: Another thing I do like in Go is the fact that all warnings are treated as errors.
    You assign a variable, then don't use it? The program will fail to run (unless
    you assign a variable to an underscore, `_`, which is a null assignment operator
    meaning the variable will not be stored anywhere). Treating warnings as errors
    has the result of meaning that when a developer encounters an error, they know
    it's serious.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我在Go中也喜欢的一点是所有警告都被视为错误。你赋值给一个变量，然后不使用它？程序将无法运行（除非你将变量赋值给下划线`_`，这是一个空赋值运算符，意味着变量不会被存储在任何地方）。将警告视为错误的结果是，当开发人员遇到错误时，他们知道这是严重的。
- en: 'So yes, PHP can learn a lot from languages such as Go, but fundamentally, it
    is clear that there is also a lot of work that already needs to be done on the
    PHP core, and in addition to this, the PHP community may well need a culture shift
    to being more open and less political. **PHP RFC: Adopt Code Of Conduct** proposed
    that PHP should adopt a *Code of Practice.* Needless to say, if this is adopted
    in some form the PHP community should benefit.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '所以是的，PHP可以从诸如Go之类的语言中学到很多东西，但基本上，很明显PHP核心已经需要做很多工作，而且除此之外，PHP社区可能需要进行文化转变，更加开放，少一些政治色彩。**PHP
    RFC: 采用行为准则**提出PHP应该采用*行为准则*。不用说，如果以某种形式采用，PHP社区应该会受益。'
- en: Turning back to the issue at hand, error suppression operators should be avoided
    unless strictly necessary in the interest of making debugging far easier for developers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 回到手头的问题，应该避免使用错误抑制运算符，除非绝对必要，以便使开发人员更容易进行调试。
- en: Blind faith
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 盲目信任
- en: Once when I was around 11 years old I was sitting in a physics lesson with a
    limited quantity of protractors and we were slowly passing them around in order
    to draw an angle. Being the devious short cutter that I was at such a young age,
    I decided not to wait and just trace a drawing someone else made. This was to
    the horror of my physics teacher at the time who stopped dead in his tracks and
    shouted "NO! PHYSICS IS ABOUT ACCURACY!"
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我大约11岁的时候，在一节物理课上，我们只有有限数量的量角器，我们慢慢地把它们传递下去，以便画出一个角度。作为一个年轻时的狡猾捷径者，我决定不等待，而是直接复制了别人画的图。当时我的物理老师惊呆了，大声喊道：“不行！物理是关于精确的！”
- en: He had a point and this is something that is also very true in the programming
    world.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 他说得有道理，这在编程世界中也是非常真实的。
- en: 'To avoid *blind faith*, you should be aware of the following mistakes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免*盲目信任*，你应该注意以下错误：
- en: Failure to check return types
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未检查返回类型
- en: Failure to check your data models
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未检查你的数据模型
- en: Assuming data within your database is correct or is in the format you expect
    it to be
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设你的数据库中的数据是正确的，或者是你期望的格式
- en: 'Let''s take this to a more extreme level; take this code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个问题提升到更极端的程度；看看这段代码：
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, there are two key mistakes. The first mistake is that
    we're directly extracting `GET` variables; we're importing remotely defined variables
    into the current symbol table, effectively allowing anyone to override any variables
    defined before the extract.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，有两个关键错误。第一个错误是我们直接提取`GET`变量；我们将远程定义的变量导入到当前符号表中，有效地允许任何人覆盖在提取之前定义的任何变量。
- en: Also, there is obviously an XSS vulnerability in that we are returning a `GET`
    variable without sanitizing it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，显然存在XSS漏洞，因为我们在返回`GET`变量时没有对其进行消毒处理。
- en: 'So here''s how we can make it better:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以这样改进：
- en: '[PRE19]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Sequential coupling
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顺序耦合
- en: '**Sequential coupling** is where you create a class that has methods that must
    be called in a particular order. Method names that start with `init`, `begin`,
    or `start` may be indicative of this behavior; this may be indicative of an anti-pattern
    depending on the context. Sometimes, engineers use cars to explain abstract concepts,
    here I''ll do the same.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**顺序耦合**是指创建一个类，该类具有必须按特定顺序调用的方法。以`init`、`begin`或`start`开头的方法名称可能表明这种行为；根据上下文，这可能表明一种反模式。有时，工程师使用汽车来解释抽象概念，在这里我也会这样做。'
- en: 'For example, take the following class:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看下面的类：
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you may note, we have to run the `startCar` function before we can use any
    of the other functions, or an exception is thrown. Really, if you try to accelerate
    a car that is not started, it shouldn''t do anything, but for the sake of argument
    I''ve changed it so that the car will simply start first. In the next example
    of stopping the car, I have changed the class so that the method will return `false`
    if you try to stop the car without it running first:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能注意到的，我们必须在使用其他函数之前运行`startCar`函数，否则会抛出异常。实际上，如果您尝试加速未启动的汽车，它不应该做任何事情，但是为了论证的目的，我已经更改了它，以便汽车首先会启动。在停止汽车的下一个示例中，我已更改了类，以便如果您尝试在汽车未运行时停止汽车，该方法将返回`false`：
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The big rewrite
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大改写
- en: One temptation of developers is to rewrite an entire codebase. There are pros
    and cons for you to decide, and yes, it is often harder to read existing code
    than it is to write new code; but please do bear in mind that rewrites take time
    and can be hugely costly for your business.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员的一个诱惑是重写整个代码库。您需要权衡利弊，是的，阅读现有代码通常比编写新代码更困难；但请记住，重写需要时间，对您的业务可能造成巨大成本。
- en: Always bear in mind that the sum of your technical debt from any one project
    can never be greater than starting the project from scratch.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，任何项目的技术债务总和永远不会超过从头开始启动项目。
- en: 'Maiz Lulkin wrote the following in a brilliant blog post:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Maiz Lulkin在一篇博客文章中写道：
- en: '*"The problem of big rewrites is that they are a technical solution to a cultural
    problem."*'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “大改写的问题在于它们是对文化问题的技术解决方案。”
- en: Big rewrites are horribly inefficient, especially when you simply cannot guarantee
    that developers will know any better now. Architecting the new system and migrating
    the data inside the deadlines can be a tall order.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 大改写非常低效，特别是当您无法保证开发人员现在会更好时。在截止日期内设计新系统并迁移数据可能是一项艰巨的任务。
- en: In addition to this, deploying the big rewrite can be hugely problematic; deploying
    such a change to the entire codebase of an application can be lethal. Try to deploy
    code regularly in frequent intervals. Try to change one thing at a time.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，部署大改写可能会带来巨大问题；将这样的更改部署到应用程序的整个代码库可能是致命的。尝试定期在频繁的间隔内部署代码。尝试一次更改一件事。
- en: Your software that exists is your existing specification. By building a rewrite,
    you are building code on the basis of legacy code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您现有的软件就是您现有的规范。通过进行重写，您正在基于遗留代码构建代码。
- en: 'Fortunately, there is an alternative; rapidly improving your current code base
    in cycles. There are three primary steps you can take to improve your code base:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，还有一种替代方法；在周期中快速改进您当前的代码库。您可以采取三个主要步骤来改进您的代码库：
- en: Tests (unit tests, behavioral tests, and so on)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试（单元测试、行为测试等）
- en: Service splitting
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务拆分
- en: Perfectly staged migrations
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完美的分阶段迁移
- en: There is a chapter in this book dedicated to refactoring and how we can alter
    the design of legacy code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本书有一章专门讲述重构以及我们如何改变遗留代码的设计。
- en: Automated tests
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化测试
- en: You need tests; yes, automated tests can be slow to write, but they are crucial
    for ensuring things don't break when you rewrite or refactor them.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要测试；是的，编写自动化测试可能会很慢，但对于确保重写或重构时不会出现问题至关重要。
- en: It is also mission-critical that your tests and development occur on an environment
    that is as close to production as possible. Small changes in web server software
    or database permissions can have disastrous consequences.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和开发发生在尽可能接近生产环境的环境中也至关重要。Web服务器软件或数据库权限的微小变化可能会产生灾难性后果。
- en: Using an automated deployment system such as Vagrant with Puppet or Docker can
    be a great solution.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动化部署系统，如Vagrant与Puppet或Docker，可能是一个很好的解决方案。
- en: 'When doing unit tests with PHPUnit and Composer, you can just include it in
    your `composer.json` file to pull it in:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用PHPUnit和Composer进行单元测试时，您可以将其包含在`composer.json`文件中以引入：
- en: '[PRE22]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In addition to this, a `phpunit.xml` file may also be useful so that PHPUnit
    knows where the tests are, but also where the Composer autoloader is (so it can
    go ahead and pull in classes):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，`phpunit.xml`文件也可能很有用，这样PHPUnit就知道测试在哪里，还知道Composer自动加载器在哪里（这样它就可以继续引入类）：
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can then write tests as you normally would in PHPUnit, for example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以像在PHPUnit中一样编写测试：
- en: '[PRE24]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Except, of course, you have the added benefit of being able to pull in PHP classes
    in your autoloader as you need them.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您还可以在需要时将PHP类引入自动加载器，从而获得额外的好处。
- en: Not all tests need to be unit tests. Writing external test scripts to test APIs
    can be beneficial too. A tool called **Selenium** ([http://www.seleniumhq.org](http://www.seleniumhq.org))
    can even help you with browser automation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有测试都需要是单元测试。编写外部测试脚本来测试API也可能很有益。一个名为**Selenium**（[http://www.seleniumhq.org](http://www.seleniumhq.org)）的工具甚至可以帮助您进行浏览器自动化。
- en: Service splitting
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务拆分
- en: Splitting your monolith into small independent loosely coupled services is a
    great way to reduce technical debt.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的单体应用程序拆分为小的独立松耦合服务是减少技术债务的好方法。
- en: Large monolith applications which have technical debt rooting right into the
    core of the application can be problematic to deal with. Building on top of such
    unstable foundations can be tough to split up later. There is a solution, however;
    by building new functionality as independent services you can effectively build
    on a new core with a stable foundation, diverging from your old weak infrastructure.
    You can then intercommunicate this with the old monolith and such new services
    using a RESTful structure.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 具有技术债务的大型单体应用程序可能很难处理，因为技术债务根植于应用程序的核心。在这样不稳定的基础上构建可能很难以后拆分。然而，有一个解决方案；通过构建独立服务的新功能，您可以有效地在稳定的基础上构建新的核心，与旧的脆弱基础设施分道扬镳。然后，您可以使用RESTful结构与旧的单体和这样的新服务进行互联。
- en: This structure allows you to continue developing new functionality while migrating
    to a new microservices architecture.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构允许您在迁移到新的微服务架构的同时继续开发新功能。
- en: Martin Fowler proposed a system known as **Branch by Abstraction**, which allows
    you to make the large-scale change to systems in a gradual way, which allows you
    to continue to release while change is still being conducted.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 马丁·福勒提出了一种称为**分支抽象**的系统，它允许您逐渐对系统进行大规模的更改，同时可以继续发布。
- en: The first step is to capture the interaction between one section of client code
    and its supplier; we can then change that section of the code so it all inter-communicates
    via an abstraction layer.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是捕捉客户端代码的一个部分与其供应商之间的交互；然后我们可以更改代码的这一部分，使其通过一个抽象层进行相互通信。
- en: We then do this for interactions with the supplier. As we do this, we take the
    opportunity to improve unit test coverage. Once a supplier isn't in use at all,
    we can migrate the clients over to use the supplier instead and delete the old
    supplier.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对与供应商的交互进行同样的操作。在这样做的同时，我们有机会提高单元测试覆盖率。一旦一个供应商完全不再使用，我们可以将客户端迁移到使用该供应商，然后删除旧的供应商。
- en: Perfectly staged migrations
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完美的分阶段迁移
- en: Splitting your monolith into small independent loosely coupled services is a
    great way to reduce technical debt, but in this process, you clearly add extra
    burden to the architectural level.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的单体架构拆分为小型独立松耦合的服务是减少技术债务的好方法，但在这个过程中，您显然增加了对架构层面的额外负担。
- en: When migrating data or hosting environments, you might come across difficulties
    in this process. This is particularly true when the deployment process isn't repeated
    and is unique for each deployment (such as in environments that don't use Continuous
    Integration).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移数据或托管环境时，您可能会在这个过程中遇到困难。当部署过程不重复并且对每个部署都是独特的时，这一点尤为真实（例如在不使用持续集成的环境中）。
- en: 'Using container technology such as Docker can allow you to better perform rapid
    application deployments, allowing you to deploy faster while also increasing portability
    and simplifying maintenance. Some people may find other technologies, such as
    Vagrant, more beneficial for them; regardless, there is a common factor in all
    these technologies: infrastructure as code.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用诸如Docker之类的容器技术可以让您更好地进行快速应用程序部署，使您能够更快地部署，同时增加可移植性并简化维护。一些人可能会发现其他技术，如Vagrant，对他们更有利；不过，所有这些技术都有一个共同的因素：基础设施即代码。
- en: '**Infrastructure as code** is the process of managing and provisioning computing
    infrastructure through code instead of interactive configuration tools; however,
    what we are after here is even more basic than this. What we want is to be able
    to stage and test migrations of any kind before the fact and re-run the exact
    process when we perform the migration.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础设施即代码**是通过代码管理和配置计算基础设施的过程，而不是通过交互式配置工具；然而，我们在这里追求的比这更基本。我们想要能够在事实之前分阶段和测试任何类型的迁移，并在执行迁移时重新运行确切的过程。'
- en: By scripting migrations, you can test them beforehand just like code. You can
    be sure when it's done on a live server instead of a staging server there's a
    reduced chance of any mistakes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过脚本化迁移，您可以像代码一样事先测试它们。您可以确保在实际服务器上完成时，与在暂存服务器上相比，减少了任何错误的机会。
- en: In addition to this, the migrations can later be used to reverse engineer the
    process should a factor in the deployment cause problems later, or so the justifications
    for decisions can be seen. It essentially acts as an artifact for the software
    deployment process.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，迁移后可以用于在部署中出现问题时逆向工程该过程，或者可以看到决策的理由。它实质上充当了软件部署过程的工件。
- en: Where possible, as many resources as possible should be available during this
    process; this includes those deploying the code, developers who put the project
    together, and in extreme cases, a communications individual to keep clients up
    to date. Those resources allow rapid debugging of those issues, but it is vital
    that an individual deploying the code takes the lead and orchestrates when these
    resources are required in order to prevent distractions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，应尽可能多地提供资源；这包括部署代码的人员、组装项目的开发人员，以及在极端情况下，一个沟通人员来及时更新客户。这些资源可以快速调试问题，但至关重要的是，部署代码的个人必须主导并协调这些资源的使用，以防止分散注意力。
- en: Working to a formal pre-planned routine, while also allowing room to correct
    any issues, can often help make deployments as painless as possible.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 按照正式的预先计划的程序工作，同时也留有纠正任何问题的空间，通常可以帮助使部署尽可能无痛。
- en: Tester-Driven Development
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: This is a tongue-in-cheek reference to **Test-Driven Development** (**TDD**).
    TDD is a software development strategy largely revolving around using development
    tests to drive implementation towards fulfilling the requirements.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对**测试驱动开发**（**TDD**）的一种半开玩笑式引用。TDD是一种软件开发策略，主要围绕使用开发测试来驱动实现以满足需求。
- en: Tester-Driven Development, however, is where the requirements are the shortcut
    and it becomes the case that the software team starts specifying the requirements
    through bug reports. Tester-Driven Development can also be referred to as **Bug-Driven
    Development** as it essentially results in bug reports being used to specify actions
    and features that developers should implement.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，测试驱动开发是指需求是一种捷径，软件团队开始通过错误报告来指定需求。测试驱动开发也可以称为**错误驱动开发**，因为它实质上导致错误报告被用来指定开发人员应该实现的操作和功能。
- en: For example, a developer builds a tool to export data from a database to a spreadsheet.
    It works perfectly, but a tester still comes back and raises a ticket saying that
    there is a bug in the product; they say that it doesn't contain the ability to
    export to PDF. If this wasn't in the requirements it shouldn't be raised as a
    bug. And yes, you should have requirements.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，开发人员构建了一个工具，用于将数据库中的数据导出到电子表格中。它运行得很完美，但测试人员仍然回来提出了一个问题，说产品中存在一个错误；他们说它没有包含导出到PDF的功能。如果这不在需求中，就不应该被提出作为错误。是的，您应该有需求。
- en: QA teams and testers exist to verify that software meets the requirements. They
    do not exist to specify the requirements themselves.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: QA团队和测试人员的存在是为了验证软件是否符合要求。他们的存在并不是为了规定要求本身。
- en: Bloated optimization
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 臃肿的优化
- en: Often, developers may trip over themselves trying to optimize their code or
    their design artifacts to a ridiculous extent, often before their code even performs
    basic functions, or even before any code has been created at all. This can rapidly
    perform issues in production.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开发人员可能会在试图过度优化他们的代码或设计工件时自相矛盾，甚至在他们的代码甚至没有执行基本功能之前，甚至在任何代码被创建之前。这可能会迅速在生产中出现问题。
- en: 'In this section, I wish to discuss three anti-patterns specifically relating
    to this topic:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我想专门讨论与这个主题相关的三种反模式：
- en: Analysis paralysis
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析瘫痪
- en: Bikeshedding
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无关紧要的争论
- en: Premature optimization
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过早的优化
- en: Analysis paralysis
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析瘫痪
- en: In short, this is where a strategy is over-analyzed to the point where progress
    is slowed down, or even stopped entirely in extreme cases. Not only can such solutions
    become obsolete rapidly, they can be made in under-educated circumstances, for
    example, in a meeting where an over-analytic boss tries to dig too deep into detail
    in advance without allowing their developers to actually do some research.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这就是一个策略被过度分析到进展被减缓甚至在极端情况下完全停滞的地方。这样的解决方案不仅可能迅速过时，而且可能是在教育不足的情况下做出的，例如，在一个过度分析的老板试图在允许他们的开发人员实际进行一些研究之前就过于深入细节的会议上。
- en: Over-analyzing a problem and seeking a perfect solution upfront just does not
    work; programmers should seek to refine their solution, not come up with the refined
    solution up front.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 过度分析问题并试图提前寻求完美解决方案是行不通的；程序员应该寻求完善他们的解决方案，而不是提前想出完善的解决方案。
- en: Bikeshedding
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无关紧要的争论
- en: Essentially, this is where analysis paralysis can occur on the basis of some
    very trivial decisions, for example, the color of a log in page. The only fix
    that's required is to not waste time on trivial decisions. Avoid design by committee
    where possible as the majority of people, regardless of how good they think their
    design skills are, are largely incompetent at design.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这就是分析瘫痪可能发生的地方，基于一些非常琐碎的决定，例如登录页面的颜色。唯一需要修复的是不要浪费时间在琐碎的决定上。尽量避免委员会决策，因为大多数人，无论他们认为自己的设计技能有多好，在设计上都是相当无能的。
- en: Premature optimization
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过早的优化
- en: In this section, so far, I've largely beaten up project managers; no time to
    beat up developers. Often, developers will seek to optimize their code prematurely
    without having educated data-led conclusions to drive where and when optimizations
    should be made.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这一部分，我主要是在批评项目经理；没有时间去批评开发人员。通常，开发人员会试图过早地优化他们的代码，而没有经过教育的数据驱动的结论来驱动何时何地进行优化。
- en: Writing clean and readable code is your first priority; then you can use some
    great profiling tools to determine where your bottlenecks are. XDebug and New
    Relic are just some of the tools that are good at this.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 编写清晰易读的代码是你的首要任务；然后你可以使用一些很棒的性能分析工具来确定你的瓶颈在哪里。XDebug和New Relic只是一些擅长这方面的工具。
- en: That said, there are some cases where optimization must be done, particularly
    on some long computational tasks where it can be mission-critical to reduce something
    from O(N2) time to O(N). This said, most simple PHP web apps will have no real
    need to use this consideration.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，有些情况下必须进行优化，特别是在一些长时间的计算任务上，从O(N2)时间减少到O(N)可能是至关重要的。也就是说，大多数简单的PHP Web应用程序不需要考虑这一点。
- en: Uneducated manager syndrome
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未受教育的经理综合症
- en: Has your manager ever built a web app themselves? I find that this is a fairly
    important characteristic for a manager to have. The same way a junior doctor will
    report to a doctor who has been through the process of being a junior doctor themselves,
    or a teacher will report to a head teacher who themselves has been a teacher,
    a software developer should report to someone who has been through that process
    themselves.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你的经理有没有亲自构建过Web应用程序？我发现这是一个经理必须具备的相当重要的特征。就像初级医生会向曾经经历过初级医生过程的医生汇报一样，或者老师会向曾经是老师的校长汇报一样，软件开发人员应该向曾经经历过这个过程的人汇报。
- en: Obviously, in small teams (for example, a small design house that does web development
    on the side), an engineering manager might not be strictly necessary. This works
    well where managers do understand the need to defer decisions to the programmers
    where necessary. However, as soon as things scale up, there needs to be structure.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在小团队中（例如，一个小型设计公司在业余时间进行Web开发），可能并不严格需要工程经理。这在经理明白必要时需要把决策推迟给程序员的情况下运作良好。然而，一旦事情扩大，就需要有结构。
- en: Decisions such as who to hire, who to fire, how to address technical debt, which
    elements need most focus, and so on, need to be taken by developers; in addition
    to this, they sometimes mustn't be taken democratically because doing so would
    result in design by committee. In this instance, an engineering manager is required.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如谁来雇佣，谁来解雇，如何解决技术债务，哪些元素需要最关注等决定，需要由开发人员来做；此外，有时候这些决定不应该民主地做，因为这样做会导致委员会决策。在这种情况下，需要一个工程经理。
- en: In large scale teams, there should always be a developer who spends more than
    90% of their time not writing code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模团队中，应该总有一个开发人员花费超过90%的时间不是在编写代码。
- en: I will take this a step further; a web engineering manager shouldn't just have
    a technical background, they should have a web background. Developing a Java application
    developer can be wholly different to building a PHP web application, and such
    an engineering manager should accordingly have an understanding of such a discipline
    by having some web experience (though it doesn't necessarily have to be in one
    particular language).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我将进一步深入；一个Web工程经理不应该只有技术背景，他们应该有Web背景。开发Java应用程序开发人员可能与构建PHP Web应用程序完全不同，因此这样的工程经理应该通过一些Web经验来理解这样的学科（尽管不一定要在一种特定的语言中）。
- en: Wrong rocky foundations
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误的基础
- en: 'The SensioLabs Insight tool was used to evaluate technical debt within various
    projects, and they evaluated and published the responses. SensioLabs responded
    on their blog saying that the results didn''t account for project age or project
    size, but nevertheless it does show the technical debt you''re up against in using
    some frameworks as foundations:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: SensioLabs Insight工具被用来评估各种项目中的技术债务，并且他们评估并发布了响应。SensioLabs在他们的博客上回应说，结果没有考虑项目的年龄或项目的大小，但无论如何，它确实显示了在使用某些框架作为基础时你所面临的技术债务：
- en: '![Wrong rocky foundations](graphics/image_02_001.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![错误的基础](graphics/image_02_001.jpg)'
- en: 'Don''t get me wrong: WordPress is a great CMS; yes, it has some quirks in the
    core and comes from the days before OOP, but it''s a great blogging platform.
    You ordinarily shouldn''t be fiddling with it''s core code, so you don''t need
    to worry about it. By no means should you write your own blogging platform or
    CMS, but at the same time, WordPress isn''t the right problem for building a marketing
    asset system or an insurance quote generator (yes, both are real projects I have
    been asked to do in WordPress initially).'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 不要误会：WordPress是一个很棒的CMS；是的，它在核心部分有一些怪癖，并且来自OOP之前的时代，但它是一个很棒的博客平台。通常情况下，你不应该去摆弄它的核心代码，所以你不需要担心它。当然，你不应该编写自己的博客平台或CMS，但与此同时，WordPress也不适合构建营销资产系统或保险报价生成器（是的，这两个都是我最初被要求在WordPress中完成的真实项目）。
- en: 'In short: use the best foundations for your task.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之：为你的任务使用最佳基础。
- en: Long methods
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长方法
- en: 'Methods can be overly complicated in some instances with PHP; for example,
    in the following class I have intentionally left out some meaningful comments
    and also made the constructor excessively long:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，PHP中的方法可能过于复杂；例如，在下面的类中，我故意省略了一些有意义的注释，并且构造函数过长：
- en: '[PRE25]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let''s make just two small changes; let''s extract some of our methods
    into their own functions and let''s add some DocBlock comments. This is still
    by no means perfect, but note the difference that is made:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们做两个小改变；让我们将一些方法提取到它们自己的函数中，并添加一些DocBlock注释。这仍然并不完美，但请注意所做的区别：
- en: '[PRE26]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Long methods are an indicator of code smell; they refer to a symptom in the
    code that may have its origins in a deeper problem. Other examples include duplicate
    code and contrived complexity (using advanced design patterns where a simpler
    approach would suffice).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 长方法是代码异味的指标；它们指的是代码中可能存在更深层问题的症状。其他例子包括重复的代码和人为的复杂性（在更简单的方法可以满足的情况下使用高级设计模式）。
- en: Magic numbers
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 魔术数字
- en: 'Note how in the preceding example I always put my constant numeric variables
    in class constants, as opposed to directly putting them in the code itself:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的例子中，我总是将我的常量数值变量放在类常量中，而不是直接放在代码中：
- en: '[PRE27]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The reason I did this was to avoid an anti-pattern known as **magic numbers** or
    **unnamed numerical constants**. Using class constants makes code easier to read,
    understand, and maintain; and of course, under the PSR standards, they should
    be declared in uppercase, separated by underscores.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我这样做的原因是为了避免一种被称为**魔术数字**或**未命名的数值常量**的反模式。使用类常量可以使代码更易于阅读、理解和维护；当然，在PSR标准下，它们应该以大写字母分隔下划线的形式声明。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we covered some fundamental anti-patterns for you to avoid;
    some were architectural, some were PHP-related, and others were at the management
    layer.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些基本的反模式，供你避免；有些是架构上的，有些是与PHP相关的，还有一些是在管理层上的。
- en: Fundamentally, anti-patterns result in technical debt. By technical debt, we
    are talking about code that is so hard to extend that it becomes harder to make
    changes to later on.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，反模式会导致技术债务。所谓技术债务，指的是代码难以扩展，以至于以后更改变得更加困难。
- en: 'Here''s a list of things I want you to do to fix this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我希望你做的事情清单：
- en: Plan before you start coding
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始编码之前制定计划
- en: Make comments, and add a comment where the purpose of your code isn't immediately
    apparent
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 做注释，并在你的代码目的不明显时添加注释
- en: Make sure your code has structure
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你的代码有结构。
- en: Try to avoid putting too much code in one method
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量避免将太多的代码放在一个方法中
- en: Use DocBlocking
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DocBlock
- en: Use common sense approaches to PHP
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用常识方法来处理PHP
- en: In this chapter, we have learned some common design issues that can lead to
    severe problems; these principles can help you prevent sizable issues later on.
    Writing code to scale is an important factor of design. At its core, this requires
    understanding the constraints. Using proper strategies for inter-process communication
    can help your service scale while writing loosely coupled code can increase code
    reuse and debugging. Finally, when it comes to deploying this awesome code, automated
    testing and Perfectly Staged Migrations can make sure this goes off without a
    hitch.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一些常见的设计问题，这些问题可能导致严重的问题；这些原则可以帮助你在以后避免重大问题。编写可扩展的代码是设计的一个重要因素。在其核心，这需要理解约束。使用适当的进程间通信策略可以帮助你的服务扩展，编写松耦合的代码可以增加代码重用和调试。最后，在部署这个令人敬畏的代码时，自动化测试和完美的分阶段迁移可以确保一切顺利进行。
- en: In the next chapters, we will move on to covering some design patterns (presumably,
    what you've been waiting for).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将继续介绍一些设计模式（大概是你一直在等待的）。
- en: If you are interested in learning about how to improve the design of an existing
    codebase, you might find the dedicated chapter on refactoring in this book particularly
    interesting; but it's worth reading up on the other design patterns first in order
    to gain an understanding of the patterns we are trying to refactor towards.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣了解如何改进现有代码库的设计，你可能会发现本书中关于重构的专门章节特别有趣；但是在阅读其他设计模式之前，了解我们试图朝着重构的模式是值得的。
