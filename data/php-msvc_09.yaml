- en: Chapter 9. From Monolithic to Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。从单块到微服务
- en: In this chapter, we will look at some possible strategies to follow when we
    have to transform a monolithic application into microservices, along with some
    examples. This process can be a little difficult if we already have a big and
    complex application, but fortunately, there are some well-known strategies that
    we can follow in order to avoid problems throughout this process.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在必须将单块应用程序转换为微服务时可以遵循的一些可能策略，以及一些示例。如果我们已经有一个庞大而复杂的应用程序，这个过程可能会有点困难，但幸运的是，有一些众所周知的策略可以遵循，以避免在整个过程中出现问题。
- en: Refactor strategies
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构策略
- en: The process of transforming a monolithic application into microservices is a
    refactor code in order to modernize your application. This should be done incrementally.
    Trying to transform the entire application into microservices in one step could
    cause problems. Little by little, it will create a new application based on microservices
    and finally, your current application will disappear because it will be transformed
    into little microservices leaving the original application empty or maybe it will
    also be a microservice.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将单块应用程序转换为微服务的过程是为了重构代码，以使您的应用程序现代化。这应该是逐步进行的。试图一步将整个应用程序转换为微服务可能会导致问题。逐渐地，它将创建一个基于微服务的新应用程序，最终，您当前的应用程序将消失，因为它将被转换为小的微服务，使原始应用程序变为空或者也可能成为一个微服务。
- en: Stop diving
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止潜水
- en: When your application is already a hole, you have to stop diving in that hole.
    In other words, stop making your monolithic application bigger. This is when you
    have to implement a new functionality, it is necessary to create a new microservice
    and connect it to the monolithic application instead of continuing developing
    the new functionalities in the monolith.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用程序已经是一个洞时，您必须停止潜水。换句话说，停止让您的单块应用程序变得更大。这是当您必须实现一个新功能时，需要创建一个新的微服务并将其连接到单块应用程序，而不是继续在单块中开发新功能。
- en: 'To do this, when a new functionality is implemented, we will have the current
    monolith, the new functionality, and also two more things:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，当实现新功能时，我们将有当前的单块、新功能，以及另外两个东西：
- en: '**Router:** This is responsible for the HTTP requests; in other words, this
    is like a gateway that knows where it needs to send every request, either to the
    old monolith or to the new functionality.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由器：**这负责处理HTTP请求；换句话说，这就像一个网关，知道需要将每个请求发送到哪里，无论是旧的单体还是新功能。'
- en: '**Glue code:** This is responsible for connecting the monolithic application
    to the new functionality. It is very common for the new functionality to need
    to access the monolithic application in order to get data or any necessary functions
    from it:![Stop diving](graphics/B06142_09_01.jpg)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粘合代码：**这负责将单块应用程序连接到新功能。新功能通常需要访问单块应用程序以获取数据或任何必要的功能：![停止潜水](graphics/B06142_09_01.jpg)'
- en: Stop diving strategy
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 停止潜水策略
- en: 'Regarding glue code, there are 3 different possibilities to access the application
    from the new functionality to the monolith:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 关于粘合代码，有3种不同的可能性可以从新功能访问应用程序到单块：
- en: Create an API on the monolith side to be consumed by the new function
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单体侧创建一个API，供新功能使用
- en: Connect directly with the monolith database
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接连接单块数据库
- en: Have a synchronized monolith copy of the database on the functionality side
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在功能方面有一个与单块数据库同步的副本
- en: As you can see, this strategy is a pretty way to start developing microservices
    in your current monolithic application. In addition, the new functionality can
    scale, deploy, and develop in an isolated way from the monolith, improving your
    application. However, this does not solve the problem, it just avoids making the
    current problem any bigger, so let’s take a look at two more strategies.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这种策略是在当前的单块应用程序中开始开发微服务的一种不错的方式。此外，新功能可以独立于单块进行扩展、部署和开发，从而改进您的应用程序。然而，这并不能解决问题，只是避免让当前问题变得更大，所以让我们再看看另外两种策略。
- en: Divide frontend and backend
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离前端和后端
- en: 'Another strategy is to divide the logic presentation part from the data access
    layer. An application usually has at least 3 different parts:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略是将逻辑呈现部分与数据访问层分开。一个应用程序通常至少有3个不同的部分：
- en: '**Presentation layer:** This is the user interface, in other words, the HTML
    language of a website'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**呈现层：**这是用户界面，换句话说，是网站的HTML语言'
- en: '**Business logic layer:** This consists of the components used to implement
    the business rules'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务逻辑层：**这由用于实现业务规则的组件组成'
- en: '**Access data layer:** This has components that have access to the database'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问数据层：**这包含访问数据库的组件'
- en: There is usually a separation between the presentation layer and the business
    logic and access data layers. The business layer has an API that has one or more
    facades that encapsulate the business logic components. From this API, it is possible
    to divide the monolith into 2 smaller applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常呈现层和业务逻辑以及访问数据层之间有一个分离。业务层具有一个API，其中有一个或多个封装业务逻辑组件的门面。从这个API，可以将单块分成2个较小的应用程序。
- en: 'After the division, the presentation layer makes calls to the business logic.
    Take a look at the following example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 分割后，呈现层调用业务逻辑。看下面的例子：
- en: '![Divide frontend and backend](graphics/B06142_09_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![分离前端和后端](graphics/B06142_09_02.jpg)'
- en: Divide frontend and backend strategy
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 分离前端和后端策略
- en: 'This division has 2 different advantages:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分割有两个不同的优势：
- en: It allows you to scale and develop two different and isolated applications
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许您扩展和开发两个不同和独立的应用程序
- en: It provides you with an API that can be consumed for future microservices
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为您提供了一个可以供未来微服务使用的API
- en: The problem with this strategy is that it is only a temporary solution, it can
    be transformed into one or two monolithic applications, so let's look at the next
    strategy in order to remove the rest of the monolith.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略的问题在于它只是一个临时解决方案，它可以转变为一个或两个单体应用程序，因此让我们看看下一个策略，以便移除剩余的单体应用程序。
- en: Extraction services
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取服务
- en: The last strategy is about isolating modules from the resultant or resultants
    monoliths. Little by little, we can extract modules from it and make a microservice
    from every module. Once we have all the important modules extracted, the resultant
    monolith will also be a microservice or it will even disappear. The general idea
    is to create logical groups of features that will be your future microservices.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的策略是从结果单体应用程序中隔离模块。我们可以逐步从中提取模块，并从每个模块创建一个微服务。一旦我们提取了所有重要的模块，结果单体应用程序也将成为一个微服务，甚至可能消失。总体思路是创建将成为未来微服务的功能的逻辑组。
- en: A monolithic application usually has many potential modules to be extracted.
    The priority must be set by selecting the easier ones first and then the most
    beneficial ones. The easier ones will give you necessary experience in extracting
    modules into microservices to do it with the important ones later.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用程序通常有许多潜在的模块可以提取。优先级必须通过首先选择更容易的模块，然后选择最有益的模块来设置。更容易的模块将为您提供必要的经验，以将模块提取为微服务，以便稍后处理重要的模块。
- en: 'Here are some tips to help you choose the most beneficial ones:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些提示，以帮助您选择最有益的模块：
- en: Modules that change frequently
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经常变化的模块
- en: Modules that require different resources to the monolith
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要与单体应用程序不同资源的模块
- en: Modules that require expensive hardware
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要昂贵硬件的模块
- en: It is useful to look for the existing coarse-grained boundaries, they are easier
    and cheaper to convert to microservices.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找现有的粗粒度��界是有用的，它们更容易且更便宜转换为微服务。
- en: How to extract a module
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何提取模块
- en: Now, let's look at how to extract a module, we will use an example to make the
    explanation a little easier to understand. Imagine that your monolithic application
    is a blog system. As you can imagine, the core functionality is the posts that are
    created by users and each post supports comments. As you can see from our small
    description, you can define the different modules of your application and decide
    which is the most important.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何提取一个模块，我们将使用一个示例来使解释更容易理解一些。想象一下，您的单体应用是一个博客系统。正如您可以想象的那样，核心功能是用户创建的帖子，每个帖子都支持评论。从我们的简要描述中可以看出，您可以定义应用程序的不同模块，并决定哪个最重要。
- en: 'Once you have the description and features of your application clear, you can
    continue with the general steps used to extract a module from your monolithic
    application:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您清楚了应用程序的描述和功能，就可以继续使用用于从单体应用程序中提取模块的一般步骤：
- en: Create an interface between the module and the monolith code. The best solution
    is a bidirectional API, because the monolith will need data from the module and
    the module will need data from the monolith. This process is not easy, you will
    probably have to change code from the monolithic application in order to make
    the API work.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块和单体代码之间创建一个接口。最佳解决方案是双向API，因为单体应用程序将需要来自模块的数据，而模块将需要来自单体应用程序的数据。这个过程并不容易，您可能需要更改单体应用程序的代码，以使API正常工作。
- en: Once the coarse-grained interface is implemented, convert the module into an
    isolated microservice.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦实现了粗粒度接口，将模块转换为独立的微服务。
- en: For example, imagine that the `POST` module is the candidate to be extracted,
    their components are used by the `Users` and `Comments` modules. As the first
    step says, it is necessary to implement a coarse-grained API. The first interface
    is an entry API used by `Users` to invoke the `POST` module and the second one
    is used by `POST` in order to invoke `Comments`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下`POST`模块是要被提取的候选模块，它们的组件被`Users`和`Comments`模块使用。正如第一步所说，需要实现一个粗粒度的API。第一个接口是由`Users`用来调用`POST`模块的入口API，第二个接口是由`POST`用来调用`Comments`的。
- en: In the second step of the extraction, convert the module to an isolated microservice.
    Once this is done, the resulting microservice will be scalable and independent,
    so it will be possible to make it grow or even to write it from scratch.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在提取的第二步中，将模块转换为独立的微服务。一旦完成，生成的微服务将是可扩展和独立的，因此可以使其增长，甚至从头开始编写。
- en: Little by little, the monolith will be smaller and your application will have
    more microservices.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步，单体应用程序将变得更小，您的应用程序将拥有更多的微服务。
- en: 'Tutorial: From monolithic to microservices'
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 教程：从单体应用到微服务
- en: In this chapter's examples, we will not use a framework and the code will be
    written without using a MVC architecture in order to focus on the subject of this
    chapter and learn how to transform a monolithic application into microservices.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，我们将不使用框架，并且将不使用MVC架构编写代码，以便专注于本章的主题，并学习如何将单体应用程序转换为微服务。
- en: There is no better way to learn something than by practicing, so let's look
    at an entire example of a blog platform that we defined in the previous section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 没有比实践更好的学习方法了，因此让我们看一个完整的博客平台示例，这是我们在前一节中定义的。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The blog platform example can be downloaded from our PHP microservices repository,
    so if you want to follow our steps, it is possible to do so by downloading it
    and following this guide.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 博客平台示例可以从我们的PHP微服务存储库中下载，因此，如果您想跟随我们的步骤，可以通过下载并按照本指南进行操作。
- en: 'Our example is a basic blog platform with the minimum functionalities to go
    through this tutorial. It is a blog system that allows the following things:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例是一个基本的博客平台，具有最低限度的功能，可以通过本教程。这是一个允许以下操作的博客系统：
- en: Registering new users
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册新用户
- en: Logging in users
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户登录
- en: Admins can post new articles
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员可以发布新文章
- en: Registered users can post new comments
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册用户可以发布新评论
- en: Admins can create new categories
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员可以创建新类别
- en: Admins can create new articles
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员可以创建新文章
- en: Admins can manage the comments
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员可以管理评论
- en: All the users can see the articles
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有用户都可以看到文章
- en: 'So, the first step in transforming a monolithic application into microservices
    is to familiarize yourself with the current application. In our imaginary schema,
    the current application can be divided into the following microservices:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将单块应用程序转换为微服务的第一步是熟悉当前应用程序。在我们的想象中，当前应用程序可以分为以下微服务：
- en: Users
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户
- en: Articles
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文章
- en: Comments
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论
- en: Categories
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类别
- en: It is pretty clear in this example, but in a real example it should be studied
    deeply in order to divide the project into little microservices that will do specific
    functions by following the priorities we explained earlier in the chapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中很清楚，但在一个真实的例子中，应该深入研究，以便按照我们在本章中之前解释的优先级将项目划分为小的微服务，这些微服务将通过执行特定功能来完成任务。
- en: Stop diving
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止潜水
- en: Now that we know how to follow the strategy that we explained before, imagine
    that we want to add a new functionality to send private messages between users
    in our blog platform.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何按照之前解释的策略进行操作，想象一下我们想要在我们的博客平台中添加一个新功能，即在用户之间发送私人消息。
- en: To figure this out, we need to know which functionalities will have the new
    sending private messages feature in order to find where the glue code and the
    request to get information (routes) from the new microservice should be.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了弄清楚这一点，我们需要知道新的发送私人消息功能将具有哪些功能，以便找到粘合代码和从新微服务获取信息（路由）的请求所在的位置。
- en: 'So, the functionalities of the new microservices can be as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，新微服务的功能可以如下：
- en: Sending a message to a user
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户发送消息
- en: Reading your messages
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读你的消息
- en: As you can see, these functionalities are very basic, but remember that this
    is only to familiarize yourself with the process of creating a new microservice
    in a monolithic application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这些功能非常基本，但请记住，这只是为了让你熟悉在单块应用程序中创建新微服务的过程。
- en: 'We will create the private messages microservices and, of course, we will use
    Lumen again. To quickly create the skeleton, run the following command on your
    terminal:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建私人消息微服务，并且当然，我们将再次使用Lumen。为了快速创建骨架，在终端上运行以下命令：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command will create a folder with Lumen installed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将创建一个带有Lumen安装的文件夹。
- en: In the [Chapter 2](ch02.html "Chapter 2. Development Environment"), *Development
    Environment*, we explained how to create Docker containers. Now, you have the
    chance to use everything you have learned and implement the monolithic and the
    different new microservices in the Docker environment. Based on the previous chapters,
    you should be able to do this on your own.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章.开发环境")中，我们解释了如何创建Docker容器。现在，你有机会运用你学到的一切，在Docker环境中实现单块和不同的新微服务。根据前面的章节，你应该能够自己做到这一点。
- en: Our new feature needs a place to store the private messages, so we will now
    create the table to be used by the private messages microservices. This can be
    created in a separate database or even in the same application's database. Remember
    that microservices can share the same database if the situation allows it, but
    imagine that this microservice will have a lot of traffic, so it is a better solution
    for us to have it in a separate database.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新功能需要一个存储私人消息的地方，所以现在我们将创建私人消息微服务将使用的表。这可以在单独的数据库中创建，甚至可以在同一个应用程序的数据库中创建。请记住，如果情况允许，微服务可以共享同一个数据库，但想象一下，这个微服务将会有很多流量，所以对我们来说，最好的解决方案是将其放在一个单独的数据库中。
- en: 'Create a new database or connect with the application database and execute
    the following query:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的数据库或连接应用程序数据库并执行以下查询：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once we have created the table, it is necessary to connect the new microservice
    to it, so open the `.env.example` file and modify the following lines:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了表，就需要将新的微服务连接到它，所以打开`.env.example`文件并修改以下行：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If your database is different, change it in the preceding code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据库不同，请在上述代码中进行更改。
- en: 'Rename the `.env.example` file to `.env` and change the `$app->run();` code
    to the following one on the `public/index.php` file; this will allow you to make
    calls to this microservice:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将`.env.example`文件重命名为`.env`，并将`$app->run();`代码更改为`public/index.php`文件中的以下代码；这将允许你调用这个微服务：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, you can check that your microservice is working properly on Postman by
    making a GET call to `http://localhost/private_messages/public/`. Remember to
    make all the required changes to match your development infrastructure.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过在Postman上进行GET调用`http://localhost/private_messages/public/`来检查你的微服务是否正常工作。记得对你的开发基础设施进行所有必要的更改。
- en: You will receive a 200 status code with the Lumen version installed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你将收到一个带有安装的Lumen版本的200状态码。
- en: 'In our microservice, we will need to include at least the following calls:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的微服务中，我们至少需要包括以下调用：
- en: 'GET `/messages/user/id`: This is required to get the messages that a user has'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET `/messages/user/id`：这是获取用户的消息所需的
- en: 'POST `/message/sender/id/recipient/id`: This is required to send a message
    to a user'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST `/message/sender/id/recipient/id`：这是向用户发送消息所需的
- en: 'So, now we will create the routes on `/private_messages/app/Http/routes.php`
    by adding the following lines at the end of the `routes.php` file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们将在`/private_messages/app/Http/routes.php`上创建路由，通过在`routes.php`文件的末尾添加以下行：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next step is to create a controller, called `MessageController`, on `/app/Http/Controllers/MessageController.php`
    with the following content:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在`/app/Http/Controllers/MessageController.php`上创建一个名为`MessageController`的控制器，并包含以下内容：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we have to tell Lumen that it is necessary to use the database, so uncomment
    the following lines on `/bootstrap/app.php`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须告诉Lumen需要使用数据库，所以取消注释`/bootstrap/app.php`中的以下行：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can create both the functionalities:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建这两个功能：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once our methods are complete, the microservice is finished. So, now we have
    to connect the monolithic application to the private messages microservice.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的方法完成，微服务就完成了。因此，现在我们必须将单块应用程序连接到私人消息微服务。
- en: 'We need to create a new button for the registered users on the `header.php`
    file of the monolithic application:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在单体应用程序的`header.php`文件中为注册用户创建一个新按钮：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we need to create a new file, called `messages.php`, in the `root` folder
    with the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在`root`文件夹中创建一个名为`messages.php`的新文件，其中包含以下代码：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, we are making a `curl` call to the microservice in order to
    get the user message list. Also, we need to get the user list to fill the user
    selector for sending messages. This piece of code can be considered as glue code because
    it is necessary to match the microservice data with the monolith data. We will
    use the following glue code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正在调用微服务以获取用户消息列表。此外，我们需要获取用户列表以填充发送消息的用户选择器。这段代码可以被视为粘合代码，因为需要将微服务数据与单体数据匹配。我们将使用以下粘合代码：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we can build the html code to display the user messages and the necessary
    form for sending messages:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建HTML代码来显示用户消息和发送消息所需的表单：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that there is a form for sending messages, so we have to add some code
    to make a call to the microservice in order to send the message. Add the following
    code after the `$messages = json_decode($result, true);` line:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有一个用于发送消息的表单，因此我们必须添加一些代码来调用微服务以发送消息。在`$messages = json_decode($result,
    true);`行后添加以下代码：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That's it. We have our first microservice included in the monolithic application.
    This is how to proceed when we have to add a new functionality in a current monolithic
    application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们的第一个微服务已经包含在单体应用程序中。这就是在当前的单体应用程序中添加新功能时的操作方式。
- en: Divide frontend and backend
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前端和后端分离
- en: The second strategy, as we said before, consists of isolating the presentation
    layer from the business logic. This can be done by creating an entire microservice
    that includes all the business logic and data access or simply by isolating the
    presentation layer from the business layer, like a **Model-View-Controller** (**MVC**)
    structure does.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，第二种策略是将表示层与业务逻辑隔离开来。这可以通过创建一个包含所有业务逻辑和数据访问的完整微服务来实现，也可以通过将表示层与业务层隔离开来实现，就像**模型-视图-控制器**（**MVC**）结构一样。
- en: This is not a complete solution for the problem of using monolithic applications
    because it results in us having two monolithic applications instead of one.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是使用单体应用程序的问题的完整解决方案，因为这将导致我们有两个单体应用程序，而不是一个。
- en: 'To do this, we should start by creating a new `Controller.php` file in the
    `root` folder. We can call this class `Controller` and it will contain all the
    methods that the views need. For example, the `Article` view needs `getArticle`,
    `postComment`, and `getArticleComments`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们应该首先在`root`文件夹中创建一个新的`Controller.php`文件。我们可以将这个类称为`Controller`，它将包含视图需要的所有方法。例如，`Article`视图需要`getArticle`，`postComment`和`getArticleComments`：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The article view should include the methods included in the `Controller.php`
    file. Take a look at the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 文章视图应包含`Controller.php`文件中包含的方法。看一下以下代码：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These are the steps that we should follow in order to isolate the business logic
    layer from the views.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们应该遵循的步骤，以便将业务逻辑层与视图隔离开来。
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want, you can put all the view files (`header.php`, `footer.php`, `index.php`,
    `article.php`, and so on) into a folder called `views` in order to have them organized
    in the same folder.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以将所有视图文件（`header.php`，`footer.php`，`index.php`，`article.php`等）放入一个名为`views`的文件夹中，以便在同一个文件夹中组织它们。
- en: Once we have all the views isolated from the business logic, we will have all
    the methods included in the controller instead of having them in the presentation
    layer. As we said before, this is only a temporary solution, so we will look at
    the real solution in order to extract the modules into microservices.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将所有视图与业务逻辑隔离开来，我们将在控制器中包含所有方法，而不是在表示层中包含它们。正如我们之前所说，这只是一个临时解决方案，因此我们将寻找真正的解决方案，以将模块提取为微服务。
- en: Extraction services
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取服务
- en: In this strategy, we have to select the first module that we want to isolate
    in order to make a microservice from it. In this case, we will start doing it
    on the `Categories` module.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种策略中，我们必须选择要隔离的第一个模块，以便从中制作一个微服务。在这种情况下，我们将从`Categories`模块开始做。
- en: The categories are most used on the admin panel. It is possible to create, modify,
    and delete categories from it and then, it is possible to select them when creating
    a new article and they are displayed in the articles to indicate the article category.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类别在管理员面板上使用最多。可以在其中创建、修改和删除类别，然后在创建新文章时选择它们，并在文章中显示以指示文章类别。
- en: The extraction process is not easy; we have to ensure that we are aware of all
    the places the module is being used at. To do this, we will create a bidirectional
    API or create all the category methods in the controller and then, we can isolate
    them in a microservice.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 提取过程并不容易；我们必须确保我们知道模块被使用的所有地方。为了做到这一点，我们将创建一个双向API或在控制器中创建所有类别方法，然后将它们隔离在一个微服务中。
- en: 'Open the `admin/categories.php` file, we have to do the same as we did with
    the divide frontend and backend strategy--find all the places where the categories
    are referenced and create a new method on the controller. Take a look at this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`admin/categories.php`文件，我们必须做与前端和后端分离相同的事情--找到所有引用类别的地方，并在控制器上创建一个新方法。看一下这个：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `controller.php` file has to contain the category methods:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`controller.php`文件必须包含类别方法：'
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are more references to categories in the `admin/articles.php` file, so
    open it and add the following lines after the `require_once` lines:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`admin/articles.php`文件中有更多关于类别的引用，因此打开它并在`require_once`行后添加以下行：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'These lines will allow you to use the category methods included in the `controller.php`
    file in the `articles.php` file. Modify the code used to get the categories to
    this one:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行将允许您在`articles.php`文件中使用`controller.php`文件中包含的类别方法。将用于获取类别的代码修改为以下代码：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finally, it is necessary to make some changes on the article view. This is the
    view to display an article, and it contains the category selected when creating
    the article.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要对文章视图进行一些更改。这是用于显示文章的视图，并且在创建文章时包含所选的类别。
- en: 'To get an article, the executed query is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取文章，执行的查询如下：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, the query requires the categories table. If you want to use
    a different database for the categories microservice, you will have to remove
    the highlighted line from the query, select `articles.category_id` in the query
    and then, get the category name with the method created to provide it. So, the
    query will look like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，查询需要类别表。如果要为类别微服务使用不同的数据库，您将需要从查询中删除突出显示的行，选择查询中的`articles.category_id`，然后使用创建的方法获取类别名称。因此，查询将如下所示：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is the code to get the category name from the provided category
    ID:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从提供的类别ID获取类别名称的代码：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once we have made all of these changes, we are ready to isolate the category
    table in a different database, so we can create a categories microservice from
    the created methods in the `controller.php` file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进行了所有这些更改，就可以将类别表隔离到不同的数据库中，因此我们可以从`controller.php`文件中创建的方法创建一个类别微服务：
- en: '`public function createCategory($name)`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public function createCategory($name)`'
- en: '`public function updateCategory($id,$name)`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public function updateCategory($id,$name)`'
- en: '`public function deleteCategory($id)`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public function deleteCategory($id)`'
- en: '`public function getCategories()`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public function getCategories()`'
- en: '`public function getCategory($id)`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public function getCategory($id)`'
- en: As you would imagine, these functions are used to create the `routes.php` file
    of the categories microservice. So, let's create a new microservice like we did
    with the stop diving strategy.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所想象的那样，这些函数用于创建类别微服务的`routes.php`文件。因此，让我们创建一个新的微服务，就像我们使用停止潜水策略一样。
- en: 'Create the new categories microservice by executing the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令创建新的类别微服务：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding command will install Lumen in a folder called categories, so we
    can start creating the code for our new categories microservice.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在名为categories的文件夹中安装Lumen，因此我们可以开始创建新类别微服务的代码。
- en: Now we have two options--the first one is to use the same table located on the
    current database--we can point the new microservice to the current database. The
    second option is to create a new table in a new database, so the new microservice
    will use its own database.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个选项--第一个是使用位于当前数据库上的相同表--我们可以将新微服务指向当前数据库。第二个选项是在新数据库中创建一个新表，因此新微服务将使用自己的数据库。
- en: 'If we want to create a new table in a new database, we can proceed as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在新数据库中创建一个新表，可以按照以下步骤进行：
- en: Export the current categories table in a SQL file. It will keep the current
    data stored.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将当前类别表导出到SQL文件中。它将保留当前存储的数据。
- en: Import the SQL file to the new database. It will create the exported table and
    data in the new database.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将SQL文件导入新数据库。它将在新数据库中创建导出的表和数据。
- en: Tip
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The export/import process can be performed using a SQL client or by executing
    `mysqldump` in console.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 导出/导入过程可以使用SQL客户端执行，也可以通过控制台执行`mysqldump`。
- en: 'Once the new table is imported to a new database or you decide to use the current
    database, it is necessary to set up the `.env.example` file in order to connect
    the new microservice to the correct database, so open it and put the correct parameters
    on it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新表被导入到新数据库，或者您决定使用当前数据库，就需要设置`.env.example`文件，以便将新微服务连接到正确的数据库，因此打开它并在其中放入正确的参数：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Do not forget to rename the `.env.example` file to `.env` and change the `$app->run()`
    line on `public/index.php`, like we did earlier to the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将`.env.example`文件重命名为`.env`，并在`public/index.php`中更改`$app->run()`行，就像我们之前所做的那样，更改为以下代码：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Also, uncomment the following lines on `/bootstrap/app.php`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 还要取消注释`/bootstrap/app.php`中的以下行：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we are ready to add the necessary methods to the `routes.php` file. We
    have to add the category methods that we have on the `Controller.php` of the monolithic
    application and translate them to routes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备在`routes.php`文件中添加必要的方法。我们必须添加单体应用程序`Controller.php`中的类别方法，并将它们转换为路由：
- en: '`public function createCategory($name)`: This is a POST method for creating
    a new category. So, it can be something like `$app->post(''category'', ''CategoryController@createCategory'');`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public function createCategory($name)`: 这是用于创建新类别的POST方法。因此，它可能类似于`$app->post(''category'',
    ''CategoryController@createCategory'');`。'
- en: '`public function updateCategory($id,$name)`: This is a PUT method to edit an
    existing category. So, it can be something like `app->put(''category/{id}'', ''CategoryController@updateCategory'');`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public function updateCategory($id,$name)`: 这是一个PUT方法，用于编辑现有的类别。因此，它可能类似于`app->put(''category/{id}'',
    ''CategoryController@updateCategory'');`。'
- en: '`public function deleteCategory($id)`: This is a DELETE method for deleting
    an existing category. So, it can be something like `app->delete(''category/{id}'',
    ''CategoryController@deleteCategory'');`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public function deleteCategory($id)`: 这是用于删除现有类别的DELETE方法。因此，它可能类似于`app->delete(''category/{id}'',
    ''CategoryController@deleteCategory'');`。'
- en: '`public function getCategories()`: This is a GET method for getting all the
    existing categories. So, it can be something like `app->get(''categories'', ''CategoryController@getCategories'');`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public function getCategories()`: 这是用于获取所有现有类别的GET方法。因此，它可能类似于`app->get(''categories'',
    ''CategoryController@getCategories'');`。'
- en: '`public function getCategory($id)`: This is a GET method too, but this only
    gets a single category. So, it can be something like `app->get(''category/{id}'',
    ''CategoryController@getCategory'');`.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public function getCategory($id)`: 这也是一个GET方法，但它只获取一个单一的类别。因此，它可能类似于`app->get(''category/{id}'',
    ''CategoryController@getCategory'');`。'
- en: 'So, once we have all our routes added to the `routes.php` file, it is time
    to create the category model. To do this, create a new folder on `/app/Model`
    and a file on `/app/Model/Category.php`, like this one:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦我们在`routes.php`文件中添加了所有路由，就是创建类别模型的时候了。要做到这一点，在`/app/Model`中创建一个新文件夹和一个文件`/app/Model/Category.php`，就像这样：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once we have created the model, create a `/app/Http/Controllers/CategoryController.php`
    file with the necessary methods:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模型后，创建一个`/app/Http/Controllers/CategoryController.php`文件，其中包含必要的方法：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, we have finished our categories microservice. You can give it a try on
    Postman in order to check that all the methods work. For example, the `getCategories`
    method can be called by Postman with the `http://localhost/categories/public/categories`
    URL.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了我们的类别微服务。您可以在Postman中尝试一下，以检查所有方法是否有效。例如，可以通过Postman使用`http://localhost/categories/public/categories`
    URL调用`getCategories`方法。
- en: Once we have the new categories microservice created and working properly, it
    is time to disconnect the categories module and connect the monolithic application
    to the microservice.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了新的类别微服务并且正常工作，就是时候断开类别模块并将单体应用程序连接到微服务了。
- en: Go back to the monolithic application and find all the references to the category
    methods. We have to replace them by making calls to the new microservice. We will
    make these calls using native curl calls, but you should consider using Guzzle
    or a similar package instead, as we did in the previous chapters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到单体应用程序并查找所有对类别方法的引用。我们必须通过调用新的微服务来替换它们。我们将使用原生curl调用进行这些调用，但是您应该考虑使用Guzzle或类似的包，就像我们在之前的章节中所做的那样。
- en: 'To do this, firstly we should create a function to make the calls in the `Controller.php`
    file. It can be something like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先我们应该在`Controller.php`文件中创建一个函数来进行调用。可以是这样的：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code will be used in order to reuse code in every single call
    to the categories microservice.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将用于在每次调用类别微服务时重用代码。
- en: 'Go to the `/admin/categories.php` file and replace the `controller->createCategory($name);` line
    with the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`/admin/categories.php`文件并用以下代码替换`controller->createCategory($name);`行：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, you can check that we are making a POST call to the create
    category method with the value parameter set to the `$name` variable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，您可以检查我们正在使用POST调用创建类别方法，并将值参数设置为`$name`变量。
- en: 'In the `/admin/categories.php` file, find and replace the `controller->updateCategory($id,
    $name);` line with the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/admin/categories.php`文件中，找到并用以下代码替换`controller->updateCategory($id, $name);`行：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the same file, find and replace `$controller->deleteCategory($_GET[''del'']);`
    with the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，找到并用以下代码替换`$controller->deleteCategory($_GET['del']);`：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the same file again and also in the `/admin/articles.php` file, find and
    replace `$arrCategories = $controller->getCategories();` with the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，再次以及在`/admin/articles.php`文件中，找到并用以下代码替换`$arrCategories = $controller->getCategories();`：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The last one is located in the `/admin/categories.php` file again. Find and
    replace the `row = $controller->getCategory($_GET[''id'']);` line with the following
    code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个位于`/admin/categories.php`文件中。找到并用以下代码替换`row = $controller->getCategory($_GET['id']);`行：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once we have finished replacing all the category methods on the monolithic application
    with calls to the new categories microservice, we can delete all the references
    to the monolithic category module.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了在单体应用程序中用新的类别微服务调用替换所有类别方法，我们可以删除对单体类别模块的所有引用。
- en: 'Go to the `Controller.php` file and delete the following functions, you do
    not need them any more because they reference to the monolithic category module:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`Controller.php`文件并删除以下函数，因为它们不再需要，因为它们引用了单体类别模块：
- en: '`public function deleteCategory($id)`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public function deleteCategory($id)`'
- en: '`public function createCategory($name)`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public function createCategory($name)`'
- en: '`public function updateCategory($id,$name)`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public function updateCategory($id,$name)`'
- en: '`public function getCategories()`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public function getCategories()`'
- en: '`public function getCategory($id)`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public function getCategory($id)`'
- en: 'And finally, if you created a new database for the categories microservice,
    you can drop the categories table located in the monolithic application database
    by executing the following query:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您为类别微服务创建了新的数据库，可以通过执行以下查询来删除位于单体应用程序数据库中的类别表：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We have finished extracting the categories service from the monolithic application.
    The next step would be to select another module, follow the same steps again,
    and repeat this process until the monolithic application disappears or becomes
    a microservice too.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从单体应用程序中提取了类别服务。下一步将是选择另一个模块，再次按照相同步骤进行，并重复此过程，直到单体应用程序消失或成为微服务为止。
- en: In [Chapter 7](ch07.html "Chapter 7. Security"), *Security* we talked about
    security in microservices. To practice what you have learned, review all the code
    in this chapter and find the weakness in our examples.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章. 安全")中，*安全*我们谈到了微服务中的安全性。为了练习您所学到的知识，请查看本章中的所有代码，并找出我们示例中的弱点。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the strategies to follow in order to transform
    a monolithic application into microservices using sample codes for every single
    step. From now on, you are ready to say goodbye to monolithic applications and
    transform them in order to start working with microservices.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了转换单体应用程序为微服务的策略，并为每个步骤使用了示例代码。从现在开始，您已经准备好告别单体应用程序，并进行转换，以开始使用微服务。
