- en: Understanding PHP Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解PHP数组
- en: The PHP array is one of the most used data types in PHP. Most of the time we
    use it without considering the impact of PHP arrays in our developed code or application.
    It is so easy to use and dynamic in nature; we love to use PHP arrays for almost
    any purpose. Sometimes we do not even want to explore if there are other available
    solutions which can be used instead of PHP array. In this chapter, we are going
    to explore the positives and negatives of PHP arrays, along with how to use arrays
    in different data structure implementations along with boosting performances.
    We will start with explaining different types of arrays in PHP followed by creating
    fixed sized arrays. Then we are going to see the memory footprints for PHP array
    elements and how can we improve them along with some data structure implementations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PHP数组是PHP中最常用的数据类型之一。大多数时候，我们在不考虑PHP数组对我们开发的代码或应用程序的影响的情况下使用它。它非常易于使用和动态的；我们喜欢几乎可以用PHP数组来实现任何目的。有时，我们甚至不想探索是否有其他可用的解决方案可以代替PHP数组。在本章中，我们将探索PHP数组的优缺点，以及如何在不同的数据结构实现中使用数组以及提高性能。我们将从解释PHP中不同类型的数组开始，然后创建固定大小的数组。然后我们将看到PHP数组元素的内存占用情况，以及如何改进它们以及一些数据结构的实现。
- en: Understanding PHP arrays in a better way
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好地理解PHP数组
- en: 'PHP arrays are so dynamic and flexible that we have to think about whether
    it is a regular array, an associative array, or a multidimensional array, as in
    some other languages. We do not need to define the size and data type of the array
    we are going to use. How can PHP do that, while other languages like C and Java
    cannot do the same? The answer is very simple: the array concept in PHP is not
    actually the real array, it is actually a **HashMap** . In other words, a PHP
    array is not the plain and simple array concept we have from other languages.
    A simple array will look like this:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: PHP数组是如此动态和灵活，以至于我们必须考虑它是常规数组，关联数组还是多维数组，就像其他一些语言一样。我们不需要定义要使用的数组的大小和数据类型。PHP如何做到这一点，而其他语言如C和Java却不能做到呢？答案很简单：PHP中的数组概念实际上并不是真正的数组，它实际上是一个HashMap。换句话说，PHP数组不是我们从其他语言中得到的简单数组概念。一个简单的数组看起来像这样：
- en: '![](Image00017.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00017.jpg)'
- en: 'But, we can definitely do that with PHP. Let us check with an example:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们绝对可以用PHP做到。让我们通过一个例子来检查：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This line shows how a typical array should look. Similar types of data have
    a sequential index (starting from 0 to 4) to access the values. So who says a
    PHP array is not a typical array? Let us explore some more examples. Consider
    the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行显示了典型数组的外观。类似类型的数据具有顺序索引（从0到4），以访问值。那么谁说PHP数组不是典型数组呢？让我们探索更多的例子。考虑以下：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is a PHP array that we use on a daily basis; we do not define the size and
    we are storing integers, a floating point number, a string, and even another array.
    Does it sound odd or is it just a super power of PHP? We can look at the definition
    from [http://php.net](http://php.net) .
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们每天都在使用的PHP数组；我们不定义大小，我们存储整数、浮点数、字符串，甚至另一个数组。这听起来奇怪还是PHP的超能力？我们可以从[http://php.net](http://php.net)的定义中了解。
- en: An array in PHP is actually an **ordered map** . A map is a type that associates
    values to keys. This type is optimized for several different uses; it can be treated
    as an array, list (vector), hash table (an implementation of a map), dictionary,
    collection, stack, queue, and probably more. As array values can be other arrays,
    trees and multidimensional arrays are also possible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，数组实际上是一个有序映射。映射是一种将值与键关联的类型。这种类型针对多种不同的用途进行了优化；它可以被视为数组、列表（向量）、哈希表（映射的一种实现）、字典、集合、栈、队列，可能还有更多。由于数组的值可以是其他数组，因此也可以存在树和多维数组。
- en: So a PHP array has got real super powers and it can be used for all possible
    data structures such as list/vector, hash table, dictionary, collection, stack,
    queue, doubly linked list, and so on. It seems that the PHP array has been built
    in such a way that it is either optimized for everything or it is not optimized
    for anything. We will explore that in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，PHP数组具有真正的超能力，可以用于所有可能的数据结构，如列表/向量、哈希表、字典、集合、栈、队列、双向链表等。看起来PHP数组是以这样一种方式构建的，要么对所有事情进行了优化，要么对任何事情都没有进行优化。我们将在本章中探索这一点。
- en: 'If we want to categorize the array, then there are mainly three types of arrays:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想对数组进行分类，那么主要有三种类型的数组：
- en: Numeric array
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字数组
- en: Associative array
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联数组
- en: Multidimensional array
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多维数组
- en: We are going to explore each type of array with some examples and explanations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一些例子和解释来探索每种类型的数组。
- en: Numeric array
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字数组
- en: 'A numeric array does not mean it only holds numeric data. In fact, it means
    the indexes will be numbers only. In PHP they can either be sequential or non-sequential
    but they have to be numeric. In numeric arrays, values are stored and accessed
    in a linear way. Here are some examples of PHP numeric array:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数字数组并不意味着它只包含数字数据。实际上，它意味着索引只能是数字。在PHP中，它们可以是顺序的或非顺序的，但它们必须是数字。在数字数组中，值以线性方式存储和访问。以下是一些PHP数字数组的例子：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will have the following output:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a very simple example where we have an array defined and indexes are
    autogenerated from 0 and incremented with the value of the array. When we add
    a new element in the array using `$array[]` , it actually increments the index
    and assigns the value in the new index. That is why value 70 has the index 5 and
    80 has the index 6.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，我们定义了一个数组，并且索引是从0自动生成的，并且随着数组的值递增。当我们使用`$array[]`在数组中添加一个新元素时，它实际上会递增索引并将值分配给新索引。这就是为什么值70具有索引5，80具有索引6。
- en: If our data is sequential, we can always use a `for` loop without any problem.
    When we say sequential, we do not mean just 0,1,2,3....,*n* . It can be 0,5,10,15,20,......,*n*
    where *n* is a multiple of 5\. Or it can be 1,3,5,7,9......,*n* where *n* is odd.
    We can create hundreds of such sequences to make the array numeric.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的数据是连续的，我们总是可以使用`for`循环而不会出现任何问题。当我们说连续时，我们不仅仅是指0,1,2,3....,*n*。它可以是0,5,10,15,20,......,*n*，其中*n*是5的倍数。或者它可以是1,3,5,7,9......,*n*，其中*n*是奇数。我们可以创建数百种这样的序列来使数组成为数字。
- en: 'A big question can be, if the indexes are not sequential, can''t we construct
    a numeric array? Yes definitely we can. We just have to adopt a different way
    to iterate. Consider the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的问题可能是，如果索引不是连续的，我们不能构造一个数字数组吗？是的，我们肯定可以。我们只需要采用不同的迭代方式。考虑以下示例：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we look at the indexes, they are not sequential. They are having random
    indexes such as `10` followed by `21` , `29` , and so on. Even at the end we have
    the index `71` , which is much smaller than the previous one of `1001` . So, should
    the last index show in between 29 and 500? Here is the output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看索引，它们不是连续的。它们具有随机索引，例如`10`后面是`21`，`29`等等。甚至在最后，我们有索引`71`，它比之前的`1001`要小得多。所以，最后一个索引应该在29和500之间吗？以下是输出：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Couple of things to notice here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几件事情需要注意：
- en: We are iterating the array the way we entered the data. There is no internal
    sorting of the indexes at all, though they are all numeric.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照输入数据的方式迭代数组。索引没有任何内部排序，尽管它们都是数字。
- en: Another interesting fact is that the size of the array `$array` is only `6`
    . It is not `1002` like C++, Java, or other languages where we need to predefine
    the size of the array before using it, and the max index can be *n-1* where *n*
    is the size of the array.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的事实是数组`$array`的大小只有`6`。它不像C++、Java或其他语言中需要在使用之前预定义数组大小的`1002`，最大索引可以是*n-1*，其中*n*是数组的大小。
- en: Associative array
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联数组
- en: 'An associative array is accessed by a key which can be any string. In an associative
    array, values are stored against the key instead of a linear index. We can use
    an associative array to store any type of data, just like the numeric array. Let
    us create a student array where we will store student information:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 关联数组是通过可以是任何字符串的键来访问的。在关联数组中，值存储在键而不是线性索引之间。我们可以使用关联数组来存储任何类型的数据，就像数字数组一样。让我们创建一个学生数组，我们将在其中存储学生信息：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the output of the code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的输出：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we are using each key to hold one piece of data. We can add as many keys
    as we need without any problem. This gives us the flexibility to represent a data
    structure similar to structure, map, and dictionary using a PHP associative array.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用每个键来保存一条数据。我们可以根据需要添加任意多个键而不会出现任何问题。这使我们能够使用PHP关联数组来表示类似结构、映射和字典的数据结构。
- en: Multidimensional array
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多维数组
- en: 'A multidimensional array contains multiple arrays in it. In other words, it
    is an array of array(s). In this book, we will be using multidimensional arrays
    in different examples as they are one of the most popular and efficient ways of
    storing data for graphs and other tree-type data structures. Let us explore the
    PHP multidimensional array using an example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组包含多个数组。换句话说，它是一个数组的数组。在本书中，我们将在不同的示例中使用多维数组，因为它们是存储图形和其他树状数据结构的数据的最流行和高效的方式之一。让我们使用一个示例来探索PHP多维数组：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The example we just saw is an example of a two-dimensional array. As a result,
    we are using two `foreach` loops to iterate the two-dimensional array. Here is
    the output of the code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的示例是一个二维数组的示例。因此，我们使用两个`foreach`循环来迭代二维数组。以下是代码的输出：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can create n-dimensional arrays using PHP as per our needs, but we have
    to remember one thing: the more dimensions we add, the more complex the structure
    becomes. We as humans usually visualize three dimensions, so in order to have
    more than three-dimensional arrays, we must have a solid understanding of how
    an array works in multiple dimensions.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据需要使用PHP创建n维数组，但是我们必须记住一件事：我们添加的维度越多，结构就会变得越复杂。我们通常可以想象三维，所以为了拥有超过三维的数组，我们必须对多维数组的工作原理有扎实的理解。
- en: We can use both a numeric array and an associative array as a single array in
    PHP. But in such a case, we have to be very cautious to choose the right way to
    iterate through the array elements. In such cases, `foreach` will be a better
    choice than a `for` or `while` loop.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在PHP中将数字数组和关联数组作为单个数组使用。但在这种情况下，我们必须非常谨慎地选择正确的方法来迭代数组元素。在这种情况下，`foreach`将比`for`或`while`循环更好。
- en: Using an array as flexible storage
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组作为灵活的存储
- en: So far we have seen a PHP array as a dynamic, hybrid data structure for storing
    any type of data. This gives us a lot more freedom to utilize an array as a flexible
    storage container for our data. We can mix different data types and different
    dimensions of data in a single array. We do not have to even define the size or
    type of array we are going to use. We can grow, shrink, and modify data to and
    from an array whenever we need to.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到PHP数组作为一种动态的、混合的数据结构，用于存储任何类型的数据。这给了我们更多的自由度，可以将数组用作灵活的存储容器。我们可以在单个数组中混合不同的数据类型和不同维度的数据。我们甚至不必定义我们将要使用的数组的大小或类型。我们可以在需要时随时增加、缩小和修改数据到数组中。
- en: 'Not only does PHP allows us to create dynamic arrays, but it also provides
    us with lots of built-in functionalities for arrays. For example: `array_intersect`
    , `array_merge` , `array_diff` , `array_push` , `array_pop` , `prev` , `next`
    , `current` , `end` , and many more.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: PHP不仅允许我们创建动态数组，而且还为数组提供了许多内置功能。例如：`array_intersect`，`array_merge`，`array_diff`，`array_push`，`array_pop`，`prev`，`next`，`current`，`end`等等。
- en: Use of multi-dimensional arrays to represent data structures
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多维数组表示数据结构
- en: 'In coming chapters, we will talk about many different data structures and algorithms.
    One of the key data structures we are going to focus is the graph. We already
    know the definition of graph data structures. Most of the time we will be using
    PHP multidimensional arrays to represent that data as an adjacency matrix. Let
    us consider the following graph diagram:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论许多不同的数据结构和算法。我们将重点讨论图形。我们已经知道图形数据结构的定义。大多数时候，我们将使用PHP多维数组来表示数据，作为邻接矩阵。让我们考虑以下图表：
- en: '![](Image00018.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00018.jpg)'
- en: 'Now if we consider each node of the graph to be a value of an array, we can
    represent the nodes as:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们把图的每个节点看作是一个数组的值，我们可以表示节点为：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: But this will only give us node names. We cannot connect or create a relationship
    between nodes. In order to do that, we need to construct a two-dimensional array
    where the node names will be keys, and values will be 0 or 1 based on the interconnectivity
    of two nodes. Since there is no direction provided in the graph, we do not know
    if *A* connects to *C* or if Connects to *A* . So we will assume both are connected
    to each other.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只会给我们节点名称。我们无法连接或创建节点之间的关系。为了做到这一点，我们需要构建一个二维数组，其中节点名称将是键，值将基于两个节点的互连性为0或1。由于图中没有提供方向，我们不知道*A*是否连接到*C*或连接到*A*。所以我们假设两者彼此连接。
- en: 'First, we need to create an array for the graph and initialize each node of
    the two-dimensional arrays as 0\. The following code will exactly do that:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为图创建一个数组，并将二维数组的每个节点初始化为0。以下代码将确切地做到这一点：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let us print the array using the following code so that we see how it looks
    actually before defining the connectivity between nodes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码打印数组，以便在定义节点之间的连接之前看到它的实际外观：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As no connection between the nodes has been defined, all cells are showing
    0\. So the output looks like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于节点之间的连接未定义，所有单元格都显示为0。因此输出看起来像这样：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we will define the connectivity of the nodes in such a way that a connection
    between the two nodes will be expressed as a value of 1, just like the following
    code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将定义节点之间的连接，使两个节点之间的连接表示为1的值，就像以下代码一样：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As there is no direction given in the graph diagram, we will consider it as
    the undirected graph and hence we are setting two values to 1 for each connection.
    For the connection between *A* and *B* , we are setting both `$graph["A"]["B"]`
    and `$graph["B"]["A"]` to `1` . We will learn more about defining connectivity
    between nodes and why we are doing it in later chapters. For now we are just focusing
    on how to use multidimensional arrays for data structures. We can reprint the
    matrix and this time, the output looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图表中没有给出方向，我们将其视为无向图，因此我们为每个连接设置了两个值为1。对于*A*和*B*之间的连接，我们将`$graph["A"]["B"]`和`$graph["B"]["A"]`都设置为`1`。我们将在后面的章节中了解更多关于定义节点之间连接的内容以及为什么我们这样做。现在我们只关注如何使用多维数组来表示数据结构。我们可以重新打印矩阵，这次输出看起来像这样：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It will be much more fun and interesting to find out more about graphs and their
    operations in [Chapter 9](text00202.html) , *Putting Graphs into Action* .
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](text00202.html)中，*将图形投入实践*，更有趣和有趣地了解图形及其操作。
- en: Creating fixed size arrays with the SplFixedArray method
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SplFixedArray方法创建固定大小的数组
- en: So far, we have explored PHP arrays and we know, we do not define the size of
    the arrays. PHP arrays can grow or shrink as per our demand. This flexibility
    comes with a great inconvenience regarding memory usage. We are going to explore
    that in this section. For now, let us focus on creating fixed size arrays using
    the SPL library.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了PHP数组，我们知道，我们不定义数组的大小。PHP数组可以根据我们的需求增长或缩小。这种灵活性带来了关于内存使用的巨大不便。我们将在本节中探讨这一点。现在，让我们专注于使用SPL库创建固定大小的数组。
- en: 'Why do we need a fixed size array? Does it have any added advantage? The answer
    is that when we know we only need a certain number of elements in an array, we
    can use a fixed array to reduce the memory usage. Before going to the memory use
    analysis, let us have some examples of using the `SplFixedArray` method:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要一个固定大小的数组？它有什么额外的优势吗？答案是，当我们知道我们只需要数组中的一定数量的元素时，我们可以使用固定数组来减少内存使用。在进行内存使用分析之前，让我们举一些使用`SplFixedArray`方法的例子：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First, we are creating a new `SplFixedArray` object with a defined size of
    10\. The remaining lines actually follow the same principle which we use in regular
    PHP array value assignment and retrieval. If we want to access an index which
    is out of the range (here it is 10), it will throw an exception:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个具有定义大小为10的新`SplFixedArray`对象。其余行实际上遵循我们在常规PHP数组值分配和检索中使用的相同原则。如果我们想访问超出范围的索引（这里是10），它将抛出一个异常：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The basic difference between a PHP array and `SplFixedArray` are:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: PHP数组和`SplFixedArray`之间的基本区别是：
- en: '`SplFixedArray` must have a fixed defined size'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SplFixedArray`必须有一个固定的定义大小'
- en: The indexes of `SplFixedArray` must be integers and within the range of 0 to
    *n* , where *n* is the size of the array we defined
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SplFixedArray`的索引必须是整数，并且在0到*n*的范围内，其中*n*是我们定义的数组的大小'
- en: The `SplFixedArray` method can be very handy when we have a lot of defined arrays
    with known size or have an upper limit for the maximum required size of the array.
    But if we do not know the array size, then it is better to use a PHP array.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有许多已知大小的定义数组或数组的最大所需大小有一个上限时，`SplFixedArray`方法可能非常方便。但如果我们不知道数组的大小，那么最好使用PHP数组。
- en: Performance comparison between a regular PHP array and SplFixedArray
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常规PHP数组和SplFixedArray之间的性能比较
- en: One of the key questions we encountered in the last section was, why should
    we use `SplFixedArray` instead of PHP arrays? We are now ready to explore the
    answer. We came across the concept that PHP arrays are actually not arrays rather
    than hash maps. Let us run a small example code in PHP 5.x version to see the
    memory usage of a PHP array.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中我们遇到的一个关键问题是，为什么我们应该使用`SplFixedArray`而不是PHP数组？我们现在准备探讨答案。我们发现PHP数组实际上不是数组，而是哈希映射。让我们在PHP
    5.x版本中运行一个小例子代码，看看PHP数组的内存使用情况。
- en: 'Let us create an array with 100,000 unique PHP integers. As I am running a
    64 bit machine, I expect each integer to take 8 bytes each. So we will have around
    800,000 bytes of memory consumed for the array. Here is the code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含100,000个唯一PHP整数的数组。由于我正在运行64位机器，我期望每个整数占用8个字节。因此，我们将为数组消耗大约800,000字节的内存。以下是代码：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we run this code in our command prompt, we will see an output of 14,649,040
    bytes. Yes, it is correct. The memory usage is almost 18.5 times more than what
    we have planned for. That means, for each element in the array an overhead of
    144 bytes (18 * 8 bytes) for one PHP array. Now, where does this extra 144 bytes
    come from and why does PHP utilize so much extra memory for each array element?
    Here is an explanation of the extra bytes used by a PHP array:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在命令提示符中运行这段代码，我们将看到一个输出为14,649,040字节。是的，没错。内存使用量几乎是我们计划的18.5倍。这意味着对于一个PHP数组中的每个元素，会有144字节（18
    * 8字节）的开销。那么，这额外的144字节是从哪里来的，为什么PHP为每个数组元素使用这么多额外的内存？以下是PHP数组使用的额外字节的解释：
- en: '![](Image00019.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00019.jpg)'
- en: 'This diagram shows how a PHP array works internally. It stores data in a bucket
    to avoid collision and to accommodate more data. To manage this dynamic nature,
    it implements both a doubly linked list and hash table internally for array. Eventually,
    it costs lots of extra memory space for each individual elements in the array.
    Here is the breakdown of the memory consumption of each element based on the PHP
    array implementation code (C code):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图表展示了PHP数组的内部工作原理。它将数据存储在一个桶中，以避免冲突并容纳更多数据。为了管理这种动态性，它在数组的内部实现了双向链表和哈希表。最终，这将为数组中的每个单独元素消耗大量额外的内存空间。以下是基于PHP数组实现代码（C代码）的每个元素的内存消耗的详细情况：
- en: '|  | **32 bit** | **64 bit** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| | **32位** | **64位** |'
- en: '| zval | 16 bytes | 24 bytes |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| zval| 16字节| 24字节|'
- en: '| + cyclic GC info | 4 bytes | 8 bytes |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| +循环GC信息| 4字节| 8字节|'
- en: '| + allocation header | 8 bytes | 16 bytes |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| +分配头| 8字节| 16字节|'
- en: '| zval (value) total | 28 bytes | 48 bytes |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| zval（值）总计| 28字节| 48字节|'
- en: '| bucket | 36 bytes | 72 bytes |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| bucket| 36字节| 72字节|'
- en: '| + allocation header | 8 bytes | 16 bytes |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| +分配头| 8字节| 16字节|'
- en: '| + pointer | 4 bytes | 8 bytes |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| +指针| 4字节| 8字节|'
- en: '| bucket (array element) total | 48 bytes | 96 bytes |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| bucket（数组元素）总计| 48字节| 96字节|'
- en: '| Grand total (bucket+zval) | 76 bytes | 144 bytes |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 总计（bucket+zval）| 76字节| 144字节|'
- en: 'In order to understand the internal structure of a PHP array, we need to study
    in depth about PHP internals. It is beyond the scope of this particular book.
    A good recommended read is: [https://nikic.github.io/2011/12/12/How-big-are-PHP-arrays-really-Hint-BIG.html](https://nikic.github.io/2011/12/12/How-big-are-PHP-arrays-really-Hint-BIG.html)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解PHP数组的内部结构，我们需要深入研究PHP内部。这超出了本书的范围。一个很好的推荐阅读是：[https://nikic.github.io/2011/12/12/How-big-are-PHP-arrays-really-Hint-BIG.html](https://nikic.github.io/2011/12/12/How-big-are-PHP-arrays-really-Hint-BIG.html)
- en: 'With the new PHP 7 version, there is a very big improvement in the PHP array
    and how it is constructed internally. As a result, the 144 bytes overhead on each
    element has come down to 36 bytes only. That is a big improvement and it is applicable
    for both 32 bit and 64 bit OS. A comparison chart, having a range of 100,000 items
    in an array, is shown as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的PHP 7版本中，PHP数组的内部构造有了很大的改进。结果，每个元素的144字节的开销仅降至36字节。这是一个很大的改进，适用于32位和64位操作系统。下面是一个比较图表，包含一个包含100,000个项目的数组：
- en: '| **$array = Range(1,100000)** | **32 bit** | **64 bit** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **$array = Range(1,100000)**| **32位**| **64位**|'
- en: '| PHP 5.6 or below | 7.4 MB | 14 MB |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| PHP 5.6或更低| 7.4 MB| 14 MB|'
- en: '| PHP 7 | 3 MB | 4 MB |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| PHP 7| 3 MB| 4 MB|'
- en: 'So, in other words, PHP 7 has an improvement factor of 2.5 times for 32 bit
    and 3.5 times for 64 bit system for array storage. That is a really good improvement.
    But this was all about a PHP array, what about `SplFixedArray` ? Let us run the
    same example using `SplFixArray` in both PHP 7 and PHP 5.x:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '换句话说，对于32位系统，PHP 7的改进系数为2.5倍，对于64位系统为3.5倍。这是一个真正的改进。但这一切都是关于PHP数组的，那么`SplFixedArray`呢？让我们在PHP
    7和PHP 5.x中使用`SplFixArray`运行相同的示例： '
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have written the memory consumption functionality of a `SplFixedArray` here.
    If we just change the line `$array = new SplFixedArray($items);` to `$array =
    [];` , we will have the same code running as for a PHP array.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里写了`SplFixedArray`的内存消耗功能。如果我们只是将行`$array = new SplFixedArray($items);`更改为`$array
    = [];`，我们将得到与PHP数组相同的代码运行。
- en: The benchmark result can vary from machine to machine as there can be different
    OS, memory size, debugger on/off, and so on. It is always suggested to run the
    codes in your own machines to generate a similar benchmark for comparisons.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试结果可能因机器而异，因为可能有不同的操作系统、内存大小、调试器开/关等。建议在自己的机器上运行代码，以生成类似的基准测试进行比较。
- en: 'Here is a comparison of memory consumption of a PHP array and `SplFixedArray`
    for an array with 100,000 integers in a 64 bit system:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是64位系统中包含100,000个整数的PHP数组和`SplFixedArray`的内存消耗比较：
- en: '| **100,000 items** | **Using PHP array** | **SplFixedArray** |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **100,000个项目** | **使用PHP数组** | **SplFixedArray** |'
- en: '| PHP 5.6 or below | 14 MB | 6 MB |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| PHP 5.6或更低| 14 MB| 6 MB|'
- en: '| PHP 7 | 5 MB | 2 MB |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| PHP 7| 5 MB| 2 MB|'
- en: Not only in memory usage, `SplFixedArray` is also faster in execution compared
    to general PHP array operations such as accessing value, assigning value, and
    so on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`SplFixedArray` 不仅在内存使用上更快，而且在执行速度上也比一般的PHP数组操作更快，比如访问值，赋值等等。'
- en: Though we use the `SplFixedArray` object with [] just like the array, PHP array
    functions will not be applicable for `SplFixedArray.` We cannot directly apply
    any PHP array functions such as `array_sum` , `array_filter` , and so on.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以像数组一样使用`SplFixedArray`对象，但PHP数组函数不适用于`SplFixedArray`。我们不能直接应用任何PHP数组函数，比如`array_sum`，`array_filter`等等。
- en: More examples using SplFixedArray
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SplFixedArray的更多示例
- en: Since `SplFixedArray` has a good performance boost indicator, we can utilize
    it instead of a regular PHP array in most of our data structures and algorithms.
    Now we will explore some more examples of using `SplFixedArray` in different scenarios.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`SplFixedArray`具有良好的性能提升指标，我们可以在大多数数据结构和算法中利用它，而不是使用常规的PHP数组。现在我们将探讨在不同场景中使用`SplFixedArray`的更多示例。
- en: Changing from a PHP array to SplFixedArray
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从PHP数组转换为SplFixedArray
- en: 'We have seen how we can create a `SplFixedArray` with a fixed length. What
    if I want to create an array to `SplFixedArray` during runtime? The following
    code block shows how to achieve it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何创建一个具有固定长度的`SplFixedArray`。如果我想在运行时创建一个`SplFixedArray`数组呢？以下代码块显示了如何实现：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here we are constructing a `SplFixedArray` from an existing array `$array`
    using the static method `fromArray` of the `SplFixedArray` class. Then we are
    printing the array using the PHP `print_r` function. It will show an output like
    this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`SplFixedArray`类的静态方法`fromArray`从现有数组`$array`构造了一个`SplFixedArray`。然后我们使用PHP的`print_r`函数打印数组。它将显示如下输出：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can see the array has been now converted to an `SplFixedArray` and it maintained
    the index number exactly as it was in the actual array. Since the actual array
    did not have 0 index defined, here index 0 is kept as null. But if we want to
    ignore the indexes from the previous array and assign them new indexes, then we
    have to change the second line of the previous code to this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到数组现在已经转换为`SplFixedArray`，并且它保持了与实际数组中完全相同的索引号。由于实际数组没有定义0索引，因此索引0保持为null。但是，如果我们想忽略以前数组的索引并为它们分配新的索引，那么我们必须将上一个代码的第二行更改为这样：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now if we print the array again, we will have the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次打印数组，将会得到以下输出：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we want to convert an array to a fixed array during runtime, it is a better
    idea to unset the regular PHP array if it is not being used later on. It will
    save memory usage if it is a big array.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在运行时将数组转换为固定数组，最好是在不再使用常规PHP数组时取消它。如果数组很大，这将节省内存使用。
- en: Converting a SplFixedArray to a PHP array
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将SplFixedArray转换为PHP数组
- en: 'We might also need to convert a `SplFixedArray` to a regular PHP array to apply
    some predefined array functions from PHP. Like the previous example, this is also
    a very simple thing to do:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还需要将`SplFixedArray`转换为常规PHP数组，以应用PHP中的一些预定义数组函数。与前面的示例一样，这也是一件非常简单的事情：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will produce the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Changing the SplFixedArray size after declaration
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在声明后更改SplFixedArray大小
- en: 'As we are defining the array size at the beginning, we may require changing
    the size later on. In order to do that, we have to use the `setSize()` method
    of the `SplFixedArray` class. An example is shown as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在开始时定义了数组大小，可能需要稍后更改大小。为了做到这一点，我们必须使用`SplFixedArray`类的`setSize()`方法。示例如下：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Creating a multidimensional array using SplFixedArray
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SplFixedArray创建多维数组
- en: 'We might also require creating two or more dimensional arrays using `SplFixedArray`
    . In order to do that, it is recommended to follow this example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还需要使用`SplFixedArray`创建两个或更多维数组。为了做到这一点，建议按照以下示例操作：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are actually creating another `SplFixedArray` inside each array indexes.
    We can add as many dimensions as we want. But we have to remember that, with dimensions,
    we are multiplying the size of the array. So it can grow really big very quickly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们在每个数组索引内部创建了另一个`SplFixedArray`。我们可以添加任意多的维度。但我们必须记住，随着维度的增加，数组的大小也会增加。因此，它可能会非常快速地变得非常大。
- en: Understanding hash tables
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解哈希表
- en: 'In programming language, a hash table is a data structure which is used to
    make an array associative. It means we can use keys to map values instead of using
    an index. A hash table must use a hash function to compute an index into an array
    of buckets or slots, from which the desired value can be found:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言中，哈希表是一种数据结构，用于使数组成为关联数组。这意味着我们可以使用键来映射值，而不是使用索引。哈希表必须使用哈希函数来计算数组桶或槽的索引，从中可以找到所需的值：
- en: '![](Image00020.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00020.jpg)'
- en: 'As we have mentioned several times, a PHP array is actually a hash table and
    hence it supports associative arrays. We need to remember one thing: that we do
    not need to define a hash function for the associative array implementation. PHP
    does it internally for us. As a result, when we create an associative array in
    PHP, we are actually creating a hash table. For example, the following code can
    be considered as the hash table:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经多次提到的，PHP数组实际上是一个哈希表，因此支持关联数组。我们需要记住一件事：对于关联数组实现，我们不需要定义哈希函数。PHP会在内部为我们做这件事。因此，当我们在PHP中创建关联数组时，实际上是在创建一个哈希表。例如，以下代码可以被视为哈希表：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As a matter of fact, we can directly invoke any keys with only **O(1)** complexity.
    The key will always refer to the same index inside the bucket, as PHP will use
    the same hash function to calculate the index.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们可以直接调用任何键，复杂度只有**O(1)**。键将始终引用桶内相同的索引，因为PHP将使用相同的哈希函数来计算索引。
- en: Implementing struct using a PHP array
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP数组实现结构
- en: 'As we already know, a struct is a complex data type where we define multiple
    properties as a group so that we can use it as a single data type. We can write
    a struct using a PHP array and class. Here is an example of a struct using a PHP
    array:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，结构是一种复杂的数据类型，我们在其中定义多个属性作为一组，以便我们可以将其用作单个数据类型。我们可以使用PHP数组和类来编写结构。以下是使用PHP数组编写结构的示例：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It is simply an associative array with keys as string. A complex struct can
    be constructed using single or more constructs as its properties. For example
    using the player struct, we can use a team struct:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是一个具有字符串键的关联数组。可以使用单个或多个结构来构造复杂的结构作为其属性。例如，使用player结构，我们可以使用team结构：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since we have seen both ways of defining a struct, we have to choose either
    one of them to implement a struct. While creating an object might look more convenient,
    it is slower compared to array implementation. Where an array has an added advantage
    of speed, it also has a disadvantage as it takes more memory space compared to
    an object. Now we have to make the decision based on our preference.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经看到了定义结构的两种方式，我们必须选择其中一种来实现结构。虽然创建对象可能看起来更方便，但与数组实现相比，它的速度较慢。数组具有速度的优势，但它也有一个缺点，即它占用比对象更多的内存空间。现在我们必须根据自己的偏好做出决定。
- en: Implementing sets using a PHP array
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP数组实现集合
- en: 'A set is a simply a collection of values without any particular order. It can
    contain any data type and we can run different set operations such as union, intersection,
    complement, and so on. As a set only contains values, we can construct a basic
    PHP array and assign values to it so that it grows dynamically. The following
    example shows two sets that we have defined; one contains some odd numbers and
    the other one has some prime numbers:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 集合只是一个没有特定顺序的值的集合。它可以包含任何数据类型，我们可以运行不同的集合操作，如并集、交集、补集等。由于集合只包含值，我们可以构建一个基本的PHP数组，并为其分配值，使其动态增长。以下示例显示了我们定义的两个集合；一个包含一些奇数，另一个包含一些质数：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In order to check the existence of a value inside the set along with union,
    intersection, and complement operation, we can use the following example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查值在集合中的存在以及并集、交集和补集操作，我们可以使用以下示例：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'PHP has many built-in functions for such operations and we can utilize them
    for our set operations. But we have to consider one fact: since the set is not
    ordered in any particular way, searching using the `in_array()` function might
    have the complexity of **O(n)** in worst case scenario. Same goes for the `array_merge()`
    function, as it will check each value from one array with another array. In order
    to speed things up, we can modify our code a little bit and make it efficient:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: PHP有许多用于此类操作的内置函数，我们可以利用它们进行集合操作。但是我们必须考虑一个事实：由于集合没有以任何特定方式排序，使用`in_array()`函数进行搜索在最坏的情况下可能具有**O(n)**的复杂度。`array_merge()`函数也是如此，它将检查一个数组中的每个值与另一个数组。为了加快速度，我们可以稍微修改我们的代码，使其更加高效：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If we analyze this code, we can see that we are using an index or key to define
    the set. Since a PHP array index or key lookup have a complexity of **O(1),**
    it makes the searching much faster. As a result, all the lookup, union, intersect,
    and complement operations will take lesser time compared to the previous example.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分析这段代码，我们可以看到我们使用索引或键来定义集合。由于PHP数组索引或键查找的复杂度为**O(1)**，这使得搜索速度更快。因此，所有查找、并集、交集和补集操作将比上一个示例花费更少的时间。
- en: Best usage of a PHP array
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP数组的最佳用法
- en: Though a PHP array consumes more memory, the flexibility of using a PHP array
    is much more important for many data structures. As a result, we will use a PHP
    regular array as well as `SplFixedArray` in many of our data structure implementations
    and algorithms. If we just consider a PHP array as a container for our data, it
    will be easier for us to utilize its immensely powerful features in many data
    structure implementations. Along with built-in functions, a PHP array is definitely
    a must use data structure for programming and developing applications using PHP.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然PHP数组消耗更多内存，但使用PHP数组的灵活性对于许多数据结构来说更为重要。因此，我们将在许多数据结构实现和算法中使用PHP常规数组以及`SplFixedArray`。如果我们只将PHP数组视为我们数据的容器，那么我们将更容易地利用其在许多数据结构实现中的强大功能。除了内置函数，PHP数组绝对是使用PHP进行编程和开发应用程序时必不可少的数据结构。
- en: PHP has some built-in sorting functions for an array. It can sort using keys
    and values along with keeping association while sorting. We are going to explore
    these built-in functions in [Chapter 7](text00165.html) , *Using Sorting Algorithms*
    .
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: PHP有一些用于数组的内置排序函数。它可以使用键和值进行排序，并在排序时保持关联。我们将在[第7章](text00165.html)中探索这些内置函数，*使用排序算法*。
- en: PHP array, is it a performance killer?
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP数组，它是性能杀手吗？
- en: We have seen in this chapter how each element in a PHP array has a very big
    overhead of memory. Since it is done by the language itself, there is very little
    we can do over here, except that we use `SplFixedArray` instead of a regular array
    where it is applicable. But if we move from our PHP 5.x version to the new PHP
    7, then we can have a huge improvement in our application, whether we use regular
    PHP array or `SplFixedArray` .
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到PHP数组中的每个元素都具有非常大的内存开销。由于这是语言本身完成的，除了在适用的情况下使用`SplFixedArray`而不是常规数组之外，我们几乎无能为力。但是，如果我们从PHP
    5.x版本迁移到新的PHP 7，那么我们的应用程序将有巨大的改进，无论我们使用常规PHP数组还是`SplFixedArray`。
- en: In PHP 7, the internal implementation of a hash table has been changed drastically
    and it is not built for efficiency. As a result, the overhead memory consumption
    for each element has gone down significantly. Though we can argue that less memory
    consumption does not make a code speedy, we can have a counter argument that if
    we have less memory to manage, we can focus more on execution rather than memory
    management. As a result, we have some impact on the performance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中，哈希表的内部实现发生了巨大的变化，它并不是为了效率而构建的。因此，每个元素的开销内存消耗显著减少。虽然我们可以争论较少的内存消耗并不会使代码更快，但我们可以反驳，如果我们有更少的内存来管理，我们可以更多地专注于执行而不是内存管理。因此，这对性能产生了一些影响。
- en: So far from the discussion, we can easily say the newly improved array in PHP
    7 is definitely a recommended choice for developers to solve complex and memory
    efficient applications.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从讨论中可以很容易地得出结论，PHP 7中新改进的数组绝对是开发人员解决复杂和内存高效应用程序的推荐选择。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have focused our discussion on PHP arrays and what can be
    done using a PHP array as a data structure. We are going to continue our exploration
    of array features in the coming chapters. In the next chapter, we are going to
    focus on linked list data structures and different variants of linked list. We
    are also going to explore different types of practical examples regarding linked
    lists and their best usages.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于讨论PHP数组以及使用PHP数组作为数据结构可以做什么。我们将在接下来的章节中继续探讨数组的特性。在下一章中，我们将专注于链表数据结构和不同变体的链表。我们还将探索关于链表及其最佳用法的不同类型的实际示例。
