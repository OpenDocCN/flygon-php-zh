- en: Chapter 13. Best Practices, Testing, and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。最佳实践、测试和调试
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using Traits and Interfaces
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特征和接口
- en: Universal exception handler
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用异常处理程序
- en: Universal error handler
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用错误处理程序
- en: Writing a simple test
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的测试
- en: Writing a test suite
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试套件
- en: Generating fake test data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成假测试数据
- en: Customizing sessions using `session_start` parameters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`session_start`参数自定义会话
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will show you how traits and interfaces work together. Then,
    we turn our attention to the design of a fallback mechanism that will catch errors
    and exceptions in situations where you were not able (or forgot) to define specific
    `try/catch` blocks. We will then venture into the world of unit testing, showing
    you first how to write simple tests, and then how to group those tests together
    into test suites. Next, we define a class that lets you create any amount of generic
    test data. We close the chapter with a discussion of how to easily manage sessions
    using new PHP 7 features.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示特征和接口如何一起工作。然后，我们将把注意力转向设计一个回退机制，它将在您无法（或忘记）定义特定的`try/catch`块的情况下捕获错误和异常。然后，我们将进入单元测试的世界，首先向您展示如何编写简单的测试，然后如何将这些测试组合成测试套件。接下来，我们定义一个类，让您可以创建任意数量的通用测试数据。最后，我们讨论如何利用新的PHP
    7功能轻松管理会话。
- en: Using Traits and Interfaces
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用特征和接口
- en: It is considered a best practice to make use of interfaces as a means of establishing
    the classification of a set of classes, and to guarantee the existence of certain
    methods. Traits and Interfaces often work together, and are an important aspect
    of implementation. Wherever you have a frequently used Interface that defines
    a method where the code does not change (such as a setter or getter), it is useful
    to also define a Trait that contains the actual code implementation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接口作为一种建立一组类的分类并保证某些方法存在的手段被认为是最佳实践。特征和接口经常一起工作，是实现的重要方面。无论何时您有一个经常使用的接口，定义了一个代码不会改变的方法（比如一个setter或getter），也定义一个包含实际代码实现的特征是有用的。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: For this example, we will use `ConnectionAwareInterface`, first presented in
    [Chapter 4](ch04.html "Chapter 4. Working with PHP Object-Oriented Programming"),
    *Working with PHP Object-Oriented Programming*. This interface defines a `setConnection()`
    method that sets a `$connection` property. Two classes in the `Application\Generic`
    namespace, `CountryList` and `CustomerList`, contain redundant code, which matches
    the method defined in the interface.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用`ConnectionAwareInterface`，首次在[第4章](ch04.html "第4章。使用PHP面向对象编程")中介绍，*使用PHP面向对象编程*。这个接口定义了一个`setConnection()`方法，用于设置一个`$connection`属性。`Application\Generic`命名空间中的两个类，`CountryList`和`CustomerList`，包含了冗余的代码，与接口中定义的方法相匹配。
- en: 'Here is what `CountryList` looks like before the change:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行更改之前，`CountryList`的样子如下：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will now move `list()` into a trait called `ListTrait`:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将`list()`移到一个名为`ListTrait`的特征中：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can then insert the code from `ListTrait` into a new class, `CountryListUsingTrait`,
    as shown next:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以将`ListTrait`中的代码插入到一个新的类`CountryListUsingTrait`中，如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we observe that many classes need to set a connection instance. Again,
    this calls for a trait. This time, however, we place the trait in the `Application\Database`
    namespace. Here is the new trait:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们注意到许多类需要设置一个连接实例。同样，这需要一个特征。然而，这一次，我们将特征放在`Application\Database`命名空间中。这是新的特征：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Traits are often used to avoid duplication of code. It is often the case that
    you also need to identify the class that uses the trait. A good way to do this
    is to develop an interface that matches the trait. In this example, we will define
    `Application\Database\ConnectionAwareInterface`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特征经常用于避免代码重复。通常情况下，您还需要确定使用特征的类。一个好的方法是开发一个与特征匹配的接口。在这个例子中，我们将定义`Application\Database\ConnectionAwareInterface`：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And here is the revised `CountryListUsingTrait` class. Note that as the new
    trait is affected by its location in the namespace, we needed to add a `use` statement
    at the top of the class. You will also note that we implement `ConnectionAwareInterface`
    to identify the fact that this class requires the method defined in the trait.
    Notice that we are taking advantage of the new PHP 7 group use syntax:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是修订后的`CountryListUsingTrait`类。请注意，由于特征的位置受到其命名空间的影响，我们需要在类的顶部添加一个`use`语句。您还会注意到，我们实现了`ConnectionAwareInterface`来确定这个类需要特征中定义的方法。请注意，我们正在利用新的PHP
    7组使用语法：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First of all, make sure the classes developed in [Chapter 4](ch04.html "Chapter 4. Working
    with PHP Object-Oriented Programming"), *Working with PHP Object-Oriented Programming*,
    have been created. These include the `Application\Generic\CountryList` and `Application\Generic\CustomerList`
    classes discussed in [Chapter 4](ch04.html "Chapter 4. Working with PHP Object-Oriented
    Programming"), *Working with PHP Object-Oriented Programming*, in the recipe *Using
    interfaces*. Save each class in a new file in the `Application\Generic` folder
    as `CountryListUsingTrait.php` and `CustomerListUsingTrait.php`. Be sure to change
    the class names to match the new names of the files!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保在[第4章](ch04.html "第4章。使用PHP面向对象编程")中开发的类已经创建。这些包括在[第4章](ch04.html "第4章。使用PHP面向对象编程")中讨论的`Application\Generic\CountryList`和`Application\Generic\CustomerList`类，在*使用接口*一节中。将每个类保存在`Application\Generic`文件夹中的一个新文件中，分别命名为`CountryListUsingTrait.php`和`CustomerListUsingTrait.php`。确保更改类名以匹配新文件的名称！
- en: As discussed in step 3, remove the `list()` method from both `CountryListUsingTrait.php`
    and `CustomerListUsingTrait.php`. Add `use ListTrait;` in place of the method
    removed. Place the removed code into a separate file, in the same folder, called
    `ListTrait.php`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如第3步所讨论的，从`CountryListUsingTrait.php`和`CustomerListUsingTrait.php`中删除`list()`方法。在删除的方法的位置添加`use
    ListTrait;`。将删除的代码放入同一文件夹中的一个单独的文件中，命名为`ListTrait.php`。
- en: You will also notice further duplication of code between the two list classes,
    in this case the `setConnection()` method. This calls for another trait!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到两个列表类之间进一步的代码重复，这种情况下是`setConnection()`方法。这需要另一个trait！
- en: Cut the `setConnection()` method out of both `CountryListUsingTrait.php` and
    `CustomerListUsingTrait.php` list classes, and place the removed code into a separate
    file called `ConnectionTrait.php`. As this trait is logically related to `ConnectionAwareInterface`
    and `Connection`, it makes sense to place the file in the `Application\Database`
    folder, and to specify its namespace accordingly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从`CountryListUsingTrait.php`和`CustomerListUsingTrait.php`列表类中剪切`setConnection()`方法，并将删除的代码放入名为`ConnectionTrait.php`的单独文件中。由于这个trait在逻辑上与`ConnectionAwareInterface`和`Connection`相关，因此将文件放在`Application\Database`文件夹中，并相应地指定其命名空间是有意义的。
- en: 'Finally, define `Application\Database\ConnectionAwareInterface` as discussed
    in step 6\. Here is the final `Application\Generic\CustomerListUsingTrait` class
    after all changes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在步骤6中讨论的地方定义`Application\Database\ConnectionAwareInterface`。在所有更改之后，以下是最终的`Application\Generic\CustomerListUsingTrait`类：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can now copy the `chap_04_oop_simple_interfaces_example.php` file mentioned
    in [Chapter 4](ch04.html "Chapter 4. Working with PHP Object-Oriented Programming"),
    *Working with PHP Object-Oriented Programming*, to a new file called `chap_13_trait_and_interface.php`.
    Change the reference from `CountryList` to `CountryListUsingTrait`. Likewise,
    change the reference from `CustomerList` to `CustomerListUsingTrait`. Otherwise,
    the code can remain the same:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以将[第4章](ch04.html "第4章。使用PHP面向对象编程")中提到的`chap_04_oop_simple_interfaces_example.php`文件复制到一个名为`chap_13_trait_and_interface.php`的新文件中。将引用从`CountryList`改为`CountryListUsingTrait`。同样，将引用从`CustomerList`改为`CustomerListUsingTrait`。否则，代码可以保持不变：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output will be exactly as described in the *Using interfaces* recipe of
    [Chapter 4](ch04.html "Chapter 4. Working with PHP Object-Oriented Programming"),
    *Working with Object-Oriented Programming*. You can see the country list portion
    of the output in the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将与[第4章](ch04.html "第4章。使用PHP面向对象编程")中*使用接口*一节中描述的完全相同，*使用面向对象编程*。您可以在以下截图中看到输出的国家列表部分：
- en: '![How it works...](graphics/B05314_13_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_13_01.jpg)'
- en: 'The next image displays the customer list portion of the output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张图片显示了输出的客户列表部分：
- en: '![How it works...](graphics/B05314_13_19.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_13_19.jpg)'
- en: Universal exception handler
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用异常处理程序
- en: Exceptions are especially useful when used in conjunction with code in a `try/catch`
    block. Using this construct, however, can be awkward in some situations, making
    code virtually unreadable. Another consideration is that many classes end up throwing
    exceptions that you have not anticipated. In such cases, it would be highly desirable
    to have some sort of fallback exception handler.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`try/catch`块中与代码结合使用时，异常特别有用。然而，在某些情况下，使用这种结构可能会很笨拙，使代码几乎无法阅读。另一个考虑因素是，许多类最终会抛出您未预料到的异常。在这种情况下，拥有某种回退异常处理程序将是非常理想的。
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we define a generic exception handling class, `Application\Error\Handler`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个通用异常处理类，`Application\Error\Handler`：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We define properties that represents a log file. If the name is not supplied,
    it is named after the year, month, and day. In the constructor, we use `set_exception_handler()`
    to assign the `exceptionHandler()` method (in this class) as the fallback handler:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了代表日志文件的属性。如果未提供名称，则以年、月和日命名。在构造函数中，我们使用`set_exception_handler()`将`exceptionHandler()`方法（在这个类中）分配为回退处理程序：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we define the `exceptionHandler()` method, which takes an `Exception`
    object as an argument. We record the date and time, the class name of the exception,
    and its message in the log file:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义`exceptionHandler()`方法，它以`Exception`对象作为参数。我们记录异常的日期和时间、异常的类名以及其消息在日志文件中：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If we specifically put a `try/catch` block in our code, this will override our
    universal exception handler. If, on the other hand, we do not use try/catch and
    an exception is thrown, the universal exception handler will come into play.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在代码中明确放置了`try/catch`块，这将覆盖我们的通用异常处理程序。另一方面，如果我们不使用try/catch并且抛出异常，通用异常处理程序将发挥作用。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: You should always use try/catch to trap exceptions and possibly continue in
    your application. The exception handler described here is only designed to allow
    your application to end "gracefully" in situations where exceptions thrown have
    not been caught.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终使用try/catch来捕获异常，并可能在应用程序中继续。这里描述的异常处理程序仅旨在允许您的应用程序在未捕获的异常情况下“优雅”地结束。
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, place the code shown in the preceding recipe into a `Handler.php` file
    in the `Application\Error` folder. Next, define a test class that will throw an
    exception. For the purposes of illustration, create an `Application\Error\ThrowsException`
    class that will throw an exception. As an example, set up a PDO instance with
    the error mode set to `PDO::ERRMODE_EXCEPTION`. You then craft an SQL statement
    that is guaranteed to fail:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将前面一节中显示的代码放入`Application\Error`文件夹中的`Handler.php`文件中。接下来，定义一个将抛出异常的测试类。为了举例，创建一个`Application\Error\ThrowsException`类，它将抛出一个异常。例如，设置一个PDO实例，错误模式设置为`PDO::ERRMODE_EXCEPTION`。然后编写一个肯定会失败的SQL语句：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, define a calling program called `chap_13_exception_handler.php` that
    sets up autoloading, uses the appropriate classes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个名为`chap_13_exception_handler.php`的调用程序，设置自动加载，使用适当的类：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At this point, if you create a `ThrowsException` instance without implementing
    the universal handler, a `Fatal Error` is generated as an exception has been thrown
    but not caught:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果您创建一个没有实现通用处理程序的`ThrowsException`实例，将生成一个`致命错误`，因为已经抛出了一个异常但没有被捕获：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![How it works...](graphics/B05314_13_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_13_02.jpg)'
- en: 'If, on the other hand, you use a `try/catch` block, the exception will be caught
    and your application is allowed to continue, if it is stable enough:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你使用`try/catch`块，异常将被捕获，你的应用程序将被允许继续，如果它足够稳定的话。
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You will observe the following output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你会观察到以下输出：
- en: '![How it works...](graphics/B05314_13_03.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_13_03.jpg)'
- en: 'To demonstrate use of the exception handler, define a `Handler` instance, passing
    a parameter that represents the directory to contain log files, before the `try/catch`
    block. After `try/catch`, outside the block, create another instance of `ThrowsException`.
    When you run this sample program, you will notice that the first exception is
    caught inside the `try/catch` block, and the second exception is caught by the
    handler. You will also note that after the handler, the application ends:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示异常处理程序的使用，首先定义一个`Handler`实例，传递一个表示包含日志文件的目录的参数，然后在`try/catch`块之前。在`try/catch`块之后，块外部，创建另一个`ThrowsException`实例。当运行这个示例程序时，你会注意到第一个异常在`try/catch`块内被捕获，第二个异常被处理程序捕获。你还会注意到，在处理程序之后，应用程序结束了。
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is the output from the completed example program, along with the contents
    of the log file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完成示例程序的输出，以及日志文件的内容：
- en: '![How it works...](graphics/B05314_13_04.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_13_04.jpg)'
- en: See also
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'It might be a good idea to review the documentation on the `set_exception_handler()`
    function. Have a look, especially, at the comment (posted 7 years ago, but still
    pertinent) by Anonymous that clarifies how this function works: [http://php.net/manual/en/function.set-exception-handler.php](http://php.net/manual/en/function.set-exception-handler.php).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能是一个好主意去查看`set_exception_handler()`函数的文档。特别要看看Anonymous在7年前发布的评论，澄清了这个函数的工作原理：[http://php.net/manual/en/function.set-exception-handler.php](http://php.net/manual/en/function.set-exception-handler.php)。
- en: Universal error handler
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用错误处理程序
- en: The process of developing a universal error handler is quite similar to the
    preceding recipe. There are certain differences, however. First of all, in PHP
    7, some errors are thrown and can be caught, whereas others simply stop your application
    dead in its tracks. To further confuse matters, some errors are treated like exceptions,
    whereas others are derived from the new PHP 7 `Error` class. Fortunately for us,
    in PHP 7, both `Error` and `Exception` implement a new interface called `Throwable`.
    Accordingly, if you are not sure whether your code will throw an `Exception` or
    an `Error`, simply catch an instance of `Throwable` and you'll catch both.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 开发通用错误处理程序的过程与前面的步骤非常相似。然而，也有一些区别。首先，在PHP 7中，一些错误被抛出并可以被捕获，而其他错误会直接停止你的应用程序。更让人困惑的是，一些错误被视为异常，而另一些则源自新的PHP
    7 `Error`类。幸运的是，在PHP 7中，`Error`和`Exception`都实现了一个叫做`Throwable`的新接口。因此，如果你不确定你的代码会抛出一个`Exception`还是一个`Error`，只需捕获`Throwable`的一个实例，你就能捕获两者。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Modify the `Application\Error\Handler` class defined in the preceding recipe.
    In the constructor, set a new `errorHandler()` method as the default error handler:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改前面步骤中定义的`Application\Error\Handler`类。在构造函数中，将一个新的`errorHandler()`方法设置为默认的错误处理程序：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We then define the new method, using the documented parameters. As with our
    exception handler, we log information to a log file:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用文档化的参数定义新方法。与我们的异常处理程序一样，我们将信息记录到日志文件中。
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Also, just to be able to distinguish errors from exceptions, add `EXCEPTION`
    to the message sent to the log file in the `exceptionHandler()` method:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，为了能够区分错误和异常，将`EXCEPTION`添加到`exceptionHandler()`方法中发送到日志文件的消息中：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, make the changes to `Application\Error\Handler` as defined previously.
    Next, create a class that throws an error that, for this illustration, could be
    defined as `Application\Error\ThrowsError`. For example, you could have a method
    that attempts a divide by zero operation, and another that attempts to parse non-PHP
    code using `eval()`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照之前定义的方式更改`Application\Error\Handler`。接下来，创建一个类，抛出一个错误，可以定义为`Application\Error\ThrowsError`。例如，你可以有一个尝试除以零的方法，另一个尝试使用`eval()`解析非PHP代码的方法。
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can then define a calling program called `chap_13_error_throwable.php`
    that sets up autoloading, uses the appropriate classes, and creates an instance
    of `ThrowsError`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以定义一个名为`chap_13_error_throwable.php`的调用程序，设置自动加载，使用适当的类，并创建一个`ThrowsError`实例。
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you then call the two methods, without a try/catch block and without defining
    the universal error handler, the first method generates a `Warning`, whereas the
    second throws a `ParseError`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用这两个方法，没有`try/catch`块，也没有定义通用错误处理程序，第一个方法会生成一个`Warning`，而第二个会抛出一个`ParseError`。
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Because this is an error, program execution stops, and you will not see `Application
    continues ...`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个错误，程序执行停止，你将看不到`Application continues ...`：
- en: '![How it works...](graphics/B05314_13_05.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_13_05.jpg)'
- en: 'If you wrap the method calls in `try/catch` blocks and catch `Throwable`, the
    code execution continues:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将方法调用包装在`try/catch`块中，并捕获`Throwable`，代码执行将继续：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'From the following output, you will also note that the program exits with `code
    0`, which tells us all is OK:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下输出中，你还会注意到程序以`code 0`退出，这告诉我们一切都很好：
- en: '![How it works...](graphics/B05314_13_06.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_13_06.jpg)'
- en: 'Finally, after the `try/catch` blocks, run the errors again, moving the echo
    statement to the end. You will see in the output that the errors were caught,
    but in the log file, notice that `DivisionByZeroError` is caught by the exception
    handler, whereas the `ParseError` is caught by the error hander:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`try/catch`块之后再次运行错误，将echo语句移到最后。你会在输出中看到错误被捕获，但在日志文件中，注意到`DivisionByZeroError`被异常处理程序捕获，而`ParseError`被错误处理程序捕获：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![How it works...](graphics/B05314_13_07.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_13_07.jpg)'
- en: See also
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: PHP 7.1 allows you to specify more than one class in the `catch` `()` clause.
    So, instead of a single `Throwable` you could say `catch` `(Exception` `|` `Error
    $e)` `{` `xxx` `}`
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 7.1允许您在`catch` `()`子句中指定多个类。因此，您可以说`catch` `(Exception` `|` `Error $e)`
    `{` `xxx` `}`
- en: Writing a simple test
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个简单的测试
- en: 'The primary means of testing PHP code is to use **PHPUnit**, which is based
    on a methodology called **Unit Testing**. The philosophy behind unit testing is
    quite simple: you break down your code into the smallest possible logical units.
    You then test each unit in isolation to confirm that it performs as expected.
    These expectations are codified into a series of **assertions**. If all assertions
    return `TRUE`, then the unit has passed the test.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 测试PHP代码的主要方法是使用**PHPUnit**，它基于一种称为**单元测试**的方法论。单元测试背后的哲学非常简单：将代码分解为尽可能小的逻辑单元。然后分别测试每个单元，以确认其表现如预期。这些期望被编码为一系列**断言**。如果所有断言返回`TRUE`，则该单元通过了测试。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the case of procedural PHP, a unit is a function. For OOP PHP, the unit is
    a method within a class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序化PHP的情况下，一个单元是一个函数。对于OOP PHP，单元是类中的一个方法。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The first order of business is to either install PHPUnit directly onto your
    development server, or download the source code, which is available in the form
    of a single **phar** (**PHP archive**) file. A quick visit to the official website
    for PHPUnit ([https://phpunit.de/](https://phpunit.de/)) lets us download right
    from the main page.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首要任务是直接在开发服务器上安装PHPUnit，或者下载源代码，源代码以单个**phar**（**PHP存档**）文件的形式提供。快速访问PHPUnit的官方网站（[https://phpunit.de/](https://phpunit.de/)）让我们可以直接从主页下载。
- en: 'It is a best practice, however, to use a package manager to both install and
    maintain PHPUnit. For this purpose, we will use a package management program called
    **Composer**. To install Composer, visit the main website, [https://getcomposer.org/](https://getcomposer.org/),
    and follow the instructions on the download page. The current procedure, at the
    time of writing, is as follows. Note that you need to substitute the hash of the
    current version in place of `<hash>`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，最佳实践是使用软件包管理器来安装和维护PHPUnit。为此，我们将使用一个名为**Composer**的软件包管理程序。要安装Composer，请访问主网站[https://getcomposer.org/](https://getcomposer.org/)，并按照下载页面上的说明进行操作。在撰写本文时，当前的过程如下。请注意，您需要用当前版本的哈希替换`<hash>`：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: The advantage of using a package management program such as Composer is that
    it will not only install, but can also be used to update any external software
    (such as PHPUnit) used by your application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Composer等软件包管理程序的优势在于它不仅可以安装，还可以用于更新应用程序使用的任何外部软件（如PHPUnit）。
- en: 'Next, we use Composer to install PHPUnit. This is accomplished by creating
    a `composer.json` file that contains a series of directives outlining project
    parameters and dependencies. A full description of these directives is beyond
    the scope of this book; however, for the purposes of this recipe, we create a
    minimal set of directives using the key parameter `require`. You will also note
    that the contents of the file are in **JavaScript Object Notation** (**JSON**)
    format:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用Composer来安装PHPUnit。这是通过创建一个包含一系列指令的`composer.json`文件来实现的，这些指令概述了项目参数和依赖关系。这些指令的完整描述超出了本书的范围；然而，为了这个示例，我们使用`require`关键参数创建了一组最小的指令。您还会注意到文件的内容是以**JavaScript对象表示**（**JSON**）格式呈现的：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To perform the installation from the command line, we run the following command.
    The output is shown just after:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从命令行执行安装，我们运行以下命令。输出如下所示：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![How to do it...](graphics/B05314_13_08.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B05314_13_08.jpg)'
- en: 'PHPUnit and its dependencies are placed in a `vendor` folder that Composer
    will create if it does not already exist. The primary command to invoke PHPUnit
    is then symbolically linked into the `vendor/bin` folder. If you place this folder
    in your `PATH`, all you need do is to run this command, which checks the version
    and incidentally confirms the installation:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PHPUnit及其依赖项被放置在`vendor`文件夹中，如果不存在，Composer将创建它。然后，调用PHPUnit的主要命令被符号链接到`vendor/bin`文件夹中。如果您将此文件夹放在您的`PATH`中，您只需要运行此命令，它将检查版本并顺便确认安装：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Running simple tests
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行简单测试
- en: 'For the purposes of this illustration, let''s assume we have a `chap_13_unit_test_simple.php`
    file that contains the `add()` function:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们假设我们有一个包含`add()`函数的`chap_13_unit_test_simple.php`文件：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Tests are then written as classes that extend `PHPUnit\Framework\TestCase`.
    If you are testing a library of functions, at the beginning of the test class,
    include the file that contains function definitions. You would then write methods
    that start with the word `test`, usually followed by the name of the function
    you are testing, and possibly some additional CamelCase words to further describe
    the test. For the purposes of this recipe, we will define a `SimpleTest` test
    class:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试然后被写成扩展`PHPUnit\Framework\TestCase`的类。如果你正在测试一个函数库，在测试类的开头，包括包含函数定义的文件。然后你会写一些以单词`test`开头的方法，通常后面跟着你正在测试的函数的名称，可能还有一些额外的驼峰命名的单词来进一步描述测试。为了这个示例，我们将定义一个`SimpleTest`测试类：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Assertions form the heart of any set of tests. The `See also` section gives
    you the documentation reference for the complete list of assertions. An assertion
    is a PHPUnit method that compares a known value against a value produced by that
    which you wish to test. An example is `assertEquals()`, which checks to see whether
    the first argument equals the second. The following example tests a method called
    `add()` and confirms **2** is the return value for `add(1,1)`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言构成了任何一组测试的核心。`另请参阅`部分为您提供了完整断言列表的文档参考。断言是一个PHPUnit方法，它比较一个已知值与您希望测试的值产生的值。例如`assertEquals()`，它检查第一个参数是否等于第二个参数。以下示例测试了一个名为`add()`的方法，并确认`add(1,1)`的返回值为**2**：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can also test to see whether something is *not* true. This example asserts
    that 1 + 1 does not equal 3:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您也可以测试某些事情是否*不*成立。这个例子断言1 + 1不等于3：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'An assertion that is extremely useful when used to test a string is `assertRegExp()`.
    Assume, for this illustration, that we are testing a function that produces an
    HTML table out of a multidimensional array:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试字符串时，使用`assertRegExp()`断言非常有用。假设，为了举例说明，我们正在测试一个函数，该函数从多维数组中生成HTML表：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can construct a simple test that confirms that the output contains `<table>`,
    one or more characters, followed by `</table>`. Further, we wish to confirm that
    a `<td>B</td>` element exists. When writing the test, we build a test array that
    consists of three sub-arrays containing the letters A—C, D—F, and G—I. We then
    pass the test array to the function, and run assertions against the result:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以构建一个简单的测试，确认输出包含`<table>`，一个或多个字符，然后是`</table>`。此外，我们希望确认存在一个`<td>B</td>`元素。在编写测试时，我们构建一个测试数组，其中包含三个子数组，分别包含字母A—C，D—F和G—I。然后我们将测试数组传递给函数，并对结果运行断言：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To test a class, instead of including a library of functions, simply include
    the file that defines the class to be tested. For the sake of illustration, let''s
    take the library of functions shown previously and move them into a `Demo` class:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试一个类，而不是包含一个函数库，只需包含定义要测试的类的文件。为了举例说明，让我们将先前显示的函数库移动到一个`Demo`类中：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In our `SimpleClassTest` test class, instead of including the library file,
    we include the file that represents the `Demo` class. We need an instance of `Demo`
    in order to run tests. For this purpose, we use a specially designed `setup()`
    method, which is run before each test. Also, you will note a `teardown()` method,
    which is run immediately after each test:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`SimpleClassTest`测试类中，我们不包含库文件，而是包含代表`Demo`类的文件。我们需要`Demo`的一个实例来运行测试。为此，我们使用一个专门设计的`setup()`方法，在每次测试之前运行。此外，您会注意到一个`teardown()`方法，在每次测试后立即运行：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The reason why `setup()` and `teardown()` are run before and after each test
    is to ensure a fresh test environment. That way, the results of one test will
    not influence the results of another test.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次测试之前和之后运行`setup()`和`teardown()`的原因是确保一个新鲜的测试环境。这样，一个测试的结果不会影响另一个测试的结果。
- en: Testing database Model classes
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试数据库模型类
- en: When testing a class, such as a Model class, that has database access, other
    considerations come into play. The main consideration is that you should run tests
    against a test database, not the real database used in production. A final point
    is that by using a test database, you can populate it in advance with appropriate,
    controlled data. `setup()` and `teardown()` could also be used to add or remove
    test data.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试具有数据库访问权限的类（例如模型类）时，还有其他考虑因素。主要考虑因素是，您应该针对测试数据库而不是生产中使用的真实数据库运行测试。最后一点是，通过使用测试数据库，您可以提前使用适当的受控数据填充它。`setup()`和`teardown()`也可以用于添加或删除测试数据。
- en: 'As an example of a class that uses the database, we will define a class `VisitorOps`.
    The new class will include methods to add, remove, and find visitors. Note that
    we''ve also added a method to return the latest SQL statement executed:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为使用数据库的类的示例，我们将定义一个`VisitorOps`类。新类将包括添加、删除和查找访问者的方法。请注意，我们还添加了一个方法来返回最新执行的SQL语句：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For tests that involve a database, it is recommended that you use a test database
    instead of the live production database. Accordingly, you will need an extra set
    of database connection parameters that can be used to establish a database connection
    in the `setup()` method.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于涉及数据库的测试，建议使用测试数据库，而不是实际生产数据库。因此，您需要额外的数据库连接参数集，可以在`setup()`方法中用于建立数据库连接。
- en: It's possible that you wish to establish a consistent block of sample data.
    This could be inserted into the test database in the `setup()` method.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能希望建立一个一致的样本数据块。这可以在`setup()`方法中插入到测试数据库中。
- en: Finally, you may wish to reset the test database after each test, which is accomplished
    in the `teardown()` method.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可能希望在每次测试后重置测试数据库，这可以在`teardown()`方法中完成。
- en: Using mock classes
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模拟类
- en: In some cases, the test will access complex components that require external
    resources. An example is a service class that needs access to a database. It is
    a best practice to minimize database access in a test suite. Another consideration
    is that we are not testing database access; we are only testing the functionality
    of one specific class. Accordingly, it is sometimes necessary to define **mock**
    classes that mimic the behavior of the their parent class, but that restrict access
    to external resources.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在某些情况下，测试将访问需要外部资源的复杂组件。一个例子是需要访问数据库的服务类。最佳实践是尽量减少测试套件中对数据库的访问。另一个考虑因素是我们不是在测试数据库访问；我们只是在测试一个特定类的功能。因此，有时需要定义**模拟**类，模仿其父类的行为，但限制对外部资源的访问。
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Limit actual database access in your tests to the Model (or equivalent) classes.
    Otherwise, the time it takes to run the entire set of tests could become excessive.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，将实际数据库访问限制在模型（或等效）类中。否则，运行整套测试所需的时间可能会变得过多。
- en: 'In this case, for illustration, define a service class, `VisitorService`, which
    makes use of the `VisitorOps` class discussed earlier:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，为了举例说明，定义一个服务类`VisitorService`，它使用先前讨论的`VisitorOps`类：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For test purposes, we add a getter and setter for the `$visitorOps` property.
    This allows us to insert a mock class in place of the real `VisitorOps` class:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试目的，我们为`$visitorOps`属性添加了getter和setter。这使我们能够在真实的`VisitorOps`类的位置插入一个模拟类：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we define a `VisitorOpsMock` mock class that mimics the functionality
    of its parent class. Class constants and properties are inherited. We then add
    mock test data, and a getter in case we need access to the test data later:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`VisitorOpsMock`模拟类，模拟其父类的功能。类常量和属性都会被继承。然后我们添加模拟测试数据，并添加一个getter以便以后访问测试数据：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we override `findAll()` to return test data using `yield`, just as in
    the parent class. Note that we still build the SQL string, as this is what the
    parent class does:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们覆盖`findAll()`以使用`yield`返回测试数据，就像父类一样。请注意，我们仍然构建SQL字符串，因为这是父类的做法：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To mock `findById()` we simply return that array key from `$this->testData`.
    For `removeById()`, we unset the array key supplied as a parameter from `$this->testData`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了模拟`findById()`，我们只需从`$this->testData`返回该数组键。对于`removeById()`，我们从`$this->testData`中取消设置为参数的数组键：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Adding data is slightly more complicated in that we need to emulate the fact
    that the `id` parameter might not be supplied, as the database would normally
    auto-generate this for us. To get around this, we check for the `id` parameter.
    If not set, we find the largest array key and increment:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加数据稍微复杂一些，因为我们需要模拟`id`参数可能不会被提供的情况，因为数据库通常会自动生成这个参数。为了解决这个问题，我们检查`id`参数。如果没有设置，我们找到最大的数组键并递增：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Using anonymous classes as mock objects
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用匿名类作为模拟对象
- en: A nice variation on mock objects involves the use of the new PHP 7 anonymous
    class in place of creating a formal class that defines mock functionality. The
    advantage of using an anonymous class is that you can extend an existing class,
    which makes the object appear legitimate. This approach is especially useful if
    you only need to override one or two methods.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟对象的一个很好的变化是使用新的PHP 7匿名类来代替创建定义模拟功能的正式类。使用匿名类的优势在于可以扩展现有类，使对象看起来合法。如果您只需要覆盖一两个方法，这种方法尤其有用。
- en: 'For this illustration, we will modify `VisitorServiceTest.php` presented previously,
    calling it `VisitorServiceTestAnonClass.php`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将修改之前介绍的`VisitorServiceTest.php`，将其命名为`VisitorServiceTestAnonClass.php`：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You will notice that in `setup()`, we define an anonymous class that extends
    `VisitorOps`. We only need to override the `findAll()` method:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到在`setup()`中，我们定义了一个匿名类，它扩展了`VisitorOps`。我们只需要覆盖`findAll()`方法：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Note that in `testShowAllVisitors()`, when `$this->visitorService->showAllVisitors()`
    is executed, the anonymous class is called by the visitor service, which in turn
    calls the overridden `findAll()`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，在`testShowAllVisitors()`中，当执行`$this->visitorService->showAllVisitors()`时，访客服务会调用匿名类，然后调用覆盖的`findAll()`：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Using Mock Builder
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模拟构建器
- en: Another technique is to use `getMockBuilder()`. Although this approach does
    not allow a great deal of finite control over the mock object produced, it's extremely
    useful in situations where you only need to confirm that an object of a certain
    class is returned, and when a specified method is run, this method returns some
    expected value.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种技术是使用`getMockBuilder()`。虽然这种方法不能对生成的模拟对象进行精细控制，但在您只需要确认返回某个类的对象，并且当运行指定方法时，该方法返回某个预期值的情况下，它非常有用。
- en: 'In the following example, we copied `VisitorServiceTestAnonClass`; the only
    difference is in how an instance of `VisitorOps` is supplied in `setup()`, in
    this case, using `getMockBuilder()`. Note that although we did not use `with()`
    in this example, it is used to feed controlled parameters to the mocked method:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们复制了`VisitorServiceTestAnonClass`；唯一的区别在于在`setup()`中提供`VisitorOps`的实例的方式，在这种情况下使用`getMockBuilder()`。请注意，尽管在这个例子中我们没有使用`with()`，但它被用来向模拟方法提供受控参数：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have shown how to create simple one-off tests. In most cases, however, you
    will have many classes that need to be tested, preferably all at once. This is
    possible by developing a *test suite*, discussed in more detail in the next recipe.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何创建简单的一次性测试。然而，在大多数情况下，您将需要测试许多类，最好一次性测试所有类。这可以通过开发一个*测试套件*来实现，下一个示例中将更详细地讨论。
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, you need to install PHPUnit, as discussed in steps 1 to 5\. Be sure to
    include `vendor/bin` in your PATH so that you can run PHPUnit from the command
    line.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要安装PHPUnit，如步骤1到5所述。确保在您的PATH中包含`vendor/bin`，这样您就可以从命令行运行PHPUnit。
- en: Running simple tests
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行简单测试
- en: Next, define a `chap_13_unit_test_simple.php` program file with a series of
    simple functions, such as `add()`, `sub()` and so on, as discussed in step 1\.
    You can then define a simple test class contained in `SimpleTest.php` as mentioned
    in steps 2 and 3.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个`chap_13_unit_test_simple.php`程序文件，其中包含一系列简单的函数，如`add()`、`sub()`等，如步骤1所述。然后，您可以按照步骤2和3中提到的方式定义一个包含在`SimpleTest.php`中的简单测试类。
- en: 'Assuming `phpunit` is in your `PATH`, from a terminal window, change to the
    directory containing the code developed for this recipe, and run the following
    command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`phpunit`在您的`PATH`中，从终端窗口，切换到为这个示例开发的代码所在的目录，并运行以下命令：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You should see the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Running simple tests](graphics/B05314_13_09.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![运行简单测试](graphics/B05314_13_09.jpg)'
- en: 'Make a change in `SimpleTest.php` so that the test will fail (step 4):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SimpleTest.php`中进行更改，使测试失败（步骤4）：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here is the revised output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修改后的输出：
- en: '![Running simple tests](graphics/B05314_13_10.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![运行简单测试](graphics/B05314_13_10.jpg)'
- en: Next, add the `table()` function to `chap_13_unit_test_simple.php` (step 5),
    and `testTable()` to `SimpleTest.php` (step 6). Re-run the unit test and observe
    the results.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加`table()`函数到`chap_13_unit_test_simple.php`（步骤5），并在`SimpleTest.php`中添加`testTable()`（步骤6）。重新运行单元测试并观察结果。
- en: To test a class, copy the functions developed in `chap_13_unit_test_simple.php`
    to a `Demo` class (step 7). After making the modifications to `SimpleTest.php`
    suggested in step 8, re-run the simple test and observe the results.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个类，将在`chap_13_unit_test_simple.php`中开发的函数复制到一个`Demo`类中（步骤7）。在按照步骤8建议的对`SimpleTest.php`进行修改后，重新运行简单测试并观察结果。
- en: Testing database model classes
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试数据库模型类
- en: 'First, create an example class to be tested, `VisitorOps`, shown in step 2
    in this subsection. You can now define a class we will call `SimpleDatabaseTest`
    to test `VisitorOps`. First of all, use `require_once` to load the class to test.
    (We will discuss how to incorporate autoloading in the next recipe!) Then define
    key properties, including test database configuration and test data. You could
    use `php7cookbook_test` as the test database:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个要测试的示例类`VisitorOps`，如本小节中的步骤2所示。现在，您可以定义一个名为`SimpleDatabaseTest`的类来测试`VisitorOps`。首先使用`require_once`加载要测试的类。（我们将讨论如何在下一个示例中使用自动加载！）然后定义关键属性，包括测试数据库配置和测试数据。您可以使用`php7cookbook_test`作为测试数据库：
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, define `setup()`, which inserts the test data, and confirms that the
    last SQL statement was `INSERT`. You should also check to see whether the return
    value was positive:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义`setup()`，插入测试数据，并确认最后一个SQL语句是`INSERT`。您还应该检查返回值是否为正数：
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After that, define `teardown()`, which removes the test data and confirms that
    the query for `id = 1` comes back as `FALSE`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，定义`teardown()`，删除测试数据，并确认`id = 1`的查询结果为`FALSE`：
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The first test is for `findAll()`. First, confirm the data type of the result.
    You could take the topmost element using `current()`. We confirm there are five
    elements, that one of them is `name`, and that the value is the same as that in
    the test data:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试是`findAll()`。首先，确认结果的数据类型。您可以使用`current()`来获取顶部元素。我们确认有五个元素，其中一个是`name`，并且该值与测试数据中的值相同：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The next test is for `findById()`. It is almost identical to `testFindAll()`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试是`findById()`。它几乎与`testFindAll()`相同：
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You do not need to bother with a test for `removeById()` as this is already
    done in `teardown()`. Likewise, there is no need to test `runSql()` as this is
    done as part of the other tests.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要为`removeById()`编写测试，因为这已经在`teardown()`中完成了。同样，也不需要测试`runSql()`，因为这是其他测试的一部分。
- en: Using mock classes
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模拟类
- en: First, define a `VisitorService` service class as described in steps 2 and 3
    in this subsection. Next, define a `VisitorOpsMock` mock class, which is discussed
    in steps 4 to 7.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照本小节中步骤2和3的描述定义一个`VisitorService`服务类。接下来，定义一个`VisitorOpsMock`模拟类，步骤4到7中有讨论。
- en: 'You are now in a position to develop a test, `VisitorServiceTest`, for the
    service class. Note that you need provide your own database configuration as it
    is a best practice to use a test database instead of the production version:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以为服务类开发一个名为`VisitorServiceTest`的测试。请注意，您需要提供自己的数据库配置，因为最佳实践是使用测试数据库而不是生产版本：
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In `setup()`, create an instance of the service, and insert `VisitorOpsMock`
    in place of the original class:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup()`中，创建服务的实例，并将`VisitorOpsMock`替换原始类：
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In our test, which produces an HTML table from the list of visitors, you can
    then look for certain elements, knowing what to expect in advance as you have
    control over the test data:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，从访客列表生成HTML表格，您可以查找特定元素，事先知道可以期望什么，因为您对测试数据有控制：
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You might then wish to experiment with the variations suggested in the last
    two subsections, *Using Anonymous Classes as Mock Objects*, and *Using Mock Builder*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可能希望尝试最后两个小节中建议的变体，即*使用匿名类作为模拟对象*和*使用模拟构建器*。
- en: There's more...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Other assertions test operations on numbers, strings, arrays, objects, files,
    JSON, and XML, as summarized in the following table:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 其他断言测试操作包括数字、字符串、数组、对象、文件、JSON和XML，如下表所总结的：
- en: '| Category | Assertions |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| Category | 断言 |'
- en: '| --- | --- |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| General | `assertEquals()`, `assertFalse()`, `assertEmpty()`, `assertNull()`,
    `assertSame(), assertThat()`, `assertTrue()` |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| General | `assertEquals()`，`assertFalse()`，`assertEmpty()`，`assertNull()`，`assertSame()`，`assertThat()`，`assertTrue()`
    |'
- en: '| Numeric | `assertGreaterThan()`, `assertGreaterThanOrEqual()`, `assertLessThan()`,
    `assertLessThanOrEqual()`, `assertNan()`, `assertInfinite()` |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| Numeric | `assertGreaterThan()`，`assertGreaterThanOrEqual()`，`assertLessThan()`，`assertLessThanOrEqual()`，`assertNan()`，`assertInfinite()`
    |'
- en: '| String | `assertStringEndsWith()`, `assertStringEqualsFile()`, `assertStringStartsWith()`,
    `assertRegExp()`, `assertStringMatchesFormat()`, `assertStringMatchesFormatFile()`
    |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| String | `assertStringEndsWith()`，`assertStringEqualsFile()`，`assertStringStartsWith()`，`assertRegExp()`，`assertStringMatchesFormat()`，`assertStringMatchesFormatFile()`
    |'
- en: '| Array/iterator | `assertArrayHasKey()`, `assertArraySubset()`, `assertContains()`,
    `assertContainsOnly()`, `assertContainsOnlyInstancesOf()`, `assertCount()` |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| Array/iterator | `assertArrayHasKey()`，`assertArraySubset()`，`assertContains()`，`assertContainsOnly()`，`assertContainsOnlyInstancesOf()`，`assertCount()`
    |'
- en: '| File | `assertFileEquals()`, `assertFileExists()` |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| File | `assertFileEquals()`，`assertFileExists()` |'
- en: '| Objects | `assertClassHasAttribute()`, `assertClassHasStaticAttribute()`,
    `assertInstanceOf()`, `assertInternalType()`, `assertObjectHasAttribute()` |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| Objects | `assertClassHasAttribute()`，`assertClassHasStaticAttribute()`，`assertInstanceOf()`，`assertInternalType()`，`assertObjectHasAttribute()`
    |'
- en: '| JSON | `assertJsonFileEqualsJsonFile()`, `assertJsonStringEqualsJsonFile()`,
    `assertJsonStringEqualsJsonString()` |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| JSON | `assertJsonFileEqualsJsonFile()`，`assertJsonStringEqualsJsonFile()`，`assertJsonStringEqualsJsonString()`
    |'
- en: '| XML | `assertEqualXMLStructure()`, `assertXmlFileEqualsXmlFile()`, `assertXmlStringEqualsXmlFile()`,
    `assertXmlStringEqualsXmlString()` |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| XML | `assertEqualXMLStructure()`，`assertXmlFileEqualsXmlFile()`，`assertXmlStringEqualsXmlFile()`，`assertXmlStringEqualsXmlString()`
    |'
- en: See also...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For a good discussion on unit testing, have a look here: [https://en.wikipedia.org/wiki/Unit_testing](https://en.wikipedia.org/wiki/Unit_testing).'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解有关单元测试的讨论，请查看这里：[https://en.wikipedia.org/wiki/Unit_testing](https://en.wikipedia.org/wiki/Unit_testing)。
- en: For more information on `composer.json` file directives, see [https://getcomposer.org/doc/04-schema.md](https://getcomposer.org/doc/04-schema.md).
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`composer.json`文件指令的更多信息，请参阅[https://getcomposer.org/doc/04-schema.md](https://getcomposer.org/doc/04-schema.md)。
- en: 'For a complete list of assertions, have a look at this PHPUnit documentation
    page: [https://phpunit.de/manual/current/en/phpunit-book.html#appendixes.assertions](https://phpunit.de/manual/current/en/phpunit-book.html#appendixes.assertions).'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看完整的断言列表，请查看PHPUnit文档页面：[https://phpunit.de/manual/current/en/phpunit-book.html#appendixes.assertions](https://phpunit.de/manual/current/en/phpunit-book.html#appendixes.assertions)。
- en: 'The PHPUnit documentation also goes into using `getMockBuilder()` in detail
    here: [https://phpunit.de/manual/current/en/phpunit-book.html#test-doubles.mock-objects](https://phpunit.de/manual/current/en/phpunit-book.html#test-doubles.mock-objects)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHPUnit文档还详细介绍了在这里使用`getMockBuilder()`：[https://phpunit.de/manual/current/en/phpunit-book.html#test-doubles.mock-objects](https://phpunit.de/manual/current/en/phpunit-book.html#test-doubles.mock-objects)
- en: Writing a test suite
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试套件
- en: You may have noticed after having read through the previous recipe that it can
    quickly become tedious to have to manually run `phpunit` and specify test classes
    and PHP filenames. This is especially true when dealing with applications that
    employ dozens or even hundreds of classes and files. The PHPUnit project has a
    built-in capability to handle running multiple tests with a single command. Such
    a set of tests is referred to as a **test suite**.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完上一篇后，您可能已经注意到手动运行`phpunit`并指定测试类和PHP文件可能会变得乏味。特别是在处理应用程序时，这些应用程序使用数十甚至数百个类和文件。PHPUnit项目具有处理单个命令运行多个测试的内置功能。这样的一组测试称为**测试套件**。
- en: How to do it...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'At its simplest, all you need to do is to move all the tests into a single
    folder:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最简单的情况下，您只需要将所有测试移动到一个文件夹中：
- en: '[PRE57]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You''ll need to adjust commands that include or require external files to account
    for the new location. The example shown (`SimpleTest`) was developed in the preceding
    recipe:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要调整包含或需要外部文件的命令，以适应新位置。所示的示例（SimpleTest）是在前一篇中开发的：
- en: '[PRE58]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can then simply run `phpunit` with the directory path as an argument. PHPUnit
    will then automatically run all tests in that folder. In this example, we assume
    there is a `tests` subdirectory:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以简单地使用目录路径作为参数运行`phpunit`。PHPUnit将自动运行该文件夹中的所有测试。在此示例中，我们假设有一个`tests`子目录：
- en: '[PRE59]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can use the `--bootstrap` option to specify a file that is executed prior
    to running the tests. A typical use for this option is to initiate autoloading:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`--bootstrap`选项指定在运行测试之前执行的文件。此选项的典型用法是初始化自动加载：
- en: '[PRE60]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here is the sample `bootstrap.php` file that implements autoloading:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是实现自动加载的示例`bootstrap.php`文件：
- en: '[PRE61]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Another possibility is to define one or more sets of tests using an XML configuration
    file. Here is an example that runs only the Simple* tests:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种可能性是使用XML配置文件定义一个或多个测试集。以下是一个示例，仅运行Simple*测试：
- en: '[PRE62]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here is another example that runs a test based on a directory and also specifies
    a bootstrap file:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是另一个示例，它基于目录运行测试，并指定了一个引导文件：
- en: '[PRE63]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作...
- en: Make sure all the tests discussed in the previous recipe, *Writing a simple
    test*, have been defined. You can then create a `tests` folder and move or copy
    all the `*Test.php` files into this folder. You'll then need to adjust the path
    in the `require_once` statements, as shown in step 2.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在上一篇中讨论的所有测试“编写简单测试”中已经定义。然后可以创建一个`tests`文件夹，并将所有`*Test.php`文件移动或复制到此文件夹中。然后需要调整`require_once`语句中的路径，如第2步所示。
- en: 'In order to demonstrate how PHPUnit can run all tests in a folder, from the
    directory containing the source code you defined for this chapter, run the following
    command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示PHPUnit如何运行本章为您定义的源代码中的所有测试，运行以下命令：
- en: '[PRE64]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You should see the following output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![How it works...](graphics/B05314_13_11.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_13_11.jpg)'
- en: 'To demonstrate the use of a autoloading via a bootstrap file, create a new
    `tests_with_autoload` directory. In this folder, define a `bootstrap.php` file
    with the code shown in step 5\. Create two directories in `tests_with_autoload`:
    `Demo` and `Simple`.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示通过引导文件进行自动加载，创建一个新的`tests_with_autoload`目录。在此文件夹中，使用步骤5中显示的代码定义一个`bootstrap.php`文件。在`tests_with_autoload`中创建两个目录：`Demo`和`Simple`。
- en: 'From the directory containing the source code for this chapter, copy the file
    (discussed in step 12 of the previous recipe) into `tests_with_autoload/Demo/Demo.php`.
    After the opening `<?php` tag, add this line:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从包含本章源代码的目录中，将文件（在上一篇中的第12步中讨论）复制到`tests_with_autoload/Demo/Demo.php`中。在开头的`<?php`标记后，添加这一行：
- en: '[PRE65]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, copy the `SimpleTest.php` file to `tests_with_autoload/Simple/ClassTest.php`.
    (Notice the filename change!). You will need to change the first few lines to
    the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`SimpleTest.php`文件复制到`tests_with_autoload/Simple/ClassTest.php`中（注意文件名更改！）。您需要将前几行更改为以下内容：
- en: '[PRE66]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'After that, create a `tests_with_autoload/phpunit.xml` file that pulls everything
    together:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，创建一个`tests_with_autoload/phpunit.xml`文件，将所有内容整合在一起：
- en: '[PRE67]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Finally, change to the directory that contains the code for this chapter. You
    can now run a unit test that incorporates a bootstrap file, along with autoloading
    and namespaces, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，切换到包含本章代码的目录。现在，您可以运行一个包含引导文件的单元测试，以及自动加载和命名空间，如下所示：
- en: '[PRE68]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The output should appear as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![How it works...](graphics/B05314_13_12.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_13_12.jpg)'
- en: See also...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more information on writing PHPUnit test suites, have a look at this documentation
    page: [https://phpunit.de/manual/current/en/phpunit-book.html#organizing-tests.xml-configuration](https://phpunit.de/manual/current/en/phpunit-book.html#organizing-tests.xml-configuration).'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关编写PHPUnit测试套件的更多信息，请参阅此文档页面：[https://phpunit.de/manual/current/en/phpunit-book.html#organizing-tests.xml-configuration](https://phpunit.de/manual/current/en/phpunit-book.html#organizing-tests.xml-configuration)。
- en: Generating fake test data
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成虚假测试数据
- en: Part of the testing and debugging process involves incorporating realistic test
    data. In some cases, especially when testing database access and producing benchmarks,
    large amounts of test data are needed. One way in which this can be accomplished
    is to incorporate a process of scraping data from websites, and then putting the
    data together in realistic, yet random, combinations to be inserted into a database.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和调试过程的一部分涉及整合真实的测试数据。在某些情况下，特别是在测试数据库访问和生成基准时，需要大量的测试数据。可以通过从网站中抓取数据的过程，然后将数据以真实但随机的组合放入数据库中来实现这一点。
- en: How to do it...
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The first step is to determine what data is needed in order to test your application.
    Another consideration is dose the website address an international audience, or
    will the market be primarily from a single country?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是确定测试应用程序所需的数据。另一个考虑因素是网站是否面向国际受众，还是市场主要来自单一国家？
- en: In order to produce a consistent fake data tool, it's extremely important to
    move the data from its source into a usable digital format. The first choice is
    a series of database tables. Another, not as attractive, alternative is a CSV
    file.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了生成一致的假数据工具，将数据从其来源移动到可用的数字格式非常重要。第一选择是一系列数据库表。另一个不太吸引人的选择是CSV文件。
- en: You may end up converting the data in stages. For example, you could pull data
    from a web page that lists country codes and country names into a text file.![How
    to do it...](graphics/B05314_13_13.jpg)
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能会分阶段转换数据。例如，您可以从列出国家代码和国家名称的网页中提取数据到一个文本文件中。![操作步骤...](graphics/B05314_13_13.jpg)
- en: Since this list is short, it's easy to literally cut and paste this into a text
    file.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个列表很短，将其直接剪切并粘贴到文本文件中非常容易。
- en: We can then do a search for " " and replace with "`\n`", which gives us this:![How
    to do it...](graphics/B05314_13_14.jpg)
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以搜索“ ”并替换为“`\n`”，得到如下结果：![操作步骤...](graphics/B05314_13_14.jpg)
- en: This can then be imported into a spreadsheet, which then lets you export to
    a CSV file. From there, it's a simple matter to import it into a database. phpMyAdmin,
    for example, has such a facility.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后可以将其导入电子表格，然后可以将其导出为CSV文件。从那里，将其导入数据库就变得很简单。例如，phpMyAdmin就有这样的功能。
- en: 'For the sake of this illustration, we will assume that we are generating data
    that will end up in the `prospects` table. Here is the SQL statement used to create
    this table:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们假设我们正在生成最终将出现在`prospects`表中的数据。以下是用于创建此表的SQL语句：
- en: '[PRE69]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now it''s time to create a class that is capable of generating fake data. We
    will then create methods to generate data for each of the fields shown above,
    except for `id`, which is auto-generated:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候创建一个能够生成假数据的类了。然后我们将创建方法来为上面显示的每个字段生成数据，除了`id`，它是自动生成的：
- en: '[PRE70]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we define constants and properties that will be used as part of the process:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义将用作过程一部分的常量和属性：
- en: '[PRE71]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We then define properties that will be used to generate random letters, street
    names, and e-mail addresses. You can think of these arrays as seeds that can be
    modified and/or expanded to suite your needs. As an example, you might substitute
    street name fragments in Paris for a French audience:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义将用于生成随机字母、街道名称和电子邮件地址的属性。您可以将这些数组视为种子，可以根据需要进行修改和/或扩展。例如，您可以为法国受众替换巴黎的街道名称片段：
- en: '[PRE72]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the constructor, we accept a `Connection` object, used for database access,
    an array of mappings to the fake data:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们接受一个用于数据库访问的`Connection`对象，一个映射到假数据的数组：
- en: '[PRE73]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To generate street names, rather than attempt to create a database table, it
    might be more efficient to use a set of seed arrays to generate random combinations.
    Here is an example of how this might work:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了生成街道名称，而不是尝试创建一个数据库表，使用一组种子数组来生成随机组合可能更有效。以下是这种方法可能的工作方式的示例：
- en: '[PRE74]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Depending on the level of realism desired, you could also build a database
    table that matches postal codes to cities. Postal codes could also be randomly
    generated. Here is an example that generates postal codes for the UK:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据所需的逼真程度，您还可以构建一个将邮政编码与城市匹配的数据库表。邮政编码也可以随机生成。以下是一个为英国生成邮政编码的示例：
- en: '[PRE75]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Fake e-mail generation can likewise use a set of seed arrays to produce random
    results. We could also program it to receive an existing `$entry` array, with
    parameters, and use those parameters to create the name portion of the address:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成假电子邮件也可以使用一组种子数组来产生随机结果。我们还可以编程让它接收一个现有的`$entry`数组，并使用这些参数来创建地址的名称部分：
- en: '[PRE76]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'For date generation, one approach would be to accept as arguments an existing
    `$entry` array, with parameters. The parameters would be an array where the first
    value is a start date. The second parameter would be the maximum number of days
    to *subtract* from the start date. This effectively lets you return a random date
    from a range. Note that we use `DateTime::sub()` to subtract a random number of
    days. `sub()` requires a `DateInterval` instance, which we build using `P`, the
    random number of days, and then `''D''`:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于日期生成，一个方法是接受一个现有的`$entry`数组作为参数。参数将是一个数组，其中第一个值是开始日期。第二个参数将是从开始日期*减去*的最大天数。这实际上让您从一个范围返回一个随机日期。请注意，我们使用`DateTime::sub()`来减去随机天数。`sub()`需要一个`DateInterval`实例，我们使用`P`、随机天数和`'D'`来构建它：
- en: '[PRE77]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As mentioned at the beginning of this recipe, the data sources we will use
    for fake data generation will vary. In some cases, as shown in the previous few
    steps, we use seed arrays, and build the fake data. In other cases, we might want
    to use a text or CSV file as a data source. Here is how such a method might look:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如本教程开始时提到的，我们用于生成假数据的数据源会有所不同。在某些情况下，如前面几个步骤所示，我们使用种子数组，并构建假数据。在其他情况下，我们可能希望使用文本或CSV文件作为数据源。以下是这种方法可能的样子：
- en: '[PRE78]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You will note that we first need to pull the file data into an array, which
    forms the return value. Here is the method that does that for us. We throw an
    `Exception` if the specified file is not found. The file type is identified as
    one of our class constants: `FILE_TYPE_TEXT` or `FILE_TYPE_CSV`. Depending on
    the type, we use either `fgetcsv()` or `fgets()`:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到，我们首先需要将文件数据提取到一个数组中，这个数组形成了返回值。以下是为我们执行此操作的方法。如果找不到指定的文件，我们会抛出一个`Exception`。文件类型被识别为我们的类常量之一：`FILE_TYPE_TEXT`或`FILE_TYPE_CSV`。根据类型，我们使用`fgetcsv()`或`fgets()`：
- en: '[PRE79]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Probably the most complicated aspect of this process is drawing random data
    from a database table. We accept as arguments the table name, the name of the
    column that comprises the primary key, an array that maps between the database
    column name in the lookup table, and the target column name:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个过程中可能最复杂的部分是从数据库表中抽取随机数据。我们接受表名、包含主键的列的名称、在查找表中数据库列名和目标列名之间映射的数组作为参数：
- en: '[PRE80]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We are now in a position to set up the prepared statement and initialize a
    number of critical variables:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以设置准备好的语句并初始化一些关键变量：
- en: '[PRE81]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The actual lookup we place inside a `do...while` loop. The reason for this
    is that we need to run the query at least once to achieve results. Only if we
    do not arrive at a result do we continue with the loop. We generate a random number
    between the lowest ID and the highest ID, and then use this in a parameter in
    the query. Notice that we also decrement a counter to prevent an endless loop.
    This is in case the IDs are not sequential, in which case we could accidentally
    generate an ID that does not exist. If we exceed the maximum attempts, still with
    no results, we throw an `Exception`:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将实际的查找放在一个`do...while`循环中。原因是我们至少需要运行一次查询才能得到结果。只有当我们没有得到结果时，我们才继续循环。我们生成一个介于最低ID和最高ID之间的随机数，然后在查询的参数中使用这个数。请注意，我们还要减少一个计数器以防止无限循环。这是因为ID不是连续的情况下，我们可能会意外地生成一个不存在的ID。如果我们超过了最大尝试次数，仍然没有结果，我们会抛出一个`Exception`：
- en: '[PRE82]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We then use the mapping array to retrieve values from the source table using
    keys expected in the destination table:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用映射数组从源表中检索值，使用目标表中预期的键：
- en: '[PRE83]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The heart of this class is a `getRandomEntry()` method, which generates a single
    array of fake data. We loop through `$mapping` one entry at a time and examine
    the various parameters:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类的核心是一个`getRandomEntry()`方法，它生成一个假数据的数组。我们逐个遍历`$mapping`，并检查各种参数：
- en: '[PRE84]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `source` parameter is used to implement what effectively serves as a Strategy
    Pattern. We support four different possibilities for `source`, all defined as
    class constants. The first one is `SOURCE_FILE`. In this case, we use the `getEntryFromFile()`
    method discussed previously:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`source`参数用于实现有效地作为策略模式的功能。我们支持四种不同的`source`，都定义为类常量。第一个是`SOURCE_FILE`。在这种情况下，我们使用之前讨论过的`getEntryFromFile()`方法：'
- en: '[PRE85]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The callback option returns a value according to the callback supplied in the
    `$mapping` array:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回调选项根据`$mapping`数组中提供的回调返回一个值：
- en: '[PRE86]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `SOURCE_TABLE` option uses the database table defined in `$mapping` as
    a lookup. Note that `getEntryFromTable()`, discussed previously, is able to return
    an array of values, which means we need to use `array_merge()` to consolidate
    the results:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SOURCE_TABLE`选项使用`$mapping`中定义的数据库表作为查找。请注意，之前讨论的`getEntryFromTable()`能够返回一个值数组，这意味着我们需要使用`array_merge()`来合并结果：'
- en: '[PRE87]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `SOURCE_METHOD` option, which is also the default, uses a method already
    included with this class. We check to see whether parameters are included, and,
    if so, add those to the method call. Note the use of `{}` to influence interpolation.
    If we made a `$this->$value[''name'']()` PHP 7 call, due to the Abstract Syntax
    Tree (AST) rewrite, it would interpolate like this, `${$this->$value}[''name'']()`,
    which is not what we want:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SOURCE_METHOD`选项，也是默认选项，使用了这个类中已经包含的一个方法。我们检查是否包括了参数，如果有，就将其添加到方法调用中。注意使用`{}`来影响插值。如果我们进行了`$this->$value[''name'']()`的PHP
    7调用，由于抽象语法树（AST）的重写，它会插值为`${$this->$value}[''name'']()`，这不是我们想要的：'
- en: '[PRE88]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We define a method that loops through `getRandomEntry()` to produce multiple
    lines of fake data. We also add an option to insert to a destination table. If
    this option is enabled, we set up a prepared statement to insert, and also check
    to see whether we need to truncate any data currently in this table:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个循环遍历`getRandomEntry()`以生成多行假数据的方法。我们还添加了一个选项来插入到目标表。如果启用了这个选项，我们设置一个准备好的语句来插入，并检查是否需要截断当前表中的任何数据：
- en: '[PRE89]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Next, we loop through the number of lines of data requested, and run `getRandomEntry()`.
    If a database insert is requested, we execute the prepared statement in a `try/catch`
    block. In any event, we turn this method into a generator using the `yield` keyword:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们循环请求的数据行数，并运行`getRandomEntry()`。如果请求插入数据库，我们在`try/catch`块中执行准备好的语句。无论如何，我们使用`yield`关键字将这个方法转换为生成器：
- en: '[PRE90]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Tip
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: If the amount of data to be returned is massive, it's much better to yield the
    data as it is produced, thus saving the memory required for an array.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要返回的数据量很大，最好在生成数据时将数据作为生成的数据，从而节省数组所需的内存。
- en: How it works...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The first thing to do is to ensure you have the data ready for random data generation.
    In this recipe, we will presume that the destination table is `prospects`, which
    has the following SQL database definition shown in step 7.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是确保你已经准备好了随机数据生成的数据。在这个示例中，我们假设目标表是`prospects`，其SQL数据库定义如步骤7所示。
- en: As a data source for names, you could create text files for first names and
    surnames. In this illustration, we will reference the `data/files` directory,
    and the files `first_names.txt` and `surnames.txt`. For city, state or province,
    postal code, and country, it might be useful to download the data from a source
    such as [http://www.geonames.org/](http://www.geonames.org/), and upload to a
    `world_city_data` table. For the remaining fields, such as address, e-mail, status,
    and so on, you could either use methods built into `FakeData`, or define callbacks.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 作为名字的数据源，你可以创建名字和姓氏的文本文件。在这个示例中，我们将引用`data/files`目录和文件`first_names.txt`和`surnames.txt`。对于城市、州或省、邮政编码和国家，可能有必要从[http://www.geonames.org/](http://www.geonames.org/)这样的来源下载数据，并上传到`world_city_data`表中。对于其余的字段，比如地址、电子邮件、状态等，你可以使用`FakeData`中内置的方法，或者定义回调函数。
- en: 'Next, be sure to define `Application\Test\FakeData`, adding the content discussed
    in steps 8 to 29\. After you have finished, create a calling program called `chap_13_fake_data.php`,
    which sets up autoloading and uses the appropriate classes. You should also define
    constants that match the path to the database configuration, and names files:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请确保定义`Application\Test\FakeData`，添加步骤8到29中讨论的内容。完成后，创建一个名为`chap_13_fake_data.php`的调用程序，设置自动加载并使用适当的类。您还应该定义与数据库配置路径和文件名匹配的常量：
- en: '[PRE91]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next, define a mapping array that uses the column names in the destination
    table (prospects) as a key. You need to then define sub-keys for `source`, `name`,
    and any other parameters that are required. For starters, ''`first_name`'' and
    ''`last_name`'' will both use a file as a source, ''name'' points to the name
    of the file, and ''`type`'' indicates a file type of text:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个映射数组，该数组使用目标表（prospects）中的列名作为键。然后，您需要为`source`、`name`和任何其他所需的参数定义子键。首先，'`first_name`'和'`last_name`'都将使用文件作为源，'name'指向文件的名称，'`type`'表示文本文件类型：
- en: '[PRE92]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The `''address''`, `''email''`, and `''last_updated''` all use built-in methods
    as a data source. The last two also define parameters to be passed:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`''address''`、`''email''`和`''last_updated''`都使用内置方法作为数据源。最后两个还定义了要传递的参数：'
- en: '[PRE93]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `''phone''`, `''status''` and `''budget''` could all use callbacks to provide
    fake data:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`''phone''`、`''status''`和`''budget''`都可以使用回调来提供虚假数据：'
- en: '[PRE94]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'And finally, `''city''` draws its data from a lookup table, which also gives
    you data for the fields listed in the `''mapping''` parameter. You can then leave
    those keys undefined. Notice that you should also specify the column representing
    the primary key for the table:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`'city'`从查找表中获取数据，该表还为`'mapping'`参数中列出的字段提供数据。然后，您可以将这些键未定义。请注意，您还应指定表示表的主键的列：
- en: '[PRE95]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'You can then define the destination table, a `Connection` instance, and create
    the `FakeData` instance. A `foreach()` loop will suffice to display a given number
    of entries:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以定义目标表、`Connection`实例，并创建`FakeData`实例。`foreach()`循环足以显示给定数量的条目：
- en: '[PRE96]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The output, for 10 rows, would look something like this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 对于10行，输出将如下所示：
- en: '![How it works...](graphics/B05314_13_15.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_13_15.jpg)'
- en: There's more...
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here is a summary of websites with various lists of data that could be of use
    when generating test data:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是各种数据列表的网站摘要，这些数据列表在生成测试数据时可能有用：
- en: '| Type of Data | URL | Notes |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | URL | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Names | [http://nameberry.com/](http://nameberry.com/) |   |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 名字 | [http://nameberry.com/](http://nameberry.com/) |   |'
- en: '|   | [http://www.babynamewizard.com/international-names-lists-popular-names-from-around-the-world](http://www.babynamewizard.com/international-names-lists-popular-names-from-around-the-world)
    |   |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '|   | [http://www.babynamewizard.com/international-names-lists-popular-names-from-around-the-world](http://www.babynamewizard.com/international-names-lists-popular-names-from-around-the-world)
    |   |'
- en: '| Raw Name Lists | [http://deron.meranda.us/data/census-dist-female-first.txt](http://deron.meranda.us/data/census-dist-female-first.txt)
    | US female first names |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 原始姓名列表 | [http://deron.meranda.us/data/census-dist-female-first.txt](http://deron.meranda.us/data/census-dist-female-first.txt)
    | 美国女性名字 |'
- en: '|   | [http://deron.meranda.us/data/census-dist-male-first.txt](http://deron.meranda.us/data/census-dist-male-first.txt)
    | US male first names |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '|   | [http://deron.meranda.us/data/census-dist-male-first.txt](http://deron.meranda.us/data/census-dist-male-first.txt)
    | 美国男性名字 |'
- en: '|   | [http://www.avss.ucsb.edu/NameFema.HTM](http://www.avss.ucsb.edu/NameFema.HTM)
    | US female first names |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '|   | [http://www.avss.ucsb.edu/NameFema.HTM](http://www.avss.ucsb.edu/NameFema.HTM)
    | 美国女性名字 |'
- en: '|   | [http://www.avss.ucsb.edu/namemal.htm](http://www.avss.ucsb.edu/namemal.htm)
    | US male first names |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '|   | [http://www.avss.ucsb.edu/namemal.htm](http://www.avss.ucsb.edu/namemal.htm)
    | 美国男性名字 |'
- en: '| Last Names | [http://names.mongabay.com/data/1000.html](http://names.mongabay.com/data/1000.html)
    | US surnames from census |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 姓氏 | [http://names.mongabay.com/data/1000.html](http://names.mongabay.com/data/1000.html)
    | 美国人口普查中的美国姓氏 |'
- en: '|   | [http://surname.sofeminine.co.uk/w/surnames/most-common-surnames-in-great-britain.html](http://surname.sofeminine.co.uk/w/surnames/most-common-surnames-in-great-britain.html)
    | British surnames |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '|   | [http://surname.sofeminine.co.uk/w/surnames/most-common-surnames-in-great-britain.html](http://surname.sofeminine.co.uk/w/surnames/most-common-surnames-in-great-britain.html)
    | 英国姓氏 |'
- en: '|   | [https://gist.github.com/subodhghulaxe/8148971](https://gist.github.com/subodhghulaxe/8148971)
    | List of US surnames in the form of a PHP array |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '|   | [https://gist.github.com/subodhghulaxe/8148971](https://gist.github.com/subodhghulaxe/8148971)
    | 以PHP数组形式列出的美国姓氏列表 |'
- en: '|   | [http://www.dutchgenealogy.nl/tng/surnames-all.php](http://www.dutchgenealogy.nl/tng/surnames-all.php)
    | Dutch surnames |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '|   | [http://www.dutchgenealogy.nl/tng/surnames-all.php](http://www.dutchgenealogy.nl/tng/surnames-all.php)
    | 荷兰姓氏 |'
- en: '|   | [http://www.worldvitalrecords.com/browsesurnames.aspx?l=A](http://www.worldvitalrecords.com/browsesurnames.aspx?l=A)
    | International surnames; just change the last letter(s) to get a list of names
    starting with that letter(s) |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '|   | [http://www.worldvitalrecords.com/browsesurnames.aspx?l=A](http://www.worldvitalrecords.com/browsesurnames.aspx?l=A)
    | 国际姓氏；只需更改最后一个或多个字母，即可获得以该字母开头的名字列表 |'
- en: '| Cities | [http://www.travelgis.com/default.asp?framesrc=/cities/](http://www.travelgis.com/default.asp?framesrc=/cities/)
    | World cities |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 城市 | [http://www.travelgis.com/default.asp?framesrc=/cities/](http://www.travelgis.com/default.asp?framesrc=/cities/)
    | 世界城市 |'
- en: '|   | [https://www.maxmind.com/en/free-world-cities-database](https://www.maxmind.com/en/free-world-cities-database)
    |   |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '|   | [https://www.maxmind.com/en/free-world-cities-database](https://www.maxmind.com/en/free-world-cities-database)
    |   |'
- en: '|   | [https://github.com/David-Haim/CountriesToCitiesJSON](https://github.com/David-Haim/CountriesToCitiesJSON)
    |   |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '|   | [https://github.com/David-Haim/CountriesToCitiesJSON](https://github.com/David-Haim/CountriesToCitiesJSON)
    |   |'
- en: '|   | [http://www.fallingrain.com/world/index.html](http://www.fallingrain.com/world/index.html)
    |   |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|   | [http://www.fallingrain.com/world/index.html](http://www.fallingrain.com/world/index.html)
    |   |'
- en: '| Postal Codes | [https://boutell.com/zipcodes/](https://boutell.com/zipcodes/)
    | US only; includes cities, postal codes, latitude and longitude |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 邮政编码 | [https://boutell.com/zipcodes/](https://boutell.com/zipcodes/) | 仅限美国；包括城市、邮政编码、纬度和经度
    |'
- en: '|   | [http://www.geonames.org/export/](http://www.geonames.org/export/) |
    International; city names, postal codes, EVERYTHING!; free download |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '|   | [http://www.geonames.org/export/](http://www.geonames.org/export/) |
    国际; 城市名称，邮政编码，一切！; 免费下载 |'
- en: Customizing sessions using session_start parameters
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用session_start参数自定义会话
- en: Up until PHP 7, in order to override `php.ini` settings for secure session management,
    you had to use a series of `ini_set()` commands. This approach is extremely annoying
    in that you also needed to know which settings were available, and being able
    to re-use the same settings in other applications was difficult. As of PHP 7,
    however, you can supply an array of parameters to the `session_start()` command,
    which immediately sets those values.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 直到PHP 7，为了覆盖`php.ini`设置以进行安全会话管理，您必须使用一系列`ini_set()`命令。这种方法非常恼人，因为您还需要知道哪些设置是可用的，并且很难在其他应用程序中重复使用相同的设置。然而，从PHP
    7开始，您可以向`session_start()`命令提供一系列参数，这将立即设置这些值。
- en: How to do it...
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We start by developing an `Application\Security\SessOptions` class, which will
    hold session parameters and also have the ability to start the session. We also
    define a class constant in case invalid session options are passed:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先开发一个`Application\Security\SessOptions`类，该类将保存会话参数，并且还具有启动会话的能力。我们还定义了一个类常量，以防传递无效的会话选项：
- en: '[PRE97]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Next we scan the list of `php.ini` session directives (documented at [http://php.net/manual/en/session.configuration.php](http://php.net/manual/en/session.configuration.php)).
    We are specifically looking for directives that, in the `Changeable` column, are
    marked `PHP_INI_ALL`. Such directives can be overridden at runtime, and are thus
    available as arguments to `session_start()`:![How to do it...](graphics/B05314_13_16.jpg)
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们扫描`php.ini`会话指令列表（在[http://php.net/manual/en/session.configuration.php](http://php.net/manual/en/session.configuration.php)中记录）。我们特别寻找`Changeable`列中标记为`PHP_INI_ALL`的指令。这些指令可以在运行时被覆盖，因此可以作为`session_start()`的参数使用：![如何做...](graphics/B05314_13_16.jpg)
- en: 'We then define these as class constants, which will make this class more usable
    for development purposes. Most decent code editors will be able to scan the class
    and give you a list of constants, making it easy to manage session settings. Please
    note that not all settings are shown, in order to conserve space in the book:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将这些定义为类常量，这将使该类更易于开发。大多数优秀的代码编辑器都能够扫描类并为您提供常量列表，从而轻松管理会话设置。请注意，并非所有设置都显示在书中，以节省空间：
- en: '[PRE98]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We are then in a position to define the constructor, which accepts an array
    of `php.ini` session settings as an argument. We use `ReflectionClass` to get
    a list of class constants, and run the `$options` argument through a loop to confirm
    the setting is allowed. Also note the use of `array_flip()`, which flips keys
    and values, so that the actual values for our class constants form the array key,
    and the name of the class constant becomes the value:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以定义构造函数，它接受一个`php.ini`会话设置数组作为参数。我们使用`ReflectionClass`来获取类常量列表，并通过循环运行`$options`参数来确认设置是否允许。还要注意使用`array_flip()`，它可以翻转键和值，以便我们的类常量的实际值形成数组键，类常量的名称成为值：
- en: '[PRE99]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We then close with two more methods; one gives us outside access to the allowed
    parameters, while the other starts the session:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们以另外两种方法结束；一种方法让我们可以从外部访问允许的参数，另一种方法启动会话：
- en: '[PRE100]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: How it works...
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Place all the code discussed in this recipe into a `SessOptions.php` file in
    the `Application\Security` directory. You can then define a calling program called
    `chap_13_session_options.php` to test the new class, which sets up autoloading
    and uses the class:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 将本章讨论的所有代码放入`Application\Security`目录中的`SessOptions.php`文件中。然后，您可以定义一个名为`chap_13_session_options.php`的调用程序来测试新类，该程序设置自动加载并使用该类：
- en: '[PRE101]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Next, define an array that uses the class constants as keys, with values as
    desired to manage the session. Note that in the example shown here, session information
    is stored in a subdirectory, `session`, which you need to create:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个数组，使用类常量作为键，所需的值来管理会话。请注意，在此处显示的示例中，会话信息存储在一个名为`session`的子目录中，您需要创建该目录：
- en: '[PRE102]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'You can now create the `SessOptions` instance and run `start()` to start the
    session. You could use `phpinfo()` here to show some information on the session:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以创建`SessOptions`实例并运行`start()`来启动会话。您可以在此处使用`phpinfo()`显示有关会话的一些信息：
- en: '[PRE103]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'If you look for information on cookies using your browser''s developer tools,
    you will note the name is set to `UNLIKELYSOURCE` and the expiration time is 5
    minutes from now:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用浏览器的开发人员工具查找有关cookie的信息，您会注意到名称设置为`UNLIKELYSOURCE`，到期时间是从现在开始的5分钟：
- en: '![How it works...](graphics/B05314_13_17.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_13_17.jpg)'
- en: 'If you do a scan of the session directory, you will see that the session information
    has been stored there:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您扫描会话目录，您会看到会话信息已存储在那里：
- en: '![How it works...](graphics/B05314_13_18.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_13_18.jpg)'
- en: See also...
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more information on session-related `php.ini` directives, see this summary:
    [http://php.net/manual/en/session.configuration.php](http://php.net/manual/en/session.configuration.php)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关与会话相关的`php.ini`指令的更多信息，请参阅此摘要：[http://php.net/manual/en/session.configuration.php](http://php.net/manual/en/session.configuration.php)
