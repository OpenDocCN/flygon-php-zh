- en: Chapter 1. Why "Good PHP Developer" Isnt an Oxymoron
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章。为什么“优秀的PHP开发者”不是一个矛盾修辞
- en: Back in 2010, MailChimp published a post on their blog, entitled *Ewww, You
    Use PHP?* In this blog post, they described the horror when they explained their
    choice of PHP to developers who consider the phrase *good PHP programmer* an oxymoron.
    In their rebuttal they argued that their PHP wasn't *your grandfathers PHP* and
    that they use a sophisticated framework. I tend to judge the quality of PHP on
    the basis of, not only how it functions, but how secure it is and how it is architected.
    This book focuses on ideas of how you should architect your code. The design of
    software allows for developers to ease the extension of the code beyond its original
    purpose, in a bug-free and elegant fashion.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，MailChimp在他们的博客上发表了一篇名为“呃，你用PHP？”的文章。在这篇博文中，他们描述了当他们向认为“优秀的PHP程序员”是一个矛盾修辞的开发人员解释他们选择PHP时的恐怖。在他们的反驳中，他们辩称他们的PHP不是“你爷爷的PHP”，他们使用了一个复杂的框架。我倾向于根据PHP的质量来评判，不仅仅是它的功能，还有它的安全性和架构。这本书关注的是关于如何设计代码的想法。软件的设计允许开发人员以无bug和优雅的方式轻松扩展代码的用途。
- en: 'As Martin Fowler put it:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 马丁·福勒说：
- en: '*"Any fool can write code that a computer can understand. Good programmers
    write code that humans can understand."*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “任何傻瓜都可以写出计算机能理解的代码。优秀的程序员写出人类能理解的代码。”
- en: This isn't just limited to code style, but how developers architect and structure
    their code. I've encountered many developers with their noses constantly stuck
    in the documentation, copying and pasting bits of code until it works; hacking
    snippets together until it works. Moreover, I far too often see the software development
    process rapidly deteriorate as developers ever more tightly couple their classes
    with functions of ever increasing length.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅局限于代码风格，而是开发人员如何设计和构建他们的代码。我遇到过许多开发人员，他们总是埋头于文档，复制和粘贴代码片段，直到它能够工作；拼凑代码片段直到它能够工作。此外，我经常看到软件开发过程迅速恶化，因为开发人员将他们的类与越来越长的函数紧密耦合。
- en: Software engineers mustn't just code software; they must know how to design
    it. Indeed often a good software engineer, when interviewing other software engineers
    will ask questions about the design of the code itself. It is trivial to get a
    piece of code that will execute, and it is also benign to question a developer
    as to whether `strtolower` or `str2lower` is the correct name of a function (for
    the record, it's `strtolower`). Knowing the difference between a class and an
    object doesn't make you a competent developer; a better interview question would,
    for example, be how one could apply subtype polymorphism to a real software development
    challenge. Failure to assess software design skills dumbs down an interview and
    results in there being no way to differentiate between those who are good at it,
    and those who aren't. These advanced topics will be discussed throughout this
    book, by learning these tactics, you will better understand what the right questions
    to ask are when discussing software architecture.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师不仅仅是编写软件；他们必须知道如何设计软件。事实上，一个优秀的软件工程师在面试其他软件工程师时会询问关于代码设计本身的问题。获得一段可以执行的代码是微不足道的，询问开发人员`strtolower`或`str2lower`哪个是函数的正确名称也是无害的（记录上，是`strtolower`）。知道类和对象之间的区别并不能让你成为一个称职的开发人员；一个更好的面试问题可能是如何将子类型多态应用于真实的软件开发挑战。未能评估软件设计技能会使面试变得肤浅，并导致无法区分谁擅长它，谁不擅长。这些高级话题将在本书中讨论，通过学习这些策略，你将更好地理解在讨论软件架构时应该问什么问题。
- en: 'Moxie Marlinspike once tweeted the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Moxie Marlinspike曾在推特上发表过以下言论：
- en: '*"As a software developer, I envy writers, musicians, and filmmakers. Unlike
    software, when they create something it is really done, forever".*'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “作为一名软件开发人员，我羡慕作家、音乐家和电影制作人。与软件不同，当他们创作出一些东西时，它真的完成了，永远。”
- en: When developing software, we mustn't forget we are authors, not just of instructions
    for a machine, but we are also authoring something that we later expect others
    to extend upon. Therefore, our code mustn't just be targeted at machines, but
    humans also. Code isn't just poetry for a machine, it should be poetry for humans
    also.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发软件时，我们不能忘记我们是作者，不仅仅是为了机器的指令，而且我们还在创作一些我们希望其他人能够扩展的东西。因此，我们的代码不仅仅是针对机器的，也是针对人类的。代码不仅仅是机器的诗歌，也应该是人类的诗歌。
- en: This is, of course, better said than done. In PHP, this may be found especially
    difficult given the freedom PHP offers developers on how they may architect and
    structure their code. By the very nature of freedom, it may be both used and abused,
    so it is true with the freedom offered in PHP.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然说起来容易做起来难。在PHP中，这可能特别困难，因为PHP为开发人员提供了如何设计和构建他们的代码的自由。由于自由的本质，它可能被使用和滥用，这在PHP提供的自由中也是真实的。
- en: Therefore, it is increasingly important that developers understand proper software
    design practices to ensure their code maintains the long term maintainability.
    Indeed, another key skill lies in *refactoring* code, improving the design of
    existing code to make it easier to extend in the long term.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，开发人员理解适当的软件设计实践以确保他们的代码保持长期可维护性变得越来越重要。事实上，另一个关键技能在于*重构*代码，改进现有代码的设计，使其更容易在长期内扩展。
- en: '**Technical debt**, the eventual consequence of poor system design, is something
    that I''ve found comes with the career of a PHP developer. This has been true
    for me whether it has been dealing with systems that provide advanced functionality
    or simple websites. It usually arises because a developer elects to implement
    a bad design for a variety of reasons; this is when adding functionality to an
    existing codebase or taking poor design decisions during the initial construction
    of software. Refactoring can help us address these issues.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务，糟糕系统设计的最终后果，是我发现作为PHP开发人员职业生涯的一部分。这对我来说是真实的，无论是处理提供高级功能还是简单网站的系统。它通常是因为开发人员选择以各种原因实施糟糕的设计而产生的；这是在向现有代码库添加功能或在软件的初始构建过程中做出糟糕的设计决策时。重构可以帮助我们解决这些问题。
- en: SensioLabs (the creators of the Symfony framework) have a tool called  **Insight**
    that allows developers to calculate the technical debt in their own code. In 2011,
    they did an evaluation of technical debt in various projects using this tool;
    rather unsurprisingly they found that WordPress 4.1 topped the chart of all platforms
    they evaluated with them claiming it would take 20.1 years to resolve the technical
    debt that the project contains.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SensioLabs（Symfony框架的创建者）有一个名为**Insight**的工具，允许开发人员计算他们自己代码中的技术债务。2011年，他们使用这个工具对各种项目进行了技术债务评估；毫不奇怪，他们发现WordPress
    4.1在他们评估的所有平台中名列前茅，他们声称解决项目中的技术债务需要20.1年的时间。
- en: Those familiar with the WordPress core may not be surprised by this, but this
    issue of course is not only associated to WordPress. In my career of working with
    PHP, from working with security critical cryptography systems to working with
    systems that work with mission critical embedded systems, dealing with technical
    debt comes with the job. Dealing with technical debt is not something to be ashamed
    of for a PHP developer, indeed some may consider it courageous. Dealing with technical
    debt is no easy task, especially in the face of an ever more demanding user base,
    client, or project manager; constantly demanding more functionality without being
    familiar with the technical debt the project has associated to it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉WordPress核心的人可能不会对此感到惊讶，但这个问题当然不仅与WordPress有关。在我的PHP职业生涯中，从处理安全关键的加密系统到处理与使命关键嵌入式系统相关的系统，处理技术债务是工作的一部分。处理技术债务对于PHP开发人员来说并不是一件可耻的事情，有些人甚至可能认为这是勇敢的。处理技术债务并不是一件容易的事情，特别是面对越来越苛刻的用户群、客户或项目经理；不断要求更多功能，而不了解项目所带来的技术债务。
- en: I recently e-mailed the PHP Internals group as to whether they should consider
    deprecating the error suppression operator `@`. When any PHP function is prepended
    by an @ symbol, the function will suppress an error returned by it. This can be
    brutal, especially where that function renders a fatal error that stops the execution
    of the script, making debugging a tough task. If the error is suppressed, the
    script may fail to execute without providing developers a reason as to why this
    is. Usage of this operator may be described as an anti-pattern in some situations,
    something we will cover in [Chapter 4](ch04.html "Chapter 4. Structural Design
    Patterns"), *Structural Design Patterns.*
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我最近给PHP Internals组发送了电子邮件，询问他们是否应该考虑废弃错误抑制运算符`@`。当任何PHP函数前面加上@符号时，该函数将抑制其返回的错误。这可能是残酷的，特别是当该函数产生致命错误导致脚本停止执行时，使得调试变得困难。如果错误被抑制，脚本可能无法执行，而不提供开发人员原因。在某些情况下，使用这个运算符可能被描述为反模式，我们将在[第4章](ch04.html
    "第4章 结构设计模式")*结构设计模式*中进行介绍。
- en: Despite the fact that no one objected to the fact that there were better ways
    of handling errors (`try`/`catch`, `proper validation`) than abusing the error
    suppression operator and that deprecation should be an eventual aim of PHP, it
    is the case that some functions return needless warnings even though they already
    have a success/failure value. This means that due to technical debt in the PHP
    core itself, this operator cannot be deprecated until a lot of other prerequisite
    work is done. In the meantime, it is down to developers to decide the best methodologies
    of handling errors. Until the inherent problem of unnecessary error reporting
    is addressed, this operator cannot be deprecated. Therefore, it is down to developers
    to be educated as to the proper methodologies that should be used to address error
    handling and not to constantly resort to using an `@` symbol.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有人反对处理错误的更好方法（`try`/`catch`，`适当的验证`）比滥用错误抑制运算符，并且废弃应该是PHP的最终目标，但事实是，一些函数即使已经有了成功/失败值，仍会返回不必要的警告。这意味着由于PHP核心中的技术债务，这个运算符在很多其他先决条件工作完成之前无法被废弃。与此同时，开发人员需要决定处理错误的最佳方法。在不解决不必要的错误报告的固有问题之前，这个运算符无法被废弃。因此，开发人员需要接受教育，了解应该用于处理错误的适当方法，而不是不断地使用`@`符号。
- en: Fundamentally, technical debt slows down development of a project and often
    leads to code being deployed that is broken as developers try and work on a fragile
    project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上说，技术债务减缓了项目的开发速度，并经常导致部署的代码存在问题，因为开发人员试图在一个脆弱的项目上工作。
- en: When starting a new project, never be afraid to discuss architecture as architecture
    meetings are vital to developer collaboration; as one Scrum Master I've worked
    with said in the face of criticism that "meetings are a great alternative to work",
    he said "meetings are work...how much work would you be doing without meetings?".
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始新项目时，永远不要害怕讨论架构，因为架构会议对开发人员的合作至关重要；正如我与之合作过的Scrum Master在面对“会议是工作的绝佳替代品”这一批评时所说的，“会议就是工作……如果没有会议，你会做多少工作？”
- en: 'In the rest of this chapter, we will cover the following points:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将涵盖以下几点：
- en: Coding style - the PSR standards
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码风格-PSR标准
- en: Revising object-oriented programming
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修订面向对象编程
- en: Setting up the environment with Composer
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Composer设置环境
- en: Who are the Gang of Four?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁是四人帮？
- en: Coding style - the PSR standards
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码风格 - PSR标准
- en: When it comes to coding style, I would like to introduce you to the PSR standards
    created by the PHP Framework Interop Group. Namely, the two standards that apply
    to coding standards are PSR-1 (Basic Coding Style) and PSR-2 (Coding Style Guide).
    In addition to this, there are PSR standards that cover additional areas, for
    example, as of today; the PSR-4 standard is the most up-to-date autoloading standard
    published by the group. You can find out more about the standards at [http://www.php-fig.org/](http://www.php-fig.org/).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码风格方面，我想向你介绍PHP框架互操作组创建的PSR标准。具体来说，适用于编码标准的两个标准是PSR-1（基本编码风格）和PSR-2（编码风格指南）。除此之外，还有PSR标准涵盖其他领域，例如，截至今天；PSR-4标准是该组发布的最新的自动加载标准。你可以在[http://www.php-fig.org/](http://www.php-fig.org/)找到更多关于这些标准的信息。
- en: Coding style being used to enforce consistency throughout a code base is something
    I strongly believe in. It does make a difference to your code readability throughout
    a project. It is especially important when you are starting a project (chances
    are you may be reading this book to find out how to do that right) as your coding
    style determines the style the developers following you in working on this project
    will adopt. Using a global standard such as PSR-1 or PSR-2 means that developers
    can easily switch between projects without having to reconfigure their code style
    in their IDE. Good code style can make formatting errors easier to spot. Needless
    to say that coding styles will develop as time progresses, to date I elect to
    work with the PSR standards.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我坚信使用编码风格来强制执行代码库中的一致性。这确实会对整个项目中的代码可读性产生影响。特别是在开始一个项目时（很可能你正在阅读本书以找出如何正确做到这一点），因为你的编码风格决定了在这个项目上跟随你的开发人员将采用的风格。使用PSR-1或PSR-2这样的全局标准意味着开发人员可以轻松地在项目之间切换，而不必在他们的IDE中重新配置他们的代码风格。良好的代码风格可以使格式错误更容易发现。毋庸置疑，随着时间的推移，编码风格会发展，迄今为止，我选择遵循PSR标准。
- en: 'I am a strong believer in the phrase: a*lways code as if the guy who ends up
    maintaining your code will be a violent psychopath who knows where you live*.
    It isn''t known who wrote this phrase originally, but it''s widely thought that
    it could have been John Woods or potentially Martin Golding.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我坚信这句话：*永远编写代码，就好像最终维护你的代码的人是一个知道你住在哪里的暴力精神病患者*。虽然不知道谁最初写下这句话，但普遍认为可能是约翰·伍兹或者马丁·戈尔丁。
- en: I would strongly recommend familiarizing yourself with these standards before
    proceeding in this book.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议在继续阅读本书之前熟悉这些标准。
- en: Revising object-oriented programming
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修订面向对象编程
- en: Object-oriented programming is more than just classes and objects; it's a whole
    programming paradigm based around *objects* (data structures) that contain data
    fields and methods. It is essential to understand this; using classes to organize
    a bunch of unrelated methods together is not object orientation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程不仅仅是类和对象；它是一种基于*对象*（数据结构）的整个编程范式，其中包含数据字段和方法。理解这一点至关重要；使用类来组织一堆无关的方法并不是面向对象。
- en: Assuming you're aware of classes (and how to instantiate them), allow me to
    remind you of a few different bits and pieces.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经了解了类（以及如何实例化它们），让我提醒你一些不同的要点。
- en: Polymorphism
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态
- en: Polymorphism is a fairly long word for a fairly simple concept. Essentially,
    polymorphism means the same *interface* is used with a different underlying code.
    So multiple classes could have a draw function, each accepting the same arguments,
    but at an underlying level, the code is implemented differently.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是一个相当长的词，表示一个相当简单的概念。本质上，多态意味着相同的*接口*与不同的基础代码一起使用。因此，多个类可以有一个绘制函数，每个函数接受相同的参数，但在基础级别上，代码实现是不同的。
- en: In this section, I would like to talk about Subtype Polymorphism in particular
    (also known as Subtyping or Inclusion Polymorphism).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我想特别谈谈子类型多态（也称为子类型或包含多态）。
- en: Let's say we have animals as our supertype; our subtypes may well be cats, dogs,
    and sheep.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的超类型是动物；我们的子类型可能是猫、狗和羊。
- en: In PHP, interfaces allow you to define a set of functionality that a class that
    implements it must contain, as of PHP 7 you can also use scalar type hints to
    define the return types we expect.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，接口允许你定义一个类必须包含的一组功能，从PHP 7开始，你还可以使用标量类型提示来定义我们期望的返回类型。
- en: 'So for example, suppose we defined the following interface:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们定义了以下接口：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We could then implement this interface in our own class, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在我们自己的类中实现这个接口，如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we were to run this code without defining the classes we would get an error
    message as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在没有定义类的情况下运行此代码，将会收到以下错误消息：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Essentially, we are required to implement the methods we defined in our interface,
    so now let''s go ahead and create a class that implements these methods:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，我们需要实现我们在接口中定义的方法，所以现在让我们创建一个实现这些方法的类：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we''ve implemented these methods, we can then just instantiate the
    class we are after and use the functions contained in it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了这些方法，我们可以实例化我们想要的类并使用其中包含的函数：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So where does polymorphism come into this? Suppose we had another class for
    a dog:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么多态是如何发挥作用的呢？假设我们有另一个类代表狗：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now let''s suppose we have multiple different types of animals in a `pets`
    array:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们在`pets`数组中有多种不同类型的动物：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can now actually go ahead and loop through all these pets individually in
    order to run the `talk` function. We don't care about the type of pet because
    the `talk` method that is implemented in every class we get is by virtue of us
    having extended the Animals interface.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以逐个循环遍历所有这些宠物，以便运行`talk`函数。我们不关心宠物的类型，因为我们扩展了动物接口，所以我们得到的每个类中实现的`talk`方法都是由我们实现的。
- en: 'So let''s suppose we wanted to have all our animals run the `talk` method.
    We could just use the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想让所有的动物都运行`talk`方法。我们可以使用以下代码：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: No need for unnecessary `switch`/`case` blocks in order to wrap around our classes,
    we just use software design to make things easier for us in the long-term.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要不必要的`switch`/`case`块来包装我们的类，我们只需使用软件设计来让事情变得更容易。
- en: Abstract classes work in a similar way, except for the fact that abstract classes
    can contain functionality where interfaces cannot.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类的工作方式类似，不同之处在于抽象类可以包含功能，而接口则不行。
- en: 'It is important to note that any class that defines one or more abstract classes
    must also be defined as abstract. You cannot have a normal class defining abstract
    methods, but you can have normal methods in abstract classes. Let''s start off
    by refactoring our interface to be an abstract class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，任何定义了一个或多个抽象类的类也必须被定义为抽象类。你不能有一个普通类定义抽象方法，但你可以在抽象类中有普通方法。让我们从重构我们的接口开始，将其变成一个抽象类：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You might have noticed that I have also added a `walk` method as an ordinary,
    non-abstract method; this is a standard method that can be used or extended by
    any classes that inherit the parent abstract class. They already have their implementation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我还添加了一个`walk`方法作为一个普通的、非抽象的方法；这是一个标准的方法，可以被任何继承父抽象类的类使用或扩展。它们已经有了它们的实现。
- en: Note that it is impossible to instantiate an abstract class (much like it's
    not possible to instantiate an interface). Instead, we must extend it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无法实例化抽象类（就像无法实例化接口一样）。相反，我们必须扩展它。
- en: 'So, in our `Cat` class let''s remove the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在我们的`Cat`类中让我们移除以下内容：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will replace it with the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用以下代码替换它：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That''s all we need to refactor in order to get classes to extend the `Animal`
    abstract class. We must implement the abstract functions in the classes as we
    outlined for the interfaces, plus we can use the ordinary functions without needing
    to implement them:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要重构的全部内容，以便让类扩展`Animal`抽象类。我们必须按照我们为接口所概述的那样在类中实现抽象函数，另外我们可以使用普通函数而不需要实现它们：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As of PHP 5.4 it has also become possible to instantiate a class and access
    a property of it in one system. PHP.net advertised it as: *Class member access
    on instantiation has been added, e.g. (new Foo)->bar().* You can also do it with
    individual properties, for example, `(new Cat)->legs`. In our example, we can
    use it as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从PHP 5.4开始，也可以在一个系统中实例化一个类并访问它的属性。PHP.net宣传它为：*在实例化时添加类成员访问，例如（new Foo）->bar()。*你也可以对单个属性这样做，例如，（new
    Cat）->legs。在我们的例子中，我们可以这样使用它：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Just to recap a few other points about how PHP implemented OOP, the `final`
    keyword before a class declaration or indeed a function declaration means that
    you cannot override such classes or functions after they've been defined.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 再来回顾一下PHP如何实现OOP的其他一些要点，类声明之前或者函数声明之前的`final`关键字意味着在它们被定义之后不能覆盖这样的类或函数。
- en: 'So, let''s try extending a class we have named as `final`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们尝试扩展一个我们称之为`final`的类：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This results in the following output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Similarly, let''s do the same except at a function level:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，让我们在函数级别做同样的事情：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This results in the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Traits (multiple inheritance)
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Trait（多重继承）
- en: '**Traits** were introduced in PHP as a mechanism for introducing Horizontal
    Reuse. PHP conventionally acts as a single inheritance language, because of the
    fact that you can''t inherit more than one class into a script.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**Trait**被引入到PHP中作为引入水平重用的机制。PHP传统上是一种单继承语言，因为你不能将多个类继承到一个脚本中。'
- en: Traditional multiple inheritance is a controversial process that is often looked
    down upon by software engineers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的多重继承是一个备受软件工程师鄙视的有争议的过程。
- en: 'Let me give you an example of using Traits first hand; let''s define an abstract
    `Animal` class that we want to extend into another class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我先给你举一个使用Trait的例子；让我们定义一个抽象的`Animal`类，我们想要将其扩展到另一个类中：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So now let's suppose we have a function to name our class, but we don't want
    it to apply to all our classes that extend the `Animal` class, we want it to apply
    to certain classes irrespective of whether they inherit the properties of the
    abstract `Animal` class or not.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们有一个函数来为我们的类命名，但我们不希望它适用于所有扩展`Animal`类的类，我们希望它适用于某些类，无论它们是否继承了抽象`Animal`类的属性。
- en: 'So we''ve defined our functions like so:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们定义了我们的函数如下：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The problem now is that there is no place we can put them without using Horizontal
    Reuse, apart from copying and pasting different bits of code or resorting to using
    conditional inheritance. This is where Traits come to the rescue; let''s start
    off by wrapping these methods in a Trait called `Name`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，除了使用水平重用之外，没有地方可以放置它们，除了复制和粘贴不同的代码片段或者诉诸于使用条件继承。这就是Trait出手的地方；让我们首先把这些方法放在一个叫做`Name`的Trait中。
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So now that we''ve defined our Trait, we can just tell PHP to use it in our
    `Cat` class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的Trait，我们可以告诉PHP在我们的`Cat`类中使用它：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice the use of the `Name` statement? That''s where the magic happens. Now
    you can call the functions in that Trait without any problems:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Name`语句的使用？这就是魔法发生的地方。现在你可以调用Trait中的函数而不会出现任何问题：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'All put together, the new code block looks as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 把所有东西放在一起，新的代码块看起来是这样的：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Scalar type hints
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标量类型提示
- en: Let me take this opportunity to introduce you to a PHP 7 concept known as **scalar
    type hinting**; it allows you to define the return types (yes, I know this isn't
    strictly under the scope of OOP; deal with it).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我借此机会向你介绍一个名为**标量类型提示**的PHP 7概念；它允许你定义返回类型（是的，我知道这严格来说不属于OOP的范围；接受它吧）。
- en: 'Let''s define a function, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个函数，如下所示：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s take a look at this function; firstly you will notice that before each
    of the arguments we define the type of variable we want to receive; in this case,
    it''s int (or integer). Next up, you''ll notice there''s a bit of code after the
    function definition `: int`, which defines our return type so our function can
    only receive an integer.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个函数；首先，您会注意到在每个参数之前，我们定义了我们想要接收的变量类型；在这种情况下，它是int（或整数）。接下来，您会注意到在函数定义之后有一些代码`：int`，它定义了我们的返回类型，因此我们的函数只能接收一个整数。
- en: If you don't provide the right type of variable as a function argument or don't
    return the right type of the variable from the function; you will get a `TypeError`
    exception. In strict mode, PHP will also throw a `TypeError` exception in the
    event that strict mode is enabled and you also provide the incorrect number of
    arguments.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有提供正确类型的变量作为函数参数，或者没有从函数中返回正确类型的变量；您将收到`TypeError`异常。在严格模式下，如果启用了严格模式，并且您还提供了不正确数量的参数，PHP也将抛出`TypeError`异常。
- en: It is also possible in PHP to define `strict_types`; let me explain why you
    might want to do this. Without `strict_types`, PHP will attempt to automatically
    convert a variable to the defined type in very limited circumstances. For example,
    if you pass a string containing solely numbers it will be converted to an integer,
    a string that's non-numeric, however, will result in a `TypeError` exception.
    Once you enable `strict_types` this all changes, you can no longer have this automatic
    casting behavior.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中也可以定义`strict_types`；让我解释为什么您可能想要这样做。没有`strict_types`，PHP将尝试在非常有限的情况下自动将变量转换为定义的类型。例如，如果您传递一个仅包含数字的字符串，它将被转换为整数，然而，一个非数字的字符串将导致`TypeError`异常。一旦您启用了`strict_types`，这一切都会改变，您将不再具有这种自动转换行为。
- en: 'Taking our previous example, without `strict_types`, you could do the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的例子中，没有`strict_types`，您可以执行以下操作：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Trying it again after enabling `strict_types`, you will find that PHP throws
    a `TypeError` exception.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用`strict_types`后再次尝试，您将发现PHP抛出`TypeError`异常。
- en: 'This configuration only applies on an individual file basis, putting it before
    you include other files will not result in this configuration being inherited
    to those files. There are multiple benefits of why PHP chose to go down this route;
    they are listed very clearly in version 0.5.3 of the RFC that implemented scalar
    type hints called **PHP RFC: Scalar Type Declarations**. You can read about it
    by going to [http://www.wiki.php.net](http://www.wiki.php.net) (the wiki, not
    the main PHP website) and searching for `scalar_type_hints_v5`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置只适用于单个文件，将其放在包含其他文件之前不会导致这个配置被继承到那些文件中。PHP选择这条路线有多个好处；它们在实现标量类型提示的RFC版本0.5.3中非常清楚地列出，名为**PHP
    RFC:标量类型声明**。您可以通过访问[http://www.wiki.php.net](http://www.wiki.php.net)（维基，而不是主要的PHP网站）并搜索`scalar_type_hints_v5`来了解更多信息。
- en: 'In order to enable it, make sure you put this as the very first statement in
    your PHP script:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用它，请确保将其作为PHP脚本中的第一个语句：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will not work unless you define `strict_types` as the very first statement
    in a PHP script; no other usages of this definition are permitted. Indeed, if
    you try to define it later on, your script PHP will throw a fatal error.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您将`strict_types`定义为PHP脚本中的第一个语句；不允许对此定义进行其他用途。实际上，如果您尝试稍后定义它，您的脚本PHP将抛出致命错误。
- en: Of course, in the interests of the rage-induced PHP core fanatic reading this
    book in its coffee stained form, I should mention that there are other valid types
    that can be used in type hinting. For example, PHP 5.1.0 introduced this with
    arrays and PHP 5.0.0 introduced the ability for a developer to do this with their
    own classes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，出于对这本书的愤怒的PHP核心狂热分子的利益，我应该提到，还有其他有效的类型可以用于类型提示。例如，PHP 5.1.0引入了数组，PHP 5.0.0引入了开发人员可以对其自己的类进行类型提示的功能。
- en: 'Let me give you a quick example of how this would work in practice, suppose
    we had an `Address` class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你一个快速的实例，说明这在实践中是如何工作的，假设我们有一个`Address`类：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can then type the hint of the `Address` class that we inject into a `Customer`
    class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以对我们注入到`Customer`类中的`Address`类进行类型提示：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And this is how it all can come together:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它如何全部组合在一起：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Limiting debug access to private/protected properties
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制对私有/受保护属性的调试访问
- en: If you define a class which contains private or protected variables, you will
    notice an odd behavior if you were to `var_dump` the object of that class. You
    will notice that when you wrap the object in a `var_dump` it reveals all variables;
    be they protected, private, or public.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您定义一个包含私有或受保护变量的类，您会注意到一个奇怪的行为，如果您`var_dump`该类的对象。您会注意到，当您将对象包装在`var_dump`中时，它会显示所有变量；无论它们是受保护的、私有的还是公共的。
- en: PHP treats `var_dump` as an internal debugging function, meaning all data becomes
    visible.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: PHP将`var_dump`视为内部调试函数，这意味着所有数据都变得可见。
- en: Fortunately, there is a workaround for this. PHP 5.6 introduced the `__debugInfo`
    magic method. Functions in classes preceded by a double underscore represent magic
    methods and have special functionality associated with them. Every time you try
    to `var_dump` an object that has the `__debugInfo` magic method set, the `var_dump`
    will be overridden with the result of that function call instead.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这方面有一个解决方法。PHP 5.6引入了`__debugInfo`魔术方法。在类中以双下划线开头的函数代表魔术方法，并与特殊功能相关联。每当您尝试`var_dump`一个设置了`__debugInfo`魔术方法的对象时，`var_dump`将被该函数调用的结果覆盖。
- en: 'Let me show you how this works in practice, let''s start by defining a class:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我向您展示这在实践中是如何工作的，让我们从定义一个类开始：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s instantiate this class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实例化这个类：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, if we were to try and access the private variable that is `hasPaws`, we
    would get a fatal error:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试访问私有变量`hasPaws`，我们将收到致命错误：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding call would result in the following fatal error being thrown:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的调用将导致抛出以下致命错误：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That is the expected output, we don''t want a `private` property visible outside
    its object. That being said, if we wrap the object with a `var_dump` as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的输出，我们不希望`private`属性在其对象外部可见。也就是说，如果我们用`var_dump`包装对象如下：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We would then get the following output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们会得到以下输出：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, our `private` property is marked as `private`, but nevertheless
    it is visible. So how would we go about preventing this?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们的`private`属性被标记为`private`，但它仍然是可见的。那么我们该如何防止这种情况发生呢？
- en: 'So, let''s redefine our class as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们重新定义我们的类如下：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, after we instantiate our class and `var_dump` the resulting object, we
    get the following output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们实例化我们的类并`var_dump`生成的对象时，我们会得到以下输出：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The script all put together looks like this now, you will notice I''ve added
    an extra `public` property called `growls`, which I have set to `true`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，整个脚本看起来是这样的，您会注意到我添加了一个额外的`public`属性，名为`growls`，我将其设置为`true`：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we were to `var_dump` this script (with both `public` and `private` property
    to play with), we would get the following output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要`var_dump`这个脚本（同时使用`public`和`private`属性），我们会得到以下输出：
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, only the `public` property is visible. So what is the moral
    of the story from this little experiment? Firstly, that `var_dumps` exposes private
    and protected properties inside objects, and secondly, that this behavior can
    be overridden.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，只有`public`属性是可见的。那么从这个小实验中的故事的道德是什么呢？首先，`var_dumps`暴露了对象中的私有和受保护属性，其次，这种行为是可以被覆盖的。
- en: Setting up the environment with Composer
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Composer设置环境
- en: '**Composer** is a dependency manager for PHP, strongly inspired by Node''s
    NPM and Bundler. It has now become integral to multiple PHP projects, including
    Laravel and Symfony. Why it is useful for us, however, is that it contains autoload
    functionality that is compliant with the PSR-0 and PSR-4 standards. You can download
    and install Composer from [http://getcomposer.org](http://getcomposer.org).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**Composer**是PHP的一个依赖管理器，受Node的NPM和Bundler的强烈启发。它现在已经成为多个PHP项目的重要组成部分，包括Laravel和Symfony。然而，对我们来说它有用的原因是，它包含符合PSR-0和PSR-4标准的自动加载功能。您可以从[http://getcomposer.org](http://getcomposer.org)下载并安装Composer。'
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In order to install Composer globally on Mac OS X or Linux, first you can run
    the installer:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Mac OS X或Linux上全局安装Composer，首先可以运行安装程序：
- en: '`**curl -sS https://getcomposer.org/installer | php**`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**curl -sS https://getcomposer.org/installer | php**'
- en: 'And then you can move Composer to install it globally:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以将Composer移动到全局安装：
- en: '`**mv composer.phar /usr/local/bin/composer**`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`**mv composer.phar /usr/local/bin/composer**`'
- en: If the command preceding fails due to a permissions issue, rerun the command
    except putting `sudo` at the very start. You'll be asked to enter your password
    after you type the command, just enter it and hit *Enter*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的命令由于权限问题而失败，请重新运行命令，但在开头加上 `sudo`。在输入命令后，您将被要求输入密码，只需输入密码并按 *Enter*。
- en: Once you've installed Composer by following the preceding steps, you can run
    it simply by running the `composer` command.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您按照上述步骤安装了Composer，您可以通过运行`composer`命令来运行它。
- en: 'In order to install Composer on Windows it is easiest to just run the installer
    on the Composer website; currently you can find it at:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Windows上安装Composer，最简单的方法是直接在Composer网站上运行安装程序；目前您可以在以下位置找到它：
- en: '[https://getcomposer.org/Composer-Setup.exe](https://getcomposer.org/Composer-Setup.exe).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://getcomposer.org/Composer-Setup.exe](https://getcomposer.org/Composer-Setup.exe)。'
- en: 'Composer is fairly easy to update, just run this command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Composer相当容易更新，只需运行此命令：
- en: '`**Composer self-update**`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`**Composer self-update**`'
- en: Composer works by using the configuration in a file called `composer.json`,
    where you can outline external dependencies and your autoloading style. Once Composer
    has installed dependencies listed in this file, it writes a `composer.lock` file
    that details the exact versions it has installed. When using version control it
    is important that you commit this file (alongside the `composer.json` file), don't
    add it to your .`gitignore` file if you're on Git. This is very important because
    the lock file details the exact version of a package that was installed at a particular
    time in your version control system. You can, however, exclude a directory called
    `vendor`, I'll explain what that does later.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Composer通过使用名为`composer.json`的文件中的配置来工作，在这里您可以概述外部依赖项和自动加载样式。一旦Composer安装了此文件中列出的依赖项，它将编写一个`composer.lock`文件，其中详细说明了它安装的确切版本。在使用版本控制时，重要的是要提交此文件（以及`composer.json`文件），如果您使用Git，则不要将其添加到您的`.gitignore`文件中。这非常重要，因为锁定文件详细说明了在版本控制系统中特定时间安装的软件包的确切版本。但是，您可以排除一个名为`vendor`的目录，稍后我会解释它的作用。
- en: 'Let''s start off by creating a file called `composer.json` in our project directory.
    This file is structured in JSON, so let me just remind you of how JSON works:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在项目目录中创建一个名为`composer.json`的文件。这个文件是以JSON格式结构化的，所以让我提醒您一下JSON的工作原理：
- en: JSON consists of key/value pairs of data, think of it like a set of variables
    being defined in a file
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON由数据的键/值对组成，可以将其视为在文件中定义一组变量。
- en: 'A key value pair is comma separated, for example, `"key" : "value"`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '键值对用逗号分隔，例如，`"key" : "value"`'
- en: Curly brackets hold objects
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花括号包含对象
- en: Square brackets hold arrays
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方括号包含数组
- en: Multiple pieces of data must be comma separated, without leaving a trailing
    comma at the end of the data
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个数据必须用逗号分隔，不要在数据末尾留下逗号
- en: Keys and values that include strings must be wrapped in quotes
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括字符串的键和值必须用引号括起来
- en: A backslash `\` is the escape key
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反斜杠`\`是转义键
- en: 'So now we can add the following markup to the `composer.json` file:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将以下标记添加到`composer.json`文件中：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So let me explain what this file does; it tells Composer to `autoload` everything
    in the `src/` directory into the `IcyApril\ChapterOne` namespace using the PSR-4
    standard.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我解释一下这个文件的作用；它告诉Composer将`src/`目录中的所有内容自动加载到`IcyApril\ChapterOne`命名空间中，使用PSR-4标准。
- en: So, the next step is to create our `src` directory where we include the code
    we want to autoload. Done that? Right, now let's open up our command line and
    move into the directory where we've put our `composer.json` file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，下一步是创建我们的`src`目录，其中包括我们想要自动加载的代码。搞定了吗？好的，现在让我们打开命令行，并进入我们放置`composer.json`文件的目录。
- en: In order to install everything in the `composer.json` file in your project just
    run the `composer install` command. For subsequent updates, the `composer update`
    command will update to the latest versions of all dependencies as defined in `composer.json`.
    If you don't want to do this, though, there is an alternative; running the `composer
    dump-autoload` command will solely regenerate the list of the PSR-0/PSR-4 classes
    that need to be included in the project (for example, you add, delete, or rename
    some of your classes).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在您的项目中安装`composer.json`文件中的所有内容，只需运行`composer install`命令。对于后续更新，`composer
    update`命令将根据`composer.json`中定义的所有依赖项的最新版本进行更新。如果您不想这样做，还有另一种选择；运行`composer dump-autoload`命令将仅重新生成需要包含在项目中的PSR-0/PSR-4类的列表（例如，您添加、删除或重命名了一些类）。
- en: 'Now let me cover how you will actually go about creating a class. So, let''s
    create an `src` directory in our project and in that `src` directory create a
    new class called `Book`. You can do this by creating a file called `Book.php`.
    In that file, add something like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我来介绍一下你实际上将如何创建一个类。所以，在我们的项目中创建一个`src`目录，在该`src`目录中创建一个名为`Book`的新类。您可以通过创建一个名为`Book.php`的文件来实现这一点。在该文件中，添加类似以下内容：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a standard class, except we're just defining a constructor that will
    echo `Hello world!` when the class is instantiated.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准类，只是我们定义了一个构造函数，当实例化类时将会输出`Hello world!`。
- en: 'As you may have noticed, we''ve followed a few naming conventions; firstly,
    the PSR-1 standard declares that class names must be declared in StudlyCaps. PSR-2
    has a few extra requirements; to name a few: four spaces instead of a tab, one
    blank space after a namespace or use declarations, and placing brackets on new
    lines. It''s definitely worth taking the time to read these standards if you haven''t
    already. You might not agree with every standard, you might have a subjective
    preference to how you format your own code; my advice is to put these preferences
    aside for the greater good. Having code that is standardized by means of utilizing
    the PSR standards offers great advantages when collaborating on common code bases.
    The benefit of having an external standard, built by an organization such as the
    PHP-FIG group, is that you have your configuration pre-built into your IDE (for
    example, PHPStorm supports PSR-1/PSR-2 out of the box). Not only this but, when
    it comes to formatting arguments you have a concrete impartial document that outlines
    how things should be done, which is great for stopping religious code formatting
    arguments during code reviews.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们遵循了一些命名约定；首先，PSR-1标准声明类名必须以StudlyCaps形式声明。PSR-2有一些额外的要求；举个例子：四个空格而不是制表符，命名空间或使用声明后面有一个空格，以及将括号放在新行上。如果您还没有阅读这些标准，那么花时间阅读这些标准绝对是值得的。您可能不同意每个标准，您可能对如何格式化自己的代码有主观偏好；我的建议是将这些偏好放在一边，为了更大的利益。通过利用PSR标准标准化的代码在共同的代码库上进行协作时具有巨大的优势。通过PHP-FIG组织等外部标准的好处是，您的IDE中已经预先构建了您的配置（例如，PHPStorm支持PSR-1/PSR-2）。不仅如此，当涉及到格式化参数时，您有一个具体的公正文件，概述了应该如何做事情，这对于在代码审查期间阻止宗教性的代码格式化争论非常有益。
- en: Now that we've created the class we can go ahead and run the `composer dump-autoload`
    command in order to refresh our autoloader script.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经创建了类，我们可以继续运行`composer dump-autoload`命令，以刷新我们的自动加载程序脚本。
- en: So, we've configured our Composer autoloader and we've also got a test class
    to play around with, but the next question is how we can implement this. So, let's
    go ahead and implement this. In the same directory where we've implemented our
    `composer.json` file, let's add our `index.php` file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经配置了Composer自动加载程序，也有了一个测试类可以操作，但下一个问题是我们如何实现这一点。所以，让我们继续实现这一点。在我们实现`composer.json`文件的同一目录中，让我们添加我们的`index.php`文件。
- en: 'The line after you put in your PHP opening tag, we need to pull in our autoloader
    script:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在您放入PHP开标签后的一行，我们需要引入我们的自动加载程序脚本：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then we can instantiate our `Book` class:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以实例化我们的`Book`类：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Set up your web server, point your document root to the folder we created, direct
    your web browser to your chosen web server and you should see Hello world! pop
    up on screen. Now you can take apart the code and play around with it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 设置您的Web服务器，将文档根目录指向我们创建的文件夹，将您选择的Web服务器指向您的Web浏览器，然后您应该在屏幕上看到Hello world！现在您可以拆开代码并进行操作。
- en: The completed code sample is available alongside this book, so you can open
    it up and play around with it directly from there, just in case you need any help
    debugging your code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的代码示例可与本书一起使用，因此您可以直接从那里打开它并进行操作，以防您需要帮助调试您的代码。
- en: Whether your classes are abstract classes or mere interfaces, when autoloading
    we treat them all as classes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您的类是抽象类还是纯接口，在自动加载时我们都将它们视为类。
- en: The Gang of Four (GoF)
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 四人帮（GoF）
- en: The architect Christopher Alexander, who mentioned how patterns can be used
    to address common design issues, originally documented the concept. The idea came
    about from Alexander; he proposes that design issues can be documented rigorously,
    alongside their proposed solution. Design patterns have most notably been applied
    to resolving architectural issues in software design.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑师克里斯托弗·亚历山大提到了模式如何用于解决常见的设计问题，最初记录了这一概念。这个想法来自亚历山大；他提出设计问题可以严格记录，以及它们的解决方案。设计模式最显著地应用于解决软件设计中的架构问题。
- en: 'In Christopher Alexander''s own words:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 用克里斯托弗·亚历山大的话说：
- en: '*"The elements of this language are entities called patterns. Each pattern
    describes a problem that occurs over and over again in our environment, and then
    describes the core of the solution to that problem, in such a way that you can
    use this solution a million times over, without ever doing it the same way twice."*'
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “这种语言的元素是被称为模式的实体。每个模式描述了我们环境中反复出现的问题，然后以这样一种方式描述了解决这个问题的核心，以便您可以使用这个解决方案一百万次，而不必重复一样的方式。”
- en: Alexander wrote his own book, predating the Gang of Four called, *A Pattern
    Language*. In this book, Alexander created his own language, he coined the phrase
    *pattern language* to describe this; this language was formed from the building
    blocks of Architectural patterns. By utilizing these Architectural patterns the
    book proposes that ordinary people can use this language as a framework to improve
    their neighborhoods and towns.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 亚历山大写了一本自己的书，早于四人帮的书，名为《模式语言》。在这本书中，亚历山大创造了自己的语言，他创造了“模式语言”这个词来描述这一点；这种语言是由建筑模式的基本构建模块形成的。通过利用这些建筑模式，该书提出普通人可以将这种语言用作改善他们的社区和城镇的框架。
- en: 'One such pattern that is documented in the book is *Pattern 12*, known as the
    Community of 7000; the book documents this pattern by stating the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 书中记录的一种这样的模式是“模式12”，被称为7000人的社区；书中通过以下方式记录了这种模式：
- en: '*"Individuals have no effective voice in any community of more than 5,000-10,000
    persons."*'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “个人在超过5,000-10,000人的任何社区中都没有有效的发言权。”
- en: By using problems such as this one with their documented solution; the book
    ultimately forms patterns, these patterns seek to act as the building blocks for
    making communities better.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这样的问题及其记录的解决方案，该书最终形成了模式，这些模式旨在成为改善社区的基本构建模块。
- en: As I mentioned, Alexander predated the Gang of Four; but his work was essential
    for sowing the seeds for software design patterns.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所提到的，亚历山大先于四人帮；但他的工作对于播种软件设计模式的种子至关重要。
- en: Now, let's turn directly on to the authors known as *The Gang of Four*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们直接转向被称为“四人帮”的作者。
- en: 'Nope, we''re not referring to the 1981 defectors from the British Labour party
    or an English post-punk band; but we are talking about the authors of a book called
    *Design Patterns: Elements of Reusable Object-Oriented Software*. This book has
    been highly influential in the realm of software development and is well known
    in the software engineering field.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们不是指1981年英国工党的叛逃者，也不是指一支英国后朋克乐队；但我们谈论的是一本名为《设计模式：可复用面向对象软件的元素》的书的作者。这本书在软件开发领域具有很高的影响力，在软件工程领域广为人知。
- en: In the first chapter of the book, the authors discuss object-oriented software
    development from their own personal experience; this includes arguing how software
    developers should program for an interface and not an implementation. This leads
    to code ultimately utilizing central functions of object-oriented programming.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在书的第一章中，作者们从自己的个人经验讨论了面向对象的软件开发；这包括争论软件开发人员应该为接口而不是实现编程。这最终导致代码最终利用了面向对象编程的核心功能。
- en: It is a common misconception that the book contains only four design patterns,
    this isn't true; it covers 23 design patterns from three fundamental categories.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 人们普遍误解这本书只包含四种设计模式，这是不正确的；它涵盖了来自三个基本类别的23种设计模式。
- en: 'Let''s cover what these categories are:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些类别是什么：
- en: Creational
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建型
- en: Structural
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构型
- en: Behavioral
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为
- en: So let's break each one of these down.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们逐一解释这些。
- en: Creational design patterns
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建型设计模式
- en: Creational design patterns concern the creation of objects themselves. Basic
    instantiation of classes without using a design pattern can result in needless
    complexity, but also in significant design problems.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型设计模式涉及对象本身的创建。在不使用设计模式的情况下基本实例化类可能会导致不必要的复杂性，也可能会导致重大的设计问题。
- en: The main usage of Creational design patterns is to separate the instantiation
    of a class from the usage of that instance. Failure to use Creational design patterns
    can mean your code is harder to understand and test.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型设计模式的主要用途是将类的实例化与该实例的使用分开。不使用创建型设计模式可能意味着您的代码更难理解和测试。
- en: Dependency injection
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖注入
- en: '**Dependency injection** is the process whereby you can actually input dependencies
    that your application needs directly into the object itself.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种过程，通过这种过程，您可以直接将应用程序需要的依赖项输入到对象本身中。
- en: 'John Munsch left an answer on Stack Overflow called *Dependency injection for
    five year olds*, this answer was republished in the book *Mark Seeman''s Dependency
    Injection in .NET*:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: John Munsch在Stack Overflow上留下了一个名为“五岁孩子的依赖注入”的答案，这个答案被重新发表在书籍《Mark Seeman's
    Dependency Injection in .NET》中：
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When you go and get things out of the refrigerator for yourself, you can cause
    problems. You might leave the door open, you might get something Mommy or Daddy
    doesn't want you to have. You might even be looking for something we don't even
    have or which has expired.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当你自己去冰箱里拿东西时，可能会引起问题。你可能会把门打开，你可能会拿到爸爸妈妈不想让你拿的东西。你甚至可能在找我们根本没有或者已经过期的东西。
- en: Tip
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: What you should be doing is stating a need, "I need something to drink with
    lunch," and then we will make sure you have something when you sit down to eat.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该说出你的需求，“我需要午餐时喝点什么”，然后我们会确保你坐下来吃饭时有东西喝。
- en: When writing a class, it's natural to use other dependencies; perhaps a database
    model class. So with dependency injection, instead of a class having its database
    model created in itself, you can create it outside that object and inject it in.
    In short, we separate our client's behavior from our client's dependencies.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写类时，自然会使用其他依赖项；也许是数据库模型类。因此，通过依赖注入，类不是在自身中创建其数据库模型，而是在对象外部创建它并注入它。简而言之，我们将客户端的行为与客户端的依赖项分开。
- en: 'When thinking of dependency injection, let''s outline the four separate roles
    involved:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑依赖注入时，让我们概述涉及的四个独立角色：
- en: The service to be injected
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要注入的服务
- en: The client that depends on the service being injected
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于被注入服务的客户端
- en: The interface that determines how the client can use the service
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定客户端如何使用服务的接口
- en: The injector that is responsible for instantiating the service and injecting
    it into the client
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责实例化服务并将其注入客户端的注入器
- en: Structural design patterns
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构设计模式
- en: Structural design patterns are fairly easy to explain, they act as interconnectors
    between entities. It serves as a blueprint for how basic classes can be combined
    to form bigger entities, all Structural design patterns involve the interconnections
    between objects.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 结构设计模式相当容易解释，它们充当实体之间的连接器。它作为基本类如何组合形成更大实体的蓝图，所有结构设计模式都涉及对象之间的互连。
- en: Behavioral design patterns
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为设计模式
- en: Behavioral design patterns work to explain how objects interact with each other;
    how they can send messages between each of the objects and how you can divide
    the steps of various tasks up among classes.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 行为设计模式用于解释对象之间的交互方式；它们如何在对象之间发送消息，以及如何将各种任务的步骤分配给不同的类。
- en: Structural patterns describe the static architecture of a design; Behavioral
    patterns are more fluid and describe a flowing process.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 结构模式描述设计的静态架构；行为模式更加灵活，描述了一个流动的过程。
- en: Architectural patterns
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构模式
- en: This is not strictly a *design pattern* (but the Gang of Four didn't cover Architectural
    patterns in their book); but it is incredibly relevant for PHP developers due
    to the web-oriented nature of PHP. Architectural patterns address various different
    constraints in computer systems through addressing performance limitations, high
    availability, and also minimization of business risk.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是严格意义上的*设计模式*（但四人帮在他们的书中没有涵盖架构模式）；但由于PHP的面向Web的特性，它对PHP开发人员非常相关。架构模式通过解决计算机系统中的各种不同约束来解决性能限制、高可用性以及业务风险的最小化。
- en: Most developers will be familiar with the Model-View-Controller architecture
    when it comes to web frameworks, more recently other architectures have started
    to emerge; for example, a microservices architecture works by a set of RESTful
    APIs that are independent and interconnected. Some people believe microservices
    move problems from the software development layer to the systems architecture
    layer. The opposite of microservices often referred to as a monolithic architecture,
    is where all the code is together in one application.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发人员在涉及Web框架时会熟悉模型-视图-控制器架构，最近其他架构开始出现；例如，微服务架构通过一组独立且相互连接的RESTful API工作。一些人认为微服务将问题从软件开发层转移到系统架构层。与微服务相反，通常被称为单块架构，是所有代码都集中在一个应用程序中。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we revised some PHP principles, including OOP principles. We
    also revised some PHP syntax basics. We have seen how you can use Composer for
    dependency management in PHP. In addition to this, we also discussed PSR standards
    and how you can implement them in your own code to make your code more readable
    by others, and also comply with some other important standards (be they autoloading
    or HTTP messaging). Finally, we introduced design patterns and the Gang of Four
    with the history behind design patterns.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们复习了一些PHP原则，包括面向对象编程原则。我们还复习了一些PHP语法基础。我们已经看到您可以如何在PHP中使用Composer进行依赖管理。除此之外，我们还讨论了PSR标准以及如何在自己的代码中实现它们，以使您的代码更易于他人阅读，并且符合其他重要标准（无论是自动加载还是HTTP消息传递）。最后，我们介绍了设计模式和四人帮以及设计模式背后的历史。
