- en: Chapter 3. Creational Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。创建性设计模式
- en: Creational design patterns are one of the three types of design pattern commonly
    associated with the Gang of Four; they are design patterns that concern object
    creation mechanisms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 创建性设计模式是与四人帮经常相关的三种设计模式之一；它们是涉及对象创建机制的设计模式。
- en: Instantiating objects or basic class creation on their own, without controlling
    this process, can result in design problems or simply add additional complexity
    to the process.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有控制这个过程的情况下实例化对象或基本类的创建，可能会导致设计问题，或者只是给过程增加额外的复杂性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: The software design process
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件设计过程
- en: Simple Factory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单工厂
- en: Factory Method
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法
- en: Abstract Factory pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: Lazy initialization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟初始化
- en: Builder pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建造者模式
- en: Prototype pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型模式
- en: Before we learn about Creational design patterns, let's talk a little about
    the architectural process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习创建性设计模式之前，让我们稍微谈谈架构过程。
- en: Software design process
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件设计过程
- en: '*Software Engineering Body of Knowledge* is a book published by the *IEEE*
    often known as the **SWEBoK**, and it summarizes the generally accepted body of
    knowledge for the entire field of software engineering.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件工程知识体系*是由*IEEE*出版的一本书，通常被称为**SWEBoK**，它总结了整个软件工程领域的通常被接受的知识体系。'
- en: 'In this book, it is stated that the definition of software design is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，软件设计的定义如下：
- en: '*"The process of defining the architecture, components, interfaces, and other
    characteristics of a system or component" and "the result of [that] process".*'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “定义系统或组件的架构、组件、接口和其他特征的过程”和“[该]过程的结果”。
- en: 'Specifically, software design can be split into two levels of hierarchy:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，软件设计可以分为两个层次的层次结构：
- en: Architectural design, describing how software is split into its composite components
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构设计，描述软件如何分割成其组成部分
- en: Detailed design, describing the specifics of each component in sufficient detail
    as to describe its component.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细设计，描述每个组件的具体细节，以描述其组件。
- en: A component is a part of a software solution, with interfaces reaching off the
    component as both *required interfaces* (things the software requires to function)
    and *provided interfaces* (things the software provides to other components).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是软件解决方案的一部分，具有接口，这些接口作为*所需接口*（软件需要的功能）和*提供的接口*（软件提供给其他组件的功能）。
- en: These two design processes (Architectural design and Detailed design) should
    result in a set of models and artifacts that record major decisions, with an explanation
    of why non-trivial decisions have been made. In the future, developers may then
    readily reference these documents in order to work out the rationale behind architectural
    decisions, making code more maintainable by ensuring decisions are thought through,
    and that thought process is passed down.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个设计过程（架构设计和详细设计）应该产生一组记录主要决策的模型和工件，并解释为什么做出了非平凡决策。将来，开发人员可以很容易地参考这些文档，以了解架构决策背后的原理，通过确保决策经过深思熟虑，并将思考过程传递下去，使代码更易于维护。
- en: The first of these processes, Architectural design, can be fairly creative and
    engaging for an entire group. The outcome of this process, however you choose
    to do it, should be a component diagram that interconnects components together
    by their interfaces.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个过程中的第一个，架构设计，可以对整个团队来说是相当有创意和吸引力的。这个过程的结果，无论你选择如何做，都应该是一个通过接口相互连接组件的组件图。
- en: This process usually can favor groups of general developers instead of tiger
    teams. *Tiger teams* are usually small groups of a specialist in a particular
    domain of product knowledge, who come together in a time-boxed environment to
    address a particular issue under the chairmanship of an architect. Often, especially
    where legacy is involved, such design efforts may require a wide body of knowledge
    to extract the necessary architectural constraints.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程通常可以更倾向于一般开发人员的团队，而不是虎队。 *虎队*通常是在特定产品知识领域的专家小组，他们在一个时间限定的环境中聚集在一起，以解决特定问题，由架构师主持。通常，特别是涉及到遗留系统时，这样的设计工作可能需要广泛的知识来提取必要的架构约束。
- en: 'This said, in order to prevent the process turning into the design by committee
    or mob rule there are some ground rules that you might want to follow: have an
    architect chair the meeting and work from the component level diagram without
    drilling any further. It often helps to mock up a component diagram before the
    meeting and to edit it as needed in the meeting itself, which helps ensure the
    team remains on track to correcting the diagram without drilling into the hows.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个说法，为了防止过程变成委员会设计或群体规则，你可能想要遵循一些基本规则：让架构师主持会议，并从组件级别图开始工作，不要深入到更深层次。在会议之前制作一个组件图通常会有所帮助，并在会议中根据需要进行编辑，这有助于确保团队保持在纠正图表的轨道上，而不深入到具体的操作。
- en: In one environment I have been in, there was a very detailed engineer who was
    head of the engineering team; he insisted on doing architecture by immediately
    drilling into the detail of components, which would rapidly leave the process
    disintegrated and unorganized; he would be starting *meetings in meetings* on
    the fly. Building component diagrams in these architecture meetings proved vital
    in keeping order in the meetings and ensuring both operational matters and Detailed
    design matters were not engaged with too early. Operational matters of how and
    where something is hosted is not usually within the remit of software engineering unless
    it directly has to alter how software is created.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我曾经参与的一个环境中，有一个非常详细的工程师担任工程团队的负责人；他坚持立即深入组件的细节进行架构，这会迅速使流程瓦解和无组织；他会即兴开始*会议中的会议*。在这些架构会议上构建组件图在保持会议秩序和确保操作事项和详细设计事项都不会过早涉及方面起到了至关重要的作用。如何和在哪里托管某些东西的操作事项通常不在软件工程的权限范围内，除非它直接影响软件的创建方式。
- en: The next step is Detailed design; this explains how a component is constructed.
    Design patterns used in construction, class diagrams and the necessary external
    resources can all be decided at this point. Some Detailed design work will be
    done at the construction level, regardless of how good the design is, software
    developers will need to make minor changes to the design to either add more detail
    or to flesh out some oversights in the architecture process. The process that
    is prior to this design must simply specify the component in sufficient detail
    to facilitate its construction and allow developers to not have to consider the
    architecture in too much detail. Developers should be developing code from artifacts
    that are closely related to the code (for example, Detailed designs) as opposed
    to coding from high-level requirements, designs, or plans.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是详细设计；这解释了组件如何构建。在这一点上可以决定使用的构造中的设计模式、类图和必要的外部资源。无论设计有多好，都将在构建级别进行一些详细设计工作，软件开发人员将需要对设计进行微小的更改，以添加更多细节或弥补架构过程中的一些疏忽。在此设计之前的过程必须简单地指定组件的足够细节，以便促进其构建，并允许开发人员不必过多考虑架构细节。开发人员应该从与代码密切相关的构件（例如详细设计）中开发代码，而不是从高级需求、设计或计划中编写代码。
- en: As an aside, let's remember that unit tests can form part of the design (for
    example, when utilizing Test-Driven Development), with each unit test specifying
    a design element (classes, methods, and specific behavior). While it simply isn't
    realistic (though some will claim it is) to reverse engineer the code into the
    design artifacts; it is possible to represent *architecture as code*, if you will;
    unit tests are one such way of achieving this.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，让我们记住，单元测试可以成为设计的一部分（例如，在使用测试驱动开发时），每个单元测试都指定一个设计元素（类、方法和特定行为）。虽然将代码逆向工程到设计构件中并不现实（尽管有人会声称是），但可以将*架构表示为代码*；单元测试就是实现这一目标的一种方式。
- en: As mentioned earlier in this book, design patterns provide a crucial role in
    software design; they allow the design of more complicated bits of software without
    re-inventing the wheel.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书前面提到的，设计模式在软件设计中起着至关重要的作用；它们允许设计更复杂的软件部分，而无需重新发明轮子。
- en: Right; now to Creational design patterns.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在是创建型设计模式。
- en: Simple Factory
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单工厂
- en: What is a factory? Let's imagine you order a new car; the dealer sends your
    order off to the factory and the factory builds your car. Your car is sent to
    you in its assembled form and you don't need to care about how it was made.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是工厂？让我们想象一下，您订购了一辆新车；经销商将您的订单发送到工厂，工厂建造您的汽车。您的汽车以组装好的形式发送给您，您不需要关心它是如何制造的。
- en: Similarly, a software factory produces objects for you. The factory takes your
    request, assembles the object using the constructor and gives them back to you
    to use. One of these types of Factory pattern is known as the **Simple Factory**.
    Let me show you how it works.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，软件工厂为您生产对象。工厂接受您的请求，使用构造函数组装对象并将它们交还给您使用。其中一种工厂模式称为**简单工厂**。让我向您展示它是如何工作的。
- en: 'Firstly, we define an abstract class, which we want to extend with other classes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个抽象类，我们希望用其他类扩展：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This class serves to allow us to have common methods and define whatever common
    functionality we want all the classes we build in our factory to have in common.
    We could also use interfaces instead of abstract classes for the implementation
    without defining any functionality whatsoever.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类用于允许我们拥有共同的方法，并定义我们希望在工厂中构建的所有类中具有的任何共同功能。我们还可以使用接口而不是抽象类来实现，而不定义任何功能。
- en: Using this interface, we can build two notifiers, `SMS` and `Email`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个接口，我们可以构建两个通知器，`SMS`和`Email`。
- en: 'The `SMS` notifier is as follows in the `SMS.php` file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`SMS`通知器在`SMS.php`文件中如下：'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Similarly, let''s put out `Email` notifier in the `Email.php` file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们在`Email.php`文件中放出`Email`通知器：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can build our factory as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式构建我们的工厂：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While we would ordinarily use Composer to do autoloading, in order to demonstrate
    how simple this method is, I will manually include the dependencies; so without
    further ado, here''s our demo:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们通常会使用Composer进行自动加载，但为了演示这种方法有多简单，我将手动包含依赖项；因此，不多说了，这是我们的演示：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We should get an output like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到这样的输出：
- en: '![Simple Factory](graphics/image_03_001.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![简单工厂](graphics/image_03_001.jpg)'
- en: Factory Method
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法
- en: The Factory Method differs from the ordinary Simple Factory on the basis that
    instead of us having one factory, we can have many.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法与普通简单工厂的不同之处在于，我们可以拥有多个工厂。
- en: 'So why would you want to do this? Well, in order to understand this, we must
    look to the open/closed principle (OCP). Bertrand Meyer is usually associated
    with having originated the term *open/closed principle* in his book, *Object-oriented
    Software Construction*. Meyer stated the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么要这样做呢？嗯，为了理解这一点，我们必须看看开闭原则（OCP）。Bertrand Meyer通常被认为是在他的书《面向对象的软件构造》中首次提出了“开闭原则”这个术语。Meyer说过以下话：
- en: '*"software entities (classes, modules, functions, etc.) should be open for
    extension, but closed for modification"*'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “软件实体（类、模块、函数等）应该对扩展开放，但对修改关闭”
- en: Where a software entity needs to be extended, this should be possible without
    modifying its source code. Those of you who are familiar with the **SOLID** (**single
    responsibility**, **open-closed**, **Liskov substitution**, **interfacesegregation**
    and **dependency inversion**) principles of object-oriented software may already
    have heard of this principle.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 软件实体需要扩展时，应该可以在不修改其源代码的情况下进行。那些熟悉面向对象软件的**SOLID**（单一职责、开闭原则、里氏替换、接口隔离和依赖倒置）原则的人可能已经听说过这个原则。
- en: The Factory Method allows you to group certain classes together and deal with
    them by means of an individual factory for a group of classes. If you want to
    add another group, you can just add another factory.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法允许您将某些类组合在一起，并通过一个单独的工厂来处理它们。如果要添加另一组，只需添加另一个工厂即可。
- en: So now, how do we do this? Well, essentially we are going to create an interface
    for each factory (or an abstract method for that matter); we then implement that
    interface into any other factories we want to build.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，现在我们该怎么做呢？嗯，基本上我们要为每个工厂创建一个接口（或者抽象方法）；然后我们将该接口实现到我们想要构建的任何其他工厂中。
- en: So let's clone our Simple Factory demo; what we're going to do is make our `NotifierFactory`
    become an interface. Then we can rebuild factories to have one factory for electronic
    notifications (e-mail or SMS) and we can then implement our interface to create,
    say, a postal courier notifier factory.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们克隆我们的简单工厂演示；我们要做的是让我们的`NotifierFactory`成为一个接口。然后我们可以重建工厂，为电子通知（电子邮件或短信）建立一个工厂，然后我们可以实现我们的接口来创建，比如说，一个邮政快递通知器工厂。
- en: 'So let''s start off by creating the interface in the `NotifierFactory.php`
    file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`NotifierFactory.php`文件中创建接口开始：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now let''s build our `ElectronicNotifierFactory` that implements our `NotifierFactory`
    interface:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建我们的`ElectronicNotifierFactory`，它实现了我们的`NotifierFactory`接口：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now refactor our `index.php` to use the new factory we have made:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以重构我们的`index.php`来使用我们制作的新工厂：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This now gives the same output as before:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这与以前的输出相同：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, the benefit now is that we can now add a new type of notifier without
    ever needing to open the factory at all, so let''s add a new notifier for postal
    communications:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在的好处是，我们现在可以添加新类型的通知器，而无需打开工厂，所以让我们为邮政通信添加一个新的通知器：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we can introduce the `CourierNotifierFactory`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以引入`CourierNotifierFactory`：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we can now amend our `index.php` file to include this new format:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们现在可以修改我们的`index.php`文件以包含这种新格式：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `index.php` file now yields this result:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.php`文件现在产生了这个结果：'
- en: '![Factory Method](graphics/image_03_002.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![工厂方法](graphics/image_03_002.jpg)'
- en: In production, you would generally put your notifiers in a different namespace
    alongside having your Factories in a different namespace.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，通常会将通知器放在不同的命名空间中，并将工厂放在不同的命名空间中。
- en: Abstract Factory pattern
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: First, if you've done any background reading before approaching this book, you
    will have heard the phrase *concrete class*. What does this mean? Well, simply
    put, it is the opposite of an abstract class; it is a class you can instantiate
    to make an object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你在阅读本书之前做了一些背景阅读，你可能已经听说过“具体类”这个词。这是什么意思？简单来说，它是抽象类的相反；它是一个可以实例化为对象的类。
- en: 'An Abstract Factory consists of the following classes: an Abstract Factory,
    Concrete Factory, Abstract Product, Concrete Product, and our client.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂由以下类组成：抽象工厂、具体工厂、抽象产品、具体产品和我们的客户端。
- en: In the Factory pattern, we produced implementations of a particular interface
    (for example, `notifier` was our interface and e-mail, SMS and post were our implementations).
    With an Abstract Factory pattern, we will create implementations of a factory
    interface, with every factory knowing how to create their products.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在工厂模式中，我们生成了特定接口的实现（例如，`notifier`是我们的接口，电子邮件、短信和邮件是我们的实现）。使用抽象工厂模式，我们将创建工厂接口的实现，每个工厂都知道如何创建它们的产品。
- en: Suppose we have two toy factories, one in San Francisco and one in London. They
    both know how to create both company's products for both locations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个玩具工厂，一个在旧金山，一个在伦敦。它们都知道如何为两个地点创建两家公司的产品。
- en: 'With this in mind, our `ToyFactory` interface looks like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们的`ToyFactory`接口看起来是这样的：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that this is done, we can build our San Francisco toy factory (`SFToyFactory`)
    to serve as our Concrete Factory:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这样做了，我们可以建立我们的旧金山玩具工厂（`SFToyFactory`）作为我们的具体工厂：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can add our British toy factory (`UKToyFactory`):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加我们的英国玩具工厂（`UKToyFactory`）：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you notice, we are creating various toys within the Toys namespace, so now
    we can put together our abstract methods for our toys. Let''s start with our `Toy`
    class. Every toy will eventually extend this class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你注意到的，我们正在在Toys命名空间中创建各种玩具，所以现在我们可以为我们的玩具组合起来的抽象方法。让我们从我们的`Toy`类开始。每个玩具最终都会扩展这个类：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, for the two types of toy we declared in our `ToyFactory` interface at
    the start (maze and puzzle), we can declare their abstract methods, starting with
    our `Maze` class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于我们在开始时在`ToyFactory`接口中声明的两种类型的玩具（迷宫和拼图），我们可以声明它们的抽象方法，从我们的`Maze`类开始：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now let''s do our `Puzzle` class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来做我们的`Puzzle`类：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now it's time for our concrete classes, so let's start with our implementations
    for San Francisco.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为我们的具体类做准备了，让我们从我们的旧金山实现开始。
- en: 'The code for `SFMazeToy` is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`SFMazeToy`的代码如下：'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And here''s the code for the `SFPuzzleToy` class, a different implementation
    to the `Maze` toy'' class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`SFPuzzleToy`类的代码，这是对`Maze`玩具类的不同实现：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can now finish this off with our implementations for the British factory.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用我们的英国工厂实现来完成这一切。
- en: 'Let''s start off by making one for the maze toy, `UKMazeToy.php`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为迷宫玩具制作一个，`UKMazeToy.php`：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And let''s make a class for the puzzle toy too, `UKPuzzleToy.php`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也为拼图玩具制作一个类，`UKPuzzleToy.php`：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now; let''s put this all together in our `index.php` file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把所有这些放在我们的`index.php`文件中：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output, if you run the given code, should look like the output shown in
    the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行给定的代码，输出应该看起来像以下截图中显示的输出：
- en: '![Abstract Factory pattern](graphics/image_03_003.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![抽象工厂模式](graphics/image_03_003.jpg)'
- en: Now, suppose we want to add a new factory with a new set of products (for, say,
    New York), we simply add the toys `NYMazeToy` and the `NYPuzzleToy`, we could
    then create a new Factory called `NYToyFactory` (implementing the `ToyFactory`
    interface) and we would be done.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要添加一个新的工厂，带有一组新的产品（比如纽约），我们只需添加玩具`NYMazeToy`和`NYPuzzleToy`，然后我们可以创建一个名为`NYToyFactory`的新工厂（实现`ToyFactory`接口），然后就完成了。
- en: Now, the downsides of this class emerge when you need to add new product classes;
    the Abstract Factory needs updating, which violates the interface segregation
    principle. So it doesn't strictly meet the SOLID principles if you are going to
    need to add new product classes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您需要添加新的产品类时，这个类的缺点就会显现出来；抽象工厂需要更新，这违反了接口隔离原则。因此，如果您需要添加新的产品类，它就不严格符合SOLID原则。
- en: This design pattern can take some time to fully appreciate, so be sure to fiddle
    around with the source code and see what you can do with it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式可能需要一些时间才能完全理解，所以一定要尝试一下源代码，看看你能做些什么。
- en: Lazy initialization
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟初始化
- en: Slappy Joe's burgers is a high quality restaurant where burgers are priced after
    they are made using the exact weight of the meat that was used. Unfortunately,
    due to the level of creation time, it would be a massive drain on resources for
    them to make every single type of burger before they are ordered.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Slappy Joe's汉堡是一家高品质的餐厅，汉堡的价格是在制作后使用的肉的准确重量来计算的。不幸的是，由于制作时间的长短，让他们在订单之前制作每一种汉堡将会对资源造成巨大的消耗。
- en: Instead of having every type of burger ready for someone to order, when someone
    orders the burger, it is made (if it isn't already) and they are charged the price
    for it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与其为每种类型的汉堡准备好让别人点餐，当有人点餐时，汉堡会被制作（如果还没有），然后他们会被收取相应的价格。
- en: 'The `Burger.php` class is structured like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Burger.php`类的结构如下：'
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the price of the burger is only calculated after it is instantiated,
    meaning the customer can't be charged until it is made. The other function in
    the class simply returns the price of the burger.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，汉堡的价格只有在实例化后才计算，这意味着顾客在制作之前无法收费。类中的另一个函数只是返回汉堡的价格。
- en: Instead of instantiating from the `Burger` class directly, a lazy initialization
    class called `BurgerLazyLoader.php` is made, this class stores a list of instances
    of each burger that has been made; if a burger is requested that isn't made, it
    will make it. Alternatively, if a burger of a particular configuration already
    exists, that burger is returned.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接从`Burger`类实例化不同，创建了一个懒初始化类`BurgerLazyLoader.php`，这个类存储了每个已制作的汉堡的实例列表；如果请求了一个尚未制作的汉堡，它将制作它。或者，如果已经存在特定配置的汉堡，那么返回该汉堡。
- en: 'Here is the `LazyLoader` class which instantiates `Burger` objects as needed:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`LazyLoader`类，它根据需要实例化`Burger`对象：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The only other function added is the `getBurgerCount` function that returns
    a count of all the instances in the instances the `LazyLoader` has.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一添加的其他函数是`getBurgerCount`函数，它返回`LazyLoader`中所有实例的计数。
- en: 'So let''s wrap all of this together in our `index.php` file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们把所有这些放在我们的`index.php`文件中：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We then get an output like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们得到了这样的输出：
- en: '![Lazy initialization](graphics/image_03_004.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![延迟初始化](graphics/image_03_004.jpg)'
- en: Given how the prices are random, you will notice the figures will be different,
    but the prices for the burger with cheese and fries remains the same the first
    and last time you call it. The instance is only created once; moreover, it is
    only created when it is needed, instead of being instantiated whenever it is wanted.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于价格是随机的，您会注意到数字会有所不同，但带奶酪和薯条的汉堡的价格在第一次和最后一次调用时保持不变。实例只创建一次；而且，它只在需要时才创建，而不是在想要时实例化。
- en: Hypothetical burger shop aside, this Creational pattern can have some great
    uses when you need it, such as when you need to delay the construction of an object
    from a class. This is often used when the constructor is an expensive or time-consuming
    operation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设汉堡店一边，当您需要时，这种创造性模式可以发挥一些很好的作用，比如当您需要延迟从一个类构造对象时。当构造函数是一个昂贵或耗时的操作时，通常会使用这种方法。
- en: If an object isn't already able to be used, one is created in a just-in-time
    fashion.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象还不能被使用，就会以及时的方式创建一个。
- en: Builder pattern
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建造者模式
- en: When we reviewed the Factory design patterns, we saw how they were useful for
    enabling polymorphism. The crucial differentiation between Factory patterns and
    the Builder pattern is that the Builder pattern solely has the aim of resolving
    one anti-pattern and does not seek to perform polymorphism. The anti-pattern in
    question is the Telescoping Constructor.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们审查工厂设计模式时，我们看到它们对实现多态性是有用的。工厂模式和建造者模式之间的关键区别在于，建造者模式仅仅旨在解决一个反模式，并不寻求执行多态性。所涉及的反模式是望远镜构造函数。
- en: The Telescoping Constructor problem is essentially where the count of arguments
    a constructor contains grows to an extent where it becomes impractical to use
    or even impractical to know which order the arguments go in.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 望远镜构造函数问题实质上是指构造函数包含的参数数量增长到一定程度，使用起来变得不切实际，甚至不切实际地知道参数的顺序。
- en: 'Let''s suppose we have a `Pizza` class as follows, it essentially contains
    a constructor and a `show` function which details the size and toppings of the
    pizza. The class looks like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`Pizza`类如下，它基本上包含一个构造函数和一个`show`函数，详细说明了披萨的大小和配料。类看起来像这样：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Notice how many parameters the constructor contains, it literally contains
    the size and then every single topping. We can do better than this. In fact, let''s
    aim to construct the pizza by adding all our parameters to a builder object that
    we can then use to create the pizza. This is what we''re aiming for:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意构造函数包含多少参数，它实际上包含大小和每个配料。我们可以做得更好。事实上，让我们的目标是通过将所有参数添加到一个建造者对象中来构建披萨，然后我们可以使用它来创建披萨。这就是我们的目标：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This isn''t too hard to do; in fact you might even find it to be one of the
    easier design patterns we learn here. Let''s first start by making a builder for
    our pizza, let''s name this class `PizzaBuilder`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不难做；实际上，您甚至可能会发现这是我们在这里学到的更容易的设计模式之一。让我们首先为我们的披萨制作一个建造者，让我们将这个类命名为`PizzaBuilder`：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This class isn't too hard to understand, we have a constructor that sets the
    size, and for each additional topping we want to add we can then just call the
    relevant topping method with the parameter set to true or false accordingly. If
    the topping method isn't called, the topping in question isn't set as a parameter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类并不难理解，我们有一个设置大小的构造函数，对于我们想要添加的每个额外配料，我们可以调用相应的配料方法，并将参数设置为true或false。如果没有调用配料方法，相应的配料就不会被设置为参数。
- en: Finally, we have a build method, which can be called to run any last minute
    logic to organize data before it's sent into the constructor of the `Pizza` class.
    This said, I often don't like to do this, as this can be considered sequential
    coupling if methods need to be in a particular order and this would intrinsically
    defeat one purpose of us making a builder to do tasks like this.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个build方法，可以在将数据发送到`Pizza`类的构造函数之前调用以运行任何最后一刻的逻辑来组织数据。话虽如此，我通常不喜欢这样做，因为如果方法需要按特定顺序执行，这可能被认为是顺序耦合，这本质上会破坏我们制作建造者来执行这样的任务的一个目的。
- en: For this reason, every topping method also returns the object that they are
    creating, allowing the output of any function to directly be injected into whatever
    class we want to use it to construct.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个配料方法也返回它们正在创建的对象，允许任何函数的输出直接注入到我们想要用它来构造的任何类中。
- en: 'Next, let''s adapt our `Pizza` class to utilize this builder:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们调整我们的`Pizza`类以利用这个建造者：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It's quite straightforward for a constructor; we just access the `public` properties
    in the builder as and when they're needed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构造函数来说，这是相当简单的；我们只需在需要时访问建造者中的`public`属性。
- en: Note that we can add additional validation of the data provided from the builder
    in the constructor here, though you can also add validation when you're setting
    the methods in the builder, depending on the type of logic required.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以在构造函数中添加对来自建造者的数据的额外验证，尽管您也可以根据所需的逻辑类型在建造者中设置方法时添加验证。
- en: 'Now we can put all this together in our `index.php` file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以把所有这些放在我们的`index.php`文件中：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output we should get looks something like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到的输出看起来像这样：
- en: '![Builder pattern](graphics/image_03_005.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![建造者模式](graphics/image_03_005.jpg)'
- en: The Builder design pattern is incredibly easy to adopt but can save a lot of
    headaches when constructing objects.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者设计模式非常容易采用，但在构建对象时可以节省很多麻烦。
- en: The disadvantage of this method is the need for a separate Builder for every
    single class; this is the cost for such control over the object construction process.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是每个类都需要一个单独的建造者；这是对对象构建过程如此控制的代价。
- en: Above this, the Builder design pattern allows you to vary the constructor variables
    and also provides for good encapsulation of the code that constructs an object
    itself. Like all design patterns, it's down to you to decide where it's most appropriate
    to use each one in your code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之上，建造者设计模式允许您改变构造函数变量，并且还提供了对构造对象本身的代码进行良好封装。就像所有设计模式一样，由您决定在代码中何处最适合使用每个设计模式。
- en: Traditionally, key-value arrays were often used in substitution of Builder classes.
    Builder classes however, give you far more control over the construction process.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，键值数组经常被用来替代建造者类。然而，建造者类可以更好地控制构建过程。
- en: There's one other thing I should mention; here, we just referenced the methods
    using our `index.php` method; often, the methods we run there are placed in a
    class that can be referred to as the *Director* class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事我应该提一下；在这里，我们只是使用我们的`index.php`方法引用了这些方法；通常，我们在那里运行的方法被放置在一个可以称为*Director*类的类中。
- en: Above this, you can also consider applying an interface to implement in your
    Builder if your Builder is going to have a lot of logic in.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之上，您还可以考虑在您的建造者中应用接口以实现大量逻辑。
- en: Prototype pattern
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型模式
- en: The Prototype design pattern allows us to effectively duplicate objects while
    minimizing the performance impacts of having to re-instantiate an object.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计模式允许我们有效地复制对象，同时最小化重新实例化对象的性能影响。
- en: You may have heard of prototypal languages if you've worked with JavaScript.
    In such languages, you work by cloning prototypal objects to create new objects;
    in turn, there is a reduced cost for creating new objects.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经使用过JavaScript，您可能已经听说过原型语言。在这样的语言中，您通过克隆原型对象来创建新对象；反过来，创建新对象的成本降低了。
- en: We have, so far, extensively discussed the use of the `__construct magic` method,
    but we haven't touched on the `__clone magic` method. The `__clone magic` method
    is what's run before an object is cloned (if possible); the method cannot be called
    directly and takes no parameters.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经广泛讨论了`__construct magic`方法的使用，但我们还没有涉及`__clone magic`方法。`__clone magic`方法是在对象被克隆（如果可能的话）之前运行的；该方法不能直接调用，也不接受任何参数。
- en: You might find it useful to use the `__clone` method when using this design
    pattern; that said, you might not need it depending on your use-case.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这种设计模式时，您可能会发现使用`__clone`方法很有用；也就是说，根据您的用例，您可能不需要它。
- en: It's very important to remember that when we clone an object, the `__construct`
    function is not re-run. The object has already been constructed so PHP sees no
    reason to re-run it, so it's worth avoiding putting meaningful logic here when
    using this design pattern for this very reason.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的一点是要记住，当我们克隆一个对象时，`__construct`函数不会重新运行。对象已经被构造，因此PHP认为没有重新运行的理由，因此在使用这种设计模式时，最好避免在这里放置有意义的逻辑。
- en: 'Let''s start off by defining a basic `Student` class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义一个基本的`Student`类：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now let''s start building our `index.php` file, starting by including our `Student.php`
    class file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始构建我们的`index.php`文件，首先包括我们的`Student.php`类文件：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can then create an instance of this class, set the various variables, and
    then `var_dump` the contents of the object so we can debug the details inside
    the object to see how it''s working:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建这个类的一个实例，设置各种变量，然后`var_dump`对象的内容，以便我们可以调试对象内部的细节，看看它是如何工作的：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output of this script looks like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的输出如下：
- en: '![Prototype pattern](graphics/image_03_006.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![原型模式](graphics/image_03_006.jpg)'
- en: 'So far, so good; we''ve essentially declared a basic class and set various
    properties. For our next challenge, let''s clone this script. We can do this by
    adding the following lines to our `index.php` file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好；我们基本上声明了一个基本类并设置了各种属性。对于我们的下一个挑战，让我们克隆这个脚本。我们可以通过将以下行添加到我们的`index.php`文件来实现这一点：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'What does this look like? Well, take a look:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么样子？好吧，看一下：
- en: '![Prototype pattern](graphics/image_03_007.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![原型模式](graphics/image_03_007.jpg)'
- en: So that seems straightforward enough; we've cloned an object and successfully
    changed the properties of that object. Our initial object, the prototype, has
    now been put into use by cloning it to build a new student.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单；我们已经克隆了一个对象并成功更改了该对象的属性。我们的初始对象，原型，现在已经被克隆以构建一个新的学生。
- en: 'And yes, we can do this again, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以再次这样做，如下所示：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: But we can also do better; by using anonymous functions, otherwise known as
    closures, we can actually add extra methods dynamically to this object.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以做得更好；通过使用匿名函数，也称为闭包，我们实际上可以动态地向这个对象添加额外的方法。
- en: 'Let''s define an anonymous function for our object:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的对象定义一个匿名函数：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, let''s echo out both a `var_dump` of the newly cloned object, but
    let''s also execute the `dance` function we''ve just created:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们同时输出新克隆对象的`var_dump`，但也执行我们刚刚创建的`dance`函数：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You'll notice that in fact, we've had to use an `__invoke` magic method to call
    the anonymous function. This method is called when a script tries to call an object
    as a function; it is vital when calling anonymous functions in classes variables.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，实际上，我们不得不使用`__invoke`魔术方法来调用匿名函数。当脚本尝试将对象作为函数调用时，将调用此方法；在类变量中调用匿名函数时，这是至关重要的。
- en: This is due to the fact that PHP class properties and methods are both in separate
    namespaces; in order to execute closures that are in class variables you either
    need to use `__invoke`; first, assign it to a class variable, use `call_user_func`,
    or use the `__call magic` method.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为PHP类属性和方法都在不同的命名空间中；为了执行在类变量中的闭包，您需要使用`__invoke`；首先将其分配给一个类变量，使用`call_user_func`，或者使用`__call`魔术方法。
- en: In this case, we just use the `__invoke` method.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只使用`__invoke`方法。
- en: 'Therefore, the output of the script looks like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，脚本的输出如下：
- en: '![Prototype pattern](graphics/image_03_008.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![原型模式](graphics/image_03_008.jpg)'
- en: Notice that our function ran at the very bottom?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的函数是在最底部运行的？
- en: 'The completed `index.php` file, therefore looks like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，完成的`index.php`文件看起来像这样：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There are a few good use cases for this; suppose you want to perform transactions.
    You can take an object, clone it, and then replace the original if all the queries
    were successful and commit that cloned object to the database in place of the
    original.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一些很好的用例；假设您想执行事务。您可以取一个对象，克隆它，然后在所有查询成功并将克隆的对象提交到数据库中以替换原始对象。
- en: It is a very useful and lightweight way to clone an object where you know that
    cloned object needs the same or nearly the same, contents as its parent object.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常有用且轻量级的方式，可以克隆一个对象，其中您知道克隆的对象需要与其父对象相同或几乎相同的内容。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started learning some critical PHP design patterns related
    to the creation of objects. We learned about various different Factory design
    patterns and how they can make your code more inline with common standards. We
    also covered how the Builder design pattern can help you avoid excessive arguments
    in your constructors. We also learned about lazy instantiation and how it can
    help your code be more efficient. Finally, we learned about how we can duplicate
    objects from prototype objects using the Prototype design pattern.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始学习与对象创建相关的一些关键PHP设计模式。我们了解了各种不同的工厂设计模式以及它们如何使您的代码更符合常见标准。我们还介绍了建造者设计模式如何帮助您避免在构造函数中使用过多参数。我们还学习了延迟实例化以及它如何帮助您的代码更加高效。最后，我们学习了如何使用原型设计模式从原型对象中复制对象。
- en: Continuing on with design patterns, in the next chapter we will talk about Structural
    design patterns.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 继续设计模式，下一章我们将讨论结构设计模式。
