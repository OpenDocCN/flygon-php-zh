- en: Appendix A. Defining PSR-7 Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. 定义PSR-7类
- en: 'In this appendix, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们将涵盖以下主题：
- en: Implementing PSR-7 value object classes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现PSR-7值对象类
- en: Developing a PSR-7 Request class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个PSR-7请求类
- en: Defining a PSR-7 Response class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个PSR-7响应类
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: '**PHP Standard Recommendation number 7** (**PSR-7**) defines a number of interfaces,
    but does not provide actual implementations. Accordingly, we need to define concrete
    code implementations in order to start creating custom middleware.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**PHP标准建议编号7**（**PSR-7**）定义了许多接口，但没有提供实际的实现。因此，我们需要定义具体的代码实现，以开始创建自定义中间件。'
- en: Implementing PSR-7 value object classes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现PSR-7值对象类
- en: In order to work with PSR-7 requests and responses, we first need to define
    a series of value objects. These are classes that represent logical objects used
    in web-based activities such as URIs, file uploads, and streaming request or response
    bodies.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理PSR-7请求和响应，我们首先需要定义一系列值对象。这些是代表在基于Web的活动中使用的逻辑对象的类，如URI、文件上传和流式请求或响应主体。
- en: Getting ready
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The source code for the PSR-7 interfaces is available as a `Composer` package.
    It is considered a best practice to use `Composer` to manage external software,
    including PSR-7 interfaces.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-7接口的源代码可作为`Composer`包使用。使用`Composer`来管理外部软件，包括PSR-7接口，被认为是最佳实践。
- en: How to do it...
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First of all, go to the following URL to obtain the latest versions of the
    PSR-7 interface definitions: [https://github.com/php-fig/http-message](https://github.com/php-fig/http-message).
    The source code is also available. At the time of writing, the following definitions
    are available:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，转到以下URL以获取PSR-7接口定义的最新版本：[https://github.com/php-fig/http-message](https://github.com/php-fig/http-message)。源代码也可用。在撰写本文时，以下定义可用：
- en: '| Interface | Extends | Notes | What the methods handle |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 接口 | 扩展 | 注释 | 方法处理的内容 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `MessageInterface` |   | Defines methods common to HTTP messages | Headers,
    message body (that is, content), and protocol |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `MessageInterface` |   | 定义HTTP消息的公共方法 | 标头、消息主体（即内容）和协议 |'
- en: '| `RequestInterface` | `MessageInterface` | Represents requests generated by
    a client | The URI, HTTP method, and the request target |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `RequestInterface` | `MessageInterface` | 代表客户端生成的请求 | URI、HTTP方法和请求目标 |'
- en: '| `ServerRequestInterface` | `RequestInterface` | Represents a request coming
    to a server from a client | Server and query parameters, cookies, uploaded files,
    and the parsed body |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `ServerRequestInterface` | `RequestInterface` | 代表来自客户端的服务器请求 | 服务器和查询参数、cookie、上传的文件和解析的主体
    |'
- en: '| `ResponseInterface` | `MessageInterface` | Represents a response from the
    server to client | HTTP status code and reason |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `ResponseInterface` | `MessageInterface` | 代表服务器对客户端的响应 | HTTP状态码和原因 |'
- en: '| `StreamInterface` |   | Represents the data stream | Streaming behavior such
    as seek, tell, read, write, and so on |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `StreamInterface` |   | 代表数据流 | 流式行为，如seek、tell、read、write等 |'
- en: '| `UriInterface` |   | Represents the URI | Scheme (that is, HTTP, HTTPS),
    host, port, username, password (that is, for FTP), query parameters, path, and
    fragment |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `UriInterface` |   | 代表URI | 方案（即HTTP、HTTPS）、主机、端口、用户名、密码（即FTP）、查询参数、路径和片段
    |'
- en: '| `UploadedFileInterface` |   | Deals with uploaded files | File size, media
    type, moving the file, and filename |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `UploadedFileInterface` |   | 处理上传的文件 | 文件大小、媒体类型、移动文件和文件名 |'
- en: 'Unfortunately, we will need to create concrete classes that implement these
    interfaces in order to utilize PSR-7\. Fortunately, the interface classes are
    extensively documented internally through a series of comments. We will start
    with a separate class that contains useful constants:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不幸的是，我们需要创建实现这些接口的具体类，以利用PSR-7。幸运的是，接口类在内部通过一系列注释进行了广泛的文档化。我们将从一个包含有用常量的单独类开始：
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that we take advantage of a new feature introduced in PHP 7 that allows
    us to define a constant as an array.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们利用了PHP 7中引入的一个新功能，允许我们将常量定义为数组。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A complete list of HTTP status codes can be found here: [https://tools.ietf.org/html/rfc7231#section-6.1](https://tools.ietf.org/html/rfc7231#section-6.1).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态码的完整列表可以在这里找到：[https://tools.ietf.org/html/rfc7231#section-6.1](https://tools.ietf.org/html/rfc7231#section-6.1)。
- en: 'Next, we will tackle classes that represent value objects used by other PSR-7
    classes. For a start, here is the class that represents a URI. In the constructor,
    we accept a URI string as an argument, and break it down into its component parts
    using the `parse_url()` function:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将处理代表其他PSR-7类使用的值对象的类。首先，这是代表URI的类。在构造函数中，我们接受一个URI字符串作为参数，并使用`parse_url()`函数将其分解为其组件部分：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**URI** stands for **Uniform Resource Indicator**. This is what you would see
    at the top of your browser when making a request. For more information on what
    comprises a URI, have a look at [http://tools.ietf.org/html/rfc3986](http://tools.ietf.org/html/rfc3986).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**URI**代表**统一资源标识符**。这是在发出请求时在浏览器顶部看到的内容。有关URI的构成，请参阅[http://tools.ietf.org/html/rfc3986](http://tools.ietf.org/html/rfc3986)。'
- en: 'Following the constructor, we define methods to access the component parts
    of the URI. The **scheme** represents a PHP wrapper (that is, HTTP, FTP, and so
    on):'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数之后，我们定义了访问URI组件部分的方法。**方案**代表PHP包装器（即HTTP、FTP等）：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The **authority** represents the username (if present), the host, and optionally
    the port number:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**权限**代表用户名（如果存在）、主机和可选的端口号：'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**User info** represents the username (if present) and optionally the password.
    An example of when a password is used is when accessing an FTP website such as
    `ftp://username:password@website.com:/path`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用户信息**代表用户名（如果存在）和可选的密码。使用密码的一个例子是访问FTP网站，如`ftp://username:password@website.com:/path`：'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Host** is the DNS address included in the URI:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**主机**是URI中包含的DNS地址：'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Port** is the HTTP port, if present. You will note if a port is listed in
    our `STANDARD_PORTS` constant, the return value is `NULL`, according to the requirements
    of PSR-7:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Port**是HTTP端口，如果存在的话。您会注意到，如果端口在我们的`STANDARD_PORTS`常量中列出，返回值是`NULL`，根据PSR-7的要求：'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Path** is the part of the URI that follows the DNS address. According to
    PSR-7, this must be encoded. We use the `rawurlencode()` PHP function as it is
    compliant with RFC 3986\. We cannot just encode the entire path, however, as the
    path separator (that is, `/`) would also get encoded! Accordingly, we need to
    first break it up using `explode()`, encode the parts, and then reassemble it:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Path**是跟随DNS地址的URI的一部分。根据PSR-7，这必须进行编码。我们使用`rawurlencode()` PHP函数，因为它符合RFC
    3986。然而，我们不能只对整个路径进行编码，因为路径分隔符（即`/`）也会被编码！因此，我们需要首先使用`explode()`将其分解，对部分进行编码，然后重新组装：'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we define a method to retrieve the `query` string (that is, from `$_GET`).
    These too must be URL-encoded. First, we define `getQueryParams()`, which breaks
    the query string into an associative array. You will note the reset option in
    case we wish to refresh the query parameters. We then define `getQuery()`, which
    takes the array and produces a proper URL-encoded string:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个方法来检索`query`字符串（即来自`$_GET`）。这些也必须进行URL编码。首先，我们定义了`getQueryParams()`，它将查询字符串分解为关联数组。您会注意到重置选项，以防我们希望刷新查询参数。然后我们定义了`getQuery()`，它接受数组并生成一个正确的URL编码字符串：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After that, we provide a method to return the `fragment` (that is, a `#` in
    the URI), and any part following it:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们提供了一个方法来返回`fragment`（即URI中的`#`）以及其后的任何部分：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we define a series of `withXXX()` methods, which match the `getXXX()`
    methods described above. These methods are designed to add, replace, or remove
    properties associated with the request class (scheme, authority, user info, and
    so on). In addition, these methods return the current instance that allows us
    to use these methods in a series of successive calls (often referred to as the
    **fluent interface**). We start with `withScheme()`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一系列`withXXX()`方法，与上面描述的`getXXX()`方法相匹配。这些方法旨在添加、替换或删除与请求类相关的属性（scheme、authority、user
    info等）。此外，这些方法返回当前实例，允许我们在一系列连续调用中使用这些方法（通常称为**流畅接口**）。我们从`withScheme()`开始：
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will note that an empty argument, according to PSR-7, signals the removal
    of that property. You will also note that we do not allow a scheme that does not
    match what is defined in our `Constants::STANDARD_PORTS` array.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 根据PSR-7，空参数表示删除该属性。您还会注意到，我们不允许与我们的`Constants::STANDARD_PORTS`数组中定义的不匹配的方案。
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We then apply similar logic to methods that overwrite, add, or replace the
    user info, host, port, path, query, and fragment. Note that the `withQuery()`
    method resets the query parameters array. `withHost()`, `withPort()`, `withPath()`,
    and `withFragment()` use the same logic, but are not shown to conserve space:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们对覆盖、添加或替换用户信息、主机、端口、路径、查询和片段的方法应用类似的逻辑。请注意，`withQuery()`方法会重置查询参数数组。`withHost()`、`withPort()`、`withPath()`和`withFragment()`使用相同的逻辑，但未显示以节省空间：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we wrap up the `Application\MiddleWare\Uri` class with `__toString()`,
    which, when the object is used in a string context, returns a proper URI, assembled
    from `$uriParts`. We also define a convenience method, `getUriString()`, that
    simply calls `__toString()`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们用`__toString()`包装`Application\MiddleWare\Uri`类，当对象在字符串上下文中使用时，返回一个由`$uriParts`组装而成的正确URI。我们还定义了一个方便的方法`getUriString()`，它只是调用`__toString()`：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the `authority` URI part is present, we add it. `authority` includes the
    user information, host, and port. Otherwise, we just append `host` and `port`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`authority` URI部分存在，我们会添加它。`authority`包括用户信息、主机和端口。否则，我们只是附加`host`和`port`：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Before adding `path`, we first check whether the first character is `/`. If
    not, we need to add this separator. We then add `query` and `fragment`, if present:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加`path`之前，我们首先检查第一个字符是否为`/`。如果不是，我们需要添加这个分隔符。然后，如果存在，我们添加`query`和`fragment`：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the use of string dereferencing (that is, `$path[0]`), now part of PHP
    7.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意字符串解引用的使用（即`$path[0]`），这是PHP 7的一部分。
- en: 'Next, we turn our attention to a class that represents the body of the message.
    As it is not known how large the body might be, PSR-7 recommends that the body
    should be treated as a **stream**. A stream is a resource that allows access to
    input and output sources in a linear fashion. In PHP, all file commands operate
    on top of the `Streams` sub-system, so this is a natural fit. PSR-7 formalizes
    this by way of `Psr\Http\Message\StreamInterface` that defines such methods as
    `read()`, `write()`, `seek()`, and so on. We now present `Application\MiddleWare\Stream`
    that we can use to represent the body of incoming or outgoing requests and/or
    responses:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将注意力转向表示消息正文的类。由于不知道正文可能有多大，PSR-7建议将正文视为**流**。流是一种允许以线性方式访问输入和输出源的资源。在PHP中，所有文件命令都是在`Streams`子系统之上运行的，因此这是一个自然的选择。PSR-7通过`Psr\Http\Message\StreamInterface`来规范化这一点，该接口定义了`read()`、`write()`、`seek()`等方法。我们现在介绍`Application\MiddleWare\Stream`，我们可以用它来表示传入或传出请求和/或响应的正文：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the constructor, we open the stream using a simple `fopen()` command. We
    then use `stream_get_meta_data()` to get information on the stream. For other
    details, we create an `SplFileInfo` instance:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们使用简单的`fopen()`命令打开流。然后我们使用`stream_get_meta_data()`获取流的信息。对于其他细节，我们创建一个`SplFileInfo`实例：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The reason why we chose `fopen()` over the more modern `SplFileObject` is that
    the latter does not allow direct access to the inner file resource object, and
    is therefore useless for this application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择`fopen()`而不是更现代的`SplFileObject`的原因是，后者不允许直接访问内部文件资源对象，因此对于这个应用程序是无用的。
- en: 'We include two convenience methods that provide access to the resource, as
    well as access to the `SplFileInfo` instance:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们包括两个方便的方法，提供对资源的访问，以及对`SplFileInfo`实例的访问：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we define low-level core streaming methods:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了低级核心流方法：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also need to define informational methods that tell us about the stream:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要定义告诉我们有关流的信息方法：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Following PSR-7 guidelines, we then define `getContents()` and `__toString()`
    in order to dump the contents of the stream:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遵循PSR-7指南，然后定义`getContents()`和`__toString()`以便转储流的内容：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An important variation of the `Stream` class shown previously is `TextStream`
    that is designed for situations where the body is a string (that is, an array
    encoded as JSON) rather than a file. As we need to make absolutely certain that
    the incoming `$input` value is of the string data type, we invoke PHP 7 strict
    types just after the opening tag. We also identify a `$pos` property (that is,
    position) that will emulate a file pointer, but instead point to a position within
    the string:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 先前显示的`Stream`类的一个重要变体是`TextStream`，它专为主体是字符串（即以JSON编码的数组）而不是文件的情况而设计。由于我们需要确保传入的`$input`值绝对是字符串数据类型，因此我们在开标签后立即调用PHP
    7严格类型。我们还标识了一个`$pos`属性（即位置），它将模拟文件指针，但实际上指向字符串中的位置：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Most of the methods are quite simple and self-explanatory. The `$stream` property
    is the input string:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数方法都非常简单且不言自明。`$stream`属性是输入字符串：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To emulate streaming behavior, `tell()`, `eof()`, `seek()`, and so on, work
    with `$pos`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了模拟流式行为，`tell()`，`eof()`，`seek()`等方法与`$pos`一起工作：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `read()` and `write()` methods work with `$pos` and substrings:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`read()`和`write()`方法与`$pos`和子字符串一起工作：'
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The last of the value objects to be presented is `Application\MiddleWare\UploadedFile`.
    As with the other classes, we first define properties that represent aspects of
    a file upload:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要介绍的值对象是`Application\MiddleWare\UploadedFile`。与其他类一样，我们首先定义代表文件上传方面的属性：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the constructor, we allow the definition of the name attribute of the file
    upload form field, as well as the corresponding array in `$_FILES`. We add the
    last parameter to signal whether or not we want the class to generate a new random
    filename once the uploaded file is confirmed:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们允许定义文件上传表单字段的名称属性，以及`$_FILES`中的对应数组。我们添加最后一个参数来表示是否希望类在确认上传文件后生成新的随机文件名：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we create a `Stream` class instance for the temporary or moved file:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为临时或移动的文件创建一个`Stream`类实例：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `moveTo()` method performs the actual file movement. Note the extensive
    series of safety checks to help prevent an injection attack. If randomize is not
    enabled, we use the original user-supplied filename:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`moveTo()`方法执行实际的文件移动。请注意，我们进行了广泛的安全检查，以帮助防止注入攻击。如果未启用随机化，则使用原始用户提供的文件名：'
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then provide access to the other parameters returned in `$_FILES` from the
    `$info` property. Please note that the return values from `getClientFilename()`
    and `getClientMediaType()` should be considered untrusted, as they originate from
    the outside. We also add a method to return the moved filename:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过`$info`属性提供对`$_FILES`中返回的其他参数的访问。请注意，`getClientFilename()`和`getClientMediaType()`的返回值应被视为不受信任，因为它们来自外部。我们还添加了一个返回移动后的文件名的方法：
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First of all, go to [https://github.com/php-fig/http-message/tree/master/src](https://github.com/php-fig/http-message/tree/master/src),
    the GitHub repository for the PSR-7 interfaces, and download them. Create a directory
    called `Psr/Http/Message` in `/path/to/source` and places the files there. Alternatively,
    you can visit [https://packagist.org/packages/psr/http-message](https://packagist.org/packages/psr/http-message)
    and install the source code using `Composer`. (For instructions on how to obtain
    and use `Composer`, you can visit [https://getcomposer.org/](https://getcomposer.org/).)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，转到[https://github.com/php-fig/http-message/tree/master/src](https://github.com/php-fig/http-message/tree/master/src)，PSR-7接口的GitHub存储库，并下载它们。在`/path/to/source`中创建一个名为`Psr/Http/Message`的目录，并将文件放在那里。或者，您可以访问[https://packagist.org/packages/psr/http-message](https://packagist.org/packages/psr/http-message)并使用`Composer`安装源代码。（有关如何获取和使用`Composer`的说明，您可以访问[https://getcomposer.org/](https://getcomposer.org/)。）
- en: 'Then, go ahead and define the classes discussed previously, summarized in this
    table:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，继续定义先前讨论的类，总结在这个表中：
- en: '| Class | Steps discussed in |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 讨论中的步骤 |'
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Application\MiddleWare\Constants` | 2 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `Application\MiddleWare\Constants` | 2 |'
- en: '| `Application\MiddleWare\Uri` | 3 to 16 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `Application\MiddleWare\Uri` | 3 to 16 |'
- en: '| `Application\MiddleWare\Stream` | 17 to 22 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `Application\MiddleWare\Stream` | 17 to 22 |'
- en: '| `Application\MiddleWare\TextStream` | 23 to 26 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `Application\MiddleWare\TextStream` | 23 to 26 |'
- en: '| `Application\MiddleWare\UploadedFile` | 27 to 31 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `Application\MiddleWare\UploadedFile` | 27 to 31 |'
- en: 'Next, define a `chap_09_middleware_value_objects_uri.php` calling program that
    implements autoloading and uses the appropriate classes. Please note that if you
    use `Composer`, unless otherwise instructed, it will create a folder called `vendor`.
    `Composer` also adds its own autoloader, which you are free to use here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个调用程序`chap_09_middleware_value_objects_uri.php`，实现自动加载并使用适当的类。请注意，如果您使用`Composer`，除非另有说明，它将创建一个名为`vendor`的文件夹。`Composer`还会添加自己的自动加载程序，您可以在此处自由使用：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can then create a `Uri` instance and use the `with` methods to add parameters.
    You can then echo the `Uri` instance directly as `__toString()` is defined:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以创建一个`Uri`实例，并使用`with`方法添加参数。然后，您可以直接将`Uri`实例作为`__toString()`定义的内容输出：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is the expected result:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是预期结果：
- en: '![How it works...](graphics/B05314_09_01.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_09_01.jpg)'
- en: 'Next, create a directory called `uploads` from `/path/to/source/for/this/chapter`.
    Go ahead and define another calling program, `chap_09_middleware_value_objects_file_upload.php`,
    that sets up autoloading and uses the appropriate classes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从`/path/to/source/for/this/chapter`创建一个名为`uploads`的目录。继续定义另一个调用程序`chap_09_middleware_value_objects_file_upload.php`，设置自动加载并使用适当的类：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Inside a `try...catch` block, check to see whether any files were uploaded.
    If so, loop through `$_FILES` and create `UploadedFile` instances where `tmp_name`
    is set. You can then use the `moveTo()` method to move the files to `TARGET_DIR`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`try...catch`块内，检查是否上传了任何文件。如果是这样，循环遍历`$_FILES`并创建`UploadedFile`实例，其中设置了`tmp_name`。然后可以使用`moveTo()`方法将文件移动到`TARGET_DIR`：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the view logic, display a simple file upload form. You could also use `phpinfo(`)
    to display information about what was uploaded:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图逻辑中，显示一个简单的文件上传表单。您还可以使用`phpinfo（）`来显示有关上传内容的信息：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, if there were any uploaded files, you can display information on each
    one. You can also use `getStream()` followed by `getContents()` to display each
    file (assuming you''re using short text files):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果有任何上传的文件，您可以显示每个文件的信息。您还可以使用`getStream()`，然后使用`getContents()`来显示每个文件（假设您正在使用短文本文件）：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here is how the output might appear:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出可能会出现的方式：
- en: '![How it works...](graphics/B05314_09_02.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_09_02.jpg)'
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information on PSR, please have a look at [https://en.wikipedia.org/wiki/PHP_Standard_Recommendation](https://en.wikipedia.org/wiki/PHP_Standard_Recommendation)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关更多关于PSR的信息，请查看[https://en.wikipedia.org/wiki/PHP_Standard_Recommendation](https://en.wikipedia.org/wiki/PHP_Standard_Recommendation)
- en: 'For information on PSR-7 specifically, here is the official description: [http://www.php-fig.org/psr/psr-7/](http://www.php-fig.org/psr/psr-7/)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关PSR-7的信息，请参阅官方描述：[http://www.php-fig.org/psr/psr-7/](http://www.php-fig.org/psr/psr-7/)
- en: For information on PHP streams, take a look at [http://php.net/manual/en/book.stream.php](http://php.net/manual/en/book.stream.php)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关PHP流的信息，请查看[http://php.net/manual/en/book.stream.php](http://php.net/manual/en/book.stream.php)
- en: Developing a PSR-7 Request class
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发PSR-7请求类
- en: One of the key characteristics of PSR-7 middleware is the use of **Request**
    and **Response** classes. When applied, this enables different blocks of software
    to perform together without sharing any specific knowledge between them. In this
    context, a request class should encompass all aspects of the original user request,
    including such items as browser settings, the original URL requested, parameters
    passed, and so forth.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-7中间件的一个关键特征是使用**Request**和**Response**类。应用时，这使得软件的不同块可以一起执行，而不共享它们之间的任何特定知识。在这种情况下，请求类应该包括原始用户请求的所有方面，包括浏览器设置、原始请求的URL、传递的参数等。
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, be sure to define classes to represent the `Uri`, `Stream`, and `UploadedFile`
    value objects, as described in the previous recipe.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保定义类来表示`Uri`、`Stream`和`UploadedFile`值对象，如前一篇中所述。
- en: 'Now we are ready to define the core `Application\MiddleWare\Message` class.
    This class consumes `Stream` and `Uri` and implements `Psr\Http\Message\MessageInterface`.
    We first define properties for the key value objects, including those representing
    the message body (that is, a `StreamInterface` instance), version, and HTTP headers:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备定义核心的`Application\MiddleWare\Message`类。这个类使用`Stream`和`Uri`，并实现`Psr\Http\Message\MessageInterface`。我们首先为键值对象定义属性，包括表示消息正文（即`StreamInterface`实例）、版本和HTTP标头的属性：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we have the `getBody()` method that represents a `StreamInterface` instance.
    A companion method, `withBody()`, returns the current `Message` instance and allows
    us to overwrite the current value of `body`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有一个代表`StreamInterface`实例的`getBody()`方法。一个伴随方法`withBody()`返回当前的`Message`实例，并允许我们覆盖`body`的当前值：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'PSR-7 recommends that headers should be viewed as case-insensitive. Accordingly,
    we define a `findHeader()` method (not directly defined by `MessageInterface`)
    that locates a header using `stripos()`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PSR-7建议将标头视为不区分大小写。因此，我们定义了一个`findHeader()`方法（不是直接由`MessageInterface`定义的），它使用`stripos()`来定位标头：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The next method, not defined by PSR-7, is designed to populate the `$httpHeaders`
    property. This property is assumed to be an associative array where the key is
    the header, and the value is the string representing the header value. If there
    is more than one value, additional values separated by commas are appended to
    the string. There is an excellent `apache_request_headers()` PHP function from
    the Apache extension that produces headers if they are not already available in
    `$httpHeaders`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个方法，不是由PSR-7定义的，旨在填充`$httpHeaders`属性。假定此属性是一个关联数组，其中键是标头，值是表示标头值的字符串。如果有多个值，则用逗号分隔的附加值附加到字符串中。如果`$httpHeaders`中没有可用的标头，有一个很好的`apache_request_headers()`
    PHP函数来自Apache扩展，可以生成标头：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If `apache_request_headers()` is not available (that is, the Apache extension
    is not enabled), we provide an alternative, `altApacheReqHeaders()`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`apache_request_headers()`不可用（即，Apache扩展未启用），我们提供一个替代方案，`altApacheReqHeaders()`：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Implementing `getHeaders()` (required in PSR-7) is now a trivial loop through
    the `$httpHeaders` property produced by the `getHttpHeaders()` method discussed
    in step 4:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getHeaders()`（在PSR-7中是必需的）现在是通过`getHttpHeaders()`方法产生的`$httpHeaders`属性的一个微不足道的循环：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Again, we provide a series of `with` methods designed to overwrite or replace
    headers. Since there can be many headers, we also have a method that adds to the
    existing set of headers. The `withoutHeader()` method is used to remove a header
    instance. Notice the consistent use of `findHeader()`, mentioned in the previous
    step, to allow for case-insensitive handling of headers:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们提供了一系列`with`方法，用于覆盖或替换标头。由于可能有许多标头，我们还有一个方法，用于添加到现有的标头集。`withoutHeader()`方法用于删除标头实例。请注意，在前一步骤中提到的`findHeader()`的一致使用，以允许对标头进行不区分大小写的处理：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We then provide a series of useful header-related methods to confirm a header
    exists, retrieve a single header line, and retrieve a header in array form, as
    per PSR-7:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们提供了一系列有用的与标头相关的方法，以确认标头是否存在，检索单个标头行，并按照PSR-7的要求以数组形式检索标头：
- en: '[PRE43]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, to round off header handling, we present `getHeadersAsString` that
    produces a single header string with the headers separated by `\r\n` for direct
    use with PHP stream contexts:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了完成头处理，我们提供了`getHeadersAsString`，它生成一个由`\r\n`分隔的头字符串，以便直接在PHP流上下文中使用：
- en: '[PRE44]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Still within the `Message` class, we now turn our attention to version handling.
    According to PSR-7, the return value for the protocol version (that is, HTTP/1.1)
    should only be the numerical part. For this reason, we also provide `onlyVersion()`
    that strips off any non-digit character, allowing periods:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Message`类中，我们现在将注意力转向版本处理。根据PSR-7，协议版本（即HTTP/1.1）的返回值应该只是数字部分。因此，我们还提供了`onlyVersion()`，它会去掉任何非数字字符，包括句点：
- en: '[PRE45]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, almost as an anticlimax, we are ready to define our `Request` class.
    It must be noted here, however, that we need to consider both out-bound as well
    as in-bound requests. That is to say, we need a class to represent an outgoing
    request a client will make to a server, as well as a request *received* from a
    client by a server. Accordingly, we provide `Application\MiddleWare\Request` (requests
    a client will make to a server), and `Application\MiddleWare\ServerRequest` (requests
    received from a client by a server). The good news is that most of our work has
    already been done: notice that our `Request` class extends `Message`. We also
    provide properties to represent the URI and HTTP method:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，几乎可以说是一个反高潮，我们准备定义我们的`Request`类。然而，需要注意的是，我们需要考虑出站请求和入站请求。也就是说，我们需要一个类来表示客户端将向服务器发出的出站请求，以及服务器从客户端*接收*的请求。因此，我们提供`Application\MiddleWare\Request`（客户端将向服务器发出的请求）和`Application\MiddleWare\ServerRequest`（服务器从客户端接收的请求）。好消息是，我们的大部分工作已经完成：注意我们的`Request`类扩展了`Message`。我们还提供了表示URI和HTTP方法的属性：
- en: '[PRE46]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'All properties in the constructor default to `NULL`, but we leave open the
    possibility of defining the appropriate arguments right away. We use the inherited
    `onlyVersion()` method to sanitize the version. We also define `checkMethod()`
    to make sure any method supplied is on our list of supported HTTP methods, defined
    as a constant array in `Constants`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数中的所有属性默认为`NULL`，但我们留下了立即定义适当参数的可能性。我们使用继承的`onlyVersion()`方法来清理版本。我们还定义了`checkMethod()`来确保提供的任何方法都在我们支持的HTTP方法列表中，该列表在`Constants`中定义为常量数组：
- en: '[PRE47]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We are going to interpret the request target as the originally requested URI
    in the form of a string. Bear in mind that our `Uri` class has methods that will
    parse this into its component parts, hence our provision of the `$uriObj` property.
    In the case of `withRequestTarget()`, notice that we run `getUri()` that performs
    the aforementioned parsing process:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将解释请求目标为最初请求的URI的字符串形式。请记住，我们的`Uri`类有方法可以将其解析为其组成部分，因此我们提供了`$uriObj`属性。在`withRequestTarget()`的情况下，注意我们运行了执行前述解析过程的`getUri()`：
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Our `get` and `with` methods, which represent the HTTP method, reveal no surprises.
    We use `checkMethod()`, used in the constructor as well, to ensure the method
    matches those we plan to support:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`get`和`with`方法代表HTTP方法，没有什么意外。我们使用在构造函数中使用的`checkMethod()`来确保方法与我们计划支持的方法匹配：
- en: '[PRE49]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we have a `get` and `with` method for the URI. As mentioned in step
    14, we retain the original request string in the `$uri` property and the newly
    parsed `Uri` instance in `$uriObj`. Note the extra flag to preserve any existing
    `Host` header:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为URI提供了`get`和`with`方法。如第14步中所述，我们保留了`$uri`属性中的原始请求字符串，并在`$uriObj`中保留了新解析的`Uri`实例。注意额外的标志以保留任何现有的`Host`头：
- en: '[PRE50]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `ServerRequest` class extends `Request` and provides additional functionality
    to retrieve information of interest to a server handling an incoming request.
    We start by defining properties that will represent incoming data read from the
    various PHP `$_ super-globals` (that is, `$_SERVER`, `$_POST`, and so on):'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ServerRequest`类扩展了`Request`，并提供了额外的功能来检索对服务器处理传入请求感兴趣的信息。我们首先定义将代表从各种PHP`$_
    super-globals`（即`$_SERVER`，`$_POST`等）读取的传入数据的属性：'
- en: '[PRE51]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We then define a series of getters to pull super-global information. We do
    not show everything, to conserve space:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了一系列getter来提取超全局信息。为了节省空间，我们没有展示所有内容：
- en: '[PRE52]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As uploaded files are supposed to be represented as independent `UploadedFile`
    objects (presented in the previous recipe), we also define a method that takes
    `$uploadedFileInfo` and creates `UploadedFile` objects:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于上传的文件应该表示为独立的`UploadedFile`对象（在上一个示例中介绍），我们还定义了一个方法，该方法接受`$uploadedFileInfo`并创建`UploadedFile`对象：
- en: '[PRE53]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As with the other classes defined previously, we provide `with` methods that
    add or overwrite properties and return the new instance:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与先前定义的其他类一样，我们提供了`with`方法，用于添加或覆盖属性并返回新实例：
- en: '[PRE54]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'One important aspect of PSR-7 messages is that the body should also be available
    in a parsed manner, that is to say, a sort of structured representation rather
    than just a raw stream. Accordingly, we define `getParsedBody()` and its accompanying
    `with` method. The PSR-7 recommendations are quite specific when it comes to form
    posting. Note the series of `if` statements that check the `Content-Type` header
    as well as the method:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PSR-7消息的一个重要方面是，消息体也应以解析的方式可用，也就是说，一种结构化表示，而不仅仅是原始流。因此，我们定义了`getParsedBody()`及其相应的`with`方法。PSR-7的建议在涉及表单提交时非常具体。请注意一系列检查`Content-Type`头以及方法的`if`语句：
- en: '[PRE55]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We also allow for attributes that are not precisely defined in PSR-7\. Rather,
    we leave this open so that the developer can provide whatever is appropriate for
    the application. Notice the use of `withoutAttributes()` that allows you to remove
    attributes at will:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还允许不是在PSR-7中精确定义的属性。相反，我们保持开放，以便开发人员可以提供适用于应用程序的任何内容。注意使用`withoutAttributes()`可以随意删除属性：
- en: '[PRE56]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, in order to load the different properties from an in-bound request,
    we define `initialize()`, which is not in PSR-7, but is extremely convenient:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了从入站请求中加载不同的属性，我们定义了`initialize()`，这不在PSR-7中，但非常方便：
- en: '[PRE57]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'First, be sure to complete the preceding recipe, as the `Message` and `Request`
    classes consume `Uri`, `Stream`, and `UploadedFile` value objects. After that,
    go ahead and define the classes summarized in the following table:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保完成前面的配方，因为`Message`和`Request`类消耗`Uri`、`Stream`和`UploadedFile`值对象。之后，继续定义下表中总结的类：
- en: '| Class | Steps they are discussed in |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 讨论的步骤 |'
- en: '| --- | --- |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Application\MiddleWare\Message` | 2 to 9 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `Application\MiddleWare\Message` | 2到9 |'
- en: '| `Application\MiddleWare\Request` | 10 to 14 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `Application\MiddleWare\Request` | 10到14 |'
- en: '| `Application\MiddleWare\ServerRequest` | 15 to 20 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `Application\MiddleWare\ServerRequest` | 15到20 |'
- en: 'After that, you can define a server program, `chap_09_middleware_server.php`,
    which sets up autoloading and uses the appropriate classes. This script will pull
    the incoming request into a `ServerRequest` instance, initialize it, and then
    use `var_dump()` to show what information was received:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以定义一个服务器程序`chap_09_middleware_server.php`，设置自动加载并使用适当的类。此脚本将把传入的请求拉入`ServerRequest`实例中，初始化它，然后使用`var_dump()`来显示接收到的信息：
- en: '[PRE58]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To run the server program, first change to the `/path/to/source/for/this/chapter
    folder`. You can then run the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行服务器程序，首先切换到`/path/to/source/for/this/chapter`文件夹。然后运行以下命令：
- en: '[PRE59]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As for the client, first create a calling program, `chap_09_middleware_request.php`,
    that sets up autoloading, uses the appropriate classes, and defines the target
    server and a local text file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 至于客户端，首先创建一个调用程序`chap_09_middleware_request.php`，设置自动加载，使用适当的类，并定义目标服务器和本地文本文件：
- en: '[PRE60]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, you can create a `Stream` instance using the text as a source. This will
    become the body of a new Request, which, in this case, mirrors what might be expected
    for a form posting:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以使用文本作为源创建一个`Stream`实例。这将成为一个新请求的主体，在这种情况下，它与表单提交所期望的相同：
- en: '[PRE61]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can then directly build a `Request` instance, supplying parameters as appropriate:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以直接构建一个`Request`实例，根据需要提供参数：
- en: '[PRE62]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Alternatively, you can use the fluent interface syntax to produce exactly the
    same results:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用流畅的接口语法来产生完全相同的结果：
- en: '[PRE63]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can then set up a cURL resource to simulate a form posting, where the data
    parameter is the contents of the text file. You can follow that with `curl_init()`,
    `curl_exec()`, and so on, echoing the results:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以设置一个cURL资源来模拟表单提交，其中数据参数是文本文件的内容。您可以跟着`curl_init()`，`curl_exec()`等，回显结果：
- en: '[PRE64]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here is how the direct output might appear:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是直接输出的样子：
- en: '![How it works...](graphics/B05314_09_03.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_09_03.jpg)'
- en: See also
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'An excellent article that shows example usage written by *Matthew Weir O''Phinney*,
    the editor of PSR-7 (also the lead architect for Zend Framework 1, 2, and 3),
    is available here: [https://mwop.net/blog/2015-01-26-psr-7-by-example.html](https://mwop.net/blog/2015-01-26-psr-7-by-example.html)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Matthew Weir O''Phinney*撰写的一个很好的示例用法文章，他是PSR-7的编辑（也是Zend Framework 1、2和3的首席架构师），可以在这里找到：[https://mwop.net/blog/2015-01-26-psr-7-by-example.html](https://mwop.net/blog/2015-01-26-psr-7-by-example.html)'
- en: Defining a PSR-7 Response class
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义PSR-7响应类
- en: The Response class represents outbound information returned to whatever entity
    made the original request. HTTP headers play an important role in this context
    as we need to know that format is requested by the client, usually in the incoming
    `Accept` header. We then need to set the appropriate `Content-Type` header in
    the Response class to match that format. Otherwise, the actual body of the response
    will be HTML, JSON, or whatever else has been requested (and delivered).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 响应类表示返回给发出原始请求的实体的出站信息。在这种情况下，HTTP标头起着重要作用，因为我们需要知道客户端请求的格式，通常是在传入的`Accept`标头中。然后，我们需要在响应类中设置适当的`Content-Type`标头以匹配该格式。否则，响应的实际主体将是HTML、JSON或其他已请求（并已传递）的内容。
- en: How to do it...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `Response` class is actually much easier to implement than the `Request`
    class as we are only concerned with returning the response from the server to
    the client. Additionally, it extends our `Application\MiddleWare\Message` class
    where most of the work has been done. So, all that remains to be done is to define
    an `Application\MiddleWare\Response` class. As you will note, the only unique
    property is `$statusCode`:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Response`类实际上比`Request`类更容易实现，因为我们只关心从服务器返回响应给客户端。此外，它扩展了我们的`Application\MiddleWare\Message`类，其中大部分工作已经完成。因此，唯一剩下的工作就是定义一个`Application\MiddleWare\Response`类。正如您将注意到的，唯一的独特属性是`$statusCode`：'
- en: '[PRE65]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The constructor is not defined by PSR-7, but we provide it for convenience,
    allowing a developer to create a `Response` instance with all parts intact. We
    use methods from `Message` and constants from the `Constants` class to verify
    the arguments:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数没有由PSR-7定义，但我们为方便起见提供了它，允许开发人员创建一个具有所有部分完整的`Response`实例。我们使用`Message`的方法和`Constants`类的常量来验证参数：
- en: '[PRE66]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We provide a nice way to set the HTTP status code, irrespective of any headers,
    using `http_response_code()`, available from PHP 5.4 onwards. As this work is
    on PHP 7, we are safe in the knowledge that this method exists:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们提供了一种很好的方法来设置HTTP状态码，而不考虑任何标头，使用`http_response_code()`，从PHP 5.4开始可用。由于这项工作是在PHP
    7上进行的，我们可以放心地知道这个方法是存在的：
- en: '[PRE67]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Otherwise, it is of interest to obtain the status code using the following
    method:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，有兴趣使用以下方法获取状态码：
- en: '[PRE68]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As with the other PSR-7-based classes discussed in earlier recipes, we also
    define a `with` method that sets the status code and returns the current instance.
    Note the use of `STATUS_CODES` to confirm its existence:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与早期的配方中讨论的其他基于PSR-7的类一样，我们还定义了一个`with`方法，用于设置状态码并返回当前实例。请注意使用`STATUS_CODES`来确认其存在：
- en: '[PRE69]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, we define a method that returns the reason for the HTTP status, which
    is a short text phrase, in this example, based on RFC 7231\. Note the use of the
    PHP 7 null coalesce operator `??` that returns the first non-null item out of
    three possible choices:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义一个返回HTTP状态原因的方法，这是一个简短的文本短语，在本例中基于RFC 7231。请注意使用PHP 7的空合并运算符`??`，它返回三个可能选择中的第一个非空项：
- en: '[PRE70]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'First of all, be sure to define the classes discussed in the previous two recipes.
    After that, you can create another simple server program, `chap_09_middleware_server_with_response.php`,
    which sets up autoloading and uses the appropriate classes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请确保定义了前两个配方中讨论的类。之后，您可以创建另一个简单的服务器程序`chap_09_middleware_server_with_response.php`，该程序设置自动加载并使用适当的类：
- en: '[PRE71]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You can then define an array with key/value pairs, where the value points to
    a text file in the current directory to be used as content:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以定义一个具有键/值对的数组，其中值指向当前目录中用作内容的文本文件：
- en: '[PRE72]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, inside a `try...catch` block, you can initialize some variables, initialize
    the server request, and set up a temporary filename:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`try...catch`块内，您可以初始化一些变量，初始化服务器请求，并设置临时文件名：
- en: '[PRE73]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'After that, check to see whether the method is GET or POST. If it''s GET, check
    to see whether an `id` parameter was passed. If so, return the body of the matching
    text file. Otherwise, return a list of text files:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，检查方法是GET还是POST。如果是GET，请检查是否传递了`id`参数。如果是，则返回匹配文本文件的正文。否则，返回文本文件列表：
- en: '[PRE74]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Otherwise, return a response indicating a success code 204 and the size of
    the request body received:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，返回一个表示成功代码204和接收到的请求体大小的响应：
- en: '[PRE75]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You can then catch any exceptions and report them with a status code of 500:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以捕获任何异常并报告它们，状态代码为500：
- en: '[PRE76]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The response needs to be wrapped in a stream, so you can write the body out
    to the temp file and create it as `Stream`. You can also set the `Content-Type`
    header to `application/json` and run `getHeaders()`, which outputs the current
    set of headers. After that, echo the body of the response. For this illustration,
    you could also dump the `Response` instance to confirm it was constructed correctly:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 响应需要包装在流中，以便将正文写入临时文件并将其创建为`Stream`。您还可以将`Content-Type`标头设置为`application/json`并运行`getHeaders()`，这将输出当前设置的标头集。之后，回显响应的正文。对于此示例，您还可以转储`Response`实例以确认它是否正确构造：
- en: '[PRE77]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To wrap things up, catch any errors or exceptions using `Throwable`, and don''t
    forget to delete the temp file:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，捕获任何错误或异常使用`Throwable`，并不要忘记删除临时文件：
- en: '[PRE78]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To test, it''s just a matter of opening a terminal window, changing to the
    `/path/to/source/for/this/chapter` directory, and running the following command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行测试，只需打开终端窗口，切换到`/path/to/source/for/this/chapter`目录，并运行以下命令：
- en: '[PRE79]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'From a browser, you can then call this program, adding an `id` parameter. You
    might consider opening the developer tools to monitor the response header. Here
    is an example of the expected output. Note the content type of `application/json`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以从浏览器调用此程序，添加一个`id`参数。您可能考虑打开开发人员工具以监视响应标头。以下是预期输出的示例。请注意`application/json`的内容类型：
- en: '![How it works...](graphics/B05314_09_04.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_09_04.jpg)'
- en: See also
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information on PSR, please visit [http://www.php-fig.org/psr/](http://www.php-fig.org/psr/).
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关PSR的更多信息，请访问[http://www.php-fig.org/psr/](http://www.php-fig.org/psr/)。
- en: The following table summarizes the state of PSR-7 compliance at the time of
    writing. The frameworks not included in this table either do not have PSR-7 support
    at all, or lack documentation for PSR-7.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下表总结了撰写时PSR-7兼容性的状态。未包括在此表中的框架要么根本不支持PSR-7，要么缺乏PSR-7的文档。
- en: '| Framework | Website | Notes |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| Framework | 网站 | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Slim | [http://www.slimframework.com/docs/concepts/value-objects.html](http://www.slimframework.com/docs/concepts/value-objects.html)
    | High PSR-7 compliance |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| Slim | [http://www.slimframework.com/docs/concepts/value-objects.html](http://www.slimframework.com/docs/concepts/value-objects.html)
    | 高PSR-7兼容性 |'
- en: '| Laravel/Lumen | [https://lumen.laravel.com/docs/5.2/requests](https://lumen.laravel.com/docs/5.2/requests)
    | High PSR-7 compliance |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| Laravel/Lumen | [https://lumen.laravel.com/docs/5.2/requests](https://lumen.laravel.com/docs/5.2/requests)
    | 高PSR-7兼容性 |'
- en: '| Zend Framework 3/Expressive | [https://framework.zend.com/blog/2016-06-28-zend-framework-3.html](https://framework.zend.com/blog/2016-06-28-zend-framework-3.html)
    or [https://zendframework.github.io/zend-expressive/](https://zendframework.github.io/zend-expressive/)
    respectively | High PSR-7 complianceAlso Diactoros, and Straigility |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| Zend Framework 3/Expressive | [https://framework.zend.com/blog/2016-06-28-zend-framework-3.html](https://framework.zend.com/blog/2016-06-28-zend-framework-3.html)
    或 [https://zendframework.github.io/zend-expressive/](https://zendframework.github.io/zend-expressive/)
    分别 | 高PSR-7兼容性Also Diactoros, and Straigility |'
- en: '| Zend Framework 2 | [https://github.com/zendframework/zend-psr7bridge](https://github.com/zendframework/zend-psr7bridge)
    | PSR-7 bridge available |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| Zend Framework 2 | [https://github.com/zendframework/zend-psr7bridge](https://github.com/zendframework/zend-psr7bridge)
    | 可用的PSR-7桥 |'
- en: '| Symfony | [http://symfony.com/doc/current/cookbook/psr7.html](http://symfony.com/doc/current/cookbook/psr7.html)
    | PSR-7 bridge available |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| Symfony | [http://symfony.com/doc/current/cookbook/psr7.html](http://symfony.com/doc/current/cookbook/psr7.html)
    | 可用的PSR-7桥 |'
- en: '| Joomla | [https://www.joomla.org](https://www.joomla.org) | Limited PSR-7
    support |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| Joomla | [https://www.joomla.org](https://www.joomla.org) | 有限的PSR-7支持 |'
- en: '| Cake PHP | [http://mark-story.com/posts/view/psr7-bridge-for-cakephp](http://mark-story.com/posts/view/psr7-bridge-for-cakephp)
    | PSR-7 support is in the roadmap and will use the bridge approach |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| Cake PHP | [http://mark-story.com/posts/view/psr7-bridge-for-cakephp](http://mark-story.com/posts/view/psr7-bridge-for-cakephp)
    | PSR-7支持在路线图中，并将使用桥接方法 |'
- en: 'There are a number of PSR-7 middleware classes already available. The following
    table summarizes some of the more popular ones:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经有许多PSR-7中间件类可用。以下表总结了一些较受欢迎的类：
- en: '| Middleware | Website | Notes |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| Middleware | 网站 | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Guzzle | [https://github.com/guzzle/psr7](https://github.com/guzzle/psr7)
    | HTTP message library |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| Guzzle | [https://github.com/guzzle/psr7](https://github.com/guzzle/psr7)
    | HTTP消息库 |'
- en: '| Relay | [http://relayphp.com/](http://relayphp.com/) | Dispatcher |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| Relay | [http://relayphp.com/](http://relayphp.com/) | 调度器 |'
- en: '| Radar | [https://github.com/radarphp/Radar.Project](https://github.com/radarphp/Radar.Project)
    | Action/domain/responder skeleton |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| Radar | [https://github.com/radarphp/Radar.Project](https://github.com/radarphp/Radar.Project)
    | 动作/领域/响应者骨架 |'
- en: '| NegotiationMiddleware | [https://github.com/rszrama/negotiation-middleware](https://github.com/rszrama/negotiation-middleware)
    | Content negotiation |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| NegotiationMiddleware | [https://github.com/rszrama/negotiation-middleware](https://github.com/rszrama/negotiation-middleware)
    | 内容协商 |'
- en: '| psr7-csrf-middleware | [https://packagist.org/packages/schnittstabil/psr7-csrf-middleware](https://packagist.org/packages/schnittstabil/psr7-csrf-middleware)
    | Cross Site Request Forgery prevention |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| psr7-csrf-middleware | [https://packagist.org/packages/schnittstabil/psr7-csrf-middleware](https://packagist.org/packages/schnittstabil/psr7-csrf-middleware)
    | 跨站点请求伪造预防 |'
- en: '| oauth2-server | [http://alexbilbie.com/2016/04/league-oauth2-server-version-5-is-out](http://alexbilbie.com/2016/04/league-oauth2-server-version-5-is-out)
    | OAuth2 server which supports PSR-7 |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| oauth2-server | [http://alexbilbie.com/2016/04/league-oauth2-server-version-5-is-out](http://alexbilbie.com/2016/04/league-oauth2-server-version-5-is-out)
    | 支持PSR-7的OAuth2服务器 |'
- en: '| zend-diactoros | [https://zendframework.github.io/zend-diactoros/](https://zendframework.github.io/zend-diactoros/)
    | PSR-7 HTTP message implementation |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| zend-diactoros | [https://zendframework.github.io/zend-diactoros/](https://zendframework.github.io/zend-diactoros/)
    | PSR-7 HTTP消息实现 |'
