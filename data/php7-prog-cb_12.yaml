- en: Chapter 12. Improving Web Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。改进Web安全
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Filtering `$_POST` data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤`$_POST`数据
- en: Validating `$_POST` data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证`$_POST`数据
- en: Safeguarding the PHP session
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护PHP会话
- en: Securing forms with a token
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用令牌保护表单
- en: Building a secure password generator
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个安全的密码生成器
- en: Safeguarding forms with a CAPTCHA
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CAPTCHA保护表单
- en: Encrypting/decrypting without `mcrypt`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密/解密而不使用`mcrypt`
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'In this chapter, we will show you how to set up a simple yet effective mechanism
    for filtering and validating a block of post data. Then, we will cover how to
    protect your PHP sessions from potential session hijacking and other forms of
    attack. The next recipe shows how to protect forms from **Cross Site Request Forgery**
    (**CSRF**) attacks using a randomly generated token. The recipe on password generation
    shows you how to incorporate PHP 7 true randomization to generate secure passwords.
    We then show you two forms of **CAPTCHA**: one that is text based, the other using
    a distorted image. Finally, there is a recipe that covers strong encryption without
    using the discredited and soon-to-be-deprecated `mcrypt` extension.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示如何建立一个简单而有效的机制，用于过滤和验证一块发布数据。然后，我们将介绍如何保护您的PHP会话免受潜在的会话劫持和其他形式的攻击。下一个配方将展示如何使用随机生成的令牌保护表单免受**跨站点请求伪造**（**CSRF**）攻击。有关密码生成的配方将向您展示如何将PHP
    7真正的随机化结合起来生成安全密码。然后，我们将向您展示两种形式的**CAPTCHA**：一种是基于文本的，另一种是使用扭曲图像的。最后，有一个配方涵盖了强加密，而不使用被废弃和即将被弃用的`mcrypt`扩展。
- en: Filtering $_POST data
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤`$_POST`数据
- en: 'The process of filtering data can encompass any or all of the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤数据的过程可以包括以下任何或所有内容：
- en: Removing unwanted characters (that is, removing `<script>` tags)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除不需要的字符（即删除`<script>`标签）
- en: Performing transformations on the data (that is, converting a quote to `&quot;`)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数据执行转换（即将引号转换为`&quot;`）
- en: Encrypting or decrypting the data
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密或解密数据
- en: Encryption is covered in the last recipe of this chapter. Otherwise, we will
    present a basic mechanism that can be used to filter `$_POST` data arriving following
    form submission.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 加密在本章的最后一个配方中有所涵盖。否则，我们将介绍一个基本机制，可用于过滤表单提交后到达的`$_POST`数据。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First of all, you need to have an awareness of the data that will be present
    in `$_POST`. Also, perhaps more importantly, you will need to be aware of the
    restrictions imposed by the database table in which the form data will presumably
    be stored. As an example, have a look at the database structure for the `prospects`
    table:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要了解将出现在`$_POST`中的数据。而且，也许更重要的是，您需要了解表单数据将被存储的数据库表所施加的限制。例如，看一下`prospects`表的数据库结构：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once you have completed an analysis of the data to be posted and stored, you
    can determine what type of filtering is to occur, and which PHP functions will
    serve this purpose.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成对要发布和存储的数据的分析后，可以确定要发生的过滤类型，以及哪些PHP函数将用于此目的。
- en: As an example, if you need to get rid of leading and trailing white space, which
    is completely possible from user supplied form data, you can use the PHP `trim()`
    function. All of the character data has length limits according to the database
    structure. Accordingly, you might consider using `substr()` to ensure the length
    is not exceeded. If you wanted to remove non-alphabetical characters, you might
    consider using `preg_replace()` with the appropriate pattern.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，如果您需要摆脱用户提供的表单数据中的前导和尾随空格，这是完全可能的，您可以使用PHP的`trim()`函数。根据数据库结构，所有字符数据都有长度限制。因此，您可能需要考虑使用`substr()`来确保长度不超过。如果您想要删除非字母字符，您可能需要考虑使用`preg_replace()`与适当的模式。
- en: 'We can now group the set of desired PHP functions into a single array of callbacks.
    Here is an example based on the filtering needs for the form data that will eventually
    be stored in the `prospects` table:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将所需的PHP函数集合成一个回调函数的单一数组。以下是一个基于表单数据过滤需求的示例，最终将存储在`prospects`表中：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we define an array that matches the field names expected in `$_POST`.
    In this array, we specify the key in the `$filter` array, along with any parameters.
    Note the first key, `*`. We will use that as a wildcard to be applied to all fields:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个与`$_POST`中预期的字段名称匹配的数组。在此数组中，我们指定`$filter`数组中的键，以及任何参数。请注意第一个键`*`。我们将使用它作为应用于所有字段的通配符：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We then loop through the data set (that is, coming from `$_POST`) and apply
    the callbacks in turn. We first run all callbacks assigned to the wildcard (`*`)
    key.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们循环遍历数据集（即来自`$_POST`）并依次应用回调。我们首先运行分配给通配符（`*`）键的所有回调。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to implement a wildcard filter to avoid redundant settings.
    In the preceding example, we wish to apply filters that represent the PHP functions
    `strip_tags()` and `trim()` for every item.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要实现通配符过滤器以避免冗余设置。在前面的示例中，我们希望应用代表PHP函数`strip_tags()`和`trim()`的过滤器到每个项目。
- en: 'Next, we run through all callbacks assigned to a particular data field. When
    we''re done, all values in `$data` will be filtered:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们运行分配给特定数据字段的所有回调。完成后，`$data`中的所有值都将被过滤：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Place the code shown in steps 4 through 6 into a file called `chap_12_post_data_filtering_basic.php`.
    You will also need to define an array to simulate data that would be present in
    `$_POST`. In this case, you could define two arrays, one with *good* data, and
    one with *bad* data:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将步骤4到6中显示的代码放入一个名为`chap_12_post_data_filtering_basic.php`的文件中。您还需要定义一个数组来模拟`$_POST`中可能存在的数据。在这种情况下，您可以定义两个数组，一个包含*好*数据，另一个包含*坏*数据：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, you will need to loop through the filter assignments, presenting the
    good and bad data:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要循环遍历过滤器分配，呈现好的和坏的数据：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here''s how the output might appear for this example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此示例的输出可能如何出现的：
- en: '![How it works...](graphics/B05314_12_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_12_01.jpg)'
- en: Note that the names were truncated and tags were removed. You will also note
    that although the e-mail address was filtered, it is still not a valid address.
    It's important to note that for proper treatment of data, it might be necessary
    to *validate* as well as to filter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，名称已被截断，标签已被删除。 您还会注意到，尽管电子邮件地址已经被过滤，但它仍然不是一个有效的地址。 需要注意的是，为了正确处理数据，可能需要*验证*和过滤。
- en: See also
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In [Chapter 6](ch06.html "Chapter 6. Building Scalable Websites"), *Building
    Scalable Websites*, the recipe entitled *Chaining $_POST filters*, discusses how
    to incorporate the basic filtering concepts covered here into a comprehensive
    filter chaining mechanism.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。构建可扩展的网站")中，*构建可扩展的网站*，名为*链接$_POST过滤器*的示例讨论了如何将此处介绍的基本过滤概念合并到全面的过滤器链接机制中。
- en: Validating $_POST data
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证$_POST数据
- en: The primary difference between filtering and validation is that the latter does
    not alter the original data. Another difference is in intent. The purpose of validation
    is to confirm that the data matches certain criteria established according to
    the needs of your customer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤和验证之间的主要区别在于后者不会更改原始数据。 另一个区别在于意图。 验证的目的是确认数据是否符合根据客户需求建立的某些标准。
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The basic validation mechanism we will present here is identical to that shown
    in the preceding recipe. As with filtering, it is vital to have an idea of the
    nature of the data to be validated, how it fits your customer's requirements,
    and also whether it matches the criteria enforced by the database. For example,
    if in the database, the maximum width of the column is 128, the validation callback
    could use `strlen()` to confirm that the length of the data submitted is less
    than or equal to 128 characters. Likewise, you could use `ctype_alnum()` to confirm
    that the data only contains letters and numbers, as appropriate.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在这里介绍的基本验证机制与前面的示例相同。 与过滤一样，了解要验证的数据的性质，它如何符合客户的要求，以及它是否符合数据库强制执行的标准是至关重要的。
    例如，如果在数据库中，列的最大宽度为128，则验证回调可以使用`strlen()`来确认提交的数据的长度是否小于或等于128个字符。 同样，您可以使用`ctype_alnum()`来确认数据是否只包含适当的字母和数字。
- en: Another consideration for validation is to present an appropriate validation
    failure message. The validation process, in a certain sense, is also a *confirmation*
    process, where somebody presumably will review the validation to confirm success
    or failure. If the validation fails, that person will need to know the reason
    why.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证的另一个考虑因素是提供适当的验证失败消息。 在某种意义上，验证过程也是一个*确认*过程，某人可能会审查验证以确认成功或失败。 如果验证失败，该人将需要知道失败的原因。
- en: 'For this illustration, we will again focus on the `prospects` table. We can
    now group the set of desired PHP functions into a single array of callbacks. Here
    is an example based on the validation needs for the form data, which will eventually
    be stored in the `prospects` table:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于本示例，我们将再次专注于`prospects`表。 现在，我们可以将一组所需的PHP函数集合到一个回调函数的数组中。 以下是基于表单数据的验证需求的示例，这些数据最终将存储在`prospects`表中：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice, for the alpha and alnum callbacks, we allow for whitespace by first
    removing it using `str_replace()`. We can then call `ctype_alpha()` or `ctype_alnum()`,
    which will determine whether any disallowed characters are present.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于alpha和alnum回调，我们通过首先使用`str_replace()`来允许空格。 然后我们可以调用`ctype_alpha()`或`ctype_alnum()`，这将确定是否存在任何不允许的字符。
- en: 'Next, we define an array of assignments that matches the field names expected
    in `$_POST`. In this array, we specify the key in the `$validator` array, along
    with any parameters:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个分配数组，与`$_POST`中预期的字段名称匹配。 在此数组中，我们指定`$validator`数组中的键，以及任何参数：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then use nested `foreach()` loops to iterate through the block of data one
    field at a time. For each field, we loop through the callbacks assigned to that
    field:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用嵌套的`foreach()`循环逐个字段地遍历数据块。 对于每个字段，我们循环遍历分配给该字段的回调函数：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Instead of echoing the output directly, as shown, you might log the validation
    success/failure to be presented to the reviewer at a later time. Also, as shown
    in [Chapter 6](ch06.html "Chapter 6. Building Scalable Websites"), *Building Scalable
    Websites*, you can work the validation mechanism into the form, displaying validation
    messages next to their matching form elements.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是直接回显输出，如所示，您可以记录验证成功/失败的结果，以便在以后向审阅人呈现。 此外，如[第6章](ch06.html "第6章。构建可扩展的网站")中所示，*构建可扩展的网站*，您可以将验证机制集成到表单中，显示验证消息与其匹配的表单元素旁边。
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Place the code shown in steps 3 through 5 into a file called `chap_12_post_data_validation_basic.php`.
    You will also need to define an array of data that simulates data that would be
    present in `$_POST`. In this case, you use the two arrays mentioned in the preceding
    recipe, one with *good* data, and one with *bad* data. The final output should
    look something like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将步骤3到5中显示的代码放入名为`chap_12_post_data_validation_basic.php`的文件中。 您还需要定义一个数据数组，模拟将出现在`$_POST`中的数据。
    在这种情况下，您使用前面示例中提到的两个数组，一个包含*好*数据，另一个包含*坏*数据。 最终输出应该看起来像这样：
- en: '![How it works...](graphics/B05314_12_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_12_02.jpg)'
- en: See also
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In [Chapter 6](ch06.html "Chapter 6. Building Scalable Websites"), *Building
    Scalable Websites*, the recipe entitled *Chaining $_POST validators* discusses
    how to incorporate the basic validation concepts covered here into a comprehensive
    filter chaining mechanism.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。构建可扩展的网站")中，*构建可扩展的网站*，名为*链接$_POST验证器*的示例讨论了如何将此处介绍的基本验证概念合并到全面的过滤器链接机制中。
- en: Safeguarding the PHP session
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护PHP会话
- en: The PHP session mechanism is quite simple. Once the session is started using
    `session_start()` or the `php.ini session.autostart` setting, the PHP engine generates
    a unique token that is, by default, conveyed to the user by way of a cookie. On
    subsequent requests, while the session is still considered active, the user's
    browser (or equivalent) presents the session identifier, again usually by way
    of a cookie, for inspection. The PHP engine then uses this identifier to locate
    the appropriate file on the server, populating `$_SESSION` with the stored information.
    There are tremendous security concerns when the session identifier is the sole
    means of identifying a returning website visitor. In this recipe, we will present
    several techniques that will help you to safeguard your sessions, which, in turn,
    will vastly improve the overall security of the website.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: PHP会话机制非常简单。一旦使用`session_start()`或`php.ini session.autostart`设置开始会话，PHP引擎会生成一个唯一的令牌，默认情况下通过cookie传递给用户。在后续请求中，当会话仍然被视为活动状态时，用户的浏览器（或等效物）再次通常通过cookie呈现会话标识符进行检查。然后，PHP引擎使用此标识符定位服务器上的适当文件，并使用存储的信息填充`$_SESSION`。当会话标识符是识别返回的网站访问者的唯一手段时，存在巨大的安全问题。在本教程中，我们将介绍几种技术，这些技术将帮助您保护会话，从而大大提高网站的整体安全性。
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First of all, it''s important to recognize how using the session as the sole
    means of authentication can be dangerous. Imagine for a moment that when a valid
    user logs in to your website, that you set a `loggedIn` flag in `$_SESSION`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，重要的是要认识到将会话作为唯一的身份验证手段可能是危险的。想象一下，当有效用户登录到您的网站时，您在`$_SESSION`中设置了一个`loggedIn`标志：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In your program logic, you allow the user to see sensitive information if `$_SESSION[''isLoggedIn'']`
    is set to `TRUE`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的程序逻辑中，如果`$_SESSION['isLoggedIn']`设置为`TRUE`，则允许用户查看敏感信息：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If an attacker were to obtain the session identifier, for example, by means
    of a successfully executed **Cross-site scripting** (**XSS**) attack, all he/she
    would need to do would be to set the value of the `PHPSESSID` cookie to the illegally
    obtained one, and they are now viewed by your application as a valid user.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果攻击者能够获取会话标识符，例如，通过成功执行的**跨站脚本**（**XSS**）攻击，他/她只需要将`PHPSESSID` cookie的值设置为非法获取的值，他们现在被您的应用程序视为有效用户。
- en: 'One quick and easy way to narrow the window of time during which the `PHPSESSID`
    is valid is to use `session_regenerate_id()`. This very simple command generates
    a new session identifier, invalidates the old one, maintains session data intact,
    and has a minimal impact on performance. This command can only be executed after
    the session has started:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缩小`PHPSESSID`有效时间窗口的一种快速简单方法是使用`session_regenerate_id()`。这个非常简单的命令生成一个新的会话标识符，使旧的会话标识符无效，保持会话数据完整，并对性能影响很小。此命令只能在会话开始后执行：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Another often overlooked technique is to ensure that web visitors have a logout
    option. It is important, however, to not only destroy the session using `session_destroy()`,
    but also to unset `$_SESSION` data and to expire the session cookie:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个经常被忽视的技术是确保网站访问者有注销选项。然而，重要的是不仅使用`session_destroy()`销毁会话，还要取消`$_SESSION`数据并使会话cookie过期：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another easy technique that can be used to prevent session hijacking is to
    develop a finger-print or thumb-print of the website visitor. One way to implement
    this technique is to collect information unique to the website visitor over and
    above the session identifier. Such information includes the user agent (that is,
    the browser), languages accepted, and remote IP address. You can derive a simple
    hash from this information, and store the hash on the server in a separate file.
    The next time the user visits the website, if you have determined they are logged
    in based on session information, you can then perform a secondary verification
    by matching finger-prints:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种可以用来防止会话劫持的简单技术是开发网站访问者的指纹。实现这种技术的一种方法是收集与会话标识符不同的网站访问者的唯一信息。这些信息包括用户代理（即浏览器）、接受的语言和远程IP地址。您可以从这些信息中派生出一个简单的哈希，并将哈希存储在服务器上的一个单独文件中。下次用户访问网站时，如果您已经确定他们基于会话信息已登录，那么您可以通过匹配指纹进行二次验证：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are using `md5()` as it's a fast hashing algorithm and is well suited for
    internal usage. It is *not recommended* to use `md5()` for any external use as
    it is subject to brute-force attacks.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`md5()`作为快速哈希算法，非常适合内部使用。*不建议*在任何外部使用中使用`md5()`，因为它容易受到暴力攻击。
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To demonstrate how a session is vulnerable, code a simple login script that
    sets a `$_SESSION[`''`isLoggedIn`''`] flag` upon successful login. You could call
    the file `chap_12_session_hijack.php`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示会话的漏洞性，编写一个简单的登录脚本，成功登录后设置`$_SESSION[`'`isLoggedIn`'`] flag`。您可以将文件命名为`chap_12_session_hijack.php`：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can then add code that displays a simple login form. To test for session
    vulnerability, follow this procedure using the `chap_12_session_hijack.php` file
    we just created:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以添加显示简单登录表单的代码。要测试会话漏洞，请按照使用我们刚刚创建的`chap_12_session_hijack.php`文件的步骤：
- en: Change to the directory containing the file.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到包含文件的目录。
- en: Run the `php -S localhost:8080` command.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`php -S localhost:8080`命令。
- en: Using one browser, open the URL `http://localhost:8080/<filename>`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个浏览器，打开URL `http://localhost:8080/<filename>`。
- en: Login as user `test` with a password as `password`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用用户名`test`和密码`password`登录。
- en: You should be able to see **You Can Now See Super Secret Information!!!**.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该能够看到**您现在可以查看超级秘密信息!!!**。
- en: 'Refresh the page: each time, you should see a new session identifier.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新页面：每次都应该看到一个新的会话标识符。
- en: Copy the value of the `PHPSESSID` cookie.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`PHPSESSID` cookie的值。
- en: Open another browser to the same web page.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个网页上用另一个浏览器打开。
- en: Modify the cookie sent by the browser by copying the value of `PHPSESSID`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制`PHPSESSID`的值修改浏览器发送的cookie。
- en: 'For illustration, we are also showing the value of `$_COOKIE` and `$_SESSION`,
    shown in the following screenshot using the Vivaldi browser:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，我们还在以下截图中使用Vivaldi浏览器显示了`$_COOKIE`和`$_SESSION`的值：
- en: '![How it works...](graphics/B05314_12_03.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_12_03.jpg)'
- en: 'We then copy the value of `PHPSESSID`, open a Firefox browser, and use a tool
    called Tamper Data to modify the value of the cookie:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们复制`PHPSESSID`的值，打开Firefox浏览器，并使用一个名为Tamper Data的工具来修改cookie的值：
- en: '![How it works...](graphics/B05314_12_04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_12_04.jpg)'
- en: 'You can see in the next screenshot that we are now an authenticated user without
    entering the username or password:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在下一个截图中看到，我们现在是经过身份验证的用户，而无需输入用户名或密码：
- en: '![How it works...](graphics/B05314_12_05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_12_05.jpg)'
- en: 'You can now implement the changes discussed in the preceding steps. Copy the
    file created previously to `chap_12_session_protected.php`. Now go ahead and regenerate
    the session ID:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以实施前面步骤中讨论的更改。将先前创建的文件复制到`chap_12_session_protected.php`。现在继续重新生成会话ID：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, initialize variables and determine the logged in status (as before):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，初始化变量并确定登录状态（与以前一样）：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can add a session thumb-print using the remote address, user agent, and
    language settings:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用远程地址、用户代理和语言设置添加会话指纹：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If the login is successful, we store thumb-print info and login status in the
    session:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果登录成功，我们将会话中的指纹信息和登录状态存储起来：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also check for the logout option and implement a proper logout procedure:
    unset `$_SESSION` variables, invalidate the session, and expire the cookie. You
    can also remove the thumb-print file and implement a redirect:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以检查注销选项并实施适当的注销过程：取消设置`$_SESSION`变量，使会话无效，并使cookie过期。您还可以删除指纹文件并实施重定向：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Otherwise, if the operation is not login or logout, you can check to see whether
    the user is considered logged in, and if the thumb-print doesn''t match, the session
    is considered invalid, and the appropriate action is taken:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果操作不是登录或注销，您可以检查用户是否被视为已登录，如果指纹不匹配，则会话被视为无效，并采取适当的操作：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can now run the same procedure as mentioned previously using the new `chap_12_session_protected.php`
    file. The first thing you will notice is that the session is now considered invalid.
    The output will look something like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用新的`chap_12_session_protected.php`文件运行与之前提到的相同的过程。您将首先注意到的是会话现在被视为无效。输出将类似于这样：
- en: '![How it works...](graphics/B05314_12_06.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_12_06.jpg)'
- en: The reason for this is that the thumb-print does not match as you are now using
    a different browser. Likewise, if you refresh the page of the first browser, the
    session identifier is regenerated, making any previously copied identifier obsolete.
    Finally, the logout button will completely clear session information.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是指纹不匹配，因为您现在正在使用不同的浏览器。同样，如果您刷新第一个浏览器的页面，会话标识符将被重新生成，使任何先前复制的标识符都将变得过时。最后，注销按钮将完全清除会话信息。
- en: See also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For an excellent overview of website vulnerabilities, please refer to the article
    present at [https://www.owasp.org/index.php/Category:Vulnerability](https://www.owasp.org/index.php/Category:Vulnerability).
    For information on session hijacking, refer to [https://www.owasp.org/index.php/Session_hijacking_attack](https://www.owasp.org/index.php/Session_hijacking_attack).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有关网站漏洞的出色概述，请参阅[https://www.owasp.org/index.php/Category:Vulnerability](https://www.owasp.org/index.php/Category:Vulnerability)上的文章。有关会话劫持的信息，请参阅[https://www.owasp.org/index.php/Session_hijacking_attack](https://www.owasp.org/index.php/Session_hijacking_attack)。
- en: Securing forms with a token
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用令牌保护表单
- en: This recipe presents another very simple technique that will safeguard your
    forms against **Cross Site Request Forgery** (**CSRF**) attacks. Simply put, a
    CSRF attack is possible when, possibly using other techniques, an attacker is
    able to infect a web page on your website. In most cases, the infected page will
    then start issuing requests (that is, using JavaScript to purchase items, or make
    settings changes) using the credentials of a valid, logged-in user. It's extremely
    difficult for your application to detect such activity. One measure that can easily
    be taken is to generate a random token that is included in every form to be submitted.
    Since the infected page will not have access to the token, nor have the ability
    to generate one that matches, form validation will fail.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方提供了另一种非常简单的技术，可以保护您的表单免受**跨站点请求伪造**（**CSRF**）攻击。简而言之，当攻击者可能使用其他技术时，可以在您网站上的网页上感染一个CSRF攻击。在大多数情况下，受感染的页面将开始发出请求（即使用JavaScript购买物品或进行设置更改）使用有效的已登录用户的凭据。您的应用程序极其难以检测到这种活动。可以采取的一个措施是生成一个随机令牌，该令牌包含在要提交的每个表单中。由于受感染的页面将无法访问令牌，也无法生成与之匹配的令牌，因此表单验证将失败。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, to demonstrate the problem, we create a web page that simulates an infected
    page that generates a request to post an entry to the database. For this illustration,
    we will call the file `chap_12_form_csrf_test_unprotected.html`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为了演示问题，我们创建一个模拟受感染页面的网页，该页面生成一个请求以将条目发布到数据库。为此示例，我们将文件命名为`chap_12_form_csrf_test_unprotected.html`：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we create a script called `chap_12_form_unprotected.php` that responds
    to the form posting. As with other calling programs in this book, we set up autoloading
    and use the `Application\Database\Connection` class covered in [Chapter 5](ch05.html
    "Chapter 5. Interacting with a Database"), *Interacting with a Database*:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为`chap_12_form_unprotected.php`的脚本，用于响应表单提交。与本书中的其他调用程序一样，我们设置自动加载并使用[第5章](ch05.html
    "第5章。与数据库交互")中介绍的`Application\Database\Connection`类，*与数据库交互*。
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We then check to see the process button has been pressed, and even implement
    a filtering mechanism, as covered in the *Filtering $_POST data* recipe in this
    chapter. This is to prove that a CSRF attack is easily able to bypass filters:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们检查处理按钮是否已被按下，并实施一个过滤机制，如本章中*过滤$_POST数据*食谱中所述。这是为了证明CSRF攻击很容易绕过过滤器：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we insert the filtered data into the database using a prepared statement.
    We then redirect to another script, called `chap_12_form_view_results.php`, which
    simply dumps the contents of the `visitors` table:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用预处理语句将过滤后的数据插入数据库。然后重定向到另一个名为`chap_12_form_view_results.php`的脚本，该脚本简单地转储`visitors`表的内容：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The result, of course, is that the attack is allowed, despite filtering and
    the use of prepared statements.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，结果是，尽管进行了过滤并使用了预处理语句，攻击仍然被允许。
- en: 'Implementing the form protection token is actually quite easy! First of all,
    you need to generate the token and store it in the session. We take advantage
    of the new `random_bytes()` PHP 7 function to generate a truly random token, one
    which will be difficult, if not impossible, for an attacker to match:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，实现表单保护令牌非常容易！首先，您需要生成令牌并将其存储在会话中。我们利用新的`random_bytes()` PHP 7函数来生成一个真正随机的令牌，这个令牌对于攻击者来说将是困难的，如果不是不可能的匹配：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The output of `random_bytes()` is binary. We use `base64_encode()` to convert
    it into a usable string. We then further process it using `urlencode()` so that
    it is properly rendered in an HTML form.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`random_bytes()`的输出是二进制的。我们使用`base64_encode()`将其转换为可用的字符串。然后我们使用`urlencode()`进一步处理它，以便在HTML表单中正确呈现。'
- en: 'When we render the form, we then present the token as a hidden field:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们呈现表单时，我们将令牌呈现为隐藏字段：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We then copy and alter the `chap_12_form_unprotected.php` script mentioned
    previously, adding logic to first check to see whether the token matches the one
    stored in the session. Note that we unset the current token to make it invalid
    for future use. We call the new script `chap_12_form_protected_with_token.php`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们复制并修改先前提到的`chap_12_form_unprotected.php`脚本，添加逻辑来首先检查会话中存储的令牌是否匹配。请注意，我们取消当前令牌以使其对将来的使用无效。我们将新脚本命名为`chap_12_form_protected_with_token.php`：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To test how an infected web page might launch a CSRF attack, create the following
    files, as shown earlier in the recipe:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试感染的网页如何发起CSRF攻击，创建以下文件，如前面的示例所示：
- en: '`chap_12_form_csrf_test_unprotected.html`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chap_12_form_csrf_test_unprotected.html`'
- en: '`chap_12_form_unprotected.php`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chap_12_form_unprotected.php`'
- en: 'You can then define a file called `chap_12_form_view_results.php`, which dumps
    the `visitors` table:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以定义一个名为`chap_12_form_view_results.php`的文件，其中转储`visitors`表的内容：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'From a browser, launch `chap_12_form_csrf_test_unprotected.html`. Here is how
    the output might appear:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从浏览器中启动`chap_12_form_csrf_test_unprotected.html`。以下是输出可能会出现的样子：
- en: '![How it works...](graphics/B05314_12_07.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_12_07.jpg)'
- en: As you can see, the attack was successful despite filtering and the use of prepared
    statements!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，尽管进行了过滤并使用了预处理语句，攻击仍然成功！
- en: 'Next, copy the `chap_12_form_unprotected.php` file to `chap_12_form_protected.php`.
    Make the change indicated in step 8 in the recipe. You will also need to alter
    the test HTML file, copying `chap_12_form_csrf_test_unprotected.html` to `chap_12_form_csrf_test_protected.html`.
    Change the value for the action parameter in the `FORM` tag as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`chap_12_form_unprotected.php`文件复制到`chap_12_form_protected.php`。按照食谱中的第8步所示进行更改。您还需要修改测试HTML文件，将`chap_12_form_csrf_test_unprotected.html`复制到`chap_12_form_csrf_test_protected.html`。将`FORM`标签中的action参数的值更改如下：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When you run the new HTML file from a browser, it calls `chap_12_form_protected.php`,
    which looks for a token that does not exist. Here is the expected output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从浏览器运行新的HTML文件时，它会调用`chap_12_form_protected.php`，该文件寻找一个不存在的令牌。以下是预期的输出：
- en: '![How it works...](graphics/B05314_12_08.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_12_08.jpg)'
- en: 'Finally, go ahead and define a file called `chap_12_form_protected.php` that
    generates a token and displays it as a hidden element:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，继续定义一个名为`chap_12_form_protected.php`的文件，生成一个令牌并将其显示为隐藏元素：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When we display and submit data from the form, the token is validated and the
    data insertion is allowed to continue, as shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们显示并提交表单中的数据时，将验证令牌并允许数据插入继续进行，如下所示：
- en: '![How it works...](graphics/B05314_12_09.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_12_09.jpg)'
- en: See also
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information on CSFR attacks, please refer to [https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有关CSFR攻击的更多信息，请参阅[https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))。
- en: Building a secure password generator
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个安全的密码生成器
- en: A common misconception is that the only way attackers crack hashed passwords
    is by using **brute force attacks** and **rainbow tables**. Although this is often
    the first pass in an attack sequence, attackers will use much more sophisticated
    attacks on a second, third, or fourth pass. Other attacks include *combination*,
    *dictionary*, *mask*, and rules-based. Dictionary attacks use a database of words
    literally from the dictionary to guess passwords. Combination is where dictionary
    words are combined. Mask attacks are similar to brute force, but more selective,
    thus cutting down the time to crack. Rules-based attacks will detect things such
    as substituting the number 0 for the letter o.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解是，攻击者破解哈希密码的唯一方法是使用**暴力攻击**和**彩虹表**。虽然这通常是攻击序列中的第一步，但攻击者会在第二、第三或第四步使用更复杂的攻击。其他攻击包括*组合*、*字典*、*掩码*和基于规则的攻击。字典攻击使用来自字典的单词数据库来猜测密码。组合是指组合字典中的单词。掩码攻击类似于暴力攻击，但更有选择性，因此缩短了破解时间。基于规则的攻击将检测诸如用数字0替换字母o之类的事情。
- en: The good news is that by simply increasing the length of the password beyond
    the magic length of six characters exponentially increases the time to crack the
    hashed password. Other factors, such as interspersing uppercase with lowercase
    letters randomly, random digits, and special characters, will also have an exponential
    impact on the time to crack. At the end of the day, we need to bear in mind that
    a human being will eventually need to enter the passwords created, which means
    that need to be at least marginally memorable.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，通过简单地增加密码长度超过六个字符的长度，可以指数级增加破解哈希密码所需的时间。其他因素，例如随机将大写字母与小写字母交错、随机数字和特殊字符，也会对破解所需的时间产生指数影响。最终，我们需要牢记的是，最终需要有人输入创建的密码，这意味着密码至少需要稍微记忆。
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Passwords should be stored as a hash, and never as plain text. MD5 and SHA*
    are no longer considered secure (although SHA* is much better than MD5). Using
    a utility such as `oclHashcat`, an attacker can generate an average of 55 billion
    attempts per second on a password hashed using MD5 that has been made available
    through an exploit (that is, a successful SQL injection attack).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 密码应该以哈希形式存储，而不是明文。MD5和SHA*不再被认为是安全的（尽管SHA*比MD5好得多）。使用诸如`oclHashcat`之类的实用程序，攻击者可以在密码使用MD5哈希后通过漏洞（即成功的SQL注入攻击）生成平均每秒55亿次尝试。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we define a `Application\Security\PassGen` class that will hold the
    methods needed for password generation. We also define certain class constants
    and properties that will be used as part of the process:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个`Application\Security\PassGen`类，该类将包含生成密码所需的方法。我们还定义了一些类常量和属性，这些常量和属性将作为流程的一部分使用：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We then define low-level methods that will be used for password generation.
    As the names suggest, `digits()` produces random digits, and `special()` produces
    a single character from the `SPECIAL_CHARS` class constant:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义将用于生成密码的低级方法。正如名称所示，`digits()`生成随机数字，`special()`从`SPECIAL_CHARS`类常量中生成一个字符：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that we are frequently using the new PHP 7 function `random_int()` in
    this example. Although marginally slower, this method offers true **Cryptographically
    Secure Pseudo Random Number Generator** (**CSPRNG**) capabilities compared to
    the more dated `rand()` function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此示例中，我们经常使用新的PHP 7函数`random_int()`。尽管稍慢，但与更陈旧的`rand()`函数相比，这种方法提供了真正的**密码安全伪随机数生成器**（**CSPRNG**）功能。
- en: 'Now comes the tricky part: generating a hard-to-guess word. This is where the
    `$wordSource` constructor parameter comes into play. It is an array of websites
    from which our word base will be derived. Accordingly, we need a method that will
    pull a unique list of words from the sources indicated, and store the results
    in a file. We accept the `$wordSource` array as an argument, and loop through
    each URL. We use `md5()` to produce a hash of the website name, which is then
    built into a filename. The newly produced filename is then stored in `$sourceList`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是棘手的部分：生成一个难以猜测的单词。这就是`$wordSource`构造函数参数发挥作用的地方。它是一个网站数组，我们的单词库将从中派生。因此，我们需要一个方法，该方法将从指定的来源中提取一个唯一的单词列表，并将结果存储在文件中。我们将`$wordSource`数组作为参数接受，并循环遍历每个URL。我们使用`md5()`生成网站名称的哈希值，然后将其构建成文件名。然后将新生成的文件名存储在`$sourceList`中：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If the file doesn''t exist, or is zero-byte, we process the contents. If the
    source is HTML, we only accept content inside the `<body>` tag. We then use `str_word_count()`
    to pull a list of words out of the string, also employing `strip_tags()` to remove
    any markup:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件不存在或为空字节，我们处理内容。如果来源是HTML，我们只接受`<body>`标签内的内容。然后我们使用`str_word_count()`从字符串中提取单词列表，同时使用`strip_tags()`去除任何标记：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We then remove any words that are too short, and use `array_unique()` to get
    rid of duplicates. The final result is stored in a file:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们删除任何太短的单词，并使用`array_unique()`去除重复项。最终结果存储在文件中：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we define a method that *flips* random letters in the word to uppercase:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个*翻转*单词中随机字母为大写的方法：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we are ready to define a method that chooses a word from our source.
    We choose a word source at random, and use the `file()` function to read from
    the appropriate cached file:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们准备定义一个从我们的来源选择单词的方法。我们随机选择一个单词来源，并使用`file()`函数从适当的缓存文件中读取：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'So that we do not always produce passwords of the same pattern, we define a
    method that allows us to place the various components of a password in different
    positions in the final password string. The algorithms are defined as an array
    of method calls available within this class. So, for example, an algorithm of
    `[''word'', ''digits'', ''word'', ''special'']` might end up looking like `hElLo123aUTo!`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了不总是生成相同模式的密码，我们定义了一个方法，允许我们将密码的各个组件放置在最终密码字符串的不同位置。算法被定义为此类中可用的方法调用数组。例如，一个`['word',
    'digits', 'word', 'special']`的算法最终可能看起来像`hElLo123aUTo!`：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The constructor accepts the word source array, minimum word length, and location
    of the cache directory. It then processes the source files and initializes the
    algorithms:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数接受单词来源数组、最小单词长度和缓存目录的位置。然后处理源文件并初始化算法：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we are able to define the method that actually generates the password.
    All it needs to do is to select an algorithm at random, and then loop through,
    calling the appropriate methods:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们能够定义实际生成密码的方法。它只需要随机选择一个算法，然后循环调用适当的方法：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'First, you will need to place the code described in the previous recipe into
    a file called `PassGen.php` in the `Application\Security` folder. Now you can
    create a calling program called `chap_12_password_generate.php` that sets up autoloading,
    uses `PassGen`, and defines the location of the cache directory:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要将前面一篇文章中描述的代码放入`Application\Security`文件夹中名为`PassGen.php`的文件中。现在您可以创建一个名为`chap_12_password_generate.php`的调用程序，设置自动加载，使用`PassGen`，并定义缓存目录的位置：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, you will need to define an array of websites that will be used as a source
    for the word-base to be used in password generation. In this illustration, we
    will choose from the Project Gutenberg texts *Ulysses* (J. Joyce), *War and Peace*
    (L. Tolstoy), and *Pride and Prejudice* (J. Austen):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要定义一个网站数组，用作密码生成中的单词库的来源。在这个例子中，我们将从Project Gutenberg的文本《尤利西斯》（J.乔伊斯）、《战争与和平》（L.托尔斯泰）和《傲慢与偏见》（J.奥斯汀）中进行选择：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we create the `PassGen` instance, and run `generate()`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建`PassGen`实例，并运行`generate()`：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here are a few example passwords produced by `PassGen`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`PassGen`生成的一些示例密码：
- en: '![How it works...](graphics/B05314_12_10.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_12_10.jpg)'
- en: See also
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'An excellent article on how an attacker would approach cracking a password
    can be viewed at [http://arstechnica.com/security/2013/05/how-crackers-make-minced-meat-out-of-your-passwords/](http://arstechnica.com/security/2013/05/how-crackers-make-minced-meat-out-of-your-passwords/).
    To find out more about brute force attacks you can refer to [https://www.owasp.org/index.php/Brute_force_attack](https://www.owasp.org/index.php/Brute_force_attack).
    For information on `oclHashcat`, see this page: [http://hashcat.net/oclhashcat/](http://hashcat.net/oclhashcat/).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关于攻击者如何破解密码的优秀文章可以在[http://arstechnica.com/security/2013/05/how-crackers-make-minced-meat-out-of-your-passwords/](http://arstechnica.com/security/2013/05/how-crackers-make-minced-meat-out-of-your-passwords/)上查看。要了解更多关于暴力破解攻击的信息，您可以参考[https://www.owasp.org/index.php/Brute_force_attack](https://www.owasp.org/index.php/Brute_force_attack)。有关`oclHashcat`的信息，请参阅此页面：[http://hashcat.net/oclhashcat/](http://hashcat.net/oclhashcat/)。
- en: Safeguarding forms with a CAPTCHA
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CAPTCHA保护表单
- en: '**CAPTCHA** is actually an acronym for **Completely Automated Public Turing
    Test to Tell Computers and Humans Apart**. The technique is similar to the one
    presented in the preceding recipe, *Securing forms with a token*. The difference
    is that instead of storing the token in a hidden form input field, the token is
    rendered into a graphic that is difficult for an automated attack system to decipher.
    Also, the intent of a CAPTCHA is slightly different from a form token: it is designed
    to confirm that the web visitor is a human being, and not an automated system.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAPTCHA**实际上是**Completely Automated Public Turing Test to Tell Computers
    and Humans Apart**的缩写。这种技术类似于前面的配方“使用令牌保护表单”。不同之处在于，它不是将令牌存储在隐藏的表单输入字段中，而是将令牌呈现为对自动攻击系统难以解密的图形。此外，CAPTCHA的目的与表单令牌略有不同：它旨在确认网页访问者是人类，而不是自动系统。'
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'There are several approaches to CAPTCHA: presenting a question based on knowledge
    only a human would possess, text tricks, and a graphics image that needs to be
    interpreted.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CAPTCHA有几种方法：基于只有人类才会知道的知识提出问题，文本技巧和需要解释的图形图像。
- en: The image approach presents web visitors with an image with heavily distorted
    letters and/or numbers. This approach can be complicated, however, in that it
    relies on the GD extension, which may not be available on all servers. The GD
    extension can be difficult to compile, and has heavy dependencies on various libraries
    that must be present on the host server.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图像方法向网页访问者展示了一个带有严重扭曲的字母和/或数字的图像。然而，这种方法可能会很复杂，因为它依赖于GD扩展，而并非所有服务器都可用。GD扩展可能很难编译，并且对主机服务器上必须存在的各种库有很重的依赖。
- en: The text approach is to present a series of letters and/or numbers, and give
    the web visitor a simple instruction such as *please type this backwards*. Another
    variation is to use ASCII "art" to form characters that a human web visitor is
    able to interpret.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本方法是呈现一系列字母和/或数字，并给网页访问者一个简单的指令，比如“请将这个倒过来输入”。另一种变化是使用ASCII“艺术”来形成人类网页访问者能够解释的字符。
- en: Finally, you might have a question/answer approach with questions such as *The
    head is attached to the body by what body part*, and have answers such as *Arm*,
    *Leg*, and *Neck*. The downside to this approach is that an automated attack system
    will have a 1 in 3 chance of passing the test.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可能会有一个问题/答案方法，例如“头部是由什么身体部位连接到身体上”，并且有答案如“手臂”、“腿”和“脖子”。这种方法的缺点是自动攻击系统有三分之一的机会通过测试。
- en: Generating a text CAPTCHA
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成文本CAPTCHA
- en: 'For this illustration, we will start with the text approach, and follow with
    the image approach. In either case, we first need to define a class that generates
    the phrase to be presented (and decoded by the web visitor). For this purpose,
    we define an `Application\Captcha\Phrase` class. We also define properties and
    class constants used in the phrase generation process:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将从文本方法开始，然后再使用图像方法。无论哪种情况，我们首先需要定义一个生成要呈现的短语（并由网页访问者解码）的类。为此，我们定义一个`Application\Captcha\Phrase`类。我们还定义了在短语生成过程中使用的属性和类常量：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The constructor, as you would expect, accepts values for the various properties,
    with defaults assigned so that an instance can be created without having to specify
    any parameters. The `$include*` flags are used to signal which character sets
    will be present in the base string from which the phrase will be generated. For
    example, if you wish to only have numbers, `$includeUpper` and `$includeLower`
    would both be set to `FALSE`. `$otherChars` is provided for extra flexibility.
    Finally, `$suppressChars` represents an array of characters that will be removed
    from the base string. The default removes uppercase `O` and lowercase `l`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数如您所期望的那样，接受各种属性的值，分配默认值，以便可以创建一个实例而无需指定任何参数。`$include*`标志用于表示将在生成短语的基本字符串中存在哪些字符集。例如，如果您只希望有数字，则`$includeUpper`和`$includeLower`都将设置为`FALSE`。`$otherChars`提供了额外的灵活性。最后，`$suppressChars`表示将从基本字符串中删除的字符数组。默认情况下，删除大写字母`O`和小写字母`l`：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We then define a series of getters and setters, one for each property. Please
    note that we only show the first two in order to conserve space.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一系列的getter和setter，每个属性都有一个。请注意，为了节省空间，我们只显示前两个。
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We next need to define a method that initializes the base string. This consists
    of a series of simple if statements that check the various `$include*` flags and
    append to the base string as appropriate. At the end, we use `str_replace()` to
    remove the characters represented in `$suppressChars`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一个初始化基本字符串的方法。这由一系列简单的if语句组成，检查各种`$include*`标志并根据需要附加到基本字符串。最后，我们使用`str_replace()`来删除`$suppressChars`中表示的字符：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Get rid of letters that can be confused with numbers (that is, the letter `O`
    can be confused with the number `0`, and a lowercase `l` can be confused with
    the number `1`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 摆脱可能与数字混淆的字母（即，字母`O`可能与数字`0`混淆，小写字母`l`可能与数字`1`混淆。
- en: 'We are now ready to define the core method that generates the random phrase
    that the CAPTCHA presents to website visitors. We set up a simple `for()` loop,
    and use the new PHP 7 `random_int()` function to jump around in the base string:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备定义生成随机短语的核心方法，这是验证码呈现给网站访问者的。我们设置一个简单的`for()`循环，并使用新的PHP 7 `random_int()`函数在基本字符串中跳转：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we turn our attention away from the phrase and onto the class that will
    produce a text CAPTCHA. For this purpose, we first define an interface so that,
    in the future, we can create additional CAPTCHA classes that all make use of `Application\Captcha\Phrase`.
    Note that `getImage()` will return text, text art, or an actual image, depending
    on which class we decide to use:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将注意力从短语转移到将生成文本验证码的类上。为此，我们首先定义一个接口，以便将来可以创建额外的验证码类，所有这些类都使用`Application\Captcha\Phrase`。请注意，`getImage()`将返回文本、文本艺术或实际图像，具体取决于我们决定使用哪个类：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For a text CAPTCHA, we define a `Application\Captcha\Reverse` class. The reason
    for this name is that this class produces not just text, but text in reverse.
    The `__construct()` method builds an instance of `Phrase`. Note that `getImage()`
    returns the phrase in reverse:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于文本验证码，我们定义了一个`Application\Captcha\Reverse`类。这个名字的原因是这个类不仅产生文本，而且是反向的文本。`__construct()`方法构建了一个`Phrase`的实例。请注意，`getImage()`以反向返回短语：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Generating an image CAPTCHA
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成图像验证码
- en: The image approach, as you can well imagine, is much more complicated. The phrase
    generation process is the same. The main difference is that not only do we need
    to imprint the phrase on a graphic, but we also need to distort each letter differently
    and introduce noise in the form of random dots.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你可以想象的那样，图像方法要复杂得多。短语生成过程是相同的。主要区别在于，我们不仅需要在图形上印刷短语，还需要以不同的方式扭曲每个字母，并引入随机点的噪音。
- en: 'We define a `Application\Captcha\Image` class that implements `CaptchaInterface`.
    The class constants and properties include not only those needed for phrase generation,
    but what is needed for image generation as well:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个实现`CaptchaInterface`的`Application\Captcha\Image`类。该类的常量和属性不仅包括短语生成所需的内容，还包括图像生成所需的内容：
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The constructor needs to accept all the arguments required for phrase generation,
    as described in the previous steps. In addition, we need to accept arguments required
    for image generation. The two mandatory parameters are `$imageDir` and `$imageUrl`.
    The first is where the graphic will be written. The second is the base URL, after
    which we will append the generated filename. `$imageFont` is provided in case
    we want to provide TrueType fonts, which will produce a more secure CAPTCHA. Otherwise,
    we''re limited to the default fonts which, to quote a line in a famous movie,
    *ain''t a pretty sight*:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数需要接受前面步骤中描述的短语生成所需的所有参数。此外，我们还需要接受图像生成所需的参数。两个必需参数是`$imageDir`和`$imageUrl`。第一个是图形将被写入的位置。第二个是基本URL，之后我们将附加生成的文件名。如果我们想提供TrueType字体，可以提供`$imageFont`，这将产生更安全的验证码。否则，我们只能使用默认字体，引用一部著名电影中的一句台词，*不是一道美丽的风景*：
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, still in the constructor, we check to see whether the `imagecreatetruecolor`
    function exists. If this comes back as `FALSE`, we know the GD extension is not
    available. Otherwise, we assign parameters to properties, generate the phrase,
    remove old images, and write out the CAPTCHA graphic:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在构造函数中，我们检查`imagecreatetruecolor`函数是否存在。如果返回`FALSE`，我们知道GD扩展不可用。否则，我们将参数分配给属性，生成短语，删除旧图像，并写出验证码图形：
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The process of removing old images is extremely important; otherwise we will
    end up with a directory filled with expired CAPTCHA images! We use the `DirectoryIterator`
    class to scan the designated directory and check the access time. We calculate
    an old image file as one that is the current time minus the value specified by
    `IMAGE_EXP_TIME`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除旧图像的过程非常重要；否则我们最终会得到一个充满过期验证码图像的目录！我们使用`DirectoryIterator`类来扫描指定目录并检查访问时间。我们将旧图像文件定义为当前时间减去`IMAGE_EXP_TIME`指定值的文件：
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We are now ready to move on to the main show. First, we split the `$imageRGB`
    array into `$red`, `$green`, and `$blue`. We use the core `imagecreatetruecolor()`
    function to generate the base graphic with the width and height specified. We
    use the RGB values to colorize the background:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备转向主要内容。首先，我们将`$imageRGB`数组分成`$red`、`$green`和`$blue`。我们使用核心的`imagecreatetruecolor()`函数生成指定宽度和高度的基本图形。我们使用RGB值对背景进行着色：
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we define *x* and *y* margins based on image width and height. We then
    initialize variables to be used to write the phrase onto the graphic. We then
    loop a number of times that matches the length of the phrase:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们根据图像宽度和高度定义*x*和*y*边距。然后，我们初始化要用于将短语写入图形的变量。然后我们循环多次，次数与短语的长度相匹配：
- en: '[PRE56]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If `$imageFont` is specified, we are able to write each character with a different
    size and angle. We also need to adjust the *x* axis (that is, horizontal) value
    according to the size:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指定了`$imageFont`，我们可以使用不同的大小和角度写入每个字符。我们还需要根据大小调整*x*轴（即水平）的值：
- en: '[PRE57]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Otherwise, we''re stuck with the default fonts. We use the largest size of
    `5`, as smaller sizes are unreadable. We provide a low level of distortion by
    alternating between `imagechar()`, which writes the image normally, and `imagecharup()`,
    which writes it sideways:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们将被默认字体所困扰。我们使用最大尺寸的`5`，因为较小的尺寸是不可读的。我们通过交替使用`imagechar()`（正常写入图像）和`imagecharup()`（侧向写入）来提供低级别的扭曲：
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next we need to add noise in the form of random dots. This is necessary in
    order to make the image harder for automated systems to detect. It is also recommended
    that you add code to draw a few lines as well:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加随机点的噪音。这是必要的，以使图像对自动化系统更难以检测。建议您也添加代码来绘制一些线条：
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We then create a random image filename using our old friend `md5()` with the
    date and a random number from `0` to `9999` as arguments. Note that we can safely
    use `md5()` as we are not trying to hide any secret information; we''re merely
    interested in generating a unique filename quickly. We wipe out the image object
    as well to conserve memory:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用我们的老朋友`md5()`创建一个随机图像文件名，其中日期和从`0`到`9999`的随机数作为参数。请注意，我们可以安全地使用`md5()`，因为我们并不试图隐藏任何秘密信息；我们只是想快速生成一个唯一的文件名。我们也清除图像对象以节省内存：
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The entire construct is in a `try/catch` block. If an error or exception is
    thrown, we log the message and take the appropriate action:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个结构都在一个`try/catch`块中。如果发生错误或异常，我们会记录消息并采取适当的措施：
- en: '[PRE61]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, we define the methods required by the interface. Note that `getImage()`
    returns an HTML `<img>` tag, which can then be immediately displayed:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义接口所需的方法。请注意，`getImage()`返回一个HTML `<img>`标签，然后可以立即显示：
- en: '[PRE62]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Be sure to define the classes discussed in this recipe, summarized in the following
    table:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 确保定义本配方中讨论的类，总结如下表：
- en: '| Class | Subsection | The steps it appears in |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 子节 | 出现的步骤 |'
- en: '| --- | --- | --- |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Application\Captcha\Phrase` | Generating a text CAPTCHA | 1 - 5 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Captcha\Phrase` | 生成文本CAPTCHA | 1 - 5 |'
- en: '| `Application\Captcha\CaptchaInterface` |   | 6 |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Captcha\CaptchaInterface` |   | 6 |'
- en: '| `Application\Captcha\Reverse` |   | 7 |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Captcha\Reverse` |   | 7 |'
- en: '| `Application\Captcha\Image` | Generating an image CAPTCHA | 2 - 13 |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Captcha\Image` | 生成图像CAPTCHA | 2 - 13 |'
- en: 'Next, define a calling program called `chap_12_captcha_text.php` that implements
    a text CAPTCHA. You first need to set up autoloading and use the appropriate classes:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个名为`chap_12_captcha_text.php`的调用程序，实现文本CAPTCHA。您首先需要设置自动加载并使用适当的类：
- en: '[PRE63]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'After that, be sure to start the session. You would use appropriate measures
    to protect the session as well. To conserve space, we only show one simple measure,
    `session_regenerate_id()`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，请确保启动会话。您还应该采取适当的措施来保护会话。为了节省空间，我们只显示了一个简单的措施，`session_regenerate_id()`：
- en: '[PRE64]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, you can define a function that creates the CAPTCHA; retrieves the phrase,
    label, and image (in this case, reverse text); and stores the value in the session:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以定义一个函数，该函数创建CAPTCHA；检索短语、标签和图像（在本例中为反向文本）；并将该值存储在会话中：
- en: '[PRE65]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now is a good time to initialize variables and determine the `loggedIn` status:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是初始化变量并确定`loggedIn`状态的好时机：
- en: '[PRE66]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You can then check to see whether the login button has been pressed. If so,
    check to see whether the CAPTCHA phrase has been entered. If not, initialize a
    message informing the user they need to enter the CAPTCHA phrase:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以检查登录按钮是否已被按下。如果是，则检查CAPTCHA短语是否已输入。如果没有，初始化一条消息，告知用户他们需要输入CAPTCHA短语：
- en: '[PRE67]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If the CAPTCHA phrase is present, check to see whether it matches what is stored
    in the session. If it doesn''t match, proceed as if the form is invalid. Otherwise,
    process the login as you would have otherwise. For the purposes of this illustration,
    you can simulate a login by using hard-coded values for the username and password:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果CAPTCHA短语存在，请检查它是否与会话中存储的内容匹配。如果不匹配，请继续处理表单无效。否则，处理登录与以往一样。为了说明这一点，您可以使用用户名和密码的硬编码值模拟登录：
- en: '[PRE68]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You might also want to add code for a logout option, as described in the *Safeguarding
    the PHP session* recipe:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想添加注销选项的代码，如*Safeguarding the PHP session*配方中所述：
- en: '[PRE69]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You can then run `setCaptcha()`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以运行`setCaptcha()`：
- en: '[PRE70]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Lastly, don''t forget the view logic, which, in this example, presents a basic
    login form. Inside the form tag, you''ll need to add view logic to display the
    CAPTCHA and label:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不要忘记视图逻辑，在本例中，它呈现一个基本的登录表单。在表单标记内，您需要添加视图逻辑来显示CAPTCHA和标签：
- en: '[PRE71]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here is the resulting output:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生成的输出：
- en: '![How it works...](graphics/B05314_12_11.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_12_11.jpg)'
- en: 'To demonstrate how to use the image CAPTCHA, copy the code from `chap_12_captcha_text.php`
    to `cha_12_captcha_image.php`. We define constants that represent the location
    of the directory in which we will write the CAPTCHA images. (Be sure to create
    this directory!) Otherwise, the autoloading and use statement structure is similar.
    Note that we also define a TrueType font. Differences are noted in **bold**:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用图像CAPTCHA，将`chap_12_captcha_text.php`中的代码复制到`cha_12_captcha_image.php`中。我们定义代表我们将写入CAPTCHA图像的目录位置的常量。（确保创建此目录！）否则，自动加载和使用语句结构类似。请注意，我们还定义了一个TrueType字体。差异以**粗体**标出：
- en: '[PRE72]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Tip
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Important!**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要！**'
- en: Fonts can potentially be protected under copyright, trademark, patent, or other
    intellectual property laws. If you use a font for which you are not licensed,
    you and your customer could be held liable in court! Use an open source font,
    or one that is available on the web server for which you have a valid license.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 字体可能受版权、商标、专利或其他知识产权法的保护。如果您使用未经许可的字体，您和您的客户可能会在法庭上承担责任！请使用开源字体，或者您拥有有效许可的Web服务器上可用的字体。
- en: 'Of course, in the `setCaptcha()` function, we use the `Image` class instead
    of `Reverse`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在`setCaptcha()`函数中，我们使用`Image`类而不是`Reverse`：
- en: '[PRE73]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Variable initialization is the same as the previous script, and login processing
    is identical to the previous script:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 变量初始化与先前的脚本相同，登录处理与先前的脚本相同：
- en: '[PRE74]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Even the view logic remains the same, as we are using `getImage()`, which,
    in the case of the image CAPTCHA, returns directly usable HTML. Here is the output
    using a TrueType font:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 即使视图逻辑保持不变，因为我们正在使用`getImage()`，在图像验证码的情况下，它返回直接可用的HTML。这是使用TrueType字体的输出：
- en: '![How it works...](graphics/B05314_12_12.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_12_12.jpg)'
- en: There's more...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you are not inclined to use the preceding code to generate your own in-house
    CAPTCHA, there are plenty of libraries available. Most popular frameworks have
    this ability. Zend Framework, for example, has its Zend\Captcha component class.
    There is also reCAPTCHA, which is generally invoked as a service in which your
    application makes a call to an external website that generates the CAPTCHA and
    token for you. A good place to start looking is [http://www.captcha.net/](http://www.captcha.net/)
    website.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不愿意使用上述代码生成自己的内部CAPTCHA，那么有很多库可用。大多数流行的框架都具有此功能。例如，Zend Framework有其Zend\Captcha组件类。还有reCAPTCHA，通常作为一项服务调用，您的应用程序会调用外部网站生成CAPTCHA和令牌。开始寻找的好地方是[http://www.captcha.net/](http://www.captcha.net/)网站。
- en: See also
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information on the protection of fonts as intellectual property, refer
    to the article present at [https://en.wikipedia.org/wiki/Intellectual_property_protection_of_typefaces](https://en.wikipedia.org/wiki/Intellectual_property_protection_of_typefaces).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 有关字体作为知识产权的保护的更多信息，请参阅[https://en.wikipedia.org/wiki/Intellectual_property_protection_of_typefaces](https://en.wikipedia.org/wiki/Intellectual_property_protection_of_typefaces)上的文章。
- en: Encrypting/decrypting without mcrypt
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密/解密无需mcrypt
- en: It is a little-known fact among members of the general PHP community that the
    `mcrypt` extension, the core of most PHP-based encryption considered secure, is
    anything but secure. One of the biggest issues, from a security perspective, is
    that the `mcrypt` extension requires advanced knowledge of cryptography to successfully
    operate, which few programmers have. This leads to gross misuse and ultimately
    problems such as a 1 in 256 chance of data corruption. Not good odds. Furthermore,
    developer support for `libmcrypt`, the core library upon which the `mcrypt` extension
    is based, was *abandoned* in 2007, which means the code base is out-of-date, bug-ridden,
    and has no mechanism to apply patches. Accordingly, it is extremely important
    to understand how to perform strong encryption/decryption *without* using `mcrypt`!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般PHP社区的成员中，一个鲜为人知的事实是，被认为是安全的大多数基于PHP的加密的核心`mcrypt`扩展实际上并不安全。从安全的角度来看，最大的问题之一是`mcrypt`扩展需要对加密学有高级知识才能成功操作，而这是很少有程序员具备的。这导致了严重的误用，最终会出现诸如256分之1的数据损坏的问题。这不是一个好的几率。此外，对于`libmcrypt`，`mcrypt`扩展所基于的核心库，开发支持在2007年就被*放弃*了，这意味着代码库已经过时，存在错误，并且没有机制来应用补丁。因此，非常重要的是要了解如何在*不*使用`mcrypt`的情况下执行强大的加密/解密！
- en: How to do it...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The solution to the problem posed previously, in case you're wondering, is to
    use `openssl`. This extension is well maintained, and has modern and very strong
    encryption/decryption capabilities.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决之前提出的问题的方法是使用`openssl`。这个扩展是被很好地维护的，并且具有现代和非常强大的加密/解密能力。
- en: Tip
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Important**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要**'
- en: In order to use any `openssl*` functions, the `openssl` PHP extension must be
    compiled and enabled! In addition, you will need to install the latest OpenSSL
    package on your web server.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用任何`openssl*`函数，必须编译和启用`openssl` PHP扩展！此外，您需要在Web服务器上安装最新的OpenSSL软件包。
- en: First, you will need to determine which cipher methods are available on your
    installation. For this purpose, you can use the `openssl_get_cipher_methods()`
    command. Examples will include algorithms based on **Advanced** **Encryption Standard**
    (**AES**), **BlowFish** (**BF**), **CAMELLIA**, **CAST5**, **Data** **Encryption
    Standard** (**DES**), **Rivest** **Cipher** (**RC**) (also affectionately known
    as **Ron's** **Code**), and **SEED**. You will note that this method shows cipher
    methods duplicated in upper and lowercase.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要确定安装中有哪些密码方法。为此，您可以使用`openssl_get_cipher_methods()`命令。示例将包括基于**高级** **加密标准**（**AES**），**BlowFish**（**BF**），**CAMELLIA**，**CAST5**，**数据**
    **加密标准**（**DES**），**Rivest** **Cipher**（**RC**）（也可亲切地称为**Ron's** **Code**），和**SEED**的算法。您会注意到，此方法显示了大小写重复的密码方法。
- en: 'Next, you will need to figure out which method is most appropriate for your
    needs. Here is a table that gives a quick summary of the various methods:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要弄清楚哪种方法最适合您的需求。这里有一个快速总结各种方法的表：
- en: '| Method | Published | Key size (bits) | Key block size (bytes) | Notes |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 发布 | 密钥大小（位） | 密钥块大小（字节） | 注释 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `camellia` | 2000 | 128, 192, 256 | 16 | Developed by Mitsubishi and NTT
    |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `camellia` | 2000 | 128, 192, 256 | 16 | 由三菱和NTT开发 |'
- en: '| `aes` | 1998 | 128, 192, 256 | 16 | Developed by Joan Daemen and Vincent
    Rijmen. Originally submitted as Rijndael |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `aes` | 1998 | 128, 192, 256 | 16 | 由Joan Daemen和Vincent Rijmen开发。最初提交为Rijndael
    |'
- en: '| `seed` | 1998 | 128 | 16 | Developed by the Korea Information Security Agency
    |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `seed` | 1998 | 128 | 16 | 由韩国信息安全机构开发 |'
- en: '| `cast5` | 1996 | 40 to 128 | 8 | Developed by Carlisle Adams and Stafford
    Tavares |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `cast5` | 1996 | 40到128 | 8 | 由Carlisle Adams和Stafford Tavares开发 |'
- en: '| `bf` | 1993 | 1 to 448 | 8 | Designed by Bruce Schneier |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `bf` | 1993 | 1到448 | 8 | 由Bruce Schneier设计 |'
- en: '| `rc2` | 1987 | 8 to 1,024defaults to 64 | 8 | Designed by Ron Rivest (one
    of the core founders of RSA) |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `rc2` | 1987 | 8到1,024默认为64 | 8 | 由Ron Rivest设计（RSA的核心创始人之一） |'
- en: '| `des` | 1977 | 56 (+8 parity bits) | 8 | Developed by IBM, based on work
    done by Horst Feistel |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `des` | 1977 | 56（+8奇偶校验位） | 8 | 由IBM开发，基于Horst Feistel的工作 |'
- en: 'Another consideration is what your preferred block cipher **mode of operation
    is**. Common choices are summarized in this table:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个考虑因素是您首选的块密码**操作模式**是什么。常见选择总结在这个表中：
- en: '| Mode | Stands For | Notes |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 代表 | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| ECB | Electronic Code Book | Does not require **initialization vector** (**IV**);
    supports parallelization for both encryption and decryption; simple and fast;
    does not hide data patterns; not recommended!!! |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| ECB | 电子密码本 | 不需要**初始化向量**（IV）；支持加密和解密的并行化；简单快速；不隐藏数据模式；不推荐！！！ |'
- en: '| CBC | Cipher Block Chaining | Requires IV; subsequent blocks, even if identical,
    are XOR''ed with previous block, resulting in better overall encryption; if the
    IVs are predictable, the first block can be decoded, leaving remaining message
    exposed; message must be padded to a multiple of the cipher block size; supports
    parallelization only for decryption |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| CBC | 密码块链接 | 需要IV；即使相同，后续块也与前一个块进行异或运算，从而获得更好的整体加密；如果IV可预测，第一个块可以被解码，剩余消息暴露；消息必须填充到密码块大小的倍数；仅支持解密的并行化
    |'
- en: '| CFB | Cipher Feedback | Close relative of CBC, except that encryption is
    performed in reverse |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| CFB | 密码反馈 | 与CBC密切相关，只是加密是反向进行的 |'
- en: '| OFB | Output Feedback | Very symmetrical: encrypt and decrypt are the same;
    does not supports parallelization at all |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| OFB | 输出反馈 | 非常对称：加密和解密相同；不支持任何并行化 |'
- en: '| CTR | Counter | Similar in operation to OFB; supports parallelization for
    both encryption and decryption |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| CTR | 计数器 | 在操作上类似于OFB；支持加密和解密的并行化 |'
- en: '| CCM | Counter with CBC-MAC | Derivative of CTR; only designed for block length
    of 128 bits; provides authentication and confidentiality; **CBC-MAC** stands for
    **Cipher Block Chaining - Message Authentication Code** |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| CCM | 计数器与CBC-MAC | CTR的派生；仅设计用于块长度为128位；提供认证和保密性；**CBC-MAC**代表**密码块链接 -
    消息认证码** |'
- en: '| GCM | Galois/Counter Mode | Based on CTR mode; should use a different IV
    for each stream to be encrypted; exceptionally high throughput (compared to other
    modes); supports parallelization for both encryption and decryption |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| GCM | Galois/Counter Mode | 基于CTR模式；每个要加密的流应使用不同的IV；吞吐量异常高（与其他模式相比）；支持加密和解密的并行化
    |'
- en: '| XTS | XEX-based Tweaked-codebook mode with ciphertext Stealing | Relatively
    new (2010) and fast; uses two keys; increases the amount of data that can be securely
    encrypted as one block |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| XTS | 基于XEX的改进密码本模式与密文窃取 | 相对较新（2010年）和快速；使用两个密钥；增加了可以安全加密的数据量 |'
- en: Before choosing a cipher method and mode, you will also need to determine whether
    the encrypted contents needs to be unencrypted outside of your PHP application.
    For example, if you are storing database credentials encrypted into a standalone
    text file, do you need to have the ability to decrypt from the command line? If
    so, make sure that the cipher method and operation mode you choose are supported
    by the target operating system.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择密码方法和模式之前，您还需要确定加密内容是否需要在PHP应用程序之外解密。例如，如果您将数据库凭据加密存储到独立的文本文件中，您是否需要能够从命令行解密？如果是这样，请确保您选择的密码方法和操作模式受目标操作系统支持。
- en: 'The number of bytes supplied for the **IV** varies according to the cipher
    method chosen. For best results, use `random_bytes()` (new in PHP 7), which returns
    a true **CSPRNG** sequence of bytes. The length of the IV varies considerably.
    Try a size of 16 to start with. If a *warning* is generated, the correct number
    of bytes to be supplied for that algorithm will be shown, so adjust the size accordingly:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供的**IV**的字节数取决于所选择的密码方法。为了获得最佳结果，使用`random_bytes()`（PHP 7中的新功能），它返回真正的**CSPRNG**字节序列。IV的长度差别很大。首先尝试大小为16。如果生成了*警告*，将显示应为该算法提供的正确字节数，因此请相应调整大小：
- en: '[PRE75]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'To perform encryption, use `openssl_encrypt()`. Here are the parameters that
    should be passed:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行加密，使用`openssl_encrypt()`。以下是应该传递的参数：
- en: '| Parameter | Notes |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| Parameter | 注释 |'
- en: '| --- | --- |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Data | Plain text you need to encrypt. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| Data | 需要加密的明文。 |'
- en: '| Method | One of the methods you identified using `openssl_get_cipher_methods()`.
    identified as follows:*method* - *key_size* - *cipher_mode*So, for example, if
    you want a method of AES, a key size of 256, and GCM mode, you would enter `aes-256-gcm`.
    |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| Method | 使用`openssl_get_cipher_methods()`识别的方法之一。识别如下：*method* - *key_size*
    - *cipher_mode*。所以，例如，如果您想要AES方法，密钥大小为256，以及GCM模式，您将输入`aes-256-gcm`。 |'
- en: '| Password | Although documented as *password*, this parameter can be viewed
    as a *key*. Use `random_bytes()` to generate a key with a number of bytes to match
    the desired key size. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| Password | 虽然文档中称为*password*，但这个参数可以被视为*key*。使用`random_bytes()`生成一个与所需密钥大小匹配的密钥。
    |'
- en: '| Options | Until you gain more experience with `openssl` encryption, it is
    recommended you stick with the default value of `0`. |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| Options | 在您对`openssl`加密有更多经验之前，建议您坚持使用默认值`0`。 |'
- en: '| IV | Use `random_bytes()` to generate an IV with a number of bytes to match
    the cipher method. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| IV | 使用`random_bytes()`生成一个与密码方法匹配字节数的IV。 |'
- en: 'As an example, suppose you wanted to choose the AES cipher method, a key size
    of 256, and XTS mode. Here is the code used to encrypt:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 举个例子，假设你想选择AES密码方法，密钥大小为256，并且选择XTS模式。以下是用于加密的代码：
- en: '[PRE76]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To decrypt, use the same values for `$key` and `$iv`, along with the `openssl_decrypt()`
    function:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要解密，使用相同的`$key`和`$iv`值，以及`openssl_decrypt()`函数：
- en: '[PRE77]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: How it works...
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In order to see which cipher methods are available, create a PHP script called
    `chap_12_openssl_encryption.php` and run this command:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看可用的密码方法，创建一个名为`chap_12_openssl_encryption.php`的PHP脚本，并运行以下命令：
- en: '[PRE78]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The output should look something like this:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '![How it works...](graphics/B05314_12_13.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_12_13.jpg)'
- en: 'Next, you can add values for the plain text to be encrypted, the method, key,
    and IV. As an example, try AES, with a key size of 256, using the XTS operating
    mode:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以添加要加密的明文、方法、密钥和IV的值。例如，尝试AES，密钥大小为256，使用XTS操作模式：
- en: '[PRE79]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'To encrypt, you can use `openssl_encrypt()`, specifying the parameters configured
    previously:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行加密，可以使用`openssl_encrypt()`，指定之前配置的参数：
- en: '[PRE80]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You might also want to base 64-encode the result to make it more usable:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还希望对结果进行 base 64 编码，以使其更易于使用：
- en: '[PRE81]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To decrypt, use the same `$key` and `$iv` values. Don''t forget to un-encode
    the base 64 value first:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密，请使用相同的 `$key` 和 `$iv` 值。不要忘记先解码 base 64 值：
- en: '[PRE82]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here is the output showing the base 64-encoded cipher text, followed by the
    decrypted plain text:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出，显示了 base 64 编码的密文，然后是解密后的明文：
- en: '![How it works...](graphics/B05314_12_14.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_12_14.jpg)'
- en: 'If you supply an incorrect number of bytes for the IV, for the cipher method
    chosen, a warning message will be shown:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为 IV 提供了不正确数量的字节，对于所选择的密码方法，将显示警告消息：
- en: '![How it works...](graphics/B05314_12_15.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_12_15.jpg)'
- en: There's more...
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In PHP 7, there was a problem when using `open_ssl_encrypt()` and `open_ssl_decrypt()`
    and the **Authenticated Encrypt with Associated Data** (**AEAD**) modes supported:
    GCM and CCM. Accordingly, in PHP 7.1, three extra parameters have been added to
    these functions, as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 7 中，使用 `open_ssl_encrypt()` 和 `open_ssl_decrypt()` 以及支持的 **Authenticated
    Encrypt with Associated Data** (**AEAD**) 模式：GCM 和 CCM 时存在问题。因此，在 PHP 7.1 中，这些函数已添加了三个额外的参数，如下所示：
- en: '| Parameter | Description |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `$tag` | Authentication tag passed by reference; variable value remains the
    same if authentication fails |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `$tag` | 通过引用传递的认证标签；如果认证失败，变量值保持不变 |'
- en: '| `$aad` | Additional authentication data |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `$aad` | 附加的认证数据 |'
- en: '| `$tag_length` | 4 to 16 for GCM mode; no limits for CCM mode; only for `open_ssl_encrypt()`
    |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `$tag_length` | GCM 模式为 4 到 16；CCM 模式没有限制；仅适用于 `open_ssl_encrypt()` |'
- en: For more information, you can refer to [https://wiki.php.net/rfc/openssl_aead](https://wiki.php.net/rfc/openssl_aead).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，您可以参考 [https://wiki.php.net/rfc/openssl_aead](https://wiki.php.net/rfc/openssl_aead)。
- en: See also
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For an excellent discussion on why the `mcrypt` extension is being deprecated
    in PHP 7.1, please refer to the article at [https://wiki.php.net/rfc/mcrypt-viking-funeral](https://wiki.php.net/rfc/mcrypt-viking-funeral).
    For a good description of block cipher, which forms the basis for the various
    cipher methods, refer to the article present at [https://en.wikipedia.org/wiki/Block_cipher](https://en.wikipedia.org/wiki/Block_cipher).
    For an excellent description of AES, refer to [https://en.wikipedia.org/wiki/Advanced_Encryption_Standard](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard).
    A good article that describes encryption operation modes can be seen at [https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在 PHP 7.1 中为什么要弃用 `mcrypt` 扩展的出色讨论，请参阅 [https://wiki.php.net/rfc/mcrypt-viking-funeral](https://wiki.php.net/rfc/mcrypt-viking-funeral)
    上的文章。有关分组密码的良好描述，这构成了各种密码方法的基础，请参阅 [https://en.wikipedia.org/wiki/Block_cipher](https://en.wikipedia.org/wiki/Block_cipher)
    上的文章。有关 AES 的出色描述，请参阅 [https://en.wikipedia.org/wiki/Advanced_Encryption_Standard](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)。可以在
    [https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)
    上看到描述加密操作模式的出色文章。
- en: Note
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For some of the newer modes, if the data to be encrypted is less than the block
    size, `openssl_decrypt()` will return no value. If you *pad* the data to be at
    least the block size, the problem goes away. Most of the modes implement internal
    padding so this is not an issue. With some of the newer modes (that is, `xts`)
    you might see this problem. Be sure to conduct tests on short strings of data
    less than eight characters before putting your code into production.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些较新的模式，如果要加密的数据小于块大小，`openssl_decrypt()` 将不返回任何值。如果 *填充* 要至少达到块大小的数据，则问题就消失了。大多数模式实现了内部填充，因此这不是问题。对于一些较新的模式（即
    `xts`），您可能会遇到这个问题。在将代码投入生产之前，请务必对少于八个字符的短数据字符串进行测试。
