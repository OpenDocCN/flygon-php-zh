- en: Using Linked Lists
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用链表
- en: We know a lot about arrays already. Now, we are going to shift our focus to
    a new type of data structure known as a *list* . It is one of the most used data
    structures in the programming world. In most of the programming languages, the
    array is a fixed size structure. As a result, it cannot grow dynamically, and
    shrinking or removing an item from a fixed size array is also problematic since
    we have to shift the array's items to fill up the gap. For this reason, many developers
    prefer lists instead of arrays. Considering the fact that each array element can
    have an overhead of some extra bytes, linked lists can be used where memory efficiency
    is a big factor. In this chapter, we will explore the different types of linked
    lists in PHP and their implementation. We will also look at real-world problems
    that can be solved using linked lists.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对数组有了很多了解。现在，我们将把重点转移到一种称为*list*的新类型的数据结构上。它是编程世界中最常用的数据结构之一。在大多数编程语言中，数组是一个固定大小的结构。因此，它无法动态增长，从固定大小数组中缩小或删除项目也是有问题的，因为我们必须移动数组的项目来填补空白。因此，许多开发人员更喜欢使用列表而不是数组。考虑到每个数组元素可能有一些额外字节的开销，链表可以在内存效率是一个重要因素的情况下使用。在本章中，我们将探讨PHP中不同类型的链表及其实现。我们还将看看可以使用链表解决的现实世界问题。
- en: What is a linked list?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是链表？
- en: 'A linked list is a collection of objects known as nodes. Each node is connected
    to the next node with a link, which is nothing but an object reference. If we
    consider the following image, each box represents a node. The arrow indicates
    the link between the nodes. This is an example of a singly linked list. The last
    node contains the next link of a NULL, so that it marks the end of the list:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 链表是一组称为节点的对象。每个节点都与下一个节点连接，连接是一个对象引用。如果我们考虑以下图像，每个框代表一个节点。箭头表示节点之间的链接。这是一个单向链表的示例。最后一个节点包含NULL的下一个链接，因此它标记了列表的结束：
- en: '![](Image00021.gif)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00021.gif)'
- en: A node is an object, meaning it can store any data type as simple as a string,
    integer, or float, or complex, such as an array, array of arrays, objects, or
    object arrays. We can store anything as per our need.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 节点是一个对象，意味着它可以存储任何数据类型，如字符串、整数、浮点数，或者复杂的数据类型，如数组、数组的数组、对象或对象数组。我们可以根据需要存储任何东西。
- en: 'We can also perform a wide variety of operations on a linked list, such as
    the following ones:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在链表上执行各种操作，例如以下操作：
- en: Checking whether the list is empty
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查列表是否为空
- en: Displaying all items in the list
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示列表中的所有项目
- en: Searching an item in the list
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中搜索项目
- en: Getting the size of the list
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取列表的大小
- en: Inserting a new item at the beginning or end of the list
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表的开头或结尾插入新项目
- en: Removing an item from the beginning or end of the list
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表的开头或结尾删除项目
- en: Inserting a new item at a specific place or before/after an item
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定位置或在某个项目之前/之后插入新项目
- en: Reversing a list
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转列表
- en: These are only some of the operations that can be performed on a linked list.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是可以在链表上执行的一些操作。
- en: 'Let''s write a simple linked list to store some names:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的链表来存储一些名称：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We mentioned earlier that a linked list consists of nodes. We have created
    a simple class for our node. The `ListNode` class has two properties: one that
    will store the data and the other for the link called `next` . Now, we are going
    to implement a linked list using the `ListNode` class. For simplicity, we will
    just have two operations: `insert` and `display` :'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到链表由节点组成。我们为我们的节点创建了一个简单的类。`ListNode`类有两个属性：一个用于存储数据，另一个用于称为`next`的链接。现在，我们将使用`ListNode`类实现一个链表。为简单起见，我们只有两个操作：`insert`和`display`：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code actually implements our two basic operations for `insert`
    and `display` nodes. In the `LinkedList` class, we have two private properties:
    `$_firstNode` and `$_totalNodes` . Both have the default value of `NULL` and `0`
    , respectively. We need to mark the head node or first node, so that we always
    know where we have to start from. We can also call it the front node. Whatever
    name we provide, it will be mainly used to indicate the start of the linked list.
    Now, let''s move to the `insert` operation code.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码实际上实现了我们的两个基本操作`insert`和`display`节点。在`LinkedList`类中，我们有两个私有属性：`$_firstNode`和`$_totalNodes`。它们的默认值分别为`NULL`和`0`。我们需要标记头节点或第一个节点，以便我们始终知道从哪里开始。我们也可以称之为前节点。无论我们提供什么名称，它主要用于指示链表的开始。现在，让我们转到`insert`操作代码。
- en: 'The insert method takes one argument, which is the data itself. We will create
    a new node with the data using the `ListNode` class. Before inserting a book title
    in our linked list, we have to consider two possibilities:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 插入方法接受一个参数，即数据本身。我们将使用`ListNode`类使用数据创建一个新节点。在我们的链表中插入书名之前，我们必须考虑两种可能性：
- en: The list is empty and we are inserting the first title
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表为空，我们正在插入第一个标题
- en: The list is not empty and the title is going to be added at the end
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表不为空，标题将被添加到末尾
- en: 'Why do we need to consider both cases? The answer is pretty simple. If we do
    not know whether the list is empty or not, we might get different results for
    our operations. We might also create invalid linking between the nodes. So, the
    idea is if the list is empty, our insert item is going to be the first item of
    the list. This is what the first part of the code is doing:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要考虑两种情况？答案很简单。如果我们不知道列表是否为空，我们的操作可能会得到不同的结果。我们还可能在节点之间创建无效的链接。因此，如果列表为空，我们的插入项将成为列表的第一项。这是代码的第一部分在做的事情：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can see from the preceding code segment that we are creating a new node
    with the data and naming the node object `$newNode` . After that, it checks whether
    `$_firstNode` is `NULL` or not. If it is `NULL` , then the list is empty. If it
    is empty, then we assign the `$newNode` object to the `$_firstNode` property.
    Now, the remaining part of the `insert` method represents our second condition,
    which is that the list is not empty, and we have to add the new item at the end
    of the list:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码片段中，我们可以看到我们正在创建一个带有数据的新节点，并将节点对象命名为`$newNode`。之后，它检查`$_firstNode`是否为`NULL`。如果是`NULL`，那么列表是空的。如果为空，那么我们将`$newNode`对象分配给`$_firstNode`属性。现在，`insert`方法的剩余部分代表了我们的第二个条件，即列表不为空，我们必须在列表的末尾添加新项目：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we get the first node of the list from the `$_firstNode` property. Now,
    we are going to iterate from the first node until the end of the list. We will
    ensure this by checking the condition that the next link for the current node
    is not `NULL` . If it is `NULL` , then we have reached the end of the list. In
    order to make sure that we are not looping to the same node all the time, we set
    the next node on from the current node as the current item during the iteration
    process. The `while` loop code implements the logic. Once we get out of the `while`
    loop, we set the last node of the linked list as `$currentNode` . Now, we have
    to assign the next link of the current last node to the newly created node named
    `$newNode` , so we simply put the object to the next link of the node. This object
    reference will work as a link between two node objects. At the end, we also increment
    the total node count value by 1 by post-incrementing the `$_totalNode` property.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`$_firstNode`属性获取列表的第一个节点。现在，我们将从第一个节点迭代到列表的末尾。我们将通过检查当前节点的下一个链接是否为`NULL`来确保这一点。如果它是`NULL`，那么我们已经到达了列表的末尾。为了确保我们不会一直循环到同一个节点，我们在迭代过程中将下一个节点设置为当前节点的当前项。`while`循环代码实现了这个逻辑。一旦我们退出`while`循环，我们将链表的最后一个节点设置为`$currentNode`。现在，我们必须将当前最后一个节点的下一个链接分配给新创建的名为`$newNode`的节点，所以我们简单地将对象放到节点的下一个链接中。这个对象引用将作为两个节点对象之间的链接。最后，我们通过后增加`$_totalNode`属性来增加总节点计数值1。
- en: We could have easily created another property for the list that would track
    the last node. It could have saved us from looping the whole list every time we
    are inserting a new node. We ignored this option intentionally to work through
    the basic understanding of the linked list. Later in this chapter, we will implement
    that for faster operations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以轻松地为列表创建另一个属性，用于跟踪最后一个节点。这样可以避免在插入新节点时每次都循环整个列表。我们故意忽略了这个选项，以便通过对链表的基本理解来进行工作。在本章的后面，我们将实现这一点以实现更快的操作。
- en: 'If we look at our `display` method, we can see that we are using almost similar
    logic to iterate through each of the nodes and displaying its content. We first
    get the head item for the linked list. Then, we iterate through the list until
    the list item is NULL. Inside the loop, we display the node data by showing its
    `$data` property. Now, we have a node class `ListNode` to create individual nodes
    for the linked list, and we have the `LinkedList` class to do basic `insert` and
    `display` operations. Let''s write a small code to utilize the `LinkedList` class
    to create a linked list for book titles:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看我们的`display`方法，我们会发现我们几乎使用了类似的逻辑来迭代每个节点并显示其内容。我们首先获取链表的头节点。然后，我们迭代列表直到列表项为NULL。在循环内，我们通过显示其`$data`属性来显示节点数据。现在，我们有一个节点类`ListNode`来为链表创建单独的节点，还有一个`LinkedList`类来执行基本的`insert`和`display`操作。让我们编写一小段代码来利用`LinkedList`类来创建一个书名的链表：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we create a new object for `LinkedList` and name it `$BookTitles` . Then,
    we insert new book items using the `insert` method. We add three books, and then,
    we are displaying the book names using the `display` method. If we run the preceding
    code, we will see following output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为`LinkedList`创建一个新对象，并将其命名为`$BookTitles`。然后，我们使用`insert`方法插入新的书籍项目。我们添加了三本书，然后使用`display`方法显示书名。如果我们运行上述代码，我们将看到以下输出：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see, there is a counter at the first line that shows that we have
    three book titles, along with their names. If we look carefully, we will see that
    the book titles are displayed the same way that we entered them. This means our
    implemented linked list is actually maintaining the order. This is because we
    have always entered the new node at the end of the list. We could have done this
    differently if we wanted. As our first example, we have covered a lot about linked
    lists and how to construct them. In the upcoming sections, we will explore more
    about how to create different types of linked lists, and with more complex examples.
    For now, we are going to focus on the different types of linked lists.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，第一行有一个计数器，显示我们有三本书的标题，以及它们的名称。如果我们仔细看，我们会发现书名的显示方式与我们输入的方式相同。这意味着我们实现的链表实际上是保持顺序的。这是因为我们总是在列表的末尾输入新节点。如果我们愿意，我们可以以不同的方式做到这一点。作为我们的第一个例子，我们已经涵盖了很多关于链表以及如何构建它们的内容。在接下来的章节中，我们将更多地探索如何创建不同类型的链表，并且使用更复杂的例子。现在，我们将专注于不同类型的链表。
- en: Different types of linked list
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的链表
- en: 'So far, we have dealt with the kind of list known as a singly linked list,
    or linear linked list. However, there are also several different types of linked
    lists based on the operations involved:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经处理了一种称为单链表或线性链表的列表类型。然而，还有基于涉及的操作的几种不同类型的链表：
- en: Doubly linked list
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向链表
- en: Circular linked list
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环链表
- en: Multi-linked list
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多链表
- en: Doubly linked lists
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表
- en: 'In a doubly linked list, there are two links on each node: one to point to
    the next node and another one to the previous node. Where the singly linked list
    is unidirectional, the doubly linked list is bidirectional. We can move forward
    or backward in the list without any problem. The following image shows a sample
    doubly linked list. Later, in the *Implementing a doubly linked list in PHP* section,
    we will explore how to implement a doubly linked list:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在双向链表中，每个节点有两个链接：一个指向下一个节点，另一个指向前一个节点。单向链表是单向的，双向链表是双向的。我们可以在列表中前进或后退而不会出现任何问题。以下图片显示了一个示例双向链表。稍后，在*在PHP中实现双向链表*部分，我们将探讨如何实现双向链表：
- en: '![](Image00022.gif)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00022.gif)'
- en: Circular linked lists
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环链表
- en: 'In a singly or doubly linked list, there is no node after the last node, so
    the last node does not have any subsequent node to iterate on. If we allow the
    last node to point to the first node, we are making a circle. Such linked lists
    are known as circular linked lists. We can have both singly and doubly linked
    lists as circular linked lists. We will also implement a circular linked list
    in this chapter. The following image depicts a circular linked list:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在单向或双向链表中，最后一个节点后面没有节点，因此最后一个节点没有任何后续节点可以迭代。如果允许最后一个节点指向第一个节点，我们就形成了一个循环。这样的链表称为循环链表。我们可以将单向链表和双向链表都作为循环链表。在本章中，我们还将实现一个循环链表。以下图片展示了一个循环链表：
- en: '![](Image00023.gif)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00023.gif)'
- en: Multi-linked lists
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多链表
- en: 'A multi-linked list, or multiply linked list, is a special type of linked list
    that has two or more links linking each node to another node. It can grow multi-directionally
    based on the purpose of the linked list. For example, if we take the example of
    a list of students with each student being a node with the properties of name,
    age, gender, department, major, and so on, then we can link each student''s node
    not only with the next and previous nodes, but also with age, gender, department,
    and major. Though the usage of such a linked list requires a good understanding
    of the linked list concept, we can use such special linked lists whenever we need.
    The following image depicts a multi-linked list:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 多链表，或多重链表，是一种特殊类型的链表，每个节点与另一个节点有两个或更多个链接。它可以根据链表的目的多向增长。例如，如果我们以学生列表为例，每个学生都是一个具有姓名、年龄、性别、系别、专业等属性的节点，那么我们可以将每个学生的节点不仅与下一个和上一个节点链接，还与年龄、性别、系别和专业链接。尽管使用这样的链表需要对链表概念有很好的理解，但我们可以在需要时使用这样的特殊链表。以下图片展示了一个多链表：
- en: '![](Image00024.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00024.jpg)'
- en: Inserting, deleting, and searching for an item
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入、删除和搜索项目
- en: 'So far, we have seen only the operations for inserting a node and displaying
    all node contents. Now, we will explore the other operations available in a linked
    list. We will mainly focus on the following operations:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了插入节点和显示所有节点内容的操作。现在，我们将探索链表中的其他操作。我们主要关注以下操作：
- en: Inserting at the first node
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个节点插入
- en: Searching for a node
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索节点
- en: Inserting before a specific node
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定节点之前插入
- en: Inserting after a specific node
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定节点之后插入
- en: Deleting the first node
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除第一个节点
- en: Deleting the last node
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除最后一个节点
- en: Searching for and deleting one node
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索并删除一个节点
- en: Reversing a linked list
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转链表
- en: Getting Nth position element
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取第N个位置的元素
- en: Inserting at the first node
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在第一个节点插入
- en: 'When we add a node in the front, or head, we have to consider two simple possibilities.
    The list can be empty and as a result the new node is the head. This possibility
    is as simple as it can get. However, if the list already has a head, then we have
    to do the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在前面或头部添加一个节点时，我们必须考虑两种简单的可能性。列表可能为空，因此新节点是头节点。这种可能性就是简单得不能再简单了。但是，如果列表已经有一个头节点，那么我们必须执行以下操作：
- en: Create the new node.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新节点。
- en: Make the new node as first node or head.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新节点作为第一个节点或头节点。
- en: Assign the previous head or first node as the next to follow for the newly created
    first node.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前一个头或第一个节点分配为新创建的第一个节点的下一个跟随节点。
- en: 'Here is the code for this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此代码：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Searching for a node
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索节点
- en: 'Searching for a node is pretty simple. We need to iterate through each node
    and check whether the target data matches with the node data. If the data is found,
    the node will be returned; otherwise, it will return `FALSE` . The implementation
    looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索节点非常简单。我们需要遍历每个节点，并检查目标数据是否与节点数据匹配。如果找到数据，将返回节点；否则，返回`FALSE`。实现如下：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Inserting before a specific node
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在特定节点之前插入
- en: 'This process is similar to the first operation that we looked at. The main
    difference is that we need to find out the specific node and then insert a new
    node before it. When we find the target node, we can change the next node so that
    it points to the newly created node, and then we can change the node following
    the newly created node so that it points to the node that we searched for. This
    is shown in the following image:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程类似于我们查看的第一个操作。主要区别在于我们需要找到特定节点，然后在其之前插入一个新节点。当找到目标节点时，我们可以更改下一个节点，使其指向新创建的节点，然后更改新创建节点后面的节点，使其指向我们搜索的节点。如下图所示：
- en: '![](Image00025.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00025.jpg)'
- en: 'Here is the code to implement the logic shown earlier:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现前面展示的逻辑的代码：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we inspect the preceding code, we can see that the logic is pretty straightforward.
    We have two parameters in this method: one is the `data` and one is the `query`
    . We iterate through each node. While doing this, we also track the current node
    and previous node. It is important to track the previous node as we will set the
    next of previous node to a newly created node when our target node is found.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查前面的代码，我们可以看到逻辑非常简单。在这个方法中有两个参数：一个是`data`，一个是`query`。我们遍历每个节点。在这样做的同时，我们还跟踪当前节点和前一个节点。跟踪前一个节点很重要，因为当找到目标节点时，我们将把前一个节点的下一个节点设置为新创建的节点。
- en: Inserting after a specific node
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在特定节点之后插入
- en: 'This process is similar to the inserted a node before a target node. The difference
    is that we need to insert the new node after the target node. Here, we need to
    consider the target node as well as the next node, to which it''s pointing. When
    we find the target node, we can change the next node so that it points to the
    newly created node, and then we can change node following the newly created node
    so that it points to the next node following the target node. Here is the code
    used to implement this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程类似于在目标节点之前插入一个节点。不同之处在于，我们需要在目标节点之后插入新节点。在这里，我们需要考虑目标节点以及它指向的下一个节点。当我们找到目标节点时，我们可以更改下一个节点，使其指向新创建的节点，然后我们可以更改紧随新创建节点的节点，使其指向目标节点之后的下一个节点。以下是用于实现此操作的代码：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Deleting the first node
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除第一个节点
- en: 'Deleting a node simply means taking out the node and rearranging the previous
    and subsequent node links. If we just remove a node and connect the previous node''s
    next link with the node following the deleted node, we are done with the delete
    operation. Just have a look at the following example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 删除节点只是意味着取出节点并重新排列前一个和后续节点的链接。如果我们只是删除一个节点并将前一个节点的下一个链接与删除节点后面的节点连接起来，我们就完成了删除操作。请看以下示例：
- en: '![](Image00026.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00026.jpg)'
- en: 'When we delete the first node, we just have to make the second node our head
    or first node. We can achieve that very easily by using the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们删除第一个节点时，我们只需将第二个节点作为我们的头节点或第一个节点。我们可以通过以下代码轻松实现这一点：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we have to consider one special case, namely decreasing the total node
    count by one.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须考虑一个特殊情况，即将总节点数减少一个。
- en: Deleting the last node
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除最后一个节点
- en: 'Deleting the last node will require us to assign the second from last node''s
    next link to `NULL` . We will iterate until the last node and track the previous
    node as we go. Once we hit the last node, the previous node property of the next
    will be set to `NULL` , as shown in the following example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 删除最后一个节点将需要我们将倒数第二个节点的下一个链接指定为`NULL`。我们将迭代直到最后一个节点，并在迭代过程中跟踪前一个节点。一旦到达最后一个节点，下一个的前一个节点属性将被设置为`NULL`，如下例所示：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At first, we check whether the list is empty or not. After that, we check whether
    the list has more than one node. Based on the answer, we iterate to the the last
    node and tracking the previous node. Then, we assign the previous node's next
    link as `NULL` , just to omit the very last node from the list.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查列表是否为空。之后，我们检查列表是否有多于一个节点。根据答案，我们迭代到最后一个节点并跟踪前一个节点。然后，我们将前一个节点的下一个链接指定为`NULL`，以便从列表中省略最后一个节点。
- en: Searching for and deleting a node
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索并删除节点
- en: 'We can delete any node from our list using a search and delete operation. First,
    we search for the node from the list and then remove the node by removing references
    from the node. Here is the code to achieve this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用搜索和删除操作从列表中删除任何节点。首先，我们从列表中搜索节点，然后通过删除节点的引用来删除节点。以下是实现此操作的代码：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Reversing a list
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反转列表
- en: 'There are many approaches to reversing a linked list. We will work on a simple
    approach to reverse the list, which is known as in place reverse. We iterate through
    the nodes and change the next node to the previous, previous to the current, and
    the current to the next. A pseudo algorithm for the logic will look like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以反转链表。我们将使用一种简单的方法来反转列表，即原地反转。我们遍历节点并将下一个节点更改为前一个节点，前一个节点更改为当前节点，当前节点更改为下一个节点。逻辑的伪算法如下所示：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we implement our reverse function based on this pseudocode, it will look
    like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们根据这个伪代码实现我们的反转函数，它将如下所示：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Getting the Nth position element
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取第N个位置的元素
- en: 'As lists are different from arrays, it is not easier to get elements from their
    positions directly. In order to get an element in the Nth position, we have to
    iterate to that position and get the element. Here is the code sample for this
    method:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表与数组不同，直接从它们的位置获取元素并不容易。为了获取第N个位置的元素，我们必须迭代到该位置并获取元素。以下是此方法的代码示例：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have now written all the required operations for our `LinkedList` class.
    Now, let''s run the program with different operations. If we run the following
    program, we will mostly cover all the operations we have written:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经为我们的`LinkedList`类编写了所有必需的操作。现在，让我们用不同的操作运行程序。如果我们运行以下程序，我们将大多数覆盖我们已经编写的所有操作：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the preceding code will look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出将如下所示：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we have a complete implementation of a linked list using PHP 7\. One thing
    we have understood so far is that unlike the implementation of arrays, we have
    to do lots of operations manually by writing codes. We also have to remember one
    thing: This is not the only way we can implement a linked list. Many prefer to
    track both the first and last nodes of the list for a better insert operation.
    Now, we will look at the complexity of linked list operations in average and worst-case
    scenarios.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用PHP 7完整实现了一个链表。到目前为止，我们已经了解到，与数组的实现不同，我们必须通过编写代码手动执行许多操作。我们还必须记住一件事：这不是我们实现链表的唯一方式。许多人更喜欢跟踪列表的第一个和最后一个节点，以获得更好的插入操作。现在，我们将查看链表操作在平均和最坏情况下的复杂性。
- en: Understanding complexity for linked lists
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解链表的复杂性
- en: 'Here is the best, worst, and average-case complexity for linked list operations:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是链表操作的最佳、最坏和平均情况复杂性：
- en: '| **Operation** | **Time Complexity: Worst Case** | **Time Complexity: Average
    Case** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **时间复杂度：最坏情况** | **时间复杂度：平均情况** |'
- en: '| Insert at beginning or end | `O(1)` | `O(1)` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 在开头或结尾插入 | `O(1)` | `O(1)` |'
- en: '| Delete at beginning or end | `O(1)` | `O(1)` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 在开头或结尾删除 | `O(1)` | `O(1)` |'
- en: '| Search | `O(n)` | `O(n)` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 搜索 | `O(n)` | `O(n)` |'
- en: '| Access | `O(n)` | `O(n)` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 访问 | `O(n)` | `O(n)` |'
- en: We can achieve the `O(1)` insert complexity at the end of the linked list by
    keeping a track of the last node, as we did for the first node in our examples.
    This will help us jump directly to the last node of the linked list without any
    iteration.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过跟踪最后一个节点来实现在链表末尾的`O(1)`插入复杂度，就像我们在示例中对第一个节点所做的那样。这将帮助我们直接跳转到链表的最后一个节点，而无需进行任何迭代。
- en: Making the linked list iterable
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将链表变成可迭代的
- en: 'So far, we have seen that we can traverse each node of the linked list using
    a `while` loop inside the methods. What if we need to iterate from outside using
    just the linked list object? It is very much possible to achieve this. PHP has
    a very intuitive iterator interface that allows any external iterators to iterate
    through an object internally. The `Iterator` interface provides the following
    methods:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到可以使用`while`循环在方法内部遍历链表的每个节点。如果我们需要从外部使用链表对象进行迭代，该怎么办？实现这一点是完全可能的。PHP有一个非常直观的迭代器接口，允许任何外部迭代器在对象内部进行迭代。`Iterator`接口提供以下方法：
- en: '**Current** : Return the current element'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Current**：返回当前元素'
- en: '**Next** : Move forward to the next element'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Next**：向前移动到下一个元素'
- en: '**Key** : Return the key of the current element'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Key**：返回当前元素的键'
- en: '**Rewind** : Rewind the `Iterator` to the first element'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rewind**：将`Iterator`倒回到第一个元素'
- en: '**Valid** : Checks whether the current position is valid'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Valid**：检查当前位置是否有效'
- en: 'We will now implement these methods in our `LinkedList` class to make our object
    iterate through the nodes from the object directly. In order to track the current
    node and the current position within the list during iteration, we will require
    two new properties for our `LinkedList` class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在我们的`LinkedList`类中实现这些方法，使我们的对象可以直接通过节点进行迭代。为了在迭代期间跟踪当前节点和列表中的当前位置，我们需要为我们的`LinkedList`类添加两个新属性：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `$_currentNode` property will track the current node during the iteration,
    and `$_currentPosition` will track the current position during the iteration.
    We also need to make sure that our class `LinkedList` class is also implementing
    the `Iterator` interface. It will look like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`$_currentNode`属性将在迭代期间跟踪当前节点，`$_currentPosition`将在迭代期间跟踪当前位置。我们还需要确保我们的`LinkedList`类也实现了`Iterator`接口。代码如下：'
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s implement those five new methods to make our linked list object
    iterable. These five methods are very straightforward and simple to implement.
    Here is the code for that:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现这五个新方法，使我们的链表对象可迭代。这五个方法非常直接和简单。代码如下：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we have a list that is iterable. This means that now we can iterate through
    our linked list object using the `foreach` loop or any other iteration process
    we wish to follow. So, now, if we write the following code, we will see all the
    book titles:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个可迭代的列表。这意味着现在我们可以使用`foreach`循环或任何其他迭代过程来遍历我们的链表对象。因此，如果我们编写以下代码，我们将看到所有的书名：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another approach can be using the `rewind` , `valid` , `next` , and `current`
    methods from the iterable interface. It will have the same output as the preceding
    code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用可迭代接口的`rewind`、`valid`、`next`和`current`方法。它将产生与前面代码相同的输出：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Building circular linked list
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建循环链表
- en: 'Building a circular linked list is not at as hard as it sounds from the name.
    So far, we have seen that adding a new node at the end is pretty simple; we set
    the next reference of the last node to `NULL` . In a circular linked list, the
    last node''s next reference will actually point to the first node, thereby creating
    a circular list. Let''s write a simple circular linked list where the nodes will
    be inserted at the end of the list:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 构建循环链表并不像名字听起来那么难。到目前为止，我们已经看到在末尾添加新节点非常简单；我们将最后一个节点的下一个引用设置为`NULL`。在循环链表中，最后一个节点的下一个引用实际上将指向第一个节点，从而创建一个循环列表。让我们编写一个简单的循环链表，其中节点将被插入到列表的末尾：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we look closely look at the preceding code, it looks exactly like our singly
    linked list implementation. The only difference is that we do not check the end
    of the list, rather than making sure the current node is not the same as the first
    node. Also, in the following line, we assign the next reference of the newly created
    node to the first node of the list:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察前面的代码，它看起来与我们的单向链表实现完全相同。唯一的区别是我们不检查列表的末尾，而是确保当前节点与第一个节点不同。此外，在以下行中，我们将新创建的节点的下一个引用分配给列表的第一个节点：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As we are implementing this, the new nodes are added to the back of the list.
    All we need to do is set the new node''s next reference to our first node in the
    list. By doing so, we have actually created a circular linked list. We have to
    make sure that we do not run- in an infinite loop. That is why we are comparing
    `$currentNode->next` to `$this->_firstNode` . The same principle will apply when
    we are displaying all elements in the circular linked list. We need to ensure
    that we do not fall in an infinite loop while displaying the titles. Here is the
    code that will display all titles from a circular linked list:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现这一点的过程中，新节点被添加到列表的末尾。我们所需要做的就是将新节点的下一个引用设置为列表中的第一个节点。通过这样做，我们实际上创建了一个循环链表。我们必须确保不会陷入无限循环。这就是为什么我们要比较`$currentNode->next`和`$this->_firstNode`。当我们显示循环链表中的所有元素时，同样的原则也适用。我们需要确保在显示标题时不会陷入无限循环。以下是显示循环链表中所有标题的代码：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: So far, we have built a singly linked list and implemented a circular linked
    list. Now, we will implement a doubly linked list with PHP.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了一个单向链表并实现了一个循环链表。现在，我们将使用PHP实现一个双向链表。
- en: Implementing a doubly linked list in PHP
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PHP中实现双向链表
- en: 'We already know from the definition of a doubly linked list that a doubly linked
    list node will have two links: one to point to the next node and another to point
    to the previous node. Also, when we add a new node or delete a new node, we need
    to set both the next and previous references for each affected nodes. We saw a
    different approach in the singly linked list implementation where we did not track
    the last node, and as a result, we had to use an iterator to reach the last node
    each time. This time, we will track the last node, along with our insert and delete
    operations, to make sure our insert, and delete, and end operations have `O(1)`
    complexity.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从双向链表的定义中知道，双向链表节点将有两个链接：一个指向下一个节点，另一个指向前一个节点。此外，当我们添加新节点或删除新节点时，我们需要为每个受影响的节点设置下一个和上一个引用。我们在单向链表实现中看到了一种不同的方法，我们没有跟踪最后一个节点，因此，我们每次都必须使用迭代器来到达最后一个节点。这一次，我们将跟踪最后一个节点，以及我们的插入和删除操作，以确保我们的插入、删除和结束操作具有`O(1)`复杂度。
- en: 'Here is how the new node class will look with two link pointers followed by
    our barebones structure of a doubly linked list class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是新节点类的外观，具有两个链接指针，后面是我们双向链表类的基本结构：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the next section, we will explore the different operations of a doubly linked
    list so that we understand the basic difference between a singly linked list and
    a doubly linked list.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨双向链表的不同操作，以便我们了解单向链表和双向链表之间的基本区别。
- en: Doubly linked list operations
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表操作
- en: 'We will explore the following operations in our doubly linked list implementation.
    Though they sound similar to those used in singly linked lists, they have a major
    difference in their implementations:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在双向链表实现中探讨以下操作。虽然它们听起来与单向链表中使用的操作类似，但它们在实现上有一个重大区别：
- en: Inserting at the first node
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个节点插入
- en: Inserting at the last node
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最后一个节点插入
- en: Inserting before a specific node
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定节点之前插入
- en: Inserting after a specific node
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定节点之后插入
- en: Deleting the first node
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除第一个节点
- en: Deleting the last node
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除最后一个节点
- en: Searching for and deleting one node
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索并删除一个节点
- en: Displaying the list forward
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向前显示列表
- en: Displaying the list backward
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向后显示列表
- en: Inserting at first the node
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先插入节点
- en: 'When we add a node at the front or head, we have to check whether the list
    is empty or not. If the list is empty, both the first and last node will point
    to the newly created node. However, if the list already has a head, then we have
    to do the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在前面或头部添加节点时，我们必须检查列表是否为空。如果列表为空，则第一个和最后一个节点将指向新创建的节点。但是，如果列表已经有一个头，则我们必须执行以下操作：
- en: Create the new node.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新节点。
- en: Make the new node as the first node or head.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新节点作为第一个节点或头。
- en: Assign the previous head or first node as the next, to follow the newly created
    first node.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前一个头或第一个节点作为下一个，以跟随新创建的第一个节点。
- en: Assign the previous first node's previous link to the new first node.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前一个第一个节点的前链接指向新的第一个节点。
- en: 'Here is the code for that:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Inserting at the last node
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在最后一个节点插入
- en: 'Since we are now tracking the last node, it will be easier to insert a new
    node at the end. First, we need to check that the list is not empty. If it is
    empty, then the new node becomes both the first and last node. However, if the
    list already has a last node, then we have to do the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在正在跟踪最后一个节点，因此在末尾插入新节点将更容易。首先，我们需要检查列表是否为空。如果为空，则新节点成为第一个和最后一个节点。但是，如果列表已经有最后一个节点，那么我们必须执行以下操作：
- en: Create the new node.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新节点。
- en: Make the new node the last node.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新节点作为最后一个节点。
- en: Assign the previous last node as the previous link of the current last node.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前一个最后一个节点作为当前最后一个节点的前链接。
- en: Assign the previous last node's next link to the new last node's previous link.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前一个最后一个节点的下一个链接指向新的最后一个节点的前链接。
- en: 'Here is the code for that:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Inserting before a specific node
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在特定节点之前插入
- en: 'Inserting before a specific node requires us to find the node first, and based
    on its position, we need to change the next and previous nodes for the new node,
    the target node, and the node before the target node, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定节点之前插入需要我们先找到节点，然后根据其位置，我们需要改变新节点、目标节点和目标节点之前的节点的下一个和上一个节点，如下所示：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Inserting after a specific node
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在特定节点之后插入
- en: 'Inserting after a specific node is similar to the method we just discussed.
    Here, we need to change the next and previous nodes for the new node, the target
    node, and the node following the target node. Here is the code for that:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定节点之后插入类似于我们刚刚讨论的方法。在这里，我们需要改变新节点、目标节点和目标节点后面的节点的下一个和上一个节点。以下是代码：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Deleting the first node
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除第一个节点
- en: 'When we remove the first node from a doubly linked list, we just need to make
    the second node the first node. Set the new first node''s previous node to `NULL`
    and reduce the total node count, just like the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从双向链表中删除第一个节点时，我们只需要将第二个节点设置为第一个节点。将新的第一个节点的前一个节点设置为`NULL`，并减少总节点数，就像以下代码一样：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Deleting the last node
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除最后一个节点
- en: 'Deleting the last node requires us to set a second to last node as the new
    last node. Also, the newly created last node should not have any next reference.
    The code sample is shown here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 删除最后一个节点需要我们将倒数第二个节点设置为新的最后一个节点。此外，新创建的最后一个节点不应该有任何下一个引用。代码示例如下：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Searching for and deleting one node
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索并删除一个节点
- en: 'When we are deleting a node from the middle of the list, we have to readjust
    the previous and the following node of the item we are looking for. First, we
    will find the intended node. Get the previous node of the target node, along with
    the next node. Then, assign the node following the previous node to point to the
    next node after the target node, and the same applies for the previous node in
    a reverse manner. Here is the code for that:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从列表中间删除一个节点时，我们必须重新调整目标节点的前一个节点和后一个节点。首先，我们会找到目标节点。获取目标节点的前一个节点以及下一个节点。然后，将前一个节点后面的节点指向目标节点后面的节点，前一个节点同样也是如此。以下是代码：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Displaying the list forward
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示列表向前
- en: 'Doubly linked lists gives us the opportunity to display the list in both directions.
    So far, we have seen that we can display the list in a unidirectional way while
    working in a singly linked list. Now, we will see the list from both directions.
    Here is the code used to display the list forward:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表使我们有机会以两个方向显示列表。到目前为止，我们已经看到在单向链表中工作时可以以单向方式显示列表。现在，我们将从两个方向查看列表。以下是用于显示列表向前的代码：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Displaying the list backward
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示列表向后
- en: 'To display the list backward, we have to start from the last node and continue
    to move backward using the previous link until we reach the end of the list. This
    gives us a unique way of moving in any direction we need during operations. Here
    is the code for that:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示列表向后，我们必须从最后一个节点开始，继续使用前一个链接向后移动，直到到达列表的末尾。这为我们在操作期间以任何方向移动提供了一种独特的方式。以下是代码：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Complexity for doubly linked lists
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表的复杂性
- en: 'Here is the best, worst, and average-case complexity for doubly linked list
    operations. It is similar to that of singly linked list operations:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是双向链表操作的最佳、最坏和平均情况复杂性。与单向链表操作类似：
- en: '| **Operation** | **Time Complexity: Worst Case** | **Time Complexity: Average
    Case** |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **时间复杂度：最坏情况** | **时间复杂度：平均情况** |'
- en: '| Insert at beginning or end | `O(1)` | `O(1)` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 在开头或结尾插入 | `O(1)` | `O(1)` |'
- en: '| Delete at beginning or end | `O(1)` | `O(1)` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 删除开头或结尾 | `O(1)` | `O(1)` |'
- en: '| Search | `O(n)` | `O(n)` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 搜索 | `O(n)` | `O(n)` |'
- en: '| Access | `O(n)` | `O(n)` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 访问 | `O(n)` | `O(n)` |'
- en: Using PHP SplDoublyLinkedList
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP SplDoublyLinkedList
- en: 'The PHP **Standard PHP Library** (**SPL** ) has an implementation of a doubly
    linked list, which is known as `SplDoublyLinkedList` . If we are using the built-in
    class, we do not need to implement the doubly linked list ourselves. The doubly
    linked list implementation actually works as a stack and queue as well. The PHP
    implementation of the doubly linked list has lots of additional functionalities.
    Here are some of the common features of `SplDoublyLinkedList` :'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: PHP **标准PHP库**（**SPL**）有一个双向链表的实现，称为`SplDoublyLinkedList`。如果我们使用内置类，就不需要自己实现双向链表。双向链表的实现实际上也可以作为堆栈和队列。PHP实现的双向链表有许多额外的功能。以下是`SplDoublyLinkedList`的一些常见特性：
- en: '| **Method** | **Description** |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Add` | Adds a new node in a specified index |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `Add` | 在指定索引处添加一个新节点 |'
- en: '| `Bottom` | Peeks a node from beginning of the list |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `Bottom` | 从列表开头窥视一个节点 |'
- en: '| `Count` | Returns the size of the list |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `Count` | 返回列表的大小 |'
- en: '| `Current` | Returns the current node |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `Current` | 返回当前节点 |'
- en: '| `getIteratorMode` | Returns the mode of iteration |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `getIteratorMode` | 返回迭代模式 |'
- en: '| `setIteratorMode` | Sets the mode of iteration. For example, LIFO, FIFO,
    and so on |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `setIteratorMode` | 设置迭代模式。例如，LIFO，FIFO等 |'
- en: '| `Key` | Returns the current node index |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `Key` | 返回当前节点索引 |'
- en: '| `next` | Moves to the next node |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `next` | 移动到下一个节点 |'
- en: '| `pop` | Pops a node from the end of the list |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `pop` | 从列表末尾弹出一个节点 |'
- en: '| `prev` | Moves to the previous node |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `prev` | 移动到前一个节点 |'
- en: '| `push` | Adds a new node at the end of the list |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `push` | 在列表末尾添加一个新节点 |'
- en: '| `rewind` | Rewinds the iterator back to the top |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `rewind` | 将迭代器倒回顶部 |'
- en: '| `shift` | Shifts a node from the beginning of the linked list |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `shift` | 从链表开头移除一个节点 |'
- en: '| `top` | Peeks a node from the end of the list |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `top` | 从列表末尾窥视一个节点 |'
- en: '| `unshift` | Prepends an element in the list |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `unshift` | 在列表中添加一个元素 |'
- en: '| `valid` | Checks whether there are any more nodes in the list |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `valid` | 检查列表中是否还有节点 |'
- en: 'Now, let''s write a small program using `SplDoublyLinkedList` for our book
    titles applications:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`SplDoublyLinkedList`为我们的书名应用程序编写一个小程序：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding code will have the following output:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将产生以下输出：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The linked list is one of the most popular data structures that are used to
    solve different problems. Whether it's regarding for a stack, queue, priority
    queue, or for implementing complex graph algorithms, the linked list is a very
    handy data structure to solve any problems you might find. In this chapter, we
    explored all possible details regarding the singly linked list, doubly linked
    list, and circular linked list, along with their complexity analysis. In the upcoming
    chapters, we will utilize linked lists to implement different data structures
    and writing algorithms.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 链表是最流行的数据结构之一，用于解决不同的问题。无论是关于堆栈、队列、优先队列，还是实现复杂的图算法，链表都是一个非常方便的数据结构，可以解决你可能遇到的任何问题。在本章中，我们探讨了关于单向链表、双向链表和循环链表的所有可能细节，以及它们的复杂性分析。在接下来的章节中，我们将利用链表来实现不同的数据结构和编写算法。
