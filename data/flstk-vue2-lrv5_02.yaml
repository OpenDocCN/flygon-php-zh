- en: Prototyping Vuebnb, Your First Vue.js Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vuebnb原型，您的第一个Vue.js项目
- en: In this chapter, we will learn the basic features of Vue.js. We'll then put
    this knowledge into practice by building a prototype of the case-study project,
    Vuebnb.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Vue.js的基本特性。然后，我们将把这些知识付诸实践，通过构建Vuebnb的案例研究项目原型。
- en: 'Topics this chapter covers:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题：
- en: Installation and basic configuration of Vue.js
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue.js的安装和基本配置
- en: Vue.js essential concepts, such as data binding, directives, watchers and lifecycle
    hooks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue.js的基本概念，如数据绑定、指令、观察者和生命周期钩子
- en: How Vue's reactivity system works
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue的响应系统是如何工作的
- en: Project requirements for the case-study project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究项目的项目要求
- en: Using Vue.js to add page content including dynamic text, lists, and a header
    image
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vue.js添加页面内容，包括动态文本、列表和页眉图像
- en: Building an image modal UI feature with Vue
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vue构建图像模态UI功能
- en: Vuebnb prototype
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vuebnb原型
- en: 'In this chapter, we''ll be building a prototype of Vuebnb, the case-study project
    that runs for the duration of this book. The prototype will just be of the listing
    page, and by the end of the chapter will look like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建Vuebnb的原型，这是本书持续运行的案例研究项目。原型将只是列表页面，到本章结束时将会是这样的：
- en: '![](assets/9596f4dc-9623-43d0-8f51-f6ab7f04aa46.png)Figure 2.1\. Vuebnb prototype'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/9596f4dc-9623-43d0-8f51-f6ab7f04aa46.png)图2.1 Vuebnb原型'
- en: Once we've set up our backend in [Chapter 3](e50310e5-b580-47d0-aff6-015808cc3b1c.xhtml),
    *Setting Up a Laravel Development Environment*, and [Chapter 4](86698fb7-c4c0-4a6e-831d-4b8cdde3a4b8.xhtml),
    *Building a Web Service with Laravel*, we'll migrate this prototype into the main
    project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在[第3章](e50310e5-b580-47d0-aff6-015808cc3b1c.xhtml) *设置Laravel开发环境*和[第4章](86698fb7-c4c0-4a6e-831d-4b8cdde3a4b8.xhtml)
    *使用Laravel构建Web服务*中设置好了我们的后端，我们将把这个原型迁移到主项目中。
- en: Project code
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目代码
- en: Before we begin, you'll need to download the code base to your computer by cloning
    it from GitHub. Instructions are given in the section *Code base* in [Chapter
    1](29c092e4-bc60-42f4-892f-fb74440d3765.xhtml), *Hello Vue - An Introduction to
    Vue.js*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，您需要通过从GitHub克隆代码库将其下载到您的计算机上。在[第1章](29c092e4-bc60-42f4-892f-fb74440d3765.xhtml)的*代码库*部分中给出了说明，*你好Vue
    - Vue.js简介*。
- en: 'The folder `vuebnb-prototype` has the project code for the prototype we''ll
    now be building. Change into that folder and list the contents:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuebnb-prototype`文件夹中包含了我们将要构建的原型的项目代码。切换到该文件夹并列出其中的内容：'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The folder contents should look like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹内容应该如下所示：
- en: '![](assets/da98e41f-aca7-4d8c-9f95-07ea87433c5a.png)Figure 2.2\. vuebnb-prototype
    project filesUnless otherwise specified, all further Terminal commands in this
    chapter will assume you''re in the `vuebnb-prototype` folder.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/da98e41f-aca7-4d8c-9f95-07ea87433c5a.png)图2.2 vuebnb-prototype项目文件除非另有说明，本章中所有后续的终端命令都假定您在`vuebnb-prototype`文件夹中。'
- en: NPM install
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPM安装
- en: 'You''ll now need to install the third-party scripts used in this project, including
    Vue.js itself. The NPM `install` method will read the included `package.json` file
    and download the required modules:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在需要安装此项目中使用的第三方脚本，包括Vue.js本身。NPM `install`方法将读取包含的`package.json`文件并下载所需的模块：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You'll now see a new  `node_modules` directory has appeared in your project
    folder.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在会看到您的项目文件夹中出现了一个新的`node_modules`目录。
- en: Main files
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要文件
- en: Open the `vuebnb-prototype`directory in your IDE. Note that the following `index.html`file
    is included. It's mostly comprised of boilerplate code, but also has some structural
    markup included in the `body` tag.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDE中打开`vuebnb-prototype`目录。请注意，包含了以下`index.html`文件。它主要由样板代码组成，但也包括一些结构标记在`body`标签中。
- en: Also note that this file links to `style.css`, where our CSS rules will be added,
    and `app.js`, where our JavaScript will be added.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，该文件链接到`style.css`，我们的CSS规则将被添加在那里，以及`app.js`，我们的JavaScript将被添加在那里。
- en: '`index.html`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Currently `app.js` is an empty file, but I have included some CSS rules in `style.css` to
    get us started.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 目前`app.js`是一个空文件，但我已经在`style.css`中包含了一些CSS规则来帮助我们入门。
- en: '`style.css`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`style.css`：'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Opening in the browser
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中打开
- en: To view the project, locate the `index.html`file in your web browser. In Chrome,
    it's as simple as File *| Open File*. When it loads, you'll see a page that is
    mostly empty, other than the toolbar at the top.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看项目，请在Web浏览器中找到`index.html`文件。在Chrome中，只需点击文件*| 打开文件*。加载完成后，您将看到一个大部分为空白的页面，除了顶部的工具栏。
- en: Installing Vue.js
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Vue.js
- en: Now it's time to add the `Vue.js` library to our project. Vue was downloaded
    as part of our NPM install, so now we can simply link to the browser-build of
    `Vue.js` with a `script` tag.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将`Vue.js`库添加到我们的项目中了。Vue已作为我们的NPM安装的一部分下载，所以现在我们可以简单地使用`script`标签链接到`Vue.js`的浏览器构建版本。
- en: '`index.html`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's important that we include the Vue library *before* our own custom `app.js` script,
    as scripts run sequentially.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们自定义的`app.js`脚本之前，包含Vue库是很重要的，因为脚本是按顺序运行的。
- en: 'Vue will now be registered as a global object. We can test this by going to
    our browser and typing the following in the JavaScript console:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Vue现在将被注册为全局对象。我们可以通过转到浏览器并在JavaScript控制台中输入以下内容来测试：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is the result:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '![](assets/25755703-7819-4ee5-b148-6b33180bb963.png)Figure 2.3\. Checking Vue
    is registered as a global object'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/25755703-7819-4ee5-b148-6b33180bb963.png)图2.3 检查Vue是否注册为全局对象'
- en: Page content
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面内容
- en: With our environment set up and starter code installed, we're now ready to take
    the first steps in building the Vuebnb prototype.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的环境设置好并安装好了起始代码后，我们现在已经准备好开始构建Vuebnb原型的第一步了。
- en: Let's add some content to the page, including the header image, the title, and
    the About section. We'll be adding structure to our HTML file and using `Vue.js`
    to insert the correct content where we need it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向页面添加一些内容，包括页眉图像、标题和*关于*部分。我们将在我们的HTML文件中添加结构，并使用`Vue.js`在需要时插入正确的内容。
- en: The Vue instance
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue实例
- en: Looking at our `app.js` file, let's now create our root instance of Vue.js by
    using the `new` operator with the `Vue` object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的`app.js`文件，现在让我们通过使用`Vue`对象的`new`运算符来创建Vue.js的根实例。
- en: '`app.js`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`：'
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you create a `Vue` instance, you will usually want to pass in a configuration
    object as an argument. This object is where your project's custom data and functions
    are defined.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个`Vue`实例时，通常会希望将一个配置对象作为参数传递进去。这个对象是定义项目的自定义数据和函数的地方。
- en: '`app.js`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`：'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As our project progresses, we'll be adding much more to this configuration object,
    but for now we've just added the `el` property that tells Vue where to mount itself
    in the page.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的项目的进展，我们将在这个配置对象中添加更多内容，但现在我们只是添加了`el`属性，告诉Vue在页面中的哪里挂载自己。
- en: You can assign to it a string (a CSS selector) or an HTML node object. In our
    case, we've used the `#app` string, which is a CSS selector referring to the element
    with the `app` ID.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其分配为一个字符串（CSS选择器）或HTML节点对象。在我们的例子中，我们使用了`#app`字符串，它是一个CSS选择器，指的是具有`app`ID的元素。
- en: '`index.html`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Vue has dominion over the element it mounts on and any child node. For our project
    so far, Vue could manipulate the `div` with the `header` class, but it could not
    manipulate the `div` with the `toolbar`ID. Anything placed within this latter `div`
    will be invisible to Vue.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/b44d2a8b-d651-4e4c-8f99-85ee662df265.png)图2.5。包含模拟列表示例的页面'
- en: '`index.html`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From now on, we'll refer to our mount node and its children as our template.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将把我们的挂载节点及其子节点称为我们的模板。
- en: Data binding
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定
- en: A simple task for Vue is to bind some JavaScript data to the template. Let's
    create a `data` property in our configuration object and assign to it an object
    including a `title` property with a `'My apartment'` string value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Vue的一个简单任务是将一些JavaScript数据绑定到模板上。让我们在配置对象中创建一个`data`属性，并为其分配一个包含`title`属性和`'My
    apartment'`字符串值的对象。
- en: '`app.js`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`：'
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Any property of this `data` object will be available within our template. To
    tell Vue where to bind this data, we can use *mustache* syntax, that is, double
    curly brackets, for example, `{{ myProperty }}`. When Vue instantiates, it compiles
    the template, replaces the mustache syntax with the appropriate text, and updates
    the DOM to reflect this. This process is called *text interpolation* and is demonstrated
    in the following code block.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`data`对象的任何属性都将在我们的模板中可用。为了告诉Vue在哪里绑定这些数据，我们可以使用*mustache*语法，也就是双花括号，例如，`{{
    myProperty }}`。当Vue实例化时，它会编译模板，用适当的文本替换mustache语法，并更新DOM以反映这一点。这个过程被称为*文本插值*，并在下面的代码块中进行了演示。
- en: '`index.html`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Will render as this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将呈现为：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's add a few more data properties now and enhance our template to include
    more of the page structure.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一些更多的数据属性，并增强我们的模板以包含更多的页面结构。
- en: '`app.js`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`：'
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`index.html`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's also add some new CSS rules.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也添加一些新的CSS规则。
- en: '`style.css`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`style.css`：'
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you now save and refresh your page, it should look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在保存并刷新你的页面，它应该看起来像这样：
- en: '![](assets/bbb14c0f-4e35-413a-8b62-2250d8786bec.png)Figure 2.4\. Listing page
    with basic data binding'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/bbb14c0f-4e35-413a-8b62-2250d8786bec.png)图2.4。带有基本数据绑定的列表页面'
- en: Mock listing
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟列表
- en: While we're developing, it'd be nice to work with some mock data so that we
    can see how our completed page will look. I've included `sample/data.js` in the
    project for this very reason. Let's load it in our document, making sure it goes
    above our `app.js` file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发时，最好使用一些模拟数据，这样我们就可以看到我们完成的页面将会是什么样子。我已经在项目中包含了`sample/data.js`，就是为了这个原因。让我们在我们的文档中加载它，确保它在我们的`app.js`文件之上。
- en: '`index.html`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Have a look at the file and you'll see that it declares a `sample` object. We
    will now utilize it in our data configuration.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下文件，你会看到它声明了一个`sample`对象。我们现在将在我们的数据配置中利用它。
- en: '`app.js`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`：'
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once you save and refresh, you''ll see more realistic data on the page:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你保存并刷新，你会在页面上看到更真实的数据：
- en: '![](assets/b44d2a8b-d651-4e4c-8f99-85ee662df265.png)Figure 2.5\. Page including
    mock-listing sampleUsing global variables split over different script files in
    this way is not an ideal practice. We''ll only be doing this in the prototype,
    though, and later we''ll get this mock-listing sample from the server.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方式中使用分布在不同脚本文件中的全局变量并不是一种理想的做法。不过，我们只会在原型中这样做，稍后我们将从服务器获取这个模拟列表示例。
- en: Header image
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页眉图像
- en: No room listing would be complete without a big, glossy image to show it off.
    We've got a header image in our mock listing that we'll now include. Add this
    markup to the page.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一个房间列表会完整而没有一个大而光滑的图片来展示它。我们的模拟列表中有一个页眉图像，现在我们将其包含进来。将这个标记添加到页面中。
- en: '`index.html`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Vue对其挂载的元素和任何子节点都具有支配权。到目前为止，对于我们的项目，Vue可以操作具有`header`类的`div`，但无法操作具有`toolbar`ID的`div`。放置在后者`div`中的任何内容对Vue来说都是不可见的。
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And this to the CSS file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其添加到CSS文件中。
- en: '`style.css`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`style.css`：'
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You may be wondering why we're using a `div` rather than an `img` tag. To help
    with positioning, we're going to set our image as the background of the `div` with
    the `header-img` class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么我们使用`div`而不是`img`标签。为了帮助定位，我们将把我们的图像设置为具有`header-img`类的`div`的背景。
- en: Style binding
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式绑定
- en: 'To set a background image, we must provide the URL as a property in a CSS rule
    like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置背景图像，我们必须在CSS规则中提供URL作为属性，就像这样：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Obviously, our header image should be specific to each individual listing, so
    we don't want to hard code this CSS rule. Instead, we can have Vue bind the URL
    from data to our template.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们的页眉图像应该针对每个单独的列表进行特定设置，所以我们不想硬编码这个CSS规则。相反，我们可以让Vue将数据中的URL绑定到我们的模板上。
- en: 'Vue can''t access our CSS style sheet, but it can bind to an inline `style` attribute:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Vue无法访问我们的CSS样式表，但它可以绑定到内联`style`属性：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You may think using a text interpolation is the solution here, for example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为在这里使用文本插值是解决方案，例如：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: But this is not valid Vue.js syntax. This is, instead, a job for another Vue.js
    feature called a `directive`. Let's explore directives first and then come back
    to solving this problem.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不是有效的Vue.js语法。相反，这是另一个Vue.js功能称为`指令`的工作。让我们先探索指令，然后再来解决这个问题。
- en: Directives
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令
- en: 'Vue''s directives are special HTML attributes with the *v-* prefix, for example, `v-if`,
    which provide a simple way to add functionality to our templates. Some examples
    of directives you can add to an element are:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Vue的指令是带有*v-*前缀的特殊HTML属性，例如`v-if`，它提供了一种简单的方法来为我们的模板添加功能。您可以为元素添加的一些指令的示例包括：
- en: '`v-if`: Conditionally render the element'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v-if`：有条件地渲染元素'
- en: '`v-for`: Render the element multiple times based on an array or object'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v-for`：基于数组或对象多次渲染元素'
- en: '`v-bind`: Dynamically bind an attribute of the element to a JavaScript expression'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v-bind`：将元素的属性动态绑定到JavaScript表达式'
- en: '`v-on`: Attach an event listener to the element'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v-on`：将事件监听器附加到元素'
- en: There are more that we will explore throughout the book.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将探索更多内容。
- en: Usage
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用法
- en: 'Just like normal HTML attributes, directives are usually name/value pairs in
    the form `name="value"`. To use a directive, simply add it to an HTML tag as you
    would an attribute, for example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 就像普通的HTML属性一样，指令通常是形式为`name="value"`的名称/值对。要使用指令，只需将其添加到HTML标记中，就像添加属性一样，例如：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Expressions
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: If a directive requires a value, it will be an *expression*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指令需要一个值，它将是一个*表达式*。
- en: 'In the JavaScript language, expressions are small, evaluable statements that
    produce a single value. Expressions can be used wherever a value is expected,
    for example in the parenthesis of an `if` statement:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript语言中，表达式是小的、可评估的语句，产生单个值。表达式可以在期望值的任何地方使用，例如在`if`语句的括号中：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The expression here could be any of the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的表达式可以是以下任何一种：
- en: A mathematical expression, for example `x + 7`
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学表达式，例如`x + 7`
- en: A comparison, for example `v <= 7`
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较，例如`v <= 7`
- en: A Vue `data` property, for example `this.myval`
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如Vue的`data`属性，例如`this.myval`
- en: 'Directives and text interpolations both accept expression values:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 指令和文本插值都接受表达式值：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Example: v-if'
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例：v-if
- en: '`v-if` will conditionally render an element if its value is a *truthy* expression.
    In the following case, `v-if` will remove/insert the `p` element depending on
    the `myval` value:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-if`将根据其值是否为*真*表达式有条件地渲染元素。在下面的情况下，`v-if`将根据`myval`的值删除/插入`p`元素：'
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Will renders as:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将呈现为：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we add a consecutive element with the `v-else` directive (a special directive
    that requires no value), it will be symmetrically removed/inserted as `myval` changes:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加一个带有`v-else`指令的连续元素（一个不需要值的特殊指令），它将在`myval`更改时对称地删除/插入：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Arguments
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数
- en: 'Some directives take an *argument*, denoted by a colon after the directive
    name. For example, the `v-on` directive, which listens to DOM events, requires
    an argument to specify which event should be listened to:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一些指令需要一个*参数*，在指令名称后面加上冒号表示。例如，`v-on`指令监听DOM事件，需要一个参数来指定应该监听哪个事件：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Instead of `click`, the argument could be `mouseenter`, `keypress`, `scroll`, or
    any other event (including custom events).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 参数不一定是`click`，也可以是`mouseenter`，`keypress`，`scroll`或任何其他事件（包括自定义事件）。
- en: Style binding (continued)
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式绑定（续）
- en: Coming back to our header image, we can use the `v-bind` directive with the `style` argument to
    bind a value to the `style` attribute.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的页眉图像，我们可以使用`v-bind`指令和`style`参数将值绑定到`style`属性。
- en: '`index.html`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`headerImageStyle` is an expression that evaluates to a CSS rule that sets
    the background image to the correct URL. It sounds very confusing, but when you
    see it working, it will be quite clear.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`headerImageStyle`是一个表达式，它评估为设置背景图像到正确URL的CSS规则。听起来很混乱，但当你看到它工作时，就会很清楚。'
- en: Let's now create `headerImageStyle`as a data property. When binding to a style
    attribute, you can use an object where the properties and values are equivalent
    to the CSS properties and values.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建`headerImageStyle`作为数据属性。当绑定到样式属性时，可以使用一个对象，其中属性和值等同于CSS属性和值。
- en: '`app.js`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`：'
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Save the code, refresh the page, and the header image will be shown:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 保存代码，刷新页面，页眉图像将显示：
- en: '![](assets/6601a188-3ce0-4e1e-8b6e-7480bb40e6ff.png)Figure 2.6\. Page including
    header image'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6601a188-3ce0-4e1e-8b6e-7480bb40e6ff.png)图2.6。包括页眉图像的页面'
- en: 'Inspect the page with your browser Dev Tools and notice how the `v-bind` directive
    has evaluated:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器开发工具检查页面，并注意`v-bind`指令的评估方式：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Lists section
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表部分
- en: 'The next bit of content we''ll add to our page is the Amenities and Prices lists:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加到页面的下一部分是`Amenities`和`Prices`列表：
- en: '![](assets/2b06075a-4384-4cc7-88c9-ce8d3e540bd0.png)Figure 2.7\. Lists section'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2b06075a-4384-4cc7-88c9-ce8d3e540bd0.png)图2.7。列表部分'
- en: If you look at the mock-listing sample, you'll see that the `amenities` and `prices` properties
    on the object are both arrays.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看模拟列表示例，您会看到对象上的`amenities`和`prices`属性都是数组。
- en: '`sample/data.js`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample/data.js`：'
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Wouldn't it be easy if we could just loop over these arrays and print each item
    to the page? We can! This is what the `v-for` directive does.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以轻松地遍历这些数组并将每个项目打印到页面上，那不是很容易吗？我们可以！这就是`v-for`指令的作用。
- en: First, let's add these as data properties on our root instance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将这些添加为根实例上的数据属性。
- en: '`app.js`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`：'
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: List rendering
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表渲染
- en: The `v-for` directive requires a special type of expression in the form of `item
    in items`, where `items` is the source array, and `item` is an alias for the current
    array element being looped over.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-for`指令需要一种特殊类型的表达式，形式为`item in items`，其中`items`是源数组，`item`是当前正在循环的数组元素的别名。'
- en: 'Let''s work on the `amenities` array first. Each member of this array is an
    object with a `title` and `icon` property, that is:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先处理`amenities`数组。该数组的每个成员都是一个具有`title`和`icon`属性的对象，即：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We'll add the `v-for` directive into the template and the expression we assign
    to it will be `amenity in amenities`. The alias part of the expression, that is
    `amenity`, will refer, throughout the loop sequence, to each object in the array,
    starting with the first.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在模板中添加`v-for`指令，并将其分配的表达式设置为`amenity in amenities`。表达式的别名部分，即`amenity`，将在整个循环序列中引用数组中的每个对象，从第一个开始。
- en: '`index.html`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It will render as:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 它将呈现为：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Icons
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图标
- en: The second property of our amenity objects is `icon`. This is actually a class
    relating to an icon in the Font Awesome icon font. We've installed Font Awesome
    as an NPM module already, so add this to the head of the page to now use it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设施对象的第二个属性是`icon`。这实际上是与Font Awesome图标字体中的图标相关的类。我们已经安装了Font Awesome作为NPM模块，因此现在可以将其添加到页面的头部以使用它。
- en: '`index.html`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now we can complete the structure of our amenities section in the template.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在模板中完成我们的设施部分的结构。
- en: '`index.html`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`style.css`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`style.css`：'
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Key
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键
- en: As you might expect, the DOM nodes generated by `v-for="amenity in amenities"` are
    reactively bound to the `amenities` array. If the content of `amenities` changes,
    Vue will automatically re-render the nodes to reflect the change.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的那样，由`v-for="amenity in amenities"`生成的DOM节点与`amenities`数组具有响应性绑定。如果`amenities`的内容发生变化，Vue将自动重新渲染节点以反映更改。
- en: When using `v-for`, it's recommended you provide a unique `key` property to
    each item in the list. This allows Vue to target the exact DOM nodes that need
    to be changed, making DOM updates more efficient.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`v-for`时，建议为列表中的每个项目提供一个唯一的`key`属性。这使得Vue能够定位需要更改的确切DOM节点，从而使DOM更新更有效率。
- en: 'Usually, the key would be a numeric ID, for example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，键将是一个数字ID，例如：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For the amenities and prices lists, the content is not going to change over
    the life of the app, so there's no need for us to provide a key. Some linters
    may warn you about this, but in this case, the warning can be safely ignored.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于设施和价格列表，内容在应用程序的生命周期内不会发生变化，因此我们不需要提供键。一些代码检查工具可能会警告您，但在这种情况下，可以安全地忽略警告。
- en: Prices
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 价格
- en: Let's now add the price list to our template as well.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们也将价格列表添加到我们的模板中。
- en: '`index.html`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: I'm sure you'll agree that looping a template is far easier than writing out
    every item. However, you may notice that there is still some common markup between
    these two lists. Later in the book we'll utilize components to make this part
    of the template even more modular.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信您会同意，循环模板比逐个项目编写要容易得多。但是，您可能会注意到这两个列表之间仍然存在一些常见的标记。在本书的后面，我们将利用组件使模板的这一部分更加模块化。
- en: Show more feature
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示更多功能
- en: We've run into a problem now that the lists section is after the About section.
    The About section has an arbitrary length, and in some of the mock listings that
    we'll add you'll see that this section is quite long.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们遇到了一个问题，即“列表”部分在“关于”部分之后。关于部分的长度是任意的，在我们将要添加的一些模拟列表中，您会看到这部分非常长。
- en: We don't want it to dominate the page and force the user to do a lot of unwelcome
    scrolling to see the lists section, so we need a way to hide some of the text
    if it's too long, yet allow the user to view the full text if they choose.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望它主导页面并迫使用户进行大量不受欢迎的滚动以查看“列表”部分，因此我们需要一种方法，如果文本太长，则隐藏一些文本，但允许用户选择查看完整文本。
- en: 'Let''s add a show more UI feature that will crop the About text after a certain
    length and give the user a button to reveal the hidden text:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个“显示更多”UI功能，它将在一定长度后裁剪“关于”文本，并为用户提供一个按钮来显示隐藏的文本：
- en: '![](assets/2097c214-5dcc-43d3-82d1-2d682fe49996.png)Figure 2.8. Show more feature'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2097c214-5dcc-43d3-82d1-2d682fe49996.png)图2.8. 显示更多功能'
- en: We'll start by adding a `contracted` class to the `p` tag that contains the `about` text
    interpolation. The CSS rule for this class will restrict its height to 250 pixels
    and hide any text overflowing the element.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先向包含“about”文本插值的`p`标签添加一个`contracted`类。此类的CSS规则将限制其高度为250像素，并隐藏溢出元素的任何文本。
- en: '`index.html`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`style.css`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`style.css`：'
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We'll also put a button after the `p` tag that the user can click to expand
    the section to full height.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在`p`标签之后放置一个按钮，用户可以单击该按钮将该部分展开到完整高度。
- en: '`index.html`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here's the CSS that's needed, including a generic button rule that will provide
    base styling for all buttons that we'll add throughout the project.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所需的CSS，包括一个通用按钮规则，该规则将为项目中将要添加的所有按钮提供基本样式。
- en: '`style.css`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`style.css`：'
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To make this work, we need a way to remove the `contracted` class when the user
    clicks the More button. Seems like a good job for directives!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，我们需要一种方法，在用户单击“更多”按钮时删除`contracted`类。看起来指令是一个很好的选择！
- en: Class binding
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类绑定
- en: How we'll approach this is to dynamically bind the `contracted` class. Let's
    create a `contracted` data property and set its initial value to `true`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取的方法是动态绑定`contracted`类。让我们创建一个`contracted`数据属性，并将其初始值设置为`true`。
- en: '`app.js`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`：'
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Like our style binding, we can bind this class to an object. In the expression,
    the `contracted` property is the name of the class to be bound, the `contracted` value is
    a reference to the data property of that same name, which is a Boolean. So if
    the `contracted` data property evaluates to `true`, that class will be bound to
    the element, and if it evaluates to `false`, it will not.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的样式绑定一样，我们可以将此类绑定到一个对象。在表达式中，`contracted`属性是要绑定的类的名称，`contracted`值是对同名数据属性的引用，它是一个布尔值。因此，如果`contracted`数据属性评估为`true`，那么该类将绑定到元素，如果评估为`false`，则不会绑定。
- en: '`index.html`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'It follows that when the page loads the `contracted` class is bound:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当页面加载时，`contracted`类被绑定：
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Event listener
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件监听器
- en: We now want to remove the `contracted` class automatically when the user clicks
    the More button. To do this job, we'll use the `v-on` directive, which listens
    to DOM events with a `click` argument.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望在用户单击“更多”按钮时自动删除`contracted`类。为了完成这项工作，我们将使用`v-on`指令，该指令使用`click`参数监听DOM事件。
- en: The value of the `v-on` directive can be an expression that assigns `contracted` to `false`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-on`指令的值可以是一个表达式，将`contracted`赋值为`false`。'
- en: '`index.html`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Reactivity
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应性
- en: When we click the More button, the `contracted` value changes and Vue will instantly
    update the page to reflect this change.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们单击“更多”按钮时，`contracted`值会发生变化，Vue将立即更新页面以反映此更改。
- en: How does Vue know to do this? To answer this question we must first understand
    the concept of getters and setters.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Vue是如何知道做到这一点的？要回答这个问题，我们必须首先了解getter和setter的概念。
- en: Getters and setters
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取器和设置器
- en: 'To assign a value to a property of a JavaScript object is as simple as:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为JavaScript对象的属性分配值就像这样简单：
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To retrieve it is just as simple:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索它就像这样简单：
- en: '[PRE52]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There's no trick here. The point I want to make though, is that we can replace
    this normal assignment/retrieval mechanism of an object through use of getters
    and setters. These are special functions that allow custom logic for getting or
    setting the property's value.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么诀窍。不过，我想要表达的是，我们可以通过使用getter和setter来替换对象的正常赋值/检索机制。这些是特殊函数，允许自定义逻辑来获取或设置属性的值。
- en: 'Getters and setters are especially useful when one property''s value is determined
    by another. Here''s an example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个属性的值由另一个属性确定时，getter和setter特别有用。这里有一个例子：
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `get` and `set` functions of the `fullName` property are invoked whenever
    we attempt a normal assignment/retrieval of its value:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试对`fullName`属性进行正常赋值/检索时，`fullName`属性的`get`和`set`函数将被调用：
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Reactive data properties
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式数据属性
- en: 'Another one of Vue''s initialization steps is to walk through all of the data
    properties and assign them getters and setters. If you look in the following screenshot,
    you can see how each property in our current app has a `get` and `set` function
    added to it:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Vue的另一个初始化步骤是遍历所有数据属性并为其分配getter和setter。如果您查看以下截图，您可以看到我们当前应用程序中的每个属性都添加了`get`和`set`函数：
- en: '![](assets/66c022e6-0030-4d84-a3ad-c05e38b395a6.png)Figure 2.9\. Getters and
    setters'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/66c022e6-0030-4d84-a3ad-c05e38b395a6.png)图2.9 获取器和设置器'
- en: Vue added these getters and setters to enable it to perform dependency tracking
    and change notification when the properties are accessed or modified. So, when
    the `contracted` value is changed by the `click` event, its `set` method is triggered.
    The `set` method will set the new value, but will also carry out a secondary task
    of informing Vue that a value has changed and any part of the page relying on
    it may need to be re-rendered.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Vue添加了这些getter和setter，以使其能够在访问或修改属性时执行依赖跟踪和更改通知。因此，当`contracted`值通过`click`事件更改时，将触发其`set`方法。`set`方法将设置新值，但也将执行通知Vue值已更改的次要任务，并且可能需要重新渲染依赖它的页面的任何部分。
- en: If you'd like to know more about Vue's reactivity system, check out the article *Reactivity
    In Vue.js (And Its Pitfalls)* at [https://vuejsdevelopers.com/2017/03/05/vue-js-reactivity/](https://vuejsdevelopers.com/2017/03/05/vue-js-reactivity/).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于Vue的响应系统的信息，请查看文章*Vue.js中的响应性（及其陷阱）*，网址为[https://vuejsdevelopers.com/2017/03/05/vue-js-reactivity/](https://vuejsdevelopers.com/2017/03/05/vue-js-reactivity/)。
- en: Hiding the More button
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏更多按钮
- en: Once the About section has been expanded, we want to hide the More button as
    it's no longer needed. We can use the `v-if` directive to achieve this in conjunction
    with the `contracted` property.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦“关于”部分被展开，我们希望隐藏“更多”按钮，因为它不再需要。我们可以使用`v-if`指令与`contracted`属性一起实现这一点。
- en: '`index.html`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Image modal window
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图片模态窗口
- en: To prevent our header image from dominating the page, we've cropped it and limited
    its height. But what if the user wants to see the image in its full glory? A great
    UI design pattern to allow the user to focus on a single item of content is a *modal
    window*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止我们的页眉图片占据页面，我们对其进行了裁剪并限制了其高度。但是，如果用户想要以全貌查看图片呢？允许用户专注于单个内容项的一个很好的UI设计模式是*模态窗口*。
- en: 'Here''s what our modal will look like when opened:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当打开时，我们的模态框将如下所示：
- en: '![](assets/2d1ce89f-6747-4219-9540-615a7a3f6d17.png)Figure 2.10\. Header image
    modal'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2d1ce89f-6747-4219-9540-615a7a3f6d17.png)图2.10 页眉图片模态'
- en: Our modal will give a properly scaled view of the header image so the user can
    focus on the appearance of the lodgings without the distraction of the rest of
    the page.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模态框将提供一个适当缩放的页眉图片视图，这样用户就可以专注于住宿的外观，而不会被页面的其他部分分散注意力。
- en: Later in the book, we will insert an image carousel into the modal so the user
    can browse through a whole collection of room images!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 书中稍后，我们将在模态框中插入一个图片轮播，这样用户就可以浏览整个房间图片集合！
- en: 'For now, though, here are the required features for our modal:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，现在我们的模态框需要以下功能：
- en: Open the modal by clicking the header image
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击页眉图片打开模态框
- en: Freeze the main window
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冻结主窗口
- en: Show the image
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示图片
- en: Close the modal window with a close button or the *Escape* key
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用关闭按钮或*Escape*键关闭模态窗口
- en: Opening
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开
- en: First, let's add a Boolean data property that will represent the opened or closed
    state of our modal. We'll initialize it to `false`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加一个布尔数据属性，表示我们模态框的打开或关闭状态。我们将其初始化为`false`。
- en: '`app.js`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`：'
- en: '[PRE56]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We'll make it so that clicking our header image will set the modal to open.
    We'll also overlay a button labelled View Photos in the bottom-left corner of
    the header image to give a stronger signal to the user that they should click
    to show the image.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使点击页眉图片打开模态框。我们还将在页眉图片的左下角叠加一个标有“查看照片”的按钮，以向用户发出更强烈的信号，告诉他们应该点击以显示图片。
- en: '`index.html`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that, by putting the click listener on the wrapping `div`, the click event
    will be captured regardless of whether the user clicks the `button` or the `div` due
    to DOM event propagation.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过将点击监听器放在包装`div`上，无论用户点击`button`还是`div`，都将捕获点击事件，这是由于DOM事件传播。
- en: We'll add some more CSS to our header image to make the cursor a *pointer*,
    letting the user know the header can be clicked, and giving the header a relative
    position so the button can be positioned within it. We'll also add rules to style
    the button.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为页眉图片添加一些CSS，使光标成为*指针*，让用户知道可以点击页眉，并为页眉添加相对位置，以便在其中定位按钮。我们还将添加样式规则来设计按钮。
- en: '`style.css`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`style.css`：'
- en: '[PRE58]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Let's now add the markup for our modal. I've put it after the other elements
    in the page, though it doesn't really matter as the modal will be out of the regular
    flow of the document. We remove it from the flow by giving it a `fixed` position
    in the following CSS.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为模态框添加标记。我把它放在页面的其他元素之后，尽管这并不重要，因为模态框将脱离文档的常规流程。我们通过在以下CSS中给它一个`fixed`位置来将其从流程中移除。
- en: '`index.html`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The main modal `div` will act as a container for the rest of the modal content,
    but also as a background panel that will cover up the main window content. To
    achieve this, we use CSS rules to stretch it to completely cover the viewport
    by giving it `top`, `right`, `bottom`, and `left` values of `0`. We'll set the `z-index` to
    a high number to ensure the modal is stacked in front of any other element in
    the page.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 主模态`div`将充当其余模态内容的容器，同时也是将覆盖主窗口内容的背景面板。为了实现这一点，我们使用CSS规则将其拉伸到完全覆盖视口，给它设置`top`、`right`、`bottom`和`left`值为`0`。我们将`z-index`设置为一个较高的数字，以确保模态框叠放在页面中的任何其他元素之前。
- en: Note also that the `display` is initially set to `none`, but we're dynamically
    binding a class to the modal called `show` that gives it block display. The addition/removal
    of this class will, of course, be bound to the value of `modalOpen`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`display`最初设置为`none`，但我们会动态地将一个名为`show`的类绑定到模态框，使其显示为块级元素。当然，添加/删除这个类将绑定到`modalOpen`的值。
- en: '`style.css`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`style.css`：'
- en: '[PRE60]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Window
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口
- en: Let's now add markup for the window that will be overlaid on our background
    panel. The window will have a width constraint and will be centered in the viewport.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为将覆盖在背景面板上的窗口添加标记。窗口将具有宽度约束，并将居中显示在视口中。
- en: '`index.html`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`style.css`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`style.css`：'
- en: '[PRE62]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Disabling the main window
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用主窗口
- en: 'When the modal is open, we want to prevent any interaction with the main window
    and also make a clear distinction between the main window and the child window.
    We can do this by:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当模态框打开时，我们希望防止与主窗口的任何交互，并且清楚地区分主窗口和子窗口。我们可以通过以下方式实现这一点：
- en: Dimming the main window
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调暗主窗口
- en: Preventing body scroll
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止body滚动
- en: Dimming the main window
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调暗主窗口
- en: We could simply hide our main window when the modal is open, but it's better
    if the user can still be aware of where they are in flow of the app. To achieve
    this, we will *dim* the main window under a semi-transparent panel.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当模态框打开时，我们可以简单地隐藏我们的主窗口，但是最好让用户仍然能够意识到他们在应用程序流程中的位置。为了实现这一点，我们将在半透明面板下*调暗*主窗口。
- en: We can do this by giving our modal panel an opaque black background.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过给我们的模态面板添加不透明的黑色背景来实现这一点。
- en: '`style.css`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`style.css`：'
- en: '[PRE63]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Preventing body scroll
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止body滚动
- en: We have a problem, though. Our modal panel, despite being full screen, is still
    a child of the `body` tag. This means we can still *scroll* the main window! We
    don't want users to interact with the main window in any way while the modal is
    open, so we must disable scrolling on the `body`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们有一个问题。尽管我们的模态面板是全屏的，但它仍然是`body`标签的子元素。这意味着我们仍然可以*滚动*主窗口！我们不希望用户在模态框打开时以任何方式与主窗口进行交互，因此我们必须禁用`body`上的滚动。
- en: The trick is to add the CSS `overflow` property to the `body` tag and set it
    to `hidden`. This has the effect of clipping any *overflow* (that is, part of
    the page not currently in view), and the rest of the content will be made invisible.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是向`body`标签添加CSS `overflow`属性，并将其设置为`hidden`。这样做的效果是裁剪任何*溢出*（即，当前不在视图中的页面的部分），其余内容将变为不可见。
- en: We'll need to dynamically add and remove this CSS rule, as we obviously want
    to be able to scroll through the page when the modal is closed. So, let's create
    a class called `modal-open` that we can apply to the `body` tag when the modal
    is open.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要动态添加和删除这个CSS规则，因为当模态框关闭时，我们显然希望能够滚动页面。因此，让我们创建一个名为`modal-open`的类，当模态框打开时，我们可以将其应用于`body`标签。
- en: '`style.css`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`style.css`：'
- en: '[PRE64]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can use `v-bind:class` to add/remove this class, right? Unfortunately, no.
    Remember that Vue only has dominion over the element where it is mounted:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`v-bind:class`来添加/删除这个类，对吗？不幸的是，不行。请记住，Vue只对它挂载的元素有控制权：
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If we add a directive to the `body` tag, it will *not* be seen by Vue.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向`body`标签添加指令，它将*不会*被Vue看到。
- en: Vue's mount element
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue的挂载元素
- en: 'What if we just mounted Vue on the `body` tag, wouldn''t that solve our problems?
    For example:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是在`body`标签上挂载Vue，那么这样做能解决我们的问题吗？例如：
- en: '[PRE66]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This is not permitted by Vue and if you attempt it you will get this error:
    Do not mount Vue to <html> or <body> - mount to normal elements instead.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Vue不允许这样做，如果您尝试这样做，您将收到此错误：不要将Vue挂载到<html>或<body> - 而是挂载到普通元素。
- en: Remember that Vue has to compile the template and replaces the mount node. If
    you have script tags as children of the mount node, as you often do with `body`,
    or if your user has browser plugins that modify the document (many do) then all
    sorts of hell might break loose on the page when it replaces that node.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Vue必须编译模板并替换挂载节点。如果您的脚本标签作为挂载节点的子元素存在（通常是`body`），或者如果您的用户有修改文档的浏览器插件（很多都有），那么当Vue替换该节点时，页面可能会出现各种问题。
- en: If you define your own root element with a unique ID, there should be no such
    conflict.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您定义了自己的具有唯一ID的根元素，则不应该出现这种冲突。
- en: Watchers
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者
- en: 'So, how can we add/remove classes from the `body` if it''s out of Vue''s dominion?
    We''ll have to do it the old-fashioned way with the browser''s Web API. We need
    to run the following statements when the modal is opened or closed:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果`body`不在Vue的控制范围之内，我们如何向`body`添加/删除类？我们将不得不用浏览器的Web API以老式的方式来做。当模态框打开或关闭时，我们需要运行以下语句：
- en: '[PRE67]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As discussed, Vue adds reactive getters and setters to each data property so
    that when data changes it knows to update the DOM appropriately. Vue also allows
    you to write custom logic that hooks into reactive data changes via a feature
    called *watchers*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 正如讨论的那样，Vue为每个数据属性添加了响应式的getter和setter，以便在数据更改时知道如何适当地更新DOM。Vue还允许您编写自定义逻辑，以通过名为*watchers*的功能钩入响应式数据更改。
- en: 'To add a watcher, first add the `watch` property to your Vue instance. Assign
    an object to this where each property has the name of a declared data property,
    and each value is a function. The function has two arguments: the old value and
    new value.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加观察者，首先向Vue实例添加`watch`属性。将一个对象分配给这个属性，其中每个属性都有一个声明的数据属性的名称，每个值都是一个函数。该函数有两个参数：旧值和新值。
- en: 'Whenever a data property changes, Vue will trigger any declared watcher methods:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 每当数据属性更改时，Vue将触发任何声明的观察者方法：
- en: '[PRE68]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Vue can't update the `body` tag for us, but it can trigger custom logic that
    will. Let's use a watcher to update the `body` tag when our modal is opened and
    closed.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Vue不能为我们更新`body`标签，但它可以触发将要更新的自定义逻辑。让我们使用一个观察者来在我们的模态框打开和关闭时更新`body`标签。
- en: '`app.js`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`：'
- en: '[PRE69]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now when you try to scroll the page you'll see it won't budge!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您尝试滚动页面时，您会发现它不会动！
- en: Closing
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭
- en: Users will need a way to close their modal and return to the main window. We'll
    overlay a button in the top-right corner that, when clicked, evaluates an expression
    to set `modalOpen` to `false`. The `show` class on our wrapper `div` will consequentially
    be removed, which means the `display` CSS property will return to `none`, thus
    removing the modal from the page.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 用户需要一种关闭他们的模态框并返回到主窗口的方法。我们将在右上角叠加一个按钮，当点击时，会评估一个表达式来将`modalOpen`设置为`false`。我们包装`div`上的`show`类将随之被移除，这意味着`display`
    CSS属性将返回到`none`，从而将模态框从页面中移除。
- en: '`index.html`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`：'
- en: '[PRE70]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`style.css`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`style.css`：'
- en: '[PRE71]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Escape key
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Escape键
- en: Having a close button for our modal is handy, but most people's instinctual
    action for closing a window is the *Escape *key.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的模态框添加一个关闭按钮很方便，但大多数人关闭窗口的本能动作是按下*Escape*键。
- en: '`v-on` is Vue''s mechanism for listening to events and seems like a good candidate
    for this job. Adding the `keyup` argument will trigger a handler callback after *any* key
    is pressed while this input is focused:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-on`是Vue监听事件的机制，似乎是这项工作的一个很好的选择。添加`keyup`参数将在此输入聚焦时按下*任何*键后触发处理程序回调：'
- en: '[PRE72]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Event modifiers
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件修饰符
- en: 'Vue makes it easy to listen for *specific* keys by offering *modifiers* to
    the `v-on` directive. Modifiers are postfixes denoted by a dot (`.`), for example:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Vue通过为`v-on`指令提供*修饰符*来轻松监听*特定*键。修饰符是由点(`.`)表示的后缀，例如：
- en: '[PRE73]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'As you''d probably guess, the `.enter` modifier tells Vue to only call the
    handler when the event is triggered by the *Enter* key. Modifiers save you from
    having to remember the specific key code, and also make your template logic more
    obvious. Vue offers a variety of other key modifiers, including:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能猜到的那样，`.enter`修饰符告诉Vue仅在事件由*Enter*键触发时调用处理程序。修饰符使您无需记住特定的键码，还使您的模板逻辑更加明显。Vue提供了各种其他键修饰符，包括：
- en: '`tab`'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tab`'
- en: '`delete`'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`'
- en: '`space`'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`空间`'
- en: '`esc`'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`esc`'
- en: 'With that in mind, it seems like we could close our modal with this directive:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，似乎我们可以使用这个指令关闭我们的模态框：
- en: '[PRE74]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: But then what tag do we attach this directive to? Unfortunately, unless an input
    is focused on, key events are dispatched from the `body` element, which, as we
    know, is out of Vue's jurisdiction!
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们应该将这个指令附加到哪个标签呢？不幸的是，除非有一个输入被聚焦，否则键事件将从`body`元素分派，而我们知道这是Vue无法控制的！
- en: To handle this event we'll, once again, resort to the Web API.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个事件，我们将再次求助于Web API。
- en: '`app.js`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`：'
- en: '[PRE75]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This works, with one caveat (discussed in the next section). But Vue can help
    us make it perfect.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以工作，但有一个警告（在下一节中讨论）。但是Vue可以帮助我们使它完美。
- en: Lifecycle hooks
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期钩子
- en: When your main script is run and your instance of Vue is set up, it goes through
    a series of initialization steps. As we said earlier, Vue will walk through your
    data objects and make them reactive, as well as compile the template and mount
    to the DOM. Later in the lifecycle, Vue will also go through updating steps, and
    later still, tear-down steps.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的主脚本运行并设置了Vue的实例时，它会经历一系列的初始化步骤。正如我们之前所说的，Vue将遍历您的数据对象并使它们具有反应性，同时编译模板并挂载到DOM上。在生命周期的后期，Vue还将经历更新步骤，然后是拆卸步骤。
- en: 'Here is a diagram of the lifecycle instance taken from [http://vuejs.org](http://vuejs.org).
    Many of these steps concern concepts that we haven''t yet covered, but you should
    get the gist:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从[http://vuejs.org](http://vuejs.org)获取的生命周期实例图。其中许多步骤涉及到我们尚未涵盖的概念，但您应该能够理解大意：
- en: '![](assets/9f308e86-bbbe-489c-9f93-06abe2675081.png)Figure 2.11\. Vue.js lifecycle
    diagram'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/9f308e86-bbbe-489c-9f93-06abe2675081.png)图2.11. Vue.js生命周期图'
- en: Vue allows you to execute custom logic at these different steps via *lifecycle
    hooks,* which are callbacks defined in the configuration object.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Vue允许您通过*生命周期钩子*在这些不同的步骤执行自定义逻辑，这些钩子是在配置对象中定义的回调函数。
- en: 'For example, here we utilize the `beforeCreate` and `created` hooks:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里我们利用了`beforeCreate`和`created`钩子：
- en: '[PRE76]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Vue will alias data properties to the context object *after* the `beforeCreate` hook
    is called but *before* the `created` hook is called, hence why `this.message` is `undefined` in
    the former.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在`beforeCreate`钩子被调用之后但在`created`钩子被调用之前，Vue将数据属性别名为上下文对象，因此在前者中`this.message`是`undefined`。
- en: 'The caveat I mentioned earlier about the *Escape* key listener is this: although
    unlikely, if the *Escape* key was pressed and our callback was called *before* Vue
    has proxied the data properties, `app.modalOpen` would be `undefined` rather than `true` and
    so our `if` statement would not control flow like we expect.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到的关于*Escape*键监听器的警告是：虽然不太可能，但如果在按下*Escape*键并且我们的回调在Vue代理数据属性之前被调用，`app.modalOpen`将是`undefined`而不是`true`，因此我们的`if`语句将无法像我们期望的那样控制流程。
- en: To overcome this we can set up the listener in the `created` lifecycle hook
    that will be called *after* Vue has proxied the data properties. This gives us
    a guarantee that `modalOpen` will be defined when the callback is run.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，我们可以在`created`生命周期钩子中设置监听器，该监听器将在Vue代理数据属性之后调用。这给了我们一个保证，当回调运行时，`modalOpen`将被定义。
- en: '`app.js`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`：'
- en: '[PRE77]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Methods
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: The Vue configuration object also has a section for *methods*. Methods are not
    reactive, so you could define them outside of the Vue configuration without any
    difference in functionality, but the advantage to Vue methods is that they are
    passed the Vue instance as context and therefore have easy access to your other
    properties and methods.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Vue配置对象还有一个*方法*部分。方法不是响应式的，因此您可以在Vue配置之外定义它们，而在功能上没有任何区别，但Vue方法的优势在于它们作为上下文传递了Vue实例，因此可以轻松访问您的其他属性和方法。
- en: Let's refactor our `escapeKeyListener` to be a `Vue` instance method.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构我们的`escapeKeyListener`成为一个`Vue`实例方法。
- en: '`app.js`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`：'
- en: '[PRE78]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Proxied properties
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理属性
- en: You may have noticed that our `escapeKeyListener` method can refer to `this.modalOpen`.
    Shouldn't it be `this.methods.modalOpen`?
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们的`escapeKeyListener`方法可以引用`this.modalOpen`。难道不应该是`this.methods.modalOpen`吗？
- en: 'When a Vue instance is constructed, it proxies any data properties, methods,
    and computed properties to the instance object. This means that from within any
    method you can refer to `this.myDataProperty`, `this.myMethod`, and so on, rather
    than `this.data.myDataProperty` or `this.methods.myMethod`, as you might assume:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当Vue实例被构建时，它会将任何数据属性、方法和计算属性代理到实例对象。这意味着在任何方法中，你可以引用`this.myDataProperty`、`this.myMethod`等，而不是`this.data.myDataProperty`或`this.methods.myMethod`，正如你可能会假设的那样：
- en: '[PRE79]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'You can see these proxied properties by printing the Vue object in the browser
    console:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在浏览器控制台中打印Vue对象来查看这些代理属性：
- en: '![](assets/d6771753-2628-41d4-809f-4e0f2ab6381e.png)Figure 2.12\. Our app''s
    Vue instance'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/d6771753-2628-41d4-809f-4e0f2ab6381e.png)图2.12。我们应用的Vue实例'
- en: Now the simplicity of text interpolations might make more sense, they have the
    context of the Vue instance, and thanks to proxied properties, can be referenced
    like `{{ myDataProperty }}`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文本插值的简单性可能更有意义，它们具有Vue实例的上下文，并且由于代理属性的存在，可以像`{{ myDataProperty }}`一样被引用。
- en: However, while proxying to the root makes syntax terser, a consequence is that
    you can't name your data properties, methods, or computed properties with the
    same name!
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然代理到根使语法更简洁，但一个后果是你不能用相同的名称命名你的数据属性、方法或计算属性！
- en: Removing listener
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除监听器
- en: To avoid any memory leaks, we should also use `removeEventListener` to get rid
    of the listener when the Vue instance is torn down. We can use the `destroy` hook
    and call our `escapeKeyListener` method for this purpose.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免任何内存泄漏，当Vue实例被销毁时，我们还应该使用`removeEventListener`来摆脱监听器。我们可以使用`destroy`钩子，并调用我们的`escapeKeyListener`方法来实现这个目的。
- en: '`app.js`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`：'
- en: '[PRE80]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got familiar with the essential features of Vue including
    installation and basic configuration, data binding, text interpolation, directives,
    methods, watchers and lifecycle hooks. We also learned about Vue's inner workings,
    including the reactivity system.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们熟悉了Vue的基本特性，包括安装和基本配置、数据绑定、文本插值、指令、方法、观察者和生命周期钩子。我们还了解了Vue的内部工作原理，包括响应系统。
- en: We then used this knowledge to set up a basic Vue project and create page content
    for the Vuebnb prototype with text, lists of information, a header image, and
    UI widgets like the show more button and the modal window.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们利用这些知识来设置一个基本的Vue项目，并为Vuebnb原型创建页面内容，包括文本、信息列表、页眉图像，以及UI小部件，如“显示更多”按钮和模态窗口。
- en: In the next chapter, we'll take a brief break from Vue while we set up a backend
    for Vuebnb using Laravel.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将暂时离开Vue，同时使用Laravel为Vuebnb设置后端。
