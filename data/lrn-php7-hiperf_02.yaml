- en: Chapter 2. New Features in PHP 7
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。PHP 7中的新功能
- en: PHP 7 has introduced new features that can help programmers write high-performing
    and effective code. Also, some old-fashioned features are completely removed,
    and PHP 7 will throw an error if used. Most of the fatal errors are now exceptions,
    so PHP won't show an ugly fatal error message any more; instead, it will go through
    an exception with the available details.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7引入了一些新功能，可以帮助程序员编写高性能和有效的代码。此外，一些老式的功能已经完全移除，如果使用PHP 7将抛出错误。现在大多数致命错误都是异常，因此PHP不会再显示丑陋的致命错误消息；相反，它将通过可用的详细信息进行异常处理。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Type hints
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型提示
- en: Namespaces and group use declarations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间和组使用声明
- en: The anonymous classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名类
- en: Old-style constructor deprecation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧式构造函数弃用
- en: The Spaceship operator
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 太空船运算符
- en: The null coalesce operator
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空合并运算符
- en: Uniform variable syntax
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一变量语法
- en: Miscellaneous changes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他更改
- en: OOP features
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程特性
- en: PHP 7 introduced a few new OOP features that will enable developers to write
    clean and effective code. In this section, we will discuss these features.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7引入了一些新的面向对象编程功能，使开发人员能够编写干净而有效的代码。在本节中，我们将讨论这些功能。
- en: Type hints
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型提示
- en: 'Prior to PHP 7, there was no need to declare the data type of the arguments
    passed to a function or class method. Also, there was no need to mention the return
    data type. Any data type can be passed to and returned from a function or method.
    This is one of the huge problems in PHP, in which it is not always clear which
    data types should be passed or received from a function or method. To fix this
    problem, PHP 7 introduced type hints. As of now, two type hints are introduced:
    scalar and return type hints. These are discussed in the following sections.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7之前，不需要声明传递给函数或类方法的参数的数据类型。此外，也不需要提及返回数据类型。任何数据类型都可以传递给函数或方法，并从函数或方法返回。这是PHP中的一个巨大问题，不清楚应该传递或接收哪些数据类型。为了解决这个问题，PHP
    7引入了类型提示。目前，引入了两种类型提示：标量和返回类型提示。这些将在以下部分讨论。
- en: Type hints is a feature in both OOP and procedural PHP because it can be used
    for both procedural functions and object methods.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示是面向对象编程和过程式PHP中的一个特性，因为它可以用于过程式函数和对象方法。
- en: Scalar type hints
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标量类型提示
- en: 'PHP 7 made it possible to use scalar type hints for integers, floats, strings,
    and Booleans for both functions and methods. Let''s have a look at the following
    example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7使得可以为整数、浮点数、字符串和布尔值的函数和方法使用标量类型提示。让我们看下面的例子：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we created a `Person` class. We have three methods, and
    each method receives different arguments whose data types are defined with them,
    as is highlighted in the preceding code. If you run the preceding code, it will
    work fine as we will pass the desired data types for each method.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个`Person`类。我们有三种方法，每种方法接收不同的参数，其数据类型在上面的代码中进行了定义。如果运行上面的代码，它将正常工作，因为我们将为每种方法传递所需的数据类型。
- en: 'Age can be a float, such as `30.5` years; so, if we pass a float number to
    the `age` method, it will still work, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 年龄可以是浮点数，例如`30.5`岁；因此，如果我们将浮点数传递给`age`方法，它仍然可以工作，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Why is that? It is because, by default, *scalar type hints are nonrestrictive*.
    This means that we can pass float numbers to a method that expects an integer
    number.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？这是因为默认情况下，*标量类型提示是非限制性的*。这意味着我们可以将浮点数传递给期望整数的方法。
- en: 'To make it more restrictive, the following single-line code can be placed at
    the top of the file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其更加严格，可以将以下单行代码放在文件的顶部：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, if we pass a float number to the `age` function, we will get an **Uncaught
    Type Error**, which is a fatal error that tells us that `Person::age` must be
    of the int type given the float. Similar errors will be generated if we pass a
    string to a method that is not of the string type. Consider the following example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们将浮点数传递给`age`函数，我们将得到一个**未捕获的类型错误**，这是一个致命错误，告诉我们`Person::age`必须是给定浮点数的整数类型。如果我们将字符串传递给不是字符串类型的方法，将生成类似的错误。考虑以下例子：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code will generate the fatal error as the string is passed to
    it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于传递了字符串，上面的代码将生成致命错误。
- en: Return type hints
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回类型提示
- en: 'Another important feature of PHP 7 is the ability to define the return data
    type for a function or method. It behaves the same way scalar type hints behave.
    Let''s modify our `Person` class a little to understand return type hints, as
    follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7的另一个重要特性是能够为函数或方法定义返回数据类型。它的行为与标量类型提示的行为相同。让我们稍微修改我们的`Person`类以理解返回类型提示，如下所示：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The changes in the class are highlighted. The return type is defined using
    the`: data-type` syntax. It does not matter if the return type is the same as
    the scalar type. These can be different as long as they match their respective
    data types.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的更改已经突出显示。使用`:数据类型`语法定义了返回类型。返回类型是否与标量类型相同并不重要。只要它们与各自的数据类型匹配即可。
- en: 'Now, let''s try an example with the object return type. Consider the previous
    `Person` class and add a `getAddress` method to it. Also, we will add a new class,
    `Address`, to the same file, as shown in the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一个带有对象返回类型的例子。考虑之前的`Person`类，并向其添加一个`getAddress`方法。此外，我们将在同一个文件中添加一个新的类`Address`，如下所示：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The additional code added to the `Person` class and the new `Address` class
    is highlighted. Now, if we call the `getAddress` method of the `Person` class,
    it will work perfectly and won''t throw an error. However, let''s suppose that
    we change the return statement, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到`Person`类和新的`Address`类的附加代码已经突出显示。现在，如果我们调用`Person`类的`getAddress`方法，它将完美地工作，不会抛出错误。然而，假设我们改变返回语句，如下所示：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this case, the preceding method will throw an *uncaught* exception similar
    to the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，上面的方法将抛出类似于以下内容的*未捕获*异常：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is because we return an array instead of an `Address` object. Now, the
    question is: why use type hints? The big advantage of using type hints is that
    it will always avoid accidentally passing or returning wrong and unexpected data
    to methods or functions.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们返回的是一个数组，而不是一个`Address`对象。现在，问题是：为什么使用类型提示？使用类型提示的重要优势是它将始终避免意外地传递或返回错误和意外的数据到方法或函数。
- en: As can be seen in the preceding examples, this makes the code clear, and by
    looking at the declarations of the methods, one can exactly know which data types
    should be passed to each of the methods and what kind of data is returned by looking
    into the code of each method or comment, if any.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，这使得代码清晰，通过查看方法的声明，可以准确知道应该传递哪些数据类型到每个方法，以及通过查看每个方法的代码或注释，返回什么类型的数据。
- en: Namespaces and group use declaration
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间和组使用声明
- en: In a very large codebase, classes are divided into namespaces, which makes them
    easy to manage and work with. However, if there are too many classes in a namespace
    and we need to use 10 of them, then we have to type the complete use statement
    for all these classes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个非常庞大的代码库中，类被划分到命名空间中，这使得它们易于管理和使用。但是，如果一个命名空间中有太多的类，而我们需要使用其中的10个类，那么我们必须为所有这些类输入完整的使用语句。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In PHP, it is not required to divide classes in subfolders according to their
    namespace, as is the case with other programming languages. Namespaces just provide
    a logical separation of classes. However, we are not limited to placing our classes
    in subfolders according to our namespaces.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，不需要根据其命名空间将类分成子文件夹，这与其他编程语言不同。命名空间只是提供类的逻辑分离。但是，我们不限于根据我们的命名空间将我们的类放在子文件夹中。
- en: 'For example, we have a `Publishers/Packt` namespace and the classes `Book`,
    `Ebook`, `Video`, and `Presentation`. Also, we have a `functions.php` file, which
    has our normal functions and is in the same `Publishers/Packt` namespace. Another
    file, `constants.php`, has the constant values required for the application and
    is in the same namespace. The code for each class and the `functions.php` and
    `constants.php` files is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有一个`Publishers/Packt`命名空间和类`Book`、`Ebook`、`Video`和`Presentation`。此外，我们有一个`functions.php`文件，其中包含我们的常规函数，并且在相同的`Publishers/Packt`命名空间中。另一个文件`constants.php`包含应用程序所需的常量值，并且在相同的命名空间中。每个类和`functions.php`和`constants.php`文件的代码如下：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, the code for the `Ebook` class is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Ebook`类的代码如下：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The code for the `Video` class is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Video`类的代码如下：'
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similarly, the code for the `presentation` class is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`presentation`类的代码如下：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All the four classes have the same methods, which return the classes' names
    using the PHP built-in `get_class()` function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有四个类都有相同的方法，这些方法使用PHP内置的`get_class()`函数返回类的名称。
- en: 'Now, add the following two functions to the `functions.php` file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下两个函数添加到`functions.php`文件中：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s add the following code to the `constants.php` file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将以下代码添加到`constants.php`文件中：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code in both `functions.php` and `constants.php` is self-explanatory. Note
    that each file has a `namespace Publishers/Packt` line at the top, which makes
    these classes, functions, and constants belong to this namespace.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`functions.php`和`constants.php`中的代码是不言自明的。请注意，每个文件顶部都有一行`namespace Publishers/Packt`，这使得这些类、函数和常量属于这个命名空间。'
- en: Now, there are three ways to use the classes, functions, and constants. Let's
    consider each one.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有三种方法可以使用类、函数和常量。让我们逐一考虑每一种。
- en: 'Take a look at the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的代码：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we used namespace names directly while creating objects
    or using functions and constants. The code looks fine, but it is cluttered. Namespace
    is everywhere, and if we have lots of namespaces, it will look very ugly, and
    the readability will be affected.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们直接使用命名空间名称创建对象或使用函数和常量。代码看起来不错，但是有点混乱。命名空间到处都是，如果我们有很多命名空间，它看起来会很丑陋，可读性也会受到影响。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We did not include class files in the previous code. Either the `include` statements
    or PHP's `__autoload` function can be used to include all the files.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的代码中没有包含类文件。可以使用`include`语句或PHP的`__autoload`函数来包含所有文件。
- en: 'Now, let''s rewrite the preceding code to make it more readable, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新编写前面的代码，使其更易读，如下所示：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, at the top, we used PHP statements for specific classes,
    functions, and constants in a namespace. However, we still wrote duplicate lines
    of code for each class, function, and/or constant. This may lead to us have lots
    of use statements at the top of the file, and the overall verbosity would not
    be good.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在顶部使用了PHP语句来指定命名空间中特定的类、函数和常量。但是，我们仍然为每个类、函数和/或常量编写了重复的代码行。这可能导致我们在文件顶部有大量的使用语句，并且整体冗长度不好。
- en: 'To fix this problem, PHP 7 introduced group use declaration. There are three
    types of group use declarations:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，PHP 7引入了组使用声明。有三种类型的组使用声明：
- en: Non mixed use declarations
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非混合使用声明
- en: Mixed use declarations
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合使用声明
- en: Compound use declarations
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合使用声明
- en: Non mixed group use declarations
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非混合组使用声明
- en: 'Consider that we have different types of features in a namespace, as we have
    classes, functions, and contacts in a namespace. In non mixed group use declarations,
    we declare them separately using a `use` statement. To better understand it, take
    a look at the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在一个命名空间中有不同类型的特性，如类、函数和联系人。在非混合组使用声明中，我们使用`use`语句分别声明它们。为了更好地理解它，请看下面的代码：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have three types of features in a namespace: class, functions, and constants.
    So, we have used separate group `use` declaration statements to use them. The
    code is now looking more cleaner, organized, and readable and doesn''t require
    too much duplicate typing.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个命名空间中，我们有三种特性：类、函数和常量。因此，我们使用单独的组`use`声明语句来使用它们。现在，代码看起来更清晰、有组织、可读性更好，而且不需要太多重复输入。
- en: Mixed group use declarations
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合组使用声明
- en: 'In this declaration, we combine all types into a single `use` statement. Take
    a look at the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个声明中，我们将所有类型合并到一个`use`语句中。看看以下代码：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The compound namespace declaration
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复合命名空间声明
- en: To understand the compound namespace declaration, we will consider the following
    criteria.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解复合命名空间声明，我们将考虑以下标准。
- en: 'Let''s say we have a `Book` class in the `Publishers\Packt\Paper` namespace.
    Also, we have an `Ebook` class in the `Publishers\Packt\Electronic` namespace.
    The `Video` and `Presentation` classes are in the `Publishers\Packt\Media` namespace.
    So, to use these classes, we will use the code, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在`Publishers\Packt\Paper`命名空间中有一个`Book`类。此外，我们在`Publishers\Packt\Electronic`命名空间中有一个`Ebook`类。`Video`和`Presentation`类位于`Publishers\Packt\Media`命名空间中。因此，为了使用这些类，我们将使用以下代码：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the compound namespace declaration, we can use the preceding namespaces
    as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在复合命名空间声明中，我们可以使用前面的命名空间，如下所示：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It is more elegant and clear, and it doesn't require extra typing if the namespace
    names are long.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这更加优雅和清晰，如果命名空间名称很长，它不需要额外的输入。
- en: The anonymous classes
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名类
- en: An anonymous class is a class that is declared and instantiated at the same
    time. It does not have a name and can have the full features of a normal class.
    These classes are useful when a single one-time small task is required to be performed
    and there is no need to write a full-blown class for it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类是在声明和实例化同时进行的类。它没有名称，并且可以具有普通类的全部特性。当需要执行一次性的小任务并且不需要为此编写完整的类时，这些类非常有用。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While creating an anonymous class, it is not named, but it is named internally
    in PHP with a unique reference based on its address in the memory block. For example,
    the internal name of an anonymous class may be `class@0x4f6a8d124`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建匿名类时，它没有名称，但在PHP内部使用基于内存块中的地址的唯一引用来命名。例如，匿名类的内部名称可能是`class@0x4f6a8d124`。
- en: 'The syntax of this class is the same as that of the named classes, but only
    the name of the class is missing, as shown in the following syntax:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的语法与命名类的语法相同，但类的名称缺失，如下所示：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s look at a basic and very simple example of an anonymous class, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个匿名类的基本和非常简单的例子，如下所示：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code will just display the output as `Altaf Hussain`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码只会显示`Altaf Hussain`。
- en: 'Arguments can also be passed to the *anonymous class constructor*, as shown
    in the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 参数也可以传递给*匿名类构造函数*，如下所示的代码：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will give us the same output as the first example.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们与第一个示例相同的输出。
- en: 'Anonymous classes can extend other classes and have the same parent-child classes
    functioning as normal named classes. Let''s have another example; take a look
    at the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类可以扩展其他类，并且具有与普通命名类相同的父子类功能。让我们看另一个例子；看看以下内容：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code will display `I am parent constructor` and `5`. As can be
    seen, we extended the `Packt` class the way we extend named classes. Also, we
    can access the `public` and `protected` properties and methods within the anonymous
    class and public properties and methods using anonymous class objects.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将显示`I am parent constructor`和`5`。可以看到，我们扩展`Packt`类的方式与我们扩展命名类的方式相同。此外，我们可以在匿名类中访问`public`和`protected`属性和方法，并且可以使用匿名类对象访问公共属性和方法。
- en: 'Anonymous classes can implement interfaces too, the same as named classes.
    Let''s create an interface first. Run the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类也可以实现接口，与命名类一样。让我们首先创建一个接口。运行以下代码：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s modify our `Packt` class as follows. We added the highlighted code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改我们的`Packt`类如下。我们添加了突出显示的代码：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The rest of the code is same as the first `Packt` class. Now, let''s create
    our anonymous class, which will implement the `Publishers` interface created in
    the previous code and extend the new `Packt` class, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分与第一个`Packt`类相同。现在，让我们创建我们的匿名类，它将实现前面代码中创建的`Publishers`接口，并扩展新的`Packt`类，如下所示：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code is self-explanatory and will output `Altaf Hussain` along
    with the address.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是不言自明的，并将输出`Altaf Hussain`以及地址。
- en: 'It is possible to use anonymous classes within another class, as shown here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在另一个类中使用匿名类，如下所示：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding code will return `60`. How does this happen? The `Math` class
    has a `multiply_sum` method that returns the object of an anonymous class. This
    anonymous class is extended from the `Math` class and has a `multiply` method.
    So, our `echo` statement can be divided into two parts: the first is `$math->multiply_sum()`,
    which returns the object of the anonymous class, and the second is `->multiply(2)`,
    in which we chained this object to call the anonymous class''s `multiply` method
    along with an argument of the value `2`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将返回`60`。这是如何发生的？`Math`类有一个`multiply_sum`方法，返回匿名类的对象。这个匿名类是从`Math`类扩展出来的，并且有一个`multiply`方法。因此，我们的`echo`语句可以分为两部分：第一部分是`$math->multiply_sum()`，它返回匿名类的对象，第二部分是`->multiply(2)`，在这里我们链接了这个对象来调用匿名类的`multiply`方法，并传入值`2`。
- en: In the preceding case, the `Math` class can be called the outer class, and the
    anonymous class can be called the inner class. However, remember that it is not
    required for the inner class to extend the outer class. In the preceding example,
    we extended it just to ensure that the inner classes could have access to the
    outer classes' properties and methods by extending the outer classes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情况下，`Math`类可以被称为外部类，匿名类可以被称为内部类。但是，请记住，内部类不需要扩展外部类。在前面的例子中，我们扩展它只是为了确保内部类可以通过扩展外部类来访问外部类的属性和方法。
- en: Old-style constructor deprecation
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旧式构造函数弃用
- en: 'Back in PHP 4, the constructor of a class has the same name method as that
    of the class. It is still used and is valid until PHP''s 5.6 version. However,
    now, in PHP 7, it is deprecated. Let''s have an example, as shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 回到PHP 4时，类的构造函数与类的同名方法。它仍然被使用，并且在PHP的5.6版本之前是有效的。然而，现在在PHP 7中，它已被弃用。让我们看一个示例，如下所示：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code will display the output `I am an old style constructor`
    with a deprecated message, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将显示输出`我是一个旧式构造函数`，并附带一个弃用消息，如下所示：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, the old style constructor is still called. Now, let''s add the PHP
    `__construct` method to our class, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然调用旧式构造函数。现在，让我们向我们的类添加PHP `__construct`方法，如下所示：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, when we instantiated the object of the class, the normal
    `__construct` constructor was called. The `packt()`method isn't considered a normal
    class method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当我们实例化类的对象时，会调用普通的`__construct`构造函数。`packt()`方法不被视为普通的类方法。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Old-style constructors are deprecated, which means that they will still work
    in PHP 7 and a deprecated message will be displayed, but it will be removed in
    the upcoming versions. It is best practice to not use them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 旧式构造函数已经被弃用，这意味着它们在PHP 7中仍然可以工作，并且会显示一个弃用的消息，但它将在即将推出的版本中被移除。最好不要使用它们。
- en: The throwable interface
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可抛出接口
- en: PHP 7 introduced a base interface that can be base for every object that can
    use the `throw` statement. In PHP, exceptions and errors can occur. Previously,
    exceptions could be handled, but it was not possible to handle errors, and thus,
    any fatal error caused the complete application or a part of the application to
    halt. To make errors (the most fatal errors) catchable as well, PHP 7 introduced
    the *throwable* interface, which is implemented by both the exception and error.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7引入了一个基本接口，可以作为可以使用`throw`语句的每个对象的基础。在PHP中，异常和错误可能会发生。以前，异常可以被处理，但无法处理错误，因此，任何致命错误都会导致整个应用程序或应用程序的一部分停止。为了使错误（最致命的错误）也可以被捕获，PHP
    7引入了*throwable*接口，它由异常和错误都实现。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The PHP classes we created can't implement the throwable interface. If required,
    these classes must extend an exception.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的PHP类无法实现可抛出接口。如果需要，这些类必须扩展异常。
- en: We all know exceptions, so in this topic, we will only discuss errors, which
    can handle the ugly, fatal errors.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道异常，因此在这个主题中，我们只讨论可以处理丑陋的致命错误的错误。
- en: Error
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误
- en: 'Almost all fatal errors can now throw an error instance, and similarly to exceptions,
    error instances can be caught using the `try/catch` block. Let''s have a simple
    example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在几乎所有致命错误都可以抛出错误实例，类似于异常，错误实例可以使用`try/catch`块捕获。让我们来看一个简单的例子：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If the preceding code is executed, a fatal error will be displayed, the application
    will be halted, and the `echo` statement won't be executed in the end.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行前面的代码，将显示致命错误，应用程序将停止，并且最终不会执行`echo`语句。
- en: 'Now, let''s place the function call in the `try/catch` block, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将函数调用放在`try/catch`块中，如下所示：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, if the preceding code is executed, the `catch` body will be executed, and
    after this, the rest of the application will continue running. In the preceding
    case, the `echo` statement will be executed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果执行前面的代码，`catch`体将被执行，之后，应用程序的其余部分将继续运行。在前面的情况下，`echo`语句将被执行。
- en: In most cases, the error instance will be thrown for the most fatal errors,
    but for some errors, a subinstance of error will be thrown, such as `TypeError`,
    `DivisionByZeroError`, `ParseError`, and so on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，错误实例将被抛出，用于最致命的错误，但对于一些错误，将抛出错误的子实例，例如`TypeError`、`DivisionByZeroError`、`ParseError`等。
- en: 'Now, let''s take a look at a `DivisionByZeroError` exception in the following
    example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个以下示例中的`DivisionByZeroError`异常：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Before PHP 7, the preceding code would have issued a warning about the division
    by zero. However, now in PHP 7, it will throw a `DivisionByZeroError`, which can
    be handled.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7之前，前面的代码会发出有关除以零的警告。然而，现在在PHP 7中，它将抛出一个`DivisionByZeroError`，可以处理。
- en: New operators
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新运算符
- en: PHP 7 introduced two interested operators. These operators can help write less
    and cleaner code, so the final code will be more readable as compared to the traditional
    operators in use. Let's have a look at them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7引入了两个有趣的运算符。这些运算符可以帮助编写更少、更清晰的代码，因此最终的代码将比使用传统运算符更易读。让我们来看看它们。
- en: The Spaceship operator (<=>)
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 太空船运算符（<=>）
- en: 'The Spaceship or Combined Comparison operator is useful to compare values (strings,
    integers, floats, and so on), arrays, and objects. This operator is just a wrapper
    and performs the same tasks as the three comparison operators `==`, `<`, and `>`.
    This operator can also be used to write clean and less code for callback functions
    for `usort`, `uasort`, and `uksort`. This operator works as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 太空船或组合比较运算符对于比较值（字符串、整数、浮点数等）、数组和对象非常有用。这个运算符只是一个包装器，执行与三个比较运算符`==`、`<`和`>`相同的任务。这个运算符也可以用于为`usort`、`uasort`和`uksort`的回调函数编写干净和少量的代码。这个运算符的工作方式如下：
- en: It returns 0 if both the operands on left- and right-hand sides are equal
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果左右两侧的操作数相等，则返回0
- en: It returns -1 if the right operand is greater than the left operand
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果右操作数大于左操作数，则返回-1
- en: It returns 1 if the left operand is greater than the right one
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果左操作数大于右操作数，则返回1
- en: 'Let''s take a look at a few examples by comparing integers, strings, objects,
    and arrays and note the result:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过比较整数、字符串、对象和数组来看几个例子，并注意结果：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the preceding code, and you will have an output similar to the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码，你将得到类似以下的输出：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the first comparison, in which we compare `$int1` and `$int3`, both are equal,
    so it will return `0`. In the second comparison, in which `$int1` and `$int2`
    are compared, it will return `-1` because the right operand (`$int2`) in greater
    than the left operand (`$int1`). Finally, the third comparison will return `1`
    as the left operand (`$int2`) is greater than the right operand (`$int3`).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个比较中，我们比较了`$int1`和`$int3`，两者都相等，所以它将返回`0`。在第二个比较中，比较了`$int1`和`$int2`，它将返回`-1`，因为右操作数（`$int2`）大于左操作数（`$int1`）。最后，第三个比较将返回`1`，因为左操作数（`$int2`）大于右操作数（`$int3`）。
- en: The preceding is a simple example in which we compared integers. We can check
    strings, objects, and arrays in the same way, and they are compared the same standard
    PHP way.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上面是一个简单的例子，我们在其中比较了整数。我们可以以相同的方式检查字符串、对象和数组，并且它们是按照标准的PHP方式进行比较的。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some examples for the `<=>` operator can be found at [https://wiki.php.net/rfc/combined-comparison-operator](https://wiki.php.net/rfc/combined-comparison-operator).
    This is an RFC publication that has more useful details about its usage.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`<=>`运算符的一些例子可以在[https://wiki.php.net/rfc/combined-comparison-operator](https://wiki.php.net/rfc/combined-comparison-operator)找到。这是一个RFC出版物，其中有关于其用法的更多有用细节。
- en: 'This operator can be more useful in sorting arrays. Take a look at the following
    code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符在对数组进行排序时更有用。看看下面的代码：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, we used two functions to sort the two different arrays
    with the same values. The `$normalArray` array is sorted by the `normal_sort`
    function, in which the `normal_sort` function uses `if` statements to compare
    the values. The second array `$spaceArray` has the same values as `$normalArray`,
    but this array is sorted by the `space_sort` function, which uses the Spaceship
    operator. The final result for both array sorts is the same, but the code in the
    callback functions is different. The `normal_sort` function has `if` statements
    and multiple lines of code, while the `space_sort` function has a single line
    of code—that's it! The `space_sort` function code is clearer and does not require
    multiple if statements.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了两个函数来对具有相同值的两个不同数组进行排序。`$normalArray`数组通过`normal_sort`函数进行排序，`normal_sort`函数使用`if`语句来比较值。第二个数组`$spaceArray`具有与`$normalArray`相同的值，但是这个数组通过`space_sort`函数进行排序，`space_sort`函数使用了太空船运算符。两个数组排序的最终结果是相同的，但回调函数中的代码是不同的。`normal_sort`函数有`if`语句和多行代码，而`space_sort`函数只有一行代码，就是这样！`space_sort`函数的代码更清晰，不需要多个if语句。
- en: The null coalesce operator(??)
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空合并运算符(??)
- en: 'We all know ternary operators, and we use them most of the time. Ternary operators
    are just a single-line replacement for *if-else* statements. For example, consider
    the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道三元运算符，并且大多数时候都会使用它们。三元运算符只是*if-else*语句的单行替代。例如，考虑以下代码：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If `$_POST[''title'']` exists, then the `$post` variable will be assigned its
    value; otherwise, `NULL` will be assigned. However, if `$_POST` or `$_POST[''title'']`
    does not exist or is null, then PHP will issue a notice of *Undefined index*.
    To fix this notice, we need to use the `isset` function, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`$_POST['title']`存在，则`$post`变量将被赋予它的值；否则，将被赋予`NULL`。但是，如果`$_POST`或`$_POST['title']`不存在或为null，则PHP将发出*未定义的索引*的通知。为了解决这个通知，我们需要使用`isset`函数，如下所示：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Mostly, it will seem fine, but it becomes very nasty when we have to check for
    values in multiple places, especially when using PHP as a templating language.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，看起来都很好，但当我们需要在多个地方检查值时，特别是在使用PHP作为模板语言时，情况就会变得非常棘手。
- en: 'In PHP 7, the coalescence operator is introduced, which is simple and returns
    the value of its first operand (left operand) if it exists and is not null. Otherwise,
    it returns its second operand (right operand). Consider the following example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中，引入了合并运算符，它很简单，如果第一个操作数（左操作数）存在且不为null，则返回其值。否则，返回第二个操作数（右操作数）。考虑以下例子：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This example is exactly similar to the preceding code. The coalesce operator
    checks whether `$_POST['title']` exists. If it does, the operator returns it;
    otherwise, it returns `NULL`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与前面的代码完全相似。合并运算符检查`$_POST['title']`是否存在。如果存在，运算符返回它；否则，返回`NULL`。
- en: 'Another great feature of this operator is that it can be chained. Here''s an
    example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符的另一个很棒的特性是它可以链接起来。以下是一个例子：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: According to the definition, it will first check whether the first operand exists
    and return it; if it does not exist, it will return the second operand. Now, if
    there is another coalesce operator used on the second operand, the same rule will
    be applied, and the value on the left operand will be returned if it exists. Otherwise,
    the value of the right operand will be returned.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，它将首先检查第一个操作数是否存在并返回它；如果不存在，它将返回第二个操作数。现在，如果第二个操作数上使用了另一个合并运算符，同样的规则将被应用，如果左操作数存在，则返回它的值。否则，将返回右操作数的值。
- en: 'So, the preceding code is the same as the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，上面的代码与以下代码相同：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As can be noted in the preceding examples, the coalesce operator can help write
    clean, concise, and less code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的例子中所示，合并运算符可以帮助编写干净、简洁和更少的代码。
- en: Uniform variable syntax
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一变量语法
- en: 'Most of the time, we may face a situation in which the method, variable, or
    classes names are stored in other variables. Take a look at the following example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们可能会遇到这样一种情况，即方法、变量或类名存储在其他变量中。看看下面的例子：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, first, `$objects['class']` will be interpreted, and after
    this, the property name will be interpreted. As shown in the preceding example,
    variables are normally evaluated from left to right.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先会解释`$objects['class']`，然后会解释属性名。如前面的例子所示，变量通常是从左到右进行评估的。
- en: 'Now, consider the following scenario:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下情景：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In PHP 5.x, this code would be executed, and the output would be `Howdy`. However,
    this is not inconsistent with the left-to-right expression evaluation. This is
    because `$$first` should be evaluated first and then the index name, but in the
    preceding case, it is evaluated as `${$first[''name'']}`. It is clear that the
    variable syntax is not consistent and may create confusion. To avoid this inconsistency,
    PHP 7 introduced a new syntax called uniform variable syntax. Without using this
    syntax, the preceding example will bring it into notice, and the desired results
    won''t be produced. To make it work in PHP 7, the curly brackets should be added,
    as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 5.x中，这段代码将被执行，并且输出将是`Howdy`。然而，这与从左到右的表达式评估是不一致的。这是因为`$$first`应该首先被评估，然后是索引名称，但在前面的情况下，它被评估为`${$first['name']}`。很明显，变量语法不一致，可能会造成混淆。为了避免这种不一致，PHP
    7引入了一种称为统一变量语法的新语法。如果不使用这种语法，前面的例子将引起注意，并且不会产生期望的结果。为了使其在PHP 7中工作，应添加大括号，如下所示：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let''s have another example, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们举一个例子，如下所示：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If the preceding code is executed in PHP 5.x, it will work fine and output our
    desired result. However, if we execute this code in PHP 7, it will give a fatal
    error. The error will be at the last line of the code, which is highlighted. PHP
    7 will first try to evaluate `$object->$method.` After this, it will try to evaluate
    `['title']`; and so on; this is not correct.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在PHP 5.x中执行上述代码，它将正常工作并输出我们想要的结果。但是，如果我们在PHP 7中执行此代码，将会产生致命错误。错误将出现在代码的最后一行，这是突出显示的。PHP
    7将首先尝试评估`$object->$method`。之后，它将尝试评估`['title']`；依此类推；这是不正确的。
- en: 'To make it work in PHP 7, the curly brackets should be added, as in the following
    code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其在PHP 7中工作，应添加大括号，如下所示：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: After making the changes mentioned before, we will get our desired output.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行了前面提到的更改之后，我们将得到我们想要的输出。
- en: Miscellaneous features and changes
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他功能和更改
- en: PHP 7 also introduced some other new features with small changes, such as new
    syntax for array constants, multiple default cases in `switch` statement, options
    array in `session_start`, and so on. Let's have a look at these too.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7还引入了一些其他新功能和小的更改，比如数组常量的新语法、`switch`语句中的多个默认情况、`session_start`中的选项数组等。让我们也看看这些。
- en: Constant arrays
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量数组
- en: 'Starting with PHP 5.6, constant arrays can be initialized using the `const`
    keyword, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从PHP 5.6开始，可以使用`const`关键字初始化常量数组，如下所示：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, starting with PHP 7, constant arrays can be initialized using the `define`
    function, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从PHP 7开始，可以使用`define`函数初始化常量数组，如下所示：
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Multiple default cases in the switch statement
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在switch语句中的多个默认情况
- en: 'Prior to PHP 7, multiple default cases in a switch statement were allowed.
    Check out the following example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7之前，允许在switch语句中有多个默认情况。请看下面的例子：
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Before PHP 7, the preceding code was allowed, but in PHP 7, this will result
    in a fatal error similar to the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7之前，允许上述代码，但在PHP 7中，这将导致类似以下的致命错误：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The options array for session_start function
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`session_start`函数的选项数组'
- en: Before PHP 7, whenever we needed to start a session, we just used the `session_start()`
    function. This function did not take any arguments, and all the settings defined
    in `php.ini` were used. Now, starting with PHP 7, an optional array for options
    can be passed, which will override the session settings in the `php.ini` file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7之前，每当我们需要启动会话时，我们只是使用`session_start()`函数。这个函数不带任何参数，并且使用`php.ini`中定义的所有设置。现在，从PHP
    7开始，可以传递一个可选的选项数组，它将覆盖`php.ini`文件中的会话设置。
- en: 'A simple example is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子如下所示：
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As can be seen in the preceding example, it is possible to override the `php.ini`
    settings for a session easily.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，很容易覆盖会话的`php.ini`设置。
- en: Filtered unserialize function
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤反序列化函数
- en: 'It is common practice to serialize and unserialize objects. However, the PHP
    `unserialize()` function was not secure because it did not have any filtering
    options and could unserialize objects of any type. PHP 7 introduced filtering
    in this function. The default filtering option is to unserialize objects of all
    classes or types. Its basic working is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化和反序列化对象是常见的做法。然而，PHP的`unserialize()`函数并不安全，因为它没有任何过滤选项，并且可以反序列化任何类型的对象。PHP
    7在这个函数中引入了过滤。默认的过滤选项是反序列化所有类或类型的对象。其基本工作如下：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed new OOP features, such as type hints, anonymous
    classes, the throwable interface, group use declaration for namespaces, and two
    important new operators, the Spaceship or Combined Comparison operator and the
    null Coalesce operator. Also, we discussed the uniform variable syntax and a few
    other new features, such as new syntax for the contact array definition, options
    array for the `session_start()` function, and removal of multiple default cases
    in the switch statement.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了新的面向对象编程功能，如类型提示、匿名类、可抛出接口、命名空间的组合使用声明以及两个重要的新运算符，太空船或组合比较运算符和null合并运算符。此外，我们还讨论了统一的变量语法和其他一些新功能，如联系数组定义的新语法、`session_start()`函数的选项数组以及在switch语句中删除多个默认情况。
- en: In the next chapter, we will discuss how to improve the application's performance.
    We will discuss Apache and NGINX and different settings for them to improve performance.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何提高应用程序的性能。我们将讨论Apache和NGINX以及它们的不同设置以提高性能。
- en: We will discuss different settings for PHP to improve its performance. The Google
    page speed module, CSS/JavaScript combining and compression, CDN, and so on will
    also be discussed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论不同的PHP设置，以提高其性能。还将讨论Google页面速度模块、CSS/JavaScript合并和压缩、CDN等。
