- en: Applying Recursive Algorithms - Recursion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用递归算法 - 递归
- en: 'Solving complex problems is always hard. Even for programmers, solving complex
    problems can prove tougher, and sometimes, a special solution is required. Recursion
    is one such special approach that computer programmers follow to solve complex
    problems. In this chapter, we will go through the definition of recursion, properties,
    different types of recursions, and lots of examples. Recursion is not a new concept;
    in nature, we see lots of recursive elements. Fractals show recursive behavior.
    The following image shows natural recursion:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 解决复杂问题总是很困难的。即使对于程序员来说，解决复杂问题也可能更加困难，有时需要特殊的解决方案。递归是计算机程序员用来解决复杂问题的一种特殊方法。在本章中，我们将介绍递归的定义、属性、不同类型的递归以及许多示例。递归并不是一个新概念；在自然界中，我们看到许多递归元素。分形展现了递归行为。以下图像显示了自然递归：
- en: '![](Image00032.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00032.jpg)'
- en: Understanding recursion
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解递归
- en: Recursion is a way to solve larger problems by dividing them into smaller problems.
    In other words, recursion is breaking the big problem into smaller similar problems
    to solve them and get the actual results. Often, recursion is termed as a function
    calling itself. It might sound strange, but the fact is the function must call
    itself when it is in recursion. What does this look like? Let's look at an example,
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是通过将大问题分解为小问题来解决更大问题的一种方法。换句话说，递归是将大问题分解为更小的相似问题来解决它们并获得实际结果。通常，递归被称为函数调用自身。这可能听起来很奇怪，但事实是当函数递归时，函数必须调用自身。这是什么样子？让我们看一个例子，
- en: 'In mathematics, the term "factorial" is very popular. A factorial of a number
    *N* is defined as multiplication of all positive integers less than and equal
    to *N* . It is always denoted with *!* (an exclamation mark). So, a factorial
    of *5* can be written as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，“阶乘”这个术语非常流行。数字*N*的阶乘被定义为小于等于*N*的所有正整���的乘积。它总是用*!*（感叹号）表示。因此，*5*的阶乘可以写成如下形式：
- en: '*5! = 5 X 4 X 3 X 2 X 1*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*5! = 5 X 4 X 3 X 2 X 1*'
- en: 'Similarly, we can write the following factorials of the given number::'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以写出给定数字的以下阶乘：
- en: '*4! = 4 X 3 X 2 X 1*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*4! = 4 X 3 X 2 X 1*'
- en: '*3! = 3 X 2 X 1*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*3! = 3 X 2 X 1*'
- en: '*2! = 2 X 1*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*2! = 2 X 1*'
- en: '*1! = 1*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*1! = 1*'
- en: 'If we look closely at our example, we can see that we can write factorial of
    *5* in terms of factorials of *4* like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察我们的例子，我们可以看到我们可以用*4*的阶乘来表示*5*的阶乘，就像这样：
- en: '*5! = 5 X 4!*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*5! = 5 X 4!*'
- en: 'Similarly, we can write:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以写成：
- en: '*4! = 4 X 3!*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*4! = 4 X 3!*'
- en: '*3! = 3 X 2!*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*3! = 3 X 2!*'
- en: '*2! = 2 X 1!*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*2! = 2 X 1!*'
- en: '*1! = 1 X 0!*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*1! = 1 X 0!*'
- en: '*0! = 1*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*0! = 1*'
- en: 'Alternatively, we can simply say in general terms that:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以简单地说一般来说：
- en: '*n! = n * (n-1)!*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*n! = n * (n-1)!*'
- en: 'This represents recursion. We are breaking each of the steps into smaller ones
    and solving the actual big problem. Here is an image to show how a factorial of
    3 is calculated:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了递归。我们将每个步骤分解成更小的步骤，并解决实际的大问题。这里有一张图片展示了如何计算3的阶乘：
- en: '![](Image00033.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00033.jpg)'
- en: 'So, the steps are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，步骤如下：
- en: '*3! = 3 X 2!*'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*3! = 3 X 2!*'
- en: '*2! = 2 X 1!*'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*2! = 2 X 1!*'
- en: '*1! = 1 X 0!*'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*1! = 1 X 0!*'
- en: '*0! = 1*'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*0! = 1*'
- en: '*1! = 1 X 1 = 1*'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*1! = 1 X 1 = 1*'
- en: '*2! = 2 X 1 = 2*'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*2! = 2 X 1 = 2*'
- en: '*3! = 3 X 2 = 6*'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*3! = 3 X 2 = 6*'
- en: Properties of recursive algorithms
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归算法的属性
- en: 'Now, the question can be, "If a function calls itself, then how does it stop
    or know when to finish the recursive call?" When we are writing a recursive solution,
    we have to make sure it has the following properties:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题可能是，“如果一个函数调用自身，那么它如何停止或知道何时完成递归调用？”当我们编写递归解决方案时，我们必须确保它具有以下属性：
- en: Each recursive call should be on a smaller subproblem. Like the factorial example,
    a factorial of 6 is solved with 6 and multiplication of a factorial of 5 and so
    it goes on.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个递归调用都应该是一个更小的子问题。就像阶乘的例子，6的阶乘是用6和5的阶乘相乘来解决的，依此类推。
- en: It must have a base case. When the base case is reached, there will be no further
    recursion, and the base case must be able to solve the problem without any further
    recursive call. In our factorial example, we did not go any further down from
    0\. So, in this case, 0 is our base case.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它必须有一个基本情况。当达到基本情况时，将不会有进一步的递归，并且基本情况必须能够解决问题，而不需要进一步的递归调用。在我们的阶乘示例中，我们没有从0进一步。所以，在这种情况下，0是我们的基本情况。
- en: There should not be any cycle. If each recursive call makes a call to the same
    problem, then there will be a never-ending cycle. After some repetitions, the
    computer will show a stack overflow error.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不应该有任何循环。如果每个递归调用都调用同一个问题，那么将会有一个永无止境的循环。经过一些重复后，计算机将显示堆栈溢出错误。
- en: 'So, if we now write our factorial program using PHP 7, then it will look like
    this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们现在使用PHP 7编写我们的阶乘程序，那么它将如下所示：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding example code, we can see that we have a base condition where
    we are returning `1` when the value of `$n` is `0` . If this condition is not
    met, then we are returning a multiplication of `$n` and a factorial of `$n-1`
    . So, it satisfies property to both numbers, 1 and 3\. We are avoiding cycles
    and also making sure each recursive call is creating a subproblem of the bigger
    one. We will write the recursive behavior like this algorithm:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，我们可以看到我们有一个基本条件，当$n$的值为$0$时，我们返回`1`。如果不满足这个条件，那么我们返回$n$的乘积和$n-1$的阶乘。所以，它满足1和3这两个数字的属性。我们避免了循环，并确保每个递归调用都创建了一个更大的子问题。我们将像这样编写递归行为的算法：
- en: '![](Image00034.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00034.jpg)'
- en: Recursion versus iterative algorithms
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归与迭代算法
- en: 'If we analyze our factorial function, we can see that it could be written using
    a simple iterative approach with a `for` or `while` loop, as shown here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分析我们的阶乘函数，我们可以看到它可以使用简单的迭代方法来编写，使用`for`或`while`循环，如下所示：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If this can be written as a simple iterative one, then why should we use recursion?
    Recursion is used to solve more complex problems. Not all problems can be solved
    iteratively so easily. For example, we need to show all the files in a certain
    directory. We can simply do this by running a loop to list all the files. However,
    what if there is another directory inside it? Then, we have to run another loop
    to get all those files inside that directory. What if there is another directory
    inside that directory and it goes on and on? In such a situation, an iterative
    approach might not help at all or might create a complex solution. It is better
    to choose a recursive approach here.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这可以写成一个简单的迭代形式，那么为什么要使用递归呢？递归用于解决更复杂的问题。并非所有问题都可以如此轻松地迭代解决。例如，我们需要显示某个目录中的所有文件。我们可以通过运行循环来列出所有文件来简单地做到这一点。但是，如果里面还有另一个目录呢？那么，我们必须运行另一个循环来获取该目录中的所有文件。如果该目录中还有另一个目录，依此类推呢？在这种情况下，迭代方法可能根本无济于事，或者可能会产生一个复杂的解决方案。在这里最好选择递归方法。
- en: Recursion manages a call stack for managing function calls. As a result, recursion
    will take more memory and time to complete compared to iteration. Also, in iteration,
    in each step, we can have a result, but for recursion, we have to wait until the
    base case to execute to get any result. If we consider both iterative and recursive
    examples for a factorial, we can see that there is a local variable called `$result`
    to store the calculation of each step. However, in recursion, there is no need
    for local variables or assignment.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 递归管理一个调用堆栈来管理函数调用。因此，与迭代相比，递归将需要更多的内存和时间来完成。此外，在迭代中，每一步都可以得到一个结果，但对于递归，我们必须等到基本情况执行才能得到任何结果。如果我们考虑阶乘的迭代和递归示例，我们可以看到有一个名为`$result`的局部变量来存储每一步的计算。然而，在递归中，不需要局部变量或赋值。
- en: Implementing Fibonacci numbers using recursion
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用递归实现斐波那契数
- en: 'In mathematics, Fibonacci numbers are special integer sequences where a number
    is composed from summation of the past two numbers, as shown in the following
    the expression:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，斐波那契数是特殊的整数序列，其中一个数字由过去两个数字的求和组成，如下所示的表达式：
- en: '![](Image00035.gif)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00035.gif)'
- en: 'If we implement this using PHP 7, it will look like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用PHP 7来实现，它将如下所示：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we consider the preceding implementation, we can see it is a bit different
    from the previous examples. Now, we are calling two functions from one function
    call. We will discuss different types of recursions shortly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑前面的实现，可以看到它与以前的示例有些不同。现在，我们从一个函数调用中调用两个函数。我们将很快讨论不同类型的递归。
- en: Implementing GCD calculation using recursion
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用递归实现GCD计算
- en: 'Another common use of recursion is implementing **Greatest Common Division**
    (**GCD** ) of two numbers. In GCD calculation, we will continue until a remainder
    becomes 0\. It can be expressed as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的另一个常见用途是实现两个数字的**最大公约数**（**GCD**）计算。在GCD计算中，我们会一直进行下去，直到余数变为0。可以表示如下：
- en: '![](Image00036.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00036.jpg)'
- en: 'Now, if we implement recursively using PHP 7, it will look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用PHP 7进行递归实现，它将如下所示：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Another interesting part of this implementation is that unlike a factorial,
    we are not returning from a base case to other steps in the call stack. The base
    case will return the calculated value. This is one of the optimized ways to do
    recursion.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的另一个有趣部分是，与阶乘不同，我们不是从基本情况返回到调用堆栈中的其他步骤。基本情况将返回计算出的值。这是递归的一种优化方式。
- en: Different types of recursions
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的递归
- en: So far, we have seen some example cases of recursion and how it is being used.
    Though the term says recursion, there are different types of recursions. We will
    explore them one by one.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一些递归的示例案例以及它的使用方式。尽管术语是递归，但有不同类型的递归。我们将逐一探讨它们。
- en: Linear recursion
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性递归
- en: One of the most commonly used recursions in the programming world is linear
    recursion. When a function calls itself once in each run, we will call it a linear
    recursion. Just like our factorial example, when we are breaking the big calculation
    to smaller ones until the base condition is reached, we call it winding. When
    we are returning from the base condition to the first recursive call, we call
    it unwinding. We will work on different linear recursions in the upcoming section
    in this chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程世界中最常用的递归之一是线性递归。当一个函数在每次运行中只调用自身一次时，我们将其称为线性递归。就像我们的阶乘示例一样，当我们将大的计算分解为较小的计算，直到达到基本条件时，我们称之为缠绕。当我们从基本条件返回到第一个递归调用时，我们称之为展开。在本章的后续部分中，我们将研究不同的线性递归。
- en: Binary recursion
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制递归
- en: 'In binary recursion, the function calls itself twice in each run. As a result,
    the calculation depends on two results from two different recursive calls to itself.
    If we look at our Fibonacci sequence generation recursive function, we can easily
    find that it is a binary recursion. Other than this, we have many commonly used
    binary recursions in the programming world, such as binary search, divide and
    conquer, merge sort, and so on. The following image shows a binary recursion:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制递归中，函数在每次运行中调用自身两次。因此，计算取决于对自身的两个不同递归调用的结果。如果我们看看我们的斐波那契序列生成递归函数，我们很容易发现它是一个二进制递归。除此之外，在编程世界中，我们还有许多常用的二进制递归，如二分查找、分治、归并排序等。下图显示了一个二进制递归：
- en: '![](Image00037.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00037.jpg)'
- en: Tail recursion
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尾递归
- en: A recursive method is tail recursive when there is no pending operation to be
    performed on return. For example, in our factorial code, the returned value is
    used to multiply with the previous value to calculate the factorial. So, this
    is not tail recursive. The same goes for the Fibonacci series recursion. If we
    look at our GCD recursion, we can find that there is no operation to do after
    the return. So, the final return or base case return is actually the answer. So,
    GCD is an example of tail recursion. Tail recursion is also a form of linear recursion.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回时没有待处理的操作时，递归方法是尾递归。例如，在我们的阶乘代码中，返回的值用于与前一个值相乘以计算阶乘。因此，这不是尾递归。斐波那契数列递归也是如此。如果我们看看我们的最大公约数递归，我们会发现在返回后没有要执行的操作。因此，最终返回或基本情况返回实际上就是答案。因此，最大公约数是尾递归的一个例子。尾递归也是线性递归的一种形式。
- en: Mutual recursion
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相互递归
- en: It might be the case that we may require to call two different methods recursively
    from two different methods in an alternate fashion. For example, function `A()`
    calls function `B()` and function `B()` calls function `A()` in each call. This
    is known as mutual recursion.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现这样的情况，我们可能需要从两个不同的方法中交替地递归调用两个不同的方法。例如，函数 `A()` 调用函数 `B()`，函数 `B()` 在每次调用中调用函数
    `A()`。这被称为相互递归。
- en: Nested recursion
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套递归
- en: 'When a recursive function call has itself as the parameter, then it is called
    nested recursion. One of the common examples of nested recursion is the Ackermann
    function. Look at the following equation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当递归函数调用自身作为参数时，它被称为嵌套递归。嵌套递归的一个常见例子是 Ackermann 函数。看看下面的方程：
- en: '![](Image00038.gif)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00038.gif)'
- en: If we look at the last line, we can see that function `A ()` is called recursively,
    but the second parameter itself is another recursive call. So, this is one of
    the examples of nested recursions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看最后一行，我们可以看到函数 `A()` 被递归调用，但第二个参数本身是另一个递归调用。因此，这是嵌套递归的一个例子。
- en: Though there are different types of recursions available, we will only use those
    that are required based on our needs. Now, we will see some real-life usage of
    recursion in our projects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有不同类型的递归可用，但我们只会根据我们的需求使用那些必需的。现在，我们将看到递归在我们的项目中的一些实际用途。
- en: Building an N-level category tree using recursion
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用递归构建 N 级类别树
- en: 'Building a multilevel nested category tree or menu is always a problem. Many
    CMS and sites only allow a certain level of nesting. In order to save performance
    issues due to multiple joins, some only allow 3-4 levels of nesting at maximum.
    Now, we will explore how we can create an N-level nested category tree or menu
    with the help of recursion, without compromising on performance. Here is our approach
    for the solution:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 构建多级嵌套的类别树或菜单总是一个问题。许多 CMS 和网站只允许一定级别的嵌套。为了避免由于多次连接而导致的性能问题，一些只允许最多3-4级的嵌套。现在，我们将探讨如何利用递归创建一个
    N 级嵌套的类别树或菜单，而不会影响性能。以下是我们解决方案的方法：
- en: We will define the table structure for the category in the database.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为数据库中的类别定义表结构。
- en: We will get all categories in the table without the use of any join or multiple
    queries. It will be a single database query with a simple select statement.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在不使用任何连接或多个查询的情况下获取表中的所有类别。这将是一个带有简单选择语句的单个数据库查询。
- en: We will build an array of categories such that we can utilize the recursion
    with that to display the nested categories or menu.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将构建一个类别数组，以便我们可以利用递归来显示嵌套的类别或菜单。
- en: 'Let''s assume that we have a simple table structure in our database to store
    our categories and it looks like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们的数据库中有一个简单的表结构来存储我们的类别，它看起来像这样：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For simplicity, we are assuming that there is no other field required in the
    table. Also, we have some data in the table like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们假设表中不需要其他字段。此外，我们的表中有一些数据如下：
- en: '| **Id** | **categoryName** | **parentCategory** | **sortInd** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **Id** | **类别名称** | **父类别** | **排序索引** |'
- en: '| 1 | First | 0 | 0 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 第一 | 0 | 0 |'
- en: '| 2 | Second | 1 | 0 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 第二 | 1 | 0 |'
- en: '| 3 | Third | 1 | 1 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 第三 | 1 | 1 |'
- en: '| 4 | Fourth | 3 | 0 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 第四 | 3 | 0 |'
- en: '| 5 | Fifth | 4 | 0 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 第五 | 4 | 0 |'
- en: '| 6 | Sixth | 5 | 0 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 第六 | 5 | 0 |'
- en: '| 7 | Seventh | 6 | 0 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 第七 | 6 | 0 |'
- en: '| 8 | Eight | 7 | 0 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 第八 | 7 | 0 |'
- en: '| 9 | Ninth | 1 | 0 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 第九 | 1 | 0 |'
- en: '| 10 | Tenth | 2 | 1 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 第十 | 2 | 1 |'
- en: 'Now, we have created a table structured for our database, and we have assumingly
    also entered some sample data. Let''s build a query to retrieve this data so that
    we can move to our recursive solution:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为我们的数据库创建了一个结构化的表，并且我们也假设输入了一些示例数据。让我们构建一个查询来检索这些数据，以便我们可以转移到我们的递归解决方案：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The core part of the preceding code is how we are storing our categories in
    an array. We are storing the results based on their parent category. This will
    help us show child categories of a category recursively. This looks pretty simple.
    Now, based on the categories array, let''s write the recursive function to show
    the categories hierarchically:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的核心部分是我们如何将我们的类别存储在数组中。我们根据它们的父类别存储结果。这将帮助我们递归地显示类别的子类别。这看起来非常简单。现在，基于类别数组，让我们编写递归函数以分层显示类别：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code actually shows all the categories and their child categories
    recursively. We take a level and first print the category on that level. Immediately,
    we will check whether it has any child level categories or not with the code `showCategoryTree($categories,
    $category->id)` . Now, if we call the recursive function with a root level (level
    0), then we will have the following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码实际上显示了所有类别及其子类别的递归。我们取一个级别，首先打印该级别上的类别。接着，我们将检查它是否有任何子级别的类别，使用代码 `showCategoryTree($categories,
    $category->id)`。现在，如果我们用根级别（级别0）调用递归函数，那么我们将得到以下输出：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output for this will be as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see, without thinking about the depth of the category level or multiple
    queries, we can build nested categories or menus with just a simple query and
    recursive function. We can use `<ul>` and `<li>` to create a nested menu if we
    want it with dynamic show and hide functionality. This can be vital for having
    an efficient solution to the problem without getting into implementation blocks,
    such as having a fixed level of joins or fixed level of categories. The preceding
    example is a perfect display of tail recursion where we are not waiting for the
    recursion to return anything, and as we move forward, the results are already
    displayed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，不需要考虑类别级别的深度或多个查询，我们可以只用一个简单的查询和递归函数构建嵌套类别或菜单。如果需要动态显示和隐藏功能，我们可以使用`<ul>`和`<li>`来创建嵌套菜单。这对于在不涉及实现阻碍的情况下获得问题的有效解决方案非常重要，比如具有固定级别的连接或固定级别的类别。前面的示例是尾递归的完美展示，在这里我们不需要等待递归返回任何东西，随着我们的前进，结果已经显示出来了。
- en: Building a nested comment reply system
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建嵌套的评论回复系统
- en: 'Quite often, we face the challenge to display comment replies in a proper way.
    Showing them chronologically does not fit our need sometimes. We may require showing
    them in such a way that the reply for each comment is below the actual comment
    itself. In other words, we can say we need a nested comment reply system or threaded
    comments. We want to build something similar to the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常面临的挑战是以适当的方式显示评论回复。按时间顺序显示它们有时不符合我们的需求。我们可能需要以这样的方式显示它们，即每条评论的回复都在实际评论本身下面。换句话说，我们可以说我们需要一个嵌套的评论回复系统或者线程化评论。我们想要构建类似以下截图的东西：
- en: '![](Image00039.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00039.jpg)'
- en: 'We can follow the same steps we did in the nested category section. However,
    this time, we will have some UI elements to give it a more realistic look. Let''s
    assume that we have a table named `comments` with the following data and columns.
    For simplicity, we are not going into multiple table relationships. We are assuming
    that the usernames are stored in the same table with the comments:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照嵌套类别部分所做的相同步骤进行。但是，这一次，我们将有一些UI元素，使其看起来更真实。假设我们有一个名为`comments`的表，其中包含以下数据和列。为简单起见，我们不涉及多个表关系。我们假设用户名存储在与评论相同的表中：
- en: '| **Id** | **comments** | **username** | **Datetime** | **parentID** | **postID**
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '**Id** | **评论** | **用户名** | **日期时间** | **父ID** | **帖子ID**'
- en: '| 1 | First comment | Mizan | 2016-10-01 15:10:20 | 0 | 1 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: 1 | 第一条评论 | Mizan | 2016-10-01 15:10:20 | 0 | 1
- en: '| 2 | First reply | Adiyan | 2016-10-02 04:09:10 | 1 | 1 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: 2 | 第一条回复 | Adiyan | 2016-10-02 04:09:10 | 1 | 1
- en: '| 3 | Reply of first reply | Mikhael | 2016-10-03 11:10:47 | 2 | 1 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: 3 | 第一条回复的回复 | Mikhael | 2016-10-03 11:10:47 | 2 | 1
- en: '| 4 | Reply of reply of first reply | Arshad | 2016-10-04 21:22:45 | 3 | 1
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: 4 | 第一条回复的回复的回复 | Arshad | 2016-10-04 21:22:45 | 3 | 1
- en: '| 5 | Reply of reply of reply of first reply | Anam | 2016-10-05 12:01:29 |
    4 | 1 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: 5 | 第一条回复的回复的回复的回复 | Anam | 2016-10-05 12:01:29 | 4 | 1
- en: '| 6 | Second comment | Keith | 2016-10-01 15:10:20 | 0 | 1 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: 6 | 第二条评论 | Keith | 2016-10-01 15:10:20 | 0 | 1
- en: '| 7 | First comment of second post | Milon | 2016-10-02 04:09:10 | 0 | 2 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: 7 | 第二篇帖子的第一条评论 | Milon | 2016-10-02 04:09:10 | 0 | 2
- en: '| 8 | Third comment | Ikrum | 2016-10-03 11:10:47 | 0 | 1 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: 8 | 第三条评论 | Ikrum | 2016-10-03 11:10:47 | 0 | 1
- en: '| 9 | Second comment of second post | Ahmed | 2016-10-04 21:22:45 | 0 | 2 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: 9 | 第二篇帖子的第二条评论 | Ahmed | 2016-10-04 21:22:45 | 0 | 2
- en: '| 10 | Reply of second comment of second post | Afsar | 2016-10-18 05:18:24
    | 9 | 2 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: 10 | 第二篇帖子的第二条评论的回复 | Afsar | 2016-10-18 05:18:24 | 9 | 2
- en: 'Let''s now write a prepared statement to fetch all the comments from a post.
    Then, we can construct an array similar to the nested category one:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个准备好的语句来从帖子中获取所有评论。然后，我们可以构建一个类似嵌套类别的数组：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we have the array and all required data in it; we can now write a function
    that will call recursively to display the comment with proper indentations:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了数组和其中的所有必需数据；我们现在可以编写一个函数，该函数将递归调用以正确缩进显示评论：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since we have added some HTML elements in the PHP code, we need some basic
    CSS to make it work. Here is the CSS code we have written to make it a clean design.
    Nothing fancy, but pure CSS to create the cascading effects and some basic styling
    for each section of the comment:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在PHP代码中添加了一些HTML元素，因此我们需要一些基本的CSS来使其工作。这是我们编写的CSS代码，用于创建清晰的设计。没有花哨的东西，只是纯CSS来创建级联效果和对评论每个部分的基本样式：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As mentioned earlier, we are not trying to make something complex here, just
    responsive, device friendly, and so on. We are assuming that you can integrate
    the logic in different parts of your application without any problem.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，我们在这里并不试图做一些复杂的东西，只是响应式的，设备友好的等等。我们假设您可以在应用程序的不同部分集成逻辑而不会出现任何问题。
- en: 'Here is the output from the data and the preceding code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据和前面代码的输出：
- en: '![](Image00040.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00040.jpg)'
- en: From the preceding two examples, we can see that it is very easy to create nested
    contents without having multiple queries or having a limitation of join statements
    for nesting. We do not even require a self-join to generate the nested data.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的两个示例中，我们可以看到，很容易创建嵌套内容，而无需多个查询或对嵌套的连接语句有限制。我们甚至不需要自连接来生成嵌套数据。
- en: Finding files and directories using recursion
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用递归查找文件和目录
- en: 'Quite often, we need to find all the files inside a directory. This includes
    all subdirectories inside it and also directories inside those subdirectories.
    As a result, we need a recursive solution to find the list of files from the given
    directory. The following example will show a simple recursive function to list
    all the files in a directory:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要找到目录中的所有文件。这包括其中所有的子目录，以及这些子目录中的目录。因此，我们需要一个递归解决方案来找到给定目录中的文件列表。以下示例将展示一个简单的递归函数来列出目录中的所有文件：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `showFiles` function actually takes a directory and first scans the directory
    to list all the files and directories under it. Then, with a `foreach` loop, it
    iterates through each file and directory. If it is a directory, we recall the
    `.` function again to list the files and directories under it. This continues
    until we traverse all the files and directories. Now, we have all the files under
    the `$files` array. Now, let''s show the files using a `foreach` loop sequentially:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`showFiles` 函数实际上接受一个目录，并首先扫描目录以列出其中的所有文件和目录。然后，通过 `foreach` 循环，它遍历每个文件和目录。如果是一个目录，我们再次调用
    `.` 函数以列出其中的文件和目录。这将继续，直到我们遍历所有文件和目录。现在，我们有了 `$files` 数组下的所有文件。现在，让我们使用 `foreach`
    循环顺序显示文件：'
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will have the following output in the command line:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在命令行中产生以下输出：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These were solutions for some common challenges we face during development.
    However, there are other places where we will use recursion heavily, such as binary
    search, trees, divide and conquer algorithm, and so on. We will discuss them in
    the upcoming chapters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们在开发过程中面临的一些常见挑战的解决方案。然而，还有其他地方我们将大量使用递归，比如二进制搜索、树、分治算法等。我们将在接下来的章节中讨论它们。
- en: Analyzing recursive algorithms
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析递归算法
- en: 'Analysis of recursive algorithms depends on the type of recursion we are using.
    If it is linear, the complexity will be different; if it is binary, it will have
    a different complexity. So, we do not have a generic complexity for the recursive
    algorithms. We have to analyze it on a case-by-case basis. Here, we will analyze
    factorial series. First, let''s focus on the factorial part. If we recall from
    this section, we had something like this for factorial recursion:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 递归算法的分析取决于我们使用的递归类型。如果是线性的，复杂度将不同；如果是二进制的，复杂度也将不同。因此，递归算法没有通用的复杂度。我们必须根据具体情况进行分析。在这里，我们将分析阶乘序列。首先，让我们专注于阶乘部分。如果我们回忆一下这一节，我们对阶乘递归有这样的东西：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s assume that it will take `T(n)` to compute factorial (`$n` ). We will
    focus on how to use this `T(n)` in terms of the Big O notation. Each time we call
    the factorial function, there are certain steps involved:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设计算阶乘（`$n`）需要 `T(n)`。我们将专注于如何使用大O符号表示这个 `T(n)`。每次调用阶乘函数时，都涉及某些步骤：
- en: Every time, we are checking the base case.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次，我们都在检查基本情况。
- en: Then, we call factorial (`$n-1` ) on each loop.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在每个循环中调用阶乘（`$n-1`）。
- en: We do a multiplication with `$n` on each loop.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在每个循环中用 `$n` 进行乘法。
- en: Then, we return the result.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们返回结果。
- en: 'Now, if we represent this using `T(n)` , then we can say:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们用 `T(n)` 表示这个，那么我们可以说：
- en: '*T(n) = a when n = 0*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*T(n) = 当 n = 0 时，a*'
- en: '*T(n) = T(n-1) + b when n > 0*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*T(n) = 当 n > 0 时，T(n-1) + b*'
- en: 'Here, both *a* and *b* are some constants. Now, let''s generate a relationship
    between *a* and *b* with *n* . We can easily write the equation as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*a* 和 *b* 都是一些常数。现在，让我们用 *n* 生成 *a* 和 *b* 之间的关系。我们可以轻松地写出以下方程：
- en: '*T(0) = a*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*T(0) = a*'
- en: '*T(1) = T(0) + b = a + b*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*T(1) = T(0) + b = a + b*'
- en: '*T(2) = T(1) + b = a + b + b = a + 2b*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*T(2) = T(1) + b = a + b + b = a + 2b*'
- en: '*T(3) = T(2) + b = a + 2b + b = a + 3b*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*T(3) = T(2) + b = a + 2b + b = a + 3b*'
- en: '*T(4) = T(3) + b = a + 3b + b = a + 4b*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*T(4) = T(3) + b = a + 3b + b = a + 4b*'
- en: 'We can see that a pattern is emerging here. So, we can establish that:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里出现了一个模式。因此，我们可以确定：
- en: '*T(n) = a + (n) b*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*T(n) = a + (n) b*'
- en: Alternatively, we can also say in simple terms that `T(n) = O(n)` .
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以简单地说 `T(n) = O(n)`。
- en: So, the factorial recursion has a linear complexity of `O(n)` .
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，阶乘递归具有线性复杂度 `O(n)`。
- en: A fibonacci sequence with recursion has approximately `O(2^n )` complexity.
    The calculation is very elaborative as we have to consider both the lower bound
    and upper bound for the Big O notation. In the upcoming chapters, we will also
    analyze binary recursion such as binary search and merge sorts. We will focus
    more on recursive analysis in those chapters.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 具有递归的斐波那契序列大约具有 `O(2^n)` 的复杂度。计算非常详细，因为我们必须考虑大O符号的下界和上界。在接下来的章节中，我们还将分析二进制递归，如二进制搜索和归并排序。我们将在这些章节中更多地关注递归分析。
- en: Maximum recursion depth in PHP
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP中的最大递归深度
- en: 'Since recursion is the process when a function calls itself, we can have a
    valid question in mind such as "how deep can we go with this recursion?". Let''s
    do a small program for this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于递归是函数调用自身的过程，我们可以心中有一个有效的问题，比如“这个递归可以有多深？”。让我们为此编写一个小程序：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Can we guess the max depth level? The depth reached 917,056 levels before exhausting
    the memory limit. If **XDebug** is enabled, then the limit will be much less compared
    to this. It also depends on your memory, OS, and PHP settings such as memory limit
    and max execution time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能猜测最大深度水平吗？在耗尽内存限制之前，深度达到了917,056级。如果启用了**XDebug**，那么限制将比这个小得多。这也取决于您的内存、操作系统和PHP设置，如内存限制和最大执行时间。
- en: Though we have the option to go very deep with our recursion, it is always important
    to remember that we must have control with our recursive function. We should know
    the base conditions and where the recursion must end. Otherwise, it might create
    some wrong results or end abruptly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们有选择深入进行递归，但始终重要的是要记住，我们必须控制好我们的递归函数。我们应该知道基本条件以及递归必须在何处结束。否则，可能会产生一些错误的结果或突然结束。
- en: Using SPL recursive iterators
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SPL递归迭代器
- en: 'The Standard PHP Library SPL has many built-in iterators for recursion purposes.
    We can use them as per our need, without taking the pain of implementing them
    from scratch. Here is the list of iterators and their functionality:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 标准PHP库SPL有许多内置的迭代器，用于递归目的。我们可以根据需要使用它们，而不必费力实现它们。以下是迭代器及其功能的列表：
- en: '**RecursiveArrayIterator** : This recursive iterator allows iterating over
    any type of array or objects and modifying the key or values or unsetting them.
    It also allows iterating over the current iterator entry.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RecursiveArrayIterator**：这个递归迭代器允许迭代任何类型的数组或对象，并修改键或值，或取消它们。它还允许迭代当前迭代器条目。'
- en: '**RecursiveCallbackFilterIterator** :If we are looking forward to applying
    a callback recursively to any array or objects, this iterator can be very helpful.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归回调过滤迭代器：如果我们希望递归地将回调应用于任何数组或对象，这个迭代器可以非常有帮助。
- en: '**RecursiveDirectoryIterator** : This iterator allows iterating any directory
    or filing systems. It makes the directory listing very easy. For example, we can
    rewrite the directory listing program we wrote in this chapter easily using this
    iterator:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归目录迭代器：这个迭代器允许迭代任何目录或文件系统。它使得目录列表非常容易。例如，我们可以很容易地使用这个迭代器重新编写本章中编写的目录列表程序：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**RecursiveFilterIterator:** If we are looking for a filter option in our iteration
    recursively, we can use this abstract iterator to implement the filtering part.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归过滤迭代器：如果我们在迭代过程中递归地寻找过滤选项，我们可以使用这个抽象迭代器来实现过滤部分。
- en: '**RecursiveIteratorIterator:** If we want to iterate over any recursive iterator,
    we can use this one. It is already built-in, and we can easily apply it. An example
    of how it is used is shown in the directory iterator section in the `RecursiveDirectoryIterator`
    section.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归迭代迭代器：如果我们想要迭代任何递归迭代器，我们可以使用这个。它已经内置，我们可以很容易地应用它。在“RecursiveDirectoryIterator”部分中显示了它的使用示例。
- en: '**RecursiveRegexIterator:** If you want to apply a regular expression to filter
    an iterator, we can use this iterator along with other iterators.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归正则表达式迭代器：如果您想要应用正则表达式来过滤迭代器，我们可以使用这个迭代器以及其他迭代器。
- en: '**RecursiveTreeIterator:** The recursive tree iterator allows us to create
    a graphical representation like a tree for any directory or multidimensional array.
    For example, the following football team list array will produce a tree structure:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归树迭代器：递归树迭代器允许我们为任何目录或多维数组创建类似树的图形表示。例如，以下足球队列表数组将产生树结构：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output will look like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using the PHP built-in function array_walk_recursive
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP内置函数array_walk_recursive
- en: The `array_walk_recursive` can be a very handy built-in function for PHP as
    it can traverse any size of array recursively and apply a callback function. Whether
    we want to find whether an element is in a multidimensional array or not, or get
    the total sum of the array of the multidimensional array, we can use this function
    without any problem.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_walk_recursive`可以是PHP中非常方便的内置函数，因为它可以递归地遍历任何大小的数组并应用回调函数。无论我们想要找出多维数组中是否存在元素，还是获取多维数组的总和，我们都可以毫无问题地使用这个函数。'
- en: 'The following code sample will produce an output of **136** when executed:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码示例将产生输出**136**：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The other two built-in recursive array functions in PHP are `array_merge_recursive`
    and `array_replace_recursive` . We can use them to merge multiple arrays to one
    or replace from multiple arrays, respectively.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中的另外两个内置递归数组函数是`array_merge_recursive`和`array_replace_recursive`。我们可以使用它们来合并多个数组到一个数组中，或者从多个数组中替换，分别。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: So far, we discussed different properties and practical usage of recursion.
    We have seen how to do the analysis of recursive algorithms. Computer programming
    and recursion are two inseparable parts. The usage of recursion is almost everywhere
    in the programming world. In the upcoming chapters, we will explore it more and
    apply wherever it's applicable. In the next chapter, we will discuss another special
    data structure called "tree".
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了递归的不同属性和实际用途。我们已经看到了如何分析递归算法。计算机编程和递归是两个不可分割的部分。递归的使用几乎无处不在于编程世界中。在接下来的章节中，我们将更深入地探讨它，并在适用的地方应用它。在下一章中，我们将讨论另一个特殊的数据结构，称为“树”。
