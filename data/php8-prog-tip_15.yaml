- en: '*Chapter 12*: Creating PHP 8 Applications Using Asynchronous Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：使用异步编程创建PHP 8应用程序'
- en: 'In recent years, an exciting new technology has taken the **PHP: Hypertext
    Preprocessor** (**PHP**) community by storm: **asynchronous programming**, also
    known as **PHP async**. The asynchronous programming model addresses an issue
    present in any application code written using the traditional synchronous mode
    of programming: your application is forced to wait for certain tasks to complete
    before providing results. The **central processing unit** (**CPU**) (or CPUs)
    of the server upon which your application is running sits idle while mundane **input/output**
    (**I/O**) tasks are performed. PHP async allows your application to take full
    advantage of hardware resources by suspending blocking I/O tasks until later.
    The net effect is a massive increase in performance, as well as the ability to
    handle a geometrically larger number of user requests.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，一项令人兴奋的新技术席卷了PHP社区：异步编程，也被称为PHP async。异步编程模型解决了使用传统同步编程模式编写的应用程序代码中存在的问题：您的应用程序在提供结果之前被迫等待某些任务完成。服务器的中央处理单元（CPU）（或CPU）在执行乏味的输入/输出（I/O）任务时处于空闲状态。PHP
    async允许您的应用程序暂停阻塞的I/O任务直到以后。其净效果是性能大幅提升，以及处理更多用户请求的能力。
- en: After reading through this chapter and carefully studying the examples, you
    will be able to develop PHP async applications. In addition, you will be able
    to take advantage of the async capabilities of selected PHP extensions and frameworks.
    By the time you are done working through this chapter, you will be in a position
    to improve the performance of your applications, from 5 times up to a staggering
    *40 times faster*!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章并仔细研究示例后，您将能够开发PHP异步应用程序。此外，您将能够利用选定的PHP扩展和框架的异步能力。在完成本章的工作后，您将能够提高应用程序的性能，速度提高5倍甚至高达40倍！
- en: 'Topics covered in this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: Understanding the PHP async programming model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解PHP异步编程模型
- en: Using the Swoole extension
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Swoole扩展
- en: Using selected PHP frameworks in async mode
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在异步模式下使用选定的PHP框架
- en: Learning about PHP 8.1 fibers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习PHP 8.1纤程
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The minimum hardware required to examine and run the code examples provided
    in this chapter is listed here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的代码示例所需的最低硬件要求如下：
- en: x86_64 based desktop PC or laptop
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于x86_64的台式电脑或笔记本电脑
- en: 1 **gigabyte** (**GB**) free disk space
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1GB的免费磁盘空间
- en: 4 GB of **random-access memory** (**RAM**)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4GB的随机存取存储器（RAM）
- en: 500 **kilobits per second** (**Kbps**) or faster internet connection
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 500千位每秒或更快的互联网连接
- en: 'In addition, you will need to install the following software:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您需要安装以下软件：
- en: Docker
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Docker Compose
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Please refer to the *Technical requirements* section of [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013),
    *Introducing New PHP 8 OOP Features,* for more information on the Docker and Docker
    Compose installation, as well as how to build the Docker container used to demonstrate
    the code explained in this book. In this book, we refer to the directory in which
    you restored the sample code for the book as `/repo`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Docker和Docker Compose安装的更多信息，请参阅《第1章》《引入新的PHP 8 OOP功能》中的《技术要求》部分，以及如何构建用于演示本书中所解释的代码的Docker容器。在本书中，我们将您为本书恢复样本代码的目录称为“/repo”。
- en: 'The source code for this chapter is located here: [https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于此处：[https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices)。
- en: We can now begin our discussion by having a look at PHP async.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始讨论PHP异步。
- en: Understanding the PHP async programming model
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解PHP异步编程模型
- en: Before we get into the details of how to develop PHP applications using asynchronous
    libraries, it's important to step back and have a look at the PHP **asynchronous
    programming model**. Understanding the difference between this and the conventional
    **synchronous programming model** opens a new world of high performance for you
    to utilize when developing PHP applications. Let's first have a look at the synchronous
    programming model, after which we'll dive into async.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解如何使用异步库开发PHP应用程序之前，重要的是退后一步，看看PHP异步编程模型。了解这一点与传统的同步编程模型之间的区别，将为您在开发PHP应用程序时利用高性能的新世界打开大门。让我们先看看同步编程模型，然后再深入了解异步。
- en: Developing synchronous programming code
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发同步编程代码
- en: In traditional PHP programming, code executes in a linear fashion. Once the
    code has been compiled into machine code, the CPU executes the code one line after
    another in a sequential manner until the code ends. This is certainly true of
    PHP *procedural programming*. Surprising to some, this is also true for **object-oriented
    programming** (**OOP**) as well! Regardless of whether or not you use objects
    as part of your code, the OOP code gets compiled into first-byte code and then
    machine code, and is processed in a synchronous manner in exactly the same manner
    as is procedural code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的PHP编程中，代码是按线性方式执行的。一旦代码被编译成机器代码，CPU就会按顺序逐行执行代码，直到代码结束。这对于PHP过程式编程来说是正确的。令一些人感到惊讶的是，这对于面向对象编程（OOP）也是正确的！无论您是否在代码中使用对象，OOP代码都会被编译成第一字节代码，然后是机器代码，并以与过程式代码完全相同的同步方式进行处理。
- en: Using OPcache and the **Just-in-Time** (**JIT**) compiler has no bearing on
    whether or not the code operates in a synchronous manner. The only thing that
    OPcache and the JIT compiler bring to the table is the ability to operate synchronous
    code faster than was otherwise possible.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OPcache和**即时**（**JIT**）编译器对代码是否以同步方式运行没有影响。OPcache和JIT编译器带来的唯一好处是能够比以前更快地运行同步代码。
- en: Important note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please do not get the impression that there is something wrong with writing
    code using the synchronous programming model! This approach is not only tried
    and true but also quite successful. Furthermore, synchronous code is supported
    by many ancillary tools such as PHPUnit, Xdebug, numerous frameworks, and many
    others.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '请不要认为使用同步编程模型编写代码有什么问题！这种方法不仅经过验证，而且非常成功。此外，许多辅助工具（如PHPUnit、Xdebug、许多框架等）都支持同步代码。 '
- en: There is a major drawback to the synchronous programming model, however. Using
    this model, the CPU has to constantly wait for certain tasks to complete before
    the program is allowed to move along. To a large extent, such tasks include access
    to an external resource, such as making a database query, writing to a log file,
    or sending an email. Such tasks are referred to as **blocking operations** (operations
    that block progress).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，同步编程模型存在一个主要缺点。使用这种模型，CPU必须不断等待某些任务完成，然后程序才能继续进行。在很大程度上，这些任务包括访问外部资源，例如进行数据库查询，写入日志文件或发送电子邮件。这些任务被称为**阻塞操作**（阻塞进度的操作）。
- en: 'The following diagram gives you a visual representation of an application flow,
    which involves the blocking operations of writing to a log file and sending an
    email notification:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表为您提供了一个应用程序流程的可视化表示，其中涉及写入日志文件和发送电子邮件通知的阻塞操作：
- en: '![Figure 12.1 – Synchronous programming model'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 - 同步编程模型'
- en: '](image/Figure_12.1_B16992_B16992.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.1_B16992_B16992.jpg)'
- en: Figure 12.1 – Synchronous programming model
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 - 同步编程模型
- en: As you can see from *Figure 12.1*, when an application writes to a log file,
    the CPU puts a hold on program code execution until the **operating system** (**OS**)
    signals that the log file's write operation has finished. Later, the code might
    send out an email notification. Again, the CPU puts a hold on code execution until
    the email send operation has concluded. Although each waiting interval may be
    insignificant in and of itself, when you add together the waiting intervals for
    all such blocking operations—especially if lengthy loops are involved—performance
    starts to degrade.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从*图12.1*中所看到的，当应用程序写入日志文件时，CPU会暂停程序代码执行，直到**操作系统**（**OS**）发出信号表示日志文件的写入操作已经完成。稍后，代码可能会发送电子邮件通知。同样，CPU会暂停代码执行，直到电子邮件发送操作结束。尽管每个等待间隔本身可能微不足道，但当您将所有这些阻塞操作的等待间隔相加时，特别是如果涉及较长的循环时，性能就会开始下降。
- en: One solution is to liberally implement a caching solution. Another solution,
    as you may have guessed, is to write your application using the asynchronous programming
    model. Let's have a look at that right now.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是大量实施缓存解决方案。另一个解决方案，你可能已经猜到了，是使用异步编程模型编写应用程序。让我们现在来看看。
- en: Understanding the asynchronous programming model
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解异步编程模型
- en: The idea behind asynchronous operations has been around for quite some time.
    One extremely well-known example is Apache Web Server, with its **Multi-Processing
    Modules** (**MPMs**). The `MaxRequestWorkers` directive allows you to specify
    how many simultaneous requests the web server can handle (see [https://httpd.apache.org/docs/current/mod/mpm_common.html#maxrequestworkers](https://httpd.apache.org/docs/current/mod/mpm_common.html#maxrequestworkers)
    for more information).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 异步操作的理念已经存在了相当长的时间。一个非常著名的例子是Apache Web服务器，以其**多处理模块**（**MPMs**）而闻名。`MaxRequestWorkers`指令允许您指定Web服务器可以处理多少个同时请求（有关更多信息，请参见[https://httpd.apache.org/docs/current/mod/mpm_common.html#maxrequestworkers](https://httpd.apache.org/docs/current/mod/mpm_common.html#maxrequestworkers)）。
- en: The asynchronous programming model usually involves setting up management nodes,
    referred to as **workers**. This allows program execution to continue without
    having to wait for any given task to complete. The gain in performance can be
    quite dramatic, especially in situations where a large number of blocking operations
    (for example, filesystem access or database queries) occur.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程模型通常涉及设置管理节点，称为**工作节点**。这允许程序执行继续进行，而无需等待任何给定任务完成。性能的提升可能会相当显著，特别是在大量阻塞操作（例如，文件系统访问或数据库查询）发生的情况下。
- en: 'The following diagram visualizes how the tasks of writing to a log file and
    sending an email might be accomplished using the asynchronous programming model:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表可视化了使用异步编程模型完成写入日志文件和发送电子邮件的任务：
- en: '![Figure 12.2 – Asynchronous programming model'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 - 异步编程模型'
- en: '](image/Figure_12.2_B16992_B16992.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.2_B16992_B16992.jpg)'
- en: Figure 12.2 – Asynchronous programming model
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 - 异步编程模型
- en: The total waiting time is reduced by a factor of how many workers are assigned.
    The program flow shown in *Figure 12.2* would involve half the waiting time as
    that shown in *Figure 12.1*. Overall performance improves as the number of workers
    assigned to handle blocking operations increases.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总等待时间减少了分配的工作节点数量的倍数。*图12.2*中显示的程序流程将比*图12.1*中显示的程序流程等待时间减少一半。随着分配给处理阻塞操作的工作节点数量的增加，整体性能会提高。
- en: Important note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The asynchronous programming model is *not to be confused* with **parallel programming**.
    In parallel programming, tasks are literally executed simultaneously, often being
    assigned to different CPUs or CPU cores. Asynchronous programming, on the other
    hand, operates sequentially but allows the sequential code to continue while waiting
    for the results of a blocking operation (for example, a filesystem request or
    a database query).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程模型*不应与**并行编程**混淆。在并行编程中，任务实际上是同时执行的，通常分配给不同的CPU或CPU核心。另一方面，异步编程是顺序操作，但允许顺序代码在等待阻塞操作的结果（例如文件系统请求或数据库查询）时继续执行。
- en: Now that you have an idea of how the PHP async programming model works, let's
    have a look at coroutine support.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了PHP异步编程模型的工作原理，让我们来看看协程支持。
- en: Working with async coroutine support
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用异步协程支持
- en: '*Coroutines* are similar to **threads** but operate in user space, not kernel
    space, and thus do not need to involve the OS. If this support is available, the
    coroutine support component detects blocking operations (such as reading or writing
    to a file) and effectively suspends that operation until results are received.
    This frees up the CPU to proceed with other tasks until the results have been
    returned from the blocking process. This process operates at the machine-code
    level and is thus undetectable to us, other than the fact that our code runs faster.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*协程*类似于**线程**，但在用户空间中运行，而不是内核空间，因此不需要涉及操作系统。如果支持协程支持，协程支持组件会检测阻塞操作（例如读取或写入文件）并有效地暂停该操作，直到收到结果。这释放了CPU以继续执行其他任务，直到从阻塞过程中返回结果。这个过程在机器码级别运行，因此对我们来说是不可检测的，除了我们的代码运行得更快之外。'
- en: Theoretically, using an extension or framework that provides **coroutine support**
    might boost performance, even if your code is written using the synchronous programming
    model. Please note that not all PHP async frameworks or extensions offer this
    support, which might, in turn, influence your choice of framework or extension
    to use for future development.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，使用提供**协程支持**的扩展或框架可能会提高性能，即使您的代码是使用同步编程模型编写的。请注意，并非所有PHP异步框架或扩展都提供此支持，这可能会影响您选择未来开发中要使用的框架或扩展。
- en: The **Swoole extension** ([https://www.swoole.co.uk/](https://www.swoole.co.uk/))
    offers coroutine support. On the other hand, ReactPHP ([https://reactphp.org/](https://reactphp.org/)),
    one of the most popular PHP async frameworks, does not offer coroutine support
    unless used with the Swoole extension (discussed next) or with PHP fibers (discussed
    in the *Learning about PHP 8.1 fibers* section). One of the reasons why ReactPHP
    is so popular, however, is the very fact that the Swoole extension is not required.
    If you are operating in a hosting environment where you do not have control over
    the PHP installation, you can still use ReactPHP and achieve a substantial performance
    gain, without having to touch the PHP installation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Swoole扩展（[https://www.swoole.co.uk/](https://www.swoole.co.uk/)）提供协程支持。另一方面，ReactPHP（[https://reactphp.org/](https://reactphp.org/)）是最受欢迎的PHP异步框架之一，但如果不使用Swoole扩展（下文讨论）或PHP
    fibers（在*学习PHP 8.1 fibers*部分讨论），则不提供协程支持。然而，ReactPHP如此受欢迎的原因之一是因为不需要Swoole扩展。如果您在无法控制PHP安装的托管环境中操作，您仍然可以使用ReactPHP并实现显著的性能提升，而无需触及PHP安装。
- en: We now turn our attention to writing code for the async model.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将注意力转向为异步模型编写代码。
- en: Creating a PHP async application
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建PHP异步应用程序
- en: Now comes the hard part! Unfortunately, an application written using the synchronous
    programming model does not take advantage of what the async model has to offer.
    Even if you are using a framework and/or extension that provides coroutine support,
    you do not realize maximum performance gain unless you refactor your code to follow
    the async programming model.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是困难的部分！不幸的是，使用同步编程模型编写的应用程序无法充分利用异步模型所提供的优势。即使您使用提供协程支持的框架和/或扩展，除非重构代码以遵循异步编程模型，否则无法实现最大性能提升。
- en: Most PHP async frameworks and extensions offer a number of ways for you to separate
    tasks. Here is a brief summary of the more commonly used approaches.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数PHP异步框架和扩展都提供多种方法来分离任务。以下是常用方法的简要总结。
- en: Event loops
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件循环
- en: In a certain sense, an **event loop** is a repetitive block of code that runs
    continuously until a specified event occurs. All of the PHP async extensions and
    frameworks offer this feature in one form or another. Listeners that take the
    form of a callback are added to an event loop. When an event is triggered, the
    listener's logic is invoked.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，**事件循环**是一段代码的重复块，它持续运行直到发生指定的事件。所有PHP异步扩展和框架都以某种形式提供此功能。以回调形式的监听器被添加到事件循环中。当事件触发时，将调用监听器的逻辑。
- en: The Swoole event loop leverages Linux `epoll_wait` ([https://linux.die.net/man/2/epoll_wait](https://linux.die.net/man/2/epoll_wait))
    functionality. Because hardware-based events report to Linux through pseudo file
    handles, the Swoole event loop allows the developer to base the starting and stopping
    of the event loop not only on attributes of actual files but also of any hardware
    process that produces a **file descriptor** (**FD**).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Swoole事件循环利用Linux `epoll_wait`（[https://linux.die.net/man/2/epoll_wait](https://linux.die.net/man/2/epoll_wait)）功能。由于基于硬件的事件通过伪文件句柄报告给Linux，Swoole事件循环允许开发人员基于实际文件的属性以及产生**文件描述符**（**FD**）的任何硬件过程来启动和停止事件循环。
- en: The ReactPHP framework offers the same functionality, but uses the PHP `stream_select()`
    function by default, in place of the OS `epoll_wait` functionality. This makes
    the ReactPHP event loop **application programming interface** (**API**) portable
    between servers, although reaction time will be slower. ReactPHP also offers the
    ability to define an event loop based on the `ext-event`, `ext-ev`, `ext-uv`,
    or `ext-libevent` PHP extensions. Leveraging these extensions gives ReactPHP access
    to the hardware, much as does Swoole.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ReactPHP框架提供了相同的功能，但默认情况下使用PHP的`stream_select()`函数，而不是操作系统的`epoll_wait`功能。这使得ReactPHP事件循环**应用程序编程接口**（**API**）在服务器之间可移植，尽管反应时间会较慢。ReactPHP还提供了基于`ext-event`，`ext-ev`，`ext-uv`或`ext-libevent`
    PHP扩展定义事件循环的能力。利用这些扩展使ReactPHP能够访问硬件，就像Swoole一样。
- en: Promises
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Promises
- en: A **promise** is a software construct that allows you to defer the processing
    of a task until later. The concept was first proposed as part of the **CommonJS**
    project ([http://wiki.commonjs.org/wiki/Promises/A](http://wiki.commonjs.org/wiki/Promises/A)).
    It was designed as a bridge between the synchronous and asynchronous programming
    worlds.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**Promise**是一种软件构造，允许您推迟任务的处理直到以后。这个概念最初是作为**CommonJS**项目的一部分提出的（[http://wiki.commonjs.org/wiki/Promises/A](http://wiki.commonjs.org/wiki/Promises/A)）。它被设计为同步和异步编程世界之间的桥梁。'
- en: 'In synchronous programming, a function (or class method) generally either *succeeds*
    or *fails*. In PHP, a failure is handled as either a deliberately thrown exception
    or a fatal error. In the asynchronous model, three states are identified as part
    of a *promise*: **fulfilled**, **failed**, and **unfulfilled**. Accordingly, when
    a *promise* instance is created, you need to supply three handlers that take action
    based upon the state they represent.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步编程中，函数（或类方法）通常要么*成功*，要么*失败*。在PHP中，失败被处理为故意抛出的异常或致命错误。在异步模型中，*promise*被识别为三种状态：**fulfilled**，**failed**和**unfulfilled**。因此，当创建一个*promise*实例时，您需要提供三个处理程序，根据它们表示的状态采取行动。
- en: 'In the case of ReactPHP, when you create a `React\Promise\Promise` instance,
    you supply a **resolver** as the first constructor argument. The resolver itself
    requires three callbacks labeled `$resolve`, `$reject`, and `$notify`. These three
    correspond to the three possible states of a promise: fulfilled, failed, or unfulfilled.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在ReactPHP中，当您创建一个`React\Promise\Promise`实例时，您需要提供一个**解析器**作为第一个构造函数参数。解析器本身需要三个标记为`$resolve`，`$reject`和`$notify`的回调函数。这三个对应于promise的三种可能状态：fulfilled，failed或unfulfilled。
- en: Streams
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流
- en: Many async frameworks provide a wrapper for PHP **streams**. PHP streams are
    most often used to handle operations involving the filesystem. File access is
    a blocking operation that causes program execution to pause until the OS returns
    the results.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 许多异步框架为PHP **streams**提供了包装器。PHP流最常用于处理涉及文件系统的操作。文件访问是一个阻塞操作，会导致程序执行暂停，直到操作系统返回结果。
- en: In order to avoid having file access block the progress of an async application,
    a `streams` component is used. ReactPHP, for example, provides classes under the
    `React\Stream` namespace that implement `ReadableStreamInterface` or `WritableStreamInterface`.
    These classes serve as a wrapper for ordinary PHP stream functions such as `fopen()`,
    `fread()`, and `fwrite()`, as well as `file_get_contents()` and `file_put_contents()`.
    The ReactPHP classes use memory to avoid blocking and defer the actual read or
    write until later, thus allowing asynchronous activities to continue.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免文件访问阻塞异步应用程序的进度，使用了一个`streams`组件。例如，ReactPHP提供了`React\Stream`命名空间下实现`ReadableStreamInterface`或`WritableStreamInterface`的类。这些类用作普通PHP流函数（如`fopen()`，`fread()`和`fwrite()`，以及`file_get_contents()`和`file_put_contents()`）的包装器。ReactPHP类使用内存来避免阻塞，并推迟实际的读取或写入，从而允许异步活动继续进行。
- en: Timers
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定时器
- en: '**Timers** are separate tasks that can be set to run after a given interval.
    In this respect, timers resemble the JavaScript `setTimeout()` function. Tasks
    scheduled using timers can be set to run one time only, or continuously at specified
    intervals.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**定时器**是可以在给定间隔后运行的单独任务。在这方面，定时器类似于JavaScript的`setTimeout()`函数。使用定时器安排的任务可以设置为仅运行一次，或者在指定间隔连续运行。'
- en: The timer implementation in most PHP async frameworks or extensions generally
    avoids using the PHP `pcntl_alarm()` function. The latter function allows a developer
    to send a `SIGALRM` signal to a process after a certain number of seconds. The
    `pcntl_alarm()` function only allows you to set one at a time, however, and the
    lowest time interval is measured in seconds. In contrast, PHP async frameworks
    and extensions allow you to set multiple timers accurately, to the millisecond.
    Another difference in PHP async timer implementation is that it is not dependent
    upon the `declare(ticks=1)` statement.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数PHP异步框架或扩展中的定时器实现通常避免使用PHP的`pcntl_alarm()`函数。后者允许开发人员在一定秒数后向进程发送`SIGALRM`信号。然而，`pcntl_alarm()`函数一次只允许设置一个，最低时间间隔以秒为单位。相比之下，PHP异步框架和扩展允许您准确地设置多个定时器，精确到毫秒。PHP异步定时器实现的另一个区别是它不依赖于`declare(ticks=1)`语句。
- en: There are many potential uses for timers—for example, a timer could check a
    directory that contains **Completely Automated Public Turing test to tell Computers
    and Humans Apart** (**CAPTCHA**) images and can remove old ones. Another potential
    use would be to refresh the cache periodically.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器有许多潜在的用途，例如，定时器可以检查包含**Completely Automated Public Turing test to tell Computers
    and Humans Apart**（**CAPTCHA**）图像的目录，并删除旧图像。另一个潜在用途是定期刷新缓存。
- en: Channels
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通道
- en: '**Channels** are a means of communicating between concurrent processes. The
    current implementation of channels is based upon an algebraic model proposed in
    1978 by Sir Charles Antony Hoare. His proposal was refined over the years and
    evolved into the model described in his book *Communicating Sequential Processes*,
    published in 1985\. Channels and the **communicating sequential processes** (**CSP**)
    model are a feature of many currently popular languages such as **Go**.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**通道**是在并发进程之间进行通信的一种方式。当前的通道实现是基于查尔斯·安东尼·霍尔爵士在1978年提出的代数模型。他的提议经过多年的完善，并演变成了他在1985年出版的书中描述的模型*Communicating
    Sequential Processes*。通道和**通信顺序进程**（**CSP**）模型是许多当前流行语言的特性，如**Go**。'
- en: In contrast to other more complicated approaches, when using channels the CSP
    processes are anonymous, whereas the channel is explicitly named. Another aspect
    of the channel approach is that the sender is prevented from sending until the
    receiver is ready to receive. This simple principle alleviates having to implement
    an excessive amount of shared locking logic. In the Swoole extension, for example,
    channels are used to implement connection pools or as a means of scheduling concurrent
    tasks.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他更复杂的方法相比，使用通道时CSP进程是匿名的，而通道是明确命名的。通道方法的另一个方面是，发送方在接收方准备好接收之前被阻止发送。这个简单的原则减轻了实现过多共享锁逻辑的负担。例如，在Swoole扩展中，通道被用来实现连接池或作为调度并发任务的一种方式。
- en: Now that you have a basic understanding of PHP async theory, it's time to put
    the theory into practice. We start by examining how to use the Swoole extension.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对PHP异步理论有了基本的了解，是时候将理论付诸实践了。我们首先来看一下如何使用Swoole扩展。
- en: Using the Swoole extension
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Swoole扩展
- en: The PHP **Swoole extension** was first made available on the PHP extension C
    library website ([https://pecl.php.net/](https://pecl.php.net/)) in December 2013\.
    Since that time, it's gained considerable attention. With the introduction of
    the JIT compiler in PHP 8, there has been a considerable amount of renewed interest
    in the Swoole extension as it's fast and stable and is in a position to make PHP
    applications run even faster. The total number of downloads is close to 6 million,
    and the average number per month is around 50,000.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: PHP **Swoole扩展**首次在PHP扩展C库网站（[https://pecl.php.net/](https://pecl.php.net/)）上于2013年12月发布。自那时起，它引起了相当大的关注。随着PHP
    8中引入了JIT编译器，Swoole扩展受到了相当多的关注，因为它快速、稳定，并且有望使PHP应用程序运行得更快。总下载量接近600万次，平均每月下载量约为5万次。
- en: In this section, you will learn about the extension, how it's installed, and
    how it's used. Let's first get an overview of the extension.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将学习有关该扩展的信息，它是如何安装和使用的。让我们首先对该扩展进行概述。
- en: Examining the Swoole extension
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查Swoole扩展
- en: Because the extension is written in the C language, once it's compiled, installed,
    and enabled, a set of functions and classes are added to your current PHP installation.
    The extension leverages certain low-level features that are only available in
    OSes derived from UNIX, however. This means that if you are running a Windows
    server, the only way you can get a PHP async application that uses the Swoole
    extension running is by installing **Windows Services for Linux** (**WSL**) or
    by setting up your application to run in a Docker container on the Windows server.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因为该扩展是用C语言编写的，一旦编译、安装和启用，一组函数和类将被添加到你当前的PHP安装中。然而，该扩展利用了一些仅在UNIX衍生的操作系统中可用的低级特性。这意味着如果你运行的是Windows服务器，你唯一能够运行使用Swoole扩展的PHP异步应用的方法是安装**Windows
    Services for Linux**（**WSL**）或者在Windows服务器上设置你的应用程序在Docker容器中运行。
- en: Tip
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to experiment with PHP async on a Windows server, consider using
    ReactPHP (discussed in the *Working with ReactPHP* section), which does not have
    the OS dependencies required by the Swoole extension.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Windows服务器上尝试PHP异步，请考虑使用ReactPHP（在*使用ReactPHP*部分讨论），它不需要Swoole扩展所需的操作系统依赖项。
- en: One of the big advantages of PHP async is that the initial block of code gets
    loaded immediately and stays in memory until the asynchronous server instance
    stops. This is the case when using the Swoole extension. In your code, you create
    an asynchronous server instance that effectively turns PHP into a continuously
    running daemon listening on the designated port. This is also a disadvantage,
    however, in that if you make changes to your program code, the changes are not
    recognized by the async server instance until you reload it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: PHP异步的一个重要优势是，初始的代码块会立即加载并保留在内存中，直到异步服务器实例停止。这是使用Swoole扩展时的情况。在你的代码中，你创建一个异步服务器实例，有效地将PHP转换为一个持续运行的守护程序，监听指定的端口。然而，这也是一个缺点，因为如果你对程序代码进行更改，这些更改在重新加载之前不会被异步服务器实例识别。
- en: One of the great features of the Swoole extension is its **coroutine support**.
    What this means, in real-life terms, is that we don't have to perform major surgery
    on applications written using the synchronous programming model. Swoole will automatically
    pick out blocking operations such as filesystem access and database queries and
    allow these operations to be placed on hold while the rest of the application
    proceeds. Because of this support, you can often simply run the synchronous application
    using Swoole, resulting in an immediate performance boost.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Swoole扩展的一个伟大特性是它的**协程支持**。这意味着，我们不必对使用同步编程模型编写的应用程序进行重大改动。Swoole将自动挑选出像文件系统访问和数据库查询这样的阻塞操作，并允许这些操作被暂停，而应用程序的其余部分继续进行。由于这种支持，你通常可以简单地使用Swoole运行同步应用程序，从而立即提高性能。
- en: Another really great feature of the Swoole extension is `Swoole\Table`. This
    feature lets you create, entirely in memory, the equivalent of a database table
    that can be shared between multiple processes. There are many possible uses for
    such a construct, and the potential performance gain is truly staggering.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Swoole扩展的另一个非常棒的功能是`Swoole\Table`。这个功能让您可以在内存中创建一个数据库表的等效内容，可以在多个进程之间共享。这样的构造有许多可能的用途，潜在的性能提升真是令人震惊。
- en: The Swoole extension has the ability to listen for **User Datagram Protocol**
    (**UDP**) transmissions rather than **Transmission Control Protocol** (**TDP**)
    ones. This is an extremely interesting possibility as UDP is much faster than
    TCP. Swoole also includes a timer implementation accurate to the millisecond,
    as well as async clients for MySQL, PostgreSQL, Redis, and cURL. The Swoole extension
    also gives you the ability to set up **inter-process communication** (**IPC**)
    using **Golang** style channels. Let's now have a look at installing Swoole.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Swoole扩展具有监听**用户数据报协议**（**UDP**）传输而不是**传输控制协议**（**TCP**）的能力。这是一个非常有趣的可能性，因为UDP比TCP快得多。Swoole还包括一个毫秒级准确的定时器实现，以及用于MySQL、PostgreSQL、Redis和cURL的异步客户端。Swoole扩展还可以使用**Golang**风格的通道设置**进程间通信**（**IPC**）。现在让我们来看一下安装Swoole。
- en: Installing the Swoole extension
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Swoole扩展
- en: The Swoole extension can be installed using the same techniques you would deploy
    to install any PHP extension written in the C language. One approach is to simply
    use your OS package manager. Examples include `apt` (or its less friendly cousin,
    `apt-get`) for Debian or Ubuntu Linux, and `yum` or `dnf` for Red Hat, CentOS,
    or Fedora. When using an OS package manager, the Swoole extension is made available
    in the form of precompiled binaries.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Swoole扩展可以使用与安装C语言编写的任何PHP扩展相同的技术来安装。一种方法是简单地使用您的操作系统包管理器。例如，对于Debian或Ubuntu
    Linux，可以使用`apt`（或其不太友好的表亲`apt-get`），对于Red Hat、CentOS或Fedora，可以使用`yum`或`dnf`。在使用操作系统包管理器时，Swoole扩展以预编译的二进制形式提供。
- en: 'The recommended approach, however, is to use the `pecl` command. If this command
    is not available on your installation, the `pecl` command can be installed (logged
    in as a root user) as follows on an Ubuntu or Debian OS: `apt install php-pear`.
    For a Red Hat, CentOS, or Fedora installation, the following works: `yum install
    php-pear`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，推荐的方法是使用`pecl`命令。如果您的安装中没有此命令，可以在Ubuntu或Debian操作系统上（以root用户身份登录）如下安装`pecl`命令：`apt
    install php-pear`。对于Red Hat、CentOS或Fedora安装，可以使用以下命令：`yum install php-pear`。
- en: 'When installing the Swoole extension using `pecl`, you can specify a number
    of options. These options are summarized here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`pecl`安装Swoole扩展时，可以指定一些选项。这些选项在这里总结如下：
- en: '![Table 12.1 – Swoole extension pecl installation options'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![表12.1 – Swoole扩展pecl安装选项'
- en: '](image/Table_12.1_B16992.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_12.1_B16992.jpg)'
- en: Table 12.1 – Swoole extension pecl installation options
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.1 – Swoole扩展pecl安装选项
- en: 'For more information on these options and for an overview of the installation
    procedure, have a look here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些选项的更多信息以及安装过程的概述，请查看这里：
- en: '[https://www.swoole.co.uk/docs/get-started/installation](https://www.swoole.co.uk/docs/get-started/installation)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.swoole.co.uk/docs/get-started/installation](https://www.swoole.co.uk/docs/get-started/installation)'
- en: 'Let''s now take a look at a sample installation that includes Swoole support
    for sockets, **JavaScript Object Notation** (**JSON**), and cURL, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个包括对套接字、**JavaScript对象表示法**（**JSON**）和cURL的Swoole支持的示例安装，如下所示：
- en: 'The first thing we need to do is to update the `pecl` **channel**. This is
    a list of PHP extension source code repositories and functions, much like the
    `sources` list used by the `apt` or `yum` package managers. Here''s the code to
    do this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是更新`pecl`的**通道**。这是PHP扩展源代码仓库和函数的列表，就像`apt`或`yum`包管理器使用的`sources`列表一样。以下是执行此操作的代码：
- en: '[PRE0]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we specify the installation command and use the `-D` flag to add options,
    as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们指定安装命令并使用`-D`标志添加选项，如下所示：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This starts the extension installation process. You now see the various C language
    code files and header files downloaded, after which your local C compiler is used
    to compile the extension. Here is a partial view of the compile process:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这开始了扩展安装过程。然后，您会看到各种C语言代码文件和头文件被下载，之后会使用本地C编译器来编译扩展。以下是编译过程的部分视图：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If a C compiler is not found, you will be warned. Also, you might need to install
    the PHP development library for your OS. The warning messages give you further
    guidance if this is the case.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找不到C编译器，将会收到警告。此外，您可能需要为您的操作系统安装PHP开发库。如果是这种情况，警告消息会给出进一步的指导。
- en: 'Once completed, you then need to enable the extension. This is accomplished
    by adding `extension=swoole` to the `php.ini` file. If you are unsure of its location,
    use the `php -i` command and look for the location of the `php.ini` file. Here
    is a command you can issue from the command line that adds this directive:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，您需要启用扩展。这可以通过将`extension=swoole`添加到`php.ini`文件中来实现。如果您不确定其位置，可以使用`php -i`命令并查找`php.ini`文件的位置。以下是您可以从命令行发出的添加此指令的命令：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can then use the following command to confirm the availability of the Swoole
    extension:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以使用以下命令来确认Swoole扩展的可用性：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This concludes the installation of the Swoole extension. If you are custom-compiling
    PHP, you can also add the `--enable-swoole` option when running `configure` prior
    to compilation. This causes the Swoole extension to be compiled and enabled along
    with your core PHP installation (and allows you to bypass the installation steps
    just outlined). We will now have a look at a brief *Hello World* example taken
    from the documentation to test the installation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了Swoole扩展的安装。如果您正在自定义编译PHP，还可以在运行`configure`之前添加`--enable-swoole`选项。这将导致Swoole扩展与核心PHP安装一起被编译和启用（并允许您跳过刚刚概述的安装步骤）。现在我们将看一下从文档中摘取的一个简短的*Hello
    World*示例，以测试安装。
- en: Testing the installation
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试安装
- en: 'The Swoole documentation provides a simple example you can use for a quick
    test to see if the installation was successful. The sample code is shown on the
    main Swoole documentation page ([https://www.swoole.co.uk/docs/](https://www.swoole.co.uk/docs/)).
    We do not reproduce it here for copyright reasons. Here are the steps taken to
    run the *Hello World* test:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Swoole文档提供了一个简单的示例，您可以用来快速测试安装是否成功。示例代码显示在主Swoole文档页面上([https://www.swoole.co.uk/docs/](https://www.swoole.co.uk/docs/))。由于版权原因，我们在这里不再重复。以下是运行*Hello
    World*测试的步骤：
- en: First, we copied the *Hello World* example from [https://www.swoole.co.uk/docs/](https://www.swoole.co.uk/docs/)
    to `/path/to/repo/ch12/php8_swoole_hello_world.php` file.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将*Hello World*示例从[https://www.swoole.co.uk/docs/](https://www.swoole.co.uk/docs/)复制到`/path/to/repo/ch12/php8_swoole_hello_world.php`文件中。
- en: Next, we modified the demo program and changed `$server = new Swoole\HTTP\Server("127.0.0.1",
    9501);` to `$server = new Swoole\HTTP\Server("0.0.0.0", 9501);`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们修改了演示程序，并将`$server = new Swoole\HTTP\Server("127.0.0.1", 9501);`更改为`$server
    = new Swoole\HTTP\Server("0.0.0.0", 9501);`。
- en: This change allows the Swoole server to listen on port `9501` for any **Internet
    Protocol** (**IP**) address.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化允许Swoole服务器监听端口`9501`，对任何**Internet Protocol** (**IP**) 地址。
- en: 'We then modified the `/repo/ch12/docker-compose.yml` file to make port `9501`
    available outside the Docker container, as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们修改了`/repo/ch12/docker-compose.yml`文件，使端口`9501`在Docker容器外可用，如下所示：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To make this change effective, we had to bring the service down and back up
    again. From a command prompt/terminal window on your local computer, use these
    two commands:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个变化生效，我们不得不关闭并重新启动服务。从本地计算机的命令提示符/终端窗口上，使用以下两个命令：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Please note that if you are running Windows, remove `.sh`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，如果您正在运行Windows，请删除`.sh`。
- en: 'We then opened a shell into the PHP 8 Docker container and ran the *Hello World*
    program, as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们打开了PHP 8 Docker容器的shell，并运行了*Hello World*程序，如下所示：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, from outside the Docker container, we opened a browser to this IP
    address and port: `http://172.16.0.88:9501`.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从Docker容器外部，我们打开了一个浏览器到这个IP地址和端口：`http://172.16.0.88:9501`。
- en: 'The following screenshot shows the result from the Swoole *Hello World* program:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了Swoole *Hello World*程序的结果：
- en: '![Figure 12.3 – The Swoole demo Hello World program output'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 - Swoole演示Hello World程序输出'
- en: '](image/Figure_12.3_B16992_B16992.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.3_B16992_B16992.jpg)'
- en: Figure 12.3 – The Swoole demo Hello World program output
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 - Swoole演示Hello World程序输出
- en: Before getting into details on how the Swoole extension can be used to improve
    application performance, we need to examine a sample application that's a prime
    candidate for the PHP async model.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解Swoole扩展如何提高应用程序性能之前，我们需要检查一个适合PHP异步模型的样本应用程序。
- en: Examining a sample I/O-intensive application
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查一个I/O密集型应用程序
- en: 'For the sake of illustration, we have created a sample application written
    as a **REpresentational State Transfer** (**REST**) API, designed to run in PHP
    8\. The sample application presents a chat or instant messaging API with the following
    simple features:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，我们创建了一个样本应用程序，编写为在PHP 8中运行的**REpresentational State Transfer** (**REST**)
    API。样本应用程序提供了以下简单功能的聊天或即时消息API：
- en: Use a **HyperText Transfer Protocol** (**HTTP**) `POST` method to post a message
    either to a specific user or to all users. After a successful posting, the API
    returns the message just posted.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**HyperText Transfer Protocol** (**HTTP**) `POST`方法将消息发布到特定用户或所有用户。成功发布后，API返回刚刚发布的消息。
- en: An HTTP `GET` method with a `from=username` parameter returns all messages to
    and from that username and messages to all users. If the `all=1` parameter is
    set, it returns a list of all usernames.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有`from=username`参数的HTTP `GET`方法返回该用户名的所有消息以及发送给所有用户的消息。如果设置了`all=1`参数，它将返回所有用户名的列表。
- en: An HTTP `DELETE` method removes all messages from the `messages` table.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个HTTP `DELETE`方法从`messages`表中删除所有消息。
- en: 'Only parts of the application code are shown in this section. If you are interested
    in the entire `Chat` application, the source code is located under `/path/to/repo/src/Chat`.
    The primary API endpoint is provided here: `http://172.16.0.81/ch12/php8_chat_ajax.php`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本节仅显示了应用程序代码的部分内容。如果您对整个`Chat`应用程序感兴趣，源代码位于`/path/to/repo/src/Chat`下。主要的API端点在这里提供：`http://172.16.0.81/ch12/php8_chat_ajax.php`。
- en: 'The examples that follow are executed in a PHP 8.1 Docker container. Be sure
    to bring down the existing containers as follows, from a command prompt on your
    local computer on a Windows computer: `C:\path\to\repo\init down`. For Linux or
    Mac, from a terminal window: `/path/to/repo/init.sh down`. To bring up the PHP
    8.1 container from a Windows computer: `C:\path\to\repo\ch12\init up`. From a
    Linux or Mac terminal window: `/path/to/repo/ch12/init.sh up`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的示例是在PHP 8.1 Docker容器中执行的。请确保从Windows计算机的命令提示符中按以下方式关闭现有容器：`C:\path\to\repo\init
    down`。对于Linux或Mac，从终端窗口：`/path/to/repo/init.sh down`。要从Windows计算机上启动PHP 8.1容器：`C:\path\to\repo\ch12\init
    up`。从Linux或Mac终端窗口：`/path/to/repo/ch12/init.sh up`。
- en: 'The examples that follow are executed in a PHP 8.1 Docker container. Be sure
    to bring down the existing containers as follows from a command prompt on your
    local computer on a Windows computer: C:\path\to\repo\init down'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的示例是在PHP 8.1 Docker容器中执行的。请确保从Windows计算机的命令提示符中按以下方式关闭现有容器：`C:\path\to\repo\init
    down`
- en: 'For Linux or Mac, from a terminal window:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux或Mac，从终端窗口：
- en: '`/path/to/repo/init.sh down`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`/path/to/repo/init.sh down`'
- en: 'To bring up the PHP 8.1 container from a Windows computer:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Windows计算机上启动PHP 8.1容器：
- en: '`C:\path\to\repo\ch12\init up`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`C:\path\to\repo\ch12\init up`'
- en: 'From a Linux or Mac terminal window:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux或Mac终端窗口：
- en: '`/path/to/repo/ch12/init.sh up`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`/path/to/repo/ch12/init.sh up`'
- en: 'We now look at the source code for the core API program itself, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下核心API程序的源代码，如下所示：
- en: 'First, we define a `Chat\Message\Pipe` class, identifying all of the external
    classes we need to use, like this:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个`Chat\Message\Pipe`类，标识了我们需要使用的所有外部类，如下所示：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then define an `exec()` static method that invokes a set of **PHP Standard
    Recommendation 15** (**PSR-15**)-compliant handlers. We also invoke the first
    stage of the pipe by calling the `process` method of the `Chat\Middleware\Access`
    middleware class. The return value of `NextHandler` is ignored:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个`exec()`静态方法，调用一组符合**PHP标准建议15**（**PSR-15**）的处理程序。我们还通过调用`Chat\Middleware\Access`中间件类的`process`方法来调用管道的第一阶段。`NextHandler`的返回值被忽略：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Still in the same method, we use a `match()` construct to check for HTTP `GET`,
    `POST`, and `DELETE` method calls. If the method is `POST`, we use the `Chat\Middleware\ValidatePost`
    validation middleware class to validate the `POST` arguments. If validation succeeds,
    the sanitized data is then passed to `Chat\Handler\PostHandler`. If the HTTP method
    is `DELETE`, we directly call `Chat\Handler\DeleteHandler`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个方法中，我们使用`match()`结构来检查HTTP的`GET`、`POST`和`DELETE`方法调用。如果方法是`POST`，我们使用`Chat\Middleware\ValidatePost`验证中间件类来验证`POST`参数。如果验证成功，经过清理的数据然后传递给`Chat\Handler\PostHandler`。如果HTTP方法是`DELETE`，我们直接调用`Chat\Handler\DeleteHandler`：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If the HTTP method is `GET`, we first check to see if the `all` parameter is
    set. If so, we invoke `Chat\Handler\GetAllNamesHandler`. Otherwise, the *default*
    clause passes data through `Chat\MiddleWare\Validate`. If validation succeeds,
    the sanitized data is passed to `Chat\Handler\GetHandler`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果HTTP方法是`GET`，我们首先检查`all`参数是否已设置。如果是，我们调用`Chat\Handler\GetAllNamesHandler`。否则，*default*子句通过`Chat\MiddleWare\Validate`传递数据。如果验证成功，经过清理的数据将传递给`Chat\Handler\GetHandler`：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The core API class can then be called using a short conventional program, as
    shown here. In this calling program, we build a PSR-7 compliant `Psr\Http\Message\ServerRequestInterface`
    instance using `Laminas\Diactoros\ServerRequestFactory`. The request is then passed
    through the `Pipe` class and a response is produced:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后可以使用一个简短的传统程序调用核心API类，如下所示。在这个调用程序中，我们使用`Laminas\Diactoros\ServerRequestFactory`构建一个符合PSR-7的`Psr\Http\Message\ServerRequestInterface`实例。然后将请求通过`Pipe`类，产生一个响应：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We also created a test program (`/repo/ch12/php8_chat_test.php`—not shown) that
    calls the API endpoint a set number of times (the default is 100). On each iteration,
    the test program posts a random message consisting of a random recipient username,
    a random date, and a sequential entry from the `/repo/sample_data/geonames.db`
    database. The test program takes two arguments. The first argument is a URL that
    represents the API. The second (optional) argument represents the number of iterations.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个测试程序（`/repo/ch12/php8_chat_test.php`—未显示），该程序调用API端点一定次数（默认为100次）。在每次迭代中，测试程序会发布一个随机消息，包括随机的接收者用户名、随机日期和来自`/repo/sample_data/geonames.db`数据库的顺序条目。测试程序需要两个参数。第一个参数是代表API的URL。第二个（可选）参数代表迭代次数。
- en: 'Here are example results running `/ch12/php8_chat_test.php` from a command
    shell into the PHP 8.1 Docker container:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是从命令行运行`/ch12/php8_chat_test.php`在PHP 8.1 Docker容器中的示例结果：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From the output, take note of the elapsed time. In the next section, using
    Swoole, we are able to cut this time in half! Before using Swoole, however, it
    is only fair to incorporate the JIT compiler. We enable JIT using the following
    command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，注意经过的时间。在下一节中，使用Swoole，我们能够将这个时间减少一半！然而，在使用Swoole之前，公平地加入JIT编译器是必要的。我们使用以下命令启用JIT：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In PHP 8.0.0, it''s possible you might encounter a few errors and possibly
    a segmentation fault. In PHP 8.1, however, the API should work as expected with
    the JIT compiler enabled. However, it''s highly doubtful the JIT compiler would
    improve performance, as the frequent API calls cause the application to wait.
    Any application with frequent blocking I/O operations is an excellent candidate
    for the asynchronous programming model. Before we proceed, however, we need to
    turn off JIT, using the same utility program as before, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8.0.0中，可能会遇到一些错误，可能会出现分段错误。然而，在PHP 8.1中，启用JIT编译器后，API应该可以正常工作。然而，JIT编译器是否会提高性能是非常可疑的，因为频繁的API调用会导致应用程序等待。任何频繁阻塞I/O操作的应用程序都是异步编程模型的绝佳候选。然而，在我们继续之前，我们需要关闭JIT，使用与之前相同的实用程序，如下所示：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's now have a look at how the Swoole extension might be used to improve the
    performance of this I/O-intensive application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看Swoole扩展如何用于改进这个I/O密集型应用程序的性能。
- en: Using the Swoole extension to improve application performance
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Swoole扩展来提高应用程序性能
- en: 'Given that Swoole provides coroutine support, all we really need to do in order
    to improve the `Chat` application performance is to rewrite the `/repo/ch12/php8_chat_ajax.php`
    calling program, turning it into an API that listens on port `9501` as a Swoole
    server instance. Here are the steps to rewrite the main API calling program:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于Swoole提供了协程支持，为了提高`Chat`应用程序的性能，我们实际上只需要重写`/repo/ch12/php8_chat_ajax.php`调用程序，将其转换为一个在端口`9501`上作为Swoole服务器实例监听的API。以下是重写主API调用程序的步骤：
- en: 'First, we enable autoloading and identify the external classes needed:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们启用自动加载并识别所需的外部类：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we start a PHP session and create a `Swoole\HTTP\Server` instance that
    listens for any IP address on port `9501`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们启动一个PHP会话，并创建一个监听端口`9501`上任何IP地址的`Swoole\HTTP\Server`实例：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then invoke the `on()` method and associate it with the `start` event. In
    this case, we make a log entry to identify when the Swoole server started. Other
    server events are documented here: [https://www.swoole.co.uk/docs/modules/swoole-http-server-doc](https://www.swoole.co.uk/docs/modules/swoole-http-server-doc):'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们调用`on()`方法并将其与`start`事件关联。在这种情况下，我们记录一个日志条目以标识Swoole服务器启动的时间。其他服务器事件在这里有文档记录：[https://www.swoole.co.uk/docs/modules/swoole-http-server-doc](https://www.swoole.co.uk/docs/modules/swoole-http-server-doc)：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we define a main server event, `$server->on(''request'', function
    () {})`, which handles incoming requests. Here''s the code to accomplish this:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个主服务器事件，`$server->on('request', function () {})`，用于处理传入的请求。以下是实现这一点的代码：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Unfortunately, a `Swoole\Http\Request` instance passed to the callback associated
    with the `on()` method is not PSR-7-compliant! Accordingly, we need to define
    a `Chat\Http\SwooleToPsr7` class and a `swooleRequestToServerRequest()` method
    that performs the conversion using a static call. We then set headers on the `Swoole\Http|Response`
    instance and return a value from the pipe to complete the circuit.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，传递给`on()`方法关联的回调的`Swoole\Http\Request`实例不符合PSR-7！因此，我们需要定义一个`Chat\Http\SwooleToPsr7`类和一个`swooleRequestToServerRequest()`方法，使用静态调用执行转换。然后我们在`Swoole\Http|Response`实例上设置头，并从管道返回一个值以完成电路。
- en: It's extremely important for you to note that the standard PHP superglobals,
    such as `$_GET` and `$_POST`, do not work as expected from a running Swoole server
    instance. The main point of entry is the initial program you use to start the
    Swoole server from the command line. The only incoming request parameter is the
    actual initial program filename. Any subsequent input must be captured through
    the `Swoole\Http\Request` instance that's passed to the `on()` function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的一点是，标准的PHP超全局变量，如`$_GET`和`$_POST`，无法从运行的Swoole服务器实例中按预期工作。入口点是您用于从命令行启动Swoole服务器的初始程序。唯一的传入请求参数是实际的初始程序文件名。任何后续输入必须通过传递给`on()`函数的`Swoole\Http\Request`实例来捕获。
- en: 'The documentation found at [https://php.net/swoole](https://php.net/swoole)
    does not show all of the methods available for the `Swoole\HTTP\Request` and `Swoole\HTTP\Response`
    classes. However, on the Swoole website itself, you can find the relevant documentation,
    which is also listed here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://php.net/swoole](https://php.net/swoole)找到的文档并未显示`Swoole\HTTP\Request`和`Swoole\HTTP\Response`类中的所有可用方法。然而，在Swoole网站本身，您可以找到相关的文档，这里也列出了：
- en: '[https://www.swoole.co.uk/docs/modules/swoole-http-request](https://www.swoole.co.uk/docs/modules/swoole-http-request)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.swoole.co.uk/docs/modules/swoole-http-request](https://www.swoole.co.uk/docs/modules/swoole-http-request)'
- en: '[https://www.swoole.co.uk/docs/modules/swoole-http-response](https://www.swoole.co.uk/docs/modules/swoole-http-response)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.swoole.co.uk/docs/modules/swoole-http-response](https://www.swoole.co.uk/docs/modules/swoole-http-response)'
- en: 'It''s also worth noting that the `Swoole\HTTP\Request` object properties roughly
    correspond to the PHP superglobals, as shown here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`Swoole\HTTP\Request`对象属性大致对应于PHP超全局变量，如下所示：
- en: '![Table 12.2 – Swoole request mapping to PHP superglobals'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![表12.2 – Swoole请求映射到PHP超全局变量'
- en: '](image/Table_12.2_B16992.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_12.2_B16992.jpg)'
- en: Table 12.2 – Swoole request mapping to PHP superglobals
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.2 – Swoole请求映射到PHP超全局变量
- en: 'Another consideration is that using Xdebug in Swoole coroutines can lead to
    segmentation faults and other issues, up to and including a **core dump**. A best
    practice is to enable Swoole debugging with the `--enable-debug` flag when first
    installing Swoole using `pecl`. To test the application, we proceed as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个考虑因素是，在Swoole协程中使用Xdebug可能会导致分段错误和其他问题，甚至包括**核心转储**。最佳实践是在首次使用`pecl`安装Swoole时使用`--enable-debug`标志启用Swoole调试。为了测试应用程序，我们进行如下操作：
- en: 'From a command shell into the PHP 8.1 Docker container, we run the Swoole version
    of our `Chat` API, as follows. The message immediately displayed is a result of
    `$server->on("start", function() {})`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行进入PHP 8.1 Docker容器，我们运行我们的`Chat` API的Swoole版本，如下所示。立即显示的消息是由`$server->on("start",
    function() {})`产生的：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then open another terminal window on our host computer and open another
    shell into the PHP 8.1 Docker container. From there, we are able to run the `/repo/ch12/php8_chat_test.php`
    test program, as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在主机计算机上打开另一个终端窗口，并在PHP 8.1 Docker容器中打开另一个shell。从那里，我们可以运行`/repo/ch12/php8_chat_test.php`测试程序，如下所示：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note the two additional arguments. The first argument tells the test program
    to use the Swoole version of the API rather than the old version that uses the
    Apache Web Server. The last arguments tell the test program to run through 1,000
    iterations.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意两个额外的参数。第一个参数告诉测试程序使用API的Swoole版本，而不是使用Apache Web服务器的旧版本。最后的参数告诉测试程序运行1,000次迭代。
- en: 'Let''s now have a look at the output, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下输出，如下所示：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The most notable feature of the output is the elapsed time. If you look back
    at the previous section, you''ll note that the API running as a traditional PHP
    application using Apache took about 3.35 seconds to complete 1,000 iterations,
    whereas the same API, running under Swoole, completes in approximately 1.86 seconds:
    almost half the time!'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最显着特征是经过的时间。如果您回顾前一节，您会注意到作为传统PHP应用程序在Apache上运行的API大约需要3.35秒才能完成1,000次迭代，而在Swoole下运行的相同API大约需要1.86秒：几乎是一半的时间！
- en: Please note that this is without any additional optimization. Swoole has many
    other features we could use, including the ability to define in-memory tables,
    spawn tasks off additional worker threads, and use event loops to facilitate caching,
    among other possibilities. As you can see, Swoole immediately provides a performance
    boost and is well worth investigating as a possible way to gain even more performance
    out of your existing applications.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是没有任何额外优化的情况。Swoole还有许多其他功能可供我们使用，包括定义内存表、在额外的工作线程中生成任务以及使用事件循环来促进缓存，还有其他可能性。正如您所看到的，Swoole立即提供了性能提升，并且非常值得调查，作为获得现有应用程序更多性能的可能途径。
- en: Now that you have an idea of how Swoole might be used to improve application
    performance, let's have a look at other potential PHP async solutions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对Swoole如何用于提高应用程序性能有了一个概念，让我们来看看其他潜在的PHP异步解决方案。
- en: Using selected PHP frameworks in async mode
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在异步模式下使用选定的PHP框架
- en: There are a number of other PHP frameworks that implement the asynchronous programming
    model. In this section, we cover ReactPHP, the most popular of the PHP async frameworks,
    as well as Amp, another popular PHP async framework. In addition, we show you
    how selected PHP frameworks can be used in async mode.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他PHP框架实现了异步编程模型。在本节中，我们将介绍ReactPHP，这是最流行的PHP异步框架，以及Amp，另一个流行的PHP异步框架。此外，我们还会向您展示如何在异步模式下使用选定的PHP框架。
- en: It's important to note that many of the PHP frameworks able to operate in asynchronous
    mode have a dependency on the Swoole extension. The one that does not have this
    dependency is ReactPHP, covered next.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，许多能够在异步模式下运行的PHP框架都依赖于Swoole扩展。没有这种依赖性的是接下来要介绍的ReactPHP。
- en: Working with ReactPHP
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ReactPHP
- en: '**ReactPHP** ([https://reactphp.org/](https://reactphp.org/)) is an implementation
    of the **Reactor software design pattern** and was inspired by the non-blocking
    asynchronous **Node.js** framework ([https://nodejs.org/en/](https://nodejs.org/en/)),
    among others.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**ReactPHP** ([https://reactphp.org/](https://reactphp.org/)) 是**Reactor软件设计模式**的一种实现，受到了非阻塞异步**Node.js**框架（[https://nodejs.org/en/](https://nodejs.org/en/)）等的启发。'
- en: Although ReactPHP does not give you the automatic performance increase seen
    with the Swoole extension, it has a big advantage in that it does not rely upon
    features of UNIX or Linux, and can thus run on a Windows server. The other advantage
    of ReactPHP is that it has no specific dependency on PHP extensions, other than
    those already included as standard extensions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ReactPHP不会像Swoole扩展那样自动提高性能，但它的一个重要优势在于它不依赖于UNIX或Linux的特性，因此可以在Windows服务器上运行。ReactPHP的另一个优势是，它除了标准扩展之外，没有对PHP扩展的特定依赖性。
- en: The core of any ReactPHP application is the `React\EventLoop\Loop` class. As
    the name implies, a `Loop` instance starts up effectively as an **infinite loop**.
    Most PHP infinite loops spell disaster for your application! In this case, however,
    the loop is used with a server instance that continuously listens to requests
    on a given port.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 任何ReactPHP应用程序的核心都是`React\EventLoop\Loop`类。顾名思义，`Loop`实例启动后实际上是一个**无限循环**。大多数PHP无限循环都会给您的应用程序带来灾难！然而，在这种情况下，循环与一个服务器实例一起使用，该服务器实例不断监听给定端口上的请求。
- en: Another key component of ReactPHP is `React\Socket\Server`. This class opens
    a socket on the given port, enabling a ReactPHP application to listen for HTTP
    requests directly without having to involve a web server.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ReactPHP的另一个关键组件是`React\Socket\Server`。这个类在给定端口上打开一个套接字，使得ReactPHP应用程序可以直接监听HTTP请求，而无需涉及Web服务器。
- en: Other features of ReactPHP include the ability to listen for UDP requests, a
    non-blocking cache, and the implementation of async promises. ReactPHP also features
    a `Stream` component that allows you to defer filesystem reads and writes, greatly
    speeding up performance because your application no longer has to wait for such
    file I/O requests to finish.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ReactPHP的其他特性包括监听UDP请求的能力，非阻塞缓存以及异步承诺的实现。ReactPHP还具有一个`Stream`组件，允许您推迟文件系统的读写操作，大大提高性能，因为您的应用程序不再需要等待这样的文件I/O请求完成。
- en: 'One final advantage to using ReactPHP is that it''s fully compliant with PSR-7
    (HTTP messaging). We''ll now look at the example program that runs the `Chat`
    API described earlier, rewritten using ReactPHP. Here are the steps to rewrite
    the program:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ReactPHP的另一个优势是它完全符合PSR-7（HTTP消息）。我们现在将查看之前描述的`Chat` API的示例程序，使用ReactPHP进行重写。以下是重写程序的步骤：
- en: 'From Command Prompt into the Docker PHP 8 container, using Composer, we install
    the necessary ReactPHP components:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令提示符进入Docker PHP 8容器，使用Composer安装必要的ReactPHP组件：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We then rewrite `/repo/ch12/php8_chat_swoole.php` and rename it as `/repo/ch12/php8_chat_react.php`.
    The first thing we need to change are the `use` statements:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将`/repo/ch12/php8_chat_swoole.php`重写为`/repo/ch12/php8_chat_react.php`。我们需要更改的第一件事是`use`语句：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We then start a session and create a `React\EventLoop\Loop` instance, as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们启动一个会话并创建一个`React\EventLoop\Loop`实例，如下所示：
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We now define a handler that accepts a PSR-7 `ServerRequestInterface` instance
    as an argument and returns a `React\Http\Message\Response` instance:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在定义一个处理程序，它接受一个PSR-7 `ServerRequestInterface`实例作为参数，并返回一个`React\Http\Message\Response`实例：
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We then set up a `React\Socker\Server` instance to listen on port `9501` and
    execute a loop, like this:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们设置一个`React\Socker\Server`实例来监听端口`9501`并执行一个循环，就像这样：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then open a separate command shell into the PHP 8.1 container and start
    the ReactPHP server as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在PHP 8.1容器中打开一个单独的命令行，并启动ReactPHP服务器，如下所示：
- en: '`root@php8_tips_php8_1 [ /repo/ch12 ]# php php8_chat_react.php`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`root@php8_tips_php8_1 [ /repo/ch12 ]# php php8_chat_react.php`'
- en: 'From another command shell into the PHP 8.1 container, we can then run the
    test program as follows: `root@php8_tips_php8_1 [ /repo/ch12 ]# php php8_chat_test.php
    \`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个命令行进入PHP 8.1容器，然后可以运行测试程序如下：`root@php8_tips_php8_1 [ /repo/ch12 ]# php php8_chat_test.php
    \`
- en: '`http://localhost:9501`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:9501`'
- en: The output (not shown) is similar to that shown when using the Swoole extension.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 输出（未显示）与使用Swoole扩展时所见的类似。
- en: 'Next, we have a look at another popular PHP async framework: Amp.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看另一个流行的PHP异步框架：Amp。
- en: Implementing PHP async using Amp
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Amp实现PHP异步
- en: The **Amp framework** (https://amphp.org/), much like ReactPHP, provides implementations
    of timers, promises, and streams. Amp also provides coroutine support, as well
    as an asynchronous iterator component. The latter is extremely intriguing, as
    iteration is essential to most PHP applications. If you can move iteration into
    an asynchronous mode of processing, while potentially involving a lot of refactoring,
    it might provide an immense boost to your application's performance. Another interesting
    twist is that Amp can directly use any ReactPHP components!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**Amp框架**（https://amphp.org/），类似于ReactPHP，提供了定时器、promise和流的实现。Amp还提供了协程支持，以及一个异步迭代器组件。后者非常有趣，因为迭代对大多数PHP应用程序至关重要。如果可以将迭代移入异步处理模式，虽然可能需要进行大量重构，但可能会极大地提高应用程序的性能。另一个有趣的变化是Amp可以直接使用任何ReactPHP组件！'
- en: To install Amp, use Composer. The various Amp components are available in discrete
    repositories, so you don't have to install the entire framework—only what you
    need. The actual implementation of a PHP Amp server is much like the example shown
    for ReactPHP.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Amp，请使用Composer。各种Amp组件都在单独的存储库中可用，因此您不必安装整个框架，只需安装您需要的部分。PHP Amp服务器的实际实现非常类似于ReactPHP中显示的示例。
- en: 'Let''s now have a look at another framework that can operate in PHP async mode:
    **Mezzio**, formerly called **Zend Expressive**.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看另一个可以在PHP异步模式下运行的框架：**Mezzio**，以前称为**Zend Expressive**。
- en: Using Mezzio with Swoole
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Mezzio与Swoole
- en: The **Mezzio** framework ([https://docs.mezzio.dev/](https://docs.mezzio.dev/))
    is the brainchild of Matthew Weier O'Phinney ([https://mwop.net/](https://mwop.net/))
    and represents a continuation of an older framework, **Zend Framework**, and a
    later one, **Zend Expressive**. Mezzio falls into the relatively new category
    of a **micro framework**. Micro frameworks do not have any reliance on the aging
    **Model-View-Controller** (**MVC**) software design pattern and are mainly oriented
    toward **RESTful API development**. In practical terms, micro frameworks support
    the principle of PHP middleware and operate with much less overhead and correspondingly
    greater speed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mezzio**框架（[https://docs.mezzio.dev/](https://docs.mezzio.dev/)）是Matthew
    Weier O''Phinney（[https://mwop.net/](https://mwop.net/)）的心血结晶，代表了一个较旧的框架**Zend
    Framework**和一个较新的框架**Zend Expressive**的延续。Mezzio属于相对较新的**微框架**类别。微框架不依赖于老化的**模型-视图-控制器**（**MVC**）软件设计模式，主要面向**RESTful
    API开发**。在实际应用中，微框架支持PHP中间件的原则，并且具有较少的开销和相应的更快速度。'
- en: 'In order to use a Mezzio application with Swoole, just the following three
    things are needed:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Swoole的Mezzio应用程序，只需要以下三件事：
- en: Install the Swoole extension (described earlier in this chapter).
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Swoole扩展（在本章前面描述）。
- en: 'Install the `mezzio-swoole` component, like this:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`mezzio-swoole`组件，就像这样：
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You would then need to run Mezzio using a Swoole server instance. This can
    be accomplished with the following command:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后需要使用Swoole服务器实例运行Mezzio。可以使用以下命令完成此操作：
- en: '[PRE29]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the configuration file for your Mezzio application, you would need to add
    the following key:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Mezzio应用程序的配置文件中，您需要添加以下密钥：
- en: '[PRE30]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To gain further performance improvements, you should of course also rewrite
    the appropriate portions of your code to take advantage of PHP async functionality.
    Next, we have a look at a PHP extension that goes beyond async.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步提高性能，当然还应该重写代码的适当部分，以利用PHP异步功能。接下来，我们来看一下超越异步的PHP扩展。
- en: Working with the parallel extension
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用并行扩展
- en: The `parallel` extension ([https://www.php.net/parallel](https://www.php.net/parallel))
    was introduced to work with PHP 7.2 and above. Its purpose is to go the next step
    beyond PHP async and into the world of full-blown parallel processing. The `parallel`
    extension provides five key low-level classes that can form the basis for a parallel-processing
    application. Using this extension allows PHP developers to write parallel code
    much like the **Go** language. Let's start with `parallel\Runtime`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`parallel`扩展（[https://www.php.net/parallel](https://www.php.net/parallel)）是为了与PHP
    7.2及以上版本一起使用而引入的。它的目的是在PHP异步之外进入全面并行处理的世界。`parallel`扩展提供了五个关键的低级类，可以构成并行处理应用程序的基础。使用此扩展允许PHP开发人员编写类似于**Go**语言的并行代码。让我们从`parallel\Runtime`开始。'
- en: The parallel\Runtime class
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: parallel\Runtime类
- en: Each `parallel\Runtime` instance spawns a new PHP thread. You can then use `parallel\Runtime::run()`
    to schedule a task. The first argument to `run()` is `Closure` (an anonymous function).
    The optional second argument is `$argv`, representing input arguments passed to
    the task at runtime. `parallel\Runtime::close()` is used to gracefully shut down
    a thread. When an error condition arises, a thread can be immediately exited using
    `parallel\Runtime::kill()`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`parallel\Runtime`实例都会生成一个新的PHP线程。然后可以使用`parallel\Runtime::run()`来安排任务。`run()`的第一个参数是`Closure`（匿名函数）。可选的第二个参数是`$argv`，表示在运行时传递给任务的输入参数。`parallel\Runtime::close()`用于优雅地关闭线程。当出现错误条件时，可以使用`parallel\Runtime::kill()`立即退出线程。
- en: The parallel\Future class
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: parallel\Future类
- en: 'A `parallel\Future` instance is created as a return value from `parallel\Runtime::run()`.
    It acts much like a PHP async *promise* (described earlier in this chapter). This
    class has three methods, listed here, that perform the following actions:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`parallel\Future`实例是从`parallel\Runtime::run()`的返回值创建的。它的作用很像PHP异步*promise*（在本章前面描述）。该类有三种方法，列在这里，执行以下操作：'
- en: '`parallel\Future::value()`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parallel\Future::value()`'
- en: Returns the fulfilled value of the task
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 返回任务的完成值
- en: '`parallel\Future::cancel()`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parallel\Future::cancel()`'
- en: Cancels the task that represents a promise *failed* state
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 取消代表*失败*状态的任务
- en: '`parallel\Future::cancelled()|done()`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parallel\Future::cancelled()|done()`'
- en: Returns task state if it's still unfulfilled
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务状态仍未实现，则返回任务状态
- en: The parallel\Channel class
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: parallel\Channel类
- en: The `parallel\Channel` class allows developers to share information between
    tasks. Use the `__construct()` method or `make()` to create a channel. If no argument
    is supplied to `__construct()` or if a second argument to `make()` is not supplied,
    the channel is considered unbuffered. If an integer is supplied to `__construct()`
    or as a second argument to `make()`, the value represents the channel's **capacity**.
    You can then use the `parallel\Channel::send()` and `parallel\Channel::recv()`
    methods to send and receive data through the channel.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`parallel\Channel`类允许开发人员在任务之间共享信息。使用`__construct()`方法或`make()`来创建一个通道。如果`__construct()`没有提供参数，或者`make()`的第二个参数没有提供，通道被认为是无缓冲的。如果向`__construct()`提供一个整数，或者向`make()`的第二个参数提供一个整数，该值表示通道的**容量**。然后，您可以使用`parallel\Channel::send()`和`parallel\Channel::recv()`方法通过通道发送和接收数据。'
- en: Unbuffered channels block calls to `send()` until there is a receiver and vice
    versa. Buffered channels, on the other hand, do not block until the capacity has
    been reached.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 无缓冲通道会阻塞对`send()`的调用，直到有接收者，反之亦然。另一方面，缓冲通道在达到容量之前不会阻塞。
- en: The parallel\Events class
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并行事件类
- en: The `parallel\Events` class is similar to the *event loop* described in the
    first section of this chapter. This class has `addChannel()` and `addFuture()`
    methods to add channels and/or future instances to monitor. The `setBlocking()`
    method allows the event loop to monitor events in either blocking or non-blocking
    modes. Use the `setTimeout()` method to set an overall control period (in milliseconds)
    for how long the loop is allowed to continue. Finally, the `poll()` method causes
    the event loop to poll for the next event.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`parallel\Events`类类似于本章第一节中描述的*事件循环*。该类具有`addChannel()`和`addFuture()`方法，用于添加要监视的通道和/或未来实例。`setBlocking()`方法允许事件循环以阻塞或非阻塞模式监视事件。使用`setTimeout()`方法设置整体控制周期（以毫秒为单位），指定循环允许继续的时间。最后，`poll()`方法导致事件循环轮询下一个事件。'
- en: Installing the parallel extension
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装并行扩展
- en: The `parallel` extension can be installed with the `pecl` command or using precompiled
    binaries, just as any other non-standard PHP extension. It's extremely important
    to note, however, that this extension only works on **Zend Thread Safety** (**ZTS**)
    PHP installations. Accordingly, if using Docker, you would need to obtain a PHP
    ZTS image, or, if custom-compiling PHP, you would need to use either the `--enable-zts`
    (Windows) or `--enable-maintainer-zts` (non-Windows) `configure` utility flag.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`parallel`扩展可以使用`pecl`命令或使用预编译的二进制文件进行安装，就像安装任何其他非标准的PHP扩展一样。然而，非常重要的是，这个扩展只能在**Zend线程安全**（**ZTS**）的PHP安装上工作。因此，如果使用Docker，您需要获取一个PHP
    ZTS镜像，或者如果自定义编译PHP，您需要使用`--enable-zts`（Windows）或`--enable-maintainer-zts`（非Windows）`configure`实用程序标志。'
- en: Now that you have an idea of how to use a number of selected PHP extensions
    and frameworks in async mode, we'll look into the future and discuss PHP 8.1 fibers.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何在异步模式下使用多个选择的PHP扩展和框架，我们将展望未来，并讨论PHP 8.1纤程。
- en: Learning about PHP 8.1 fibers
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解PHP 8.1纤程
- en: A **Request for Comments** (**RFC**) was published in March 2021 by Aaron Piotrowski
    and Niklas Keller, both PHP core team developers, outlining the case for including
    support for **fibers** in the PHP language core. The RFC was ratified at the end
    of the month and has now been implemented in the upcoming 8.1 version of PHP.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求评论**（**RFC**）于2021年3月由PHP核心团队开发人员Aaron Piotrowski和Niklas Keller发布，概述了在PHP语言核心中包含对**纤程**支持的情况。该RFC在月底得到批准，并已在即将推出的PHP
    8.1版本中实施。'
- en: The fiber implementation is low-level, meaning that it is mainly designed to
    be used as part of a PHP async framework such as ReactPHP or Amp, or an extension
    such as the Swoole extension. Because this will, as of PHP 8.1 and beyond, be
    a core part of the language, developers will not have to worry so much about which
    extensions are loaded. Also, this greatly enhances PHP async frameworks as they
    now have low-level support, directly in the language core, greatly improving performance.
    Let's now have a look at the `Fiber` class itself.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 纤程实现是低级的，这意味着它主要设计用作PHP异步框架（如ReactPHP或Amp）或扩展（如Swoole扩展）的一部分。因为从PHP 8.1开始，这将成为语言的核心部分，开发人员不必太担心加载哪些扩展。此外，这极大地增强了PHP异步框架，因为它们现在在语言核心中直接获得低级支持，大大提高了性能。现在让我们来看一下`Fiber`类本身。
- en: Discovering the Fiber class
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现Fiber类
- en: The PHP 8.1 `Fiber` class offers a bare-bones implementation upon which async
    framework and extension developers can build timers, event loops, promises, and
    other async artifacts.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8.1的`Fiber`类提供了一个基本的实现，异步框架和扩展开发人员可以在此基础上构建定时器、事件循环、承诺和其他异步工件。
- en: 'Here is the formal class definition:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是正式的类定义：
- en: '[PRE31]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is a summary of the `Fiber` class methods:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Fiber`类方法的摘要：
- en: '![Table 12.3 – Fiber class method summary'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![表12.3 - Fiber类方法摘要'
- en: '](image/Table_12.3_B16992.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_12.3_B16992.jpg)'
- en: Table 12.3 – Fiber class method summary
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.3 - Fiber类方法摘要
- en: As you can see from *Table 12.3*, after creating a `Fiber` instance, use `start()`
    to run the callback associated with the fiber. After that, you are free to suspend,
    resume, or cause the fiber to fail, using `throw()`. You can also just let the
    callback run in its own fiber, and use `getReturn()` to retrieve the returned
    information. You might also note that the `is*()` methods can be used to determine
    the fiber's state at any given moment.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从*表12.3*中所见，创建`Fiber`实例后，使用`start()`来运行与纤程关联的回调。之后，您可以自由地挂起、恢复或导致纤程失败，使用`throw()`。您也可以让回调在自己的纤程中运行，并使用`getReturn()`来检索返回的信息。您还可以注意到，`is*()`方法可以用来确定纤程在任何给定时刻的状态。
- en: Tip
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on the PHP 8.1 fibers implementation, please have a look
    at the following RFC: [https://wiki.php.net/rfc/fibers](https://wiki.php.net/rfc/fibers).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PHP 8.1纤程实现的更多信息，请参阅以下RFC：[https://wiki.php.net/rfc/fibers](https://wiki.php.net/rfc/fibers)。
- en: Let's now have a look at an example that illustrates the use of fibers.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个示例，说明如何使用纤程。
- en: Using fibers
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用纤程
- en: PHP 8.1 fibers form the basis of a PHP async application. Although the primary
    audience for fibers is framework and extension developers, any PHP developer can
    benefit from this class. To illustrate the problem PHP fibers can solve, let's
    have a look at a simple example.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8.1 fibers 构成了 PHP 异步应用程序的基础。尽管 fibers 的主要受众是框架和扩展开发人员，但任何 PHP 开发人员都可以从这个类中受益。为了说明
    PHP fibers 可以解决的问题，让我们看一个简单的例子。
- en: Defining a sample program that performs blocking operations
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义一个执行阻塞操作的示例程序
- en: 'In this example, written using the synchronous programming model, we perform
    three actions, as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，使用同步编程模型，我们执行三个操作，如下：
- en: Execute an HTTP `GET` request.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 HTTP `GET` 请求。
- en: Perform a database query.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行数据库查询。
- en: Write information to an access log.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将信息写入访问日志。
- en: 'Already having some knowledge of async programming, you realize that all three
    tasks represent *blocking* operations. Here are the steps we''ll take:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 已经具有一些异步编程知识的你意识到，所有三个任务都代表着 *阻塞* 操作。我们将采取以下步骤：
- en: 'First, we define a PHP file to be included that defines the callbacks:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个要包含的 PHP 文件，其中定义了回调：
- en: '[PRE32]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we define a PHP program that includes the callbacks'' definition and
    executes them sequentially. We use a PHP 8 `match {}` construct to assign different
    arguments to pass to the appropriate callback. Finally, we return the number of
    bytes generated by the callback by simply returning a string and running `strlen()`:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个包含回调定义并按顺序执行它们的 PHP 程序。我们使用 PHP 8 的 `match {}` 结构来为适当的回调分配不同的参数。最后，我们通过简单返回一个字符串并运行
    `strlen()` 来返回回调生成的字节数：
- en: '[PRE33]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we then run the program as is, the results are predictably abysmal, as we
    can see here:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按原样运行程序，结果可预见地糟糕，就像我们在这里看到的一样：
- en: '[PRE34]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The **Uniform Resource Locator** (**URL**) request to download Tolstoy's *War
    and Peace* took the most time and produced a byte count of over 3 million. The
    total elapsed time was a fraction over 6 seconds.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一资源定位符**（**URL**）请求下载托尔斯泰的《战争与和平》花费了最长的时间，产生了超过 300 万字节的字节数。总共经过的时间略超过 6
    秒。'
- en: Let's now look at how the calling program could be rewritten using fibers.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用 fibers 重写调用程序。
- en: Example program using fibers
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 fibers 的示例程序
- en: 'From the PHP 8.1 Docker container, we can define a calling program that uses
    fibers. Here are the steps to do this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 从 PHP 8.1 Docker 容器中，我们可以定义一个使用 fibers 的调用程序。以下是这样做的步骤：
- en: 'First, we include the callbacks, as we did earlier, like this:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们像之前一样包含回调，像这样：
- en: '[PRE35]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we create a `Fiber` instance to wrap each callback. We then use `start()`
    to start the callback, supplying the appropriate information:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个 `Fiber` 实例来包装每个回调。然后使用 `start()` 启动回调，提供适当的信息：
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We then set up a loop and check in on each callback to see if it''s finished.
    If so, we echo the results from `getReturn()` and unset the fiber:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们设置一个循环，并检查每个回调是否已经完成。如果是，我们从 `getReturn()` 中输出结果并取消 fiber：
- en: '[PRE37]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Please note that this example is for illustration only. It's far more likely
    that you would use an existing framework such as ReactPHP or Amp, both of which
    have been rewritten to take advantage of PHP 8.1 fibers. It's also important to
    note that even if multiple fibers are running simultaneously, the shortest runtime
    you can achieve is directly proportionate to the amount of time taken by the longest-running
    task. Let's now have a look at the effect of fibers on ReactPHP and Swoole.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此示例仅用于说明。更有可能的是，您会使用现有的框架，如 ReactPHP 或 Amp，它们都已重写以利用 PHP 8.1 fibers。还要注意，即使多个
    fibers 同时运行，您可以实现的最短运行时间也与最长运行任务所花费的时间成正比。现在让我们看看 fibers 对 ReactPHP 和 Swoole 的影响。
- en: Examining the effect of fibers on ReactPHP and Swoole
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 fibers 对 ReactPHP 和 Swoole 的影响
- en: For this illustration, you need to open two separate command shells into the
    PHP 8.1 Docker container. Follow the directions given in the previous section,
    but open two command shells instead of one. We will then use the `/repo/ch12/php8_chat_test.php`
    program to test the effect of fibers. Let's run the first test, using the built-in
    PHP web server as a control.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，您需要在 PHP 8.1 Docker 容器中打开两个单独的命令 shell。按照上一节中给出的说明操作，但打开两个命令 shell 而不是一个。然后我们将使用
    `/repo/ch12/php8_chat_test.php` 程序来测试 fibers 的影响。让我们运行第一个测试，使用内置的 PHP web 服务器作为对照。
- en: Testing using the built-in PHP web server
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内置的 PHP web 服务器进行测试
- en: 'In the first test, we use the built-in PHP web server and the conventional
    `/repo/ch12/php8_chat_ajax.php` implementation. Here are the steps we''ll take:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试中，我们使用内置的 PHP web 服务器和传统的 `/repo/ch12/php8_chat_ajax.php` 实现。我们将采取以下步骤：
- en: 'In both command shells, change to the `/repo/ch12` directory, like this:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个命令 shell 中，切换到 `/repo/ch12` 目录，像这样：
- en: '[PRE38]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the first command shell, run a standard HTTP server using the built-in PHP
    web server, with this command:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个命令 shell 中，使用内置的 PHP web 服务器运行标准的 HTTP 服务器，使用以下命令：
- en: '[PRE39]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the second command shell, execute the test program, as shown:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个命令 shell 中，执行测试程序，如下所示：
- en: '[PRE40]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The resulting output should look something like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出应该是这样的：
- en: '[PRE41]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, the conventional code, written using synchronous programming,
    came in at around 1.7 seconds for 1,000 iterations. Let's now have a look at running
    the same test using ReactPHP.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用同步编程编写的传统代码，在 1000 次迭代中大约需要 1.7 秒。现在让我们看看使用 ReactPHP 运行相同测试的情况。
- en: Testing using ReactPHP
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ReactPHP 进行测试
- en: 'In the second test, we use our `/repo/ch12/php8_chat_react.php` ReactPHP implementation.
    Here are the steps we''ll take:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个测试中，我们使用我们的 `/repo/ch12/php8_chat_react.php` ReactPHP 实现。我们将采取以下步骤：
- en: In the first command shell, hit *Ctrl* + *C* to exit the built-in PHP web server.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个命令 shell 中，按下 *Ctrl* + *C* 退出内置的 PHP web 服务器。
- en: Exit and re-enter the first command shell using `exit`, followed by either `init
    shell` for Windows or `./init.sh shell` for Linux or Mac.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `exit` 退出第一个命令 shell，然后使用 `init shell`（Windows）或 `./init.sh shell`（Linux
    或 Mac）重新进入。
- en: 'Start the ReactPHP server using this command:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动 ReactPHP 服务器：
- en: '[PRE42]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the second command shell, execute the test program, like this:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个命令行窗口中，执行测试程序，就像这样：
- en: '[PRE43]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The resulting output should look something like this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE44]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: From the output, you can see that ReactPHP benefits greatly from fibers. The
    total elapsed time was an impressive `1.2` seconds for 1,000 iterations!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，您可以看到 ReactPHP 从 fibers 中受益匪浅。1000 次迭代的总耗时令人印象深刻，为 `1.2` 秒！
- en: This concludes our discussion of PHP 8.1 fibers. You now have an idea of what
    fibers are and how they can be used directly in your program code, as well as
    how they benefit external PHP async frameworks.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对 PHP 8.1 fibers 的讨论。您现在知道了 fibers 是什么，以及它们如何直接在您的程序代码中使用，以及它们如何使外部 PHP
    异步框架受益。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned the difference between conventional synchronous
    programming and asynchronous programming. Key terms such as event loops, timers,
    promises, and channels were covered. This knowledge gives you the ability to determine
    when a block of code is written using the asynchronous programming model, and
    how to rewrite portions of existing synchronous model applications to take advantage
    of asynchronous features.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了传统同步编程和异步编程之间的区别。涵盖了事件循环、定时器、承诺和通道等关键术语。这些知识使您能够确定何时使用异步编程模型编写代码块，以及如何重写现有同步模型应用程序的部分以利用异步特性。
- en: You then learned about the Swoole extension and how it can be applied to existing
    application code to achieve performance improvements. You also learned about a
    number of other frameworks and extensions that operate in an asynchronous manner.
    You reviewed concrete code examples and now have a headstart on writing asynchronous
    code.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您了解了 Swoole 扩展以及如何将其应用于现有应用程序代码以实现性能改进。您还了解了一些其他以异步方式运行的框架和扩展。您回顾了具体的代码示例，现在可以开始编写异步代码了。
- en: In the last section, you were introduced to PHP 8.1 fibers. You then reviewed
    a code example showing you how to create cooperative multitasking functions and
    class methods using PHP 8.1 fibers. You also saw how selected PHP async frameworks
    are able to benefit from PHP 8.1 fiber support, providing even more performance
    improvements.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，您了解了 PHP 8.1 fibers。然后，您回顾了一个代码示例，向您展示了如何使用 PHP 8.1 fibers 创建协作多任务函数和类方法。您还看到了选择的
    PHP 异步框架如何能够从 PHP 8.1 fibers 支持中受益，提供了更多的性能改进。
- en: This is the last chapter in the book. We hope you have enjoyed reviewing the
    vast array of new features and benefits made available in PHP 8\. You also now
    have a deeper understanding of potential traps to avoid in object-oriented and
    procedural code, as well as various changes to PHP 8 extensions. With this knowledge,
    not only are you now in a position to write better code, but you also have a solid
    plan of action that minimizes the chance of application code failure following
    a PHP 8 migration.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章。我们希望您喜欢回顾 PHP 8 中提供的各种新功能和好处。您现在对面向对象和过程式代码中要避免的潜在陷阱有了更深入的了解，以及对 PHP
    8 扩展的各种更改。有了这些知识，您不仅能够写出更好的代码，而且还有一个坚实的行动计划，最大程度地减少了 PHP 8 迁移后应用代码失败的可能性。
