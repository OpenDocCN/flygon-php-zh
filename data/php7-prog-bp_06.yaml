- en: Chapter 6.  Building a Chat Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。构建聊天应用程序
- en: In this chapter, we will build a real-time chat application using**WebSocket**.
    You will learn how to use the **Ratchet** framework to build standalone WebSocket
    and HTTP servers with PHP and how to connect to WebSocket servers in a JavaScript
    client application. We will also discuss how you can implement authentication
    for WebSocket applications and how to deploy them in a production environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用**WebSocket**构建一个实时聊天应用程序。您将学习如何使用**Ratchet**框架使用PHP构建独立的WebSocket和HTTP服务器，以及如何在JavaScript客户端应用程序中连接到WebSocket服务器。我们还将讨论如何为WebSocket应用程序实现身份验证以及如何在生产环境中部署它们。
- en: The WebSocket protocol
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSocket协议
- en: In this chapter, we'll be working extensively with WebSockets. To fully understand
    the workings of the chat application that we're going to build, let's first have
    a look at how WebSockets work.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将广泛使用WebSocket。为了充分理解我们将要构建的聊天应用程序的工作原理，让我们首先看一下WebSocket的工作原理。
- en: The WebSockets protocol is specified in **RFC 6455** and uses HTTP as the underlying
    transport protocol. In contrast to the traditional request/reply paradigm, in
    which the client sends a request to the server, who then replies with a response
    message, WebSocket connections can be kept open for a long time, and both server
    and client can send and receive messages (or *data frames*) on the WebSocket.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket协议在**RFC 6455**中指定，并使用HTTP作为底层传输协议。与传统的请求/响应范式相比，在该范式中，客户端向服务器发送请求，服务器然后回复响应消息，WebSocket连接可以保持打开很长时间，服务器和客户端都可以在WebSocket上发送和接收消息（或*数据帧*）。
- en: 'WebSocket connections are always initiated by the client (so, typically, a
    user''s browser). The following listing shows an example request that a browser
    might send to a server supporting WebSockets:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket连接始终由客户端（通常是用户的浏览器）发起。下面的清单显示了浏览器可能发送给支持WebSocket的服务器的示例请求：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Just like regular HTTP requests, the request contains a request method (`GET`)
    and a path (`/chat`). The `Upgrade` and `Connection` headers tell the server that
    the client would like to *upgrade* the regular HTTP connection into a WebSocket
    connection.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 就像常规的HTTP请求一样，请求包含一个请求方法（`GET`）和一个路径（`/chat`）。`Upgrade`和`Connection`头告诉服务器，客户端希望将常规HTTP连接升级为WebSocket连接。
- en: The `Sec-WebSocket-Key` header contains a random, base64-encoded string that
    uniquely identifies this single WebSocket connection. The `Sec-WebSocket-Protocol`
    header can be used to specify a subprotocol that the client would like to use.
    Subprotocols can be used to further define what the communication between the
    server and the client should look like and are often application-specific (in
    our case, the `chat` protocol).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sec-WebSocket-Key`头包含一个随机的、base64编码的字符串，唯一标识这个单个WebSocket连接。`Sec-WebSocket-Protocol`头可以用来指定客户端想要使用的子协议。子协议可以用来进一步定义服务器和客户端之间的通信应该是什么样子的，并且通常是特定于应用程序的（在我们的情况下，是`chat`协议）。'
- en: 'When the server accepts the upgrade request, it will respond with a `101 Switching
    Protocols` response, as shown in the following listing:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器接受升级请求时，它将以`101 Switching Protocols`响应作为响应，如下面的清单所示：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Sec-WebSocket-Accept` header contains a hash of the `Sec-WebSocket-Key`
    from the request (the exact hashing is specified in RFC 6455). The `Sec-WebSocket-Protocol`
    header in the response confirms that the server understands the protocol that
    the client specified in its request.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sec-WebSocket-Accept`头包含了来自请求的`Sec-WebSocket-Key`的哈希值（确切的哈希值在RFC 6455中指定）。响应中的`Sec-WebSocket-Protocol`头确认了服务器理解客户端在请求中指定的协议。'
- en: After this handshake is completed, the connection will stay open and both server
    and client can send and receive messages from the socket.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个握手之后，连接将保持打开状态，服务器和客户端都可以从套接字发送和接收消息。
- en: First steps with Ratchet
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ratchet的第一步
- en: In this section, you will learn how to install and use the Ratchet framework.
    It's important to note that Ratchet applications work differently than regular
    PHP applications that are deployed in a web server and work on a per-request basis.
    This will require you to adopt a new way of thinking of how PHP applications are
    run and deployed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何安装和使用Ratchet框架。需要注意的是，Ratchet应用程序的工作方式与部署在Web服务器上并且基于每个请求工作的常规PHP应用程序不同。这将要求您采用一种新的思考方式来运行和部署PHP应用程序。
- en: Architectural considerations
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构考虑
- en: 'Implementing a WebSocket server with PHP is not trivial. Traditionally, PHP''s
    architecture revolves around the classical request/reply paradigm: the web server
    receives a request, passes it to the PHP interpreter (which is typically built
    into the web server or managed by a process manager such as PHP-FPM), which processes
    the request and returns a response to the web server who in turn responds to the
    client. The lifetime of data in a PHP script is limited to a single request (a
    principle that is called **Shared Nothing**).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PHP实现WebSocket服务器并不是一件简单的事情。传统上，PHP的架构围绕着经典的请求/响应范式：Web服务器接收请求，将其传递给PHP解释器（通常内置于Web服务器中或由进程管理器（如PHP-FPM）管理），解析请求并将响应返回给Web服务器，然后Web服务器再响应客户端。PHP脚本中数据的生命周期仅限于单个请求（这一原则称为**共享无状态**）。
- en: This works well for classical web applications; especially the Shared Nothing
    principle as it is one of the reasons that PHP applications usually scale very
    well. However, for WebSocket support, we need a different paradigm. Client connections
    need to stay open for a very long time (hours, potentially days) and servers need
    to react to client messages at any time during the connection lifetime.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于传统的Web应用程序非常有效；特别是共享无状态原则，因为这是PHP应用程序通常很好扩展的原因之一。然而，对于WebSocket支持，我们需要一种不同的范式。客户端连接需要保持打开状态很长时间（可能是几个小时，甚至几天），服务器需要在连接的整个生命周期内随时对客户端消息做出反应。
- en: One library that implements this new paradigm is the `Ratchet` library that
    we'll be working with in this chapter. In contrast to regular PHP runtimes that
    live within a web server, Ratchet will start its own web server that can serve
    long-running WebSocket connections. As you'll be dealing with PHP processes with
    extremely long run times (a server process may run for days, weeks, or months),
    you will need to pay special attention to things such as memory consumption.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种新范式的一个库是我们在本章中将要使用的`Ratchet`库。与常规的PHP运行时不同，它们存在于Web服务器中，Ratchet将启动自己的Web服务器，可以为长时间运行的WebSocket连接提供服务。由于您将处理具有极长运行时间的PHP进程（服务器进程可能运行数天、数周或数月），因此您需要特别注意诸如内存消耗之类的事项。
- en: Getting started
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: 'Ratchet can be easily installed using**Composer**. It requires PHP in at least
    version 5.3.9 and also works well with PHP 7\. Start by initializing a new project
    with the `composer init` command on a command line in your project directory:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '使用**Composer**可以轻松安装Ratchet。它需要至少版本为5.3.9的PHP，并且也与PHP 7兼容。首先，在项目目录的命令行上使用`composer
    init`命令初始化一个新项目： '
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, add Ratchet as a dependency to your project:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将Ratchet添加为项目的依赖项：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Also, configure Composer''s autoloader by adding the following section to the
    generated `composer.json` file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过向生成的`composer.json`文件添加以下部分来配置Composer的自动加载器：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As usual, PSR-4 autoloading means that the Composer class loader will look for
    classes of the `Packt\Chp6\Example` namespace within the `src/` folder of your
    project directory. A (hypothetical) `Packt\Chp6\Example\Foo\Bar` class would need
    to be defined in the file `src/Foo/Bar.php` file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，PSR-4自动加载意味着Composer类加载器将在项目目录的`src/`文件夹中查找`Packt\Chp6\Example`命名空间的类。一个（假设的）`Packt\Chp6\Example\Foo\Bar`类需要在`src/Foo/Bar.php`文件中定义。
- en: 'As Ratchet implements its own web server, you will not need a dedicated web
    server such as **Apache** or **Nginx** (for now). Start by creating a file called `server.php`,
    in which you initialize and run the Ratchet web server:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ratchet实现了自己的Web服务器，您将不需要专用的Web服务器，如**Apache**或**Nginx**（目前）。首先创建一个名为`server.php`的文件，在其中初始化和运行Ratchet
    Web服务器：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can then start your web server (it will listen on the port that you have
    specified as the second parameter of the `Ratchet\App` constructor) using the
    following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以启动您的Web服务器（它将侦听您在`Ratchet\App`构造函数的第二个参数中指定的端口）使用以下命令：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you do not have a PHP 7 installation ready on your machine, you can get
    started quickly with**Docker**, using the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的计算机上没有准备好PHP 7安装，您可以使用以下命令快速开始使用**Docker**：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Both of these commands will start a long-running PHP process that can directly
    handle HTTP requests on your command line. In a later section, you will learn
    how to deploy your application to production servers. Of course, this server does
    not really do much, yet. However, you can still test it using a CLI command or
    your browser, as shown in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令都将启动一个长时间运行的PHP进程，可以直接在命令行上处理HTTP请求。在后面的部分中，您将学习如何将应用程序部署到生产服务器上。当然，这个服务器实际上并没有做太多事情。但是，您仍然可以使用CLI命令或浏览器进行测试，如下面的屏幕截图所示：
- en: '![Getting started](graphics/image_06_001.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![入门](graphics/image_06_001.jpg)'
- en: Testing the example application with HTTPie
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTPie测试示例应用程序
- en: 'Let''s continue by adding some business logic to our server. WebSocket applications
    served by Ratchet need to be PHP classes that implement `Ratchet\MessageComponentInterface`.
    This interface defines the following four methods:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续向我们的服务器添加一些业务逻辑。由Ratchet提供服务的WebSocket应用程序需要是实现`Ratchet\MessageComponentInterface`的PHP类。此接口定义了以下四种方法：
- en: '`onOpen(\Ratchet\ConnectionInterface $c)` will be called whenever a new client
    connects to the WebSocket server'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onOpen(\Ratchet\ConnectionInterface $c)`将在新客户端连接到WebSocket服务器时调用'
- en: '`onClose(\Ratchet\ConnectionInterface $c)` will be called when a client disconnects
    from the server'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onClose(\Ratchet\ConnectionInterface $c)`将在客户端从服务器断开连接时调用'
- en: '`onMessage(\Ratchet\ConnectionInterface $sender, $msg)` will be called when
    a client sends a message to the server'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMessage(\Ratchet\ConnectionInterface $sender, $msg)`将在客户端向服务器发送消息时调用'
- en: '`onError(\Ratchet\ConnectionInterface $c, \Exception $e)` will be called when
    an exception occurred at some point while handling a message'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError(\Ratchet\ConnectionInterface $c, \Exception $e)`将在处理消息时发生异常时调用'
- en: 'Let''s start with a simple example: a WebSocket service that clients can send
    messages to, and it will respond to the same client with the same message, but
    reversed. Let''s call this class `Packt\Chp6\Example\ReverseEchoComponent`; the
    code is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始：一个WebSocket服务，客户端可以向其发送消息，它将以相同的消息但是反向的方式回复给同一个客户端。让我们称这个类为`Packt\Chp6\Example\ReverseEchoComponent`；代码如下：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that although we do not need all of the methods specified by the `MessageComponentInterface`,
    we need to implement all of them nonetheless in order to satisfy the interface.
    For example, if you do not need anything special to happen when a client connects
    or disconnects, implement the `onOpen` and `onClose` methods, but just leave them
    empty.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管我们不需要`MessageComponentInterface`指定的所有方法，但我们仍然需要实现所有这些方法，以满足接口。例如，如果在客户端连接或断开连接时不需要发生任何特殊的事情，则实现`onOpen`和`onClose`方法，但只需将它们留空即可。
- en: 'In order to better understand what''s happening in this application, add some
    simple debug messages to the `onOpen` and `onClose` methods, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解此应用程序中发生的情况，请向`onOpen`和`onClose`方法添加一些简单的调试消息，如下所示：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, implement the `onMessage` method. The `$msg` parameter will contain the
    message that was sent by the client as string, and you can use the `ConnectionInterface`
    class'' `send()` method to send messages back to the client, as shown in the following
    code snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，实现`onMessage`方法。`$msg`参数将包含客户端发送的消息作为字符串，并且您可以使用`ConnectionInterface`类的`send()`方法将消息发送回客户端，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You might be inclined to use PHP 7's new type hinting feature to hint the `$msg`
    parameter as `string`. This does not work in this case, because it would change
    the method's interface that is prescribed by the `Ratchet\MessageComponentInterface`
    and cause a fatal error.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能倾向于使用PHP 7的新类型提示功能来提示`$msg`参数为`string`。在这种情况下，这是行不通的，因为它会改变由`Ratchet\MessageComponentInterface`规定的方法接口，并导致致命错误。
- en: 'You can then register your WebSocket application at the `Ratchet\App` instance
    in your `server.php` file using the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用以下代码在`server.php`文件中将您的WebSocket应用程序注册到`Ratchet\App`实例中：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Testing WebSocket applications
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试WebSocket应用程序
- en: 'To test WebSocket applications, I can recommend the **wscat **tool. It is a
    command-line tool written in JavaScript (and thus requires Node.js to be running
    on your machine) and can be installed using `npm`, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试WebSocket应用程序，我可以推荐**wscat**工具。它是一个用JavaScript编写的命令行工具（因此需要在您的计算机上运行Node.js），可以使用`npm`进行安装，如下所示：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With the WebSocket server listening at port `8080`, you can use `wscat` to
    open a new WebSocket connection using the following CLI command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WebSocket服务器监听端口`8080`，您可以使用以下CLI命令使用`wscat`打开新的WebSocket连接：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will open a command-line prompt in which you can enter messages that are
    sent to the WebSocket server. Messages received from the server will also be displayed.
    See the following screenshot for an example output of both the WebSocket server
    and wscat:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个命令行提示符，您可以在其中输入要发送到WebSocket服务器的消息。还将显示从服务器接收到的消息。请参见以下屏幕截图，了解WebSocket服务器和wscat的示例输出：
- en: '![Testing WebSocket applications](graphics/image_06_002.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![测试WebSocket应用程序](graphics/image_06_002.jpg)'
- en: Testing WebSocket applications using wscat
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用wscat测试WebSocket应用程序
- en: Playing with the event loop
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩转事件循环
- en: In the preceding example, you have only sent messages to clients after having
    received a message from the same client. This is the traditional request/reply
    communication pattern that works well in most scenarios. However, it is important
    to understand that when using WebSockets, you are not forced to follow this pattern,
    but can send messages to connected clients at any time you like.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您只在收到来自同一客户端的消息后才向客户端发送消息。这是在大多数情况下都能很好地工作的传统请求/回复通信模式。但是，重要的是要理解，当使用WebSocket时，您并不被强制遵循这种模式，而是可以随时向连接的客户端发送消息。
- en: In order to gain a better understanding of the possibilities you have in a Ratchet
    application, let's have a look at the architecture of Ratchet. Ratchet is built
    on ReactPHP; an event-driven framework for network applications. The central component
    of a React application is the **event loop**. Each event that is triggered in
    the application (for example, when a new user connects or sends a message to the
    server) is stored in a queue, and the event loop processes all events stored in
    this queue.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解您在Ratchet应用程序中拥有的可能性，让我们来看看Ratchet的架构。Ratchet是建立在ReactPHP之上的；一个用于网络应用程序的事件驱动框架。React应用程序的核心组件是**事件循环**。应用程序中触发的每个事件（例如，当新用户连接或向服务器发送消息时）都存储在队列中，事件循环处理存储在此队列中的所有事件。
- en: ReactPHP offers different implementations of event loops. Some of these require
    additional PHP extensions such as `libevent` or `ev` to be installed (and typically,
    the event loops based on `libevent`, `ev`, or similar extensions offer the best
    performance). Usually, applications like Ratchet will automatically choose which
    event loop implementation to use so that you do not need to concern yourself with
    the inner workings of ReactPHP if you do not want to.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ReactPHP提供了不同的事件循环实现。其中一些需要安装额外的PHP扩展，如`libevent`或`ev`（通常，基于`libevent`、`ev`或类似扩展的事件循环提供最佳性能）。通常，像Ratchet这样的应用程序会自动选择要使用的事件循环实现，因此如果您不想要关心ReactPHP的内部工作，通常不需要担心。
- en: By default, a Ratchet application creates its own event loop; however, you can
    also inject your own event loop into the `Ratchet\App` class that you've created
    yourself.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ratchet应用程序会创建自己的事件循环；但是，您也可以将自己创建的事件循环注入到`Ratchet\App`类中。
- en: 'All ReactPHP event loops must implement the interface `React\EventLoop\LoopInterface`.
    You can use the class `React\EventLoop\Factory` to automatically create an implementation
    of this interface that is supported by your environment:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有ReactPHP事件循环都必须实现接口`React\EventLoop\LoopInterface`。您可以使用类`React\EventLoop\Factory`自动创建一个在您的环境中受支持的此接口的实现：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can then pass this `$loop` variable into your Ratchet application:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以将这个`$loop`变量传递到您的Ratchet应用程序中：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Having direct access to the event loop allows you to implement some interesting
    features. For example, you can use the event loop''s `addPeriodicTimer` function
    to register a callback that will be executed by the event loop in a periodic interval.
    Let''s use this feature in a short example by building a new WebSocket component
    called `Packt\Chp6\Example\PingComponent`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 直接访问事件循环允许您实现一些有趣的功能。例如，您可以使用事件循环的`addPeriodicTimer`函数注册一个回调，该回调将在周期性间隔内由事件循环执行。让我们在一个简短的示例中使用这个特性，通过构建一个名为`Packt\Chp6\Example\PingComponent`的新WebSocket组件：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this example, the `$users` property will help us to keep track of connected
    users. Each time a new client connects, we can use the `onOpen` event to store
    the connection in the `$users` property, and use the `onClose` event to remove
    the connection:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`$users`属性将帮助我们跟踪连接的用户。每当新客户端连接时，我们可以使用`onOpen`事件将连接存储在`$users`属性中，并使用`onClose`事件来移除连接：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As our WebSocket component now knows the connected users, we can use the event
    loop to register a timer that periodically broadcasts messages to all connected
    users. This can be easily done in the constructor:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的WebSocket组件现在知道了连接的用户，我们可以使用事件循环来注册一个定时器，定期向所有连接的用户广播消息。这可以很容易地在构造函数中完成：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The function passed to `addPeriodicTimer` will be called every five seconds
    and will send a message with an incrementing counter to each connected user. Modify
    your `server.php` file to add this new component to your Ratchet application:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `addPeriodicTimer` 的函数将每五秒钟被调用一次，并向每个连接的用户发送一个带有递增计数器的消息。修改您的 `server.php`
    文件，将这个新组件添加到您的 Ratchet 应用程序中：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can again test this WebSocket handler using wscat, as shown in the following
    screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以再次使用 wscat 测试这个 WebSocket 处理程序，如下截图所示：
- en: '![Playing with the event loop](graphics/image_06_003.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![Playing with the event loop](graphics/image_06_003.jpg)'
- en: Periodic messages cast by a periodic event loop timer
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 定期事件循环计时器发送的周期性消息
- en: This is a good example of a scenario in which a WebSocket client receives updates
    from a server without having explicitly requested them. This offers efficient
    ways to push new data to connected clients in near real-time, without the need
    to repeatedly poll for information.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的例子，说明了 WebSocket 客户端在没有明确请求的情况下从服务器接收更新。这提供了有效的方式，以几乎实时地向连接的客户端推送新数据，而无需重复轮询信息。
- en: Implementing the chat application
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现聊天应用程序
- en: After this short introduction in the development with WebSockets, let us now
    begin implementing the actual chat application. The chat application will consist
    of the server-side application built in PHP with Ratchet, and an HTML and JavaScript-based
    client that will run in the user's browser.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个关于使用 WebSocket 进行开发的简短介绍之后，让我们现在开始实现实际的聊天应用程序。聊天应用程序将由使用 Ratchet 构建的 PHP
    服务器端应用程序和在用户浏览器中运行的基于 HTML 和 JavaScript 的客户端组成。
- en: Bootstrapping the project server-side
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动项目服务器端
- en: 'As mentioned in the previous section, applications based on ReactPHP will achieve
    the best performance when used with an event-loop extension such as `libevent`
    or `ev`. Unfortunately, the `libevent` extension is not compatible with PHP 7,
    yet. Luckily, ReactPHP also works with the `ev` extension, whose latest version
    already supports PHP 7\. Just like in the previous chapter, we''ll be working
    with Docker in order to have a clean software stack to work on. Start by creating
    a *Dockerfile* for your application container:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，基于 ReactPHP 的应用程序在与事件循环扩展（如 `libevent` 或 `ev`）一起使用时将获得最佳性能。不幸的是，`libevent`
    扩展与 PHP 7 不兼容。幸运的是，ReactPHP 也可以与 `ev` 扩展一起使用，其最新版本已经支持 PHP 7。就像在上一章中一样，我们将使用 Docker
    来创建一个干净的软件堆栈。首先为您的应用程序容器创建一个 *Dockerfile*：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You will then be able to build an image from this file and start the container
    using the following CLI command from within your project directory:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将能够从该文件构建一个镜像，并使用以下 CLI 命令从项目目录内启动容器：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that this command will not actually work as long as there is no `server.php`
    file in your project directory.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只要您的项目目录中没有 `server.php` 文件，这个命令实际上是不会起作用的。
- en: 'Just as in the previous example, we will be using Composer as well for dependency
    management and for autoloading. Create a new folder for your project and create
    a `composer.json` file with the following contents:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在前面的示例中一样，我们也将使用 Composer 进行依赖管理和自动加载。为您的项目创建一个新的文件夹，并创建一个 `composer.json`
    文件，其中包含以下内容：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Continue by installing all required packages by running `composer install`
    in your project directory and create a provisional `server.php` file with the
    following contents:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在项目目录中运行 `composer install` 安装所有必需的软件包，并创建一个临时的 `server.php` 文件，其中包含以下内容：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You have already used the `Ratchet\App` constructor in the introductory example.
    A few words concerning this class'' constructor parameters:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在介绍示例中使用了 `Ratchet\App` 构造函数。关于这个类的构造函数参数有几点需要注意：
- en: The first parameter, `$httpHost` is the HTTP hostname at which your application
    will be available. This value will be used as the allowed origin host. This means
    that when your server is listening on `localhost`, only JavaScript running on
    the `localhost` domain will be allowed to connect to your WebSocket server.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数 `$httpHost` 是您的应用程序将可用的 HTTP 主机名。这个值将被用作允许的来源主机。这意味着当您的服务器监听 `localhost`
    时，只有在 `localhost` 域上运行的 JavaScript 才能连接到您的 WebSocket 服务器。
- en: The `$port` parameter is specified at which port your WebSocket server will
    listen on. Port `8080` will suffice for now; in a later section, you will learn
    how you can safely configure your application to be available on the HTTP standard
    port `80`.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$port` 参数指定了您的 WebSocket 服务器将监听的端口。端口 `8080` 现在足够了；在后面的部分，您将学习如何安全地配置您的应用程序以在
    HTTP 标准端口 `80` 上可用。'
- en: The `$address` parameter describes the IP address the WebSocket server will
    listen on. This parameter's default value is `'127.0.0.1'`, which would allow
    clients running on the same machine to connect to your WebSocket server. This
    won't work when you are running your application in a Docker container. The string
    `'0.0.0.0'` will instruct the application to listen on all available IP addresses.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$address` 参数描述了 WebSocket 服务器将监听的 IP 地址。这个参数的默认值是 `''127.0.0.1''`，这将允许在同一台机器上运行的客户端连接到您的
    WebSocket 服务器。当您在 Docker 容器中运行应用程序时，这是行不通的。字符串 `''0.0.0.0''` 将指示应用程序监听所有可用的 IP
    地址。'
- en: The fourth parameter, `$loop`, allows you to inject a custom event loop into
    the Ratchet application. If you do not pass this parameter, Ratchet will construct
    its own event loop.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数 `$loop` 允许您将自定义事件循环注入 Ratchet 应用程序。如果不传递此参数，Ratchet 将构造自己的事件循环。
- en: 'You should now be able to start your application container using the following
    command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该能够使用以下命令启动您的应用程序容器：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As your application is now one single, long-running PHP process, changes to
    your PHP code base will not become effective until you restart the server. Keep
    in mind that you stop the server using *Ctrl* + *C* and restart it using the same
    command (or using the `docker restart chat-app` command) when making changes to
    your application's PHP code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的应用程序现在是一个单一的、长时间运行的 PHP 进程，对 PHP 代码库的更改在重新启动服务器之前不会生效。请记住，当您对应用程序的 PHP 代码进行更改时，使用
    *Ctrl* + *C* 停止服务器，并使用相同的命令重新启动服务器（或使用 `docker restart chat-app` 命令）。
- en: Bootstrapping the HTML user interface
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导HTML用户界面
- en: 'The user interface for our chat application will be based on HTML, CSS, and
    JavaScript. For managing frontend dependencies, we will be using **Bower** in
    this example. You can install Bower using `npm` with the following command (as
    root or with `sudo`):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天应用程序的用户界面将基于HTML、CSS和JavaScript。为了管理前端依赖关系，在本例中我们将使用**Bower**。您可以使用以下命令（作为root用户或使用`sudo`）安装Bower：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Continue by creating a new directory `public/` in which you can place all your
    frontend files. In this directory, place a file `bower.json` with the following
    contents:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创建一个新的`public/`目录，您可以在其中放置所有前端文件。在该目录中，放置一个带有以下内容的`bower.json`文件：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After creating the `bower.json` file, you can install the declared dependencies
    (in this case, the **Twitter Bootstrap** framework) using the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`bower.json`文件后，您可以使用以下命令安装声明的依赖项（在本例中是**Twitter Bootstrap**框架）：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will download the Bootstrap framework and all its dependencies (actually,
    only the jQuery library) into the directory `bower_components/`, from which you
    will be able to include them in your HTML frontend files later.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载Bootstrap框架及其所有依赖项（实际上只有jQuery库）到`bower_components/`目录中，然后您将能够在稍后的HTML前端文件中包含它们。
- en: 'It''s also useful to have a web server up and running that can serve your HTML
    frontend files. This is especially important when your WebSocket application is
    restricted to a `localhost` origin, which will only allow requests from JavaScript
    served from the `localhost` domain (which does not include local files opened
    in a browser). One quick and easy way is to use the `nginx` Docker image. Be sure
    to run the following command from within your `public/` directory:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个有用的方法是运行一个能够提供HTML前端文件的Web服务器。当您的WebSocket应用程序受限于`localhost`来源时，这一点尤为重要，它将只允许来自`localhost`域的JavaScript的请求（这不包括在浏览器中打开的本地文件）。一个快速简单的方法是使用`nginx`
    Docker镜像。确保从`public/`目录中运行以下命令：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After that, you will be able to open `http://localhost` in your browser and
    view the static files from your `public/` directory. If you place an empty `index.html`
    in that directory, Nginx will use that page as an index page that will not need
    to be explicitly requested by its path (meaning that `http://localhost` will serve
    the contents of the file `index.html` to the user).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您将能够在浏览器中打开`http://localhost`并查看来自`public/`目录的静态文件。如果您在该目录中放置一个空的`index.html`，Nginx将使用该页面作为索引页面，无需显式请求其路径（这意味着`http://localhost`将向用户提供文件`index.html`的内容）。
- en: Building a simple chat application
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个简单的聊天应用程序
- en: 'You can now start implementing the actual chat application. As already shown
    in the previous examples, you need to implement `Ratchet\MessageComponentInterface`
    for this. Start by creating a `Packt\Chp6\Chat\ChatComponent` class and implementing
    all methods that are required by the interface:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以开始实现实际的聊天应用程序。如前面的示例所示，您需要为此实现`Ratchet\MessageComponentInterface`。首先创建一个`Packt\Chp6\Chat\ChatComponent`类，并实现接口所需的所有方法：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first thing that the chat application needs to do is to keep track of connected
    users. For this, you will need to maintain a collection of all open connections,
    add new connections when a new user connects, and remove them when a user disconnects.
    For this, initialize an instance of the `SplObjectStorage` class in the constructor:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天应用程序需要做的第一件事是跟踪连接的用户。为此，您需要维护所有打开连接的集合，在新用户连接时添加新连接，并在用户断开连接时将其移除。为此，在构造函数中初始化`SplObjectStorage`类的一个实例：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can then attach new connections to this storage in the `onOpen` event and
    remove them in the `onClose` event:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`onOpen`事件中将新连接附加到此存储中，并在`onClose`事件中将其移除：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Each connected user can now send messages to the server. For each received
    message, the component''s `onMessage` method will be called. To implement a real
    chat application, each received message needs to be relayed to the other users-conveniently,
    you already have a list of all connected users in your `$this->users` collection
    to whom you can then send the received message:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每个连接的用户都可以向服务器发送消息。对于每条接收到的消息，组件的`onMessage`方法将被调用。为了实现一个真正的聊天应用程序，每条接收到的消息都需要被传递给其他用户，方便的是，您已经有了一个包含所有连接用户的`$this->users`集合，可以向他们发送接收到的消息：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can then register your chat component at the Ratchet application in your
    `server.php` file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在您的`server.php`文件中注册您的聊天组件：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After restarting your application, test the chat functionality by opening two
    WebSocket connections with wscat in two separate terminals. Each message that
    you send in one connection should pop up in the other.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动应用程序后，通过在两个单独的终端中使用wscat打开两个WebSocket连接来测试聊天功能。您在一个连接中发送的每条消息都应该在另一个连接中弹出。
- en: '![Building a simple chat application](graphics/image_06_004.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![构建一个简单的聊天应用程序](graphics/image_06_004.jpg)'
- en: Testing the rudimentary chat application using two wscat connections
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个wscat连接测试简陋的聊天应用程序
- en: 'Now that you have an (admittedly, still rudimentary) chat server running, we
    can start building the HTML frontend for the chat application. For the beginning,
    a static HTML file will be completely sufficient for this. Begin by creating an
    empty `index.html` file in your `public/` directory:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有一个（诚然，仍然很简陋的）聊天服务器在运行，我们可以开始为聊天应用程序构建HTML前端。首先，一个静态的HTML文件对此来说完全足够了。首先在`public/`目录中创建一个空的`index.html`文件：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this file, we are already including the frontend libraries that we'll use
    for this example; the Bootstrap framework (with one JavaScript and one CSS file)
    and the jQuery library (with one other JavaScript file).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们已经包含了我们将在本例中使用的前端库；Bootstrap框架（一个JavaScript和一个CSS文件）和jQuery库（另一个JavaScript文件）。
- en: 'As you will be writing a fair amount of JavaScript for this application, it
    is also useful to add another instance of a `js/app.js` file in which you can
    place your own JavaScript code to the `<head>` section of the HTML page:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将为这个应用程序编写大量的JavaScript代码，因此在HTML页面的`<head>`部分中添加另一个`js/app.js`文件实例也是很有用的：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can then continue by building a minimalist chat window in the `<body>`
    section of your `index.html` file. All you need to get started is an input field
    for writing messages, a button for sending them, and an area for displaying other
    user''s messages:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在`index.html`文件的`<body>`部分构建一个极简的聊天窗口。你只需要一个用于编写消息的输入字段，一个用于发送消息的按钮，以及一个用于显示其他用户消息的区域：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The HTML file contains an input field (`id="message"`) in which a user can
    enter new chat messages, a button (`id="submit"`) to submit the message, and a
    (currently still empty) section (`id="messages"`) in which the messages received
    from other users can be displayed. The following screenshot shows how this page
    will be displayed in the browser:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: HTML文件中包含一个输入字段（`id="message"`），用户可以在其中输入新的聊天消息，一个按钮（`id="submit"`）用于提交消息，以及一个（目前还是空的）部分（`id="messages"`），用于显示从其他用户接收到的消息。以下截图显示了这个页面在浏览器中的显示方式：
- en: '![Building a simple chat application](graphics/image_06_005.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![构建一个简单的聊天应用](graphics/image_06_005.jpg)'
- en: Of course, all of this will not be any good without the appropriate JavaScript
    to actually make the chat work. In JavaScript, you can open a WebSocket connection
    by using the `WebSocket` class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些都不会有任何作用，如果没有适当的JavaScript来实际使聊天工作。在JavaScript中，你可以使用`WebSocket`类打开一个WebSocket连接。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**On browser support** WebSockets are supported in all modern browsers and
    have been for quite some time. You may run into issues where you need to support
    older Internet Explorer versions (9 and below), which do not support WebSockets.
    In this case, you can use the `web-socket-js` library, which internally uses a
    fallback using Flash, which is also well supported by Ratchet.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于浏览器支持** WebSockets在所有现代浏览器中都得到支持，而且已经有一段时间了。你可能会遇到需要支持较旧的Internet Explorer版本（9及以下）的问题，这些版本不支持WebSockets。在这种情况下，你可以使用`web-socket-js`库，它在内部使用Flash作为回退，而Ratchet也很好地支持Flash。'
- en: 'In this example, we will be placing all our JavaScript code in the file `js/app.js`
    in the `public/` directory. You can open a new WebSocket connection by instantiating
    the `WebSocket` class with the WebSocket server''s URL as the first parameter:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将把所有的JavaScript代码放在`public/`目录下的`js/app.js`文件中。你可以通过用WebSocket服务器的URL作为第一个参数来实例化`WebSocket`类来打开一个新的WebSocket连接：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Just like the server-side component, the client-side WebSocket offers several
    events that you can listen on. Conveniently, these events are named similarly
    to the methods used by Ratchet, `onopen`, `onclose`, and `onmessage`, all of which
    you can (and should) implement in your own code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 就像服务器端组件一样，客户端WebSocket也提供了几个你可以监听的事件。方便的是，这些事件的名称与Ratchet使用的方法类似，`onopen`，`onclose`和`onmessage`，你都可以（也应该）在自己的代码中实现：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Receiving messages
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接收消息
- en: Each client connection will have a corresponding `ConnectionInterface` instance
    in the Ratchet server application. When you call a connection's `send()` method
    on the server, this will trigger the `onmessage` event on the client side.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每个客户端连接在Ratchet服务器应用程序中都会有一个对应的`ConnectionInterface`实例。当你在服务器上调用连接的`send()`方法时，这将触发客户端的`onmessage`事件。
- en: 'Each time a new message is received; this message should be displayed in the
    chat window. For this, you can implement a new JavaScript method `appendMessage`
    that will display a new message in the previously created message container:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每次收到新消息时，这条消息应该显示在聊天窗口中。为此，你可以实现一个新的JavaScript方法`appendMessage`，它将在之前创建的消息容器中显示新消息：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, we are using a simple jQuery construct to create a new HTML
    element and populate it with the current date and time and the actual message
    text received. Be aware that a single message currently only consists of the raw
    message text and does not yet contain any kind of meta data, such as an author
    or other information. We'll get to that later.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个简单的jQuery构造来创建一个新的HTML元素，并用当前的日期和时间以及实际接收到的消息文本填充它。请注意，单个消息目前只包含原始消息文本，还不包含任何形式的元数据，比如作者或其他信息。我们稍后会解决这个问题。
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: While creating HTML elements with jQuery is sufficient in this case, you might
    want to consider using a dedicated templating engine such as **Mustache** or **Handlebars**
    in a real-world scenario. Since this is not a JavaScript book, we will be sticking
    to the basics here.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用jQuery创建HTML元素已经足够了，但在实际情况下，你可能会考虑使用专门的模板引擎，比如**Mustache**或**Handlebars**。由于这不是一本JavaScript书，我们将在这里坚持基础知识。
- en: 'You can then call the `appendMessage` method when a message is received:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当收到消息时，你可以调用`appendMessage`方法：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The event's data property contains the entire received message as a string and
    you can use it as you see fit. Currently, our chat application is only equipped
    to handle plain text chat messages; whenever you need to transport more or structured
    data, using JSON encoding is probably a good option.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的数据属性包含整个接收到的消息作为一个字符串，你可以根据需要使用它。目前，我们的聊天应用程序只能处理纯文本聊天消息；每当你需要传输更多或结构化的数据时，使用JSON编码可能是一个不错的选择。
- en: Sending messages
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送消息
- en: 'To send messages, you can (unsurprisingly) use the connection''s `send()` method.
    Since you already have the respective user input fields in your HTML file, all
    it needs now to get the first version of our chat working is a little more jQuery:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送消息，你可以（不出所料地）使用连接的`send()`方法。由于你已经在HTML文件中有了相应的用户输入字段，现在只需要更多的jQuery就可以让我们的聊天的第一个版本运行起来：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As soon as the HTML page is loaded completely, we begin listening on the submit
    button's `click` event. When the button is clicked, the message from the input
    field is sent to the server using the connection's `send()` method. Each time
    a message is sent, Ratchet will call the `onMessage` event in the server-side
    component, allowing the server to react to that message and to dispatch it to
    other connected users.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦HTML页面完全加载，我们就开始监听提交按钮的`click`事件。当按钮被点击时，输入字段中的消息将使用连接的`send()`方法发送到服务器。每次发送消息时，Ratchet都会调用服务器端组件的`onMessage`事件，允许服务器对该消息做出反应并将其分发给其他连接的用户。
- en: Usually, a user will want to see messages that they sent themselves in the chat
    window, too. That is why we are calling the `appendMessage` that was implemented
    previously, which will insert the sent message into the message container, just
    as if it was received from a remote user.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，用户希望在聊天窗口中看到他们自己发送的消息。这就是为什么我们调用之前实现的`appendMessage`，它将把发送的消息插入到消息容器中，就好像它是从远程用户接收的一样。
- en: Testing the application
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试应用程序
- en: When both containers (web server and WebSocket application) are running, you
    can now test the first version of your chat by opening the URL `http://localhost`
    in your browser (better yet, open the page twice in two different windows so that
    you can actually use the application to chat with yourself).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个容器（Web服务器和WebSocket应用程序）都在运行时，您现在可以通过在浏览器中打开URL `http://localhost` 来测试您的聊天的第一个版本（最好是在两个不同的窗口中打开页面，这样您实际上可以使用应用程序与自己聊天）。
- en: 'The following screenshot shows an example of the result that you should get
    when testing the application:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了测试应用程序时应该获得的结果示例：
- en: '![Testing the application](graphics/image_06_006.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![测试应用程序](graphics/image_06_006.jpg)'
- en: Testing the first version of the chat application with two browser windows
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个浏览器窗口测试聊天应用程序的第一个版本
- en: Keeping the connection from timing out
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止连接超时
- en: When you keep the test site open for more than a few minutes, you might notice
    that eventually the WebSocket connection will be closed. This is because most
    browsers will close a WebSocket connection when no messages were sent or received
    in a certain time frame (usually five minutes). As you are working with long-running
    connections, you will also need to consider connectivity issues-what if one of
    your users uses a mobile connection and temporarily disconnects while using your
    application?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将测试站点保持打开超过几分钟时，您可能会注意到最终WebSocket连接将被关闭。这是因为大多数浏览器在一定时间内没有发送或接收消息时（通常为五分钟）会关闭WebSocket连接。由于您正在处理长时间运行的连接，您还需要考虑连接问题-如果您的用户之一使用移动连接并在使用您的应用程序时暂时断开连接会怎么样？
- en: 'The easiest way to mitigate this is to implement a simple re-connect mechanism-whenever
    the connection is closed, wait a few seconds and then try again. For this, you
    can start a timeout in the `onclose` event in which you open a new connection:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的缓解方法是实现一个简单的重新连接机制-每当连接关闭时，等待几秒然后再次尝试。为此，您可以在`onclose`事件中启动一个超时，在其中打开一个新连接：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This way, each time the connection is closed (due to a timeout, network connectivity
    problems, or any other reason); the application will try to re-establish the connection
    after a grace time of five seconds.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每当连接关闭时（由于超时、网络连接问题或任何其他原因）；应用程序将在五秒的宽限时间后尝试重新建立连接。
- en: 'If you want to proactively prevent disconnects, you can also periodically send
    messages through the connection in order to keep the connection alive. This can
    be done by registering an interval function that periodically (in intervals smaller
    than the timeout) sends messages to the server:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望主动防止断开连接，您还可以定期通过连接发送消息以保持连接活动。这可以通过注册一个间隔函数来完成，该函数定期（在超时时间内的间隔内）向服务器发送消息：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'There are a few caveats to consider here: first of all, you should only start
    sending keep-alive messages after the connection was actually established (that
    is why we are registering the interval in the `onopen` event), and you should
    also stop sending keep-alives when the connection was closed (which can still
    happen, for example, when the network is not available), which is why the interval
    needs to be cleared in the `onclose` event.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要考虑的注意事项：首先，您应该在连接实际建立之后才开始发送保持活动的消息（这就是为什么我们在`onopen`事件中注册间隔），并且当连接关闭时也应该停止发送保持活动的消息（例如，当网络不可用时仍然可能发生），这就是为什么间隔需要在`onclose`事件中清除。
- en: 'Furthermore, you probably do not want keep-alive messages to be broadcast to
    the other connected clients; this means that these messages also need a special
    handling in the server-side component:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可能不希望保持活动的消息广播到其他连接的客户端；这意味着这些消息在服务器端组件中也需要特殊处理：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Deployment options
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署选项
- en: As you have already noticed, Ratchet applications are not deployed like your
    typical PHP application, but in fact run their own HTTP server that can directly
    answer HTTP requests. Also, most applications will not *only* serve WebSocket
    connections, but also need to process regular HTTP requests, too.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经注意到的，Ratchet应用程序不像您典型的PHP应用程序那样部署，而是实际上运行自己的HTTP服务器，可以直接响应HTTP请求。此外，大多数应用程序不仅仅会提供WebSocket连接，还需要处理常规的HTTP请求。
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This section is meant to give you an overview on how to deploy a Ratchet application
    in a production environment. For the remaining sections of this chapter, we will
    continue using the Docker-based development setup (without load balancing and
    fancy process managers) for the sake of simplicity.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本节旨在为您概述如何在生产环境中部署Ratchet应用程序。在本章的其余部分，为了简单起见，我们将继续使用基于Docker的开发设置（不使用负载平衡和花哨的进程管理器）。
- en: 'This will open an entire set of new problems to solve. One of them is scalability:
    by default, PHP runs single-threaded, so even when using the asynchronous event
    loop offered by `libev`, your application will never scale beyond a single CPU.
    While you could consider using the `pthreads` extension to enable threading in
    PHP (and to enter a whole new world of pain), it is usually easier to simply start
    the Ratchet application multiple times, have it listen on different ports, and
    use a load-balancer such as Nginx to distribute HTTP requests and WebSocket connections
    among them.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带来一整套新问题需要解决。其中之一是可伸缩性：默认情况下，PHP是单线程运行的，因此即使使用`libev`提供的异步事件循环，您的应用程序也永远无法扩展到多个CPU。虽然您可以考虑使用`pthreads`扩展在PHP中启用线程（并进入一个全新的痛苦世界），但通常更容易的方法是简单地多次启动Ratchet应用程序，让它们侦听不同的端口，并使用Nginx等负载均衡器将HTTP请求和WebSocket连接分发给它们。
- en: For processing regular (non-WebSocket) HTTP requests, you can still use a regular
    PHP process manager such as PHP-FPM or Apache's PHP module. You can then configure
    Nginx to dispatch those regular requests to FPM and all WebSocket requests to
    one of your running Ratchet applications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理常规（非WebSocket）HTTP请求，您仍然可以使用常规的PHP进程管理器，如PHP-FPM或Apache的PHP模块。然后，您可以配置Nginx将这些常规请求分派给FPM，将所有WebSocket请求分派给您运行的Ratchet应用程序之一。
- en: '![Deployment options](graphics/B05285_06_07.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![部署选项](graphics/B05285_06_07.jpg)'
- en: Deploying and load-balancing Ratchet applications using an Nginx load balancer
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Nginx负载均衡器部署和负载平衡Ratchet应用程序
- en: 'To achieve this, you first need to make the port that your application listens
    on so that it can be configured separately for each running process. As the application
    is started through the command line, the easiest way to make the port configurable
    per-process is a command-line parameter. You can use the `getopt` function to
    easily parse command-line parameters. While you''re at it, you can also make the
    listen address configurable. Insert the following code into your `server.php`
    file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，您首先需要使应用程序侦听的端口可以为每个运行的进程单独配置。由于应用程序是通过命令行启动的，使端口可配置的最简单方法是使用命令行参数。您可以使用`getopt`函数轻松解析命令行参数。在此过程中，您还可以使侦听地址可配置。将以下代码插入到您的`server.php`文件中：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, you need to make sure your server actually automatically starts a sufficient
    number of processes. In a Linux environment, the **Supervisor** tool is usually
    a good choice for this. On Ubuntu or Debian Linux systems, you can install it
    from the system''s package repositories using the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要确保您的服务器实际上自动启动了足够数量的进程。在Linux环境中，**Supervisor**工具通常是一个不错的选择。在Ubuntu或Debian
    Linux系统上，您可以使用以下命令从系统的软件包存储库安装它：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can then place a configuration file in `/etc/supervisor/conf.d/` with the
    following contents:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`/etc/supervisor/conf.d/`中放置一个配置文件，内容如下：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This will configure Supervisor to start four instances of the chat application
    on system boot. They will listen at the ports `8000` to `8003` and will automatically
    be restarted by Supervisor when they unexpectedly terminate-remember: a PHP fatal
    error may be relatively harmless in a FPM-managed environment, but in a standalone
    PHP process, a single fatal error will bring down your entire application for
    all users until someone restarts the process. For this reason, it''s good to have
    a service like Supervisor that automatically restarts crashed processes.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这将配置Supervisor在系统启动时启动四个聊天应用程序的实例。它们将侦听端口`8000`到`8003`，并在它们意外终止时由Supervisor自动重新启动-请记住：在FPM管理的环境中，PHP致命错误可能相对无害，但在独立的PHP进程中，一个致命错误将使您的整个应用程序对所有用户不可用，直到有人重新启动该进程。因此，最好有一个像Supervisor这样的服务，可以自动重新启动崩溃的进程。
- en: 'Next, install an Nginx web server to serve as a load balancer for the four
    running chat applications. On Ubuntu or Debian, install Nginx as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装一个Nginx web服务器，用作四个运行的聊天应用程序的负载均衡器。在Ubuntu或Debian上，安装Nginx如下：
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After having installed Nginx, place a configuration file `chat.conf` in the
    directory `/etc/nginx/sites-enabled/` with the following contents:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Nginx后，在目录`/etc/nginx/sites-enabled/`中放置一个名为`chat.conf`的配置文件，内容如下：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This configuration will configure all four application processes as *upstream*
    servers for the Nginx load balancer. All HTTP requests starting with the `/chat/`
    path will be forwarded to one of the Ratchet applications running on the server.
    The `proxy_http_version` and `proxy_set_header` directives are necessary to allow
    Nginx to correctly forward the WebSocket handshake between server and client.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置将配置所有四个应用程序进程作为Nginx负载均衡器的*上游*服务器。所有以`/chat/`路径开头的HTTP请求将被转发到服务器上运行的Ratchet应用程序之一。`proxy_http_version`和`proxy_set_header`指令是必要的，以便Nginx能够正确地在服务器和客户端之间转发WebSocket握手。
- en: Bridging Ratchet and PSR-7 applications
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接Ratchet和PSR-7应用程序
- en: Sooner or later, your chat application will also need to respond to regular
    HTTP requests (for example, this will become necessary as soon as you want to
    add an authentication layer with a login form and authentication processing).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 迟早，您的聊天应用程序还需要响应常规的HTTP请求（例如，一旦您想要添加具有登录表单和身份验证处理的身份验证层，这将变得必要）。
- en: As explained in the previous section, a common setup for WebSocket applications
    in PHP is to have a Ratchet application handle all WebSocket connections, and
    to direct all regular HTTP requests to a regular PHP-FPM setup. However, as a
    Ratchet application in fact also ships its own HTTP server, you can also respond
    to regular HTTP requests directly from your Ratchet application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，PHP中WebSocket应用程序的常见设置是让Ratchet应用程序处理所有WebSocket连接，并将所有常规HTTP请求定向到常规的PHP-FPM设置。但是，由于Ratchet应用程序实际上也包含自己的HTTP服务器，因此您也可以直接从Ratchet应用程序响应常规HTTP请求。
- en: 'Just as you have used the `Ratchet\MessageComponentInterface` to implement
    WebSocket applications, you can use the `Ratchet\HttpServerInterface` to implement
    a regular HTTP server. As an example, consider the following class:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您使用`Ratchet\MessageComponentInterface`来实现WebSocket应用程序一样，您可以使用`Ratchet\HttpServerInterface`来实现常规HTTP服务器。例如，考虑以下类：
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see, the methods defined by the `HttpServerInterface` are similar
    to the `MessageCompomentInterface`. The only difference is the `$request` parameter
    that is now additionally passed into the `onOpen` method. This class is an instance
    of the `Guzzle\Http\Message\RequestInterface` (which, unfortunately, does not
    implement the PSR-7 `RequestInterface`) from which you can get the basic HTTP
    request properties.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`HttpServerInterface`定义的方法与`MessageCompomentInterface`类似。唯一的区别是现在还将`$request`参数传递到`onOpen`方法中。这个类是`Guzzle\Http\Message\RequestInterface`的一个实例（不幸的是，它不实现PSR-7
    `RequestInterface`），您可以从中获取基本的HTTP请求属性。
- en: 'You can now use the `onOpen` method to send a regular HTTP in response to a
    received HTTP request:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`onOpen`方法来对收到的HTTP请求发送常规HTTP响应：
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see, you'll have to send the entire HTTP response (including response
    headers!) in the `onOpen` method. This is a bit tedious, and we'll find a better
    way for that later, but it will suffice for the moment.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您需要在`onOpen`方法中发送整个HTTP响应（包括响应标头！）。这有点繁琐，但稍后我们会找到更好的方法，但目前这样就足够了。
- en: 'Next, register your HTTP server in your `server.php` the same way that you
    would register a new WebSocket server:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`server.php`中注册您的HTTP服务器，方式与注册新的WebSocket服务器相同：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Especially note the third parameter `[''*'']` here: this parameter will allow
    any request origin (not just `localhost`) for this route, as most browsers and
    command-line clients will not even send an origin header for regular HTTP requests.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意这里的第三个参数`['*']`：此参数将允许此路由的任何请求来源（不仅仅是`localhost`），因为大多数浏览器和命令行客户端甚至不会为常规HTTP请求发送来源标头。
- en: 'After restarting your application, you can test the new HTTP route using any
    regular HTTP client, either on the command line or using your browser. As shown
    in the following screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动应用程序后，您可以使用任何常规HTTP客户端（无论是命令行还是浏览器）测试新的HTTP路由。如下面的截图所示：
- en: '![Bridging Ratchet and PSR-7 applications](graphics/image_06_008.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![桥接Ratchet和PSR-7应用程序](graphics/image_06_008.jpg)'
- en: Testing a Ratchet HTTP server using cURL
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用cURL测试Ratchet HTTP服务器
- en: Building an HTTP response including headers by hand is a very tedious task-especially
    if at some point, your application contains multiple HTTP endpoints. For this
    reason, it would be nice to have a framework that handles all this stuff for you.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 手动构建包括标头的HTTP响应是一项非常繁琐的任务-特别是如果在某个时刻，您的应用程序包含多个HTTP端点。因此，最好有一个框架来为您处理所有这些事情。
- en: In the previous chapter, you've already worked with the  **Slim** framework,
    which you can also integrate quite nicely with Ratchet. Unfortunately, Ratchet
    is not (yet) PSR-7 compliant, so you'll have to do some legwork to convert Ratchet's
    request interfaces to PSR-7 instances and pipe PSR-7 responses back into the `ConnectionInterface`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您已经使用了**Slim**框架，您也可以将其与Ratchet很好地集成。不幸的是，Ratchet目前还不符合PSR-7，因此您需要做一些工作来将Ratchet的请求接口转换为PSR-7实例，并将PSR-7响应返回到`ConnectionInterface`。
- en: 'Start by installing the Slim framework into your application using Composer:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先使用Composer将Slim框架安装到您的应用程序中：
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The goal of the remainder of this section will be to build a new implementation
    of the `HttpServerInterface` that takes a Slim application as a dependency and
    forwards all incoming requests to the Slim application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分的目标是构建`HttpServerInterface`的新实现，该实现将Slim应用程序作为依赖项，并将所有传入的请求转发到Slim应用程序。
- en: 'Start by defining the class `Packt\Chp6\Http\SlimAdapterServer` that implements
    the `HttpServerInterface` and accepts a `Slim\App` as a dependency:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义实现`HttpServerInterface`并接受`Slim\App`作为依赖项的`Packt\Chp6\Http\SlimAdapterServer`类：
- en: '[PRE54]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The first thing that you''ll need to do is to map the `$request` parameter
    that Ratchet passes into the `onOpen` event to a PSR-7 request object (which you
    can then pass into the Slim application for processing). The Slim framework ships
    its own implementation of this interface: the class `Slim\Http\Request`. Start
    by adding the following code to your `onOpen` method, which maps the request URI
    to an instance of the `Slim\Http\Uri` class:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是将Ratchet传递到`onOpen`事件的`$request`参数映射到PSR-7请求对象（然后将其传递到Slim应用程序进行处理）。Slim框架提供了其自己的实现：`Slim\Http\Request`类。首先将以下代码添加到您的`onOpen`方法中，将请求URI映射到`Slim\Http\Uri`类的实例：
- en: '[PRE55]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This will map the Guzzle request's URI object in a Slim URI object. These are
    largely compatible, allowing you to simply copy most of the properties into the
    `Slim\Http\Uri` class' constructor. Only the `$guzzleUri->getQuery()` return value
    needs to be forced into a string by concatenating it with an empty string.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Slim URI对象中映射Guzzle请求的URI对象。它们在很大程度上是兼容的，允许您将大多数属性简单地复制到`Slim\Http\Uri`类的构造函数中。只有`$guzzleUri->getQuery()`返回值需要通过与空字符串连接来强制转换为字符串。
- en: 'Continue by building the HTTP request header object:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 继续构建HTTP请求标头对象：
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After having built both the request URI and headers, you can create an instance
    of the `SlimRequest` class:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 构建请求URI和标头后，您可以创建`SlimRequest`类的实例：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can then use this request object to invoke the Slim application that you''ve
    passed as a dependency into the `SlimAdapterServer` class:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用此请求对象来调用作为依赖项传递给`SlimAdapterServer`类的Slim应用程序：
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `$this->app->process()` function will actually execute the Slim application.
    It works similar to the `$app->run()` method that you've worked with in the previous
    chapter, but directly accepts a PSR-7 request object and returns a PSR-7 response
    object for further processing.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`$this->app->process()`函数实际上会执行Slim应用程序。它类似于您在上一章中使用的`$app->run()`方法，但直接接受PSR-7请求对象，并返回一个用于进一步处理的PSR-7响应对象。'
- en: 'The final challenge is now to use the `$slimResponse` object and return all
    data contained in it back to the client. Let''s start by sending the HTTP headers:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的挑战是现在使用`$slimResponse`对象，并将其中包含的所有数据返回给客户端。让我们从发送HTTP头部开始：
- en: '[PRE59]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `$statusLine` contains the first line of the HTTP response (usually, something
    like `HTTP/1.1 200 OK` or `HTTP/1.1 404 Not Found`). The nested `foreach` loops
    are used to collect all response headers from the PSR-7 response object and concatenate
    them into a string that can be used in an HTTP response (each header gets its
    own line, separated by both a **Carriage Return** (**CR**) and **Line Feed** (**LF**)
    newline). The double `\r\n` finally terminates the header and marks the beginning
    of the response body, which you''ll output next:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`$statusLine`包含HTTP响应的第一行（通常是`HTTP/1.1 200 OK`或`HTTP/1.1 404 Not Found`之类的内容）。嵌套的`foreach`循环用于从PSR-7响应对象中收集所有响应头，并将它们连接成一个字符串，该字符串可以用于HTTP响应（每个头部都有自己的一行，由**回车**（**CR**）和**换行**（**LF**）分隔）。双`\r\n`最终终止头部，并标记响应主体的开始，接下来您将输出它：'
- en: '[PRE60]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In your `server.php` file, you can now instantiate a new Slim application,
    pass it into a new `SlimAdapterServer` class, and register this server at the
    Ratchet application:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`server.php`文件中，您现在可以实例化一个新的Slim应用程序，将其传递给一个新的`SlimAdapterServer`类，并在Ratchet应用程序中注册此服务器：
- en: '[PRE61]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Integrating the Slim framework into your Ratchet application allows you to serve
    both WebSocket requests and regular HTTP requests with the same application. Serving
    HTTP requests from one continuously running PHP process presents interesting new
    opportunities, although you'll have to use these with care. You will need to worry
    about things like memory consumption (PHP does have a **Garbage Collector**, but
    if you do not pay attention, you may still create a memory leak that will cause
    your PHP process to run into the memory limit and crash and burn), but building
    applications like these may be an interesting alternative when you have high-performance
    requirements.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将Slim框架集成到Ratchet应用程序中，可以让您使用同一个应用程序为WebSocket请求和常规HTTP请求提供服务。从一个持续运行的PHP进程中提供HTTP请求会带来一些有趣的新机会，尽管您必须谨慎使用。您需要担心诸如内存消耗（PHP确实有**垃圾回收器**，但如果不注意，仍可能造成内存泄漏，导致PHP进程超出内存限制而崩溃），但在有高性能要求时，构建这样的应用可能是一个有趣的选择。
- en: Accessing your application via the web server
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Web服务器访问您的应用程序
- en: In our development setup, we're currently running two containers, the application
    container itself, listening on port `8080` and an Nginx server listening on port
    `80` that serves static files such as the `index.html` and various CSS and JavaScript
    files. Exposing two different ports for static files and the application itself
    is often not recommendable in a production setup.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的开发设置中，我们当前运行两个容器，应用程序容器本身监听端口`8080`，而Nginx服务器监听端口`80`，提供静态文件，如`index.html`和各种CSS和JavaScript文件。在生产设置中，通常不建议为静态文件和应用程序本身公开两个不同的端口。
- en: 'Because of this, we will now configure our web server container to serve a
    static file, when it''s present (such as the `index.html` or CSS and JavaScript
    files), and to delegate the HTTP request to the application container when no
    actual file with the given name exists. For this, start by creating an Nginx configuration
    file that you can place anywhere in your project directory-for example, `etc/nginx.conf`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在将配置我们的Web服务器容器，以便在存在静态文件时提供静态文件（例如`index.html`或CSS和JavaScript文件），并在没有实际文件存在的情况下将HTTP请求委托给应用程序容器。为此，首先创建一个Nginx配置文件，您可以将其放在项目目录的任何位置，例如`etc/nginx.conf`：
- en: '[PRE62]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This configuration will cause Nginx to look for files in the `/var/www` directory
    (when using Docker to start the Nginx web server, you can simply mount your local
    directory into the container's `/var/www` directory). There, it will first look
    for a direct filename match, then for an `index.html` inside a directory, and
    as a last option, pass the request to an upstream HTTP server.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这种配置将导致Nginx在`/var/www`目录中查找文件（当使用Docker启动Nginx Web服务器时，您可以将本地目录简单地挂载到容器的`/var/www`目录中）。在那里，它将首先查找直接的文件名匹配，然后查找目录中的`index.html`，最后将请求传递给上游HTTP服务器。
- en: Tip
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This configuration is also suitable for a production setup as described in the
    *Deployment options *section. When you have multiple instances of your application
    running, you will need to reference a dedicated upstream configuration with multiple
    upstream applications in your `proxy_pass` statement.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这种配置也适用于*部署选项*部分中描述的生产设置。当您运行多个应用程序实例时，您将需要在`proxy_pass`语句中引用一个专用的上游配置，其中包含多个上游应用程序。
- en: 'After creating the configuration file, you can re-create your Nginx container
    as follows (pay special attention to the `--link` flag of the `docker run` command):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 创建配置文件后，您可以按以下方式重新创建Nginx容器（特别注意`docker run`命令的`--link`标志）：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Adding authentication
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加身份验证
- en: 'Currently, our application is missing one crucial feature: anyone can post
    messages in the chat, and there is also no way to determine which user sent which
    message. Because of this, in the next step, we will add an authentication layer
    to our chat application. For this, we''ll need a login form and some kind of authentication
    handler.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序缺少一个至关重要的功能：任何人都可以在聊天中发布消息，也没有办法确定哪个用户发送了哪条消息。因此，在下一步中，我们将为我们的聊天应用程序添加一个身份验证层。为此，我们将需要一个登录表单和某种身份验证处理程序。
- en: In this example, we will use a typical session-based authentication. After successfully
    authenticating the username and password, the system will create a new session
    for the user and store the (random and non-guessable) session ID in a cookie on
    the user's browser. On subsequent requests, the authentication layer can use the
    session ID from the cookie to look up the currently authenticated user.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用典型的基于会话的身份验证。成功验证用户名和密码后，系统将为用户创建一个新的会话，并将（随机且不可猜测的）会话ID存储在用户浏览器的cookie中。在后续请求中，身份验证层可以使用来自cookie的会话ID来查找当前经过身份验证的用户。
- en: Creating the login form
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建登录表单
- en: 'Let''s start by implementing a simple class for managing sessions. This class
    will be named `Packt\Chp6\Authentication\SessionProvider`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现一个简单的用于管理会话的类。这个类将被命名为`Packt\Chp6\Authentication\SessionProvider`：
- en: '[PRE64]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This session handler is built extremely simple: it simply stores which user
    (by name) is using which session ID; new sessions can be registered using the
    `registerSession` method. As all HTTP requests will be served by the same PHP
    process, you do not even need to persist these sessions in a database, but can
    simply keep them in-memory (however, you will need database-backed session storage
    as soon as you have multiple processes running in a load-balanced environment,
    as you cannot simply share memory between different PHP processes).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个会话处理程序非常简单：它只是简单地存储哪个用户（按名称）正在使用哪个会话ID；可以使用`registerSession`方法注册新会话。由于所有HTTP请求将由同一个PHP进程提供，因此您甚至不需要将这些会话持久化到数据库中，而是可以简单地将它们保存在内存中（但是，一旦在负载平衡环境中运行多个进程，您将需要基于数据库的会话存储，因为您不能简单地在不同的PHP进程之间共享内存）。
- en: Tip
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**On really random random numbers**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于真正随机的随机数**'
- en: In order to generate a cryptographically secure session ID, we're using the
    `random_bytes` function which was added in PHP 7 and is now the suggested way
    to obtain cryptographically secure random data (do not use functions such as `rand`
    or `mt_rand` for this, ever).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '为了生成一个密码安全的会话ID，我们使用了在PHP 7中添加的`random_bytes`函数，现在建议使用这种方式来获取密码安全的随机数据（永远不要使用`rand`或`mt_rand`等函数）。 '
- en: 'In the following steps, we''ll implement a few additional routes into our newly
    integrated Slim application:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将在新集成的Slim应用程序中实现一些额外的路由：
- en: The `GET /` route will serve the actual chat HTML site. Up until now, this was
    a static HTML page that was served directly by the web server. Using authentication,
    we will be needing a bit more login on this site (for example, redirecting a user
    to the login page when they are not logged in), which is why we're moving the
    index page into the application.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET /`路由将提供实际的聊天HTML网站。直到现在，这是一个静态的HTML页面，直接由Web服务器提供。使用身份验证，我们将需要在这个网站上进行更多的登录（例如，当用户未登录时将其重定向到登录页面），这就是为什么我们将首页页面移到应用程序中。'
- en: The `GET /login` route will serve a login form in which users can authenticate
    with a username and password. Provided credentials will be submitted to the...
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET /login`路由将提供一个登录表单，用户可以通过用户名和密码进行身份验证。提供的凭据将提交给...'
- en: '`POST /authenticate` route. This route will verify credentials provided by
    a user and start a new session (using the previously-built `SessionProvider` class)
    when a user was successfully authenticated. After a successful authentication,
    the `/authenticate` route will redirect the user back to the `/` route.'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST /authenticate`路由。这个路由将验证用户提供的凭据，并在用户成功验证后启动一个新的会话（使用之前构建的`SessionProvider`类）。验证成功后，`/authenticate`路由将重定向用户回到`/`路由。'
- en: 'Let''s start by registering these three routes in the Ratchet application and
    connecting them to the previously created Slim adapter in the `server.php` file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始在Ratchet应用程序中注册这三个路由，并将它们连接到之前创建的Slim适配器中的`server.php`文件中：
- en: '[PRE65]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Continue by implementing the `/` route. Remember, this route is supposed to
    simply serve the `index.html` file that you have already created previously, but
    only if a valid user session exists. For this, you will have to check if there
    is an HTTP cookie with a session ID provided within the HTTP request and then
    verify that there is a valid user session with this ID. For this, add the following
    code to your `server.php` (also, remove the previously created `GET /hello` route,
    if still present). As shown in the following code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 继续实现`/`路由。请记住，这个路由只是简单地提供您之前创建的`index.html`文件，但前提是存在有效的用户会话。为此，您需要检查HTTP请求中是否提供了带有会话ID的HTTP
    cookie，然后验证是否存在具有此ID的有效用户会话。为此，请将以下代码添加到您的`server.php`中（如果仍然存在，请删除之前创建的`GET /hello`路由）。如下面的代码所示：
- en: '[PRE66]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This route serves the file `templates/index.html` to your users. Currently,
    this file should be located in the `public/` directory in your setup. Create the
    `templates/` directory in your project folder and move the `index.html` there
    from the `public/` directory. This way, the file will not be served by the Nginx
    web server anymore, and all requests to `/` will be directly forwarded to the
    Ratchet application (which will then either deliver the index view or redirect
    the user to the login page).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个路由为您的用户提供`templates/index.html`文件。目前，这个文件应该位于您的设置中的`public/`目录中。在项目文件夹中创建`templates/`目录，并将`index.html`从`public/`目录移动到那里。这样，文件将不再由Nginx
    Web服务器提供，所有对`/`的请求将直接转发到Ratchet应用程序（然后要么提供索引视图，要么将用户重定向到登录页面）。
- en: 'In the next step, you can implement the `/login` route. No special logic is
    required for this route:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，您可以实现`/login`路由。这个路由不需要特殊的逻辑：
- en: '[PRE67]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Of course, for this route to actually work, you will need to create the `templates/login.html`
    file. Start by creating a simple HTML document for this new template:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要使这个路由实际工作，您需要创建`templates/login.html`文件。首先创建一个简单的HTML文档作为新模板：
- en: '[PRE68]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This loads all required JavaScript libraries and CSS files required for the
    login form to work. In the `<body>` section, you can then add the actual login
    form:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载所有必需的JavaScript库和CSS文件，以便登录表单正常工作。在`<body>`部分，您可以添加实际的登录表单：
- en: '[PRE69]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Pay special attention to the `<form>` tag: the form''s action parameter is
    the `/authenticate` route; this means that all values that are entered into the
    form will be passed into the (still to-be-written) `/authenticate` route handler
    where you will be able to verify the entered credentials and create a new user
    session.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意`<form>`标签：表单的action参数是`/authenticate`路由；这意味着所有输入到表单中的值将被传递到（尚未编写的）`/authenticate`路由处理程序中，您将能够验证输入的凭据并创建一个新的用户会话。
- en: 'After saving this template file and restarting the application, you can test
    the new login form by simply requesting the `/` URL, either in your browser or
    using a command-line tool such as **HTTPie** or **curl**. As you do not have a
    login session yet, you should be redirected to the login form at once. As shown
    in the following screenshot:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此模板文件并重新启动应用程序后，您可以通过简单地请求`/` URL（无论是在浏览器中还是使用诸如**HTTPie**或**curl**之类的命令行工具）来测试新的登录表单。由于您尚未拥有登录会话，因此应立即被重定向到登录表单。如下截图所示：
- en: '![Creating the login form](graphics/image_06_009.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![创建登录表单](graphics/image_06_009.jpg)'
- en: Unauthenticated users are now redirected to the login form
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 未经身份验证的用户现在将被重定向到登录表单
- en: 'The one thing that''s missing now is the actual `/authenticate` route. For
    this, add the following code in your `server.php` file:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一缺少的是实际的`/authenticate`路由。为此，请在您的`server.php`文件中添加以下代码：
- en: '[PRE70]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Of course, the actual user authentication is still extremely rudimentary in
    this example-we're only checking one hardcoded user/password combination. In a
    production setup, you can implement any kind of user authentication in this place
    (which will typically consist of looking up a user in a database collection and
    comparing the submitted password's hash with the user's stored password hash).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这个例子中，实际的用户身份验证仍然非常基本-我们只检查一个硬编码的用户/密码组合。在生产设置中，您可以在此处实现任何类型的用户身份验证（通常包括在数据库集合中查找用户并比较提交的密码哈希与用户存储的密码哈希）。
- en: Checking the authorization
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查授权
- en: Now, all that's left is to extend the chat application itself to only allow
    authorized users to connect. Luckily, WebSocket connections start as regular HTTP
    connections (before being upgraded to a WebSocket connection). This means that
    the browser will transfer all cookies in a `Cookie` HTTP header which you can
    then access in your application.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，唯一剩下的就是扩展聊天应用程序本身，以仅允许经过授权的用户连接。幸运的是，WebSocket连接开始时作为常规HTTP连接（在升级为WebSocket连接之前）。这意味着浏览器将在`Cookie`
    HTTP标头中传输所有cookie，然后您可以在应用程序中访问这些cookie。
- en: 'In order to keep the authorization concern separated from the actual chat business
    logic, we will implement everything authorization-related in a special decorator
    class that also implements the `Ratchet\MessageComponentInterface` interface and
    wraps the actual chat application. We will call this class `Packt\Chp6\Authentication\AuthenticationComponent`.
    Start by implementing this class with a constructor that accepts both a `MessageComponentInterface`
    and a `SessionProvider` as dependencies:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将授权问题与实际的聊天业务逻辑分开，我们将在一个特殊的装饰器类中实现所有与授权相关的内容，该类还实现了`Ratchet\MessageComponentInterface`接口并包装了实际的聊天应用程序。我们将称这个类为`Packt\Chp6\Authentication\AuthenticationComponent`。首先，通过实现一个接受`MessageComponentInterface`和`SessionProvider`作为依赖项的构造函数来实现这个类：
- en: '[PRE71]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Continue by implementing the methods that are defined by the `MessageComponentInterface`.
    to begin, implement all these methods to simply delegate to the respective method
    on the `$wrapped` object:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过实现`MessageComponentInterface`定义的方法。首先，将所有这些方法实现为简单地委托给`$wrapped`对象上的相应方法：
- en: '[PRE72]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You can now add an authentication check to the following new `onOpen` method.
    In here, you can check if a cookie with a session ID is set, use the `SessionProvider`
    to check if the session ID is valid, and only accept the connection (meaning:
    delegate to the wrapped component) when a valid session exists:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以向以下新的`onOpen`方法添加身份验证检查。在这里，您可以检查是否设置了带有会话ID的cookie，使用`SessionProvider`检查会话ID是否有效，并且仅在存在有效会话时接受连接（意思是：委托给包装组件）：
- en: '[PRE73]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: If no session ID is found or if the given session ID is not valid, the connection
    will be closed immediately. Otherwise, the session ID will be used to look up
    the associated user from the `SessionProvider` and added as a new property to
    the connection object. In the wrapped component, you can then simply access `$conn->user`
    again to get a reference to the currently authenticated user.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未找到会话ID或给定的会话ID无效，则连接将立即关闭。否则，会话ID将用于从`SessionProvider`中查找关联的用户，并将其添加为连接对象的新属性。在包装组件中，您可以简单地再次访问`$conn->user`以获取对当前经过身份验证的用户的引用。
- en: Connecting users and messages
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接用户和消息
- en: You can now assert that only authenticated users can send and receive messages
    in the chat. However, the messages themselves are not yet associated with any
    specific user, so you'll still not know which user actually sent a message.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以断言只有经过身份验证的用户才能在聊天中发送和接收消息。但是，消息本身尚未与任何特定用户关联，因此您仍然不知道实际发送消息的用户是谁。
- en: 'Up until now, we have worked with simple plain-text messages. As each message
    will now need to contain more information than the pure message text, we''ll switch
    to JSON encoded messages. Each chat message will contain an `msg` property that
    is sent from the client to the server, and the server will add an `author` property
    filled with the username of the currently authenticated username. This can be
    done in the `onMessage` method of the `ChatComponent` that you''ve built earlier,
    as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用简单的纯文本消息。由于每条消息现在需要包含比纯文本更多的信息，因此我们将切换到JSON编码的消息。每条聊天消息将包含一个从客户端发送到服务器的`msg`属性，服务器将添加一个填充有当前经过身份验证的用户名的`author`属性。这可以在您之前构建的`ChatComponent`的`onMessage`方法中完成，如下所示：
- en: '[PRE74]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this example, we're first JSON-decoding the message received from the client.
    Then, we'll add an `"author"` property to the message, filled with the username
    of the authenticated user (remember, the `$from->user` property is set in the
    `AuthenticationComponent` that you built in the previous section). The message
    is then re-encoded and sent to all connected users.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先对从客户端接收的消息进行JSON解码。然后，我们将向消息添加一个`"author"`属性，其中填写了经过身份验证的用户的用户名（请记住，`$from->user`属性是在您之前构建的`AuthenticationComponent`中设置的）。然后，将重新编码消息并发送给所有连接的用户。
- en: 'Of course, our JavaScript frontend must also support these new JSON encoded
    messages. Start by changing the `appendMessage` function in your `app.js` JavaScript
    file to accept messages in the form of structured objects, instead of simple strings:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的JavaScript前端也必须支持这些新的JSON编码消息。首先，要更改`app.js` JavaScript文件中的`appendMessage`函数，以接受结构化对象形式的消息，而不是简单的字符串：
- en: '[PRE75]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `appendMessage` function is used by both the WebSocket connection''s `onmessage`
    event and your submit button listener. The `onmessage` event needs to be modified
    to first JSON-decode incoming messages:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`appendMessage`函数被WebSocket连接的`onmessage`事件和您的提交按钮监听器所使用。`onmessage`事件需要修改为首先对传入的消息进行JSON解码：'
- en: '[PRE76]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Also, the submit button listener needs to send JSON-encoded data to the WebSocket
    server, and also pass structured data into the modified `appendMessage` function:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，提交按钮监听器需要将JSON编码的数据发送到WebSocket服务器，并将结构化数据传递到修改后的`appendMessage`函数中：
- en: '[PRE77]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned about the basic principles of WebSocket applications
    and how to build them using the Ratchet framework. In contrast to most PHP applications,
    Ratchet apps are deployed as single, long-running PHP processes that do not require
    process managers such as FPM or web servers. This requires a quite different deployment,
    which we have also looked into in this chapter, both for development and for high-scale
    production environments.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了WebSocket应用程序的基本原则以及如何使用Ratchet框架构建它们。与大多数PHP应用程序相比，Ratchet应用程序部署为单个长时间运行的PHP进程，不需要像FPM或Web服务器这样的进程管理器。这需要一种完全不同的部署方式，我们在本章中也进行了研究，无论是用于开发还是用于高规模的生产环境。
- en: In addition to simply serving WebSockets using Ratchet, we have also looked
    at how you can integrate Ratchet applications with other frameworks (for example,
    the Slim framework that you have already worked with in [Chapter 5](ch05.html
    "Chapter 5.  Creating a RESTful Web Service"), *Creating a RESTful Web Service*)
    using the PSR-7 standard.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单地使用Ratchet提供WebSockets之外，我们还研究了如何使用PSR-7标准将Ratchet应用程序与其他框架集成（例如，您在[第5章](ch05.html
    "第5章。创建RESTful Web服务")中已经使用过的Slim框架，*创建RESTful Web服务*)。
- en: In [Chapter 7](ch07.html "Chapter 7. Building an Asynchronous Microservice Architecture"),
    *Building an Asynchronous Microservice Architecture*, you will learn about yet
    another communication protocol that you can use to integrate applications. While
    WebSockets are still built on HTTP, the next chapter will feature the **ZeroMQ**
    protocol-which is completely different from HTTP and brings along a whole new
    set of challenges to be solved.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。构建异步微服务架构")中，*构建异步微服务架构*，您将了解另一种通信协议，可以用来集成应用程序。虽然WebSockets仍然建立在HTTP之上，但下一章将介绍**ZeroMQ**协议-这与HTTP完全不同，并带来了一整套新的挑战需要解决。
