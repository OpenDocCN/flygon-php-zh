- en: Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: Although we discussed different aspects, what we have made is a RESTful web
    service for a simple blog in this book. We took that example to keep things simple
    in terms of business logic so that we can focus on our actual subject in detail.
    This was helpful, but in the real world, things are not that simple and small.
    There are big systems with different parts, which are difficult to maintain. These
    parts are also difficult to debug and scale. Scaling is different from just maintaining
    something and optimizing it for better performance. In scaling, optimization of
    both code and deployment environment matter. Scalability, maintainability, and
    performance have always been challenges that we have faced.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在本书中讨论了不同的方面，但我们所做的是为一个简单的博客创建了一个RESTful web服务。我们选择了这个例子，以便在业务逻辑方面保持简单，这样我们可以更详细地专注于我们的实际主题。这是有帮助的，但在现实世界中，事情并不那么简单和小。有着不同部分的大型系统很难维护。这些部分也很难调试和扩展。扩展性与仅仅维护和优化以获得更好的性能是不同的。在扩展性方面，代码和部署环境的优化都很重要。可扩展性、可维护性和性能一直是我们面临的挑战。
- en: To handle this, we have an architectural style, known as microservices. So,
    in this chapter, we will discuss this. Microservices are not an essential thing
    to use. However, they solve some challenges that we often face while making RESTful
    web services for bigger systems. So, we will see how microservices solve those
    problems and what are the challenges that come with microservices architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们有一种被称为微服务的架构风格。因此，在本章中，我们将讨论这个问题。微服务并不是必须使用的东西。然而，它们解决了我们在为更大的系统创建RESTful
    web服务时经常面临的一些挑战。因此，我们将看到微服务如何解决这些问题，以及微服务架构带来的挑战。
- en: 'Here are the topics that we will discuss in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将讨论的主题：
- en: Introducing microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍微服务
- en: Motivation towards microservices-based architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于微服务架构的动机
- en: How it is different from SOA (Service Oriented Architecture)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与SOA（面向服务的架构）有何不同
- en: Team structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队结构
- en: Microservices challenges
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的挑战
- en: Microservices implementation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务实现
- en: Introducing Microservices
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍微服务
- en: 'Let''s first define microservices architecture and then go into the details
    of microservices. Microservices architecture became a hot term, but there wasn''t
    any formal definition. In fact, to date, there is no official consensus regarding
    its properties or definition. However, different people have tried to define it.
    I found a definition on Martin Fowler''s blog very convincing. He and James Lewis
    defined it this way:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们定义微服务架构，然后深入了解微服务的细节。微服务架构成为一个热门术语，但并没有任何正式的定义。事实上，迄今为止，关于其属性或定义，还没有官方共识。然而，不同的人尝试过定义它。我在Martin
    Fowler的博客上找到了一个定义，非常令人信服。他和James Lewis这样定义它：
- en: <q>The microservice architectural style is an approach to developing a single
    application as a **suite of small services**, each **running in its own process**
    and communicating with lightweight mechanisms, often an HTTP resource API. These
    services are **built around business capabilities** and **independently deployable**
    by fully automated deployment machinery. There is a **bare minimum of centralized
    management** of these services, which may be written in different programming
    languages and use different data storage technologies. -- James Lewis and Martin
    Fowler</q>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构风格是一种将单个应用程序开发为一组小服务的方法，每个服务在自己的进程中运行，并使用轻量级机制进行通信，通常是HTTP资源API。这些服务围绕业务能力构建，并且可以通过完全自动化的部署机制独立部署。这些服务的集中管理最少，可能使用不同的编程语言和不同的数据存储技术。--
    James Lewis和Martin Fowler
- en: It seems very formal, so let's dig into this definition and try to understand
    microservice architecture.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎很正式，所以让我们深入了解这个定义，并尝试理解微服务架构。
- en: First of all, you should know that in the example, the RESTful web service we
    created for the blog was a monolithic web service. This means everything was in
    the same web service. Everything was together, so it needs to be deployed together
    as one code base. We can use the same monolithic approach for a bigger application
    as well, but that application will start becoming more and more complex and will
    be less scalable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你应该知道，在我们为博客创建的RESTful web服务的例子中，是一个单体式的web服务。这意味着一切都在同一个web服务中。一切都在一起，因此需要一起部署为一个代码库。我们也可以对更大的应用程序使用相同的单体式方法，但该应用程序将变得越来越复杂，可扩展性将会减弱。
- en: As opposed to that, microservices are composed of a lot of small services. Every
    small service is known as a microservice, or we can simply call it a service.
    These services fulfill the purpose of one application, but they are independent
    and very loosely coupled. So, every microservice has a separate code base and
    has a separate database or storage. As each microservice is independent, it can
    be deployed independently, even if we want to deploy on the same server or a different
    one. This means all services may or may not be in the same language or framework.
    It is possible that if one service is in PHP, another can be in Node.js and another
    can be in Python.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，微服务由许多小服务组成。每个小服务被称为微服务，或者我们可以简单地称之为服务。这些服务实现了一个应用程序的目的，但它们是独立的，非常松散耦合的。因此，每个微服务都有一个单独的代码库和一个单独的数据库或存储。由于每个微服务都是独立的，即使我们想要在同一台服务器上或不同的服务器上部署，它也可以独立部署。这意味着所有服务可能是相同的语言或框架，也可能不是。如果一个服务是PHP，另一个可能是Node.js，另一个可能是Python。
- en: How to divide an application into microservices?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何将应用程序划分为微服务？
- en: So, the question is, "If we have a big application, then how do we decide how
    to divide it in different micro services?" We will look into different factors
    while understanding how to divide one big system into microservices. These factors
    are based on what Martin Fowler called "Characteristics of Microservices." You
    can see Martin Fowler's complete post on Characteristics of Microservices at [https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，问题是，“如果我们有一个庞大的应用程序，那么我们如何决定如何将其分成不同的微服务？”在理解如何将一个大系统分成微服务时，我们将考虑不同的因素。这些因素基于马丁·福勒所谓的“微服务的特征”。您可以在[https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html)上查看马丁·福勒关于微服务特征的完整文章。
- en: 'So, these are the factors to consider while dividing a big system into small
    microservices:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在将一个大系统分成小的微服务时，需要考虑以下因素：
- en: Each microservice should be independent of other microservices. If not completely
    independent (as these services are part of one application so they may interact
    with each other) then dependency should be minimal.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务应该独立于其他微服务。如果不是完全独立的（因为这些服务是一个应用程序的一部分，所以它们可能会相互交互），那么依赖关系应该是最小的。
- en: We will divide the application into different components. By components, we
    mean a unit of software that is independently replaceable and upgradeable. This
    means replacing or upgrading a component should not have any (or should have minimum)
    effect on the application. One microservice will be based on such a single component.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将应用程序分成不同的组件。所谓组件，是指一个可以独立替换和升级的软件单元。这意味着替换或升级一个组件不应该对应用程序产生任何（或者最小的）影响。一个微服务将基于这样一个单一组件。
- en: A service should have a single responsibility.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个服务应该有一个单一的责任。
- en: To divide an application or system into several micro-systems, you can start
    by looking at the business requirements. It is a good idea to make components
    based on business capabilities. In fact, our teams should be divided based on
    business capability, not based on technology.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序或系统分成几个微系统，可以从业务需求入手。根据业务能力制作组件是一个好主意。事实上，我们的团队应该根据业务能力而不是技术来划分。
- en: At the same time, it is important to ensure that services are not too fine-grained.
    Fine-grained services can result in more effort at the development end and still
    result in bad performance because there are too many things interacting with each
    other because they actually depend on each other.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时，确保服务不要过于细粒度也很重要。过于细粒度的服务可能会导致开发工作量增加，同时由于相互交互的事物太多而导致性能不佳，因为它们实际上是相互依赖的。
- en: In an ideal case, those services are always independent of each other. However,
    it is not always possible. Sometimes, there is something that one service needs
    from the other one, and sometimes, two or more services have some common logic.
    So, dependent services interact with each other mostly through HTTP calls, and
    common logic can be in a shared code base across different services. However,
    that is only possible when the same technology is being used in those services.
    Actually, this means that two or more services are depending on common code base.
    So, in theory based on the preceding definition, this is against the microservices
    architecture, but as there is no formal theory or official specification so we
    are considering anything that is happening in real world what is happening in
    the real world.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，这些服务总是彼此独立的。然而，这并不总是可能的。有时，一个服务需要另一个服务的某些东西，有时，两个或更多服务有一些共同的逻辑。因此，依赖服务主要通过HTTP调用相互交互，共同的逻辑可以在不同服务之间的共享代码库中。然而，这仅在这些服务中使用相同技术时才可能。实际上，这意味着两个或更多服务依赖于共同的代码库。因此，根据前述定义，从理论上讲，这违反了微服务架构，但由于没有正式的理论或官方规范，所以我们考虑任何在现实世界中发生的事情。
- en: Motivation towards microservices
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对微服务的动机
- en: There are several motivations towards microservices. However, the one that I
    want to start with is when we are dividing it into components having single responsibilities,
    we are abiding by the **SRP** (**Single Responsibility Principle**). Single responsibility
    is actually one of the first five Object Oriented Principles, also known as SOLID
    ([https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design))
    ). This single responsibility principle, even if it is at architectural level
    or low level, it makes things simple and easy. Here, in the case of microservices,
    separates different components from each other. So, the reason for modifying a
    component will be related to one single functionality. Other components and functionalities
    of the system will work as they were working before. This is how being separated
    and being independent as microservices makes them easier to modify without affecting
    others.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个动机支持微服务。然而，我想要开始的是，当我们将其分成具有单一责任的组件时，我们遵守**SRP**（**单一责任原则**）。单一责任实际上是面向对象原则中的前五个之一，也被称为SOLID（[https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design))）。这个单一责任原则，无论是在架构层面还是低层面，都使事情变得简单和容易。在微服务的情况下，它将不同的组件分离开来。因此，修改一个组件的原因将与一个单一功能相关。系统的其他组件和功能将像以前一样工作。这就是微服务作为独立的组件和功能使它们更容易修改而不影响其他组件的方式。
- en: Here are some of the other reasons why it is necessary to separate microservices.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是必须分开微服务的其他原因。
- en: Maintenance and debugging
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护和调试
- en: It is nothing new to tell that modular code is always more easily maintainable.
    You can debug it easily and what can be more modular than components that are
    not only modular but also deployed as separate modules possibly on separate servers
    or separate server instances. So, we get a lot of advantages out of microservices
    that we can get from modular code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉大家模块化的代码总是更容易维护并且可以轻松调试，这并不是什么新鲜事。您可以轻松调试它，而且还有什么比不仅是模块化而且还部署为独立模块的组件更模块化的呢？因此，我们从微服务中获得了许多优势，这些优势是我们从模块化代码中获得的。
- en: However, there is something to understand. If we are working with the microservices
    architecture from start, application will be modular because we are making services
    separately. However, if we didn't start with microservices and later on, we want
    to convert it to microservices, then first, we need to have modular code and then
    we can use the microservices architecture because if we don't have modules and
    loosely coupled code, we cannot split them in to independent components.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一点需要理解。如果我们从一开始就使用微服务架构，应用程序将是模块化的，因为我们正在分开开发服务。然而，如果我们没有从一开始就使用微服务，而是后来想要将其转换为微服务，那么首先，我们需要有模块化的代码，然后我们才能使用微服务架构，因为如果我们没有模块和松散耦合的代码，我们就无法将它们拆分成独立的组件。
- en: So, in short, motivation here for microservices is simply that we can debug
    modular code and components easily. In the case of maintenance, there will not
    be such a ripple effect if the code is in separate components and other services
    are getting what they need, without worrying about the internal logic of modified
    components.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，微服务的动机很简单，我们可以轻松地调试模块化的代码和组件。在维护的情况下，如果代码在独立的组件中，并且其他服务得到了它们所需的东西，而不用担心修改组件的内部逻辑，那么就不会出现连锁反应。
- en: Actually this is not it; a very important factor in the maintenance stage is
    productivity. In bigger code bases, productivity can be reduced over time, because
    developers need to worry about the whole application. However, in microservices,
    developers in one team doing one particular change don't have to worry about the
    whole application but the code inside that particular service at the time, because
    for that particular change and for the developer working on it, this one microservice
    is the whole application which has a lot less responsibility than the overall
    application. So, that way, productivity during maintenance can be much better
    in microservices than monolithic applications.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这还不是全部；在维护阶段一个非常重要的因素是生产力。在更大的代码库中，随着时间的推移，生产力可能会降低，因为开发人员需要担心整个应用程序。然而，在微服务中，一个团队中的开发人员进行的特定更改不需要担心整个应用程序，而只需要关注那个特定服务内的代码，因为对于那个特定的更改和正在处理它的开发人员来说，这一个微服务就是整个应用程序，其责任远远小于整个应用程序。因此，在维护期间，微服务的生产力可能比单片应用程序要好得多。
- en: Scalability
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性
- en: When your system scales and you want to serve more clients and want good performance
    as well, after sometime, when you have done optimizations as well, you need better,
    more powerful servers. You can make servers more powerful by adding more resources
    into them. This is called vertical scaling. Vertical scaling has its limits. After
    all, this is one server. What if we want more scalability? Actually, there is
    another way of scaling, that is, horizontal scaling. In horizontal scaling, you
    add more small servers or server instances instead of adding all the resources
    in to one server. In that case, how will one monolithic application be deployed
    on multiple servers? We will probably need to deploy the complete application
    on multiple servers and then load balancers, managing traffic through multiple
    servers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统扩展并且您想要为更多客户提供良好的性能时，经过一段时间，当您也进行了优化后，您需要更好、更强大的服务器。您可以通过向服务器添加更多资源来使服务器更强大。这被称为垂直扩展。垂直扩展有其局限性。毕竟，这是一个服务器。如果我们想要更多的可扩展性呢？实际上，还有另一种扩展方式，即水平扩展。在水平扩展中，您添加更多的小型服务器或服务器实例，而不是将所有资源添加到一个服务器中。在这种情况下，一个单片应用程序将如何部署在多个服务器上？我们可能需要在多个服务器上部署完整的应用程序，然后通过负载均衡器来管理通过多个服务器的流量。
- en: However, having the whole application on multiple servers is not cost effective.
    What if we can have one part of the application served from one server and another
    part from another server? How can this be possible? We have one application. So,
    this is where the microservices architecture comes in. Its advantages are not
    limited to just scalability. One of its key benefits is the loosely coupled components
    of a system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将整个应用程序部署在多个服务器上并不划算。如果我们可以让应用程序的一部分从一个服务器提供，另一部分从另一个服务器提供呢？这怎么可能？我们只有一个应用程序。这就是微服务架构的优势所在。它的好处不仅仅是可扩展性。其关键好处之一是系统中松散耦合的组件。
- en: Technology diversity
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术多样性
- en: As we have seen, in microservices, every codebase is separate from the other.
    So, different teams working on different services can use different technologies
    and different storage if they want to. In fact, those teams are completely free
    from the need to use the same technology across different services until you are
    providing other services that are interacting with each other. However, if we
    want to use the option of shared code to avoid repeatedly writing the same logic
    in different technologies, then to have a shared code base, we may need to use
    the same technology.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，在微服务中，每个代码库都与其他代码库分开。因此，不同的团队可以使用不同的技术和不同的存储来开发不同的服务。事实上，这些团队完全不需要在不同的服务之间使用相同的技术，除非它们提供的其他服务需要相互交互。然而，如果我们想要使用共享代码的选项来避免在不同技术中重复编写相同的逻辑，那么为了拥有共享的代码库，我们可能需要使用相同的技术。
- en: Resilience
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性
- en: In microservices, resilience is also one of the key benefits. As every service
    is a separate component, if one component of the system is failing for some reason,
    then the problem can be isolated from the rest of the system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务中，弹性也是其中一个关键的好处。由于每个服务都是一个独立的组件，如果系统的一个组件因某种原因失败，那么问题可以与系统的其余部分隔离开来。
- en: However, we need to make sure that with failures, the system degrades properly.
    If there is failure in a service, we can try to minimize it, but there can be
    a failure again. However, to minimize its effect, we should handle it carefully
    so that we minimize its impact on other services and our application's user.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要确保系统在发生故障时能够正确降级。如果一个服务出现故障，我们可以尝试将其最小化，但可能会再次出现故障。然而，为了最小化其影响，我们应该小心处理，以便最小化其对其他服务和我们应用程序用户的影响。
- en: Replaceability
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可替换性
- en: If you want to replace a part of the system, then it is not that simple in monolithic
    architecture because everything is in the same code base. However, in microservices,
    it is easier to replace one component of the system because all you need to do
    is have another service and replace it with the existing one. Obviously, you still
    need to have an alternative service, but it is not like replacing the whole component
    in the same code base with some other code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要替换系统的一部分，那么在单片架构中并不那么简单，因为一切都在同一个代码库中。然而，在微服务中，更容易替换系统的一个组件，因为你所需要做的就是有另一个服务并用它替换现有的服务。显然，你仍然需要有一个替代服务，但不像在同一个代码库中用其他代码替换整个组件那样。
- en: Parallelization
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行化
- en: Normally, clients want their software to be developed early and come onto the
    market early so that they can test their idea or capture more market. For that
    reason, they want more developers working in parallel on their application. Unfortunately,
    in monolithic applications, we can do limited parallel work. Actually, we can
    do that in monolithic applications as well if we have very modular code. However,
    still, it can't be as independent and modular as it is in a microservices-based
    application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，客户希望他们的软件能够早期开发并尽快上市，以便他们可以测试他们的想法或占领更多市场。因此，他们希望有更多的开发人员并行工作在他们的应用程序上。不幸的是，在单片应用程序中，我们可以进行有限的并行工作。实际上，如果我们有非常模块化的代码，我们也可以在单片应用程序中进行并行工作。然而，它仍然不能像基于微服务的应用程序那样独立和模块化。
- en: Every service is being developed and deployed separately. Although these services
    communicate with each other, still, development can be done independently, and
    in most cases, we can keep several services being developed separately. So, many
    developers, in fact, the development team, can work in parallel, which means software
    can be developed early. If there is a problem or another feature is required in
    multiple modules, then it can be done in parallel.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务都是独立开发和部署的。虽然这些服务彼此通信，但开发可以独立进行，在大多数情况下，我们可以保持几个服务的独立开发。因此，许多开发人员，实际上是开发团队，可以并行工作，这意味着软件可以早期开发。如果多个模块需要解决问题或需要另一个功能，则可以并行进行。
- en: How it is different from SOA
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与SOA的不同之处
- en: 'SOA stands for Service Oriented Architecture. By name it seems that this architecture
    depends on services just like micro-services. Service Orientation is a design
    paradigm in computer software in the form of services. Its principles stress the
    separation of concerns (the same as SRP). Until now, it seems similar to microservices.
    Before understanding difference, we need to know that what is SOA. Although there
    is no one clear official definition of SOA. So let''s take this basic definition
    from wikipedia:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SOA代表面向服务的架构。从名称上看，这种架构依赖于服务，就像微服务一样。服务定位是计算机软件中的一种服务设计范式。其原则强调关注点的分离（与SRP相同）。到目前为止，它似乎与微服务相似。在了解差异之前，我们需要知道什么是SOA。尽管没有一个清晰的官方定义SOA。所以让我们从维基百科中获取这个基本定义：
- en: A service-oriented architecture (SOA) is a style of software design where services
    are provided to the other components by application components, through a communication
    protocol over a network. The basic principles of service-oriented architecture
    are independent of vendors, products and technologies.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务的架构（SOA）是一种软件设计风格，应用组件通过网络上的通信协议向其他组件提供服务。服务导向架构的基本原则与供应商、产品和技术无关。
- en: If you look at this definition then you will find that SOA is very similar to
    micro-services but its definition is not that concise and clear. One reason can
    be that SOA itself is a generalized architecture. Or we can better say that SOA
    is generalized form of micro-services.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看这个定义，你会发现SOA与微服务非常相似，但它的定义并不那么简洁和清晰。一个原因可能是SOA本身是一个广义的架构。或者我们可以更好地说，SOA是微服务的广义形式。
- en: 'As stated in Oracle''s post:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如Oracle的帖子所述：
- en: <q>Microservices are the kind of SOA we have been talking about for the last
    decade. -- *Torsten Winterberg, Oracle ACE Director.*</q>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: “过去十年我们一直在谈论的就是微服务的SOA。”-- *Torsten Winterberg, Oracle ACE Director.*
- en: So micro-services follow same principles but it is bit more specialized and
    focus on having multiple independent services where a service is a completely
    different component and it exists independent of other services.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，微服务遵循相同的原则，但它更加专业化，专注于拥有多个独立的服务，其中一个服务是完全不同的组件，独立于其他服务存在。
- en: Team structure
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队结构
- en: 'As per Conway''s law:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据康威定律：
- en: <q>"Organizations which design systems ... are constrained to produce designs
    which are copies of the communication structures of these organizations."</q>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “设计系统的组织...受限于产生与这些组织的通信结构相同的设计。”
- en: So, in order to produce designs based on microservices architecture and to gain
    its benefits, we also need structured teams working on this accordingly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了基于微服务架构制定设计并获得其好处，我们还需要相应地组织工作的结构化团队。
- en: 'Normally, in a monolithic application, we have teams such as the following
    ones:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在单片应用程序中，我们有以下团队：
- en: Dev-ops team
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dev-ops团队
- en: Backend-developer team
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端开发团队
- en: DB administrator team
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库管理员团队
- en: Mobile application developer team
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动应用程序开发团队
- en: 'However, in the case of distributed architecture such as microservices (if
    we are developing an e-commerce application), we will have teams such as the following
    ones:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在分布式架构的情况下，例如微服务（如果我们正在开发电子商务应用程序），我们将有以下团队：
- en: Products catalog
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品目录
- en: Inventory
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存
- en: Orders
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单
- en: Coupons
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优惠券
- en: Wishlist
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 愿望清单
- en: All these teams will have members, including Dev-ops, Backend-developer, DB
    administrator, and mobile app developer. So, in the case of microservices, we
    will have a team per service.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些团队都将有成员，包括Dev-ops、后端开发人员、数据库管理员和移动应用开发人员。因此，在微服务的情况下，我们将为每个服务设立一个团队。
- en: '**Size of team:**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**团队规模：**'
- en: 'There is no hard and fast rule, but it is recommended that team size should
    be as per Jeff Bezos'' 2 pizza rule: <q>if a team couldn''t be fed with two pizzas,
    it was too big.</q> The reason is that if the team becomes bigger, then communication
    can be terrible.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 没有硬性规定，但建议团队规模应符合杰夫·贝佐斯的“2披萨规则”：<q>如果一个团队不能靠两块披萨养活，那就太大了。</q>原因是，如果团队变得更大，那么沟通可能会变得糟糕。
- en: Challenges of micro-services
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的挑战
- en: Nothing comes free. Everything has its downside or at least some challenges
    that you need to deal with. If we go for microservices, it has its own challenges.
    So, let's look at them and discuss how they can be minimized if there is trade-off.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 没有免费的午餐。一切都有其不利之处，或者至少有一些需要应对的挑战。如果我们选择微服务，它也有自己的挑战。因此，让我们来看看它们，并讨论如果有权衡的话，如何将它们最小化。
- en: Infrastructure maintenance
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施维护
- en: Although you don't have to update your infrastructure every day, it still needs
    to be maintained and it needs more effort. Technology freedom comes with microservices,
    but not without any cost. You have to maintain different server instances using
    different technologies. This will need better infrastructure and people with experience
    of more technologies.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你不必每天更新你的基础设施，但它仍然需要维护，需要更多的努力。微服务带来了技术自由，但并非没有任何代价。你必须使用不同的技术来维护不同的服务器实例。这将需要更好的基础设施和有更多技术经验的人。
- en: Actually, you don't always need better infrastructure and people with knowledge
    of all those different technologies. Normally, every team working on different
    services will have its own infrastructure or Dev-ops-related people. However,
    in that case, you need more people because now, you are not sharing Dev-ops or
    infrastructure-related people across different teams. In fact, this is how teams
    are made for microservices. Teams don't have shared resources at-least they shouldn't
    have. Otherwise, you don't get the advantage of parallel working because of independent
    services.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你并不总是需要更好的基础设施和对所有这些不同技术都有了解的人。通常，每个负责不同服务的团队都会有自己的基础设施或与Dev-ops相关的人员。然而，在这种情况下，你需要更多的人，因为现在，你不再在不同团队之间共享Dev-ops或基础设施相关的人员。事实上，这就是微服务团队的组成方式。团队至少不应该有共享资源。否则，你就无法因为独立服务而获得并行工作的优势。
- en: However, infrastructure doesn't only mean server setup, but also deployments,
    monitoring, and logging. So, for that purpose, you can't just use one technology
    and solve the problem on the trade-off of limiting your technology choices. However,
    limiting your technology choices can make it a bit easier for Dev-ops as well.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，基础设施不仅意味着服务器设置，还包括部署、监控和日志记录。因此，为了达到这个目的，你不能只使用一种技术来解决问题，而牺牲了你的技术选择。然而，限制你的技术选择也可以让Dev-ops变得更容易一些。
- en: Another thing is that you need to have automated deployments on a continuous
    integration server. It runs your test cases, and then, if everything works well,
    it deploys on your actual server. For this purpose, you need to have Dev-ops person/people
    who write scripts to automate your deployments. There are several ways to do so.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件事是你需要在持续集成服务器上进行自动部署。它运行你的测试用例，然后，如果一切顺利，就会部署到你的实际服务器上。为此，你需要有Dev-ops人员编写脚本来自动化你的部署。有几种方法可以做到这一点。
- en: Performance
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: Actually, there can be reasons for microservices to run faster if one completely
    independent microservice is being used by the client. A clear reason is that a
    request has to go through less stuff in one small micro-service than passing through
    a big monolithic application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，微服务可以更快地运行的原因是，客户端使用了一个完全独立的微服务。一个明显的原因是，一个请求在一个小的微服务中需要经过的步骤比在一个大型单体应用中要少。
- en: However, this is an ideal case and not all microservices are completely independent
    of each other. They interact with each other and depend on each other. So, if
    one service has to get something from another one, it will most probably need
    a network call, and network calls are expensive. This results in performance problems.
    However, this can be minimized if services are created in a way where dependency
    is minimal. If dependency is not minimal, that means services are not independent
    and in that case we can combine such services and make one independent service.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一个理想情况，不是所有的微服务都完全独立于彼此。它们相互作用并且相互依赖。因此，如果一个服务需要从另一个服务获取某些东西，它很可能需要进行网络调用，而网络调用是昂贵的。这会导致性能问题。然而，如果服务以最小的依赖方式创建，这种情况可以最小化。如果依赖不是最小的，那就意味着服务不是独立的，在这种情况下，我们可以合并这样的服务并创建一个独立的服务。
- en: Another option can be shared code; the code that will be used across different
    services. If two or more services are using the same functionality, then instead
    of having that as another service that different services depend on, we can simply
    make it a shared code that will be part of different services' code base. We will
    not repeat ourselves and will try to make it a module or package that different
    services can use. However, some people think it is bad practice as we will have
    some code shared between different services, which means it is not going to be
    loosely coupled.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择可以是共享代码；这段代码将被用于不同的服务之间。如果两个或更多服务使用相同的功能，那么我们可以将其作为不同服务依赖的另一个服务，而是将其作为不同服务代码库的一部分共享代码。我们不会重复自己，会尝试将其制作成不同服务可以使用的模块或包。然而，有些人认为这是不好的做法，因为我们会在不同服务之间共享一些代码，这意味着它不会松散耦合。
- en: Debugging and fault-finding
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和故障排除
- en: As you can see, we said debugging and maintenance will be easier in a microservice.
    However, it also becomes a challenge when there is communication between these
    services and one's output is effecting another.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们说在微服务中调试和维护会更容易。然而，当这些服务之间进行通信并且一个服务的输出影响另一个服务时，这也会成为一个挑战。
- en: 'When we have different services, we need a way for services to communicate
    with each other. Services communicate with each other in two ways: through HTTP
    calls or through messages. Here, by messages we mean using some sort of messaging
    queues such as RabbitMQ and so on. In the case of message passing, it can be very
    difficult if there is some bug or something unexpected is happening. Since it
    is not one service and every service is working based on the previous service''s
    output, it is difficult to know where the problem is.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有不同的服务时，我们需要一种服务之间相互通信的方式。服务之间的通信有两种方式：通过HTTP调用或通过消息。这里，通过消息我们指的是使用某种消息队列，比如RabbitMQ等。在消息传递的情况下，如果出现错误或者发生了一些意外情况，那么这可能会非常困难。因为不只有一个服务，每个服务都是基于前一个服务的输出工作的，所以很难知道问题出在哪里。
- en: So, a way to tackle this is to write tests thoroughly. Because if it is making
    sure that every service's test cases are written and testing whether they are
    working fine, then it can fail before deployment.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，解决这个问题的一种方法是彻底编写测试。因为如果确保每个服务的测试用例都被编写并测试它们是否正常工作，那么在部署之前就可以发现问题。
- en: However, this is not always the case. It is because there is not one service.
    Many services are interacting and sometimes, there is a problem in the live environment
    and you want to debug and fix it. For this purpose, logs are very important. However,
    again, this is a distributed environment. So, what can we do? Here are few things
    that you need to ensure you do with logs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，情况并非总是如此。这是因为不只有一个服务。许多服务正在交互，有时，实时环境中会出现问题，你希望进行调试和修复。出于这个目的，日志非常重要。然而，再次强调，这是一个分布式环境。那么，我们能做些什么呢？以下是你需要确保在日志中做的一些事情。
- en: Logs should be centralized
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志应该是集中的
- en: You need to collect logs in some central place. If you have logs in one centralized
    place, then it is much easier to look into them instead of checking every server
    instance for its logs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在某个集中的地方收集日志。如果你的日志在一个集中的地方，那么查看它们就会更容易，而不是检查每个服务器实例的日志。
- en: It is also important because you should have logs in an external place other
    than your instances as logs' backup. The reason is that if you replace an instance,
    then you probably want to keep a copy of your logs to utilize while debugging.
    This can be any place either Amazon S3, your DB, or a disk, but you want it to
    be durable and available. If you are on AWS, then you can also use their monitoring
    service named CloudWatch at [https://aws.amazon.com/cloudwatch/](https://aws.amazon.com/cloudwatch/).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这也很重要，因为你应该在实例之外的地方有日志备份。原因是，如果你替换了一个实例，那么你可能希望保留日志的副本以便在调试时使用。这可以是任何地方，包括亚马逊S3、你的数据库或者磁盘，但你希望它是持久的和可用的。如果你在AWS上，你也可以使用他们的监控服务CloudWatch。
- en: Logs should be searchable
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志应该是可搜索的。
- en: Having logs is good. But just like a lot of information on Internet, it is not
    really useful if you don't know which link has the right information for you.
    It has become easier because of search engines telling us which pages have more
    relevant content. Similarly, logs of live applications, especially when there
    is a log of many services together, will not be that helpful. There will be a
    lot of logs. So, in order to make them usable, you should store your logs in way
    in which they can be searched for and be easily understood when you see them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有日志是好的。但就像互联网上的很多信息一样，如果你不知道哪个链接对你来说有用，那它实际上并不有用。由于搜索引擎告诉我们哪些页面有更相关的内容，这变得更容易。同样，活动应用程序的日志，特别是当有很多服务的日志在一起时，将不会那么有用。会有很多日志。因此，为了使它们可用，你应该以一种可以搜索和在查看时容易理解的方式存储你的日志。
- en: Track chain of requests
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪请求链
- en: Just like users go from one page to another on a website, the users' clients
    send request after request to perform different tasks. So, it is a good idea to
    know which requests the user sent before this one because in some cases, previous
    requests can have an impact othes. So, to track this, you can simply pass an identifier
    for the first time and should expect the same among all other requests.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 就像用户在网站上从一个页面转到另一个页面一样，用户的客户端发送请求来执行不同的任务。因此，知道用户在这之前发送了哪些请求是一个好主意，因为在某些情况下，之前的请求可能会影响其他请求。因此，为了跟踪这一点，你可以简单地传递一个标识符，第一次期望在所有其他请求中都能找到相同的标识符。
- en: Another advantage is that it will not only show you flow, but it will also be
    easier for you if you are asked to explain why some specific problem occurred.
    If that identifier is at the client side, the concerned person can give you that
    identifier for reference with their error report so that you can can understand
    which request flow to trace.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是，它不仅会显示流程，而且如果有人要求你解释为什么出现了某个特定的问题，那么对你来说也会更容易。如果标识符在客户端，相关人员可以在错误报告中给你该标识符作为参考，这样你就可以理解要跟踪哪个请求流程。
- en: Dynamic log levels
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态日志级别
- en: Normally, for logging, you use some sort of logging framework, and typical log
    levels are warning, info, debug, and verbose. Normally, in production, log level
    info or other information is used, but if you want to have some problem and you
    want to debug it, you should be able to dynamically change that log level.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于日志记录，你会使用某种日志框架，典型的日志级别有警告、信息、调试和详细。通常，在生产环境中，会使用信息级别或其他信息，但如果你想要解决一些问题并进行调试，你应该能够动态地更改日志级别。
- en: So, if you need, you should be able to set the log level dynamically on the
    fly. This is important because if you have problems in production, then you don't
    want it to persist for a long time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果需要的话，你应该能够动态地在运行时设置日志级别。这很重要，因为如果在生产环境中出现问题，你不希望它持续很长时间。
- en: Implementation
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: As this chapter is just an introduction to microservices, we will not go into
    the details of implementation. However, we will just have an overview of how we
    will implement different things in microservices. We have already discussed RESTful
    web service implementation in this book. However, here are some other pieces that
    come with microservices. So, we will just get idea of what is involved in implementing
    these parts.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章只是微服务的简介，我们不会深入讨论实现的细节。然而，我们将概述如何在微服务中实现不同的事物。我们已经在本书中讨论了RESTful Web服务的实现。然而，微服务还有其他一些部分。因此，我们只会了解在实现这些部分时涉及了什么。
- en: Deployments
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: We will have deployments automated. We will use continuous delivery tools. Continuous
    delivery is a process in which there are frequent deliveries with short cycles,
    and it ensures that software can be reliably released at any time. It aims to
    release software faster and minimize risk with a build, and test and release software
    frequently approach.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将自动化部署。我们将使用持续交付工具。持续交付是一个过程，其中有短周期的频繁交付，并确保软件可以随时可靠地发布。它旨在更快地发布软件，并通过构建、测试和频繁发布软件的方法来最小化风险。
- en: 'Continuous delivery takes automation from source control all the way through
    production. There are various tools or processes that help in accomplishing a
    continuous delivery process. However, two important things in this are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付从源代码控制一直到生产的自动化。有各种工具或流程可以帮助实现持续交付过程。然而，在其中有两个重要的事情：
- en: Testing
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: CI (Continuous Integration)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI（持续集成）
- en: First of all, before committing to code, a developer should run their tests
    (most importantly, unit tests) while on commit CI server, run integration tests,
    and integrate on the CI server if tests are passed. Travis CI and Jenkins CI are
    popular CI tools. Other than that, Circle CI is popular as well.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在提交代码之前，开发人员应该在提交CI服务器上运行他们的测试（最重要的是单元测试），运行集成测试，并在通过测试时在CI服务器上集成。Travis
    CI和Jenkins CI是流行的CI工具。除此之外，Circle CI也很受欢迎。
- en: 'After continuous integration, build is made automatically and deployed automatically.
    As a picture is worth a thousand words, to elaborate further, I have added this
    image from Wikipedia here (this image is from Wikimedia):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续集成之后，构建会自动进行并自动部署。由于一图胜千言，为了进一步阐述，我在这里添加了维基百科的这张图片（这张图片来自维基媒体）：
- en: '![](assets/649c4881-012a-43e8-adbf-adb9dc13a4b3.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/649c4881-012a-43e8-adbf-adb9dc13a4b3.png)'
- en: Through this diagram, we will get some idea of CI. For detailed information
    on continuous delivery, you can read the Wikipedia article at [https://en.wikipedia.org/wiki/Continuous_delivery](https://en.wikipedia.org/wiki/Continuous_delivery).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个图表，我们将对CI有一些了解。有关持续交付的详细信息，您可以阅读维基百科文章[https://en.wikipedia.org/wiki/Continuous_delivery](https://en.wikipedia.org/wiki/Continuous_delivery)。
- en: Inter-services communication
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务间通信
- en: We saw that communication between servers is important. Services depend on each
    other, and sometimes, input of one service is the output of another, while sometimes,
    one service is using another. One important thing is communication between these
    services.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到服务器之间的通信很重要。服务彼此依赖，有时一个服务的输入是另一个服务的输出，有时一个服务正在使用另一个服务。其中一个重要的事情是这些服务之间的通信。
- en: 'So, we can divide inter-service communication into two types:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将服务间通信分为两种类型：
- en: Synchronous communication
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同步通信
- en: Asynchronous communication
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步通信
- en: Synchronous communication
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步通信
- en: In synchronous communication, one service communicates with another and waits
    to get a result. This is normally done through simple HTTP calls using the same
    approach as end clients. So, these are simple HTTP calls that get a response (mostly
    JSON). One service sends an HTTP request to another service, waits for its response,
    and proceeds after getting the response. Synchronous communication has network
    overheads and have to wait for response, but it is simple to implement and sometimes
    that delay is not a problem. So in such cases, for the sake of simplicity we can
    use synchronous communication.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步通信中，一个服务与另一个服务通信并等待结果。通常通过简单的HTTP调用来完成，使用与最终客户端相同的方法。因此，这些是简单的HTTP调用，得到一个响应（通常是JSON）。一个服务向另一个服务发送HTTP请求，等待其响应，并在收到响应后继续。同步通信具有网络开销，并且必须等待响应，但实现简单，有时延迟不是问题。因此，在这种情况下，为了简单起见，我们可以使用同步通信。
- en: Asynchronous communication
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步通信
- en: In asynchronous communication, one service doesn't wait for another's response.
    It is based on a pub-sub model. It uses a message broker to send messages to other
    consumer/subscriber's services. It is done using Lightweight Messaging tools,
    through which one service sends messages to another. Such messaging tools include,
    but are not limited to, RabbitMQ, Apache Kafka, and Akka.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步通信中，一个服务不会等待另一个的响应。它基于发布-订阅模型。它使用消息代理向其他消费者/订阅者的服务发送消息。它使用轻量级消息传递工具，通过这些工具，一个服务向另一个服务发送消息。这样的消息传递工具包括但不限于RabbitMQ、Apache
    Kafka和Akka。
- en: If you are interested in knowing more about microservices inter communications,
    then the article at [http://howtocookmicroservices.com/communication/](http://howtocookmicroservices.com/communication/)
    might seem interesting.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对了解更多关于微服务之间通信的内容感兴趣，那么[http://howtocookmicroservices.com/communication/](http://howtocookmicroservices.com/communication/)上的文章可能会很有趣。
- en: Shared library or common code
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享库或公共代码
- en: As we discussed, there can be some code that is common among different services.
    It can be third-party code as well as code written by teams for the same application.
    In either case, we obviously want to use that common code. In order to do that,
    we don't just replicate that code in our applications because it breaks the DRY
    (Don't Repeat Yourself) principle. However, note that we can't use common code
    if we are using different programming languages/technologies.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论的，可能有一些代码在不同的服务之间是共通的。它既可以是第三方代码，也可以是由团队为同一个应用程序编写的代码。无论哪种情况，我们显然都希望使用这些共通的代码。为了做到这一点，我们不会在我们的应用程序中复制这些代码，因为这违反了DRY（不要重复自己）原则。但是，请注意，如果我们使用不同的编程语言/技术，我们就无法使用共通的代码。
- en: So what we do is, we package that common code or shared library and upload it
    somewhere, from where we can fetch that package while deploying it. In the case
    of PHP, we will create composer packages and upload at packagist. Then, in service,
    when we need that common code, we will simply install the composer's package and
    use that common code from the vendor directory.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们做的是，我们打包那些通用代码或共享库，然后上传到某个地方，在部署时可以从那里获取这个包。在PHP的情况下，我们会创建composer包并上传到packagist。然后，在服务中，当我们需要那些通用代码时，我们只需安装composer的包并从vendor目录中使用那些通用代码。
- en: Such packages and package managers like composer are not just in PHP. In Node.js,
    there is NPM (Node Package Manager) using which you can create a Node package
    to serve the purpose. So, in different technologies, there are different ways
    to create and use such packages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 像composer这样的包和包管理器不仅仅存在于PHP中。在Node.js中，有NPM（Node Package Manager），你可以使用它来创建一个Node包来实现相同的目的。因此，在不同的技术中，有不同的方法来创建和使用这样的包。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, as the last chapter of this book, I tried to introduce microservices,
    an architecture style getting a lot of attention nowadays. We looked into it because
    we needed an architecture in which we can use RESTful web services to achieve
    better performance and scalability in complex and bigger systems.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，作为本书的最后一章，我试图介绍微服务，这是一种现在备受关注的架构风格。我们研究它是因为我们需要一种架构，可以使用RESTful Web服务在复杂和更大的系统中实现更好的性能和可伸缩性。
- en: The focus of the book was RESTful web services in PHP7, and we looked at other
    topics that were connected with building RESTful web services or PHP7 in someway.
    We looked at some of these topics in detail, whereas we just touched upon some
    others. Many of these topics are too broad to be contained in one chapter. Some
    of these topics can have a complete book dedicated to them. That's why, I provided
    different URLs towards learning material or suggested reading, which you can refer
    to if you are interested.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的重点是PHP7中的RESTful Web服务，我们还研究了与构建RESTful Web服务或PHP7相关的其他主题。我们详细研究了其中一些主题，而其他一些只是触及了一下。许多这些主题太广泛，无法包含在一个章节中。其中一些主题可以有一本专门的书来专门讨论。这就是为什么我提供了不同的URL以供学习材料或建议阅读，如果你感兴趣的话可以参考。
- en: What's next
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来
- en: 'There are two important things:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件重要的事情：
- en: '**Practice:**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**实践：**'
- en: Actual learning starts when you start practicing something. When you practice,
    you sometimes face problems and learn more, which you couldn't learn without solving
    those problems.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的学习是当你开始实践某些东西时才开始的。当你实践时，有时会遇到问题并学到更多，这是你在没有解决这些问题的情况下无法学到的。
- en: '**Looking into suggested material:**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**查阅建议的材料：**'
- en: Wherever I have provided suggested reading, pause there and at least have a
    look at the suggested material. If you find it helpful, feel free to dig deeper
    into it. Who knows, that suggested material might teach you something even more
    valuable to you than this entire book. After all, that material provides much
    more detail than we have discussed in this book.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我提供了什么建议阅读材料，都请停下来至少看一下建议的材料。如果你觉得有帮助，可以深入了解。谁知道，那些建议的材料可能会教会你比整本书更有价值的东西。毕竟，那些材料提供了比我们在本书中讨论的更多细节。
