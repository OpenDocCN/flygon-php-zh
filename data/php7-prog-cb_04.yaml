- en: Chapter 4. Working with PHP Object-Oriented Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 使用PHP面向对象编程
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们将涵盖：
- en: Developing classes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发类
- en: Extending classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展类
- en: Using static properties and methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态属性和方法
- en: Using namespaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名空间
- en: Defining visibility
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义可见性
- en: Using interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口
- en: Using traits
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用traits
- en: Implementing anonymous classes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现匿名类
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will consider recipes that take advantage of the **object-oriented
    programming** (**OOP**) capabilities available in PHP 7.0, 7.1, and above. Most
    of the OOP functionality available in PHP 7.x is also available in PHP 5.6\. A
    new feature introduced in PHP 7 is support for **anonymous classes**. In PHP 7.1,
    you can modify the visibility of class constants.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将考虑利用PHP 7.0、7.1及以上版本中可用的**面向对象编程**（**OOP**）功能的相关内容。PHP 7.x中大部分的OOP功能也适用于PHP
    5.6。PHP 7引入的新功能是支持**匿名类**。在PHP 7.1中，您可以修改类常量的可见性。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Another radically new feature is the ability to **catch** certain types of error.
    This is discussed in greater detail in [Chapter 13](ch13.html "Chapter 13. Best
    Practices, Testing, and Debugging"), *Best Practices, Testing, and Debugging*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个全新的功能是**捕获**某些类型的错误。这在[第13章](ch13.html "第13章.最佳实践、测试和调试")*最佳实践、测试和调试*中更详细地讨论。
- en: Developing classes
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发类
- en: The traditional development approach is to place the class into its own file.
    Typically, classes contain logic that implements a single purpose. Classes are
    further broken down into self-contained functions which are referred to as **methods**.
    Variables defined inside classes are referred to as **properties**. It is recommended
    to develop a test class at the same time, a topic discussed in more detail in
    [Chapter 13](ch13.html "Chapter 13. Best Practices, Testing, and Debugging"),
    *Best Practices, Testing, and Debugging*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的开发方法是将类放入自己的文件中。通常，类包含实现单一目的的逻辑。类进一步分解为自包含的函数，这些函数被称为**方法**。在类内定义的变量被称为**属性**。建议同时开发一个测试类，这是在[第13章](ch13.html
    "第13章.最佳实践、测试和调试")*最佳实践、测试和调试*中更详细讨论的主题。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a file to contain the class definition. For the purposes of autoloading
    it is recommended that the filename match the classname. At the top of the file,
    before the keyword `class`, add a **DocBlock**. You can then define properties
    and methods. In this example, we define a class `Test`. It has a property `$test`,
    and a method `getTest()`:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文件来包含类定义。为了自动加载的目的，建议文件名与类名匹配。在文件顶部，在关键字`class`之前，添加一个**DocBlock**。然后您可以定义属性和方法。在这个例子中，我们定义了一个类`Test`。它有一个属性`$test`和一个方法`getTest()`：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: It is considered best practice to name the file after the class. Although class
    names in PHP are not case sensitive, it is further considered best practice to
    use an uppercase letter for the first name of a class. You should not put executable
    code in a class definition file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件命名为类名被认为是最佳实践。虽然PHP中的类名不区分大小写，但进一步被认为是最佳实践的是使用大写字母作为类名的第一个字母。您不应该在类定义文件中放置可执行代码。
- en: Each class should contain a **DocBlock** before the keyword `class`. In the
    DocBlock you should include a short description of the purpose of the class. Skip
    a line, and then include a more detailed description. You can also include `@`
    tags such as `@author`, `@license` and so on. Each method should likewise be preceded
    by a DocBlock that identifies the purpose of the method, as well as its incoming
    parameters and return value.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都应该在关键字`class`之前包含一个**DocBlock**。在DocBlock中，您应该包括一个关于类目的简短描述。空一行，然后包括更详细的描述。您还可以包括`@`标签，如`@author`、`@license`等。每个方法也应该在之前包含一个标识方法目的的DocBlock，以及它的传入参数和返回值。
- en: 'It''s possible to define more than one class per file, but is not considered
    best practice. In this example we create a file, `NameAddress.php`, which defines
    two classes, `Name` and `Address`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在一个文件中定义多个类，但这不被认为是最佳实践。在这个例子中，我们创建一个文件`NameAddress.php`，其中定义了两个类，`Name`和`Address`：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Although you can define more than one class in a single file, as shown in the
    preceding code snippet, it is not considered best practice. Not only does this
    negate the logical purity of the file, but it makes autoloading more difficult.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以在单个文件中定义多个类，如前面的代码片段所示，但这并不被认为是最佳实践。这不仅会使文件的逻辑纯度降低，而且会使自动加载变得更加困难。
- en: 'Class names are case-insensitive. Duplications will be flagged as errors. In
    this example, in a file `TwoClass.php`, we define two classes, `TwoClass` and
    `twoclass`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类名不区分大小写。重复将被标记为错误。在这个例子中，在一个名为`TwoClass.php`的文件中，我们定义了两个类，`TwoClass`和`twoclass`：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'PHP 7.1 has addressed inconsistent behavior in the use of the keyword `$this`.
    Although permitted in PHP 7.0 and PHP 5.x, any of the following uses of `$this`
    will now generate an error as of PHP 7.1, if `$this` is used as:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PHP 7.1已解决了在使用关键字`$this`时的不一致行为。虽然在PHP 7.0和PHP 5.x中允许使用，但在PHP 7.1中，如果`$this`被用作：
- en: A parameter
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个参数
- en: A `static` variable
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`static`变量
- en: A `global` variable
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`global`变量
- en: A variable used in `try...catch` blocks
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`try...catch`块中使用的变量
- en: A variable used in `foreach()`
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`foreach()`中使用的变量
- en: As an argument to `unset()`
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为`unset()`的参数
- en: As a variable (that is, `$a = 'this'; echo $$a`)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个变量（即，`$a = 'this'; echo $$a`）
- en: Indirectly via reference
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引用间接使用
- en: 'If you need to create an object instance but don''t care to define a discreet
    class, you can use the generic `stdClass` which is built into PHP. `stdClass`
    allows you to define properties *on the fly* without having to define a discreet
    class that extends `stdClass`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您需要创建一个对象实例，但不想定义一个离散的类，您可以使用内置于PHP中的通用`stdClass`。`stdClass`允许您在不必定义一个扩展`stdClass`的离散类的情况下*即兴*定义属性：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This facility is used in a number of different places in PHP. As an example,
    when you use **PHP Data Objects** (**PDO**) to do a database query, one of the
    fetch modes is `PDO::FETCH_OBJ`. This mode returns instances of `stdClass` where
    the properties represent database table columns:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个功能在PHP的许多不同地方使用。例如，当您使用**PHP数据对象**（**PDO**）来进行数据库查询时，其中的一个获取模式是`PDO::FETCH_OBJ`。这种模式返回`stdClass`的实例，其中的属性代表数据库表列：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Take the example for the `Test` class shown in the preceding code snippet,
    and place the code in a file named `Test.php`. Create another file called `chap_04_oop_defining_class_test.php`.
    Add the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 取出前面代码片段中的`Test`类的例子，并将代码放入一个名为`Test.php`的文件中。创建另一个名为`chap_04_oop_defining_class_test.php`的文件。添加以下代码：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output will show the initial value of the `$test` property, followed by
    the new value modified by calling `setTest()`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示`$test`属性的初始值，然后通过调用`setTest()`修改的新值：
- en: '![How it works...](graphics/B05314_04_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_01.jpg)'
- en: 'The next example has you define two classes, `Name` and `Address` in a single
    file `NameAddress.php`. You can call and use these two classes with the following
    code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子让您在一个名为`NameAddress.php`的单个文件中定义两个类，`Name`和`Address`。您可以使用以下代码调用和使用这两个类：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although no errors are generated by the PHP interpreter, by defining multiple
    classes, the logical purity of the file is compromised. Also, the filename doesn't
    match the classname, which could impact the ability to autoload.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然PHP解释器没有生成错误，但通过定义多个类，文件的逻辑纯度受到了损害。此外，文件名与类名不匹配，这可能会影响自动加载的能力。
- en: 'The output from this example is shown next:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的例子的输出如下所示：
- en: '![How it works...](graphics/B05314_04_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_02.jpg)'
- en: 'Step 3 also shows two class definitions in one file. In this case, however,
    the objective is to demonstrate that classnames in PHP are case-insensitive. Place
    the code into a file, `TwoClass.php`. When you try to include the file, an error
    is generated:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤3还展示了一个文件中的两个类定义。然而，在这种情况下，目标是演示PHP中的类名是不区分大小写的。将代码放入一个名为`TwoClass.php`的文件中。当您尝试包含该文件时，将生成一个错误：
- en: '![How it works...](graphics/B05314_04_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_03.jpg)'
- en: To demonstrate the direct use of `stdClass`, create an instance, assign a value
    to a property, and use `var_dump()`to display the results. To see how `stdClass`
    is used internally, use `var_dump()` to display the results of a `PDO` query where
    the fetch mode is set to `FETCH_OBJ`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示直接使用`stdClass`，创建一个实例，为属性赋值，并使用`var_dump()`来显示结果。要查看`stdClass`在内部的使用方式，使用`var_dump()`来显示`PDO`查询的结果，其中获取模式设置为`FETCH_OBJ`。
- en: 'Enter the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![How it works...](graphics/B05314_04_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_04.jpg)'
- en: See also...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见...
- en: For more information on refinements in PHP 7.1 on the keyword `$this`, please
    see [https://wiki.php.net/rfc/this_var](https://wiki.php.net/rfc/this_var).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PHP 7.1中关键字`$this`的改进的更多信息，请参阅[https://wiki.php.net/rfc/this_var](https://wiki.php.net/rfc/this_var)。
- en: Extending classes
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展类
- en: One of the primary reasons developers use OOP is because of its ability to re-use
    existing code, yet, at the same time, add or override functionality. In PHP, the
    keyword `extends` is used to establish a parent/child relationship between classes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员使用OOP的主要原因之一是因为它能够重用现有的代码，同时又能够添加或覆盖功能。在PHP中，关键字`extends`用于在类之间建立父/子关系。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the `child` class, use the keyword `extends` to set up inheritance. In the
    example that follows, the `Customer` class extends the `Base` class. Any instance
    of `Customer` will inherit visible methods and properties, in this case, `$id`,
    `getId()` and `setId()`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`child`类中，使用关键字`extends`来建立继承关系。在接下来的例子中，`Customer`类扩展了`Base`类。`Customer`的任何实例都将继承可见的方法和属性，这里是`$id`，`getId()`和`setId()`：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can force any developer using your class to define a method by marking
    it `abstract`. In this example, the `Base` class defines as `abstract` the `validate()`
    method. The reason why it must be abstract is because it would be impossible to
    determine exactly how a child class would be validated from the perspective of
    the parent `Base` class:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过将其标记为`abstract`来强制任何使用您的类的开发人员定义一个方法。在这个例子中，`Base`类将`validate()`方法定义为`abstract`。它必须是抽象的原因是因为从父类`Base`的角度来确定子类如何被验证是不可能的：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If a class contains an **abstract method**, the class itself must be declared
    as `abstract`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类包含一个**抽象方法**，那么这个类本身必须声明为`abstract`。
- en: 'PHP only supports a single line of inheritance. The next example shows a class,
    `Member`, which inherits from `Customer`. `Customer`, in turn, inherits from `Base`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PHP只支持单一继承线。下一个例子展示了一个名为`Member`的类，它从`Customer`继承。`Customer`又从`Base`继承：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To satisfy a type-hint, any child of the target class can be used. The `test()`
    function, shown in the following code snippet, requires an instance of the `Base`
    class as an argument. Any class within the line of inheritance can be accepted
    as an argument. Anything else passed to `test()` throws a `TypeError`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了满足类型提示，目标类的任何子类都可以使用。下面的代码片段中显示的`test()`函数需要`Base`类的一个实例作为参数。继承线中的任何类都可以被接受为参数。传递给`test()`的任何其他内容都会引发`TypeError`：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the first bullet point, a `Base` class and a `Customer` class were defined.
    For the sake of demonstration, place these two class definitions in a single file,
    `chap_04_oop_extends.php`, and add the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个要点中，定义了一个`Base`类和一个`Customer`类。为了演示，将这两个类定义放入一个名为`chap_04_oop_extends.php`的单个文件中，并添加以下代码：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that the `$id` property and the `getId()` and `setId()` methods are inherited
    from the parent `Base` class into the child `Customer` class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`$id`属性和`getId()`和`setId()`方法从父类`Base`继承到子类`Customer`：
- en: '![How it works...](graphics/B05314_04_06.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_06.jpg)'
- en: To illustrate the use of an `abstract` method, imagine that you wish to add
    some sort of validation capability to any class that extends `Base`. The problem
    is that there is no way to know what might be validated in the inherited classes.
    The only thing that is certain is that you must have a validation capability.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`abstract`方法的使用，想象一下你希望为任何扩展`Base`的类添加某种验证能力。问题是不知道在继承类中可能会验证什么。唯一确定的是你必须有验证能力。
- en: Take the same `Base` class mentioned in the preceding explanation and add a
    new method, `validate()`. Label the method as `abstract`, and do not define any
    code. Notice what happens when the child `Customer` class extends `Base`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面解释中提到的相同的`Base`类，并添加一个新的方法`validate()`。将该方法标记为`abstract`，不定义任何代码。注意当子`Customer`类扩展`Base`时会发生什么。
- en: '![How it works...](graphics/B05314_04_07.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_07.jpg)'
- en: 'If you then label the `Base` class as `abstract`, but fail to define a `validate()`
    method in the child class, the *same error* will be generated. Finally, go ahead
    and implement the `validate()` method in a child `Customer` class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`Base`类标记为`abstract`，但未在子类中定义`validate()`方法，将生成*相同的错误*。最后，继续在子`Customer`类中实现`validate()`方法：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can then add the following procedural code to test the results:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以添加以下过程代码来测试结果：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '![How it works...](graphics/B05314_04_08.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_08.jpg)'
- en: 'To show a single line of inheritance, add a new `Member` class to the first
    example of `Base` and `Customer` shown in the preceding step 1:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 展示单行继承，将一个新的`Member`类添加到前面步骤1中显示的`Base`和`Customer`的第一个示例中：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create an instance of `Member`, and notice, in the following code, that all
    properties and methods are available from every inherited class, even if not directly
    inherited:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`Member`的实例，并注意在下面的代码中，所有属性和方法都可以从每个继承的类中使用，即使不是直接继承的。
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is the output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '![How it works...](graphics/B05314_04_09.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_09.jpg)'
- en: 'Now define a function, `test()`, which takes an instance of `Base` as an argument:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在定义一个名为`test()`的函数，该函数以`Base`的实例作为参数：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Notice that instances of `Base`, `Customer`, and `Member` are all acceptable
    as arguments:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Base`，`Customer`和`Member`的实例都是可以接受的参数：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '![How it works...](graphics/B05314_04_10.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_10.jpg)'
- en: 'However, if you try to run `test()` with an object instance that is not in
    the line of inheritance, a `TypeError` is thrown:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试使用不在继承线上的对象实例运行`test()`，将抛出一个`TypeError`：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can observe this in the following image:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在下面的图片中观察到这一点：
- en: '![How it works...](graphics/B05314_04_11.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_11.jpg)'
- en: Using static properties and methods
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态属性和方法
- en: PHP lets you access properties or methods without having to create an instance
    of the class. The keyword used for this purpose is **static**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: PHP允许你访问属性或方法，而不必创建类的实例。用于此目的的关键字是**static**。
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'At its simplest, simply add the `static` keyword after stating the visibility
    level when declaring an ordinary property or method. Use the `self` keyword to
    reference the property internally:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最简单的方法是在声明普通属性或方法时，在声明可见级别后添加`static`关键字。使用`self`关键字在内部引用属性：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `self` keyword will bind early, which will cause problems when accessing
    static information in child classes. If you absolutely need to access information
    from the child class, use the `static` keyword in place of `self`. This process
    is referred to as **Late Static Binding**.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`self`关键字将会提前绑定，这会在访问子类中的静态信息时造成问题。如果你绝对需要访问子类的信息，使用`static`关键字代替`self`。这个过程被称为**后期静态绑定**。'
- en: 'In the following example, if you echo `Child::getEarlyTest()`, the output will
    be **TEST**. If, on the other hand, you run `Child::getLateTest()`, the output
    will be **CHILD**. The reason is that PHP will bind to the *earliest* definition
    when using `self`, whereas the *latest* binding is used for the `static` keyword:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的示例中，如果你输出`Child::getEarlyTest()`，输出将是**TEST**。另一方面，如果你运行`Child::getLateTest()`，输出将是**CHILD**。原因是当使用`self`时，PHP将绑定到*最早*的定义，而对于`static`关键字，将使用*最新*的绑定：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In many cases, the **Factory** design pattern is used in conjunction with static
    methods to produce instances of objects given different parameters. In this example,
    a static method `factory()` is defined which returns a PDO connection:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在许多情况下，**工厂**设计模式与静态方法一起使用，以根据不同的参数生成对象的实例。在这个例子中，定义了一个静态方法`factory()`，它返回一个PDO连接：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You can reference static properties and methods using the **class resolution
    operator** "`::"`. Given the `Test` class shown previously, if you run this code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**类解析运算符**"`::"`来引用静态属性和方法。给定之前显示的`Test`类，如果你运行这段代码：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You will see this output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这个输出：
- en: '![How it works...](graphics/B05314_04_13.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_13.jpg)'
- en: 'To illustrate Late Static Binding, based on the classes `Test2` and `Child`
    shown previously, try this code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明后期静态绑定，基于之前显示的`Test2`和`Child`类，尝试这段代码：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output illustrates the difference between `self` and `static`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 输出说明了`self`和`static`之间的区别。
- en: '![How it works...](graphics/B05314_04_14.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_14.jpg)'
- en: 'Finally, to test the `factory()` method shown previously, save the code into
    the `Application\Database\Connection` class in a `Connection.php` file in the
    `Application\Database` folder. You can then try this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了测试之前显示的`factory()`方法，将代码保存到`Application\Database\Connection`类中，保存在`Application\Database`文件夹中的`Connection.php`文件中。然后你可以尝试这样做：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You will see a list of countries pulled from the sample database:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到从示例数据库中提取的国家列表：
- en: '![How it works...](graphics/B05314_04_15.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_15.jpg)'
- en: See also
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information on Late Static Binding, see this explanation in the PHP
    documentation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有关后期静态绑定的更多信息，请参阅PHP文档中的解释：
- en: '[http://php.net/manual/en/language.oop5.late-static-bindings.php](http://php.net/manual/en/language.oop5.late-static-bindings.php)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://php.net/manual/en/language.oop5.late-static-bindings.php](http://php.net/manual/en/language.oop5.late-static-bindings.php)'
- en: Using namespaces
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命名空间
- en: An aspect that is critical to advanced PHP development is the use of namespaces.
    The arbitrarily defined namespace becomes a prefix to the class name, thereby
    avoiding the problem of accidental class duplication, and allowing you extraordinary
    freedom of development. Another benefit to the use of a namespace, assuming it
    matches the directory structure, is that it facilitates autoloading, as discussed
    in [Chapter 1](ch01.html "Chapter 1. Building a Foundation"), *Building a Foundation*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级PHP开发来说，关键的一点是使用命名空间。任意定义的命名空间成为类名的前缀，从而避免了意外类重复的问题，并允许您在开发中拥有非凡的自由度。另一个使用命名空间的好处是，假设它与目录结构匹配，它可以促进自动加载，如[第1章](ch01.html
    "第1章。构建基础")中所讨论的*构建基础*。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'To define a class within a namespace, simply add the keyword `namespace` at
    the top of the code file:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在命名空间中定义一个类，只需在代码文件顶部添加关键字`namespace`：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Best practice**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: As with the recommendation to have only one class per file, likewise you should
    have only one namespace per file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个文件只有一个类的建议类似，您应该每个文件只有一个命名空间。
- en: 'The only PHP code that should precede the keyword `namespace` would be a comment
    and/or the keyword `declare`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关键字`namespace`之前应该只有一个注释和/或关键字`declare`。
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In PHP 5, if you needed to access a class in an external namespace you could
    prepend a `use` statement containing only the namespace. You would need to then
    prefix any class reference within this namespace with the last component of the
    namespace:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PHP 5中，如果您需要访问外部命名空间中的类，可以添加一个只包含命名空间的`use`语句。然后，您需要使用命名空间的最后一个组件作为前缀来引用该命名空间内的任何类：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, you could distinctly specify all three classes:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您可以明确指定所有三个类：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'PHP 7 has introduced a syntactical improvement referred to as **group use**
    which greatly improves code readability:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PHP 7引入了一种称为**group use**的语法改进，大大提高了代码的可读性：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As mentioned in [Chapter 1](ch01.html "Chapter 1. Building a Foundation"),
    *Building a Foundation*, namespaces form an integral part of the **autoloading**
    process. This example shows a demonstration autoloader which echoes the argument
    passed, and then attempts to include a file based on the namespace and class name.
    This assumes that the directory structure matches the namespace:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如[第1章](ch01.html "第1章。构建基础")中所述，*构建基础*，命名空间是**自动加载**过程的一个组成部分。此示例显示了一个演示自动加载程序，它会回显传递的参数，然后尝试根据命名空间和类名包含一个文件。这假设目录结构与命名空间匹配：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'For illustration purposes, define a directory structure that matches the `Application\*`
    namespace. Create a base folder `Application`, and a sub-folder `Entity`. You
    can also include any sub-folders as desired, such as `Database` and `Generic`,
    used in other chapters:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，定义一个与`Application\*`命名空间匹配的目录结构。创建一个基础文件夹`Application`，以及一个子文件夹`Entity`。您还可以根据需要包含任何其他章节中使用的子文件夹，比如`Database`和`Generic`：
- en: '![How it works...](graphics/B05314_04_16.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_04_16.jpg)'
- en: 'Next, create three `entity` classes, each in their own file, under the `Application/Entity`
    folder: `Name.php`, `Address.php`, and `Profile.php`. We only show `Application\Entity\Name`
    here. `Application\Entity\Address` and `Application\Entity\Profile` will be the
    same, except that `Address` has an `$address` property, and `Profile` has a `$profile`
    property, each with an appropriate `get` and `set` method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`Application/Entity`文件夹下分别创建三个`entity`类，每个类都在自己的文件中：`Name.php`，`Address.php`和`Profile.php`。这里只展示`Application\Entity\Name`。`Application\Entity\Address`和`Application\Entity\Profile`将是相同的，只是`Address`有一个`$address`属性，而`Profile`有一个`$profile`属性，每个属性都有适当的`get`和`set`方法：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can then either use the autoloader defined in [Chapter 1](ch01.html "Chapter 1. Building
    a Foundation"), *Building a Foundation*, or use the simple autoloader mentioned
    previously. Place the commands to set up autoloading in a file, `chap_04_oop_namespace_example_1.php`.
    In this file, you can then specify a use statement which only references the namespace,
    not the class names. Create instances of the three entity classes `Name`, `Address`
    and `Profile`, by prefixing the class name with the last part of the namespace,
    `Entity`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用[第1章](ch01.html "第1章。构建基础")中定义的自动加载程序，或者使用之前提到的简单自动加载程序。将设置自动加载的命令放在一个文件`chap_04_oop_namespace_example_1.php`中。在此文件中，您可以指定一个`use`语句，只引用命名空间，而不是类名。通过使用命名空间的最后一部分`Entity`作为类名的前缀，创建三个实体类`Name`，`Address`和`Profile`的实例：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here is the output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![How it works...](graphics/B05314_04_17.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_04_17.jpg)'
- en: 'Next, use **Save as** to copy the file to a new one named `chap_04_oop_namespace_example_2.php`.
    Change the `use` statement to the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用**另存为**将文件复制到一个名为`chap_04_oop_namespace_example_2.php`的新文件中。将`use`语句更改为以下内容：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can now create class instances using only the class name:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以仅使用类名创建类实例：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When you run this script, here is the output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此脚本时，输出如下：
- en: '![How it works...](graphics/B05314_04_18.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_04_18.jpg)'
- en: 'Finally, again run **Save as** and create a new file, `chap_04_oop_namespace_example_3.php`.
    You can now test the **group use** feature introduced in PHP 7:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，再次使用**另存为**创建一个新文件`chap_04_oop_namespace_example_3.php`。您现在可以测试PHP 7中引入的**group
    use**功能：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Again, when you run this block of code, the output will be the same as the
    preceding output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当您运行此代码块时，输出将与前面的输出相同：
- en: '![How it works...](graphics/B05314_04_19.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_04_19.jpg)'
- en: Defining visibility
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义可见性
- en: Deceptively, the word *visibility* has nothing to do with application security!
    Instead it is simply a mechanism to control the use of your code. It can be used
    to steer an inexperienced developer away from the *public* use of methods that
    should only be called inside the class definition.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 欺骗地，*可见性*一词与应用程序安全无关！相反，它只是一种控制代码使用的机制。它可以用来引导经验不足的开发人员远离应该仅在类定义内部调用的方法的*public*使用。
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Indicate the visibility level by prepending the `public`, `protected`, or `private`
    keyword in front of any property or method definition. You can label properties
    as `protected` or `private` to enforce access only through public `getters` and
    `setters`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在任何属性或方法定义的前面添加“public”、“protected”或“private”关键字来指示可见性级别。您可以将属性标记为“protected”或“private”，以强制仅通过公共“getter”和“setter”访问。
- en: In this example, a `Base` class is defined with a protected property `$id`.
    In order to access this property, the `getId()` and `setId()` public methods are
    defined. The protected method `generateRandId()` can be used internally, and is
    inherited in the `Customer` child class. This method cannot be called directly
    outside of class definitions. Note the use of the new PHP 7 `random_bytes()` function
    to create a random ID.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此示例中，定义了一个带有受保护属性“$id”的“Base”类。为了访问此属性，定义了“getId（）”和“setId（）”公共方法。受保护方法“generateRandId（）”可以在内部使用，并且在“Customer”子类中继承。此方法不能直接在类定义之外调用。请注意使用新的PHP
    7“random_bytes（）”函数创建随机ID。
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Best practice**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Mark properties as `protected`, and define the `publicgetNameOfProperty()` and
    `setNameOfProperty()` methods to control access to the property. Such methods
    are referred to as `getters` and `setters`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将属性标记为“protected”，并定义“publicgetNameOfProperty（）”和“setNameOfProperty（）”方法来控制对属性的访问。这些方法被称为“getter”和“setter”。
- en: Mark a property or method as `private` to prevent it from being inherited or
    visible from *outside* the class definition. This is a good way to create a class
    as a **singleton**.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将属性或方法标记为“private”以防止其被继承或从类定义之外可见。这是创建类作为**单例**的好方法。
- en: 'The next code example shows a class `Registry`, of which there can only be
    one instance. Because the constructor is marked as `private`, the only way an
    instance can be created is through the static method `getInstance()`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个代码示例显示了一个名为“Registry”的类，其中只能有一个实例。因为构造函数标记为“private”，所以唯一可以创建实例的方法是通过静态方法“getInstance（）”：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can mark a method as `final` to prevent it from being overridden. Mark a
    class as `final` to prevent it from being extended.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将方法标记为“final”以防止其被覆盖。将类标记为“final”以防止其被扩展。
- en: 'Normally, class constants are considered to have a visibility level of `public`.
    As of PHP 7.1, you can declare class constants to be `protected` or `private`.
    In the following example, the `TEST_WHOLE_WORLD` class constant behaves exactly
    as in PHP 5\. The next two constants, `TEST_INHERITED` and `TEST_LOCAL`, follow
    the same rules as any `protected` or `private` property or method:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，类常量被认为具有“public”的可见性级别。从PHP 7.1开始，您可以将类常量声明为“protected”或“private”。在以下示例中，“TEST_WHOLE_WORLD”类常量的行为与PHP
    5中完全相同。接下来的两个常量，“TEST_INHERITED”和“TEST_LOCAL”，遵循与任何“protected”或“private”属性或方法相同的规则：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Create a file `chap_04_basic_visibility.php` and define two classes: `Base`
    and `Customer`. Next, write code to create instances of each:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为“chap_04_basic_visibility.php”的文件，并定义两个类：“Base”和“Customer”。接下来，编写代码以创建每个实例：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Notice that the following code works OK, and is in fact considered the best
    practice:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下代码可以正常工作，并且实际上被认为是最佳实践：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Even though `$id` is `protected`, the corresponding methods, `getId()` and
    `setId()`, are both `public`, and therefore accessible from outside the class
    definition. Here is the output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管“$id”是“protected”，但相应的方法“getId（）”和“setId（）”都是“public”，因此可以从类定义外部访问。以下是输出：
- en: '![How it works...](graphics/B05314_04_20.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_20.jpg)'
- en: 'The following lines of code will not work, however, as `private` and `protected`
    properties are not accessible from outside the class definition:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下代码行将无法工作，因为“private”和“protected”属性无法从类定义之外访问：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following output shows the expected errors:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了预期的错误：
- en: '![How it works...](graphics/B05314_04_21.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_21.jpg)'
- en: See also
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information on `getters` and `setters`, see the recipe in this chapter
    entitled *Using getters and setters*. For more information on PHP 7.1 class constant
    visibility settings, please see [https://wiki.php.net/rfc/class_const_visibility](https://wiki.php.net/rfc/class_const_visibility).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有关“getter”和“setter”的更多信息，请参见本章中标题为“使用getter和setter”的配方。有关PHP 7.1类常量可见性设置的更多信息，请参见[https://wiki.php.net/rfc/class_const_visibility](https://wiki.php.net/rfc/class_const_visibility)。
- en: Using interfaces
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用接口
- en: Interfaces are useful tools for systems architects and are often used to prototype
    an **Application Programming Interface** (**API**). Interfaces don't contain actual
    code, but can contain names of methods as well as method signatures.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是系统架构师的有用工具，通常用于原型设计**应用程序编程接口**（**API**）。接口不包含实际代码，但可以包含方法的名称以及方法签名。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All methods identified in the `Interface` have a visibility level of `public`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在“接口”中标识的方法都具有“public”的可见性级别。
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Methods identified by the interface cannot contain actual code implementations.
    You can, however, specify the data types of method arguments.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由接口标识的方法不能包含实际代码实现。但是，您可以指定方法参数的数据类型。
- en: 'In this example, `ConnectionAwareInterface` identifies a method, `setConnection()`,
    which requires an instance of `Connection` as an argument:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此示例中，“ConnectionAwareInterface”标识了一个方法“setConnection（）”，该方法需要一个“Connection”的实例作为参数：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To use the interface, add the keyword `implements` after the open line that
    defines the class. We have defined two classes, `CountryList` and `CustomerList`,
    both of which require access to the `Connection` class via a method, `setConnection()`.
    In order to identify this dependency, both classes implement `ConnectionAwareInterface`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用接口，请在定义类的开放行之后添加关键字`implements`。我们定义了两个类，`CountryList`和`CustomerList`，它们都需要通过`setConnection()`方法访问`Connection`类。为了识别这种依赖关系，这两个类都实现了`ConnectionAwareInterface`：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Interfaces can be used to satisfy a type hint. The following class, `ListFactory`,
    contains a `factory()` method, which initializes any class that implements `ConnectionAwareInterface`.
    The interface is a guarantee that the `setConnection()` method is defined. Setting
    the type hint to the interface instead of a specific class instance makes the
    `factory` method more generically useful:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口可用于满足类型提示。以下类`ListFactory`包含一个`factory()`方法，该方法初始化任何实现`ConnectionAwareInterface`的类。接口是`setConnection()`方法被定义的保证。将类型提示设置为接口而不是特定类实例使`factory`方法更通用：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If a class implements multiple interfaces, a **naming collision** occurs if
    method signatures do not match. In this example, there are two interfaces, `DateAware`
    and `TimeAware`. In addition to defining the `setDate()` and `setTime()` methods,
    they both define `setBoth()`. Having duplicate method names is not an issue, although
    it is not considered best practice. The problem lies in the fact that the method
    signatures differ:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个类实现多个接口，如果方法签名不匹配，则会发生**命名冲突**。在这个例子中，有两个接口，`DateAware`和`TimeAware`。除了定义`setDate()`和`setTime()`方法之外，它们都定义了`setBoth()`。具有重复的方法名称不是问题，尽管这不被认为是最佳实践。问题在于方法签名不同：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As the code block stands, a fatal error will be generated (which cannot be caught!).
    To resolve the problem, the preferred approach would be to remove the definition
    of `setBoth()` from one or the other interface. Alternatively, you could adjust
    the method signatures to match.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码块的当前状态将生成致命错误（无法捕获！）。要解决问题，首选方法是从一个接口中删除`setBoth()`的定义。或者，您可以调整方法签名以匹配。
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Best practice**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Do not define interfaces with duplicate or overlapping method definitions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 不要定义具有重复或重叠方法定义的接口。
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `Application/Database` folder, create a file, `ConnectionAwareInterface.php`.
    Insert the code discussed in the preceding step 2.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Application/Database`文件夹中，创建一个文件`ConnectionAwareInterface.php`。插入前面步骤2中讨论的代码。
- en: Next, in the `Application/Generic` folder, create two files, `CountryList.php`
    and `CustomerList.php`. Insert the code discussed in step 3.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`Application/Generic`文件夹中，创建两个文件，`CountryList.php`和`CustomerList.php`。插入步骤3中讨论的代码。
- en: 'Next, in a directory parallel to the `Application` directory, create a source
    code file, `chap_04_oop_simple_interfaces_example.php`, which initializes the
    autoloader and includes the database parameters:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在与`Application`目录平行的目录中，创建一个源代码文件`chap_04_oop_simple_interfaces_example.php`，该文件初始化自动加载程序并包含数据库参数：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The database parameters in this example are assumed to be in a database configuration
    file indicated by the `DB_CONFIG_FILE` constant.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，假定数据库参数在由`DB_CONFIG_FILE`常量指示的数据库配置文件中。
- en: 'You are now in a position to use `ListFactory::factory()` to generate `CountryList`
    and `CustomerList` objects. Note that if these classes did not implement `ConnectionAwareInterface`,
    an error would be thrown:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`ListFactory::factory()`生成`CountryList`和`CustomerList`对象。请注意，如果这些类没有实现`ConnectionAwareInterface`，将会抛出错误：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here is the output for country list:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是国家列表的输出：
- en: '![How it works...](graphics/B05314_04_22.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_22.jpg)'
- en: 'You can also use the `factory` method to generate a `CustomerList` object and
    use it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`factory`方法生成`CustomerList`对象并使用它：
- en: '[PRE49]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here is the output for `CustomerList`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`CustomerList`的输出：
- en: '![How it works...](graphics/B05314_04_23.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_23.jpg)'
- en: 'If you want to examine what happens when multiple interfaces are implemented,
    but where the method signature differs, enter the code shown in the preceding
    step 4 into a file, `chap_04_oop_interfaces_collisions.php`. When you try to run
    the file, an error is generated, as shown here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要检查实现多个接口但方法签名不同的情况发生了什么，请将步骤4中显示的代码输入到文件`chap_04_oop_interfaces_collisions.php`中。当您尝试运行该文件时，将生成错误，如下所示：
- en: '![How it works...](graphics/B05314_04_24.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_24.jpg)'
- en: 'If you make the following adjustment in the `TimeAware` interface, no errors
    will result:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在`TimeAware`接口中进行以下调整，将不会产生错误：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Using traits
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用特征
- en: If you have ever done any C programming, you are perhaps familiar with macros.
    A macro is a predefined block of code that *expands* at the line indicated. In
    a similar manner, traits can contain blocks of code that are copied and pasted
    into a class at the line indicated by the PHP interpreter.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经进行过C编程，您可能熟悉宏。宏是预定义的代码块，在指定的行处*展开*。类似地，特征可以包含代码块，在PHP解释器指定的行处复制并粘贴到类中。
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Traits are identified with the keyword `trait`, and can contain properties and/or
    methods. You may have noticed duplication of code when examining the previous
    recipe featuring the `CountryList` and `CustomerList` classes. In this example,
    we will re-factor the two classes, and move the functionality of the `list()`
    method into a `Trait`. Notice that the `list()` method is the same in both classes.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特征用关键字`trait`标识，可以包含属性和/或方法。在上一个示例中，当检查`CountryList`和`CustomerList`类时，您可能已经注意到代码的重复。在这个例子中，我们将重构这两个类，并将`list()`方法的功能移入`Trait`。请注意，`list()`方法在两个类中是相同的。
- en: Traits are used in situations where there is duplication of code between classes.
    Please note, however, that the conventional approach to creating an abstract class
    and extending it might have certain advantages over using traits. Traits cannot
    be used to identify a line of inheritance, whereas abstract parent classes can
    be used for this purpose.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特征在类之间存在代码重复的情况下使用。然而，请注意，使用传统的创建抽象类并扩展它的方法可能比使用特征具有某些优势。特征不能用于标识继承线，而抽象父类可以用于此目的。
- en: 'We will now copy `list()` into a trait called `ListTrait`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将`list()`复制到一个名为`ListTrait`的特征中：
- en: '[PRE51]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can then insert the code from `ListTrait` into a new class, `CountryListUsingTrait`,
    as shown in the following code snippet. The entire `list()` method can now be
    removed from this class:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以将`ListTrait`中的代码插入到一个新的类`CountryListUsingTrait`中，如下面的代码片段所示。现在可以从这个类中删除整个`list()`方法：
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Any time you have duplication of code, a potential problem arises when you need
    to make a change. You might find yourself having to do too many global search
    and replace operations, or cutting and pasting of code, often with disastrous
    results. Traits are a great way to avoid this maintenance nightmare.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 每当存在代码重复时，当您需要进行更改时，可能会出现潜在问题。您可能会发现自己需要进行太多的全局搜索和替换操作，或者剪切和粘贴代码，通常会导致灾难性的结果。特征是避免这种维护噩梦的好方法。
- en: 'Traits are affected by namespaces. In the example shown in step 1, if our new
    `CountryListUsingTrait` class is placed into a namespace, `Application\Generic`,
    we will also need to move `ListTrait` into that namespace as well:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特征受命名空间的影响。在第1步中所示的示例中，如果我们的新`CountryListUsingTrait`类放置在一个名为`Application\Generic`的命名空间中，我们还需要将`ListTrait`移动到该命名空间中：
- en: '[PRE53]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Methods in traits override inherited methods.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特征中的方法会覆盖继承的方法。
- en: 'In the following example, you will notice that the return value for the `setId()`
    method differs between the `Base` parent class and the `Test` trait. The `Customer`
    class inherits from `Base`, but also uses `Test`. In this case, the method defined
    in the trait will override the method defined in the `Base` parent class:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的示例中，您会注意到`setId()`方法的返回值在`Base`父类和`Test`特征之间不同。`Customer`类继承自`Base`，但也使用`Test`。在这种情况下，特征中定义的方法将覆盖`Base`父类中定义的方法：
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In PHP 5, traits could also override properties. In PHP 7, if the property in
    a trait is initialized to a different value than in the parent class, a fatal
    error is generated.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 5中，特征也可以覆盖属性。在PHP 7中，如果特征中的属性初始化值与父类中的不同，将生成致命错误。
- en: Methods directly defined in the class that use the trait override duplicate
    methods defined in the trait.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中直接定义使用特征的方法会覆盖特征中定义的重复方法。
- en: 'In this example, the `Test` trait defines a property `$id` along with the `getId()`
    methods and `setId()`. The trait also defines `setName()`, which conflicts with
    the same method defined in the `Customer` class. In this case, the directly defined
    `setName()` method from `Customer` will override the `setName()` defined in the
    trait:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，`Test`特征定义了一个`$id`属性以及`getId()`方法和`setId()`。特征还定义了`setName()`，与`Customer`类中定义的相同方法冲突。在这种情况下，`Customer`中直接定义的`setName()`方法将覆盖特征中定义的`setName()`：
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Use the `insteadof` keywords to resolve method name conflicts when using multiple
    traits. In conjunction, use the `as` keyword to alias method names.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用多个特征时，使用`insteadof`关键字解决方法名称冲突。此外，使用`as`关键字为方法名称创建别名。
- en: 'In this example, there are two traits, `IdTrait` and `NameTrait`. Both traits
    define a `setKey()` method, but express the key in different ways. The `Test`
    class uses both traits. Note the `insteadof` keyword, which allows us to distinguish
    between the conflicting methods. Thus, when `setKey()` is called from the `Test`
    class, the source will be drawn from `NameTrait`. In addition, `setKey()` from
    `IdTrait` will still be available, but under an alias, `setKeyDate()`:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，有两个特征，`IdTrait`和`NameTrait`。两个特征都定义了一个`setKey()`方法，但是以不同的方式表示键。`Test`类使用了这两个特征。请注意`insteadof`关键字，它允许我们区分冲突的方法。因此，当从`Test`类调用`setKey()`时，源将来自`NameTrait`。此外，`IdTrait`中的`setKey()`仍然可用，但是在别名`setKeyDate()`下：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: From step 1, you learned that traits are used in situations where there is duplication
    of code. You need to gauge whether or not you could simply define a base class
    and extend it, or whether using a trait better serves your purposes. Traits are
    especially useful where the duplication of code is seen in logically unrelated
    classes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 从第1步中，您了解到特征在存在代码重复的情况下使用。您需要评估是否可以简单地定义一个基类并扩展它，或者使用特征更好地满足您的目的。特征在逻辑上不相关的类中看到代码重复时特别有用。
- en: 'To illustrate how trait methods override inherited methods, copy the block
    of code mentioned in step 7 into a separate file, `chap_04_oop_traits_override_inherited.php`.
    Add these lines of code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明特征方法如何覆盖继承的方法，请将第7步提到的代码块复制到一个单独的文件`chap_04_oop_traits_override_inherited.php`中。添加以下代码：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As you can see from the output (shown next), the property `$id` is stored as
    an instance of `stdClass()`, which is the behavior defined in the trait:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看到（如下所示），`$id`属性存储为`stdClass()`的实例，这是特征中定义的行为：
- en: '![How it works...](graphics/B05314_04_28.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_28.jpg)'
- en: 'To illustrate how directly defined class methods override trait methods, copy
    the block of code mentioned in step 9 into a separate file, `chap_04_oop_trait_methods_do_not_override_class_methods.php`.
    Add these lines of code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明直接定义的类方法如何覆盖特征方法，请将第9步提到的代码块复制到一个单独的文件`chap_04_oop_trait_methods_do_not_override_class_methods.php`中。添加以下代码：
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As you can see from the following output, the `$id` property is stored as an
    integer, as defined in the `Customer` class, whereas the trait defines `$id` as
    an instance of `stdClass`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从下面的输出中可以看到，`$id`属性存储为整数，如`Customer`类中定义的那样，而特征将`$id`定义为`stdClass`的实例：
- en: '![How it works...](graphics/B05314_04_29.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_29.jpg)'
- en: 'In step 10, you learned how to resolve duplicate method name conflicts when
    using multiple traits. Copy the block of code shown in step 11 into a separate
    file, `chap_04_oop_trait_multiple.php`. Add the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10步中，您学会了如何在使用多个特征时解决重复方法名称冲突。将步骤11中显示的代码块复制到一个单独的文件`chap_04_oop_trait_multiple.php`中。添加以下代码：
- en: '[PRE59]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Notice in the following output that `setKey()` yields the output produced from
    the new PHP 7 function, `random_bytes()` (defined in `NameTrait`), whereas `setKeyDate()`
    produces a key using the `date()` and `rand()` functions (defined in `IdTrait`):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在下面的输出中，`setKey()`产生了从新的PHP 7函数`random_bytes()`（在`NameTrait`中定义）产生的输出，而`setKeyDate()`使用`date()`和`rand()`函数（在`IdTrait`中定义）产生一个密钥：
- en: '![How it works...](graphics/B05314_04_30.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_30.jpg)'
- en: Implementing anonymous classes
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现匿名类
- en: PHP 7 introduced a new feature, **anonymous classes**. Much like anonymous functions,
    anonymous classes can be defined as part of an expression, creating a class that
    has no name. Anonymous classes are used in situations where you need to create
    an object *on the fly*, which is used and then discarded.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7引入了一个新特性，**匿名类**。就像匿名函数一样，匿名类可以作为表达式的一部分来定义，创建一个没有名称的类。匿名类用于需要*临时*创建并使用然后丢弃对象的情况。
- en: How to do it...
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: An alternative to `stdClass` is to define an anonymous class.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`stdClass`的替代方案是定义一个匿名类。
- en: 'In the definition, you can define any properties and methods (including magic
    methods). In this example, we define an anonymous class with two properties and
    a magic method, `__construct()`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义中，您可以定义任何属性和方法（包括魔术方法）。在这个例子中，我们定义了一个具有两个属性和一个魔术方法`__construct()`的匿名类：
- en: '[PRE60]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: An anonymous class can extend any class.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匿名类可以扩展任何类。
- en: 'In this example, an anonymous class extends `FilterIterator`, and overrides
    both the `__construct()` and `accept()` methods. As an argument, it accepts `ArrayIterator`
    `$b`, which represents an array of 10 to 100 in increments of 10\. The second
    argument serves as a limit on the output:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个匿名类扩展了`FilterIterator`，并覆盖了`__construct()`和`accept()`方法。作为参数，它接受了`ArrayIterator`
    `$b`，它代表了一个10到100的增量为10的数组。第二个参数作为输出的限制：
- en: '[PRE61]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: An anonymous class can implement an interface.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匿名类可以实现一个接口。
- en: 'In this example, an anonymous class is used to generate an HTML color code
    chart. The class implements the built-in PHP `Countable` interface. A `count()`
    method is defined, which is called when this class is used with a method or function
    that requires `Countable`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个匿名类用于生成HTML颜色代码图表。该类实现了内置的PHP `Countable`接口。定义了一个`count()`方法，当这个类与需要`Countable`的方法或函数一起使用时调用：
- en: '[PRE62]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Anonymous classes can use traits.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匿名类可以使用特征。
- en: 'This last example is a modification from the preceding one defined immediately.
    Instead of defining a class `Test`, we define an anonymous class instead:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个最后的例子是对前面立即定义的修改。我们不是定义一个`Test`类，而是定义一个匿名类：
- en: '[PRE63]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In an anonymous class you can define any properties or methods. Using the preceding
    example, you could define an anonymous class that accepts constructor arguments,
    and where you can access properties. Place the code described in step 2 into a
    test script `chap_04_oop_anonymous_class.php`. Add these `echo` statements:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在匿名类中，您可以定义任何属性或方法。使用前面的例子，您可以定义一个接受构造函数参数的匿名类，并且可以访问属性。将步骤2中描述的代码放入一个名为`chap_04_oop_anonymous_class.php`的测试脚本中。添加这些`echo`语句：
- en: '[PRE64]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here is the output from the anonymous class:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是匿名类的输出：
- en: '![How it works...](graphics/B05314_04_05.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_05.jpg)'
- en: 'In order to use `FilterIterator` you *must* override the `accept()` method.
    In this method, you define criteria for which elements of the iteration are to
    be included as output. Go ahead now and add the code shown in step 4 to the test
    script. You can then add these `echo` statements to test the anonymous class:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`FilterIterator`，您*必须*覆盖`accept()`方法。在这个方法中，您定义了迭代的元素被包括在输出中的标准。现在继续并将步骤4中显示的代码添加到测试脚本中。然后您可以添加这些`echo`语句来测试匿名类：
- en: '[PRE65]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In this example, a limit of 50 is established. The original `ArrayIterator`
    contains an array of values, 10 to 100, in increments of 10, as seen in the following
    output:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，建立了一个50的限制。原始的`ArrayIterator`包含一个值数组，从10到100，增量为10，如下面的输出所示：
- en: '![How it works...](graphics/B05314_04_12.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_12.jpg)'
- en: To have a look at an anonymous class that implements an interface, consider
    the example shown in steps 5 and 6\. Place this code in a file, `chap_04_oop_anonymous_class_interfaces.php`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看实现接口的匿名类，请考虑步骤5和6中显示的例子。将这段代码放入一个文件`chap_04_oop_anonymous_class_interfaces.php`中。
- en: 'Next, add code that lets you paginate through the HTML color chart:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加代码，让您可以通过HTML颜色图表进行分页：
- en: '[PRE66]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, go ahead and present the HTML color chart as a web page:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，继续并将HTML颜色图表呈现为一个网页：
- en: '[PRE67]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Notice that you can take advantage of the `Countable` interface by passing
    the instance of the anonymous class into the `count()` function (shown between
    `<H1>` tags). Here is the output shown in a browser window:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以通过将匿名类的实例传递给`count()`函数（在`<H1>`标签之间显示）来利用`Countable`接口。以下是在浏览器窗口中显示的输出：
- en: '![How it works...](graphics/B05314_04_25.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_25.jpg)'
- en: 'Lastly, to illustrate the use of traits in anonymous classes, copy the `chap_04_oop_trait_multiple.php`
    file mentioned in the previous recipe to a new file, `chap_04_oop_trait_anonymous_class.php`.
    Remove the definition of the `Test` class, and replace it with an anonymous class:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了说明匿名类中使用特征，将前面一篇文章中提到的`chap_04_oop_trait_multiple.php`文件复制到一个新文件`chap_04_oop_trait_anonymous_class.php`中。删除`Test`类的定义，并用匿名类替换它：
- en: '[PRE68]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Remove this line:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 删除这一行：
- en: '[PRE69]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'When you run the code, you will see exactly the same output as shown in the
    preceding screenshot, except that the class reference will be anonymous:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行代码时，您将看到与前面截图中完全相同的输出，只是类引用将是匿名的：
- en: '![How it works...](graphics/B05314_04_31.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_04_31.jpg)'
