- en: RESTful Web Services, Introduction and Motivation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful网络服务，介绍和动机
- en: 'RESTful web services are being used widely nowadays. RESTful is simple and
    most widely used among other web services. In fact, its simplicity is a reason
    for its fame as well. If you are reading this book, then chances are that you
    know something about RESTful web services. You probably have used it or you have
    just heard of it. But even if you don''t know much about RESTful web services,
    don''t worry as we are first defining it right here. So first, let''s list the
    high level topics that we will be covering in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful网络服务现在被广泛使用。RESTful是简单的，也是其他网络服务中最广泛使用的。事实上，它的简单性也是它出名的原因。如果你正在阅读这本书，那么你很可能对RESTful网络服务有所了解。你可能已经使用过它，或者只是听说过。但即使你对RESTful网络服务不太了解，也不用担心，因为我们首先在这里对它进行了定义。所以首先，让我们列出本章将涵盖的高层主题：
- en: Web services, what is a web service?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络服务，什么是网络服务？
- en: REST architecture (constraints of REST)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST架构（REST的约束）
- en: RESTful web services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful网络服务
- en: Conventions of RESTful web services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful网络服务的约定
- en: HTTP verbs (methods)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP动词（方法）
- en: Why RESTful web services?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么要使用RESTful网络服务？
- en: Response type and response codes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应类型和响应代码
- en: Case study - RESTful web service endpoints for a blog
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究-博客的RESTful网络服务端点
- en: However, there are a lot of misconceptions about RESTful web services. For example,
    some people think that anything over the web returning JSON is a RESTful web service
    and RESTful web services only return JSON. This is not true.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于RESTful网络服务有很多误解。例如，有些人认为任何返回JSON的网络上的东西都是RESTful网络服务，而RESTful网络服务只返回JSON。这是不正确的。
- en: In fact, RESTful web services support multiple formats and not everything returning
    JSON is a RESTful web service. To avoid confusion, let us understand what RESTful
    web service is.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，RESTful网络服务支持多种格式，并不是所有返回JSON的东西都是RESTful网络服务。为了避免混淆，让我们了解一下什么是RESTful网络服务。
- en: A web service based on the REST architecture is a RESTful web service. So, what
    exactly is a web service and REST architecture? Let's start by understanding web
    service first and then the REST architecture.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基于REST架构的网络服务是RESTful网络服务。那么，到底什么是网络服务和REST架构呢？让我们先了解网络服务，然后再了解REST架构。
- en: Web services
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络服务
- en: Web services are defined differently at different places. Word-by word translation
    states that any service provided on the web including a web page is a web service
    but this isn't true if the technical term *web service* is referred to.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务在不同的地方有不同的定义。逐字翻译的定义是，包括网页在内的任何在网上提供的服务都是网络服务，但是如果指的是技术术语*网络服务*，这并不正确。
- en: 'To define web service, we will look at web service definition from the W3C
    glossary:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义网络服务，我们将从W3C词汇表中查看网络服务的定义：
- en: '"A Web service is a software system designed to support inter-operable machine-to-machine
    interaction over a network. It has an interface described in a machine-process
    able format (specifically WSDL). Other systems interact with the Web service in
    a manner prescribed by its description using SOAP-messages, typically conveyed
    using HTTP with an XML serialization in conjunction with other Web-related standards."
    -W3C, web services glossary.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: “网络服务是一种旨在支持网络上可互操作的机器对机器交互的软件系统。它具有用机器可处理的格式（特别是WSDL）描述的接口。其他系统按照其描述的方式使用SOAP消息与网络服务进行交互，通常使用HTTP与其他与Web相关的标准一起进行XML序列化。”-W3C，网络服务词汇表。
- en: 'This definition again, is not completely true as it is more specific to SOAP
    and WSDL based web services. In fact, later in the W3C Working Group Note, February
    11, 2004, it was stated that:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义同样并不完全正确，因为它更具体地适用于基于SOAP和WSDL的网络服务。事实上，在2004年2月11日的W3C工作组说明中，它指出：
- en: '"We can identify two major classes of web services:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: “我们可以确定两类主要的网络服务：
- en: '*- REST-compliant web services,* in which the primary purpose of the service
    is to manipulate XML representations of Web resources using a uniform set of "stateless"
    operations;'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*-符合REST的网络服务，*其中服务的主要目的是使用一组统一的“无状态”操作来操作Web资源的XML表示；'
- en: '- and *arbitrary web services,* in which the service may expose an arbitrary
    set of operations."'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: -和*任意网络服务*，其中服务可能公开一组任意操作。”
- en: 'So considering that, a more general and better definition of a web service
    is this, from the preceding mentioned W3C web services glossary definition:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于网络服务的一个更一般和更好的定义是，来自前面提到的W3C网络服务词汇表的定义：
- en: '"A Web service is a software system designed to support inter-operable machine-to-machine
    interaction over a network."'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: “网络服务是一种旨在支持网络上可互操作的机器对机器交互的软件系统。”
- en: Why a web service?
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要使用网络服务？
- en: Now, we know what a web service is. So before proceeding to REST, it is important
    to know the need for a web service. Where can a web service be used?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道了什么是网络服务。所以在继续讨论REST之前，了解网络服务的需求是很重要的。网络服务可以在哪里使用？
- en: As just defined, a web service is a system to support machine-to-machine inter-operable
    communication over a network. It is very useful for communication between different
    systems or devices. In our case, we will be using web services to provide an interface
    by which either a mobile application or a web application will be able to communicate
    with a server to get and store data. This will make the client-side application
    separate from the server side logic. And nowadays, SPAs (Single Page Applications)
    and mobile applications need to be stand alone, separate from server side and
    only interacting with server side logic with web services. So definitely web services
    are very much important nowadays. However, web service usage is not limited to
    client side application usage but it is also useful in server to server communication
    where one server acts as a client.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如刚刚定义的，Web服务是支持网络上机器对机器的可互操作通信的系统。它对于不同系统或设备之间的通信非常有用。在我们的情况下，我们将使用Web服务来提供一个接口，通过这个接口，移动应用程序或Web应用程序将能够与服务器通信以获取和存储数据。这将使客户端应用程序与服务器端逻辑分离。如今，单页应用程序（SPA）和移动应用程序需要独立，与服务器端逻辑分离，并且只通过Web服务与服务器端逻辑交互。因此，Web服务如今非常重要。然而，Web服务的使用不仅限于客户端应用程序的使用，而且在服务器之间的通信中也很有用，其中一个服务器充当客户端。
- en: REST architecture
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST架构
- en: REST stands for Representational State Transfer. It is an architectural style
    founded by Roy Fielding in 2000 and was stated in his PhD dissertation. He stated
    that REST <q>"provides a set of architectural constraints that, when applied as
    a whole, emphasizes scalability of component interactions, generality of interfaces,
    independent deployment of components, and intermediary components to reduce interaction
    latency, enforce security, and encapsulate legacy systems."</q>.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: REST代表表述性状态转移。这是由Roy Fielding在2000年创立的架构风格，并在他的博士论文中阐述。他指出REST <q>“提供了一组架构约束，当作为一个整体应用时，强调组件交互的可扩展性，接口的通用性，组件的独立部署，以及中间组件来减少交互延迟，强制安全性，并封装遗留系统。”</q>。
- en: REST is an architectural style for a network-based application and HTTP 1.1
    was based on it, as it was developed in parallel to HTTP 1.1.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: REST是基于网络应用的架构风格，而HTTP 1.1就是基于它开发的。
- en: A RESTful system or RESTful web service must abide by the following six constraints;
    otherwise, it will not be considered as RESTful or REST-compliant. While reading
    and understanding the following mentioned constraints, think about the modern
    web as an example of REST architecture.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个符合RESTful或REST的网络服务必须遵守以下六个约束；否则，它将不被视为RESTful或REST兼容。在阅读和理解以下提到的约束时，可以将现代网络视为REST架构的一个例子。
- en: Client server
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端服务器
- en: REST is about separating the client and server. This constraint is about "separation
    of concerns". It means that the server and client have separate responsibilities,
    so one is not responsible for the other's duties. For example, the client is not
    responsible for data storage on the server as it is the server's responsibility.
    In the same way, the server doesn't need to know about the user interface. So
    both the server and client perform their tasks and fulfill their own responsibilities
    which makes their work easier. Hence, the server can be more scalable and the
    user interface on the client can be independent and more interactive.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: REST是关于分离客户端和服务器的。这个约束是关于“关注点分离”。这意味着服务器和客户端有各自的责任，因此一个不负责另一个的职责。例如，客户端不负责服务器上的数据存储，因为这是服务器的责任。同样，服务器不需要了解用户界面。因此，服务器和客户端都执行自己的任务并履行自己的责任，这使得他们的工作更容易。因此，服务器可以更具可扩展性，客户端上的用户界面可以是独立的和更具交互性。
- en: Stateless
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态
- en: Client server communication is stateless. Each request coming from the client
    will have all the information required to serve a request. This means there is
    no state in this communication other than what is in the request. The response
    which the client will get will be based on the request without looking at any
    state other than what is in request.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端服务器通信是无状态的。来自客户端的每个请求都将包含提供请求所需的所有信息。这意味着在这种通信中除了请求中的信息之外，没有其他状态。客户端将收到的响应将基于请求而不查看除请求中的信息之外的任何状态。
- en: 'If the session needs to be maintained, the session will be stored based on
    a token or identifier which is coming in the request. So if we look at an example
    of a web request, then the flow of HTTP is no more than a request sent by the
    **client** to the **server** and a response, sent back to the **client** from
    the **server,** as shown in the following diagram:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要维护会话，会话将基于请求中的令牌或标识符进行存储。因此，如果我们看一个Web请求的例子，那么HTTP的流程不过是一个请求由**客户端**发送到**服务器**，然后服务器发送一个响应回到**客户端**，如下图所示：
- en: '![](assets/74c3c7ee-f037-4b40-aa87-03cb16a3c8a8.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/74c3c7ee-f037-4b40-aa87-03cb16a3c8a8.png)'
- en: 'If a session needs to be maintained, the session data will be stored on the
    server, while the session identifier will be sent back to the client. In subsequent
    requests, the client will include that session identifier in every request by
    which the server will identify the client and load the related session''s data
    as explained in the following diagram:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要维护会话，会话数据将存储在服务器上，而会话标识符将发送回客户端。在随后的请求中，客户端将在每个请求中包含该会话标识符，服务器将通过此标识符识别客户端并加载相关会话数据，如下图所示：
- en: '![](assets/61eb3fc0-43b0-4370-b2f3-5af39dcb72ed.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/61eb3fc0-43b0-4370-b2f3-5af39dcb72ed.png)'
- en: 'And in subsequent requests:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的请求中：
- en: '![](assets/57cdc659-e497-496c-83e9-17613a213282.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/57cdc659-e497-496c-83e9-17613a213282.png)'
- en: So REST is stateless. To maintain the state, one needs to pass an identifier
    or any other information, to logically group different requests to maintain a
    session in the request. If no such identifier is passed in the request, the server
    will never know if those two requests are from same client.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，REST是无状态的。为了维护状态，需要传递标识符或任何其他信息，以逻辑上分组不同的请求以在请求中维护会话。如果在请求中没有传递这样的标识符，服务器将永远不知道这两个请求是否来自同一个客户端。
- en: The advantage of statelessness is simplicity. The same requests will not result
    in different responses unless the request parameters are changed. It will return
    different results based on different request parameters not due to some sort of
    state. Even the state depends on requests, as shown in the preceding example.
    So that session identifier is in the request, which can result in a different
    state and, hence, results in a different response.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态性的优势在于简单性。相同的请求不会产生不同的响应，除非请求参数发生了变化。它将根据不同的请求参数返回不同的结果，而不是由于某种状态。即使状态取决于请求，如前面的例子所示。因此，会话标识符在请求中，这可能导致不同的状态，因此导致不同的响应。
- en: Cache-able
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可缓存
- en: This constraint specifies that a RESTful web service response must define itself
    as cache-able or not, so that the client can know whether it should be cached
    or not. If it is correctly defined, it can result in less overhead and better
    performance because the client will not go to the server if it is able to use
    the cached version.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约束规定RESTful Web服务的响应必须定义自身是否可缓存，以便客户端知道是否应该缓存。如果正确定义，它可以减少开销并提高性能，因为如果能够使用缓存版本，客户端就不会去服务器。
- en: Uniform interface
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一接口
- en: The uniform interface is the most distinguishing constraint. It basically decouples
    the architecture makes the interface separate from the implementation, just as
    any good system does.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 统一接口是最具区别性的约束。它基本上解耦了架构，使接口与实现分离，就像任何良好的系统一样。
- en: 'It is similar to how it is in OOP: an interface separates the implementation
    and declaration. It is similar to how an operating system separates the user interface
    from the complex implementation logic that keeps our software''s running.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于面向对象编程中的情况：接口分离了实现和声明。这类似于操作系统将用户界面与复杂的实现逻辑分离开来，以保持软件的运行。
- en: The uniform interface has four constraints. In order to understand uniform interface,
    we need to understand these constraints.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 统一接口有四个约束。为了理解统一接口，我们需要理解这些约束。
- en: Resource identification
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源标识
- en: Resources will be identified in requests. For example, a resource in a web-based
    REST system will be identified by the URI. And no matter how a resource is stored
    on the server, it will remain separate from what will be returned to the client
    in the response.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 资源将在请求中被标识。例如，在基于Web的REST系统中，资源将由URI标识。无论资源在服务器上如何存储，它都将与响应中返回给客户端的内容分开。
- en: In fact, resource storage on the server is an implementation but the request
    and response is what a client is interacting with, so it is like an interface
    to the client. And a client can identify a resource by this interface. So all
    that a client knows is what it is requesting and getting in response.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，服务器上的资源存储是一种实现，但请求和响应是客户端与之交互的方式，因此它就像是对客户端的接口。客户端可以通过这个接口识别资源。客户端所知道的就是它请求和得到的响应。
- en: For example, a client usually sends a request to the URI and gets a response
    in the form of HTML, JSON, or XML. None of these formats are how the server stores
    data internally in the database or somewhere else on the server. But for a client,
    it is the URI where it will hit and the HTML, JSON, and XML is what it gets.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，客户端通常会向URI发送请求，并以HTML、JSON或XML的形式获得响应。这些格式都不是服务器在数据库内部或其他地方存储数据的方式。但对于客户端来说，重要的是它将要访问的URI以及它得到的HTML、JSON和XML。
- en: This is what a resource is for a client, no matter how it is stored on the server.
    And this is the benefit, because no matter if the server's internal logic or representation
    is changed, for the client it will remain the same because the client sends the
    request to the URI and gets a response in the form of HTML, JSON, or XML and not
    how it is stored on the server. This constraint, results in loose coupling of
    resource identification and representation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是客户端的资源，无论它在服务器上如何存储。这就是好处，因为无论服务器的内部逻辑或表示如何更改，对于客户端来说它都将保持不变，因为客户端将请求发送到URI并以HTML、JSON或XML的形式获得响应，而不是它在服务器上的存储方式。这个约束导致资源标识和表示的松散耦合。
- en: Manipulation of resources through representations
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过表示来操作资源
- en: This constraint states that the client should hold the representation of a resource
    that has enough information to modify or delete the resource. For example, in
    the web-based REST system, any operation can be performed on a resource using
    the HTTP method and URI. This makes things easy to follow, as the API developer
    doesn't need to provide documentation for each and every endpoint related to a
    resource.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约束规定客户端应该持有足够的信息来修改或删除资源的表示。例如，在基于Web的REST系统中，可以使用HTTP方法和URI对资源执行任何操作。这使得事情变得容易跟踪，因为API开发人员不需要为与资源相关的每个端点提供文档。
- en: Self-descriptive messages
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自描述消息
- en: This constraint states that each message should be able to be processed based
    on information contained in itself. That means, every message passed between the
    server and client should be stateless be independent of other messages. One message
    doesn't have an impact on other messages. So, it doesn't matter if two messages
    are passed in some particular order or not, as they are independent. The request
    in a message is enough to get a response and that response has all that needs
    to be conveyed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，根据需要向客户端发送代码是可选的，如果不想扩展客户端的功能，则不需要。
- en: Hypermedia as the engine of application state (HATEOAS)
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超媒体作为应用状态的引擎（HATEOAS）
- en: This constraint states that, based on what a server provides to a REST client,
    the REST client should be able to discover all available actions and resources.
    In other words, it states that if a client knows an entry point then from that
    first endpoint, it should be able to discover other relevant endpoints related
    to that resource. For example, if a client goes to a resource's listing endpoint,
    that should include links to resources in that listing. And if there is pagination
    or limit being applied, it should have links to go to the rest of the items in
    the listing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约束规定，基于服务器向REST客户端提供的内容，REST客户端应该能够发现所有可用的操作和资源。换句话说，它指出，如果客户端知道一个入口点，那么从第一个端点开始，它应该能够发现与该资源相关的其他相关端点。例如，如果客户端转到资源的列表端点，那应该包括该列表中资源的链接。如果应用了分页或限制，它应该有链接以转到列表中其余的项目。
- en: If a client has created a new resource, the new resource's link should be included
    in response as well which can be used for read, update, and delete operations
    on that resource by using different HTTP verbs. For operations other than typical
    CRUD, it will obviously have more URLs, so URLs for those operations should also
    be in the response, so that all endpoints related to the resource can be discoverable
    from one entry point.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端创建了一个新资源，新资源的链接也应该包含在响应中，这个链接可以用于使用不同的HTTP动词进行对该资源的读取、更新和删除操作。对于除了典型的CRUD之外的操作，显然会有更多的URL，因此这些操作的URL也应该在响应中，以便从一个入口点发现与资源相关的所有端点。
- en: Due to HATEOAS, an endpoint exposes links to related endpoints. This reduces
    the need of a thorough API documentation, although not completely, but one does
    not need to see the API documentation for the links already being exposed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HATEOAS，一个端点会暴露出与其相关的链接。这减少了对全面API文档的需求，尽管不是完全减少，但不需要查看已经暴露的链接的API文档。
- en: Code on demand (optional)
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按需发送代码（可选）
- en: This states that the server can add more functionality to the REST client, by
    sending code that can be executable by that client. In the context of the web,
    one such example is JavaScript code that the server sends to the browser.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明服务器可以通过发送可由客户端执行的代码，为REST客户端添加更多功能。在网络环境中，一个这样的例子是服务器发送给浏览器的JavaScript代码。
- en: Let's consider an example to understand this better.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子来更好地理解这一点。
- en: For example, a web browser acts like a REST client and the server passes HTML
    content that the browser renders. At the server side, there is some sort of server-side
    language which is performing some logical work at the server side. But if we want
    to add some logic which will work in the browser then we (as server-side developers)
    will have to send some JavaScript code to the client side and the browser and
    then execute that JavaScript code. So that the JavaScript code can add validation
    to a form, some animation or anything else, that couldn't be possible simply in
    HTML content. That JavaScript code is code on demand which the server sends to
    the client that extends the functionality of the REST client.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Web浏览器就像一个REST客户端，服务器传递HTML内容，浏览器呈现。在服务器端，有一些服务器端语言在服务器端执行一些逻辑工作。但是，如果我们想要在浏览器中添加一些逻辑，那么我们（作为服务器端开发人员）将不得不向客户端发送一些JavaScript代码，然后执行该JavaScript代码。因此，JavaScript代码是服务器发送给客户端的按需代码，它扩展了REST客户端的功能。
- en: Note that sending code on demand to the client is optional, and not required
    if we don't want to extend the client's functionality.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经定义了REST和网络服务，现在我们可以说RESTful网络服务是符合REST的任何网络服务。
- en: Layered system
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分层系统
- en: This constraint states that the REST system can have multiple layers and if
    a client is requesting for a response and getting a response, it can't be differentiated
    if it was returned from the server or another middle-ware server. So if one server
    layer is replaced by an other, it doesn't affect the client unless it provides
    what it is expected to provide. In short, one layer doesn't have knowledge beyond
    the next layer with which it is interacting directly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: REST系统的多层约束
- en: RESTful web services
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST系统可以有多个层，并且如果客户端请求响应并获得响应，无法区分它是从服务器返回的还是从另一个中间件服务器返回的。因此，如果一个服务器层被另一个替换，除非提供了预期的内容，否则不会影响客户端。简而言之，一个层与其直接交互的下一层之外没有知识。
- en: As we have already defined REST and web services, we can now say that a RESTful
    web service is any web service that is REST-compliant.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful网络服务
- en: Now, as we have already defined RESTful web services, we need to learn how RESTful
    web services work, and what RESTful web services are based on and why they are
    preferred over other web services such as SOAP.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经定义了RESTful网络服务，我们需要了解RESTful网络服务是如何工作的，以及RESTful网络服务基于什么，以及为什么它们比其他网络服务（如SOAP）更受欢迎。
- en: Conventions of RESTful web services
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful网络服务的约定
- en: 'RESTful web services are based on RESTful resources. A RESTful resource is
    an entity/resource that is mostly stored on a server and that client request using
    RESTful web services. Here are a few characteristics of a resource in terms of
    RESTful web services:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful web服务是基于RESTful资源的。RESTful资源是一个实体/资源，通常存储在服务器上，并且客户端使用RESTful web服务请求它。以下是关于RESTful
    web服务中资源的一些特征：
- en: It is an entity normally referred as a noun in the URL
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通常被称为URL中的名词实体
- en: It is unique
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是唯一的
- en: It has data associated with it
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与数据相关联
- en: It has at least one URI
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它至少有一个URI
- en: If you are still wondering what exactly is a resource, consider the example
    of a blog. In a blog system, a **Post**, **User**, **Category**, or **Comment**
    can be a resource. In a shopping cart, a **Product**, **Category**, or an **Order**
    can be a resource. In fact, any entity which a client is requesting from the server
    is a resource.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还在疑惑什么是资源，可以考虑博客的例子。在博客系统中，**帖子**，**用户**，**类别**或**评论**都可以是资源。在购物车中，**产品**，**类别**或**订单**可以是资源。事实上，任何客户从服务器请求的实体都是资源。
- en: 'Most commonly, there are five typical operations which can be performed on
    a resource:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的是，可以对资源执行五种典型操作：
- en: List
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: Create
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建
- en: Read
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取
- en: Update
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新
- en: Delete
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除
- en: 'For each operation, we need two things: the URI and HTTP method or verb.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个操作，我们需要两样东西：URI和HTTP方法或动词。
- en: The URI contains a resource name that is a noun and the HTTP method that is
    a verb. To perform some operation on an entity, we need to have a noun that tells
    us which entity we need to perform some operation. We also need to specify a verb
    to tell us what operation we want to perform.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: URI包含一个名词资源和一个动词HTTP方法。要对实体执行某些操作，我们需要一个名词，告诉我们需要执行某些操作的实体是什么。我们还需要指定一个动词，告诉我们要执行什么操作。
- en: For the preceding mentioned operations, there is a URL convention that we use
    with HTTP verbs and resource names. In the next section, we will review the URL
    structure and HTTP verbs for each operation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面提到的操作，我们使用HTTP动词和资源名称的URL约定。在下一节中，我们将审查每个操作的URL结构和HTTP动词。
- en: HTTP verbs and URL structure
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP动词和URL结构
- en: Here is how these operations can be performed on a resource using a combination
    of URIs and HTTP verbs. Note, in the following mentioned operation's URIs, you
    need to replace `{resource}` with a resource name.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用URI和HTTP动词在资源上执行这些操作的。请注意，在下面提到的操作的URI中，您需要用资源名称替换`{resource}`。
- en: List operation
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表操作
- en: '**HTTP method :** `GET`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP方法：**`GET`'
- en: '**URI:** `/{resource}`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URI：**`/{resource}`'
- en: '**Result:** It returns the list of the type of resource whose name is mentioned.
    In that list, it will give unique identifiers for the resource and these identifiers
    can be used to perform other operations on that particular resource.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果：**它返回所提到资源类型的列表。在该列表中，它将为资源提供唯一标识符，这些标识符可以用于对特定资源执行其他操作。'
- en: Create operation
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建操作
- en: '**HTTP method :** `POST`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP方法：**`POST`'
- en: '**URI:** `/{resource}`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URI：**`/{resource}`'
- en: '**Parameters:** can be multiple parameters in `POST` body'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数：**可以在`POST`主体中有多个参数'
- en: '**Result:** This should create a new resource with parameters in the body.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果：**这应该在主体中使用参数创建一个新的资源。'
- en: As you can see, there is no difference in the URI for Create and List but these
    two operations are distinguished by the HTTP method which results in different
    operations. In fact, a combination of the HTTP method and URI tells which operation
    should be performed.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如你所看到的，创建和列表的URI没有区别，但这两个操作是通过HTTP方法区分的，这导致了不同的操作。事实上，HTTP方法和URI的组合告诉我们应该执行哪种操作。
- en: READ operation
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取操作
- en: '**HTTP method**: `GET`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP方法：**`GET`'
- en: '**URI**: `/{resource}/{resource_id}`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**URI：**`/{resource}/{resource_id}`'
- en: '**Result**: This should return the record based on the resource''s ID.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果：**这应该根据资源的ID返回记录。'
- en: Here `resource_id` will be the ID of the resource which can be found from the
    List operation's result.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`resource_id`将是可以从列表操作结果中找到的资源的ID。
- en: Update operation
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新操作
- en: 'There can be two types of update operations:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可以有两种类型的更新操作：
- en: Update some attributes of a particular record
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新特定记录的一些属性
- en: Replace that particular record completely with a new one
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用新的完全替换特定记录
- en: 'Only thing that change to perform these two operations: HTTP method.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这两个操作的唯一变化是HTTP方法。
- en: 'With the Update operation, to update some of attributes of the resource use:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更新操作，更新资源的一些属性：
- en: '**HTTP method**: `PATCH`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP方法：**`PATCH`'
- en: 'While to replace the whole resource use:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当要替换整个资源时使用：
- en: '**HTTP method**: `PUT`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP方法：**`PUT`'
- en: 'The URI and the parameters will remain the same:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: URI和参数将保持不变：
- en: '**URI**: `/{resource}/{resource_id}`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**URI：**`/{resource}/{resource_id}`'
- en: '**Parameters**: There can be multiple parameters in a query string. Initially,
    people try to pass these parameters in the body but actually, the `PATCH` and
    `PUT` parameters are passed using a query string.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：**可以在查询字符串中有多个参数。最初，人们尝试在主体中传递这些参数，但实际上，使用查询字符串传递`PATCH`和`PUT`参数。'
- en: '**Result**: This should update or replace the resource based on the HTTP method.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果：**这应该根据HTTP方法更新或替换资源。'
- en: Here, `resource_id` will be the ID of the resource which can be found from the
    List operation's result. Again, practically using `PATCH` or `PUT` will not make
    any difference but based on REST standards `PATCH` should be used for updating
    the different attributes of a record while `PUT` should be used for replacing
    the whole resource.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`resource_id`将是可以从列表操作结果中找到的资源的ID。实际上，使用`PATCH`或`PUT`不会有任何区别，但基于REST标准，应该使用`PATCH`来更新记录的不同属性，而应该使用`PUT`来替换整个资源。
- en: Delete operation
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除操作
- en: '**HTTP method**: ``DELETE``'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP方法：**``DELETE``'
- en: '**URI**: `/{resource}/{resource_id}`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URI：**`/{resource}/{resource_id}`'
- en: '**Result**: This should delete the resource based on the resource ID in the
    URI'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果：**这应该根据URI中的资源ID删除资源'
- en: If you feel overwhelmed at the moment, don't worry, because right now we have
    just seen which combination of HTTP method and URI is used for which operations.
    Shortly, we will discuss a case study and will see some operations on different
    resources along with examples.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在感到不知所措，不要担心，因为我们刚刚看到了哪种HTTP方法和URI的组合用于哪些操作。很快，我们将讨论一个案例研究，并看到一些不同资源上的操作以及示例。
- en: Before anything else, since we now know about RESTful web services and how they
    work, it's a good time to understand why we prefer to use RESTful web services
    over other web services.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何其他事情之前，既然我们现在了解了RESTful网络服务以及它们的工作原理，现在是了解为什么我们更喜欢使用RESTful网络服务而不是其他网络服务的好时机。
- en: Why RESTful web services?
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要使用RESTful网络服务？
- en: In fact, RESTful web services are not the only type of web services that we
    can write. There are other ways to write web services as well. There are old ways
    of writing web services as well as some more recent ways. We will not go in to
    detail about other web services, as that is out of the scope of the book, with
    the focus here being on RESTful web services and how to build them.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，RESTful网络服务并不是我们唯一可以编写的网络服务类型。我们也有其他编写网络服务的方式。还有一些更早的编写网络服务的方式以及一些更近期的方式。我们不会详细讨论其他网络服务，因为这超出了本书的范围，重点在于RESTful网络服务以及如何构建它们。
- en: REST versus SOAP
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST与SOAP
- en: One old alternative to REST is SOAP. In fact, SOAP was already, used when REST
    came along as an alternative. A key difference is that SOAP doesn't have some
    particular convention that tells consumers how to access that. SOAP exposes its
    services using WSDL. Consider WSDL as a definition of services that SOAP provides.
    This is how the consumer knows what SOAP based web service provides and how to
    consume them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: REST的一个旧的替代方案是SOAP。事实上，当REST作为一种替代方案出现时，SOAP已经存在。一个关键的区别是SOAP没有告诉消费者如何访问的特定约定。SOAP使用WSDL来公开其服务。将WSDL视为SOAP提供的服务的定义。这就是消费者知道SOAP基于网络服务提供了什么以及如何消费它们的方式。
- en: On the other hand, REST emphasizes on "c**<q>onventions over configurations</q>**".
    If you look at the URL structures and HTTP verbs of RESTful web services as we
    did earlier, there is a fixed convention. For example, if you are at the client
    side and want to create a product, if you know what parameters it will take then
    you can simply create it by sending a `POST` request to `example.com/product`
    and the resource will be created. If you want to list all the products, you can
    use the same URL with a `GET` request. If you get product IDs from the List operation,
    you can simply use them to update or delete a product by using `example.com/product/{product_id}`
    using `PATCH` and `PUT` or `DELETE` respectively. It is that simple to know what
    URL and HTTP method to use to do a type of operation because these are some conventions
    that RESTful web services follow. So, the one on the client end will just follow
    those conventions and will not need large documentations for simple tasks.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，REST强调“约定优于配置”。如果你像我们之前所做的那样看RESTful网络服务的URL结构和HTTP动词，你会发现有一个固定的约定。例如，如果你在客户端并且想要创建一个产品，如果你知道它将需要哪些参数，那么你可以通过向`example.com/product`发送`POST`请求来创建它，资源将被创建。如果你想列出所有产品，你可以使用相同的URL和`GET`请求。如果你从列表操作中获取产品ID，你可以简单地使用它们来通过`example.com/product/{product_id}`分别使用`PATCH`和`PUT`或`DELETE`来更新或删除产品。要知道使用哪种URL和HTTP方法来执行某种操作是如此简单，因为这些是RESTful网络服务遵循的一些约定。因此，客户端端只需遵循这些约定，对于简单的任务就不需要大量的文档。
- en: Other than that, simplicity of statelessness, separation of concerns, and cache-ability
    are some of the other advantages of RESTful web services that we have already
    seen in detail.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，无状态性的简单性、关注点的分离和可缓存性是我们已经详细了解的RESTful网络服务的其他优点之一。
- en: Nature of HTTP methods
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP方法的性质
- en: Since we will be mainly dealing with URLs over HTTP and will be using HTTP methods,
    it is better to spend some time understanding the nature of HTTP methods.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将主要处理HTTP上的URL和使用HTTP方法，最好花一些时间了解HTTP方法的性质。
- en: We should also understand that HTTP methods are not actually doing any type
    of listing or creation or modification by themselves. It is just a convention
    to use certain HTTP methods and URL patterns for certain operations. These methods
    do not perform any operations on their own but it depends on the server-side developer.
    These methods can result in any operation depending on the code that the developer
    writes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该了解，HTTP方法实际上并不是通过自身进行任何类型的列举、创建或修改。这只是一种约定，使用特定的HTTP方法和URL模式进行特定的操作。这些方法本身并不执行任何操作，而是取决于服务器端开发人员。这些方法可以根据开发人员编写的代码进行任何操作。
- en: When we talk about the nature of HTTP methods, then it is about the convention
    and standards which are followed. After all, RESTful web services are about preferring
    convention over configuration. The foundation of today's HTTP and REST lies on
    these conventions and while writing RESTful web services, we are going to follow
    these conventions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论HTTP方法的性质时，这是关于遵循的约定和标准。毕竟，RESTful网络服务是关于优先选择约定而不是配置。今天的HTTP和REST的基础就在于这些约定，而在编写RESTful网络服务时，我们将遵循这些约定。
- en: Safe/unsafe HTTP methods
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全/不安全的HTTP方法
- en: HTTP methods can be both safe or unsafe. By safe, it means the methods are not
    expected to change any resource on the server and by unsafe it means the methods
    are expected to change some resource on the server. So this way, we have `GET`
    as the only safe method, as it is not expected to change anything on the server
    while other methods such as `PUT`, `POST`, `PATCH`, and `DELETE` are considered
    as unsafe methods since they are expected to do some changes on the server.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP方法可以是安全的或不安全的。安全的意思是这些方法不会改变服务器上的任何资源，而不安全的意思是这些方法预期会改变服务器上的一些资源。因此，我们有`GET`作为唯一的安全方法，因为它不预期在服务器上做任何改变，而其他方法如`PUT`、`POST`、`PATCH`和`DELETE`被认为是不安全的方法，因为它们预期在服务器上做一些改变。
- en: Idempotent and non-idempotent methods
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 幂等和非幂等方法
- en: There are methods which achieve the same results no matter how many time we
    repeat the same operations. We consider `GET`, `PUT`, `PATCH`, and `DELETE` as
    idempotent methods, as no matter how many times we repeat these method calls,
    it will always result in the same thing. For example, if you are using `GET example.com/books`
    , it will always return the same list of books, no matter how many times you call
    this URL with the `GET` method. However, if user put something else in database
    then it can have different result in listing but to declare some method idempotent
    or not, we are not considering change in result because of external factors instead
    of that method call itself. In the same way, if you use `PUT` or `PATCH`, let's
    say `PATCH` `example.com/books/2?author=Ali`, it will always result in the same
    response no matter how many times you call this method with the same parameters.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有些方法可以实现相同的结果，无论我们重复相同的操作多少次。我们认为`GET`、`PUT`、`PATCH`和`DELETE`是幂等方法，因为无论我们重复调用这些方法多少次，结果总是相同的。例如，如果您使用`GET
    example.com/books`，它将始终返回相同的书籍列表，无论您用`GET`方法调用这个URL多少次。然而，如果用户在数据库中放入其他东西，那么在列出中可能会有不同的结果，但为了声明某些方法是否幂等，我们不考虑由于外部因素而导致结果的变化，而是考虑方法调用本身。同样，如果您使用`PUT`或`PATCH`，比如`PATCH
    example.com/books/2?author=Ali`，无论您用相同的参数多少次调用这个方法，结果始终相同。
- en: The same is the case with `DELETE`. It doesn't matter how many times you call
    `DELETE` on the same resource, it will only be deleted once. However, for `DELETE`,
    it can vary based on the implementation as well. It is something that depends
    on how you as a programmer want to implement. You probably want to `DELETE` and
    give a successful response the first time and on subsequent calls. You can simply
    give 404 because the resource no longer exists.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`DELETE`也是一样的。无论您多少次在相同的资源上调用`DELETE`，它只会被删除一次。然而，对于`DELETE`，它也可能基于实现而有所不同。这取决于您作为程序员想要如何实现。您可能希望第一次`DELETE`并给出成功的响应，而在后续调用中，您可以简单地给出404，因为资源已经不存在。
- en: '`POST` is non-idempotent because it creates a new resource on the server and
    the response has at least one unique attribute (mostly that is the ID of the resource),
    even if all the other attributes are same in the case of the same request parameters.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`是非幂等的，因为它在服务器上创建一个新资源，响应至少有一个唯一的属性（通常是资源的ID），即使在相同的请求参数的情况下，所有其他属性都相同。'
- en: Until now, we have understood RESTful web services conventions, URL patterns,
    HTTP methods, and the nature of HTTP methods. However, it was mostly about requests.
    The URL and HTTP method are both request-related points. We haven't yet looked
    at responses, so now let's take a look into that.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了RESTful web服务的约定、URL模式、HTTP方法和HTTP方法的性质。然而，这主要是关于请求。URL和HTTP方法都是与请求相关的点。我们还没有看过响应，所以现在让我们来看一下。
- en: HTTP response
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP响应
- en: 'The purpose of the request is to get a response or else it is of no use, considering
    that we also need to understand what type of response is expected against a request.
    There are two things that we will discuss in this context:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的目的是获得响应，否则就没有用处，考虑到我们还需要了解对请求期望的响应类型。在这个上下文中，有两件事情我们将讨论：
- en: Response type
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应类型
- en: Response code
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应代码
- en: Response type
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应类型
- en: In the current world, many people think that the response of a RESTful web service
    must be a JSON or text having a JSON string. However, we can also use XML in response
    to a RESTful web service request. A lot of people use JSON in response because
    it is lightweight and easy to parse. But at the same time, this is just a matter
    of preference, and depends on the requirement and has nothing to do with REST
    standards.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前世界中，许多人认为RESTful web服务的响应必须是JSON或包含JSON字符串的文本。然而，我们也可以在RESTful web服务请求的响应中使用XML。许多人使用JSON作为响应，因为它轻量且易于解析。但与此同时，这只是一种偏好，取决于需求，与REST标准无关。
- en: Both XML and JSON are ways to format data. XML stands for Extensible Markup
    Language, having markup syntax. While JSON stands for JavaScript Object Notation,
    with JavaScript object-like syntax. For more understanding of JSON, please check
    out [http://www.json.org/](http://www.json.org/)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: XML和JSON都是格式化数据的方式。XML代表可扩展标记语言，具有标记语法。而JSON代表JavaScript对象表示法，具有类似JavaScript对象的语法。要更好地理解JSON，请查看[http://www.json.org/](http://www.json.org/)
- en: We will shortly look into the case study of a blog and will see request and
    response examples. In this book, will use JSON as the response type, as JSON is
    simpler than XML. And while developing new applications, we mostly use JSON because
    it is lightweight and easy to understand. As you can see in the following examples,
    the same data in JSON is much simpler than XML and only has content that matters.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快看一个博客的案例研究，并看到请求和响应的例子。在这本书中，我们将使用JSON作为响应类型，因为JSON比XML更简单。在开发新应用程序时，我们大多使用JSON，因为它轻量且易于理解。正如您在以下示例中所看到的，JSON中的相同数据比XML简单得多，只包含重要的内容。
- en: 'Here, we are trying to show the data of books having one or more authors:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们试图展示具有一个或多个作者的书籍的数据：
- en: 'XML:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: XML：
- en: '[PRE0]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s look at the same example in JSON:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在JSON中看同样的例子：
- en: '[PRE1]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can clearly see from the preceding example, that XML and JSON both convey
    the same information. However, in JSON it is much easier as well as it needs a
    lot less words to show the same information.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以清楚地从前面的例子中看到，XML和JSON都传达相同的信息。然而，在JSON中，这更容易，而且需要更少的词来显示相同的信息。
- en: Hence in the rest of book, we will be using JSON as the response type of our
    RESTful web services.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本书的其余部分，我们将使用JSON作为我们的RESTful web服务的响应类型。
- en: Response codes
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应代码
- en: Response codes, better known as HTTP status codes, tell us about the status
    of a request. If an HTTP request is successful, the HTTP status code is 200 which
    means OK. If there is a server error, it returns 500 status code which means an
    internal server error. In case of any problem in the request, the HTTP status
    code is 400 and onwards where 400 status code means a bad request. In case of
    redirection, the response code is 300 and onwards.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 响应代码，更为人所知的是HTTP状态代码，告诉我们请求的状态。如果HTTP请求成功，HTTP状态代码是200，表示OK。如果有服务器错误，它返回500状态代码，表示内部服务器错误。如果请求中有任何问题，HTTP状态代码是400及以上，其中400状态代码表示错误的请求。在重定向的情况下，响应代码是300及以上。
- en: To see the complete list of response code and their usage, see [https://en.wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的响应代码列表及其用法，请参见[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)
- en: I won't go into details of it as it would be redundant since all of it is already
    available at the preceding mentioned Wikipedia link. However, we will discuss
    the different status codes as we proceed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细介绍，因为这将是多余的，因为所有这些信息已经在前面提到的维基百科链接中都可以找到。然而，我们将在后续讨论不同的状态代码。
- en: Case study - RESTful web service endpoints for a blog
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究 - 博客的RESTful web服务端点
- en: To understand RESTful web services, let's consider the case study of a blog
    where we will discuss resources/entities in a blog. We will start to define the
    requirements and endpoints URLs for the blog's resources and then define responses
    that we should have against those requests. So these endpoints and response definitions
    will help us understand how RESTful web services endpoint should look like and
    what the response should be. In the later chapters, we will talk more about the
    implementation of these endpoints, so these definitions will act as an API document
    for the next chapters. However, for simplicity, we will keep it minimal for now
    and later add more attributes to it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解RESTful web服务，让我们以博客为案例研究，在博客中讨论资源/实体。我们将开始定义博客资源的要求和端点URL，然后定义我们应该对这些请求做出怎样的响应。因此，这些端点和响应定义将帮助我们理解RESTful
    web服务端点应该是什么样子，以及响应应该是什么样子。在后面的章节中，我们将更多地讨论这些端点的实现，因此这些定义将作为下一章的API文档。然而，为了简单起见，我们现在将保持最小限度，并在以后添加更多属性。
- en: Although based on HATEOAS, a RESTful web service should return links to the
    next endpoints and there are conventions that tell us about other endpoints but
    the API document is still important. API consumers (client-side developers) and
    API providers (server-side developers) should agree on it so that both can work
    in parallel without waiting for the other. However, in the real world, we don't
    have to write API document for basic CRUD operations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基于HATEOAS，RESTful web服务应该返回到下一个端点的链接，并且有一些约定告诉我们其他端点的信息，但API文档仍然很重要。API消费者（客户端开发人员）和API提供者（服务器端开发人员）应该就此达成一致，以便两者可以并行工作，而不必等待对方。然而，在现实世界中，我们不必为基本的CRUD操作编写API文档。
- en: In a typical blog, the most common resources are posts and comments. There are
    others as well but for now, we will discuss these two resources for the sake of
    understanding RESTful web services. Note that we are not considering authentication
    related stuff but will look into that in the later chapters.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的博客中，最常见的资源是文章和评论。还有其他资源，但现在我们将讨论这两个资源，以便理解RESTful web服务。请注意，我们不考虑与身份验证相关的内容，但将在后面的章节中进行讨论。
- en: If client-side and server-side teams are of the same organization, working on
    a single app, then it is a good idea to get such document created by the client-side
    team as the server-side team is just the serving client side.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端和服务器端团队属于同一组织，共同开发一个应用程序，那么由客户端团队创建这样的文档是个好主意，因为服务器端团队只是为客户端提供服务。
- en: Blog post
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 博客文章
- en: Here, we are listing the requirement of a blog post and its endpoints. For those
    endpoints, we will write a request and a response.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们列出了博客文章及其端点的要求。对于这些端点，我们将编写一个请求和一个响应。
- en: Requirements
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: A blog post can be created, modified, visited, and deleted. There should also
    be a way to list all the blog posts. So we are going to list the blog post's endpoints.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建、修改、访问和删除博客文章。还应该有一种方法列出所有博客文章。因此，我们将列出博客文章的端点。
- en: Endpoints
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端点
- en: 'Here are the endpoints for blog post:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是博客文章的端点：
- en: Creating blog post
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建博客文章
- en: '**Request**: `POST /posts HTTP/1.1`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：`POST /posts HTTP/1.1`'
- en: '**Body parameters**:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主体参数**：'
- en: 'Content: This is an awesome post'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 内容：这是一篇很棒的文章
- en: 'Title: Awesome Post'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 标题：很棒的文章
- en: '**Response**:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回应**：'
- en: '[PRE2]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Response code**: 201 Created'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应代码**：201 Created'
- en: Here `POST` is the method, `/posts` is the URL (path after the server name)
    and HTTP 1.1 is the protocol. We will keep using the same way of mentioning requests
    in later examples as well. So, the first part of the request is the HTTP method,
    the second one is the URL and the third part is the protocol.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`POST`是方法，`/posts`是URL（服务器名称后的路径），HTTP 1.1是协议。我们将继续以相同的方式提及后续示例中的请求。因此，请求的第一部分是HTTP方法，第二部分是URL，第三部分是协议。
- en: The response code tells the client that the resource has been created successfully.
    If a request parameter is missed by mistake, the response code should be **400**,
    which represents a bad request.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 响应代码告诉客户端资源已成功创建。如果请求参数被错误地省略，响应代码应为**400**，表示错误的请求。
- en: Reading blog post
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读博客文章
- en: '**Request**: `GET /posts/1 HTTP/1.1`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：`GET /posts/1 HTTP/1.1`'
- en: '**Response**:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回应**：'
- en: '[PRE3]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Response code**: 200 OK'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应代码**：200 OK'
- en: Note, if a blog post with an ID provided (in the current case, 1) does not exist,
    it should return **404**, which means resource Not Found.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果提供的ID对应的博客文章不存在（在当前情况下为1），它应该返回**404**，表示资源未找到。
- en: Updating blog post
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新博客文章
- en: '**Request**: `PATCH /posts/1?title=Modified%20Post HTTP/1.1`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：`PATCH /posts/1?title=Modified%20Post HTTP/1.1`'
- en: '**Response**:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回应**：'
- en: '[PRE4]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Response code**: 200 OK'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应代码**：200 OK'
- en: Note, if a blog post with the ID provided (that is 1 in this case) does not
    exist, it should return the response code **404** that means resource not found.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果提供的帖子ID（在本例中为1）不存在，应返回响应代码**404**，表示资源未找到。
- en: Also, we have used PATCH instead of PUT for the update since PATCH is used to
    modify all or some attributes of a record while PUT is used for modifying a whole
    record just like replacing an old record with a new one. So, if we use PUT and
    pass only one attribute, the other attributes will become empty. In the case of
    PATCH, it will only update the attribute that is passed and other attributes remain
    untouched.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于PATCH用于修改记录的所有或一些属性，而PUT用于修改整个记录，就像用新记录替换旧记录一样。因此，如果我们使用PUT并且只传递一个属性，其他属性将变为空。在PATCH的情况下，它只会更新传递的属性，其他属性保持不变。
- en: Delete blog post
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除博客帖子
- en: '**Request**: `DELETE /posts/1 HTTP/1.1`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：`DELETE /posts/1 HTTP/1.1`'
- en: '**Response**:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应**：'
- en: '[PRE5]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Response code**: `200 OK`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应代码**：`200 OK`'
- en: Note, if a blog post with an ID provided (in the current case, 1) does not exist,
    it should return **404**, which means resource `Not Found`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果提供的博客帖子ID（在当前情况下为1）不存在，应返回**404**，表示资源未找到。
- en: Listing all blog posts
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出所有博客帖子
- en: '**Request**: `GET /posts HTTP/1.1`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：`GET /posts HTTP/1.1`'
- en: '**Response**:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应**：'
- en: '[PRE6]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Response code:** `200 OK`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应代码**：`200 OK`'
- en: Here, data is an array of objects as there are multiple records returning. Other
    than `total_count`, there is a pagination object as well, and right now it shows
    the first and last pages because `total_count` for records is only 2\. So, there
    is no next or previous page. Otherwise, we should also have to show the next and
    previous in pagination.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数据是对象数组，因为有多个记录返回。除了`total_count`之外，还有一个分页对象，目前显示第一页和最后一页，因为记录的`total_count`只有2。因此，没有下一页或上一页。否则，我们还应该在分页中显示下一页和上一页。
- en: As you can see, there are links in the pagination as well as the post's links
    in post objects. We have included these links in response to being compliant with
    the HATEOAS constraint, which stated that if the client knows about an entry point,
    it should be enough to discover relevant endpoints.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，分页中也有链接，以及帖子对象中的帖子链接。我们在响应中包含了这些链接，以符合HATEOAS约束，该约束规定如果客户端知道入口点，那么应该足以发现相关的端点。
- en: Here, we explored the requirements of blog posts and defined the request and
    response of their endpoints. In the next entity/resource, we are going to define
    endpoints and responses in comments.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们探讨了博客帖子的要求，并定义了它们的端点的请求和响应。在下一个实体/资源中，我们将定义评论的端点和响应。
- en: Blog post comments
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 博客帖子评论
- en: Here, we are listing the requirements of a blog post comment and then its endpoints.
    For those endpoints, we will write `Request` and `Response`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们列出了博客帖子评论的要求，然后是它们的端点。对于这些端点，我们将编写`请求`和`响应`。
- en: Requirements
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: There will be one, more than one, or no comments on posts. So, a comment can
    be created on a blog post. A blog post's comments can be listed. A comment can
    be read, modified, or deleted.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 帖子上可能有一个、多个或没有评论。因此，可以在博客帖子上创建评论。可以列出博客帖子的评论。可以阅读、修改或删除评论。
- en: Let's define endpoints for these requirements.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这些要求定义端点。
- en: Endpoints
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端点
- en: 'Here are the endpoints for the post''s comments:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是帖子评论的端点：
- en: Creating the post's comment
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建帖子的评论
- en: '**Request:** `POST /posts/1/comments HTTP/1.1`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：`POST /posts/1/comments HTTP/1.1`'
- en: '**Body parameters**: `comment: An Awesome Post`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主体参数**：`comment: An Awesome Post`'
- en: '**Response:**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应**：'
- en: '[PRE7]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Response code:** `201 Created`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应代码**：`201 Created`'
- en: Here in the case of a comment, a comment is created against a certain blog post.
    So, the request URL includes `post_id` as well.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在评论的情况下，评论是针对某篇博客文章创建的。因此，请求URL也包括`post_id`。
- en: Reading a comment
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读评论
- en: '**Request:** `GET /posts/1/comment/1 HTTP/1.1` or `GET /comment/1 HTTP/1.1`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：`GET /posts/1/comment/1 HTTP/1.1` 或 `GET /comment/1 HTTP/1.1`'
- en: The second one seems more reasonable as in that one only needs to have a comment's
    ID without worrying about the post ID of that comment. And since a comment's ID
    is unique, we don't need to have the post's ID to get the comment. So, we will
    proceed with the second URL that is `GET /comment/1 HTTP/1.1`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个看起来更合理，因为只需要有一个评论的ID，而不用担心评论的帖子ID。而且由于评论的ID是唯一的，我们不需要有帖子的ID来获取评论。因此，我们将继续使用第二个URL，即`GET
    /comment/1 HTTP/1.1`。
- en: '**Response:**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应**：'
- en: '[PRE8]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Response code:** `200 OK`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应代码**：`200 OK`'
- en: Since any comment can only exist against some post, the response includes `post_id`
    as well.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任何评论只能存在于某个帖子中，因此响应也包括`post_id`。
- en: Updating a comment
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新评论
- en: '**Request:** `PATCH /comment/1?comment="Modified%20Awesome%20Comment'' HTTP/1.1`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：`PATCH /comment/1?comment="Modified%20Awesome%20Comment'' HTTP/1.1`'
- en: '**Response:**'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应**：'
- en: '[PRE9]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Response code:** `200 OK`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应代码**：`200 OK`'
- en: Here, we used PATCH as we want to update a single attribute of a comment that
    is a comment. Also, you can see `%20` passed in a new comment. So, `%20` is just
    a replacement for a space as a URL cannot contain spaces. So with URL encoding,
    spaces should always be replaced by `%20`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用PATCH，因为我们想要更新评论的单个属性。此外，您可以看到在新评论中传递了`%20`。因此，`%20`只是空格的替换，因为URL不能包含空格。因此，在URL编码中，空格应始终被`%20`替换。
- en: Deleting a post comment
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除帖子评论
- en: '**Request:** `DELETE /comments/1 HTTP/1.1`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：`DELETE /comments/1 HTTP/1.1`'
- en: '**Response:**'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应**：'
- en: '[PRE10]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Response code:** `200 OK`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应代码**：`200 OK`'
- en: Note, if a post comment with an ID provided (in the current case, 1) does not
    exist, it should return **404** **Not Found**.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果提供的帖子评论ID（在当前情况下为1）不存在，应返回**404 Not Found**。
- en: Listing all comments for a particular post
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出特定帖子的所有评论
- en: '**Request:** `GET /posts/1/comments HTTP/1.1`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：`GET /posts/1/comments HTTP/1.1`'
- en: '**Response:**'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应**：'
- en: '[PRE11]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Response Code:** `200 OK`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应代码**：`200 OK`'
- en: As you can see, a post's comments listing is very similar to a blog post's listing.
    And it has `total_count` and pagination in the same way. It shows the first and
    last page right now because `total_count` for the records is only 2\. So there
    is no next or previous page. Otherwise, we should also have to show the next and
    previous links in pagination.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，帖子的评论列表与博客帖子的列表非常相似。它以相同的方式显示`total_count`和分页。它现在显示第一页和最后一页，因为记录的`total_count`只有2。所以没有下一页或上一页。否则，我们还应该在分页中显示下一页和上一页的链接。
- en: Normally, you don't see pagination with comments on blogs, but it is better
    to keep it consistent to have pagination in the listing. Because there can be
    lot of comments for a post, we should apply some limit to it, so we will need
    pagination.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在博客上看不到评论的分页，但最好保持一致，在列表中加入分页。因为一篇帖子可能有很多评论，我们应该对其进行一些限制，所以我们需要分页。
- en: More resources
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多资源
- en: Although we have tried to look into RESTful web services in a way that one gets
    practical knowledge with the examples, here are some other interesting resources.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经尝试以实例的方式了解RESTful网络服务，但这里还有一些其他有趣的资源。
- en: 'Dissertation of Roy Fielding in which he introduced REST:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Roy Fielding介绍REST的论文：
- en: '[http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)'
- en: 'A group discussion with Roy Fielding''s response:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Roy Fielding的回应的小组讨论：
- en: '[https://groups.yahoo.com/neo/groups/rest-discuss/conversations/topics/6735](https://groups.yahoo.com/neo/groups/rest-discuss/conversations/topics/6735)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://groups.yahoo.com/neo/groups/rest-discuss/conversations/topics/6735](https://groups.yahoo.com/neo/groups/rest-discuss/conversations/topics/6735)'
- en: 'This is an interesting thread at [stackoverflow.com](http://stackoverflow.com)
    regarding REST versus SOAP:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于REST与SOAP的有趣讨论：[stackoverflow.com](http://stackoverflow.com)
- en: '[http://stackoverflow.com/questions/19884295/soap-vs-rest-differences](http://stackoverflow.com/questions/19884295/soap-vs-rest-differences)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://stackoverflow.com/questions/19884295/soap-vs-rest-differences](http://stackoverflow.com/questions/19884295/soap-vs-rest-differences)'
- en: 'Roy Fielding talking about REST :'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Roy Fielding谈论REST：
- en: '[https://www.youtube.com/watch?v=w5j2KwzzB-0](https://www.youtube.com/watch?v=w5j2KwzzB-0)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=w5j2KwzzB-0](https://www.youtube.com/watch?v=w5j2KwzzB-0)'
- en: 'A different way to look at REST:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: REST的另一种看法：
- en: '[https://www.youtube.com/watch?v=RY_kMXEJZfk](https://www.youtube.com/watch?v=RY_kMXEJZfk)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=RY_kMXEJZfk](https://www.youtube.com/watch?v=RY_kMXEJZfk)'
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we understood what a RESTful web service is. We looked at constraints
    that should be fulfilled to be called as a RESTful web service. Then we understood
    that REST is an architecture and it is a way to build stuff and it favors convention
    over configuration. We looked at HTTP verbs (methods) and looked at URL conventions.
    We understood that these are just conventions. HTTP verbs and URLs are used in
    RESTful web services; otherwise it is always up to the developer to provide the
    expected behavior as REST has conventions which are just considered as standard
    but it don't provide any implementation.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们了解了什么是RESTful网络服务。我们看了应该满足的约束条件，才能称为RESTful网络服务。然后我们了解到REST是一种架构，是一种构建东西的方式，它更青睐约定而不是配置。我们看了HTTP动词（方法）并看了URL约定。我们了解到这些只是约定。HTTP动词和URL在RESTful网络服务中使用；否则，开发人员始终可以提供预期的行为，因为REST有约定，这些约定只是被视为标准，但它不提供任何实现。
- en: In this chapter, we didn't talk about the implementation of RESTful web services.
    We just considered a case study of a typical blog and took examples of two resources
    of the blog and defined their endpoints with the expected responses. We also looked
    at HTTP response code but we didn't write actual code to implement these RESTful
    web services. We defined these endpoints, so we will see their implementation
    in the next chapters.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们没有讨论RESTful网络服务的实现。我们只考虑了一个典型博客的案例研究，并且以博客的两个资源为例，定义了它们的端点和预期的响应。我们还看了HTTP响应代码，但我们没有编写实际的代码来实现这些RESTful网络服务。我们定义了这些端点，所以我们将在下一章看到它们的实现。
- en: As this book is about building RESTful web services in the PHP7, in next chapter
    we will look at the features that came in PHP7\. PHP7 does not offer anything
    specific to RESTful web services but we will be utilizing some of the new features
    in PHP7 to write better and clean code to build RESTful web services.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这本书是关于在PHP7中构建RESTful网络服务，下一章我们将看一下PHP7中的新功能。PHP7并没有提供任何特定于RESTful网络服务的功能，但我们将利用PHP7中的一些新功能来编写更好、更干净的代码来构建RESTful网络服务。
- en: If you already know PHP7 well and don't wish to dig into that at the moment,
    you can skip [Chapter 2](a9520046-cc27-42d5-bb35-db474dd77a75.xhtml), *PHP7, To
    Code It Better*, and start [Chapter 3](75dfe538-b06c-46b9-a07f-8ac29a158975.xhtml),
    *Creating RESTful Endpoints*, where we will build RESTful web services.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经很了解PHP7，并且不想此刻深入研究，你可以跳过[第二章](a9520046-cc27-42d5-bb35-db474dd77a75.xhtml)，*PHP7，编写更好的代码*，并开始[第三章](75dfe538-b06c-46b9-a07f-8ac29a158975.xhtml)，*创建RESTful端点*，在那里我们将构建RESTful网络服务。
