- en: '*Chapter 4*: Making Direct C-Language Calls'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：进行直接的C语言调用'
- en: This chapter introduces the **Foreign Function Interface** (**FFI**). In this
    chapter, you will learn what FFI is all about, what it's good for, and how to
    use it. This information in this chapter is important for developers interested
    in rapid custom prototyping using direct C-language calls.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了**外部函数接口**（FFI）。在本章中，您将了解FFI的全部内容，它的作用以及如何使用它。本章的信息对于对使用直接C语言调用进行快速自定义原型设计感兴趣的开发人员非常重要。
- en: In this chapter, not only do you learn about the background behind introducing
    FFI into the PHP language, but you also learn how to incorporate C-language structures
    and functions directly into your code. Although—as you will learn—this should
    not be done to achieve greater speed, it does give you the ability to incorporate
    any C-language libraries directly into your PHP application. This ability opens
    the doors to an entire world of functionality hitherto unavailable to PHP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您不仅了解了将FFI引入PHP语言背后的背景，还学会了如何直接将C语言结构和函数合并到您的代码中。尽管——正如您将了解的那样——这并不是为了实现更快的速度，但它确实使您能够直接将任何C语言库合并到您的PHP应用程序中。这种能力为PHP打开了一个以前无法实现的功能世界。
- en: 'Topics covered in this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: Understanding FFI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解FFI
- en: Learning where to use FFI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会何时使用FFI
- en: Examining the FFI class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查FFI类
- en: Using FFI in an application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中使用FFI
- en: Working with PHP callbacks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PHP回调函数
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To examine and run the code examples provided in this chapter, the minimum
    recommended hardware is listed here:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查和运行本章提供的代码示例，以下是最低推荐的硬件要求：
- en: X86_64-based desktop PC or laptop
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于X86_64的台式PC或笔记本电脑
- en: 1 **gigabyte** (**GB**) free disk space
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1千兆字节（GB）的可用磁盘空间
- en: 4 GB of **random-access memory** (**RAM**)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 GB的随机存取内存（RAM）
- en: 500 **kilobits per second** (**Kbps**) or faster internet connection
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 500千位每秒（Kbps）或更快的互联网连接
- en: 'In addition, you will need to install the following software:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您需要安装以下软件：
- en: Docker
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Docker Compose
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Please refer to the *Technical requirements* section of [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013),
    *Introducing New PHP 8 OOP Features,* for more information on Docker and Docker
    Compose installation, as well as how to build the Docker container used to demonstrate
    code explained in this book. In this book, we refer to the directory in which
    you restored the sample code as `/repo`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[*第1章*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013)的*技术要求*部分，了解有关Docker和Docker
    Compose安装的更多信息，以及如何构建用于演示本书中代码的Docker容器。在本书中，我们将恢复示例代码的目录称为`/repo`。
- en: 'The source code for this chapter is located here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于此处：
- en: https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices
- en: We can now begin our discussion by gaining an understanding of FFI.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始讨论FFI的理解。
- en: Understanding FFI
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解FFI
- en: The main purpose of a FFI is to allow any given programming language the ability
    to incorporate code and function calls from external libraries written in other
    languages. An early example of this was the ability of 1980s microcomputers to
    incorporate assembler language into otherwise sluggish **Beginners' All-purpose
    Symbolic Instruction Code** (**BASIC**) programming language scripts using the
    `PEEK` and `POKE` commands. Unlike many other languages, PHP did not have this
    capability prior to PHP 7.4, although it had been under discussion since 2004.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: FFI的主要目的是允许任何给定的编程语言能够将来自其他语言编写的外部库的代码和函数调用合并到其中。早期的一个例子是20世纪80年代微型计算机能够使用`PEEK`和`POKE`命令将汇编语言合并到否则笨拙的**通用符号指令代码**（BASIC）编程语言脚本中。与许多其他语言不同，PHP在PHP
    7.4之前没有这种能力，尽管自2004年以来一直在讨论中。
- en: In order to gain a full understanding of FFI in PHP 8, it's necessary to digress
    and have a look at why it took so long for FFI to be fully adopted into the PHP
    language. It's also necessary to take a quick look at PHP extensions in general,
    and the ability to work with C-language code. We first examine the relationship
    between PHP and the C language.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了全面了解PHP 8中的FFI，有必要偏离一下，看看为什么FFI在PHP语言中被完全采用花了这么长时间。还有必要快速了解一下PHP扩展，以及与C语言代码的工作能力。我们首先研究PHP和C语言之间的关系。
- en: Relationship between PHP and the C language
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP和C语言之间的关系
- en: The **C language** was developed at Bell Labs by Dennis Ritchie in late 1972\.
    Since that time, despite the introduction of its object-oriented cousin C++, this
    language continues to dominate the programming language landscape. PHP itself
    is written in C; accordingly, the ability to directly load C-shared libraries,
    and to gain direct access to C functions and data structures, is an incredibly
    important addition to the PHP language.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**C语言**是由丹尼斯·里奇在1972年末在贝尔实验室开发的。自那时起，尽管引入了其面向对象的表亲C++，这种语言仍然主导着编程语言领域。PHP本身是用C编写的；因此，直接加载C共享库并直接访问C函数和数据结构的能力对于PHP语言来说是一个非常重要的补充。'
- en: The introduction of the FFI extension into the PHP language gives PHP the ability
    to load and directly work with both C structures and C functions. In order to
    make intelligent decisions about where and when you might want to use the FFI
    extension, let's look at PHP extensions in general.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将FFI扩展引入PHP语言使PHP能够加载并直接使用C结构和C函数。为了能够明智地决定何时何地使用FFI扩展，让我们先看一下一般的PHP扩展。
- en: Understanding PHP extensions
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解PHP扩展
- en: '**PHP extensions**, as the title implies, *extend* the PHP language. Each extension
    can add **object-oriented programming** (**OOP**) classes as well as procedural-level
    functions. Each extension serves a distinct logical purpose—for example, the `GD`
    extension handles graphic image manipulation, while the `PDO` extension handles
    database access.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**PHP扩展**，顾名思义，*扩展*了PHP语言。每个扩展都可以添加**面向对象编程**（**OOP**）类以及过程级函数。每个扩展都有一个独特的逻辑目的，例如，`GD`扩展处理图形图像处理，而`PDO`扩展处理数据库访问。'
- en: As an analogy, consider a hospital. In the hospital, you have departments such
    as Emergency, Surgery, Pediatrics, Orthopedics, Cardiac, X-Ray, and so forth.
    Each department is self-contained and serves a distinct purpose. Collectively
    the departments form the hospital. In a like manner, PHP is like the hospital,
    and its extensions are like the various departments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 类比一下，考虑一家医院。在医院里，您有急诊、外科、儿科、骨科、心脏科、X光等科室。每个科室都是独立的，有着不同的目的。这些科室共同构成了医院。同样地，PHP就像医院，它的扩展就像各种科室。
- en: Not all extensions are equal. Some extensions, referred to as **core extensions**,
    are always available when PHP is installed. Other extensions must be downloaded,
    compiled, and enabled manually. Let's now have a look at core extensions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有扩展都是相同的。一些扩展，称为**核心扩展**，在安装PHP时始终可用。其他扩展必须手动下载、编译和启用。现在让我们来看看核心扩展。
- en: Accessing PHP core extensions
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问PHP核心扩展
- en: 'PHP core extensions are directly included in the main PHP source code repository
    located here: https://github.com/php/php-src/tree/master/ext. If you go to this
    web page, you''ll see a list of subdirectories, as shown in the following screenshot.
    Each subdirectory contains C-language code comprising the particular extension:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: PHP核心扩展直接包含在主PHP源代码存储库中，位于此处：https://github.com/php/php-src/tree/master/ext。如果您转到此网页，您将看到一个子目录列表，如下面的屏幕截图所示。每个子目录包含特定扩展的C语言代码：
- en: '![Figure 4.1 – PHP core extensions seen on GitHub'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1-在GitHub上看到的PHP核心扩展'
- en: '](image/Figure_4.1_B16992.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.1_B16992.jpg)'
- en: Figure 4.1 – PHP core extensions seen on GitHub
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1-在GitHub上看到的PHP核心扩展
- en: Thus, when PHP is installed on a server, all of the core extensions are compiled
    and installed as well. We will now have a brief look at extensions that are not
    part of the core.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当PHP安装在服务器上时，所有核心扩展都会被编译和安装。现在我们来简要看看不属于核心的扩展。
- en: Examining non-core PHP extensions
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查非核心PHP扩展
- en: PHP extensions that are not part of the core are usually maintained by a specific
    vendor (**Microsoft** is an example). Very typically, non-core extensions are
    considered optional and are not widely used.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不属于核心的PHP扩展通常由特定供应商（**Microsoft**就是一个例子）维护。非核心扩展通常被认为是可选的，并且使用不广泛。
- en: 'Once a non-core extension starts getting used more and more frequently, it''s
    quite possible that it will eventually be migrated into the core. Examples of
    this are numerous. The most recent is the `JSON` extension: it''s now not only
    part of the core, but in PHP 8 this extension can no longer be disabled.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦非核心扩展开始被越来越频繁地使用，它很可能最终会被迁移到核心中。这方面的例子很多。最近的一个是`JSON`扩展：它现在不仅是核心的一部分，而且在PHP
    8中这个扩展不能再被禁用。
- en: It's also possible for a core extension to be removed. An example of this is
    the `mcrypt` extension. This was deprecated in PHP 7.1 as the underlying library
    upon which this extension relied had been *abandoned* for over 9 years. In PHP
    7.2, it was formally removed from the core. We now consider where to find non-core
    extensions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 核心扩展也可能被移除。其中一个例子是`mcrypt`扩展。这在PHP 7.1中被弃用，因为该扩展依赖的基础库已经*被遗弃*了9年以上。在PHP 7.2中，它正式从核心中移除。现在我们考虑在哪里找到非核心扩展。
- en: Finding non-core extensions
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找非核心扩展
- en: 'A logical question you might ask at this point is: *Where do you get non-core
    extensions?* In general, non-core extensions are available directly from the vendor,
    from [github.com](http://github.com), or from this website: http://pecl.php.net/.
    There have been complaints over the years that [pecl.php.net](http://pecl.php.net)
    contains outdated and unmaintained code. Although this is partially true, it is
    also true that up-to-date, actively maintained code does exist on this website.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可能会问一个合乎逻辑的问题：*您从哪里获取非核心扩展？*一般来说，非核心扩展可以直接从供应商、[github.com](http://github.com)或此网站：http://pecl.php.net/获取。多年来一直有人抱怨[pecl.php.net](http://pecl.php.net)包含过时和未维护的代码。尽管这在一定程度上是真的，但同样也存在最新的、积极维护的代码在这个网站上。
- en: 'As an example, if you have a look at the PHP extension for MongoDB, you''ll
    see that the last release was at the end of November 2020\. The following screenshot
    shows the **PHP Extension Community Library** (**PECL**) website page for this
    extension:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您查看MongoDB的PHP扩展，您会发现最新版本是在2020年11月底发布的。以下屏幕截图显示了此扩展的**PHP扩展社区库**（**PECL**）网站页面：
- en: '![Figure 4.2 – pecl.php.net page for the PHP MongoDB extension'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2-用于PHP MongoDB扩展的pecl.php.net页面'
- en: '](image/Figure_4.2_B16992.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.2_B16992.jpg)'
- en: Figure 4.2 – pecl.php.net page for the PHP MongoDB extension
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2-用于PHP MongoDB扩展的pecl.php.net页面
- en: 'In many cases, the vendor prefers to retain full control over the extension.
    This means you need to go to their website to obtain the PHP extension. An example
    of this is the PHP extension for Microsoft SQL Server, found at this **Uniform
    Resource Locator** (**URL**): https://docs.microsoft.com/en-us/sql/connect/php/download-drivers-php-sql-server?view=sql-server-ver15.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，供应商更倾向于保留对扩展的完全控制。这意味着您需要去他们的网站获取PHP扩展。一个例子是Microsoft SQL Server的PHP扩展，可以在此**统一资源定位符**（**URL**）找到：https://docs.microsoft.com/en-us/sql/connect/php/download-drivers-php-sql-server?view=sql-server-ver15.
- en: The key takeaway from this subsection is that the PHP language is enhanced through
    its extensions. The extensions are written in the C language. Accordingly, the
    ability to model the logic of a prototype extension directly inside a PHP script
    is extremely important. Let's now turn our attention to where you should use FFI.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节的关键要点是，PHP语言通过其扩展进行增强。这些扩展是用C语言编写的。因此，在PHP脚本中直接建模原型扩展的逻辑能力非常重要。现在让我们把注意力转向应该在哪里使用FFI。
- en: Learning where to use FFI
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习何时使用FFI
- en: The potential for importing C libraries directly into PHP is truly staggering.
    One of the PHP core developers actually used the FFI extension to bind PHP to
    the C-language **TensorFlow** machine learning platform!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将C库导入到PHP中的潜力真是令人震惊。PHP核心开发人员中的一位实际上使用FFI扩展将PHP绑定到C语言**TensorFlow**机器学习平台！
- en: Tip
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For information on the TensorFlow machine learning platform, head over to this
    web page: https://www.tensorflow.org/. To see how PHP can be bound to this library,
    have a look here: [https://github.com/dstogov/php-tensorflow](https://github.com/dstogov/php-tensorflow).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有关TensorFlow机器学习平台的信息，请访问此网页：https://www.tensorflow.org/。要了解PHP如何与此库绑定，请查看这里：[https://github.com/dstogov/php-tensorflow](https://github.com/dstogov/php-tensorflow)。
- en: As we show you in this section, the FFI extension is not a magic solution for
    all of your needs. This section discusses the main strengths and weaknesses of
    the FFI extension, as well as giving you guidelines for its use. A myth we debunk
    in this section is that making direct C-language calls using the FFI extension
    speeds up PHP 8 program execution. First, let's have a look at what took so long
    to get the FFI extension into PHP.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节中所展示的，FFI扩展并不是解决所有需求的神奇解决方案。本节讨论了FFI扩展的主要优势和劣势，并为您提供了使用指南。我们在本节中揭穿的一个神话是，使用FFI扩展直接调用C语言来加速PHP
    8程序执行。首先，让我们看看将FFI扩展纳入PHP中花费了这么长时间。
- en: Adopting FFI into PHP
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将FFI引入PHP
- en: The first FFI extension was actually introduced for PHP 5 on the PECL website
    (https://pecl.php.net/) in January 2004 by PHP core developers **Wez Furlong**
    and **Ilia Alshanetsky**. The project never passed its Alpha stage, however, and
    development was dropped within a month.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，第一个FFI扩展是由PHP核心开发人员**Wez Furlong**和**Ilia Alshanetsky**于2004年1月在PECL网站（https://pecl.php.net/）上为PHP
    5引入的。然而，该项目从未通过Alpha阶段，并在一个月内停止了开发。
- en: As PHP developed and matured over the next 14 years, it became apparent that
    PHP would benefit from the ability to rapidly prototype potential extensions directly
    within a PHP script. Without this capability, PHP was in danger of falling behind
    other languages such as Python and Ruby.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 随着PHP在接下来的14年中的发展和成熟，人们开始意识到PHP将受益于在PHP脚本中快速原型化潜在扩展的能力。如果没有这种能力，PHP有可能落后于其他语言，比如Python和Ruby。
- en: In the past, lacking a fast-prototyping capability, extension developers were
    forced to compile their full extension and install it using `pecl`, before being
    able to test it in a PHP script. In some cases, developers had to *recompile PHP
    itself* just to test their new extension! In contrast, the FFI extension allows
    a developer to *directly place* C function calls inside the PHP script for immediate
    testing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，由于缺乏快速原型能力，扩展开发人员被迫在能够在PHP脚本中测试之前编译完整的扩展并使用`pecl`安装它。在某些情况下，开发人员甚至不得不*重新编译PHP本身*来测试他们的新扩展！相比之下，FFI扩展允许开发人员*直接在*PHP脚本中放置C函数调用以进行即时测试。
- en: Starting with PHP 7.4 and carried on into PHP 8, an improved version of the
    FFI extension was proposed by core developer Dmitry Stogov. After a compelling
    proof of concept (see the preceding *Tip* box regarding PHP binding to the TensorFlow
    machine learning platform), this FFI extension version was incorporated into the
    PHP language.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从PHP 7.4开始，并持续到PHP 8，核心开发人员Dmitry Stogov提出了改进版本的FFI扩展。在令人信服的概念验证之后（请参阅有关PHP绑定到TensorFlow机器学习平台的前面的*提示*框），这个FFI扩展版本被纳入了PHP语言中。
- en: Tip
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The original FFI PHP extension can be found here: http://pecl.php.net/package/ffi.
    For more information on the revised FFI proposal, see the following article: https://wiki.php.net/rfc/ffi.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的FFI PHP扩展可以在这里找到：http://pecl.php.net/package/ffi。有关修订后的FFI提案的更多信息，请参阅以下文章：https://wiki.php.net/rfc/ffi。
- en: Let's now examine why FFI should not be used to gain speed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看为什么不应该使用FFI来提高速度。
- en: Do not use FFI for speed
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要使用FFI来提高速度
- en: Because the FFI extension allows PHP direct access to C-language libraries,
    there is a temptation to believe that your PHP applications will suddenly operate
    blindingly fast, at machine-language speeds. Unfortunately, this is not the case.
    The FFI extension needs to first open the given C library and then parse and pseudo-compile
    a `FFI` instance before execution. The FFI extension then acts as a bridge between
    the C-library code and the PHP script.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因为FFI扩展允许PHP直接访问C语言库，人们很容易相信你的PHP应用程序会突然以机器语言速度运行得非常快。不幸的是，事实并非如此。FFI扩展需要首先打开给定的C库，然后在执行之前解析和伪编译`FFI`实例。然后FFI扩展充当C库代码和PHP脚本之间的桥梁。
- en: 'It might be of relief to some readers that relatively sluggish FFI extension
    performance is not limited to PHP 8\. Other languages suffer the same throttling
    effect when using their own FFI implementations. There''s an excellent performance
    comparison, based upon the *Ary 3 benchmark*, available here: https://wiki.php.net/rfc/ffi#php_ffi_performance.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对一些读者来说，相对缓慢的FFI扩展性能不仅限于PHP 8。其他语言在使用自己的FFI实现时也会遇到相同的限制效果。这里有一个基于*Ary 3基准*的优秀性能比较，可以在这里找到：https://wiki.php.net/rfc/ffi#php_ffi_performance。
- en: If you have a look at the table shown on the web page just referenced, you'll
    see that the Python FFI implementation performed the benchmark in 0.343 seconds,
    whereas running the same benchmark using only native Python code executed in 0.212
    seconds.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看刚刚引用的网页上显示的表格，您会发现Python FFI实现在0.343秒内完成了基准测试，而仅使用本机Python代码运行相同的基准测试只需0.212秒。
- en: Looking at the same table, the PHP 7.4 FFI extension ran the benchmark in 0.093
    seconds (30 times faster than Python!), whereas the same benchmark running with
    just native PHP code executed in 0.040 seconds.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 查看相同的表，PHP 7.4 FFI扩展在0.093秒内运行了基准测试（比Python快30倍！），而仅使用本机PHP代码运行的相同基准测试在0.040秒内执行。
- en: 'The next logical question is: *Why should you use the FFI extension at all?*
    This is covered in the next section.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个逻辑问题是：*为什么你应该使用FFI扩展？* 这将在下一节中介绍。
- en: Why use the FFI extension?
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要使用FFI扩展？
- en: 'The answer to the preceding question is simple: this extension is primarily
    designed for rapid **PHP extension prototyping**. PHP extensions are the lifeblood
    of the language. Without extensions, PHP is *just another programming language*.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对上一个问题的答案很简单：这个扩展主要是为了快速**PHP扩展原型**。PHP扩展是语言的命脉。没有扩展，PHP只是*另一种编程语言*。
- en: When senior-level developers first embark upon a programming project, they need
    to determine the best language for the project. One key factor is how many extensions
    are available and how actively these are maintained. There is generally a direct
    correlation between the number of actively maintained extensions and the long-term
    success potential of a project using that language.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当高级开发人员首次着手进行编程项目时，他们需要确定项目的最佳语言。一个关键因素是可用的扩展数量以及这些扩展的活跃程度。通常，活跃维护的扩展数量与使用该语言的项目的长期成功潜力之间存在直接关系。
- en: So, if there's a way to speed up extension development, the long-term viability
    of the PHP language itself is improved. The value the FFI extension brings to
    the PHP language is its ability to test an extension prototype directly in a PHP
    script without having to go through the entire compile-link-load-test cycle.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果有一种方法可以加快扩展开发的速度，那么PHP语言本身的长期可行性就得到了改善。FFI扩展为PHP语言带来的价值在于，它能够在不必经历整个编译-链接-加载-测试周期的情况下，直接在PHP脚本中测试扩展原型。
- en: Another use case for the FFI extension, outside of rapid prototyping, is a way
    to allow PHP direct access to obscure or proprietary C code. An example of this
    would be the custom C code written to control factory machines. In order to have
    PHP run the factory, the FFI extension can be used to bind PHP directly to the
    C libraries controlling the various machines.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: FFI扩展的另一个用例，除了快速原型设计之外，是允许PHP直接访问模糊或专有的C代码的一种方式。一个例子是编写用于控制工厂机器的自定义C代码。为了让PHP运行工厂，可以使用FFI扩展将PHP直接绑定到控制各种机器的C库。
- en: Finally, another use case for this extension is to use it to *preload* C libraries,
    potentially reducing memory consumption. Before we show usage examples, let's
    have a look at the `FFI` class and its methods.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个扩展的另一个用例是用它来*预加载* C 库，可能会减少内存消耗。在我们展示使用示例之前，让我们来看看`FFI`类及其方法。
- en: Examining the FFI class
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查FFI类
- en: 'As you learned in this chapter, not every developer has a need to use the FFI
    extension. Having direct experience with the FFI extension deepens your understanding
    of the internals of the PHP language, and this deepened understanding can have
    a beneficial impact on your career as a PHP developer: it''s quite possible that
    at some point in the future, you will be employed by a company that has developed
    a custom PHP extension. Knowing how to operate the FFI extension in this situation
    allows you to develop new features for a custom PHP extension, as well as helping
    you to troubleshoot extension problems.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在本章中所学到的，不是每个开发人员都需要使用FFI扩展。直接使用FFI扩展可以加深您对PHP语言内部的理解，这种加深的理解对您作为PHP开发人员的职业生涯可能会产生积极影响：很可能在将来的某个时候，您将被一家开发了自定义PHP扩展的公司雇佣。在这种情况下，了解如何操作FFI扩展可以让您为自定义PHP扩展开发新功能，同时帮助您解决扩展问题。
- en: 'The `FFI` class consists of 20 methods that fall into four broad categories,
    outlined as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`FFI`类包括20个方法，分为四个广泛的类别，如下所述：'
- en: '**Creational**: Methods in this category create instances of classes available
    from the FFI extension **application programming interface** (**API**).'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建性**：此类别中的方法创建了FFI扩展**应用程序编程接口**（**API**）中可用的类的实例。'
- en: '**Comparison**: Comparison methods are designed to compare C data values.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较**：比较方法旨在比较C数据值。'
- en: '**Informational**: This set of methods gives you metadata on C data values,
    including size and *alignment*.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息性**：这组方法为您提供有关C数据值的元数据，包括大小和*对齐*。'
- en: '**Infrastructural**: Infrastructural methods are used to carry out logistical
    operations such as copying, populating, and releasing memory.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施**：基础设施方法用于执行后勤操作，如复制、填充和释放内存。'
- en: Tip
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The complete FFI class is documented here: [https://www.php.net/manual/en/class.ffi.php](https://www.php.net/manual/en/class.ffi.php).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的FFI类文档在这里：[https://www.php.net/manual/en/class.ffi.php](https://www.php.net/manual/en/class.ffi.php)。
- en: Interestingly, all `FFI` class methods can be called in a static manner. It's
    now time to take a dive into the details and usage of the class associated with
    FFI, starting with the *creational* methods.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，所有`FFI`类方法都可以以静态方式调用。现在是时候深入了解与FFI相关的类的细节和用法了，首先是*创建性*方法。
- en: Working with FFI creational methods
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FFI创建方法
- en: 'The `FFI` methods that fall into the *creational* category are designed to
    produce either `FFI` instances directly or instances of classes provided by the
    FFI extension. When working with C functions made available through the FFI extension,
    it''s important to recognize that you cannot directly pass native PHP variables
    into the function and expect it to work. The data must first be either created
    as a `FFI` data type or imported into a `FFI` data type, before the `FFI` data
    type can be passed into the C function. In order to create a `FFI` data type,
    use one of the functions summarized in *Table 4.1*, shown here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 属于*创建*类别的FFI方法旨在直接产生`FFI`实例或FFI扩展提供的类的实例。在使用FFI扩展提供的C函数时，重要的是要认识到不能直接将本地的PHP变量传递给函数并期望它能工作。数据必须首先被创建为`FFI`数据类型或导入到`FFI`数据类型中，然后才能将`FFI`数据类型传递给C函数。要创建`FFI`数据类型，请使用下面总结的函数之一，如下所示：
- en: '![Table 4.1 – Summary of FFI class creational methods'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![表4.1 – FFI类创建方法总结'
- en: '](image/Table_4.1_B16992.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_4.1_B16992.jpg)'
- en: Table 4.1 – Summary of FFI class creational methods
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 – FFI类创建方法总结
- en: Both the `cdef()` and `scope()` methods produce a direct `FFI` instance, while
    the other methods produce object instances that can be used to create a `FFI`
    instance. `string()` is used to extract a given number of byes from a native C
    variable. Let's have a look at creating and using `FFI\CType` instances.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdef()`和`scope()`方法都会产生一个直接的`FFI`实例，而其他方法会产生可以用来创建`FFI`实例的对象实例。`string()`用于从本地C变量中提取给定数量的字节。让我们来看看如何创建和使用`FFI\CType`实例。'
- en: Creating and using FFI\CType instances
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和使用FFI\CType实例
- en: It's extremely important to note that once the `FFI\CType` instance has been
    created, *do not* simply assign a value to it as if it were a native PHP variable.
    Doing so would simply overwrite the `FFI\CType` instance due to the fact that
    PHP is loosely typed. Instead, to assign a scalar value to a `FFI\CType` instance,
    use its `cdata` property.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的一点是，一旦创建了`FFI\CType`实例，*不要*简单地将一个值赋给它，就像它是一个本地的PHP变量一样。这样做只会由于PHP是弱类型语言而简单地覆盖`FFI\CType`实例。相反，要将标量值赋给`FFI\CType`实例，使用它的`cdata`属性。
- en: 'The following example creates a `$arr` C array. The native C array is then
    populated with values up to its maximum size, after which we use a simple `var_dump()`
    to view its contents. We will proceed as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子创建了一个`$arr` C数组。然后用值填充本地C数组，直到达到最大大小，之后我们使用一个简单的`var_dump()`来查看它的内容。我们将按照以下步骤进行：
- en: 'First, we create the array using `FFI::arrayType()`. As arguments, we supply
    a `FFI::type()` method and dimensions. We then use `FFI::new()` to create the
    `FFI\Ctype` instance. The code is illustrated in the following snippet:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`FFI::arrayType()`来创建数组。作为参数，我们提供了一个`FFI::type()`方法和维度。然后我们使用`FFI::new()`来创建`FFI\Ctype`实例。代码如下所示：
- en: '[PRE0]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, we could also combine the operations into a single statement,
    as shown here:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，我们也可以将操作合并成一个单一的语句，如下所示：
- en: '`$arr = FFI::new(FFI::type("char[3][3]"));`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`$arr = FFI::new(FFI::type("char[3][3]"));`'
- en: 'We then initialize three variables that provide test data, as shown in the
    following code snippet. Note that the native PHP `count()` function works on `FFI\CData`
    array types:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们初始化了三个提供测试数据的变量，如下面的代码片段所示。请注意，本地的PHP`count()`函数适用于`FFI\CData`数组类型：
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now populate it with values, much as with a PHP array, except that we
    need to use the `cdata` property in order to retain the element as a `FFI\CType`
    instance. The code is shown in the following snippet:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以用值填充它，就像用PHP数组一样，只是我们需要使用`cdata`属性来保留元素作为`FFI\CType`实例。代码如下所示：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding example, we use nested `for()` loops to populate the two-dimensional
    3 x 3 array with letters of the alphabet. If we now execute a simple `var_dump()`,
    we get the following result:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用嵌套的`for()`循环来填充二维的3 x 3数组，用字母表的字母。如果我们现在执行一个简单的`var_dump()`，我们会得到以下结果：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first important thing to note from the output is that the indices are all
    integers. The second takeaway from the output is that this is clearly not a native
    PHP array. `var_dump()` shows us that each array element is a `FFI\CData` instance.
    Also, note that C-language strings are treated like an array.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中要注意的第一件重要的事情是，索引都是整数。从输出中得到的第二个要点是，这显然不是一个本地的PHP数组。`var_dump()`告诉我们，每个数组元素都是一个`FFI\CData`实例。还要注意的是，C语言字符串被视为数组。
- en: 'Because the array is of type `char`, we can use `FFI::string()` to display
    one of the rows. Here is a command that produces an *ABC* response:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数组的类型是`char`，我们可以使用`FFI::string()`来显示其中一行。下面是一个产生*ABC*响应的命令：
- en: '`echo FFI::string($arr[0], 3);`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo FFI::string($arr[0], 3);`'
- en: 'Any attempt to supply the `FFI\CData` instance to a PHP function that takes
    an array as an argument is doomed to failure, even if it is defined as an array
    type. In the following code snippet, note the output if we add this command to
    the preceding code block:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 任何尝试将`FFI\CData`实例提供给一个以数组作为参数的PHP函数都注定失败，即使它被定义为数组类型。在下面的代码片段中，注意如果我们将这个命令添加到前面的代码块中的输出：
- en: '`echo implode('','', $arr);`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo implode('','', $arr);`'
- en: 'As you can see from the output shown next, because the data type is not `array`,
    `implode()` issues a fatal error. Here is the resulting output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从下面的输出中可以看到，因为数据类型不是`array`，`implode()`会发出致命错误。以下是结果输出：
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You know now how to create and use `FFI\CType` instances. Let's now turn our
    attention to creating `FFI` instances.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何创建和使用`FFI\CType`实例了。现在让我们转向创建`FFI`实例。
- en: Creating and using FFI instances
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和使用FFI实例
- en: As mentioned in the chapter introduction, the FFI extension facilitates rapid
    prototyping. Accordingly, using the FFI extension, you can develop the C functions
    designed to go into your new extension one at a time, and test them right away
    inside a PHP application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如章节介绍中所述，FFI扩展有助于快速原型设计。因此，使用FFI扩展，你可以逐个开发设计用于新扩展的C函数，并立即在PHP应用程序中进行测试。
- en: Important note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The FFI extension does not compile C code. In order to use a C function with
    the FFI extension, you must first compile the C code into a shared library using
    a C compiler. You will learn how to do this in the last section in this chapter,
    *Using FFI in an application*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: FFI扩展不会编译C代码。为了在FFI扩展中使用C函数，您必须首先使用C编译器将C代码编译成共享库。您将在本章的最后一节“在应用程序中使用FFI”中学习如何做到这一点。
- en: In order to bridge between PHP and a native C-library function call, you need
    to create a `FFI` instance. The FFI extension needs you to supply a C definition
    that defines the C function signature and the C library that you plan to use.
    Both `FFI::cdef()` and `FFI::scope()` can be used to directly create `FFI` instances.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在PHP和本地C库函数调用之间建立桥梁，您需要创建一个`FFI`实例。FFI扩展需要您提供一个定义了C函数签名和您计划使用的C库的C定义。`FFI::cdef()`和`FFI::scope()`都可以直接创建`FFI`实例。
- en: 'The following example uses `FFI::cdef()` to bind two native C-library functions.
    This is what happens:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`FFI::cdef()`绑定了两个本地C库函数。具体操作如下：
- en: 'The first native method, `srand()`, is used to seed a randomization sequence.
    `rand()`, the other native C function, calls the next number in the sequence.
    The `$key` variable holds the final product of the randomization. `$size` represents
    the number of random numbers to call. The code is illustrated in the following
    snippet:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个本地方法`srand()`用于初始化随机化序列。另一个本地C函数`rand()`调用序列中的下一个数字。`$key`变量保存了随机化的最终产品。`$size`表示要调用的随机数的数量。代码如下所示：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We then create the `FFI` instance by invoking `cdef()` and identifying the
    native C functions in a string `$code`, taken out of the `libc.so.6` native C
    library, as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过调用`cdef()`并在字符串`$code`中标识本地C函数来创建`FFI`实例，该字符串取自`libc.so.6`本地C库，如下所示：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We then seed the randomization by calling `srand()`. Then, in a loop, we invoke
    the `rand()` native C library function to produce a random number. We use the
    `sprintf()` native PHP function to convert the resulting integer to hex, the output
    of which is appended to `$key`, which is echoed. The code can be seen here:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们通过调用`srand()`来初始化随机化。然后，在循环中，我们调用`rand()`本地C库函数来生成一个随机数。我们使用`sprintf()`本地PHP函数将生成的整数转换为十六进制，然后将其附加到`$key`，并将其输出。代码如下所示：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And here is the output of the preceding code snippet. Note that the resulting
    value could be used as a random key:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码片段的输出。请注意，生成的值可以用作随机密钥：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the output, you see a string of concatenated random integers converted to
    hexadecimal. Note that the resulting value changes each time the script is invoked.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，您会看到一串连接的随机整数转换为十六进制的字符串。请注意，每次调用脚本时，结果值都会发生变化。
- en: Tip
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: For true randomization, it might be better to just use the `random_int()` native
    PHP function. There are also excellent key-generation functions that form part
    of the `openssl` extension. The example shown here is primarily designed to familiarize
    you with FFI extension usage.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于真正的随机化，最好只使用`random_int()`本地PHP函数。`openssl`扩展中还有出色的密钥生成函数。这里展示的示例主要是为了让您熟悉FFI扩展的用法。
- en: Important note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The FFI extension also includes two additional creational methods: `FFI::load()`
    and `FFI::scope()`. `FFI::load()` is used to directly load C-function definitions
    from a C header (`*.h`) file during the **preloading** process. `FFI::scope()`
    makes the preloaded C functions available for use via the FFI extension. For more
    information on preloading, have a look at a complete preloading example in the
    FFI documentation here: [https://www.php.net/manual/en/ffi.examples-complete.php](https://www.php.net/manual/en/ffi.examples-complete.php).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: FFI扩展还包括两种额外的创建方法：`FFI::load()`和`FFI::scope()`。`FFI::load()`用于在**预加载**过程中直接从C头文件（`*.h`）加载C函数定义。`FFI::scope()`使预加载的C函数可通过FFI扩展使用。有关预加载的更多信息，请查看FFI文档中的完整预加载示例：[https://www.php.net/manual/en/ffi.examples-complete.php](https://www.php.net/manual/en/ffi.examples-complete.php)。
- en: Let's now have a look at FFI extension functions used for comparison between
    native C data types.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看用于比较本地C数据类型的FFI扩展函数。
- en: Comparing data using FFI
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FFI比较数据
- en: It's important to keep in mind that when you create a C-language data structure
    using the FFI extension, it exists outside of your PHP application. As you saw
    in the preceding example (see the *Creating and using FFI\CType instances* section),
    PHP can interact with the C data to a certain extent. However, for comparison
    purposes, it's best to use `FFI::memcmp()`, as native PHP functions might return
    inconsistent results.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用FFI扩展创建C语言数据结构时，它存在于PHP应用程序之外。正如您在前面的示例中看到的（请参阅*创建和使用FFI\CType实例*部分），PHP可以在一定程度上与C数据交互。但是，为了比较目的，最好使用`FFI::memcmp()`，因为本地PHP函数可能返回不一致的结果。
- en: 'The two comparison functions available in the FFI extension are summarized
    here in *Table 4.2*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: FFI扩展中提供的两个比较函数在*表4.2*中总结如下：
- en: '![Table 4.2 – Summary of FFI class comparison methods'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![表4.2 – FFI类比较方法总结'
- en: '](image/Table_4.2_B16992.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_4.2_B16992.jpg)'
- en: Table 4.2 – Summary of FFI class comparison methods
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2 – FFI类比较方法总结
- en: '`FFI::isNull()` can be used to determine whether or not the `FFI\CData` instance
    is `NULL`. What is more interest is `FFI::memcmp()`. Although this function operates
    in the same manner as the **spaceship operator** (`<=>`), it accepts a *third
    argument* that represents how many bytes you wish to include in the comparison.
    The following example illustrates this usage:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`FFI::isNull()`可用于确定`FFI\CData`实例是否为`NULL`。更有趣的是`FFI::memcmp()`。虽然这个函数的操作方式与**太空船操作符**（`<=>`）相同，但它接受一个*第三个参数*，表示您希望在比较中包含多少字节。以下示例说明了这种用法：'
- en: 'We first define a set of four variables representing `FFI\CData` instances
    that can contain up to six characters and populate the instances with sample data,
    as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先定义一组代表`FFI\CData`实例的四个变量，这些实例可以包含多达六个字符，并使用示例数据填充这些实例，如下所示：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Recall that the C language treats character data as an array, so we can''t
    just directly assign a string, even if using the `cdata` property. Accordingly,
    we need to define an anonymous function that populates the instances with letters
    of the alphabet. We use the following code to do this:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，C语言将字符数据视为数组，因此即使使用`cdata`属性，我们也不能直接分配字符串。因此，我们需要定义一个匿名函数，用字母填充实例。我们使用以下代码来实现这一点：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we use the function to populate the four `FFI\CData` instances with differing
    sets of letters, as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用该函数将四个`FFI\CData`实例填充为不同的字母集，如下所示：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now use the `FFI::string()` method to display the contents thus far,
    as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`FFI::string()`方法来显示到目前为止的内容，如下所示：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is the output from the `printf()` statements:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`printf()`语句的输出：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see from the output, the values of `$c` and `$d` are the same. The
    first three characters for `$a` and `$b` are the same, but the last three are
    different.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输出中可以看出，`$c`和`$d`的值是相同的。`$a`和`$b`的前三个字符相同，但最后三个字符不同。
- en: 'At this point, if we were to try to use the spaceship operator (`<=>`) for
    comparison, the result would be the following:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，如果我们尝试使用太空船操作符（`<=>`）进行比较，结果将如下：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Likewise, an attempt to use `strcmp()`, even though the data is a character
    type, the result would be as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，尝试使用`strcmp()`，即使数据是字符类型，结果如下：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Accordingly, our only alternative is to use `FFI::memcmp()`. In the set of
    comparisons shown here, note that the third argument is `6`, indicating PHP should
    compare up to six characters:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们唯一的选择是使用`FFI::memcmp()`。在这组比较中，注意第三个参数是`6`，表示PHP应该比较最多六个字符：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As expected, the output is the same as using the spaceship operator on native
    PHP strings, as shown here:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如预期的那样，输出与在原生PHP字符串上使用太空船操作符的输出相同，如下所示：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note what happens if we restrict the comparison to only three characters. Here
    is another `FFI::memcmp()` comparison added to the code block, setting the third
    argument to `3`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，如果将比较限制为仅三个字符，会发生什么。这是添加到代码块中的另一个`FFI::memcmp()`比较，将第三个参数设置为`3`：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see from the output shown here, by restricting `memcmp()` to only
    three characters, `$a` and `$b` are considered equal because they both start with
    the same three characters, `a`, `b`, and `c`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里显示的输出中可以看出，通过将`memcmp()`限制为仅三个字符，`$a`和`$b`被视为相等，因为它们都以相同的三个字符`a`、`b`和`c`开头：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The most important thing to take away from this illustration is that you need
    to find a balance between the number of characters to compare and the nature of
    the data you are comparing. The fewer characters compared, the faster the overall
    operation. However, if the nature of the data is such that erroneous results are
    possible, you must increase the character count and suffer a slight loss in performance.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中最重要的是，您需要在要比较的字符数和要比较的数据性质之间找到平衡。比较的字符数越少，整体操作速度越快。然而，如果数据的性质可能导致错误的结果，您必须增加字符数，并在性能上稍微损失。
- en: Let's now have a look at gathering information from FFI extension data.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看如何从FFI扩展数据中收集信息。
- en: Extracting information from FFI extension data
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从FFI扩展数据中提取信息
- en: 'When you are using `FFI` instances and native C data structures, native PHP
    informational methods such as `strlen()` and `ctype_digit()` do not yield useful
    information. Accordingly, the FFI extension includes three methods designed to
    produce information about FFI extension data. These three methods are summarized
    here in *Table 4.3*:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`FFI`实例和原生C数据结构时，原生PHP信息方法（如`strlen()`和`ctype_digit()`）无法提供有用的信息。因此，FFI扩展包括三种方法，旨在生成有关FFI扩展数据的信息。这三种方法在*表4.3*中总结如下：
- en: '![Table 4.3 – Summary of FFI class informational methods'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![表4.3 - FFI类信息方法总结'
- en: '](image/Table_4.3_B16992.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_4.3_B16992.jpg)'
- en: Table 4.3 – Summary of FFI class informational methods
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.3 - FFI类信息方法总结
- en: We first look at `FFI::typeof()`, after which we dive into the other two methods.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们看看`FFI::typeof()`，然后再深入了解其他两种方法。
- en: Determining the nature of FFI data using FFI::typeof()
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用FFI::typeof()确定FFI数据的性质
- en: 'Here is an example that illustrates the use of `FFI::typeof()`. The example
    also demonstrates that native PHP informational functions do not yield useful
    results when dealing with FFI data. This is what we do:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，说明了如何使用`FFI::typeof()`。该示例还演示了处理FFI数据时，原生PHP信息函数无法产生有用的结果。我们这样做：
- en: 'First, we define a `$char` C string and populate it with the first six letters
    of the alphabet, as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个`$char` C字符串，并用字母表的前六个字母填充它，如下所示：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then attempt to use `strlen()` to get the length of the string. In the following
    code snippet, note the use of `$t::class`: this is the equivalent of `get_class($t)`.
    This usage is only available in PHP 8 and above:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们尝试使用`strlen()`来获取字符串的长度。在下面的代码片段中，请注意使用`$t::class`：这相当于`get_class($t)`。此用法仅适用于PHP
    8及以上版本：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The result in PHP 7.4 is a `Warning` message. However, in PHP 8, if you pass
    anything other than a string to `strlen()`, a fatal `Error` message is thrown.
    Here is the PHP 8 output at this point:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PHP 7.4中的结果是一个`Warning`消息。然而，在PHP 8中，如果将除字符串以外的任何内容传递给`strlen()`，将抛出致命的`Error`消息。这是此时的PHP
    8输出：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In a similar manner, an effort to use `ctype_alnum()` is made, as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，尝试使用`ctype_alnum()`，如下所示：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is the output from the `echo` command shown in *Step 4*:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是在*步骤4*中显示的`echo`命令的输出：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can clearly see, we are not getting any useful information about the
    FFI data using native PHP functions! However, using `FFI::typeof()`, as shown
    here, returns better results:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显然，我们无法使用原生PHP函数获取有关FFI数据的有用信息！然而，使用`FFI::typeof()`，如下所示，会返回更好的结果：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is the output from `var_dump()`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`var_dump()`的输出：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see from the final output, we now have useful information! Let's
    now have a look at the other two FFI informational methods.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从最终输出中可以看出，我们现在有了有用的信息！现在让我们来看看另外两种FFI信息方法。
- en: Making use of FFI::alignof() and FFI::sizeof()
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用FFI::alignof()和FFI::sizeof()
- en: Before getting into a practical example showing the use of these two methods,
    it's important to understand what exactly is meant by **alignment**. In order
    to understand alignment, you need to have a basic understanding of how memory
    is organized in most computers.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入展示这两种方法的实际示例之前，重要的是要理解**对齐**的确切含义。为了理解对齐，您需要对大多数计算机中内存的组织方式有基本的了解。
- en: RAM is still the fastest way to temporarily store information used during a
    program run cycle. Your computer's **central processing unit** (**CPU**) moves
    information in and out of memory as the program executes. Memory is organized
    in parallel arrays. The alignment value returned by `alignof()` would be how many
    bytes can be obtained at once from parallel slices of the aligned memory arrays.
    In older computers, a value of 4 was typical. For most modern microcomputers,
    values of 8 or 16 (or greater) are common.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: RAM仍然是在程序运行周期内临时存储信息的最快方式。您计算机的**中央处理单元**（**CPU**）在程序执行时将信息从内存中移入和移出。内存以并行数组的形式组织。`alignof()`返回的对齐值将是可以一次从对齐内存数组的并行切片中获取多少字节。在旧计算机中，值为4是典型的。对于大多数现代微型计算机，常见的值为8或16（或更大）。
- en: 'Let''s now have a look at an example that illustrates how these two FFI extension
    informational methods are used, and how that information can produce a performance
    improvement. This is how we''ll proceed:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个示例，说明了这两种FFI扩展信息方法的使用以及这些信息如何产生性能改进。我们将按照以下步骤进行：
- en: 'First, we create a `FFI` instance, `$ffi`, in which we define two C structures
    labeled `Good` and `Bad`. Notice in the following code snippet that both structures
    have the same properties; however, the properties are arranged in a different
    order:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`FFI`实例`$ffi`，在其中定义了两个标记为`Good`和`Bad`的C结构。请注意，在下面的代码片段中，这两个结构具有相同的属性；然而，这些属性的排列顺序不同。
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then extract the two structures from `$ffi`, as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们从`$ffi`中提取这两个结构，如下所示：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `var_dump()` output is shown here:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var_dump()`输出如下所示：'
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then use the two informational methods to report on the two data structures,
    as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用这两个信息方法来报告这两个数据结构，如下所示：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last four lines of output from this code example are shown here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例的最后四行输出如下所示：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see from the output, the return from `FFI::alignof()` tells us that
    the alignment blocks are 8 bytes wide. However, you can also see that the size
    in bytes taken up by the `Bad` structure is 50% larger than the size required
    for the `Good` structure. Since the two data structures have exactly the same
    properties, any developer in their right mind would choose the `Good` structure.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，`FFI::alignof()`的返回告诉我们对齐块的宽度为8字节。然而，您还可以看到，`Bad`结构占用的字节数比`Good`结构所需的空间大50%。由于这两个数据结构具有完全相同的属性，任何理智的开发人员都会选择`Good`结构。
- en: From this example, you can see that the FFI extension informational methods
    are able to give us an idea on how best to structure our C data in order to produce
    the most efficient results.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，您可以看到FFI扩展信息方法能够让我们了解如何最有效地构造我们的C数据。
- en: Tip
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For an excellent discussion on the difference between `sizeof()` and `alignof()`
    in the C language, see this article: https://stackoverflow.com/questions/11386946/whats-the-difference-between-sizeof-and-alignof.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C语言中`sizeof()`和`alignof()`的区别的出色讨论，请参阅这篇文章：https://stackoverflow.com/questions/11386946/whats-the-difference-between-sizeof-and-alignof。
- en: You now have an understanding of what the FFI extension informational methods
    are and have seen some examples of their use. Let's now have a look at the FFI
    extension methods pertaining to infrastructure.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了FFI扩展信息方法是什么，并且已经看到了它们的使用示例。现在让我们来看看与基础设施相关的FFI扩展方法。
- en: Using FFI infrastructural methods
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FFI基础设施方法
- en: FFI extension infrastructural category methods can be thought of as *behind-the-scenes*
    components that support the infrastructure needed for C function binding to work
    properly. As we have stressed throughout this chapter, the FFI extension is needed
    if you wish to directly access C data structures from within a PHP application.
    Thus, if you need to do the equivalent of a PHP `unset()` statement to release
    memory, or a PHP `include()` statement to include external program code, the FFI
    extension infrastructural methods provide the bridge between native C data and
    PHP.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: FFI扩展基础类别方法可以被视为支持C函数绑定所需的*幕后*组件。正如我们在本章中一直强调的那样，如果您希望直接从PHP应用程序中访问C数据结构，则需要FFI扩展。因此，如果您需要执行类似于PHP
    `unset()`语句以释放内存，或者PHP `include()`语句以包含外部程序代码，FFI扩展基础方法提供了本地C数据和PHP之间的桥梁。
- en: '*Table 4.4*, shown here, summarizes methods in this category:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*表4.4*，如下所示，总结了这个类别中的方法：'
- en: '![Table 4.4 – FFI class infrastructural methods'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![表4.4 – FFI类基础方法'
- en: '](image/Table_4.4_B16992.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_4.4_B16992.jpg)'
- en: Table 4.4 – FFI class infrastructural methods
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.4 – FFI类基础方法
- en: Let's first have a look at `FFI::addr()`, `free()`, `memset()`, and `memcpy()`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们先看看`FFI::addr()`、`free()`、`memset()`和`memcpy()`。
- en: Working with FFI::addr(), free(), memset(), and memcpy()
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用FFI::addr()、free()、memset()和memcpy()
- en: PHP developers often assign a value to a variable by **reference**. This allows
    a change in one variable to be automatically reflected in another. The use of
    references is especially useful when passing parameters to a function or method
    where you need to return more than a single value. Passing by reference allows
    the function or method to return an unlimited number of values.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: PHP开发人员经常通过**引用**给变量赋值。这允许一个变量的更改自动反映在另一个变量中。当传递参数给需要返回多个值的函数或方法时，引用的使用尤其有用。通过引用传递允许函数或方法返回无限数量的值。
- en: The `FFI::addr()` method creates a C pointer to an existing `FFI\CData` instance.
    Just as with a PHP reference, any changes made to the data associated with the
    pointer will likewise be changed.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`FFI::addr()`方法创建一个指向现有`FFI\CData`实例的C指针。就像PHP引用一样，对指针关联的数据所做的任何更改也将被更改。'
- en: In the process of building an example using the `FFI::addr()` method, we also
    introduce you to `FFI::memset()`. This function is much like the `str_repeat()`PHP
    function, in that it (`FFI::memset()`) populates a specified number of bytes with
    a specific value. In this example, we use `FFI::memset()` to populate a C character
    string with letters of the alphabet.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`FFI::addr()`方法构建示例的过程中，我们还向您介绍了`FFI::memset()`。这个函数很像`str_repeat()`PHP函数，因为它（`FFI::memset()`）用特定值填充指定数量的字节。在这个例子中，我们使用`FFI::memset()`来用字母表的字母填充C字符字符串。
- en: In this subsection, we also have a look at `FFI::memcpy()`. This function is
    used to copy data from one `FFI\CData` instance to another. Unlike the `FFI::addr()`
    method, `FFI::memcpy()` creates a clone that has no connection to the source of
    the copied data. In addition, we introduce `FFI::free()`, a method used to release
    a pointer created using `FFI::addr()`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们还将介绍`FFI::memcpy()`。这个函数用于将数据从一个`FFI\CData`实例复制到另一个实例。与`FFI::addr()`方法不同，`FFI::memcpy()`创建一个克隆，与复制数据源没有任何连接。此外，我们介绍了`FFI::free()`，这是一个用于释放使用`FFI::addr()`创建的指针的方法。
- en: 'Let''s have a look at how these FFI extension methods can be used, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些FFI扩展方法如何使用，如下所示：
- en: 'First, a `FFI\CData` instance, `$arr`, is created, consisting of a C string
    of six characters. Note in the following code snippet the use of `FFI::memset()`,
    another infrastructural method, to populate the string with **American Standard
    Code for Information Interchange** (**ASCII**) code 65: the letter `A`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`FFI\CData`实例`$arr`，由六个字符的C字符串组成。请注意，在下面的代码片段中，使用了`FFI::memset()`，另一个基础设施方法，用**美国信息交换标准代码**（**ASCII**）码65：字母`A`填充字符串：
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `echo` result using the `FFI::string()` method is shown here:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`FFI::string()`方法的`echo`结果如下所示：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As you can see from the output, six instances of ASCII code 65 (the letter
    `A`) appears. We then create another `FFI\CData` instance, `$arr2`, and use `FFI::memcpy()`
    to copy six characters from one instance to the other, as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输出中可以看到，出现了六个ASCII码65（字母`A`）的实例。然后我们创建另一个`FFI\CData`实例`$arr2`，并使用`FFI::memcpy()`将一个实例中的六个字符复制到另一个实例中，如下所示：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Unsurprisingly, the output is identical to the output in *Step 2*, as we can
    see here:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 毫不奇怪，输出与*步骤2*中的输出完全相同，如下所示：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we create a C pointer to `$arr`. Note that when pointers are assigned,
    they appear to the native PHP `var_dump()` function as array elements. We can
    then change the value of array element `0`, and use `FFI::memset()` to populate
    it with the letter `B`. The code is shown in the following snippet:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个指向`$arr`的C指针。请注意，当指针被赋值时，它们会出现在本机PHP `var_dump()`函数中作为数组元素。然后我们可以改变数组元素`0`的值，并使用`FFI::memset()`将其填充为字母`B`。代码如下所示：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is the output associated with the remaining code shown in *Step 5*:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是*步骤5*中剩余代码的输出：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see from the output, we first have a `BBBBBB` string. You can see
    that the pointer is in the form of a PHP array. The original `FFI\CData` instance,
    `$arr`, has now changed to letter `B`. However, the preceding output also clearly
    shows that the copy, `$arr2`, is not affected by changes made to `$arr` or its
    `$ref[0]` pointer.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看到，我们首先有一个`BBBBBB`字符串。您可以看到指针的形式是一个PHP数组。原始的`FFI\CData`实例`$arr`现在已经改变为字母`B`。然而，前面的输出也清楚地显示了复制的`$arr2`不受对`$arr`或其`$ref[0]`指针所做的更改的影响。
- en: 'Finally, in order to release the pointer created using `FFI::addr()`, we use
    `FFI::free()`. This method is much like the native PHP `unset()` function but
    is designed to work with C pointers. Here is the last line of code added to our
    example:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了释放使用`FFI::addr()`创建的指针，我们使用`FFI::free()`。这个方法很像本机PHP的`unset()`函数，但是设计用于处理C指针。这是我们添加到示例的最后一行代码：
- en: '`FFI::free($ref);`'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`FFI::free($ref);`'
- en: Now that you have an idea about how to work with C pointers and about populating
    C data with information, let's have a look at how to do type casting with a `FFI\CData`
    instance.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何使用C指针以及如何使用信息填充C数据，让我们看看如何使用`FFI\CData`实例进行类型转换。
- en: Learning about FFI::cast()
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习关于FFI::cast()
- en: 'In PHP, the process of **type casting** occurs quite frequently. It''s used
    when PHP is asked to perform operations involving dissimilar data types. A classic
    example of this is shown in the following block of code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，**类型转换**的过程经常发生。当PHP被要求执行涉及不同数据类型的操作时，就会使用它。下面是一个经典的例子：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this trivial example, `$a` is assigned a data type of `int` (integer) and
    `$b` is assigned a type of `string`. The `echo` statement requires PHP to first
    typecast `$b` to `int`, perform the addition, and then typecast the result to
    `string`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个微不足道的例子中，`$a`被分配了`int`（整数）的数据类型，`$b`被分配了`string`的类型。`echo`语句要求PHP首先将`$b`强制转换为`int`，执行加法，然后将结果强制转换为`string`。
- en: 'Native PHP also allows the developer to force the data type by prepending the
    desired data type in parentheses in front of the variable or expression. The rewritten
    example from the previous code snippet might appear as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本机PHP还允许开发人员通过在变量或表达式前面的括号中添加所需的数据类型来强制数据类型。从前面代码片段的重写示例可能如下所示：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Forced type casting makes your intention extremely clear to other developers
    who make use of your code. It also guarantees results in that forcing the type
    cast exerts greater control over the flow of your code, and does not rely upon
    PHP default behavior.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 强制类型转换使您的意图对其他使用您代码的开发人员非常清晰。它还保证了结果，因为强制类型转换对代码流的控制更大，并且不依赖于PHP的默认行为。
- en: 'The FFI extension has a similar capability in the form of the `FFI::cast()`
    method. As you have seen throughout this chapter, FFI extension data is isolated
    from PHP and is immune to PHP type casting. In order to force the data type, you
    can use `FFI::cast()` to return a parallel `FFI\CData` type as required. Let''s
    see how to do that in the following steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: FFI扩展具有类似的功能，即`FFI::cast()`方法。正如您在本章中看到的，FFI扩展数据与PHP隔离，并且不受PHP类型转换的影响。为了强制数据类型，您可以使用`FFI::cast()`返回所需的并行`FFI\CData`类型。让我们看看如何在以下步骤中做到这一点：
- en: 'In this example, we create a `FFI\CData` instance, `$int1`, of type `int`.
    We use its `cdata` property to assign a value `123`, as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`int`类型的`FFI\CData`实例`$int1`。我们使用它的`cdata`属性来赋值`123`，如下所示：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As you can see from the output shown here, the integer value of `123`, when
    typecast to `bool` (Boolean), shows up in the output as `1`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您从这里显示的输出中看到的，将`123`的整数值强制转换为`bool`（布尔值），在输出中显示为`1`：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next we create a `FFI\CData` instance, `$int2`, of type `int` and assign a
    value `123`. We then typecast it to `float` and back again to `int`, as illustrated
    in the following code snippet:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个`int`类型的`FFI\CData`实例`$int2`，并赋值`123`。然后我们将其强制转换为`float`，再转回`int`，如下面的代码片段所示：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output from the last three lines is quite gratifying. We see that our original
    value `123` is represented as `1.7235971111195E-43`. When typecast back to `int`,
    our original value is restored. Here is the output from the last three lines:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后三行的输出非常令人满意。我们看到我们的原始值`123`被表示为`1.7235971111195E-43`。当强制转换回`int`时，我们的原始值被恢复。以下是最后三行的输出：
- en: '[PRE43]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The FFI extension, as with the C language in general, does not allow all types
    to be converted. As an example, in the last block of code, we attempt to typecast
    a `FFI\CData` instance, `$float2`, of type `float` to type `char`, as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FFI扩展与C语言一般一样，不允许所有类型进行转换。例如，在上一段代码中，我们尝试将类型为`float`的`FFI\CData`实例`$float2`强制转换为`char`类型，如下所示：
- en: '[PRE44]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The results are disastrous! As you can see from the output shown here, a `FFI\Exception`
    is thrown:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果是灾难性的！正如您从这里显示的输出中看到的，抛出了一个`FFI\Exception`：
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this section, we addressed a series of FFI extension methods that create
    FFI extension object instances, compare values, gather information, and work with
    the C data infrastructure created. You learned there are FFI extension methods
    that mirror these same capabilities in the native PHP language. In the next section,
    we review a practical example that incorporates a C-function library into a PHP
    script using the FFI extension.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了一系列FFI扩展方法，这些方法创建了FFI扩展对象实例，比较值，收集信息，并处理所创建的C数据基础设施。您了解到有一些FFI扩展方法在本机PHP语言中具有相同的功能。在下一节中，我们将回顾一个实际的例子，将一个C函数库整合到PHP脚本中，使用FFI扩展。
- en: Using FFI in an application
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中使用FFI
- en: Any shared C library (generally with a `*.so` extension) can be included in
    a PHP application using the FFI extension. If you plan to work with any of the
    core PHP libraries or libraries produced when PHP extensions are installed, it's
    important to note that you have the ability to modify the behavior of the PHP
    language itself.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 任何共享的C库（通常具有`*.so`扩展名）都可以使用FFI扩展包含在PHP应用程序中。如果您计划使用任何核心PHP库或在安装PHP扩展时生成的库，重要的是要注意您有能力修改PHP语言本身的行为。
- en: Before we examine how that works, let's first have a look at incorporating an
    external C library into a PHP script using the FFI extension.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们研究它是如何工作之前，让我们首先看看如何将外部C库整合到PHP脚本中，使用FFI扩展。
- en: Integrating an external C library into a PHP script
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将外部C库整合到PHP脚本中
- en: 'For the purposes of illustration, we use a simple function that might have
    originated from a **Computer Science 101** (**CS101**) class: the famous **bubble
    sort**. This algorithm is widely used in beginner''s computer science classes
    because it''s easy to follow.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，我们使用了一个简单的函数，可能源自**计算机科学101**（**CS101**）课程：著名的**冒泡排序**。这个算法在初学者的计算机科学课程中被广泛使用，因为它很容易理解。
- en: Important note
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The **bubble sort** is an extremely inefficient sort algorithm and has long
    been superseded by faster sorting algorithms such as the **shell sort**, **quick
    sort**, or **merge sort** algorithms. Although there is no authoritative reference
    for the bubble-sort algorithm, you can read a good general discussion of it here:
    [https://en.wikipedia.org/wiki/Bubble_sort](https://en.wikipedia.org/wiki/Bubble_sort).'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**冒泡排序**是一种极其低效的排序算法，长期以来一直被更快的排序算法（如**希尔排序**、**快速排序**或**归并排序**算法）所取代。虽然没有冒泡排序算法的权威参考，但您可以在这里阅读到一个很好的一般讨论：[https://en.wikipedia.org/wiki/Bubble_sort](https://en.wikipedia.org/wiki/Bubble_sort)。'
- en: 'In this subsection, we do not go through details of the algorithm. Rather,
    the purpose of this subsection is to demonstrate how to take an existing C library
    and incorporate one of its functions into a PHP script. We now show you the original
    C source code, how to convert it into a shared library, and—finally—how to incorporate
    the library into PHP using FFI. Here''s what we''ll do:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小节中，我们不会详细介绍算法。相反，这个小节的目的是演示如何将现有的C库并入到PHP脚本中的一个函数。我们现在向您展示原始的C源代码，如何将其转换为共享库，最后如何使用FFI将库整合到PHP中。我们将做以下事情：
- en: 'The first step, of course, is to compile the C code into object code. Here
    is the bubble-sort C code used for this example:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，第一步是将C代码编译为对象代码。以下是本例中使用的冒泡排序C代码：
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We then compile the C code into object code using the GNU C compiler (included
    in the Docker image used for this course), as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用GNU C编译器（包含在本课程使用的Docker镜像中）将C代码编译为对象代码，如下所示：
- en: '`gcc -c -Wall -Werror -fpic bubble.c`'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcc -c -Wall -Werror -fpic bubble.c`'
- en: 'Next, we incorporate the object code into a shared library. This step is necessary
    as the FFI extension is only able to access shared libraries. We run the following
    code to do this:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将对象代码合并到一个共享库中。这一步是必要的，因为FFI扩展只能访问共享库。我们运行以下代码来完成这一步：
- en: '`gcc -shared -o libbubble.so bubble.o`'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcc -shared -o libbubble.so bubble.o`'
- en: 'We are now ready to define the PHP script that uses our new shared library.
    We begin by defining a function that shows output from a `FFI\CData` array, as
    follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备定义使用我们新共享库的PHP脚本。我们首先定义一个函数，该函数显示来自`FFI\CData`数组的输出，如下所示：
- en: '[PRE47]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The critical part is next: defining the `FFI` instance. We use `FFI::cdef()`
    to accomplish this and supply two arguments. The first argument is the function
    signature, and the second argument is a path to our newly created shared library.
    Both arguments can be seen in the following code snippet:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是关键部分：定义`FFI`实例。我们使用`FFI::cdef()`来完成这个任务，并提供两个参数。第一个参数是函数签名，第二个参数是我们新创建的共享库的路径。这两个参数都可以在以下代码片段中看到：
- en: '[PRE48]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We then create a `FFI\CData` element as an integer array with 16 values populated
    with random integers, using the `rand()` function. The code is shown in the following
    snippet:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个`FFI\CData`元素，作为一个包含16个随机整数的整数数组，使用`rand()`函数进行填充。代码如下所示：
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we display the contents of the array before the sort, perform the
    sort, and display the contents after. Note in the following code snippet that
    we execute the sort using a call to `bubble_sort()` from the `FFI` instance:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们显示了排序之前数组的内容，执行了排序，并显示了排序后的内容。请注意，在以下代码片段中，我们使用`FFI`实例调用`bubble_sort()`来执行排序：
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output, as you might expect, shows an array of random integers before the
    sort. After the sort, the values are in order. Here is the output from the code
    shown in *Step 7*:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出，正如您所期望的那样，在排序之前显示了一组随机整数。排序后，数值是有序的。以下是*步骤7*中代码的输出：
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now that you have an idea how to integrate an external C library into a PHP
    application using the FFI extension, we turn to our last topic: PHP callbacks.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您已经了解了如何使用FFI扩展将外部C库集成到PHP应用程序中，我们转向最后一个主题：PHP回调。
- en: Working with PHP callbacks
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PHP回调
- en: As we mentioned at the beginning of this section, it's possible to use the FFI
    extension to incorporate shared C libraries that are part of the actual PHP language
    (or its extensions). This integration is important as it allows you to read and
    write native PHP data in your C library by accessing the C data structures defined
    in the PHP shared C libraries.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节开头提到的，可以使用FFI扩展来整合实际PHP语言（或其扩展）中的共享C库。这种整合很重要，因为它允许您通过访问PHP共享C库中定义的C数据结构来读取和写入本机PHP数据。
- en: The purpose of this subsection, however, is not to show you how to create a
    PHP extension. Rather, in this subsection, we introduce you to the FFI extension's
    ability to override native PHP language functionality. This ability is referred
    to as a **PHP callback**. Before we get into the implementation details, we must
    first examine potential dangers associated with this ability.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本小节的目的并不是向您展示如何创建PHP扩展。相反，在本小节中，我们向您介绍了FFI扩展覆盖本机PHP语言功能的能力。这种能力被称为**PHP回调**。在我们深入实现细节之前，我们必须首先检查与这种能力相关的潜在危险。
- en: Understanding the dangers inherent to PHP callbacks
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解PHP回调的潜在危险
- en: It's important to understand that the C functions defined in the various PHP
    shared libraries are often used by multiple PHP functions. Accordingly, if you
    override one of the low-level functions at the C level, you might experience unexpected
    behavior in your PHP application.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，PHP共享库中定义的C函数通常被多个PHP函数使用。因此，如果您在C级别覆盖了其中一个低级函数，您可能会在PHP应用程序中遇到意外行为。
- en: Another known issue is that overriding native PHP C functions has a high probability
    of producing **memory leaks**. Over time, a long-running application that uses
    such overrides can fail, and can potentially crash the server!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个已知问题是，覆盖本机PHP C函数很有可能会产生**内存泄漏**。随着时间的推移，使用这种覆盖的长时间运行的应用程序可能会失败，并且有可能导致服务器崩溃！
- en: A final consideration is that the PHP callback capability is not supported on
    all FFI platforms. Accordingly, although the code might work on a Linux server,
    it might not work (or might not work the same) on a Windows server.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要考虑的是，PHP回调功能并非在所有FFI平台上都受支持。因此，尽管代码可能在Linux服务器上运行，但在Windows服务器上可能无法运行（或可能无法以相同的方式运行）。
- en: Tip
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Rather than using a FFI PHP callback to override native PHP C library functionality,
    it might be easier, faster, and safer to just define your own PHP function!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用FFI PHP回调来覆盖本机PHP C库功能，也许更容易、更快速、更安全的方法是只定义自己的PHP函数！
- en: Now that you have an idea of the dangers involved using PHP callbacks, let's
    have a look at a sample implementation.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您已经了解了使用PHP回调涉及的危险，让我们来看一个示例实现。
- en: Implementing a PHP callback
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现PHP回调
- en: 'In the following example, the `zend_write` internal PHP shared library C function
    is overridden using a callback that adds a **line feed** (**LF**) to the end of
    the output. Note that this override affects any native PHP function dependent
    upon it, including `echo`, `print`, `printf`: in other words, any PHP function
    that produces direct output. To implement a PHP callback, follow these steps:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，使用回调覆盖了`zend_write`内部PHP共享库的C函数，该回调在输出末尾添加了**换行符**（**LF**）。请注意，此覆盖会影响任何依赖它的本机PHP函数，包括`echo`、`print`、`printf`：换句话说，任何产生直接输出的PHP函数。要实现PHP回调，请按照以下步骤进行：
- en: 'First, we define a `FFI` instance using `FFI::cdef()`. The first argument is
    the function signature of `zend_write`. The code is shown in the following snippet:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`FFI::cdef()`定义了一个`FFI`实例。第一个参数是`zend_write`的函数签名。代码如下所示：
- en: '[PRE52]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We then add code to confirm that, unmodified, `echo` does not add an extra
    LF at the end. You can see the code here:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加了代码来确认未经修改的`echo`不会在末尾添加额外的换行符。您可以在这里看到代码：
- en: '[PRE53]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Unsurprisingly, the output produces `ABCNext line`. There are no carriage returns
    or LFs present in the output, which is shown here:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 毫不奇怪，输出产生了`ABCNext line`。输出中没有回车或换行符，如下所示：
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We then clone the pointer to `zend_write` into the `$orig_zend_write` variable.
    If we didn''t do this, we would be unable to use the original function! The code
    is shown here:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将指向`zend_write`的指针克隆到`$orig_zend_write`变量中。如果我们不这样做，我们将无法使用原始函数！代码如下所示：
- en: '`$orig_zend_write = clone $zend->zend_write;`'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: $orig_zend_write = clone $zend->zend_write;
- en: 'Next, we produce a PHP callback in the form of an anonymous function that overrides
    the original `zend_write` function. In the function, we invoke the original `zend_write`
    function and append a LF to its output, as follows:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们以匿名函数的形式生成一个PHP回调，覆盖原始的`zend_write`函数。在函数中，我们调用原始的`zend_write`函数并在其输出中添加一个LF，如下所示：
- en: '[PRE55]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The remaining code reruns the `echo` command shown in the preceding step, as
    we can see here:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的代码重新运行了前面步骤中显示的`echo`命令，如下所示：
- en: '[PRE56]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following output demonstrates that the PHP `echo` command now produces
    a LF at the end of each command:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下输出演示了PHP `echo` 命令现在在每个命令的末尾产生一个LF：
- en: '[PRE57]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It's also important to note that modifying the PHP library C-language `zend_write`
    function has an impact on all PHP native functions using this C-language function.
    This includes `print()`, `printf()` (and its variants), and so forth.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，修改PHP库C语言`zend_write`函数会影响使用这个C语言函数的所有PHP本机函数。这包括`print()`，`printf()`（及其变体）等。
- en: This concludes our discussion of using the FFI extension in a PHP application.
    You now know how to incorporate native C functions from an external shared library.
    You also know how to substitute a PHP callback for a native PHP core or extension
    shared library, giving you the potential to alter the behavior of the PHP language
    itself.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对在PHP应用程序中使用FFI扩展的讨论。您现在知道如何将外部共享库中的本机C函数整合到PHP中。您还知道如何用PHP回调替换本机PHP核心或扩展共享库，从而有可能改变PHP语言本身的行为。
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about the FFI, its history, and how it can be used
    to facilitate rapid PHP extension prototyping. You also learned that although
    the FFI extension should not be used to improve speed, it also serves the purpose
    of allowing your PHP application to directly call native C functions from an external
    C library. The power of this ability was demonstrated through an example that
    called a bubble-sort function from an external C library. This same capability
    can be extended to encompass any of the thousands of C libraries available, including
    machine learning, optical character recognition, communications, encryption; *ad
    infinitum*.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了FFI及其历史，以及如何使用它来促进快速的PHP扩展原型设计。您还了解到，虽然FFI扩展不应该用于提高速度，但它也可以让您的PHP应用程序直接调用外部C库的本机C函数。这种能力的强大之处通过一个调用外部C库的冒泡排序函数的示例得到了展示。这种能力也可以扩展到包括机器学习、光学字符识别、通信、加密等成千上万个C库，*无穷无尽*。
- en: In this chapter, you acquired a deeper understanding of how PHP itself operates
    at the C- language level. You learned how to create and directly use C-language
    data structures, giving you the ability to interact, and even override, the PHP
    language itself. In addition, you now have an idea how to incorporate the functionality
    of any C-language library directly into a PHP application. A further benefit of
    this knowledge is that it serves to enhance your career prospects if you find
    a job with a company that either plans to develop, or has already developed, its
    own custom PHP extension.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将更深入地了解PHP本身在C语言级别的运行方式。您将学习如何创建并直接使用C语言数据结构，使您能够与PHP语言本身进行交互，甚至覆盖PHP语言本身。此外，您现在已经知道如何将任何C语言库的功能直接整合到PHP应用程序中。这种知识的另一个好处是，如果您找到一家计划开发自己的自定义PHP扩展或已经开发了自定义PHP扩展的公司，它将有助于增强您的职业前景。
- en: The next chapter marks the beginning of a new section of the book, *PHP 8 Tricks*.
    In the next section, you will learn about backward-compatibility issues when upgrading
    to PHP 8\. The next chapter specifically addresses backward-compatibility issues
    with respect to OOP.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章标志着书的新部分*PHP 8 技巧*的开始。在下一节中，您将学习升级到PHP 8时的向后兼容性问题。下一章具体讨论了面向对象编程方面的向后兼容性问题。
