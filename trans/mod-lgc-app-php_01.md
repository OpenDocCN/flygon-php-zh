# 第一章 传统应用程序

在其最简单的定义中，传统应用程序是指您作为开发人员从其他人那里继承的任何应用程序。它是在您到达之前编写的，您在构建过程中几乎没有或根本没有决策权。

然而，在开发人员中，“传统”这个词有更多的含义。它带有组织不良、难以维护和改进、难以理解、未经测试或无法测试等负面含义。该应用程序作为产品提供收入，但作为程序，它是脆弱的，对变化敏感。

由于这是一本专门讨论基于 PHP 的传统应用程序的书，我将提供一些我在实践中看到的 PHP 特定特征。对于我们的目的，在 PHP 中的传统应用程序是指符合以下两个或更多描述的应用程序：

+   它使用直接放置在 Web 服务器文档根目录中的页面脚本。

+   它在某些目录中有特殊的索引文件，以防止访问这些目录。

+   它在一些文件的顶部有特殊的逻辑，如果某个值未设置，则会使用`die()`或`exit()`。

+   它的架构是基于包含而不是基于类或对象的。

+   它的类相对较少。

+   存在的任何类结构都是杂乱的、不连贯的，或者是不一致的。

+   它更多地依赖于函数而不是类方法。

+   它的页面脚本、类和函数将模型、视图和控制器的关注点合并到同一个范围内。

+   它显示出一次或多次未完成的重写尝试的证据，有时作为失败的框架集成。

+   它没有为开发人员运行的自动化测试套件。

这些特征对于任何曾经处理过非常古老的 PHP 应用程序的人来说可能很熟悉。它们描述了我所说的典型 PHP 应用程序。

# 典型 PHP 应用程序

大多数 PHP 开发人员并没有接受过正式的编程培训，或者几乎完全是自学的。他们通常是从其他非技术专业转入这门语言。不知何故，他们被赋予了创建网页的任务，因为他们被视为组织中最懂技术的人。由于 PHP 是一种宽容的语言，并且在没有太多纪律的情况下赋予了很多权力，因此很容易在没有太多培训的情况下制作工作的网页甚至应用程序。

这些和其他因素强烈影响了典型 PHP 应用程序的基础。它们通常不是用流行的全栈框架甚至微框架编写的。相反，它们通常是一系列页面脚本，直接放置在 Web 服务器文档根目录中，客户端可以直接浏览。需要重复使用的任何功能都已经被收集到一系列“包含”文件中。有用于常见配置和设置、页眉和页脚、常见表单和内容、函数定义、导航等的“包含”文件。

典型 PHP 应用程序中对“包含”文件的依赖是我称之为基于包含的架构的原因。传统应用程序在程序的各个部分之间使用“包含”调用来将它们耦合成一个整体。这与面向类的架构形成对比，即使应用程序不遵循良好的面向对象编程原则，至少行为被捆绑到类中。

## 文件结构

典型的基于包含的 PHP 应用程序通常看起来像这样：

```php
**/path/to/docroot/**
bin/                         # command-line tools
cache/                    # cache files
common/                # commonly-used include files
classes/                 # custom classes
Image.php            #
Template.php       #
functions/             # custom functions
db.php                 #
log.php                #
cache.php           #
setup.php            # configuration and setup
css/                     # stylesheets
img/                    # images
index.php           # home page script
js/                       # JavaScript
lib/                     # third-party libraries
log/                    # log files
page1.php        # other page scripts
page2.php        #
page3.php        #
sql/                   # schema migrations
sub/                  # sub-page scripts
index.php         #
subpage1.php #
subpage2.php #
theme/             # site theme files
header.php      # a header template
footer.php        # a footer template
nav.php           # a navigation template ~~
```

所示的结构是一个简化的示例。有许多可能的变化。在一些传统应用程序中，我曾看到成百上千的主要页面脚本和数十个子目录，这些子目录有它们自己独特的层次结构用于额外的页面。关键是传统应用程序通常位于文档根目录中，具有用户可以直接浏览的页面脚本，并且使用“包含”文件来管理大部分程序行为，而不是类和对象。

## 页面脚本

传统应用程序将使用单独的页面脚本作为公共行为的访问点。每个页面脚本负责设置全局环境，执行请求的逻辑，然后将输出传递给客户端。

附录 A，*典型的传统页面脚本*包含了一个真实应用程序中典型传统页面脚本的经过消毒、匿名化的版本。我已经自作主张使缩进保持一致（原本，缩进有些随机），并将其包装在 60 个字符中，以便更好地适应电子阅读器屏幕。现在去看看它，但要小心。如果你变瞎了或者因此经历了创伤后应激障碍，我不会对此负责！当我们检查它时，我们发现了许多使维护和改进变得困难的问题：

+   `include`语句执行设置和呈现逻辑

+   内联函数定义

+   全局变量

+   模型、视图和控制器逻辑都集成在一个单独的脚本中

+   信任用户输入

+   可能的 SQL 注入漏洞

+   可能的跨站脚本漏洞

+   未引用的数组键生成通知

+   未用大括号包裹的`if`块（稍后在块中添加一行实际上不会成为块的一部分）

+   复制和粘贴重复

附录 A，*典型的传统页面脚本*示例相对来说比传统页面脚本要温和一些。我见过其他脚本，其中混合了 JavaScript 和 CSS 代码，还有远程文件包含和各种安全漏洞。它也只有（！）大约 400 行长。我见过数千行长的页面脚本，生成了几种不同的页面变体，都包含在一个单独的`switch`语句中，有十几个`case`条件。

## 重写还是重构？

许多开发人员在面对典型的 PHP 应用程序时，只能忍受一段时间，然后就想要放弃并从头开始重写。从轨道上摧毁它；这是这些热情洋溢、充满活力的程序员的呐喊口号。其他开发人员，由于他们的死亡行军经历而失去了热情，对这样的建议感到谨慎和警惕。他们完全意识到代码库很糟糕，但他们所知道的魔鬼（或在我们的情况下，代码）总比他们不知道的魔鬼好。

## 重写的利弊

完全重写是一个非常诱人的想法。主张重写的开发人员觉得他们将能够第一次就做对所有正确的事情。他们将能够编写单元测试，强制执行最佳实践，根据现代模式定义分离关注点，并使用最新的框架，甚至编写自己的框架（因为他们最了解自己的需求）。因为现有应用程序可以作为参考实现，他们确信在重写应用程序时几乎不需要试错。所需的行为已经存在；所有开发人员需要做的就是将它们复制到新系统中。在现有系统中难以实现的行为可以作为重写的一部分从一开始就添加进去。

尽管重写听起来很诱人，但它充满了许多危险。Joel Spolsky 在 2000 年关于旧版网景导航器网络浏览器重写的评论如下：

| | *网景公司犯了软件公司可能犯的最严重的战略错误，决定从头开始重写他们的代码。路易·蒙图利是网景导航器原始版本的五位编程超级巨星之一，他给我发电子邮件说，我完全同意，这是我从网景辞职的主要原因之一。这个决定让网景损失了 3 年时间。这是三年时间，公司无法添加新功能，无法应对来自 Internet Explorer 的竞争威胁，不得不坐视微软完全吞掉他们的市场份额。* | |
| --- | --- | --- |
| --*乔尔·斯波尔斯基，《网景疯了》* |

网景因此破产了。

乔什·科尔讲述了一个类似的故事，涉及 TextMate：

| *Macromates 是一家成功的文本编辑器 Textmate 的独立公司，决定重写 Textmate 2 的代码基础。他们花了 6 年时间才发布了一个测试版，这在当今的时间里是一个漫长的时间，他们失去了很多市场份额。当他们发布测试版时，已经太迟了，6 个月后他们放弃了这个项目，并将其推到 Github 上作为一个开源项目。* |   |
| --- | --- |
| --*乔什·科尔，《TextMate 2 和为什么不应该重写你的代码》* |

弗雷德·布鲁克斯称对进行完全重写的冲动为第二系统效应。他在 1975 年写道：

| *第二个是人类设计的最危险的系统。…一般的倾向是过度设计第二个系统，使用在第一个系统上小心翼翼地搁置的所有想法和装饰。…第二系统效应…倾向于完善那些由于基本系统假设的变化而已经过时的技术。…项目经理如何避免第二系统效应？坚持要求至少有两个系统经验的高级架构师。* |   |
| --- | --- |
| --*弗雷德·布鲁克斯，《神话般的程序员月工作》，第 53-58 页。* |

开发人员在四十年前和今天是一样的。我期待他们在未来四十年也是一样的；人类始终是人类。过度自信、不够悲观、对历史的无知以及成为自己的客户的愿望都会让开发人员很容易地产生理性化，认为这一次会有所不同，当他们尝试重写时。

## 为什么重写不起作用？

重写很少成功的原因有很多，但我只会集中在一个一般原因上：资源、知识、沟通和生产力的交集。（一定要阅读《神话般的程序员月工作》（第 13-26 页），了解与将资源和计划安排视为可互换元素相关的问题的出色描述。）

与所有事物一样，我们只有有限的资源来对抗重写项目。组织中只有一定数量的开发人员。这些开发人员将不得不*同时*对现有程序进行维护*和*编写程序的全新版本。任何参与一个项目的开发人员将无法参与另一个项目。

### 上下文切换问题

一个想法是让现有的开发人员在旧应用程序和新应用程序上花一部分时间。然而，将开发人员在两个项目之间移动不会带来生产力的均衡分配。由于上下文切换的认知负荷，开发人员在每个项目上的生产力将不到一半。

### 知识问题

为了避免在维护和重写之间切换开发人员带来的生产力损失，组织可能会尝试雇佣更多的开发人员。然后一些人可以专门负责旧项目，另一些人可以专门负责新项目。不幸的是，这种方法揭示了 F·A·哈耶克所说的知识问题。最初应用于经济领域，知识问题同样适用于编程。

如果我们让新开发人员参与重写项目，他们将不了解现有系统、现有问题、业务目标，甚至可能不了解进行重写的最佳实践。他们将需要在这些方面接受培训，很可能是由现有的开发人员进行培训。这意味着已经被指定维护现有程序的现有开发人员将不得不花费大量时间向新员工传授知识。所涉及的时间量是非常可观的，这种知识的传递将不得不持续，直到新开发人员和现有开发人员一样熟练。这意味着资源的线性增加导致生产力的不成比例增加：程序员数量增加 100%将导致产出不到 50%的增加，有时甚至更少。

或者，我们可以让现有的开发人员参与重写项目，让新员工负责维护现有程序。这也暴露了一个知识问题，因为新开发人员完全不熟悉该系统。他们将从哪里获取他们需要做工作的知识？当然是从现有的开发人员那里，他们仍然需要花费宝贵的时间向新员工传授知识。我们再次看到，开发人员的线性增加导致生产力的不成比例增加。

### 时间表问题

为了解决知识问题和相关的沟通成本，有些人可能会觉得处理项目的最佳方式是将所有现有的开发人员都专门用于重写，并延迟对现有系统的维护和升级，直到重写完成。这是一个很大的诱惑，因为开发人员会急于解决自己的问题，并成为自己的客户-对他们想要拥有的功能和他们想要进行的修复感到兴奋。这些愿望会导致他们高估自己进行全面重写的能力，低估完成所需的时间。而管理者则会接受开发人员的乐观态度，可能会在时间表中添加一些缓冲以确保安全。

当开发人员意识到任务实际上比他们最初想象的要大得多和更加压倒性时，他们的过度自信和乐观主义将变成沮丧和痛苦。重写将比预期的时间长得多，不是一点点，而是一个数量级或更多。在重写期间，现有程序将被搁置-存在错误和缺少功能-令现有客户失望，无法吸引新客户。重写项目最终将成为一场惊慌的死亡行军，不惜一切代价完成，结果将是一个与第一个一样糟糕的代码库，只是以不同的方式。它只是第一个系统的复制品，因为时间表的压力将决定新功能要延迟到初始发布之后。

### 迭代重构

考虑到完全重写所带来的风险，我建议进行重构。重构意味着通过小步骤改进程序的*质量*，而不改变程序的*功能*。整个系统引入了一个相对较小的变化。然后测试系统以确保它仍然正常工作，最后将系统投入生产。第二个小变化建立在前一个变化的基础上，依此类推。随着时间的推移，系统变得更容易维护和改进。

重构方法显然不如完全重写吸引人。它违背了大多数开发人员的核心感知。开发人员必须继续长时间地使用系统，无论其中存在什么问题。他们不能立刻切换到最新、最热门的框架。他们不能成为自己的客户，并满足第一次就把事情做对的愿望。作为一种长期策略，重构方法并不吸引那些更看重快速开发新应用而不是修补现有应用的文化。开发人员通常更喜欢开始自己的新项目，而不是维护他人开发的旧项目。

然而，作为一种降低风险的策略，使用迭代的重构方法无疑优于重写。与重写项目中的任何类似部分相比，单个重构本身要小得多。它们可以在比重写更短的时间内应用，并且在每次迭代结束时都会使现有代码库保持工作状态。现有应用程序从未停止运行或进展。迭代的重构可以集成到一个更大的过程中，其中安排允许进行错误修复、功能添加和重构以改进下一个周期。

最后，任何单个重构步骤的目标不是完美，而是改进。我们并不试图在长时间内实现一个不可能的目标。我们正在朝着可以在短时间内实现的易于可视化的目标迈出小步。每个小的重构胜利都将提高士气，并激发对下一个重构步骤的热情。随着时间的推移，这些许多小胜利积累成一个大胜利：一个永远不停地为企业创造收入的现代化代码库。

# 遗留框架

到目前为止，我们一直在讨论基于页面、包含导向系统的遗留应用程序。然而，还有大量基于公共框架的遗留代码。

## 基于框架的遗留应用程序

PHP 领域中的每个不同的公共框架都有其独特的问题。使用*CakePHP*（[`cakephp.org/`](http://cakephp.org/)）编写的应用程序遇到的遗留问题与使用 CodeIgniter、Solar、Symfony 1、Zend Framework 1 等编写的应用程序遇到的问题不同。每个不同的框架及其各种变体都鼓励应用程序中不同类型的紧耦合。因此，需要重构使用其中一个框架构建的应用程序的具体步骤与需要为另一个框架进行重构的步骤非常不同。

因此，本书的各个部分可能作为指导遗留应用程序不同部分的重构的指南，但整体上，本书并不针对基于这些公共框架的应用程序进行重构。

内部、私有或其他非公开框架由组织内部的架构师直接控制，很可能会受益于本书中包含的重构。

## 重构到框架

我有时听说开发人员明智地希望避免完全重写，而是希望重构或迁移到公共框架。这听起来像是两全其美，结合了迭代方法和开发人员使用最新技术的愿望。

我对遗留 PHP 应用程序的经验是，它们对框架集成的抵抗几乎和对单元测试一样强烈。如果应用程序已经处于可以将其逻辑移植到框架的状态，那么首先移植它的必要性就很小。

然而，当我们完成本书中的重构时，应用很可能会处于一个更适合进行公共框架迁移的状态。开发人员是否仍然愿意这样做是另一回事。

# 回顾和下一步

在这一点上，我们意识到重写虽然吸引人，但是是一种危险的方法。迭代的重构方法听起来更像是实际工作，但它的好处是可以实现和现实的。

下一步是通过解决一些先决条件来为重构方法做好准备。之后，我们将通过一系列相对较小的步骤来现代化我们的遗留应用程序，每章一步，每一步都分解成易于遵循的过程，并提供常见问题的答案。

让我们开始吧！
