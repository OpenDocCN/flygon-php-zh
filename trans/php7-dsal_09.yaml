- en: Putting Graphs into Action
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图应用到实际中
- en: The graph is one of the most interesting data structures that is used to solve
    various real-life problems. Whether we are talking about showing directions on
    maps, finding the shortest route, planning for complex network flow, finding a
    connection between profiles in social media, or recommendations, we are dealing
    with graph data structures and their associated algorithms. Graphs give us so
    many ways to solve problems that they have been used frequently to solve complex
    problems. As a result, it is very important for us to understand graphs and how
    we can use them in our solutions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图是用于解决各种现实问题的最有趣的数据结构之一。无论是在地图上显示方向，寻找最短路径，规划复杂的网络流量，寻找社交媒体中的个人资料之间的联系或推荐，我们都在处理图数据结构及其相关算法。图给我们提供了解决问题的许多方法，因此它们经常被用来解决复杂问题。因此，我们非常重要的是要理解图以及我们如何在解决方案中使用它们。
- en: Understanding graph properties
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解图的属性
- en: 'A graph is a collection of vertices or nodes that are connected to each other
    through edges. These edges can be ordered or unordered, which means that the edge
    can have a direction associated with it or it can be non-directed, which is also
    known as bidirectional edge. We represent a graph using a set *G* in relationship
    with vertices *V* and edges *E* as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 图是通过边连接在一起的顶点或节点的集合。这些边可以是有序的或无序的，这意味着边可以有与之相关的方向，也可以是无向的，也称为双向边。我们使用集合*G*与顶点*V*和边*E*的关系来表示图，如下所示：
- en: '*G = (V, E)*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*G = (V, E)*'
- en: '![](Image00069.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00069.jpg)'
- en: 'In the preceding diagram, we have five vertices and six edges:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们有五个顶点和六条边：
- en: '*V = {A, B, C, D, E}*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*V = {A, B, C, D, E}*'
- en: '*E = {AB, AC, AD, BD, BE, CD, DE}*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*E = {AB, AC, AD, BD, BE, CD, DE}*'
- en: If we consider the previous diagram, the connectivity between **A** and **B**
    can be represented as **AB** or **BA** as we have not defined the direction for
    the connectivity. One of the significant differences between the graph and the
    tree data structures is that the graph can form a cycle or loop, but a tree data
    structure cannot. Unlike a tree data structure, we can start from any vertices
    in a graph data structure. Also, we can have a direct edge between any two vertices,
    whereas in a tree, two nodes can only be connected if the child node is the immediate
    descendant of the parent node.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑前面的图，A和B之间的连接可以表示为AB或BA，因为我们没有定义连接的方向。图和树数据结构之间的一个重要区别是，图可以形成循环，但树数据结构不能。与树数据结构不同，我们可以从图数据结构中的任何顶点开始。此外，我们可以在任何两个顶点之间有直接的边，而在树中，只有在子节点是父节点的直接后代时，两个节点才能连接。
- en: There are different properties and keywords related to graphs. We will now explore
    those terms before moving on to further discussions on graphs and their applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图有不同的属性和与之相关的关键词。在继续讨论图及其应用之前，我们将探讨这些术语。
- en: Vertex
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点
- en: Each node in a graph is called a vertex. Usually, a vertex is represented as
    a circle. In our diagram, the nodes **A** , **B** , **C** , **D,** and **E** are
    vertices.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的每个节点称为一个顶点。通常，顶点表示为一个圆。在我们的图中，节点A，B，C，D和E是顶点。
- en: Edge
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边
- en: 'An edge is a connection between two vertices. Usually, it is represented by
    a line drawn between two vertices. In the previous diagram, we had edges between
    **A** and **B** , **A** and **C** , **A** and **D** , **B** and **D** , **C**
    and **D** , **B** and **E** , and **D** and **E** . We can represent the edge
    as **AB** or (**A** , **B** ). Edges can be of three types:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 边是两个顶点之间的连接。通常，它由两个顶点之间的线表示。在前面的图中，我们在A和B之间，A和C之间，A和D之间，B和D之间，C和D之间，B和E之间，以及D和E之间有边。我们可以表示边为AB或（A，B）。边可以有三种类型：
- en: '**Directed edge** : If an edge is marked with an arrow, then it indicates a
    directed edge. A directed edge is unidirectional. The head of the arrow is the
    end vertex and the tail of the arrow is the start vertex:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有向边**：如果一条边标有箭头，那么它表示一条有向边。有向边是单向的。箭头的头部是终点，箭头的尾部是起点：'
- en: '![](Image00070.gif)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00070.gif)'
- en: In the preceding diagram, we can see that **A** has a directed edge to **B**
    , which means **A** , **B** is an edge, but not vice versa (**B** , **A** ). So,
    this is an example of a unidirectional edge, or directed edge.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到A有一个指向B的有向边，这意味着A，B是一条边，但反之不成立（B，A）。因此，这是一个单向边或有向边的例子。
- en: '**Undirected edge** : An undirected edge is a connection between two vertices
    without any direction. This means that the edge satisfies a bidirectional relationship.
    The following diagram is an example of an undirected graph, where **A** is connected
    to **B** in such a way that both edges (**A** , **B** ) and (**B** , **A** ) are
    the same:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无向边：无向边是两个顶点之间没有方向的连接。这意味着边满足双向关系。下图是无向图的一个例子，其中A与B连接的方式是（A，B）和（B，A）是相同的：
- en: '![](Image00071.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00071.jpg)'
- en: '**Weighted edge** : When an edge carries additional information, such as cost,
    distance, or other information, we call that edge a weighted edge. This is used
    for many graph algorithms. In the following diagram, the weight for edge (**A**
    , **B** ) is **5** . This can be distance, or cost, or anything, as per the definition
    of the graph:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加权边**：当一条边携带额外信息，如成本、距离或其他信息时，我们称该边为加权边。这用于许多图算法。在下图中，边（A，B）的权重为5。根据图的定义，这可以是距离、成本或其他任何东西：'
- en: '![](Image00072.gif)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00072.gif)'
- en: Adjacent
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邻接
- en: Two vertices are adjacent if they have an edge in between them. Two vertices
    A and B are said to be adjacent if they have a direct edge between them. In the
    following diagram, we can see that vertex **1** and vertex **2** are connected
    with the edge **e1** , and as a result, they are called adjacent. Since vertex
    **2** has no edge between vertex 3 and 4, vertex **2** is not adjacent to vertex
    **3** and vertex **4** .
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个顶点之间有一条边，则它们是相邻的。如果顶点A和B之间有直接的边，则它们被称为相邻。在下图中，我们可以看到顶点1和顶点2通过边e1相连，因此它们被称为相邻。由于顶点2与顶点3和4之间没有边，所以顶点2不与顶点3和顶点4相邻。
- en: Incident
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联
- en: 'An edge is incident on a vertex if the vertex is one of the end points of the
    edge. Also, two edges are incident if both of them share a vertex. If we consider
    the following diagram, we can see the incident edges (**e1** , **e2** ), (**e2**
    , **e3** ), and (**e1** , **e3** ) sharing vertex **1** among themselves. W e
    also have incident edges (**e3** , **e4** ) that share vertex **4** among themselves
    and edges (**e2** , **e4** ) that share vertex **3** among themselves. Similarly,
    we can say that vertex **1** is incident on edges **e1** , **e2** , and **e3**
    , vertex **2** is incident on edge **e1** , vertex **3** is incident on edges
    **e2** , and **e4** , and vertex **4** is incident on edges **e3** , and **e4**
    :'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果顶点是边的端点之一，则边与顶点相关。此外，如果两条边共享一个顶点，则两条边是相关的。如果考虑下图，我们可以看到边(e1，e2)，(e2，e3)和(e1，e3)共享顶点1。我们还有边(e3，e4)共享顶点4，以及边(e2，e4)共享顶点3。类似地，我们可以说顶点1与边e1，e2和e3相关，顶点2与边e1相关，顶点3与边e2和e4相关，顶点4与边e3和e4相关：
- en: '![](Image00073.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00073.jpg)'
- en: Indegree and outdegree
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入度和出度
- en: The total count of incoming edges to a particular vertex is known as the indegree
    of that vertex, and the total number of outgoing edges from a particular vertex
    is known as the outdegree of that vertex. If we consider the directed edges of
    the following diagram, we can say that vertex **A** has an indegree of 0 and an
    outdegree of 1, vertex **B** has an indegree of 2 and an outdegree 1, vertex **C**
    has an indegree 1 and an outdegree of 1, vertex **D** has an indegree of 1 and
    an outdegree of 1, vertex **E** has an indegree of 1 and an outdegree of 2, and
    lastly, vertex **F** has an indegree of 1 and an outdegree of 0.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 特定顶点的入边总数称为该顶点的入度，特定顶点的出边总数称为该顶点的出度。如果考虑下图的有向边，我们可以说顶点A的入度为0，出度为1，顶点B的入度为2，出度为1，顶点C的入度为1，出度为1，顶点D的入度为1，出度为1，顶点E的入度为1，出度为2，最后，顶点F的入度为1，出度为0。
- en: Path
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路径
- en: 'A path is a sequence of vertices and edges that starts from a starting vertex
    and ends in another vertex that we are trying to reach. In the following diagram,
    the path from **A** to **F** is represented by (**A** , **B** ), (**B** , **C**
    ), (**C** , **E** ), and (**E** , **F** ):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 路径是从起始顶点到我们试图到达的另一个顶点的顶点和边的序列。在下图中，从A到F的路径由(A，B)，(B，C)，(C，E)和(E，F)表示：
- en: '![](Image00074.gif)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00074.gif)'
- en: Types of graphs
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的类型
- en: There are different types of graphs available based on how they are drawn or
    represented. Each type of graph has a different behavior and usage. We will focus
    on four main types of graph.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们的绘制或表示方式，有不同类型的图可用。每种类型的图都有不同的行为和用途。我们将重点讨论四种主要类型的图。
- en: Directed graphs
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有向图
- en: 'If a graph contains only directed edges, then the graph is known as a directed
    graph. A directed graph is also known as a digraph or a directed network. The
    following diagram represents a directed graph. Here, the (**A** , **B** ), (**B**
    , **C** ), (**C** , **E** ), (**E** , **D** ), (**E** , **F** ), and (**D** ,
    **B** ) edges are directed edges. Since the edges are directed, edge **AB** is
    not the same as edge **BA** :'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图只包含有向边，则图称为有向图。有向图也称为有向图或有向网络。下图表示了一个有向图。这里，(A，B)，(B，C)，(C，E)，(E，D)，(E，F)和(D，B)边是有向边。由于边是有向的，边AB与边BA不同：
- en: '![](Image00075.gif)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00075.gif)'
- en: Undirected graphs
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无向图
- en: 'If a graph contains only undirected edges, then the graph is an undirected
    graph. In other words, the edges in an undirected graph are bidirectional. Sometimes,
    the undirected graph is also known as an undirected network. In an undirected
    graph, if vertex A is connected to vertex B, then it is assumed that both (A,
    B) and (B, A) represent the same edge. The following diagram shows an example
    of an undirected graph where all the edges do not have arrows to indicate direction:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图只包含无向边，则图是无向图。换句话说，无向图中的边是双向的。有时，无向图也被称为无向网络。在无向图中，如果顶点A连接到顶点B，则假定(A，B)和(B，A)表示相同的边。下图显示了一个无向图的示例，其中所有边都没有箭头表示方向：
- en: '![](Image00076.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00076.jpg)'
- en: Weighted graphs
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加权图
- en: 'If all the edges of a graph are weighted edges, then the graph is known as
    a weighted graph. We will talk a lot about weighted graphs in the upcoming sections.
    Weighted graphs can be directed or undirected graphs. Each edge must have a value
    associated with it. The weight of an edge is always referred to as the cost of
    the edge. The following diagram represents an undirected weighted graph with five
    vertices and seven edges. Here, the weight of the edge between vertex **1** and
    **2** is **2** , the edge between vertex **1** and **4** is **5** , and the edge
    between vertex **4** and **5** is **58** :'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图的所有边都是加权边，则图称为加权图。我们将在接下来的部分中详细讨论加权图。加权图可以是有向图或无向图。每条边必须有一个与之关联的值。边的权重总是被称为边的成本。下图表示了一个具有五个顶点和七条边的无向加权图。这里，顶点1和2之间的边的权重为2，顶点1和4之间的边的权重为5，顶点4和5之间的边的权重为58：
- en: '![](Image00077.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00077.jpg)'
- en: Directed acyclic graphs (DAG)
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有向无环图（DAG）
- en: 'An acyclic graph is a graph without a cycle or loop. If we want to visit other
    nodes from a particular node, we will not visit any of the nodes twice. A directed
    acyclic graph, popularly known as a DAG, is a directed graph that is acyclic.
    A directed acyclic graph has many usages in graph algorithms. A directed acyclic
    graph has a topological ordering, where the ordering of the vertices is such that
    the starting endpoint of every edge occurs earlier in the ordering than the ending
    endpoints of the edges. The following diagram represents a DAG:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 无环图是一种没有循环或环路的图。如果我们想从特定节点访问其他节点，我们不会访问任何节点两次。有向无环图，通常称为DAG，是一个无环的有向图。有向无环图在图算法中有许多用途。有向无环图具有拓扑排序，其中顶点的排序使得每条边的起始端点在排序中出现在边的结束端点之前。以下图表示一个DAG：
- en: '![](Image00078.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00078.jpg)'
- en: From the first look, it seems that **B** , **C** , **E** , and **D** form a
    cycle, but close observation shows that they do not form a cycle, whereas, the
    example we have used in the directed graph section is a perfect example of a cyclic
    graph.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，似乎B，C，E和D形成一个循环，但仔细观察表明它们并没有形成循环，而我们在有向图部分使用的示例是循环图的完美示例。
- en: Representing graphs in PHP
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PHP中表示图
- en: 'Since graphs are represented with vertices and edges, we have to consider both
    in representing the graph. There are several ways to represent a graph, but the
    most popular ones are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图是由顶点和边表示的，我们必须考虑两者来表示图。表示图的方法有几种，但最流行的方法如下：
- en: Adjacency list
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邻接表
- en: Adjacency matrix
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邻接矩阵
- en: Adjacency lists
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邻接表
- en: 'We can represent a graph using a linked list where one array will be used for
    vertices and each vertex will have a linked list, which will represent the edges
    between adjacent vertices. An example graph looks like this when represented in
    an adjacency list:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用链表表示图，其中一个数组将用于顶点，每个顶点将有一个链表，表示相邻顶点之间的边。当以邻接表表示时，示例图如下：
- en: '![](Image00079.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00079.jpg)'
- en: Adjacency matrix
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邻接矩阵
- en: 'In an adjacency matrix, we represent the graph in a two-dimensional array,
    where each node represents the array index horizontally and vertically. If the
    edge from A to B is directional, then we mark that array index [A][B] to 1 to
    mark the connection; otherwise, it''s 0\. If the edge is not directional, then
    both [A][B] and [B][A] are set to 1\. If the graph is a weighted graph, then [A][B]
    or [B][A] will store the weight instead of 1\. The following diagram shows the
    undirected graph representation using a matrix:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '在邻接矩阵中，我们使用二维数组表示图，其中每个节点在水平和垂直方向上表示数组索引。如果从A到B的边是有方向的，则将该数组索引[A][B]标记为1以标记连接；否则为0。如果边是无方向的，则[A][B]和[B][A]都设置为1。如果图是加权图，则[A][B]或[B][A]将存储权重而不是1。以下图显示了使用矩阵表示的无向图表示： '
- en: '![](Image00080.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00080.jpg)'
- en: 'This one shows the directed graph representation of the matrix:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图显示了矩阵的有向图表示：
- en: '![](Image00081.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00081.jpg)'
- en: Though our graph representation shows an alphabetic representation of array
    indexes in both an adjacency list and matrix, we can use a numeric index to represent
    vertices as well.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的图表示显示了邻接表和矩阵中数组索引的字母表示，但我们也可以使用数字索引来表示顶点。
- en: Revisiting BFS and DFS for graphs
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新讨论图的BFS和DFS
- en: We have already seen how we can implement a **breadth first search** (**BFS**
    ) and a **depth** **first** **search** (**DFS** ) in a tree structure. We will
    revisit our BFS and DFS for graphs. The difference between a tree implementation
    and a graph implementation is that in a graph implementation, we can start from
    any vertex, whereas we start from the root of the tree in a tree data structure.
    Another important thing to consider is that our graphs can have cycles, which
    were absent in the tree, so, we cannot revisit a node or vertex as it will end
    up in an infinite loop. We will use a concept called graph coloring where we keep
    the status of different node visits with a color or a value to keep it simple.
    Let's now write some code to implement the BFS and DFS in the graph.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在树结构中实现广度优先搜索（BFS）和深度优先搜索（DFS）。我们将重新讨论我们的BFS和DFS用于图。树实现和图实现之间的区别在于，在图实现中，我们可以从任何顶点开始，而在树数据结构中，我们从树的根开始。另一个重要的考虑因素是，我们的图可以有循环，而树中没有循环，因此我们不能重新访问一个节点或顶点，否则会陷入无限循环。我们将使用一个称为图着色的概念，其中我们使用颜色或值来保持不同节点访问的状态，以保持简单。现在让我们编写一些代码来实现图中的BFS和DFS。
- en: Breadth first search
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广度优先搜索
- en: 'We are now going to implement a BFS for a graph. Considering the following
    undirected graph, first, we need to represent the graph in a matrix or list. For
    the sake of simplicity, we will use the adjacency matrix for the graph representation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现图的BFS。考虑以下无向图，首先，我们需要用矩阵或列表表示图。为了简单起见，我们将使用邻接矩阵表示图：
- en: '![](Image00082.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00082.jpg)'
- en: 'The preceding adjacency graph has six vertices, and the vertices are labeled
    from **1** to **6** (no 0). Since our vertices are numbered, we can use those
    as array indexes for faster access. We will can construct the graph like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的邻接图有六个顶点，顶点从1到6标记（没有0）。由于我们的顶点编号，我们可以将它们用作数组索引以加快访问速度。我们可以构建图如下：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we have two arrays, one for representing the actual graph and the other
    one for keeping track of the visited nodes. We want to make sure that we do not
    visit a node multiple times as it might end up in an infinite loop. Since our
    graph has six vertices, we kept `$vertexCount` as `6` . We then initialize the
    graph array as a two-dimensional array with an initial value of `0` . We will
    start the index from `1` for the array. We also set each vertex as not visited
    by assigning each vertex to `0` in the `$visited` array. Now, we will add the
    edges in our graph representation. Since the graph is undirected, we need to set
    two properties for each edge. In other words, we need to set bidirectional edge
    values for edges between the vertex labeled 1 and 2 since both share an edge between
    them. Here is the code for the full representation of the earlier graph:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个数组，一个用于表示实际图形，另一个用于跟踪已访问的节点。我们希望确保我们不会多次访问一个节点，因为这可能会导致无限循环。由于我们的图形有六个顶点，我们将`$vertexCount`保持为`6`。然后，我们将图数组初始化为具有初始值`0`的二维数组。我们将从数组的索引`1`开始。我们还将通过将每个顶点分配给`$visited`数组中的`0`来设置每个顶点为未访问状态。现在，我们将在我们的图形表示中添加边。由于图是无向的，我们需要为每条边设置两个属性。换句话说，我们需要为标记为1和2的顶点之间的边设置双向边值，因为它们之间共享一条边。以下是先前图形的完整表示的代码：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So, we have represented the graph using an adjacency matrix. Now, let''s define
    the BFS algorithm for the matrix:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经使用邻接矩阵表示了图。现在，让我们为矩阵定义BFS算法：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our implemented BFS function takes three arguments: the actual graph, the starting
    vertex, and the empty visited array. We could have avoided the third argument
    and written the initialization inside the BFS function. At the end of the day,
    we can choose either of the ways to accomplish this. Inside our function implementation,
    we have two queues: one to keep the nodes that we need to visit and another one
    for the order of the visited nodes, or the path of the search. At the end of the
    function, we return the path queue.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的BFS函数接受三个参数：实际图形、起始顶点和空的已访问数组。我们本可以避免第三个参数，并在BFS函数内部进行初始化。归根结底，我们可以选择任一种方式来完成这一点。在我们的函数实现中，有两个队列：一个用于保存我们需要访问的节点，另一个用于保存已访问节点的顺序，或者搜索的路径。在函数结束时，我们返回路径队列。
- en: 'Inside the function, we first add the starting node to the queue. Then, we
    start from that node to visit its adjacent nodes. If the node is not visited and
    has a connection to the current node, we add it to our queue for visiting. We
    also mark the current node as visited and add it to our path. Now, we will call
    our BFS function with our constructed graph matrix and a visiting node. Here is
    the program to execute the BFS functionality:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们首先将起始节点添加到队列中。然后，我们从该节点开始访问其相邻节点。如果节点未被访问并且与当前节点有连接，则将其添加到我们的访问队列中。我们还将当前节点标记为已访问，并将其添加到我们的路径中。现在，我们将使用我们构建的图矩阵和一个访问节点来调用我们的BFS函数。以下是执行BFS功能的程序：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we can see from the preceding code snippet, we start the search from node
    1\. The output will look like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中可以看出，我们从节点1开始搜索。输出将如下所示：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we had 5 as the starting node by changing the second argument of the `BFS`
    function call from 1 to 5, then the output would have been the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`BFS`函数调用的第二个参数从1更改为5作为起始节点，那么输出将如下所示：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Depth first search
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度优先搜索
- en: 'As we have seen for the BFS, we can define any starting vertex for the DFS
    as well. The difference is that for a list of visited nodes, we will use a stack
    instead of a queue. Other parts of the code will be similar to our BFS code. We
    will also use the same graph we used for the BFS implementation. The DFS implementation
    we will implement is an iterative one. Here is the code for it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在BFS中看到的那样，我们也可以为DFS定义任何起始顶点。不同之处在于，对于已访问节点的列表，我们将使用堆栈而不是队列。代码的其他部分将类似于我们的BFS代码。我们还将使用与BFS实现相同的图。我们将实现的DFS是迭代的。以下是其代码：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As mentioned earlier, for a DFS, we have to use a stack instead of a queue
    as we need the last vertex from the stack instead of the first one (if we have
    used a queue). For the path part, we use a queue so that we can show the path
    sequentially during the display. Here is the code to call for our graph `$graph`
    :'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，对于DFS，我们必须使用堆栈而不是队列，因为我们需要从堆栈中获取最后一个顶点，而不是第一个（如果我们使用了队列）。对于路径部分，我们使用队列，以便在显示过程中按顺序显示路径。以下是调用我们的图`$graph`的代码：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code will produce the following output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将产生以下输出：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For the preceding example, we start from vertex 1, and we will visit vertex
    5 first out of the two adjacent vertices with the labels 5 and 2 of vertex 1\.
    Now, vertex 5 has two vertices with labels 4 and 2\. Vertex 4 will be visited
    first as it appears as the first edge from vertex 5 (bearing in mind our left
    to right direction of visiting nodes). Next, we will visit vertex 6 from vertex
    4\. Since, we cannot go any further from vertex 6, it will return to vertex 4
    and visit the unvisited adjacent vertex with the label 3\. When we are at vertex
    3, there are two adjacent vertices available from 3\. They are labeled as vertex
    4 and vertex 2\. We already visited vertex 4 earlier, so we cannot revisit it,
    and we have to visit vertex 2 from vertex 3\. Since vertex 2 has three vertices,
    vertex 3, 5, and 1, and all of them are already visited, we are actually done
    with our DFS implementation here.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述示例，我们从顶点1开始，并首先访问顶点5，这是顶点1的两个相邻顶点中标记为5和2的顶点之一。现在，顶点5有两个标记为4和2的顶点。顶点4将首先被访问，因为它是从顶点5出发的第一条边（记住我们从左到右访问节点的方向）。接下来，我们将从顶点4访问顶点6。由于我们无法从顶点6继续前进，它将返回到顶点4并访问标记为3的未访问相邻顶点。当我们到达顶点3时，有两个相邻顶点可供访问。它们被标记为顶点4和顶点2。我们之前已经访问了顶点4，因此无法重新访问它，我们必须从顶点3访问顶点2。由于顶点2有三个顶点，分别是顶点3、5和1，它们都已经被访问，因此我们实际上已经完成了DFS的实现。
- en: We can pass an extra parameter if we are looking for a specific end vertex from
    a starting vertex. In the earlier example, we were just getting the adjacent vertex
    and visiting all of them. For a specific end vertex, we had to match the target
    vertex with each of our visiting vertex during the iteration of the DFS algorithm.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从一个起始顶点寻找特定的终点顶点，我们可以传递一个额外的参数。在之前的例子中，我们只是获取相邻的顶点并访问它们。对于特定的终点顶点，我们需要在DFS算法的迭代过程中将目标顶点与我们访问的每个顶点进行匹配。
- en: Topological sorting using Kahn's algorithm
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kahn算法进行拓扑排序
- en: 'Let''s assume that we have some tasks to do, and each of the tasks has some
    dependencies that mean that the dependent tasks should be done first before doing
    the actual task. The problem arises when we have an interrelationship between
    tasks and dependencies. Now, we need to come up with a proper order for completing
    the tasks. We need a special type of sorting so that we can sort these connected
    tasks without violating our rules for finishing the tasks. Topological sorting
    will be the right choice for solving such problems. In topological sorting, a
    directed edge AB from vertex A to B is sorted in such a way that A will always
    come before B in the ordering. This will be applicable for all the vertices and
    edges. Another important factor for applying a topological sort is that the graph
    must be a DAG. Any DAG has at least one topological sorting. Most of the time,
    there are multiple topological sortings that are possible for a given graph. There
    are two popular algorithms available for topological sorting: Kahn''s algorithm
    and the DFS approach. We will talk about Kahn''s algorithm here as we have already
    discussed DFS a few times in this book.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一些任务要做，每个任务都有一些依赖关系，这意味着在执行实际任务之前，应该先完成依赖的任务。当任务和依赖之间存在相互关系时，问题就出现了。现在，我们需要找到一个合适的顺序来完成这些任务。我们需要一种特殊类型的排序，以便在不违反完成任务的规则的情况下对这些相互关联的任务进行排序。拓扑排序将是解决这类问题的正确选择。在拓扑排序中，从顶点A到B的有向边AB被排序，以便A始终在排序中位于B之前。这将适用于所有的顶点和边。应用拓扑排序的另一个重要因素是图必须是一个DAG。任何DAG都至少有一个拓扑排序。大多数情况下，对于给定的图，可能存在多个拓扑排序。有两种流行的算法可用于拓扑排序：Kahn算法和DFS方法。我们将在这里讨论Kahn算法，因为我们在本书中已经多次讨论了DFS。
- en: 'Kahn''s algorithm has the following steps to find the topological ordering
    from a DAG:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Kahn算法有以下步骤来从DAG中找到拓扑排序：
- en: Calculate the indegree (incoming edges) for each of the vertex and put all vertices
    in a queue where the indegree is 0\. Also, initialize the count for the visited
    node to 0.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每个顶点的入度（入边），并将所有入度为0的顶点放入队列中。还要将访问节点的计数初始化为0。
- en: 'Remove a vertex from the queue and perform the following operations on it:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从队列中移除一个顶点，并对其执行以下操作：
- en: 1\. Increment the visited node count by 1.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 将访问节点计数加1。
- en: 2\. Reduce the indegree for all adjacent vertices by 1.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 将所有相邻顶点的入度减1。
- en: 3\. If the indegree of the adjacent vertex becomes 0, add it to the queue.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 如果相邻顶点的入度变为0，则将其添加到队列中。
- en: Repeat *step 2* until the queue is empty.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤2*，直到队列为空。
- en: If the count of the visited node is not the same as the count of the nodes,
    then topological sorting is not possible for the given DAG.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果访问节点的计数与节点的计数不同，则给定DAG的拓扑排序是不可能的。
- en: 'Let''s consider the following graph. It is a perfect example of DAG. Now, we
    want to sort it using topological sorting and Kahn''s algorithm:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下图。这是一个DAG的完美例子。现在，我们想使用拓扑排序和Kahn算法对其进行排序：
- en: '![](Image00083.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00083.jpg)'
- en: 'Now let us represent this graph using an adjacency matrix as we did previously
    for the other graphs. The matrix will look as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用邻接矩阵来表示这个图，就像我们之前为其他图所做的那样。矩阵将如下所示：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we will implement Kahn''s algorithm as per our defined steps. Here is
    the implementation for it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将按照我们定义的步骤实现Kahn算法。以下是它的实现：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we can see from the preceding implementation, we have actually considered
    every step we mentioned for Kahn''s algorithm. We started by finding the indegree
    for vertices and also putting the 0 indegree vertices in a queue. Then, we checked
    each node of the queue and reduced the indegree of the neighbor vertices and again
    added any neighbor with 0 indegrees to the queue. At the end, we returned the
    sorted queue, or an empty queue if the count of ordered vertices and actual vertices
    count does not match. We can now call the function to return the sorted list of
    vertices as a queue. Here is the code to do this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的实现中可以看出，我们实际上考虑了我们提到的Kahn算法的每一步。我们首先找到了顶点的入度，并将入度为0的顶点放入了队列中。然后，我们检查了队列的每个节点，并减少了相邻顶点的入度，并再次将任何入度为0的相邻顶点添加到队列中。最后，我们返回了排序后的队列，或者如果有序顶点的计数与实际顶点的计数不匹配，则返回一个空队列。现在，我们可以调用该函数来返回排序后的顶点列表作为队列。以下是执行此操作的代码：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, this will go through each of the queue elements and print them. The output
    will look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这将遍历队列中的每个元素并将它们打印出来。输出将如下所示：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The output corresponds to our expectations. As we can see from the earlier diagram,
    vertex **2** has a direct edge to vertex **1** and vertex **3** , and vertex **1**
    has a direct edge to vertex **0** and vertex **3** . Since vertex **2** has no
    incoming edges, we will start from vertex **2** for the topological sorting. Vertex
    **1** has one incoming edge and vertex **3** has two, so, after vertex **2** ,
    we will visit vertex **1** as per the algorithm. The same principle will take
    us to vertex **0** followed by vertex **3** and at the end to vertex **4** . We
    have to also remember that there can be multiple topological orderings possible
    for a given graph. The complexity of Kahn's algorithm is **O** (*V+E* ), where
    **V** is the number of vertices and **E** is the number of edges.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 输出符合我们的期望。从之前的图表中可以看出，顶点 **2** 直接连接到顶点 **1** 和顶点 **3** ，顶点 **1** 直接连接到顶点 **0**
    和顶点 **3** 。由于顶点 **2** 没有入边，我们将从顶点 **2** 开始进行拓扑排序。顶点 **1** 有一个入边，顶点 **3** 有两个入边，所以在顶点
    **2** 之后，我们将按照算法访问顶点 **1** 。相同的原则将带我们到顶点 **0** ，然后是顶点 **3** ，最后是顶点 **4** 。我们还必须记住对于给定的图，可能存在多个拓扑排序。Kahn算法的复杂度是
    **O** (*V+E* )，其中 **V** 是顶点的数量，**E** 是边的数量。
- en: Shortest path using the Floyd-Warshall algorithm
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Floyd-Warshall算法的最短路径
- en: 'A common scenario for a pizza-delivery company is to deliver the pizza as quickly
    as possible. Graph algorithms can help us in such situations. The Floyd-Warshall
    algorithm is a very common algorithm that is used to find the shortest path from
    u to v using all pairs of vertices (u, v). The shortest path indicates the shortest
    possible distance between two nodes that are interconnected. The graph for calculating
    the shortest path has to be a weighted graph. In some cases, the weight can be
    negative as well. The algorithm is very simple and one of the easiest to implement.
    It is shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 披萨外卖公司的常见情景是尽快送达披萨。图算法可以帮助我们在这种情况下。Floyd-Warshall算法是一种非常常见的算法，用于找到从u到v的最短路径，使用所有顶点对(u,
    v)。最短路径表示两个相互连接的节点之间的最短可能距离。用于计算最短路径的图必须是加权图。在某些情况下，权重也可以是负数。该算法非常简单，也是最容易实现的之一。它在这里显示：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'First, we copied each of our weights to a cost or distance matrix. Then, we
    ran through each vertex and figured out the cost or distance of visiting from
    vertex `i` to vertex `j` through vertex `k` . If the distance or cost is less
    than a direct path between vertex `i` and vertex `j` , we choose the path `i`
    to `k` to `j` instead of the direct path of `i` to `j` . Let''s consider the following
    diagram:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将每个权重复制到一个成本或距离矩阵中。然后，我们遍历每个顶点，并计算从顶点 `i` 经过顶点 `k` 到达顶点 `j` 的成本或距离。如果距离或成本小于顶点
    `i` 到顶点 `j` 的直接路径，我们选择路径 `i` 到 `k` 到 `j` 而不是直接路径 `i` 到 `j` 。让我们考虑以下图表：
- en: '![](Image00084.gif)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00084.gif)'
- en: 'Here, we can see an undirected graph with weights on each edge. Now, if we
    look for the shortest path from **A** to **E** , then we have the following options:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个带有每条边权重的无向图。现在，如果我们寻找从 **A** 到 **E** 的最短路径，那么我们有以下选项：
- en: '**A** to **E** via **B** has a distance of **20**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A** 到 **E** 通过 **B** 的距离为 **20**'
- en: '**A** to **E** via **D** has a distance of **25**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A** 到 **E** 通过 **D** 的距离为 **25**'
- en: '**A** to **E** via **D** and **B** has a distance of **20**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A** 到 **E** 通过 **D** 和 **B** 的距离为 **20**'
- en: '**A** to **E** via **B** and **D** has a distance of **35**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A** 到 **E** 通过 **B** 和 **D** 的距离为 **35**'
- en: 'So, we can see that the lowest distance is **20** . Now, let''s implement this
    programmatically with numeric representations of the vertices. We will use 0,
    1, 2, 3, and 4 instead of A, B, C, D, and E, respectively. Now, let''s represent
    the earlier graph in an adjacency matrix format:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到最小距离是 **20** 。现在，让我们以数值表示顶点，以编程方式实现这一点。我们将使用0、1、2、3和4代替A、B、C、D和E。现在，让我们用邻接矩阵格式表示之前的图：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we took a difference approach and initialized all the edges to the maximum
    value of the PHP integer. The reason for doing this is to ensure that a value
    of 0 for non-edges does not impact the algorithm logic, as we are searching for
    the minimum value. Now, we need to add the weights to the graph as shown in the
    earlier diagram:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们采取了不同的方法，并将所有边初始化为PHP整数的最大值。这样做的原因是确保非边的值为0不会影响算法逻辑，因为我们正在寻找最小值。现在，我们需要像之前的图表中显示的那样向图中添加权重：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Since this is an undirected graph, we assign both edges the same value. If
    it were a directed graph, we could have made only one entry for each weight. Now,
    it is time to implement the Floyd-Warshall algorithm to find the shortest paths
    for any given pair of nodes. Here is our implementation of this function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个无向图，我们给两条边分配相同的值。如果是有向图，我们只能为每个权重制作一次输入。现在，是时候实现Floyd-Warshall算法，以找到任意一对节点的最短路径。这是我们对该函数的实现：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we mentioned earlier, the implementation is really simple. We have three
    inner loops to calculate the minimum distance, and we also return the distance
    array at the end of the function. Now, let''s call this function and check whether
    our expected results match:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，实现非常简单。我们有三个内部循环来计算最小距离，并且在函数结束时返回距离数组。现在，让我们调用这个函数并检查我们的预期结果是否匹配：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is the output of the code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的输出：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we check our previous graph, we can see that the shortest distance between
    **D** and **C** is actually **10** , and the path is D → B → C (5+5), which is
    the shortest distance out of all the possible routes (D → A → B → C (20), or D
    → E → B → C (35)).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查之前的图表，我们可以看到 **D** 和 **C** 之间的最短距离实际上是 **10** ，路径是 D → B → C (5+5)，这是所有可能路线中的最短距离
    (D → A → B → C (20)，或 D → E → B → C (35))。
- en: The complexity for the Floyd-Warshall algorithm is **O** (*V3* ), where **V**
    is the number of vertices in the graph. Now we will explore another algorithm
    that is famous for finding the single source shortest path.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Floyd-Warshall算法的复杂度为 **O** (*V3* )，其中 **V** 是图中顶点的数量。现在我们将探讨另一个以找到单源最短路径而闻名的算法。
- en: Single source shortest path using Dijkstra's algorithm
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Dijkstra算法的单源最短路径
- en: 'We can easily find the shortest path using the Floyd-Warshall algorithm, but
    we do not get the actual path to go from node X to Y. This is because the Floyd-Warshall
    algorithm does the calculation for the distance or cost and does not store the
    actual path for the minimum cost. For example, using Google Maps, we can always
    find a route to our destination from any given location. Google Maps can show
    us the best route as regards the distance, time of travel, or other factors. This
    is a perfect example of single source shortest path algorithm usage. There are
    many algorithms to find the solution for a single source shortest path problem;
    however, Dijkstra''s shortest path algorithm is the most popular one. There are
    many ways to implement Dijkstra''s algorithm, such as using Fibonacci heaps, min-heaps,
    priority queues, and so on. Each implementation has its own advantage regarding
    the performance and improvement of Dijkstra''s solution. Let''s go through the
    pseudocode for the algorithm:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地使用Floyd-Warshall算法找到最短路径，但我们无法得到从节点X到Y的实际路径。这是因为Floyd-Warshall算法计算距离或成本，不存储最小成本的实际路径。例如，使用Google地图，我们总是可以找到从任何给定位置到目的地的路线。Google地图可以显示最佳路线，关于距离、旅行时间或其他因素。这是单源最短路径算法使用的完美例子。有许多算法可以找到单源最短路径问题的解决方案；然而，Dijkstra最短路径算法是最流行的。有许多实现Dijkstra算法的方法，例如使用斐波那契堆、最小堆、优先队列等。每种实现都有其自身的优势，关于Dijkstra解决方案的性能和改进。让我们来看一下算法的伪代码：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we will implement the algorithm using a priority queue. First, let''s
    choose a graph to implement the algorithm. We can select the following undirected
    weighted graph. It has six nodes with many connections between the nodes and vertices.
    First, we need to represent the following graph in an adjacency matrix:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用优先队列来实现算法。首先，让我们选择一个图来实现算法。我们可以选择以下无向加权图。它有六个节点，节点和顶点之间有许多连接。首先，我们需要用邻接矩阵表示以下图：
- en: '![](Image00085.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00085.jpg)'
- en: 'As we can see from the preceding diagram, our vertices are labeled with the
    letters **A** to **F** , so we will use the vertex name as the key in a PHP associative
    array:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中可以看出，我们的顶点用字母**A**到**F**标记，因此我们将使用顶点名称作为PHP关联数组中的键：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we will implement Dijkstra''s algorithm using a priority queue. We will
    find a path from the source vertex to the target vertex using the adjacency matrix
    we created for the last diagram. Our Dijkstra''s algorithm will return an array
    with the minimum distance between two nodes and the followed path. We will return
    the path as a stack so that we can get the actual path in the reverse order. Here
    is the implementation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用优先队列来实现Dijkstra算法。我们将使用我们为上一个图表创建的邻接矩阵来找到从源顶点到目标顶点的路径。我们的Dijkstra算法将返回一个数组，其中包括两个节点之间的最小距离和所遵循的路径。我们将路径返回为一个栈，以便我们可以按相反顺序获取实际路径。以下是实现：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we can see from the preceding implementation, first, we created two arrays
    to store the distance and predecessors, along with the priority queue. Then, we
    set each vertex as the maximum integer (`PHP_INT_MAX` ) value of PHP (INFINITY
    in the pseudocode) and the predecessor as `NULL` . We also took the minimum value
    of all adjacent nodes and stored them in the queue. After the loop, we set the
    source node distance as `0` . Then we checked each node in the queue and checked
    the nearest neighbors to find a minimum path. If a path is found using `if ($dist[$u]
    + $cost < $dist[$v])` , we assign it to the vertex.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的实现中可以看出，首先，我们创建了两个数组来存储距离和前任，以及优先队列。然后，我们将每个顶点设置为PHP的最大整数（`PHP_INT_MAX`）值（伪代码中的INFINITY）和前任为`NULL`。我们还取了所有相邻节点的最小值并将它们存储在队列中。循环结束后，我们将源节点的距离设置为`0`。然后我们检查队列中的每个节点，并检查最近的邻居以找到最小路径。如果使用`if
    ($dist[$u] + $cost < $dist[$v])`找到了路径，我们将其分配给该顶点。
- en: 'We then created a stack named `$s` to store the path. We started from our target
    vertex and visited adjacent vertices to reach our source vertex. As we moved through
    the adjacent vertices, we also calculated the distance we covered by visiting
    those vertices. Since our function is returning both the distance and the path,
    we constructed an array to return both the distance and path for the given graph,
    source, and target. If no path exists, we return 0 as the distance and an empty
    stack for the output. Now, we will write a few lines of code to use the graph
    `$graph` and the function `Dijkstra` to check our implementation:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个名为`$s`的栈来存储路径。我们从目标顶点开始，访问相邻的顶点以到达源顶点。当我们通过相邻的顶点移动时，我们还计算了通过访问这些顶点所覆盖的距离。由于我们的函数返回了距离和路径，我们构造了一个数组来返回给定图、源和目标的距离和路径。如果没有路径存在，我们将返回距离为0，并返回一个空栈作为输出。现在，我们将写几行代码来使用图`$graph`和函数`Dijkstra`来检查我们的实现：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we run this code, it will have the following output in our command line:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，它将在命令行中输出以下内容：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The output looks exactly right, as we can see from the graph that the shortest
    path from **A** to **F** is through **C** and the shortest distance is *5 + 3
    = 8* .
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来完全正确，从图表中我们可以看到从**A**到**F**的最短路径是通过**C**，最短距离是*5 + 3 = 8*。
- en: Dijkstra's algorithm has a running complexity of **O** (*V2* ). Since we are
    using the minimum priority queue, the runtime complexity is **O** (*E + V log
    V* ).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra算法的运行复杂度为**O**(*V2*)。由于我们使用了最小优先队列，运行时复杂度为**O**(*E + V log V*)。
- en: Finding the shortest path using the Bellman-Ford algorithm
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bellman-Ford算法找到最短路径
- en: 'Though Dijkstra''s algorithm is the most popular and efficient one that is
    used to find the single source shortest path, there is one problem that it does
    not address. If the graph has a negative cycle, Dijkstra''s algorithm cannot detect
    the negative cycle, and, thus, it does not work. A negative cycle is a cycle where
    the sum of all the edges in the cycle is negative. If a graph contains a negative
    cycle, then finding the shortest path will not be possible, so it is important
    that we address the issue while finding the shortest path. That is why we use
    the Bellman-Ford algorithm, even though it is slower compared to Dijkstra''s algorithm.
    Here is the algorithm pseudocode for the Bellman-Ford algorithm for the shortest
    path:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Dijkstra算法是最流行和高效的用于找到单源最短路径的算法，但它没有解决一个问题。如果图中有一个负循环，Dijkstra算法无法检测到负循环，因此它无法工作。负循环是一个循环，其中所有边的总和为负。如果一个图包含一个负循环，那么找到最短路径将是不可能的，因此在寻找最短路径时解决这个问题是很重要的。这就是为什么我们使用Bellman-Ford算法，尽管它比Dijkstra算法慢。以下是Bellman-Ford算法寻找最短路径的算法伪代码：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can see that the Bellman-Ford algorithm also considers the edge sand vertices
    in finding the shortest path between nodes. This is known as the relaxation process,
    which is also used in Dijkstra''s algorithm. The relaxation process in graph algorithms
    refers to the updating of the cost of all vertices connected to a vertex *V* if
    those costs would be improved by including the path via *V* . In simple words,
    the relaxation process is trying to lower the cost of getting to a vertex using
    another vertex. Now, we will implement this algorithm for the same graph we used
    in Dijkstra''s algorithm. The only difference is that here we will use numeric
    labels for our nodes and vertex here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Bellman-Ford算法在寻找节点之间的最短路径时也考虑了边和顶点。这被称为松弛过程，在Dijkstra算法中也使用。图算法中的松弛过程是指如果通过*V*的路径包括*V*，则更新与顶点*V*连接的所有顶点的成本。简而言之，松弛过程试图通过另一个顶点降低到达一个顶点的成本。现在，我们将为我们在Dijkstra算法中使用的相同图实现这个算法。唯一的区别是这里我们将为我们的节点和顶点使用数字标签：
- en: '![](Image00086.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00086.jpg)'
- en: 'Now it is time to represent the graph in an adjacency matrix format. Here is
    the matrix in PHP:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候以邻接矩阵格式表示图了。以下是PHP中的矩阵：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Previously, we used a value of 0 to indicate that there was no edge between
    two vertices. If we do the same here, then taking a minimum between two edges
    where one represents 0 will always yield a 0 during the relaxation process, which
    actually means that there is no connection between two vertices. As a result,
    we have to choose a larger number to represent the non-existent edges. We can
    use the `MAX_INT_VALUE` constant of PHP to represent those edges so that those
    non-existent edges are not considered. This can be our new graph representation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们使用值0表示两个顶点之间没有边。如果我们在这里做同样的事情，那么在松弛过程中，取两条边中的最小值，其中一条代表0，将始终产生0，这实际上意味着两个顶点之间没有连接。因此，我们必须选择一个更大的数字来表示不存在的边。我们可以使用PHP的`MAX_INT_VALUE`常量来表示这些边，以便这些不存在的边不被考虑。这可以成为我们新的图表示：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s write the implementation for the Bellman-Ford algorithm. We will
    use the same approach we defined in the pseudocode:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为Bellman-Ford算法编写实现。我们将使用在伪代码中定义的相同方法：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Unlike Dijkstra''s algorithm, we are not tracking the predecessors. We are
    considering the distance during the relaxation process. Since we are using the
    maximum value for an integer in PHP, it automatically cancels outs the possibility
    of choosing a nonexistent edge with a value of 0 as the minimum path. The last
    part of the implementation detects any negative cycle in the given graph and returns
    an empty array in that case:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与Dijkstra算法不同的是，我们不是在跟踪前任。我们在松弛过程中考虑距离。由于我们在PHP中使用整数的最大值，它自动取消了选择值为0的不存在边作为最小路径的可能性。实现的最后部分检测给定图中的任何负循环，并在这种情况下返回一个空数组：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will have the following output, which shows the shortest path distance
    from our source node to other nodes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出，显示了从我们的源节点到其他节点的最短路径距离：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The Bellman-Ford algorithm has the run-time complexity of **O** (*V* , *E* ).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Bellman-Ford算法的运行时间复杂度为**O**(*V*, *E*)。
- en: Understanding the minimum spanning tree (MST)
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解最小生成树（MST）
- en: 'Suppose we are designing our new office campus with multiple buildings interconnected
    to each other. If we approach the problem by considering the interconnectivity
    between each building, it will take a huge number of cables. However, if we could
    somehow connect all the buildings through a common connectivity where each building
    is connected to every other building with only one connection, then this solution
    will reduce the redundancy and cost. If we think of our buildings as vertices
    and the connectivity between buildings as the edges, we can construct a graph
    using this approach. The problem we are trying to solve is also known as the **minimum
    spanning tree,** or **MST** . Consider the following graph. We have 10 vertices
    and 21 edges. However, we can connect all 10 vertices with only nine edges (the
    dark line). This will keep our cost or distance to a minimal level:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在设计一个新的办公园区，其中有多栋建筑相互连接。如果我们考虑每栋建筑之间的互联性，将需要大量的电缆。然而，如果我们能够通过一种共同的连接方式将所有建筑物连接起来，其中每栋建筑物只与其他建筑物通过一个连接相连，那么这个解决方案将减少冗余和成本。如果我们把我们的建筑看作顶点，建筑之间的连接看作边，我们可以使用这种方法构建一个图。我们试图解决的问题也被称为**最小生成树**或**MST**。考虑以下图。我们有10个顶点和21条边。然而，我们可以用只有九条边（黑线）连接所有10个顶点。这将使我们的成本或距离保持在最低水平：
- en: '![](Image00087.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00087.jpg)'
- en: There are several algorithms that we can use to find an MST from a given graph.
    The two most popular are Prim's algorithm and Kruskal's algorithm. We will explore
    these two algorithms in the upcoming sections.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种算法可以用来从给定的图中找到最小生成树。最流行的两种是Prim算法和Kruskal算法。我们将在接下来的部分探讨这两种算法。
- en: Implementing Prim's spanning tree algorithm
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Prim生成树算法
- en: 'Prim''s algorithm for finding the minimum spanning tree relies on a greedy
    approach. A greedy approach is defined as an algorithm paradigm where we try to
    find the global optimal solution by considering the local optimal solution at
    each stage. We will explore greedy algorithms in [Chapter 11](text00238.html)
    , *Solve Problems with Advanced Techniques* . In a greedy approach, the algorithm
    creates subsets of edges and finds out the least costly one from the subset of
    edges. This subset of edges will include all vertices. It starts from an arbitrary
    position and grows the tree one vertex at a time by choosing the cheapest possible
    connection between the vertices. Let''s consider the following graph:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Prim算法用于寻找最小生成树依赖于贪婪方法。贪婪方法被定义为一种算法范例，其中我们尝试通过考虑每个阶段的局部最优解来找到全局最优解。我们将在[第11章](text00238.html)中探讨贪婪算法，*使用高级技术解决问题*。在贪婪方法中，算法创建边的子集，并找出子集中成本最低的边。这个边的子集将包括所有顶点。它从任意位置开始，并通过选择顶点之间最便宜的可能连接来逐个顶点地扩展树。让我们考虑以下图：
- en: '![](Image00088.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00088.jpg)'
- en: 'Now, we will apply a very basic version of Prim''s algorithm to get the minimum
    spanning tree as well as the minimum cost or weight of the edges. The graph will
    look like this as an adjacency matrix:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将应用Prim算法的一个非常基本的版本，以获得最小生成树以及边的最小成本或权重。图将看起来像这样，作为邻接矩阵：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we will implement the algorithm for Prim''s minimum spanning tree. We
    are assuming that we are going to start from vertex 0 to find out the whole spanning
    tree, so we will just pass the graph adjacency matrix in the function, and it
    will display the connecting edges for the spanning tree along with the minimum
    cost:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现Prim最小生成树的算法。我们假设我们将从顶点0开始找出整个生成树，因此我们只需将图的邻接矩阵传递给函数，它将显示生成树的连接边以及最小成本：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, if we call the function `primMST` with our graph `$G` , the following
    will be the output and the MST constructed by the algorithm:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们用我们的图$G$调用函数`primMST`，则以下将是算法构建的输出和最小生成树：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![](Image00089.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00089.jpg)'
- en: There are other ways to implement Prim's algorithm with the help of a Fibonacci
    heap, a priority queue, and so on. It is quite similar to Dijkstra's algorithm
    to find the shortest path. Our implementation has a time complexity of **O** (*V²*
    ). Using the binary heap and the Fibonacci heap, we can reduce the complexity
    significantly.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他实现Prim算法的方法，如使用斐波那契堆、优先队列等。这与Dijkstra算法寻找最短路径非常相似。我们的实现具有**O**(*V²*)的时间复杂度。使用二叉堆和斐波那契堆，我们可以显著降低复杂度。
- en: Kruskal's algorithm for spanning tree
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kruskal算法的生成树
- en: 'Another popular algorithm for finding a minimum spanning tree is Kruskal''s
    algorithm. It is similar to Prim''s algorithm and uses a greedy approach to find
    the solution. Here are the steps we need to implement Kruskal''s algorithm:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于寻找最小生成树的流行算法是Kruskal算法。它类似于Prim算法，并使用贪婪方法来找到解决方案。以下是我们需要实现Kruskal算法的步骤：
- en: Create a forest **T** (a set of trees), where each vertex in the graph is a
    separate tree.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个森林**T**（一组树），图中的每个顶点都是一个单独的树。
- en: Create a set **S** containing all the edges in the graph.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含图中所有边的集合**S**。
- en: 'While **S** is non-empty and **T** is not yet spanning:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当**S**非空且**T**尚未跨越时：
- en: 1\. Remove an edge with the minimum weight from **S** .
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 从**S**中移除权重最小的边。
- en: 2\. If that edge connects two different trees, then add it to the forest, combining
    two trees into a single tree; otherwise, discard that edge.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 如果该边连接两棵不同的树，则将其添加到森林中，将两棵树合并成一棵树；否则，丢弃该边。
- en: 'We will use the same graph that we used for Prim''s algorithm. Here is the
    implementation of Kruskal''s algorithm:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与Prim算法相同的图。以下是Kruskal算法的实现：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As we can see, we have two separate functions—`unionSet` and `findSet` —to
    perform the union operations of two disjointed sets, as well as find out whether
    a number exists in a set or not. Now, let''s run the program with our constructed
    graph like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们有两个单独的函数——`unionSet`和`findSet`——来执行两个不相交集合的并操作，以及找出一个数字是否存在于集合中。现在，让我们用我们构建的图运行程序：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will produce the following output, which is similar to our output from
    Prim''s algorithm:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出，与我们从Prim算法得到的输出类似：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The complexity of Kruskal's algorithm is **O** (*E log V* ), which is better
    than the generic implementation of Prim's algorithm.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Kruskal算法的复杂度是**O**(*E log V*），这比通用的Prim算法实现更好。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed different graph algorithms and their operations.
    Graphs are very handy in solving a wide range of problems. We have seen that for
    the same graph, we can apply different algorithms and get different performances.
    We have to choose carefully which algorithms we want to apply based on the nature
    of the problem. There are many other graph topics that we left out of this book
    due to some constraints. There are topics such as graph coloring, bipartite matching,
    and flow problems, which should be studied and applied where applicable. In the
    next chapter, we will shift our focus to our last data structure topic for this
    book, called heap, and learn the different usages of the heap data structure.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了不同的图算法及其操作。图在解决各种问题时非常方便。我们已经看到，对于相同的图，我们可以应用不同的算法并获得不同的性能。我们必须仔细选择要应用的算法，这取决于问题的性质。由于某些限制，本书中我们略过了许多其他图的主题。有一些主题，如图着色、二分匹配和流问题，应该在适用的地方进行研究和应用。在下一章中，我们将把重点转移到本书的最后一个数据结构主题，称为堆，学习堆数据结构的不同用法。
