- en: Chapter 5.  Creating a RESTful Web Service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。创建RESTful Web服务
- en: The goal of this chapter is to implement a RESTful Web Service that can be used
    to manage user profiles. Each user will have some basic contact information (such
    as a username, a given name, and a family name), a password for authentication,
    and a profile image.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是实现一个RESTful Web服务，用于管理用户配置文件。每个用户将具有一些基本的联系信息（例如用户名、名字和姓氏）、用于认证的密码和个人资料图片。
- en: This service will be implemented using the Slim micro framework, a small and
    lightweight framework that is available as an open-source library (MIT licensed)
    for PHP 5.5 and newer (we'll be using PHP 7, of course). For persistence, a MongoDB
    database will be used. This offers the perfect chance to explore PHP's MongoDB
    extension, which replaces the old (similarly named, but completely different)
    Mongo extension that was removed with PHP 7.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这项服务将使用Slim微框架实现，这是一个小巧轻便的框架，作为PHP 5.5及更新版本的开源库（MIT许可）提供（当然我们将使用PHP 7）。为了持久性，将使用MongoDB数据库。这提供了一个完美的机会来探索PHP的MongoDB扩展，它取代了旧的（同名，但完全不同）在PHP
    7中被移除的Mongo扩展。
- en: 'In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: The basics of RESTful Web Services, most importantly the common HTTP request
    and response methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful Web服务的基础知识，最重要的是常见的HTTP请求和响应方法
- en: Installing and using the Slim framework, and also the basics of the PSR-7 standard
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和使用Slim框架，以及PSR-7标准的基础知识
- en: Designing and implementing the actual example RESTful Web Service using the
    Slim framework and MongoDB storage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Slim框架和MongoDB存储设计和实现实际示例RESTful Web服务
- en: How to work with PSR-7 streams and store large files in a MongoDB database with
    GridFS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用PSR-7流和在MongoDB数据库中使用GridFS存储大文件
- en: RESTful basics
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful基础知识
- en: In this section, we will recapitulate the basics of RESTful Web Services. You
    will learn about the basic architectural goals of REST Web Services and the most
    common protocol semantics of the **Hypertext Transfer Protocol** (**HTTP**), which
    is commonly used to implement such services.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重述RESTful Web服务的基础知识。您将了解REST Web服务的基本架构目标以及**超文本传输协议**（**HTTP**）的最常见协议语义，通常用于实现此类服务。
- en: REST architectures
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST架构
- en: The term **Representational State Transfer** was coined by Roy Fielding in 2000
    and describes an architectural style for distributed systems that is, in principle,
    independent of any concrete communication protocol. In practice, most REST architectures
    are implemented using the **Hypertext Transfer Protocol** - in short, HTTP.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**表现状态转移**这个术语是由Roy Fielding在2000年创造的，描述了一种分布式系统的架构风格，原则上独立于任何具体的通信协议。实际上，大多数REST架构都是使用**超文本传输协议**来实现的，简称HTTP。'
- en: 'The key component of each RESTful Web Service is the resource. Each resource
    should meet the following requirements:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个RESTful Web服务的关键组件是资源。每个资源应满足以下要求：
- en: '**Addressability**: Each resource must be identifiable by a **Uniform Resource
    Identifier** (**URI**), which is standardized in RFC 3986\. For instance, a user
    with the username `johndoe` might have the URI `http://example.com/api/users/johndoe`.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可寻址性**：每个资源必须由**统一资源标识符**（**URI**）进行标识，这在RFC 3986中得到了标准化。例如，具有用户名`johndoe`的用户可能具有URI`http://example.com/api/users/johndoe`。'
- en: '**Statelessness**: The participants'' communication between each other is stateless;
    this means that REST applications typically do not use user sessions. Instead,
    each request needs to contain all information that the server will need to fulfill
    the request.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态性**：参与者之间的通信是无状态的；这意味着REST应用程序通常不使用用户会话。相反，每个请求都需要包含服务器需要满足请求的所有信息。'
- en: '**Uniform interface**: Each resource must be accessible by a set of standard
    methods. When using HTTP as a transfer protocol, you will typically use the HTTP
    methods for querying or modifying the state of resources. The next section of
    this chapter contains a short overview of the most common HTTP standard methods
    and response codes.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一接口**：每个资源必须可通过一组标准方法访问。当使用HTTP作为传输协议时，您通常会使用HTTP方法来查询或修改资源的状态。本章的下一节包含对最常见的HTTP标准方法和响应代码的简要概述。'
- en: '**Decoupling of resources and representation**: Each resource can have multiple
    representations. For example, a REST service might serve both a JSON and an XML
    representation of a user profile. Typically, the client specifies in which format
    the server should respond, and the server will choose a representation that best
    fits the requirements specified by the client. This process is called  **Content
    Negotiation**.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源和表示的解耦**：每个资源可以有多个表示。例如，REST服务可能同时提供用户配置文件的JSON和XML表示。通常，客户端会指定服务器应该以哪种格式响应，服务器将选择最符合客户端指定要求的表示。这个过程称为**内容协商**。'
- en: In this chapter, you will learn to implement all these architectural principles
    in a small RESTful Web Service. You will implement several different resource
    types with different representations and learn how to use different HTTP methods
    and response codes to query and modify these resources. Additionally, you will
    learn how you can use advanced HTTP features to your advantage (such as the rich
    set of cache-control headers).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何在一个小型的RESTful Web服务中实现所有这些架构原则。您将实现几种不同类型的资源，具有不同的表示，并学习如何使用不同的HTTP方法和响应代码来查询和修改这些资源。此外，您还将学习如何利用高级的HTTP功能（例如丰富的缓存控制头集）。
- en: Common HTTP methods and response codes
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的HTTP方法和响应代码
- en: HTTP defines a set of standard methods (or *verbs*) that clients can use in
    requests, and status codes that servers can use in responses to said requests.
    In REST architectures, the different request methods are used to either query
    or modify the server-side state of the resource that is identified by the request
    URI. These request methods and response status codes are standardized in RFC 7231\.
    **Table 1** and **Table 2** show an overview of the most common request methods
    and status codes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP定义了一组标准方法（或*动词*），客户端可以在请求中使用，以及服务器可以在响应中使用的状态代码。在REST架构中，不同的请求方法用于查询或修改由请求URI标识的资源的服务器端状态。这些请求方法和响应状态代码在RFC
    7231中标准化。**表1**和**表2**显示了最常见的请求方法和状态代码的概述。
- en: The request methods `GET`, `HEAD`, and `OPTIONS` are defined as *safe*. Servers
    should not modify their own state when processing these kinds of requests. Furthermore,
    both the safe methods and `PUT` and `DELETE` methods are defined as *idempotent*.
    Idempotency means that repeated identical requests should have the same effect
    as a single request - for instance, multiple `DELETE` requests to the `/api/users/12345`
    URI should still result in that one resource being deleted.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请求方法`GET`，`HEAD`和`OPTIONS`被定义为*安全*。服务器在处理这些类型的请求时不应修改自己的状态。此外，安全方法和`PUT`和`DELETE`方法都被定义为*幂等*。幂等性意味着重复的相同请求应具有与单个请求相同的效果-例如，对`/api/users/12345`
    URI的多个`DELETE`请求仍应导致删除该资源。
- en: 'Table 1, Common HTTP request methods:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 表1，常见的HTTP请求方法：
- en: '| **HTTP method** | **Description** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP方法** | **描述** |'
- en: '| `GET` | Used for querying the state of the resource identified by the URI.
    The server responds with a representation of the queried resource. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 用于查询由URI标识的资源的状态。服务器将以查询的资源表示形式做出响应。 |'
- en: '| `HEAD` | Just like `GET`, except the server returns only the response headers
    and not the actual resource representation. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `HEAD` | 就像`GET`一样，只是服务器返回响应头，而不是实际的资源表示。 |'
- en: '| `POST` | `POST` requests can contain a resource representation in their request
    body. The server should store this object as a new sub-resource of the resource
    identified by the request URI. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `POST`请求可以在其请求体中包含资源表示。服务器应将此对象存储为请求URI标识的资源的新子资源。 |'
- en: '| `PUT` | Just like `POST`, `PUT` requests also contain a resource representation
    in their request body. The server should ensure that a resource with the given
    URI and representation exists and should create one if necessary. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 就像`POST`一样，`PUT`请求也在其请求体中包含资源表示。服务器应确保具有给定URI和表示的资源存在，并且如果需要应创建一个资源。
    |'
- en: '| `DELETE` | Deletes the resource with the specified URI. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 删除指定URI的资源。 |'
- en: '| `OPTIONS` | Can be used by clients to query which operations are allowed
    for a given resource. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `OPTIONS` | 客户端可以使用它来查询给定资源允许哪些操作。 |'
- en: 'Table 2: Common HTTP response status codes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表2：常见的HTTP响应状态代码：
- en: '| **Status code** | **Description** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **状态代码** | **描述** |'
- en: '| `200 OK` | The request was successfully processed; the response message typically
    contains a representation of the requested resource. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `200 OK` | 请求已成功处理；响应消息通常包含所请求资源的表示。 |'
- en: '| `201 Created` | Like `200 OK`, but in addition, explicitly states that a
    new resource was created by the request. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `201 Created` | 像`200 OK`一样，但另外明确指出请求创建了一个新资源。 |'
- en: '| `202 Accepted` | The request was accepted for processing, but has not yet
    been processed. This is useful when a server processes time-consuming requests
    asynchronously. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `202 Accepted` | 请求已被接受处理，但尚未被处理。当服务器异步处理耗时请求时，这是有用的。 |'
- en: '| `400 Bad Request` | The server was unable to interpret the client''s request.
    This might be the case when a request contains invalid JSON or XML data. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `400 Bad Request` | 服务器无法解释客户端的请求。当请求包含无效的JSON或XML数据时可能会出现这种情况。 |'
- en: '| `401 Unauthorized` | The client needs to authenticate before accessing this
    resource. The response can contain more information on the required authentication
    and the request can be repeated with appropriate credentials. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `401 Unauthorized` | 客户端需要在访问此资源之前进行身份验证。响应可以包含有关所需身份验证的更多信息，并且请求可以使用适当的凭据重复。
    |'
- en: '| `403 Forbidden` | Can be used when the client was authenticated, but is not
    authorized to access a given resource. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `403 Forbidden` | 当客户端经过身份验证，但未被授权访问特定资源时可以使用。 |'
- en: '| `404 Not Found` | Used when the resource specified by the URI does not exist.
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `404 Not Found` | 当URI指定的资源不存在时使用。 |'
- en: '| `405 Method Not Allowed` | The request method is not allowed for the specified
    resource. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `405 Method Not Allowed` | 请求方法不允许指定的资源。 |'
- en: '| `500 Internal Server Error` | An error occurred on the server while processing
    the request. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `500 Internal Server Error` | 服务器在处理请求时发生错误。 |'
- en: First steps with the Slim framework
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Slim框架的第一步
- en: In this section, you will take you first steps with the Slim framework. For
    this, you will first use Composer to install the framework and then build a small
    sample application that will show you the basic principles of the framework.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将首先使用Composer安装框架，然后构建一个小型示例应用程序，该应用程序将向您展示框架的基本原则。
- en: Installing Slim
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Slim
- en: 'The Slim framework can be easily installed using Composer. It requires PHP
    in at least version 5.5, but also works well with PHP 7\. Start by initializing
    a new project with Composer:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Slim框架可以很容易地使用Composer安装。它需要至少版本5.5的PHP，但也可以很好地与PHP 7一起使用。首先通过Composer初始化一个新项目：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will create a new project-level `composer.json` file for our project.
    Now you can add the slim/slim package as a dependency:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们的项目创建一个新的项目级`composer.json`文件。现在，您可以将slim/slim包添加为依赖项：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A small sample application
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个小样本应用程序
- en: 'You can now start using the Slim framework in your PHP application. For this,
    create an `index.php` file in your web server''s document root with the following
    content:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在您的PHP应用程序中开始使用Slim框架。为此，在您的Web服务器文档根目录中创建一个`index.php`文件，并包含以下内容：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's have a look at how the Slim framework works here. The central object here
    is the `$app` variable, an instance of the `Slim\App` class. You can then use
    this application instance to register routes. Each route is a mapping of an HTTP
    request path to a simple callback function that handles an HTTP request. These
    handler functions need to accept a request and a response object and need to return
    a new response object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Slim框架在这里是如何工作的。这里的中心对象是`$app`变量，它是`Slim\App`类的一个实例。然后可以使用这个应用实例来注册路由。每个路由都是一个将HTTP请求路径映射到处理HTTP请求的简单回调函数。这些处理函数需要接受一个请求和一个响应对象，并需要返回一个新的响应对象。
- en: 'Before you can test this application, you may need to configure your web server
    to rewrite all requests to your `index.php` file. If you are using Apache as a
    web server, this can be done with a simple `.htaccess` file in your document root:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试这个应用程序之前，你可能需要配置你的Web服务器将所有请求重写到你的`index.php`文件。如果你正在使用Apache作为Web服务器，可以在你的文档根目录中使用一个简单的`.htaccess`文件来完成这个操作：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This configuration will rewrite requests for all URLs to your `index.php` file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置将重写所有URL的请求到你的`index.php`文件。
- en: 'You can test your (admittedly still very simple) API with your browser. If
    you prefer the command line, I can recommend the **HTTPie** command-line tool.
    HTTPie is Python-based and you can easily install it using your operating system''s
    package manager or Python''s own package manager, **pip**:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用浏览器测试你的（尽管仍然非常简单的）API。如果你更喜欢命令行，我可以推荐使用HTTPie命令行工具。HTTPie是基于Python的，你可以使用操作系统的软件包管理器或Python自己的软件包管理器pip轻松安装它：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can then use `HTTPie` on the command-line to perform RESTful HTTP requests
    easily and also get syntax-highlighted output. See the following figure for an
    example output of HTTPie when used with the example application:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以在命令行上使用`HTTPie`轻松执行RESTful HTTP请求，并获得语法高亮的输出。查看以下图例，了解在与示例应用程序一起使用HTTPie时的示例输出：
- en: '![A small sample application](graphics/image_05_001.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![一个小样例应用](graphics/image_05_001.jpg)'
- en: Example output of HTTPie with the Slim example application
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Slim示例应用程序的HTTPie的示例输出
- en: Accepting URL parameters
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接受URL参数
- en: 'Slim routes can also contain parameters in their path. In your `index.php`,
    add the following route before the last `$app->run()` statement:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Slim路由也可以包含路径中的参数。在你的`index.php`中，在最后一个`$app->run()`语句之前添加以下路由：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, any route specification can contain arbitrary parameters in
    curly brackets. The route handler function can then accept a third parameter that
    contains all path parameters from the URL as an associative array (such as the
    username parameter in the preceding example).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，任何路由规范都可以包含花括号中的任意参数。然后路由处理函数可以接受一个包含URL中所有路径参数的关联数组的第三个参数（例如前面示例中的用户名参数）。
- en: Accepting HTTP requests with a message body
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受带有消息体的HTTP请求
- en: So far, you have only worked with HTTP `GET` requests. Of course, the Slim framework
    also supports any other kind of request method that is defined by the HTTP protocol.
    One interesting difference between a `GET` and - for example - a `POST` request,
    however, is that some requests (such as `POST`, `PUT`, and others) can contain
    a request body.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只使用了HTTP `GET`请求。当然，Slim框架也支持HTTP协议定义的任何其他类型的请求方法。然而，`GET`和例如`POST`请求之间的一个有趣的区别是，一些请求（如`POST`、`PUT`等）可以包含请求体。
- en: 'The request body consists of structured data that is serialized as a string
    according to some pre-defined encoding. When sending a request to a server, the
    client uses the **Content-Type** HTTP header to tell the server which encoding
    is used for the request body. Common encodings include the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请求体由结构化数据组成，按照预定义的编码序列化为字符串。当向服务器发送请求时，客户端使用Content-Type HTTP头告诉服务器请求体使用的编码。常见的编码包括以下内容：
- en: '`application/x-www-form-urlencoded` is typically used by browsers when submitting
    an HTML form'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/x-www-form-urlencoded` 通常由浏览器在提交HTML表单时使用'
- en: '`application/json` for JSON encoding'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/json` 用于JSON编码'
- en: '`application/xml` or `text/xml` for XML encoding'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/xml` 或 `text/xml` 用于XML编码'
- en: 'Luckily, the Slim framework supports all these encodings and determines the
    correct method to parse a request body automatically. You can test this with the
    following simple route handler:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Slim框架支持所有这些编码，并自动确定解析请求体的正确方法。你可以使用以下简单的路由处理程序进行测试：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note the use of the `getParsedBody()` method that is offered by the `Request`
    class. This method will use the request body and automatically use the correct
    decoding method depending on the Content-Type header that was present in the request.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`Request`类提供的`getParsedBody()`方法。这个方法将使用请求体，并根据请求中存在的Content-Type头自动使用正确的解码方法。
- en: 'You can now use any of the preceding content encodings presented to `POST`
    data to this route. This can be easily tested using the following curl commands:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用之前介绍的任何内容编码来将数据`POST`到这个路由。可以使用以下curl命令进行简单测试：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All of these requests will yield the same response from your Slim application,
    as they're containing the exact same data, just using a different content encoding.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些请求将从你的Slim应用程序中产生相同的响应，因为它们包含完全相同的数据，只是使用了不同的内容编码。
- en: The PSR-7 standard
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PSR-7标准
- en: One of the Slim framework's main features is the PSR-7 compliance. PSR-7 is
    a **PHP Standard Recommendation** (**PSR**) defined by the **PHP Framework Interoperability
    Group** (**FIG**) and describes a set of standard interfaces that can be implemented
    by HTTP servers and client libraries written in PHP to increase operability between
    those products (or in plain English, to enable these libraries to be used with
    each other).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Slim框架的主要特性之一是PSR-7兼容性。PSR-7是由PHP框架互操作性组（FIG）定义的PHP标准推荐（PSR），描述了一组标准接口，可以由PHP编写的HTTP服务器和客户端库实现，以增加这些产品之间的可操作性（或者用简单的英语来说，使这些库可以相互使用）。
- en: 'PSR-7 defines a set of PHP interfaces that the framework can implement. The
    following figure illustrates the interfaces that are defined by the PSR-7 standard.
    You can even install these interfaces in your project by acquiring the `psr/http-messages`
    package using Composer:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-7定义了框架可以实现的一组PHP接口。下图说明了PSR-7标准定义的接口。您甚至可以通过使用Composer获取`psr/http-messages`包在您的项目中安装这些接口：
- en: '![The PSR-7 standard](graphics/image_05_002.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![PSR-7标准](graphics/image_05_002.jpg)'
- en: The interfaces defined by the PSR-7 standard
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-7标准定义的接口
- en: The `Slim\Http\Request` and `Slim\Http\Response` classes that you have worked
    with in the previous examples already implement these PSR-7 interfaces (the `Slim\Http\Request`
    class implements the `ServerRequestInterface` and `Slim\Http\Response` implements `ResponseInterface`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您在之前的示例中使用的`Slim\Http\Request`和`Slim\Http\Response`类已经实现了这些PSR-7接口（`Slim\Http\Request`类实现了`ServerRequestInterface`，`Slim\Http\Response`实现了`ResponseInterface`）。
- en: 'These standardized interfaces become especially useful when you want to use
    two different HTTP libraries together. As an interesting example, consider a PSR-7
    compliant HTTP server framework like Slim used together with a PSR-7 compliant
    client library, for example **Guzzle** (use the package key `guzzlehttp/guzzle`
    if you want to install it with Composer). You can use these two libraries and
    easily wire them together for a dead-simple reverse proxy:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要将两个不同的HTTP库一起使用时，这些标准化的接口变得特别有用。作为一个有趣的例子，考虑一个PSR-7兼容的HTTP服务器框架，比如与一个PSR-7兼容的客户端库一起使用，例如**Guzzle**（如果要使用Composer安装，请使用包键`guzzlehttp/guzzle`）。您可以使用这两个库，并轻松地将它们连接在一起，实现一个非常简单的反向代理：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What exactly happens here? The Slim request handler gets an implementation of
    the `ServerRequestInterface` passed as a first parameter (remember; this interface
    inherits the regular `RequestInterface`) and needs to return a `ResponseInterface`
    implementation. Conveniently, the `send()` method of `GuzzleHttp\Client` also
    accepts a `RequestInterface` and returns a `ResponseInterface`. Because of this,
    you can simply re-use the request object that you received in your handler and
    pipe it into the Guzzle client and also re-use the response object returned by
    the Guzzle client. Guzzle's `send()` method actually returns an instance of the
    `GuzzleHttp\Psr7\Response` class (and not `Slim\Http\Response`). That is completely
    acceptable, as both of these classes implement the same interface. In addition,
    the preceding example uses the method defined by the PSR-7 interfaces to modify
    the host part of the request URI.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里到底发生了什么？Slim请求处理程序将`ServerRequestInterface`的实现作为第一个参数传递（记住；这个接口继承了常规的`RequestInterface`），并且需要返回一个`ResponseInterface`的实现。方便的是，`GuzzleHttp\Client`的`send()`方法也接受`RequestInterface`并返回`ResponseInterface`。因此，您可以简单地重用您在处理程序中收到的请求对象，并将其传递到Guzzle客户端中，并且还可以重用Guzzle客户端返回的响应对象。Guzzle的`send()`方法实际上返回`GuzzleHttp\Psr7\Response`类的实例（而不是`Slim\Http\Response`）。这是完全可以接受的，因为这两个类都实现了相同的接口。此外，前面的示例使用了PSR-7接口定义的方法来修改请求URI的主机部分。
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Immutable Objects** You may have wondered about the `withUri` and `withHost`
    methods in the preceding code example. Why do the PSR-7 interfaces not imply declare
    methods such as `setUri` or `setHost`? The answer is that all PSR-7 implementations
    are designed to be immutable. This means that objects are not intended to be modified
    after they are created. All the methods starting with `with` (and PSR-7 actually
    defines a lot of them) are designed to return a copy of the original object with
    one modified property. So basically, instead of modifying objects with setter
    methods, you''ll be passing around clones of an original object:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可变对象** 您可能会对前面示例中的`withUri`和`withHost`方法感到好奇。为什么PSR-7接口没有声明`setUri`或`setHost`等方法？答案是所有PSR-7实现都设计为不可变。这意味着对象在创建后不打算被修改。所有以`with`开头的方法（实际上PSR-7定义了很多）都旨在返回原始对象的副本，其中一个属性被修改。因此，基本上，您将传递原始对象的克隆，而不是使用setter方法修改对象：'
- en: '`// using mutable objects (not supported by PSR-7)`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 使用可变对象（不受PSR-7支持）`'
- en: '`$uri->setHost(''foobar.com'');`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`$uri->setHost(''foobar.com'');`'
- en: '`// using immutable objects`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 使用不可变对象`'
- en: '`$uri = $uri->withHOst(''foobar.com'');`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`$uri = $uri->withHOst(''foobar.com'');`'
- en: Middleware
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件
- en: 'Middleware is one of the most important features of the Slim framework and
    similar libraries. It allows you to modify an HTTP request before it is passed
    to the actual request handler, modify an HTTP response after being returned from
    the request handler, or bypass a request handler entirely. There are quite a number
    of possible use cases for this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是Slim框架和类似库中最重要的功能之一。它允许您在将HTTP请求传递给实际请求处理程序之前修改HTTP请求，在从请求处理程序返回后修改HTTP响应，或者完全绕过请求处理程序。这有很多可能的用例：
- en: You can handle authentication and authorization in middleware. Authentication
    encompasses identifying a user from given request parameters (maybe the HTTP request
    contains an authorization header or a cookie with a session ID) and authorization
    involves checking if the authenticated user is actually allowed to access a particular
    resource.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在中间件中处理身份验证和授权。身份验证包括从给定的请求参数中识别用户（也许HTTP请求包含授权头或包含会话ID的cookie），授权涉及检查经过身份验证的用户是否实际被允许访问特定资源。
- en: You can implement a rate limiting for your API by counting requests by a particular
    user and returning with an error response code early before hitting the actual
    request handler.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过计算特定用户的请求次数并在实际请求处理程序之前返回错误响应代码来为您的API实现速率限制。
- en: In general, all kinds of operations that enrich a request with additional data
    before being processed by the request handler.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总的来说，所有在请求被请求处理程序处理之前丰富请求的各种操作。
- en: Middleware is also chainable. The framework can manage any number of middleware
    components, and an incoming request will be piped through all registered middleware.
    Each item of middleware must be callable as a function and accept a `RequestInterface`,
    a `ResponseInterface`, and a function that represents the next instance of middleware
    (or the request handler itself).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件也是可链接的。框架可以管理任意数量的中间件组件，并且传入的请求将通过所有注册的中间件。每个中间件项必须作为函数可调用，并接受 `RequestInterface`、`ResponseInterface`
    和表示下一个中间件实例（或请求处理程序本身）的函数。
- en: 'The following code example shows middleware that adds an (admittedly extremely
    simple) HTTP authentication to an application:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了一个向应用程序添加（诚然非常简单的）HTTP 身份验证的中间件：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `$app->add()` function can be used to register middleware that will be invoked
    on any request. As you can see, the middleware function itself looks similar to
    a regular request handler, with the only difference being the third parameter,
    `$next`. Each request can be passed through a potentially indeterminate amount
    of middleware. The `$next` function gives a component of middleware control over
    whether a request should be passed to the next component of middleware in the
    chain (or the registered request handler itself). It is important to note, however,
    that the middleware does not have to call the `$next` function at any time. In
    the preceding example, an unauthorized HTTP request will never even get through
    to the actual request handler, because the middleware that handles authentication
    does not invoke `$next` at all when there is no valid authentication.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`$app->add()` 函数可用于注册中间件，该中间件将在任何请求上被调用。正如你所看到的，中间件函数本身看起来类似于常规请求处理程序，唯一的区别是第三个参数
    `$next`。每个请求可以通过潜在的不确定数量的中间件。`$next` 函数使得中间件组件可以控制请求是否应该传递给链中的下一个中间件组件（或注册的请求处理程序本身）。然而，需要注意的是，中间件不必在任何时候调用
    `$next` 函数。在上面的例子中，未经授权的 HTTP 请求甚至不会通过实际的请求处理程序，因为处理身份验证的中间件在没有有效身份验证时根本不调用 `$next`。'
- en: This is where PSR-7 comes into play. Because of PSR-7, you can develop and distribute
    middleware and they will work with all frameworks and libraries that also implement
    PSR-7\. This guarantees interoperability between libraries and also ensures that
    there is a shared ecosystem of libraries that can be widely re-used. A simple
    Internet search for `PSR-7 middlewares` yields a plethora of libraries that you
    can use nearly out-of-the box.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 PSR-7 起作用的地方。由于 PSR-7，您可以开发和分发中间件，并且它们将与实现 PSR-7 的所有框架和库一起工作。这保证了库之间的互操作性，并确保存在可以广泛重用的库的共享生态系统。简单的互联网搜索
    `PSR-7 中间件` 将产生大量几乎可以立即使用的库。
- en: Implementing the REST service
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 REST 服务
- en: In this chapter, you will begin implementing the actual user profile service.
    As a first step, we will design the RESTful API of the service and then continue
    by implementing the designed API endpoints.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将开始实现实际的用户配置文件服务。作为第一步，我们将设计服务的 RESTful API，然后继续实现设计的 API 端点。
- en: Designing the service
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计服务
- en: Now it is time to get to the actual task that we want to implement in this chapter.
    In this chapter, you will develop a RESTful Web Service using the Slim framework
    and MongoDB to access and read user profiles. In short, one of the first steps
    that you should take when designing a REST Web Service is to think about the resources
    that you want to offer to your users.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始实现本章中要实现的实际任务了。在本章中，您将使用 Slim 框架和 MongoDB 开发一个 RESTful Web 服务，以访问和读取用户配置文件。简而言之，在设计
    REST Web 服务时，您应该考虑要向用户提供的资源的第一步。
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Keeping RESTful** Be sure to design around resources whose state you modify
    with HTTP verbs such as `POST`, `PUT`, and `DELETE`. I''ve often seen HTTP APIs
    being developed around procedures, not resources, that end up in URLs such as `POST
    /users/create` or `POST /users/update` that resemble more of an RPC-based API
    design.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**保持 RESTful** 请确保围绕使用 `POST`、`PUT` 和 `DELETE` 等 HTTP 动词修改状态的资源进行设计。我经常看到围绕过程而不是资源开发的
    HTTP API，最终导致 URL，例如 `POST /users/create` 或 `POST /users/update`，更像是基于 RPC 的 API
    设计。'
- en: 'The table that follows shows the resources and operations that we''ll be working
    with in this chapter. There are a few central resources:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了本章中将使用的资源和操作。有一些中心资源：
- en: '`/profiles` is a collection of all known profiles. It is read-only - meaning
    that only `GET` (and `HEAD`) operations will be allowed - and contains a collection
    of all user profiles. Users of your API should be able to filter the set by a
    set of constraints or limit the returned collection to a given length. Both filtering
    and limitations can be implemented as optional query parameters:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/profiles` 是所有已知配置文件的集合。它是只读的 - 意味着只允许 `GET`（和 `HEAD`）操作 - 并包含所有用户配置文件的集合。您的
    API 的用户应该能够通过一组约束来过滤集合或将返回的集合限制为给定长度。过滤和限制都可以作为可选查询参数实现：'
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`/profiles/{username}` is a resource that represents a single user. A `GET`
    request on this resource will return this user''s profile, while a `PUT` request
    will create the profile or update it if it already exists and a `DELETE` request
    will delete the profile.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/profiles/{username}` 是代表单个用户的资源。对此资源的 `GET` 请求将返回该用户的配置文件，而 `PUT` 请求将创建配置文件或更新已存在的配置文件，`DELETE`
    请求将删除配置文件。'
- en: '`/profiles/{username}/image` represents a user''s profile image. It can be
    set using a `PUT` operation, read with a `GET` operation, and removed with a `DELETE`
    operation.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/profiles/{username}/image` 代表用户的配置文件图像。可以使用 `PUT` 操作设置它，使用 `GET` 操作读取它，并使用
    `DELETE` 操作删除它。'
- en: '| **Route** | **Purpose** |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **路由** | **目的** |'
- en: '| `GET /profiles` | Lists all users, optionally filtered by search parameters
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `GET /profiles` | 列出所有用户，可选择按搜索参数过滤 |'
- en: '| `GET /profiles/{username}` | Returns a single user |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `GET /profiles/{username}` | 返回单个用户 |'
- en: '| `PUT /profiles/{username}` | Creates a new user with a given username or
    updates an already existing one with that username |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `PUT /profiles/{username}` | 创建具有给定用户名的新用户，或更新已存在的具有该用户名的用户 |'
- en: '| `DELETE /profiles/{username}` | Deletes a user |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE /profiles/{username}` | 删除用户 |'
- en: '| `PUT /profiles/{username}/image` | Stores a new profile image for a user
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `PUT /profiles/{username}/image` | 为用户存储新的个人资料图片 |'
- en: '| `GET /profiles/{username}/image` | Retrieves the user''s profile image |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `GET /profiles/{username}/image` | 检索用户的个人资料图片 |'
- en: '| `DELETE /profiles/{username}/image` | Deletes a profile image |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE /profiles/{username}/image` | 删除个人资料图片 |'
- en: One question that might arise is why this example uses a `PUT` request to create
    new profiles, and not `POST`. I've often seen `POST` being associated with *creating
    objects* and `PUT` with *updating objects* - this is an incorrect interpretation
    of the HTTP standards. Note that we're using the username as part of the profile's
    URI. This means that when creating a profile for a new user with a given user
    name, you already know which URI the resource will have after it's created.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现的一个问题是，为什么这个例子使用`PUT`请求来创建新的个人资料，而不是`POST`。我经常看到`POST`与*创建对象*相关联，`PUT`与*更新对象*相关联
    - 这是对HTTP标准的错误解释。请注意，我们将用户名作为个人资料的URI的一部分。这意味着当为具有给定用户名的新用户创建个人资料时，您已经知道资源在创建后将具有哪个URI。
- en: And that is exactly what the `PUT` resource is for - ensuring that a resource
    with a given representation exists with the given URI. The advantage is that you
    can rely on `PUT` requests being idempotent. This means that a dozen identical
    `PUT` requests to `/profiles/martin-helmich` will not do any harm, while a dozen
    identical `POST` requests to `/profiles/` might very well create a dozen different
    user profiles.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是`PUT`资源的作用 - 确保具有给定表示的资源存在于给定的URI中。优点是您可以依赖`PUT`请求是幂等的。这意味着对`/profiles/martin-helmich`的十几个相同的`PUT`请求不会造成任何伤害，而对`/profiles/`的十几个相同的`POST`请求很可能会创建十几个不同的用户资料。
- en: Bootstrapping the project
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动项目
- en: 'Before beginning to implement your REST service, you will probably need to
    take care of some system requirements. For the sake of simplicity, we''ll be working
    with a set of linked Docker containers in this example. Start by creating a new
    container running a MongoDB instance using the official MongoDB image:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现REST服务之前，您可能需要处理一些系统要求。为了简单起见，我们将在这个例子中使用一组链接的Docker容器。首先创建一个新的容器，使用官方的MongoDB镜像运行一个MongoDB实例：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For the application container, you can use the official PHP image. However,
    as the MongoDB PHP driver is not part of the standard PHP distribution, you will
    need to install it via **PECL**. For this, you can create a custom **Dockerfile** to
    build your application container:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序容器，您可以使用官方的PHP镜像。但是，由于MongoDB PHP驱动程序不是标准PHP分发的一部分，您需要通过**PECL**安装它。为此，您可以创建一个自定义的**Dockerfile**来构建您的应用程序容器：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, build your container and run it. Link it to the already running MongoDB
    container:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，构建您的容器并运行它。将其链接到已经运行的MongoDB容器：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will create a new Apache container running PHP 7 with the current working
    directory mapped to the web server's document root. The `-p 80:80` flag allows
    the Apache container to be accessed using `http://localhost` from your browser
    or a command-line client.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的Apache容器，其中运行PHP 7，并将当前工作目录映射到Web服务器的文档根目录。`-p 80:80`标志允许通过浏览器或命令行客户端使用`http://localhost`访问Apache容器。
- en: 'Just like in the first examples in this chapter, we will be using Composer
    to manage the project''s dependencies and for automatic class loading. You can
    start with the following `composer.json` file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本章的第一个例子一样，我们将使用Composer来管理项目的依赖关系和自动类加载。您可以从以下`composer.json`文件开始：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After creating the `composer.json` file, install the project's dependencies
    with `composer install`. If you are not running Composer in an environment that
    matches all specified constraints, you can add the `--ignore-platform-reqs` flag
    to the Composer command.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`composer.json`文件后，使用`composer install`安装项目的依赖项。如果您没有在符合所有指定约束的环境中运行Composer，可以在Composer命令中添加`--ignore-platform-reqs`标志。
- en: In this example, we will be using Composer's PSR-4 autoloader with `Packt\Chp5`
    as a base namespace and all classes located in the `src/` directory. That means
    that a class such as `Packt\Chp5\Foo\Bar` needs to be defined in the file `src/Foo/Bar.php`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用Composer的PSR-4自动加载器，以`Packt\Chp5`作为基本命名空间，所有类都位于`src/`目录中。这意味着类如`Packt\Chp5\Foo\Bar`需要在文件`src/Foo/Bar.php`中定义。
- en: Building the persistence layer with MongoDB
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MongoDB构建持久层
- en: 'The first step we''ll take in this example is to build an object-oriented model
    of the application''s domain - the user profile. In the first step, this will
    not be overly complicated. Let''s start by defining a `Profile` class with the
    following properties:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将采取的第一步是构建应用程序域的面向对象模型 - 用户个人资料。在第一步中，这将不会过于复杂。让我们从定义一个`Profile`类开始，具有以下属性：
- en: A username that uniquely identifies the user and can serve as a login username
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一标识用户并可用作登录用户名的用户名
- en: A given name and a family name
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定的名字和姓氏
- en: A list of interests and hobbies that the user cares about
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户关心的兴趣和爱好列表
- en: The user's birthday
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的生日
- en: The hash value of the user's password, which will come in handy later when you
    want users to authenticate before editing their own profile (and keeping them
    from editing other people's profiles)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户密码的哈希值，在以后用户在编辑自己的个人资料之前进行身份验证时会很有用（并防止他们编辑其他人的个人资料）
- en: This can be implemented as a simple PHP class. Note that the class is currently
    completely immutable, as its properties can only be set using the constructor.
    Also, this class does not contain any kind of persistence logic (meaning getting
    data from the database or putting it back). Following *Separation of Concerns*,
    modeling data and persisting it from and into a database are two different concerns
    that should be handled in different classes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以作为一个简单的PHP类来实现。请注意，该类目前完全是不可变的，因为它的属性只能使用构造函数设置。此外，此类不包含任何持久性逻辑（意味着从数据库获取数据或将其放回）。遵循*关注点分离*，建模数据并将其持久化到数据库中是两个不同的关注点，应该在不同的类中处理。
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now you can model user profiles within your application - but you cannot do
    anything with them yet. Our first goal will be to store instances of the `Profile`
    class in the MongoDB database backend. This will be done in the `Packt\Chp5\Service\ProfileService`
    class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在应用程序中建模用户配置文件-但是您还不能对其进行任何操作。我们的第一个目标将是将`Profile`类的实例存储在MongoDB数据库后端。这将在`Packt\Chp5\Service\ProfileService`类中完成：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `ProfileService` gets an instance of the `MongoDB\Collection` class passed
    as a dependency into its constructor. This class is provided by the `mongodb/mongodb` Composer
    package and models one single MongoDB collection (although not exactly true, a
    collection is MongoDB''s equivalent to a MySQL table). Again, we follow Separation
    of Concerns: establishing the connection to the database is not the `ProfileService''s`
    concern and will be handled at a different place.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProfileService`将`MongoDB\Collection`类的实例作为依赖项传递到其构造函数中。这个类由`mongodb/mongodb`
    Composer包提供，并且模型一个单一的MongoDB集合（虽然不完全正确，但集合是MongoDB等同于MySQL表）。同样，我们遵循关注点分离：建立与数据库的连接不是`ProfileService`的关注点，将在不同的地方处理。'
- en: 'Let''s start by implementing a method in this service that can add new user
    profiles to the database. A fitting name for such a method is `insertProfile`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在此服务中实现一个方法，该方法可以将新用户配置文件添加到数据库中。这样的方法的合适名称是`insertProfile`：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that this code example contains a private method, `profileToRecord()`,
    that converts an instance of the `Profile` class to a plain PHP array that will
    be stored as a document in the collection. This code was extracted into its own
    method, because it will be useful to have it as a re-usable function later. The
    actual insertion is performed by the collection's `insertOne` method, which takes
    a simple PHP array as a parameter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此代码示例包含一个私有方法`profileToRecord()`，它将`Profile`类的实例转换为一个普通的PHP数组，该数组将作为文档存储在集合中。这段代码被提取到自己的方法中，因为以后将有用作可重用的函数。实际的插入是由集合的`insertOne`方法执行的，该方法将一个简单的PHP数组作为参数。
- en: 'As the next step, let''s continue by extending the profile service with another
    method, `updateProfile`, that can - you guessed it - update existing profiles:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，让我们通过使用另一个方法`updateProfile`来扩展配置文件服务，该方法可以-您猜对了-更新现有配置文件：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first parameter passed to the `findOneAndUpdate` method is a MongoDB query.
    It contains a set of constraints that a document should match (in this case, the
    document's `username` property being equal to whatever value `$profile->getUsername()`
    returns).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`findOneAndUpdate`方法的第一个参数是MongoDB查询。它包含一组约束，文档应该匹配（在本例中，文档的`username`属性等于`$profile->getUsername()`返回的任何值）。
- en: Just like SQL queries, these can get arbitrarily complex. For example, the following
    query will match all users whose given name is `Martin` and are born after January
    1st, 1980 and like either open source software or science fiction literature.
    You can find a full reference of MongoDB query selection operators at [https://docs.mongodb.com/manual/reference/operator/query/](https://docs.mongodb.com/manual/reference/operator/query/)
    .
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 就像SQL查询一样，这些查询可以变得任意复杂。例如，以下查询将匹配所有名为`Martin`且出生于1980年1月1日后的用户，并且喜欢开源软件或科幻文学。您可以在[https://docs.mongodb.com/manual/reference/operator/query/](https://docs.mongodb.com/manual/reference/operator/query/)找到MongoDB查询选择运算符的完整参考。
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second parameter to `findOneAndUpdate()` contains a set of update operations
    which will be applied to the first document found that matches the given query.
    In this example, the `$set` operator contains an array of property values that
    will be updated on matched documents. Just like queries, these update statements
    can get more complex. The following will update all matched users'' given names
    to `Max` and `add` music to their list of interests:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOneAndUpdate()`的第二个参数包含一组更新操作，这些操作将应用于与给定查询匹配的第一个找到的文档。在此示例中，`$set`运算符包含一个属性值数组，该数组将在匹配的文档上进行更新。就像查询一样，这些更新语句可能会变得更加复杂。以下内容将更新所有匹配的用户的名字为`Max`，并将音乐添加到他们的兴趣列表中：'
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Using a simple test script, you can now already test this profile service.
    For this, you will need to establish a connection to your MongoDB database. If
    you used the Docker commands previously, the hostname of your MongoDB server will
    simply be `db`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个简单的测试脚本，您现在可以测试此配置文件服务。为此，您需要建立与MongoDB数据库的连接。如果您之前使用了Docker命令，则您的MongoDB服务器的主机名将简单地是`db`：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Adding and updating user profiles is nice, but the profile service does not
    yet support loading those profiles back from the database. For this, you can extend
    your `ProfileService` with a few more methods. Start with a `hasProfile` method
    that simply checks if a profile for a given username exists or not:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 添加和更新用户配置文件很好，但配置文件服务还不支持从数据库加载这些配置文件。为此，您可以使用更多方法扩展您的`ProfileService`。从一个简单检查给定用户名的配置文件是否存在的`hasProfile`方法开始：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `hasProfile` method simply checks if a profile for a given username is stored
    in the database. For this, the collection's `count` method is used. This method
    accepts a MongoDB query object and will return the count of all documents matching
    this constraint (in this case, the number of all documents with a given username).
    The `hasProfile` method will return true when a profile with the given username
    already exists.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasProfile`方法简单地检查数据库中是否存储了给定用户名的配置文件。为此，使用了集合的`count`方法。该方法接受一个MongoDB查询对象，并将返回匹配此约束的所有文档的计数（在本例中，具有给定用户名的所有文档的数量）。当具有给定用户名的配置文件已经存在时，`hasProfile`方法将返回true。'
- en: 'Continue by implementing the `getProfile` method, which loads a user profile
    from the database and returns a respective instance of the `Profile` class:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 继续实现`getProfile`方法，该方法从数据库加载用户配置文件并返回相应的`Profile`类的实例：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `getProfile` method uses the collection's `findOne` method (which incidentally
    accepts the same query object), which returns the first document that matches
    the constraint (or null, when no document can be found). When no profile with
    the given username can be found, `Packt\Chp5\Exception\UserNotFoundException`
    will be thrown. The implementation of this class is left as an exercise for the
    reader. The document - if found - is then passed into the private `recordToProfile`
    method, which inverts the `profileToRecord` method that you've already implemented
    earlier. Note that all MongoDB query method do not return plain arrays as documents,
    but always returns instances of the `MongoDB\Model\BSONDocument` class. You can
    use these exactly as you would use a regular array, but can trip over it when
    type-hinting function arguments or return values.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`getProfile`方法使用集合的`findOne`方法（偶然接受相同的查询对象），该方法返回与约束匹配的第一个文档（或null，当找不到文档时）。当找不到具有给定用户名的配置文件时，将抛出`Packt\Chp5\Exception\UserNotFoundException`。这个类的实现留给读者作为练习。然后将找到的文档传递给私有的`recordToProfile`方法，该方法反转了您之前已经实现的`profileToRecord`方法。请注意，所有MongoDB查询方法都不会返回普通数组作为文档，而总是返回`MongoDB\Model\BSONDocument`类的实例。您可以像使用常规数组一样使用它们，但在类型提示函数参数或返回值时可能会遇到问题。'
- en: Adding and retrieving users
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和检索用户
- en: As you have now successfully implemented the persistence logic of the profile
    REST service, you can now start implementing the actual REST Web Service.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已成功实现了配置文件REST服务的持久性逻辑，您现在可以开始实现实际的REST Web服务。
- en: 'In the previous examples, we have used simple callback functions as request
    handlers for the Slim framework:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们已经使用简单的回调函数作为Slim框架的请求处理程序：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is perfectly fine for getting started quickly, but will get difficult to
    maintain as your application grows. In order to structure your application in
    a more scalable way, you can exploit the fact that a Slim request handler does
    not have to be an anonymous function, but can in fact be anything that is callable.
    In PHP, you can also make objects callable by implementing the `__invoke` method.
    You can use this to implement a request handler that can be a stateful class with
    its own properties.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于快速入门是完全可以的，但随着应用程序的增长，将会变得难以维护。为了以更可扩展的方式构建应用程序，您可以利用Slim请求处理程序不必是匿名函数的事实，而实际上可以是任何可调用的东西。在PHP中，您还可以通过实现`__invoke`方法使对象可调用。您可以使用这个来实现一个请求处理程序，它可以是一个具有自己属性的有状态类。
- en: 'Before implementing the request handler, though, let us take a look at the
    web service''s responses. As we have chosen JSON as our primary representation
    format, you will frequently need to convert instances of the `Profile` class to
    a JSON object - and of course also the other way around. In order to keep this
    conversion logic reusable, it is recommended that this functionality be implemented
    in a separate unit. For this, you can implement a `ProfileJsonMapping` trait as,
    shown in the following example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实现请求处理程序之前，让我们先看一下Web服务的响应。由于我们选择了JSON作为我们的主要表示格式，您经常需要将`Profile`类的实例转换为JSON对象
    - 当然也需要反过来。为了保持这种转换逻辑的可重用性，建议将此功能实现为一个单独的单元。为此，您可以实现一个`ProfileJsonMapping` trait，如下例所示：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the representation logic taken care of, you can now continue by implementing
    the route for getting a single user profile. In this example, we will implement
    this route in the `Packt\Chp5\Route\ShowUserRoute` class and use the `ProfileJsonMapping`
    trait shown previously:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 表示逻辑已经处理好了，现在您可以继续实现获取单个用户配置文件的路由。在这个示例中，我们将在`Packt\Chp5\Route\ShowUserRoute`类中实现这个路由，并使用之前显示的`ProfileJsonMapping`
    trait：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, the `__invoke` method in this class has the same signature as
    the callback request handlers that you've seen in the previous examples. Also,
    this route class uses the `ProfileService` that you have implemented in the previous
    section. The actual handler first checks if a profile exists with a given username
    and returns a **404 Not Found** status code when the requested profile does not
    exist. Otherwise, the `Profile` instance will be converted to a plain array and
    returned as a JSON string.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个类中的`__invoke`方法与您在之前的示例中看到的回调请求处理程序具有相同的签名。此外，这个路由类使用了您在上一节中实现的`ProfileService`。实际处理程序首先检查是否存在具有给定用户名的配置文件，并在请求的配置文件不存在时返回**404
    Not Found**状态码。否则，`Profile`实例将被转换为普通数组，并作为JSON字符串返回。
- en: 'You can now initialize your Slim application in your `index.php` as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以在您的`index.php`中初始化您的Slim应用程序，如下所示：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If your database still contains some test data from the previous section, you
    can now already test this API, for example, by using HTTPie.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的数据库仍然包含来自上一节的一些测试数据，您现在可以通过使用HTTPie等工具来测试此API。
- en: '![Adding and retrieving users](graphics/image_05_003.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![添加和检索用户](graphics/image_05_003.jpg)'
- en: Using the REST API to access user profiles
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用REST API访问用户配置文件
- en: 'For creating new user profiles (and updating existing ones), you can now create
    a new request handler class. As a `PUT` request to `/profiles/{username}` will
    either create a new profile or update an already existing one, the new request
    handler will need to do both:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于创建新用户配置文件（以及更新现有配置文件），您现在可以创建一个新的请求处理程序类。由于对`/profiles/{username}`的`PUT`请求将创建一个新配置文件或更新已经存在的配置文件，新的请求处理程序将需要同时做这两件事：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, we are using the `Request` class' `getParsedBody` method to
    retrieve the parsed message body. Fortunately, this method is intelligent enough
    to look at the request's `Content-Type` header and automatically choose an appropriate
    parsing method (in the case of an `application/json` request, the `json_decode`
    method will be used to parse the request body).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`Request`类的`getParsedBody`方法来检索解析后的消息体。幸运的是，这个方法足够智能，可以查看请求的`Content-Type`头，并自动选择适当的解析方法（在`application/json`请求的情况下，将使用`json_decode`方法来解析请求体）。
- en: After retrieving the parsed message body, the `profileFromJson` method defined
    in the `ProfileJsonMapping` trait is used to create an actual instance of the
    `Profile` class from this body. Depending on whether a profile with this username
    already exists, we can then insert or update the user profile using the methods
    implemented in the `ProfileService` class. Note that depending on whether a new
    profile is created or an existing one is updated, a different HTTP status code
    is returned (`201 Created` when a new profile was created, or `200 OK` otherwise).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索解析后的消息体之后，使用`ProfileJsonMapping`特性中定义的`profileFromJson`方法来从这个主体创建`Profile`类的实际实例。根据这个用户名是否已经存在配置文件，然后我们可以使用`ProfileService`类中实现的方法插入或更新用户配置文件。请注意，根据是创建新配置文件还是更新现有配置文件，将返回不同的HTTP状态代码（当创建新配置文件时为`201
    Created`，否则为`200 OK`）。
- en: Tip
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**What about validation?** You will note that currently, you can pass literally
    anything as a body parameter and the request handler will try to save it as a
    user profile, even when necessary properties are missing or the body does not
    contain valid JSON. PHP 7''s new type safety features will give you some safety,
    as - thanks to strict typing, which is enabled with `declare(strict_types=1)`
    - they will simply throw a `TypeError` when some fields are missing in the input
    body. A more thorough implementation of input validation will be looked at in
    the *Validating input* section:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证呢？** 您会注意到目前，您可以将任何东西作为主体参数传递，请求处理程序将尝试将其保存为用户配置文件，即使缺少必要的属性或主体不包含有效的JSON。PHP
    7的新类型安全功能将为您提供一些安全性，因为 - 由于启用了`declare(strict_types=1)`的严格类型，当输入主体中缺少某些字段时，它们将简单地抛出`TypeError`。输入验证的更彻底的实现将在*验证输入*部分进行讨论：'
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can now connect this class with a new route in your `index.php`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以在您的`index.php`中的新路由中连接这个类：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Afterwards, you can try to create a new user profile using HTTPie:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以尝试使用HTTPie创建一个新的用户配置文件：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can also try to update the created profile by simply repeating the same
    PUT request with a different set of parameters. The HTTP response code (`201 Created`
    or `200 OK`) allows you to determine if a new profile was created or an existing
    one was updated.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以尝试通过简单重复相同的PUT请求并使用不同的参数来更新创建的配置文件。HTTP响应代码（`201 Created`或`200 OK`）允许您确定是创建了新配置文件还是更新了现有配置文件。
- en: Listing and searching users
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出和搜索用户
- en: 'The current state of your API allows users to read, create, and update specific
    user profiles. However, the web service is still missing functionality for searching
    the profile collection or listing all known user profiles. For listing profiles,
    you can extend the `ProfileService` class with a new function, `getProfiles`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您的API的当前状态允许用户读取、创建和更新特定用户配置文件。但是，网络服务仍然缺少搜索配置文件集合或列出所有已知用户配置文件的功能。对于列出配置文件，您可以使用一个新函数`getProfiles`来扩展`ProfileService`类：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In case you are not familiar with this syntax: the previous function is a **generator**
    function. The `yield` statement will cause the function to return an instance
    of the `Generator` class, which itself implements the `Traversable` interface
    (meaning that you can iterate over it using a `foreach` loop). This construct
    is particularly handy when dealing with large data sets. As the `find` function
    itself also returns a `Traversable`, you can stream the matching profile documents
    from the database, lazily map them to user objects, and pass the data stream into
    your request handler, without the need to put the entire collection of objects
    into memory.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉这种语法：前一个函数是一个**生成器**函数。`yield`语句将导致函数返回`Generator`类的一个实例，它本身实现了`Traversable`接口（这意味着您可以使用`foreach`循环对其进行迭代）。当处理大型数据集时，这种构造特别方便。由于`find`函数本身也返回一个`Traversable`，您可以从数据库中流式传输匹配的配置文件文档，惰性地将它们映射到用户对象，并将数据流传递到请求处理程序中，而无需将整个对象集合放入内存中。
- en: 'For comparison, consider the following implementation, which works with plain
    arrays instead of generators. You will notice that, due to usage of the `ArrayObject`
    class, even the method''s interface stays the same (returning a `Traversable`).
    However, this implementation stores a list of all found profile instances within
    the `ArrayObject` instance, whereas the previous implementation only handled one
    object at a time:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对比，考虑以下实现，它使用普通数组而不是生成器。您会注意到，由于使用了`ArrayObject`类，即使方法的接口保持不变（返回`Traversable`），这个实现在`ArrayObject`实例中存储了所有找到的配置文件实例的列表，而之前的实现一次只处理一个对象：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As the MongoDB API directly accepts well-structured query objects for matching
    documents instead of a custom text-based language (yes, I'm looking at you, SQL),
    you will not have to worry about injection attacks that traditional SQL-based
    systems are (not always, but often) vulnerable to. This allows our `getProfiles`
    function to accept a query object in the `$filter` argument that we simply pipe
    into the `find` method.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MongoDB API直接接受结构良好的查询对象来匹配文档，而不是自定义的基于文本的语言（是的，我在看你，SQL），因此您不必担心传统基于SQL的系统（并非总是，但通常是）容易受到的注入攻击。这允许我们的`getProfiles`函数接受`$filter`参数中的查询对象，我们只需将其传递给`find`方法。
- en: 'In the next step, you can extend the `getProfiles` function by adding new arguments
    for sorting the result set:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以通过添加新的参数来扩展`getProfiles`函数，以对结果集进行排序：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Using this new function, it is easy to implement a new class, `Packt\Chp5\Route\ListProfileRoute`,
    that you can use to query the entire user collection:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新函数，很容易实现一个新的类`Packt\Chp5\Route\ListProfileRoute`，您可以使用它来查询整个用户集合：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After that, you can register the new request handler at your Slim application
    in the `index.php` file:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，您可以在`index.php`文件中为Slim应用程序注册新的请求处理程序：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Deleting profiles
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除配置文件
- en: 'Deleting user profiles should be an easy task by now. First, you''ll need a
    new method in your `ProfileService` class:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，删除用户配置文件应该是一个简单的任务。首先，您需要在`ProfileService`类中添加一个新的方法：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The MongoDB collection's `findOneAndDelete` method does exactly what it promises.
    The first parameter to this function is a MongoDB query object as you have already
    used it in the previous sections. The first document matched by this query object
    will be deleted from the collection.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB集合的`findOneAndDelete`方法确实实现了它承诺的功能。此函数的第一个参数是一个MongoDB查询对象，就像您在前几节中已经使用过的那样。由此查询对象匹配的第一个文档将从集合中删除。
- en: 'After that, you can implement a new request handler class that uses the profile
    service to delete a profile, if present. When trying to delete a non-existing
    user, the request handler will respond with the correct status code, **404 Not
    Found**:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，您可以实现一个新的请求处理程序类，该类使用配置文件服务来删除配置文件（如果存在）。当尝试删除一个不存在的用户时，请求处理程序将以正确的状态代码“404未找到”做出响应：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You will notice that there is now some duplicate code in our example codebase.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们的示例代码库中现在有一些重复的代码。
- en: Both `ShowProfileRoute` and `DeleteProfileRoute` need to check if a user profile
    with a given username exists, and if not, return a `404 Not Found` response.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShowProfileRoute`和`DeleteProfileRoute`都需要检查给定用户名的用户配置文件是否存在，如果不存在，则返回“404未找到”响应。'
- en: 'This is a good use case for using middleware. As already stated in the previous
    section, middleware can either send a response to an HTTP request by itself, or
    pass the request to the next middleware component or the actual request handler.
    This allows you to implement middleware that takes the username from the route
    parameters, check if a profile exists for that user, and return an error response
    if that user does not exist. If that user does in fact exist, the request can
    be passed to the request handler:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用中间件的一个很好的用例。如前一节所述，中间件可以通过自身发送响应到HTTP请求，或将请求传递给下一个中间件组件或实际的请求处理程序。这使您可以实现中间件，从路由参数中获取用户名，检查该用户是否存在配置文件，并在该用户不存在时返回错误响应。如果该用户确实存在，则可以将请求传递给请求处理程序：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: All PSR-7 requests can have arbitrary attributes that can be set with `$req->withAttribute($name,
    $value)` and retrieved with `$req->getAttribute($name)`. This allows middleware
    to pass any kind of value to the actual request handler - this is exactly what
    `ProfileMiddleware` does by attaching the `profile` attribute to the request.
    The actual request handler can then retrieve the user profile, which has already
    been loaded, by simply calling `$req->getAttribute('profile')`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 所有PSR-7请求都可以具有可以使用`$req->withAttribute($name, $value)`设置的任意属性，并且可以使用`$req->getAttribute($name)`检索。这允许中间件将任何类型的值传递给实际的请求处理程序
    - 这正是`ProfileMiddleware`通过将`profile`属性附加到请求来实现的。然后，实际的请求处理程序可以通过简单调用`$req->getAttribute('profile')`来检索已加载的用户配置文件。
- en: 'Middleware is registered in a similar fashion to regular request handlers.
    Each time you register a new request handler with `$app->get(...)` or `$app->post(...)`,
    this method will return an instance of the route configuration to which you can
    assign different middleware. In your `index.php` file, you can register your middleware
    like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件的注册方式与常规请求处理程序类似。每次使用`$app->get(...)`或`$app->post(...)`注册新的请求处理程序时，此方法将返回路由配置的实例，您可以为其分配不同的中间件。在您的`index.php`文件中，您可以像这样注册您的中间件：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After registering the middleware for the `GET /profiles/{username}` and `DELETE
    /profiles{username}` route, you can modify the respective route handlers to simply
    use the profile request attribute and remove the error checking:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在为`GET /profiles/{username}`和`DELETE /profiles{username}`路由注册中间件之后，您可以修改相应的路由处理程序，简单地使用配置文件请求属性并删除错误检查：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The same goes for the `DeleteProfileRoute` class:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteProfileRoute`类也是如此：'
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Validating input
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证输入
- en: 'When implementing the `PUT /profiles/{username}` route, you might have noticed
    that we did not pay that much attention to the validation of user inputs. To an
    extent, we can actually use PHP 7''s new strict typing for validating user inputs.
    You can activate strict typing by using a `declare(strict_types = 1)` statement
    in the first line of your code. Consider the following example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`PUT /profiles/{username}`路由时，您可能已经注意到我们并没有那么关注用户输入的验证。在某种程度上，我们实际上可以使用PHP
    7的新严格类型来验证用户输入。您可以通过在代码的第一行使用`declare(strict_types = 1)`语句来激活严格类型。考虑以下示例：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Assuming, for example, that the `Profile` class'' `$givenName` parameter is
    type-hinted with `string`, the previous statement will throw a `TypeError` when
    `$json[''givenName'']` is not set. You would then be able to catch this error
    using a `try`/`catch` statement and return the appropriate **400 Bad Request**
    HTTP response:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设`Profile`类的`$givenName`参数被类型提示为`string`，当`$json['givenName']`未设置时，前面的语句将抛出`TypeError`。然后，您可以使用`try`/`catch`语句捕获此错误，并返回适当的**400
    Bad Request** HTTP响应：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: However, this provides only rudimentary error checking, as you can only verify
    data types and cannot assert logical constraints. Also, this approach provides
    a bad user experience, as the error response will only contain the first triggered
    error.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只提供了基本的错误检查，因为您只能验证数据类型，无法断言逻辑约束。此外，这种方法会提供糟糕的用户体验，因为错误响应只会包含第一个触发的错误。
- en: 'For implementing a more elaborate validation, you can add another middleware
    to your application (using middleware is a good choice here, because it allows
    you to keep the concern of validation logic encapsulated in a single class). Let''s
    call this class `Packt\Chp5\Middleware\ProfileValidationMiddleware`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现更复杂的验证，您可以向应用程序添加另一个中间件（在这里使用中间件是一个很好的选择，因为它允许您将验证逻辑的关注点封装在一个单独的类中）。让我们称这个类为`Packt\Chp5\Middleware\ProfileValidationMiddleware`：
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After declaring the validation middleware class, you can register it in your
    `index.php` file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 声明验证中间件类之后，您可以在您的`index.php`文件中注册它：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Streams and large files
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流和大文件
- en: So far, our web service can perform the basic operations on a user profile.
    In this chapter, we will extend the user profile service to also handle a user's
    profile image. During the course of this chapter, you will learn how you can process
    even very large files using PHP streams.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的Web服务可以对用户个人资料执行基本操作。在本章中，我们将扩展用户个人资料服务，以处理用户的个人资料图像。在本章的过程中，您将学习如何使用PHP流处理甚至非常大的文件。
- en: Profile image upload
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置图像上传
- en: Basically, in a RESTful application, you can treat an image just as any other
    resource. You can create and update it using `POST` and/or `PUT` operations, and
    you can retrieve it using `GET`. The only difference is the chosen representation
    of the resource. Instead of JSON encoding using `application/json` as a Content-Type,
    you will now work with resources that have a JPEG or PNG representation, with
    their respective `image/jpeg` or `image/png` content types.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在RESTful应用程序中，您可以将图像视为任何其他资源。您可以使用`POST`和/或`PUT`操作创建和更新它，并使用`GET`检索它。唯一的区别是资源的选择表示。不再使用`application/json`作为Content-Type进行JSON编码，而是使用具有JPEG或PNG表示的资源，其相应的`image/jpeg`或`image/png`内容类型。
- en: At this point, it will be useful to understand how the PSR-7 standard models
    HTTP requests and response bodies. Since technically, each message (both request
    and response) body is just a string of characters, these could be modeled as simple
    PHP strings. This works fine for the messages that you have been working with
    in the past few sections, but may present problems when working with larger messages
    (say, for example, images). This is why PSR-7 models all message bodies as streams
    that a user can read from (in case of request bodies) or write to (in case of
    response bodies). You can pipe data from a stream into a file or another networked
    stream, without ever needing to fit the entire contents into the memory of your
    PHP process.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，了解PSR-7标准如何对HTTP请求和响应主体进行建模将是有用的。从技术上讲，每个消息（请求和响应）主体只是一个字符串，这些可以被建模为简单的PHP字符串。这对于您在过去几节中处理的消息来说是可以的，但在处理更大的消息时（比如图像），可能会出现问题。这就是为什么PSR-7将所有消息主体都建模为用户可以从中读取（对于请求主体）或写入（对于响应主体）的流。您可以将流中的数据传输到文件或另一个网络流中，而无需将整个内容适应PHP进程的内存中。
- en: 'In the next step, we will implement the user''s profile image as a new resource.
    A user''s profile image will have the URI, `/profiles/{username}/image`. Loading
    a user''s image will be a simple `GET` request (returning a response with the
    appropriate `Content-Type: image/jpeg` or `image/png` header and the image''s
    binary contents as message body). Updating an image will work the other way around,
    using a `PUT` request with a Content-Type header and the image contents as message
    body.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们将实现用户的个人资料图像作为一个新的资源。用户的个人资料图像将具有URI `/profiles/{username}/image`。加载用户的图像将是一个简单的`GET`请求（返回一个带有适当的`Content-Type:
    image/jpeg`或`image/png`头和图像二进制内容的响应主体）。更新图像将使用`PUT`请求，带有Content-Type头和图像内容作为消息主体。'
- en: 'Start by implementing a new request handler class, in which you read blocks
    from the request streams and write them into a file:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先实现一个新的请求处理程序类，在其中从请求流中读取块并将其写入文件：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This request handler opens a file handle for writing using `fopen(...)`, then
    reads the request body in blocks of 4 KB and writes them into the opened file.
    The advantage of this solution is that it does not really matter if the file you
    are saving is 4 KB or 400 MB. As you are only reading 4 KB blocks of the input
    at any time, you will have a more-or-less constant memory usage, independent of
    input size.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求处理程序使用`fopen(...)`打开一个文件句柄进行写入，然后以4 KB的块读取请求体，并将其写入打开的文件。这种解决方案的优势在于，无论您保存的文件是4
    KB还是400 MB，都不会真正有影响。因为您一次只读取输入的4 KB块，所以内存使用量会保持相对恒定，与输入大小无关。
- en: Tip
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**On scalability** Storing files in the local filesystem is not very scalable
    and should only be considered as an example in this case. In order to keep this
    scalable, you could put your image directory on a network storage (for example,
    NFS) or use other distributed storage solutions. In the following section, *Using
    GridFS storage* you will also learn how to use GridFS to store files in a scalable
    way.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于可扩展性** 在本地文件系统中存储文件并不是非常可扩展的，应该只被视为一个示例。为了保持可扩展性，您可以将图像目录放在网络存储上（例如NFS），或者使用其他分布式存储解决方案。在接下来的部分中，*使用GridFS存储*
    您还将学习如何使用GridFS以可扩展的方式存储文件。'
- en: 'Next, register the request handler at your Slim application:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在您的Slim应用程序中注册请求处理程序：
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In order to test this route, find an arbitrary-sized image file on your computer
    and use the following curl command on the command line (remember; as we are using
    `profileMiddleware` for the new route, you will need to specify a user profile
    that actually exists in your database for this):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个路由，在您的计算机上找到一个任意大小的图像文件，并在命令行上使用以下curl命令（记住；由于我们正在为新路由使用`profileMiddleware`，因此您需要为此指定实际存在于数据库中的用户个人资料）：
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After running this command, you should find a `jdoe` file in the `images/` directory
    in your project folder with the exact same contents as the original file.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您应该在项目文件夹的`images/`目录中找到一个`jdoe`文件，其内容与原始文件完全相同。
- en: 'Delivering profile images back to your users works in a similar way. For this,
    implement a new request handler called `Packt\Chp5\Route\ShowImageRoute`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户的个人资料图片返回给用户的工作方式类似。为此，实现一个名为`Packt\Chp5\Route\ShowImageRoute`的新请求处理程序：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we are using the `mime_content_type` method to load the actual content
    type of the uploaded file. The content type is needed, because the HTTP response
    needs to contain a Content-Type header, which is in turn required by the browser
    to correctly display the image.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`mime_content_type`方法来加载上传文件的实际内容类型。需要内容类型，因为HTTP响应需要包含Content-Type标头，浏览器才能正确显示图像。
- en: 'Also, we are using the `Slim\Http\Body` class, which makes the implementation
    even easier: this class implements the PSR-7 `StreamInterface` and can be initialized
    with an open stream (which might, for example, be an open file handler). The Slim
    framework will then take care of delivering the contents of this file to the user.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用`Slim\Http\Body`类，这使得实现更加容易：这个类实现了PSR-7 `StreamInterface`，并且可以使用打开的流（例如，可能是打开的文件处理程序）进行初始化。然后，Slim框架将负责将此文件的内容传递给用户。
- en: 'This request handler can also be registered in the `index.php`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此请求处理程序也可以在`index.php`中注册：
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If you have uploaded a test image after implementing the `PUT` route, you can
    now test the `GET` route with the same user profile. As a curl command will only
    return a large blob of binary data, it might be preferable to visit `http://localhost/profiles/jdoe/image`
    in a browser of your choice.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在实现`PUT`路由后上传了测试图像，现在可以使用相同的用户个人资料测试`GET`路由。由于curl命令只会返回一个大的二进制数据块，因此最好在您选择的浏览器中访问`http://localhost/profiles/jdoe/image`。
- en: Using GridFS storage
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GridFS存储
- en: Storing user-uploaded files in the server's local filesystem is a viable solution
    for small sites. However, as soon as you feel the need to horizontally scale your
    application, you will need to look into distributed filesystems. For example,
    you could replace your user images folder with a network device that is mounted
    via the NFS filesystem. As you have already been working with MongoDB a lot in
    this chapter, in this section you will learn about GridFS. GridFS is a specification
    for storing - potentially very large - files in a MongoDB database.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户上传的文件存储在服务器的本地文件系统中对于小型站点是一个可行的解决方案。但是，一旦您感到需要对应用程序进行水平扩展，您就需要研究分布式文件系统。例如，您可以用NFS文件系统挂载的网络设备替换用户图像文件夹。由于在本章中您已经大量使用了MongoDB，在本节中您将了解GridFS。GridFS是一种在MongoDB数据库中存储
    - 可能非常大的 - 文件的规范。
- en: 'The GridFS specification is simple. You will need two collections - `fs.files`
    and `fs.chunks`. The former will be used to store file metadata, while the latter
    will store the actual content of the files. Since MongoDB documents are limited
    to 16 MB by default, each stored file will be split into several *chunks* of (by
    default) 255 KB. A file document will have the following form:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: GridFS规范很简单。您将需要两个集合 - `fs.files`和`fs.chunks`。前者将用于存储文件元数据，而后者将存储文件的实际内容。由于MongoDB文档默认限制为16
    MB，每个存储的文件将被分割成几个（默认为）255 KB的*块*。文件文档将具有以下形式：
- en: '[PRE52]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A chunk document will have the following form:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 块文档将具有以下形式：
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that GridFS is simply a recommendation on how you can store files in a
    MongoDB database, and you would be free to implement any other kind of file storage
    in a MongoDB store. However, GridFS is a widely accepted standard, and the chances
    are good that you will find GridFS implementations for nearly every language.
    So, if you want to write files into a GridFS storage using a PHP application,
    and then read them from there using a Python program, you'll find standard implementations
    for both runtimes that you can use out-of-the-box, without having to re-invent
    the wheel.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，GridFS只是关于如何在MongoDB数据库中存储文件的建议，您可以自由地在MongoDB存储中实现任何其他类型的文件存储。但是，GridFS是一个被广泛接受的标准，很可能您会发现几乎每种语言都有GridFS的实现。因此，如果您想使用PHP应用程序将文件写入GridFS存储，然后使用Python程序从那里读取文件，您会发现这两种运行时都有标准实现，可以直接使用，而无需重新发明轮子。
- en: 'In PHP 7, you can use the `helmich/gridfs` library for GridFS access. You can
    acquire it using Composer:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中，您可以使用`helmich/gridfs`库来访问GridFS。您可以使用Composer获取它：
- en: '[PRE54]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: GridFS is oriented around buckets. Each bucket can contain an arbitrary number
    of files, and internally stores them in two MongoDB collections, `<bucket name>.files`
    and `<bucket name>.chunks`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: GridFS围绕存储桶展开。每个存储桶可以包含任意数量的文件，并在两个MongoDB集合中内部存储它们，`<bucket name>.files`和`<bucket
    name>.chunks`。
- en: Begin by modifying your application Bootstrap in your `index.php` by creating
    a new bucket for the user profile images, using the `Helmich\GridFS\Bucket` class.
    Each bucket can be initialized with a `BucketOptions` instance, in which you can
    configure several bucket options, such as the bucket name.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过使用`Helmich\GridFS\Bucket`类在您的`index.php`中修改应用程序引导程序，为用户个人资料图片创建一个新的存储桶。每个存储桶可以使用`BucketOptions`实例进行初始化，在其中您可以配置几个存储桶选项，例如存储桶名称。
- en: 'After creating the bucket, you can pass it as a dependency into the `ShowImageRoute`
    and `PutImageRoute` classes:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 创建存储桶后，您可以将其作为依赖项传递给`ShowImageRoute`和`PutImageRoute`类：
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `PutImageRoute` and `ShowImageRoute` now get a GridFS bucket passed as
    a dependency. You can now adjust these classes to write uploaded files into that
    bucket. Let''s start by adjusting the `PutImageRoute` class:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`PutImageRoute`和`ShowImageRoute`现在作为依赖项传递了一个GridFS桶。现在，您可以调整这些类，将上传的文件写入该桶。让我们从调整`PutImageRoute`类开始：'
- en: '[PRE56]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The interface of a GridFS bucket is described in the `BucketInterface`, which
    we are using in this example. You can now modify the `__invoke` method of `PutImageRoute`,
    to store uploaded profile images in the bucket:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: GridFS桶的接口在`BucketInterface`中描述，我们在这个例子中使用。现在，您可以修改`PutImageRoute`的`__invoke`方法，将上传的个人资料图片存储在桶中：
- en: '[PRE57]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this example, we are using the `$req->getBody()->detach()`method to get the
    actual underlying input stream from the request body. This stream is then passed
    into the bucket's `uploadFromStream` method, together with a filename (in this
    case, simply the username) and an `UploadOptions` object. The `UploadOptions`
    object defines configuration options for the file upload; among others, you can
    specify arbitrary metadata that will be stored alongside GridFS' own metadata
    in the `<bucketname>.files` collection.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`$req->getBody()->detach()`方法来从请求体中获取实际的底层输入流。然后将该流传递到桶的`uploadFromStream`方法中，以及文件名（在这种情况下，简单地是用户名）和一个`UploadOptions`对象。`UploadOptions`对象定义了文件上传的配置选项；其中，您可以指定将存储在`<bucketname>.files`集合中的GridFS自身元数据旁边存储的任意元数据。
- en: 'Now, all that''s left is to adjust the `ShowProfileRoute` to also use the GridFS
    bucket. First of all, modify the class'' constructor to accept a `BucketInterface`
    as parameter, just as we did with the `PutProfileRoute`. Then, you can adjust
    the `__invoke` method to download the requested profile images from the GridFS
    bucket:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的就是调整`ShowProfileRoute`以使用GridFS桶。首先，修改类的构造函数以接受`BucketInterface`作为参数，就像我们在`PutProfileRoute`中所做的那样。然后，您可以调整`__invoke`方法，从GridFS桶中下载请求的个人资料图片：
- en: '[PRE58]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this example, we're using the Bucket's `openDownloadStreamByName` method
    to find a file in the bucket by its name and return a stream object from which
    we can download the file.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了Bucket的`openDownloadStreamByName`方法来通过文件名在桶中查找文件，并返回一个流对象，从中我们可以下载文件。
- en: The opened download stream is an implementation of the `Helmich\GridFS\Stream\DownloadStream`
    interface. Unfortunately, you cannot use this interface directly in your HTTP
    response. However, you can use the `Helmich\GridFS\Stream\Psr7\DownloadStreamAdapter`
    interface to create a PSR-7 compatible stream from the GridFS stream that you
    can use in the HTTP response.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 打开的下载流是`Helmich\GridFS\Stream\DownloadStream`接口的实现。不幸的是，您不能直接在HTTP响应中使用此接口。但是，您可以使用`Helmich\GridFS\Stream\Psr7\DownloadStreamAdapter`接口从GridFS流创建一个符合PSR-7标准的流，您可以在HTTP响应中使用。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned about the basic architectural principles of
    RESTful Web Services and also how to build one on your own using the Slim framework.
    We have also had a look at the PSR-7 standard that allows you to write HTTP components
    in PHP that are portable across frameworks and become highly re-usable. Finally,
    you have also learned how to use PHP's new MongoDB extension for both direct access
    to stored collections, and also in combination with other high-level abstractions, such
    as the GridFS standard.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了RESTful Web服务的基本架构原则，以及如何使用Slim框架自己构建一个。我们还看了一下PSR-7标准，它允许您在PHP中编写可在框架之间移植并且高度可重用的HTTP组件。最后，您还学会了如何使用PHP的新MongoDB扩展来直接访问存储的集合，以及与其他高级抽象（如GridFS标准）结合使用。
- en: Both your newly acquired Slim knowledge and your understanding of the PSR-7
    standard will benefit you in the following chapter, in which you will build a
    real-time chat application using the Ratchet framework - and then use PSR-7 to
    integrate Ratchet with the Slim framework.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您新学到的Slim知识和对PSR-7标准的理解将使您受益于接下来的章节，您将在其中使用Ratchet框架构建一个实时聊天应用程序，然后使用PSR-7将Ratchet与Slim框架集成。
