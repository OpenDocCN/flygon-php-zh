- en: Chapter 9. Extract Domain Logic to Transactions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。将域逻辑提取到事务中
- en: In the previous chapter, we extracted all our SQL statements to a layer of *Gateway*
    objects. This encapsulates the interactions between the application and the database.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们将所有SQL语句提取到了*网关*对象的一层。这样封装了应用程序与数据库之间的交互。
- en: However, we usually need to apply some amount of business or domain logic to
    the data coming from and going back to the database. The logic can include things
    like data validation, adding or modifying values for presentation or calculation
    purposes, collecting simpler records into more complex ones, using the data to
    perform related actions, and so on. This domain logic is often embedded into a
    page script, making that logic difficult to reuse and test.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们通常需要对从数据库获取的数据应用一定数量的业务或域逻辑，以及返回数据库。逻辑可以包括数据验证，添加或修改值以用于演示或计算目的，将更简单的记录收集到更复杂的记录中，使用数据执行相关操作等。这种域逻辑通常嵌入到页面脚本中，使得该逻辑难以重用和测试。
- en: 'This chapter describes one way to extract domain behaviors into a separate
    layer. In many ways, this chapter forms the very core of the book: everything
    before now has led us to this central concern of the legacy application, and everything
    that comes after will lead us into layers above and around this core functionality.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了将域行为提取到单独层的一种方法。在许多方面，本章构成了本书的核心：到目前为止，一切都导致了我们对遗留应用程序的这一核心关注点，而之后的一切将引导我们进入这个核心功能周围和上面的层。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Domain or Model?**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**域还是模型？**'
- en: The domain logic in the legacy application is the model portion of model-view-controller.
    However, the legacy codebase is unlikely to have separate entity objects that
    provide a full model of the business domain. Thus, we will be speaking in terms
    of domain logic and not model logic throughout this chapter. If we are lucky enough
    to have separate model objects already, so much the better.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留应用程序中的域逻辑是模型-视图-控制器中的模型部分。然而，遗留代码库不太可能有提供业务域的完整模型的单独实体对象。因此，在本章中，我们将讨论域逻辑而不是模型逻辑。如果我们足够幸运已经有了单独的模型对象，那就更好了。
- en: Embedded Domain Logic
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式域逻辑
- en: Although we have extracted SQL statements, the page scripts and classes are
    probably manipulating the results and performing other actions related to the
    retrieved data. These manipulations and actions are the core of the domain logic,
    and it is currently embedded along with other non-domain concerns.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经提取了SQL语句，页面脚本和类可能正在操作结果并执行与检索数据相关的其他操作。这些操作和动作是域逻辑的核心，目前它们与其他非域关注点一起嵌入。
- en: We can see an example of the progression from embedded SQL to using *Gateway*
    classes by examining the differences between the code in [Appendix B](apb.xhtml
    "Appendix B. Code before Gateways"), *Code before Gateway* and [Appendix C](apc.xhtml
    "Appendix C. Code after Gateways"), *Code after Gateway*. The code is too lengthy
    to present here. What we want to notice is that even after extracting the embedded
    SQL statements, the code is still doing a lot of work with the incoming and outgoing
    data before the results are presented to the user.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看[附录B](apb.xhtml "附录 B. 网关之前的代码")中的代码，*网关之前的代码*和[附录C](apc.xhtml "附录 C.
    网关之后的代码")中的代码，*网关之后的代码*，来看到从嵌入式SQL到使用*网关*类的进展。这里的代码太长，无法在此处呈现。我们要注意的是，即使在提取嵌入式SQL语句之后，代码仍然在将结果呈现给用户之前对传入和传出的数据进行了大量处理。
- en: Having the domain logic embedded in the page script makes it very difficult
    to test that logic in isolation. We also cannot reuse it easily. If we wanted
    to search for repetition and duplication in how we work with the domain entities
    (in this case a series of articles) we would need to review every page script
    in the entire application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将域逻辑嵌入页面脚本中使得难以独立测试该逻辑。我们也无法轻松地重用它。如果我们想要搜索在如何处理域实体（在本例中是一系列文章）方面的重复和重复，我们需要审查整个应用程序中的每个页面脚本。
- en: The solution here is to extract the domain logic to one or more classes so that
    we can test them independently of any particular page script. We can then instantiate
    the domain logic classes and use them in any page script we like.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的解决方案是将域逻辑提取到一个或多个类中，以便我们可以独立于任何特定页面脚本对它们进行测试。然后我们可以实例化域逻辑类并在任何我们喜欢的页面脚本中使用它们。
- en: Before we can apply that solution, we need to determine how to structure the
    target classes for our domain logic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '在应用该解决方案之前，我们需要确定如何为我们的域逻辑结构目标类。 '
- en: Domain logic patterns
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域逻辑模式
- en: 'Martin Fowler''s **Patterns of Enterprise Application Architecture** (**PoEAA**)
    catalogs four domain logic patterns:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Martin Fowler的**企业应用架构模式**（**PoEAA**）目录了四种域逻辑模式：
- en: '**Transaction Script**: It organizes [domain] logic primarily as a single procedure,
    making calls directly to the database or through a thin database wrapper. Each
    transaction will have its own Transaction Script, although common subtasks can
    be broken into subprocedures."'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务脚本**：它主要将[域]逻辑组织为单个过程，直接调用数据库或通过一个薄的数据库包装器。每个事务都将有自己的事务脚本，尽管常见的子任务可以分解为子过程。'
- en: '**Domain Model**: It creates a web of interconnected objects, where each object
    represents some meaningful individual, whether as large as a corporation or as
    small as a single line on an order form.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**域模型**：它创建了一组相互连接的对象，其中每个对象代表一些有意义的个体，无论是像公司那样大，还是像订单表上的一行那样小。'
- en: '**Table Module**: It organizes domain logic with one class per table in the
    database, and a single instance of a class contains the various procedures that
    will act on the data, if you have many orders, a Domain Model will have one order
    object per order while a Table Module will have one object to handle all orders.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表模块**：它使用数据库中每个表一个类的方式组织域逻辑，并且一个类的单个实例包含将对数据进行操作的各种过程，如果你有很多订单，域模型将每个订单一个订单对象，而表模块将有一个对象来处理所有订单。'
- en: '**Service Layer**: It defines an application''s boundary and its set of available
    operations from the perspective of interfacing client layers. It encapsulates
    the application''s business logic, controlling transactions and coordinating responses
    in the implementation of its operations.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务层**：它从客户端层的接口角度定义了应用程序的边界和可用操作集。它封装了应用程序的业务逻辑，在实现其操作时控制事务并协调响应。'
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I strongly recommend purchasing PoEAA in hard copy and reading the pattern descriptions
    and examples in full. The book is an absolute must-have reference for the professional
    programmer. I find myself consulting it on a weekly basis (sometimes more often)
    and it always provides clarity and insight.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议购买PoEAA的纸质版，并完整阅读模式描述和示例。这本书对专业程序员来说是一个绝对必备的参考书。我发现自己每周都要查阅它（有时更频繁），它总是能提供清晰和洞察力。
- en: 'The choice before us now is this: given the existing structure of our legacy
    application, which of these patterns best fits the architecture currently in place?'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们面临的选择是：鉴于我们遗留应用程序的现有结构，哪种模式最适合当前的架构？
- en: We will dismiss Service Layer at this point, since it implies a level of sophistication
    that is probably not present in our legacy application. We will likewise dismiss
    Domain Model, since it implies a well-designed set of business entity objects
    that encapsulate behavior. If the legacy application already has one of these
    patterns implemented, then so much the better. Otherwise, that leaves us with
    the Table Module and Transaction Script patterns.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将放弃服务层，因为它暗示着一个在我们遗留应用程序中可能不存在的复杂程度。同样，我们也将放弃领域模型，因为它暗示着一个封装行为的良好设计的业务实体对象集。如果遗留应用程序已经实现了这些模式中的一个，那就更好了。否则，这就只剩下表模块和交易脚本模式了。
- en: When we extracted our SQL statements to `Gateway` classes in the previous chapter,
    those `Gateway` classes were likely to follow the Table Data Gateway pattern,
    in particular if they were simple enough to interact with only a single table
    per `Gateway` class. This makes it seem like the Table Module pattern would be
    a good fit for our domain logic.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们将SQL语句提取到`Gateway`类中时，这些`Gateway`类很可能遵循了表数据网关模式，特别是如果它们足够简单，只与每个`Gateway`类交互一个表。这使得表模块模式似乎是我们领域逻辑的一个很好的选择。
- en: However, it is unlikely that each remaining page script or class with embedded
    domain logic is interacting with a single table at a time. More frequently, legacy
    applications have many interactions across many tables in a single class or script.
    As such, we will begin by using the Transaction Script pattern when we extract
    our domain logic.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，剩下的每个页面脚本或嵌入领域逻辑的类可能不太可能一次只与一个表交互。更频繁地，遗留应用程序在一个类或脚本中跨多个表有许多交互。因此，当我们提取领域逻辑时，我们将首先使用交易脚本模式。
- en: Transaction Script is admittedly a simple pattern to follow. With it, we extract
    the domain logic from the page script and dump it into a class method mostly intact.
    We make modifications to the logic only for getting data into and out of the class
    method so that the original code can still operate properly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 交易脚本无可否认是一种简单的模式。通过它，我们将领域逻辑从页面脚本中提取出来，基本完整地转移到一个类方法中。我们只对逻辑进行修改，以便将数据正确地输入和输出到类方法中，以便原始代码仍然能够正常运行。
- en: Although we may wish for something more sophisticated than Transaction Script,
    we have to remember that one of our goals here is to avoid changing the existing
    logic too dramatically. We are refactoring, not rewriting. What we want right
    now is to move the code around so that it can be tested and reused appropriately.
    Thus, a Transaction Script is probably the best way to wrap our legacy domain
    logic as-it-exists, not as-we-want-it-to-be.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可能希望有比交易脚本更复杂的东西，但我们必须记住，我们在这里的目标之一是尽量避免对现有逻辑进行太大的改变。我们是重构，而不是重写。我们现在想要的是将代码移动到适当的位置，以便进行适当的测试和重用。因此，交易脚本可能是包装我们遗留的领域逻辑的最佳方式，就像它存在的那样，而不是我们希望它成为的样子。
- en: Once we extract the domain logic to its own layer, we will then be able to see
    that logic more clearly and with less distraction. At that point, if it is truly
    needed, we can begin to plan a refactoring of the domain layer to something more
    sophisticated. For example, we may build a Service Layer that uses Table Modules
    or a Domain Model to coordinate the various domain interactions. The interface
    presented to the page scripts by the Service Layer might remain completely unchanged
    from the Transaction Script interface, although the underlying architecture may
    have changed completely. But that is a task for another day.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将领域逻辑提取到自己的层中，我们就能更清晰地看到这个逻辑，减少干扰。在那时，如果真的需要的话，我们可以开始计划将领域层重构为更复杂的东西。例如，我们可以构建一个使用表模块或领域模型来协调各种领域交互的服务层。服务层向页面脚本呈现的接口可能与交易脚本接口完全保持不变，尽管底层架构可能已经完全改变。但这是另一天的任务。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**What about Active Record?**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**活动记录呢？**'
- en: Ruby on Rails is famous for using the Active Record pattern, and many PHP developers
    love that kind of database interaction. It definitely has its strengths. However,
    Fowler classifies Active Record as a data source architecture pattern, not a domain
    logic pattern, so we will not be addressing it here.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby on Rails以使用活动记录模式而闻名，许多PHP开发人员喜欢这种数据库交互方式。它确实有其优势。然而，Fowler将活动记录分类为数据源架构模式，而不是领域逻辑模式，因此我们不会在这里讨论它。
- en: The Extraction Process
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取过程
- en: Of the refactoring processes described in this book, extracting domain logic
    is going to be the most difficult, time consuming, and detail-oriented. This is
    a very tough thing to do, and it requires a lot of care and attention. The domain
    logic is the very core of our legacy application, and we need to make sure to
    pull out just the right parts. This means success is completely dependent on our
    familiarity and competence with the the legacy application as it exists now.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中描述的重构过程中，提取领域逻辑将是最困难、耗时和细节导向的。这是一件非常艰难的事情，需要非常小心和注意。领域逻辑是我们遗留应用程序的核心，我们需要确保只提取出正确的部分。这意味着成功完全取决于我们对现有遗留应用程序的熟悉程度和能力。
- en: Luckily, our prior exercises in modernizing our legacy codebase have given us
    a broad overview of the application as a whole, as well as deep knowledge of the
    specific parts we have had to extract and refactor. This should endow us with
    the confidence to complete this task successfully. It is a demanding, but ultimately
    satisfying, activity.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们之前对现代化遗留代码库的练习已经让我们对整个应用程序有了广泛的了解，以及对我们必须提取和重构的特定部分有了深入的了解。这应该让我们有信心成功完成这项任务。这是一项要求很高，但最终令人满意的活动。
- en: 'In general, we proceed as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们按照以下步骤进行：
- en: Search the entire codebase for uses of `Gateway` classes that exist outside
    `Transactions` classes.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索整个代码库，查找存在于“交易”类之外的“网关”类的使用情况。
- en: Where we find `Gateway` usage, examine the logic surrounding the `Gateway` operations
    to discover which portions of that logic are related to the domain behaviors of
    the application.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在发现“网关”使用的地方，检查围绕“网关”操作的逻辑，以发现该逻辑的哪些部分与应用程序的领域行为相关。
- en: Extract the relevant domain logic to one or more `Transactions` classes related
    to the domain elements, and modify the original code to use the `Transactions`
    class instead of the embedded domain logic.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取相关的领域逻辑到一个或多个与领域元素相关的“交易”类中，并修改原始代码以使用“交易”类而不是嵌入的领域逻辑。
- en: Spot check to make sure the original code still works properly, and modify the
    extracted logic as necessary to ensure correct operation.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽查以确保原始代码仍然正常工作，并根据需要修改提取的逻辑以确保正确运行。
- en: Write tests for the extracted `Transactions` logic, refining them along with
    the tested code until they pass.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为提取的“交易”逻辑编写测试，并随着测试代码的完善而完善测试，直到测试通过。
- en: When all original tests and new tests pass, commit the code and tests, push
    to the common repository, and notify QA.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当所有原始测试和新测试都通过时，提交代码和测试，推送到公共存储库，并通知质量保证部门。
- en: Search again for uses of `Gateway` classes, and continue extracting domain logic
    until `Gateway` usage exists only in `Transactions`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次搜索“网关”类的使用情况，并继续提取领域逻辑，直到“网关”的使用仅存在于“交易”中。
- en: Search for uses of Gateway
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索“网关”的使用情况
- en: 'As in earlier chapters, we use our project-wide search facility to find where
    we create new instances of `Gateway` classes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期章节一样，我们使用项目范围的搜索功能来查找我们创建“网关”类实例的位置：
- en: 'Search for:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The new `Gateway` instance may be used directly in a page script, in which case
    we have found some candidate code for extracting domain logic. If the `Gateway`
    instance is injected into a class, we now need to dive into that class to find
    where the `Gateway` is used. The code surrounding that usage will be our candidate
    for extracting domain logic.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 新的“网关”实例可能直接在页面脚本中使用，这种情况下我们已经找到了一些候选代码来提取领域逻辑。如果“网关”实例被注入到一个类中，我们现在需要深入到该类中找到“网关”的使用位置。围绕该使用的代码将成为我们提取领域逻辑的候选代码。
- en: Discover and Extract Relevant Domain Logic
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发现和提取相关的领域逻辑
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'When extracting logic to a class method, we should be careful to follow all
    the lessons we learned about dependency injection in prior chapters. Among other
    things, this means: no use of globals, replacing superglobals with a `Request`
    object, no use of the `new` keyword outside `Factory` classes, and (of course)
    injecting objects via the constructor as needed.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在将逻辑提取到类方法时，我们应该小心遵循我们在之前章节中学到的关于依赖注入的所有经验教训。除其他事项外，这意味着：不使用全局变量，用“请求”对象替换超全局变量，不在“工厂”类之外使用“new”关键字，以及（当然）根据需要通过构造函数注入对象。
- en: 'After we have found some candidate code using a `Gateway`, we need to examine
    the code surrounding `Gateway` usage for these and other operations:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用“网关”找到一些候选代码之后，我们需要检查围绕“网关”使用的代码，以进行这些和其他操作：
- en: Normalizing, filtering, sanitizing, and validating of data
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的规范化、过滤、清理和验证
- en: Calculation, modification, creation, and manipulation of data
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的计算、修改、创建和操作
- en: Sequential or concurrent operations and actions using the data
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据进行顺序或并发操作和动作
- en: Retention of success/failure/warning/notice messages from those operations and
    actions
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留来自这些操作和动作的成功/失败/警告/通知消息
- en: Retention of values and variables for later inputs and outputs
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留值和变量以供以后的输入和输出
- en: These and other pieces of logic are likely to be domain-related.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些和其他逻辑片段很可能与领域相关。
- en: 'To successfully extract the domain logic to one or more `Transactions` classes
    and methods, we will have to perform these and other activities:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功地将领域逻辑提取到一个或多个“交易”类和方法中，我们将不得不执行这些和其他活动：
- en: Breaking up or reorganizing the extracted domain logic into support methods
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解或重新组织提取的领域逻辑以支持方法
- en: Breaking up or reorganizing the original code to wrap around the new `Transactions`
    calls
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解或重新组织原始代码以包装新的“交易”调用
- en: Retaining, returning, or reporting data needed by the original code
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留、返回或报告原始代码所需的数据
- en: Adding, changing, or removing variables in the original code related to the
    extracted domain logic
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加、更改或删除与提取的领域逻辑相关的原始代码中的变量
- en: Creating and injecting dependencies for the `Transactions` classes and methods
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为“交易”类和方法创建和注入依赖项
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Discovery-and-extraction is best thought of as a learning exercise. Picking
    apart the legacy application like this is a way of learning how the application
    is constructed. As such, we should not be afraid to make multiple attempts at
    extraction. If our first attempt fails, ends up ugly, or gives poor results, we
    should feel no guilt about scrapping the work and starting over, having learned
    a little more about what works and what doesn't. For my own part, I often make
    two or three passes at extracting domain logic before the work is completed to
    my satisfaction. This is where a revision control system makes our life so much
    easier; we can work piecemeal, committing only as we are happy with the result,
    and reverting back to earlier stages if we need to begin again from a clean slate.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 发现和提取最好被视为学习的过程。像这样拆解遗留应用程序是一种了解应用程序构造的方式。因此，我们不应害怕多次尝试提取。如果我们的第一次尝试失败，变得丑陋，或者结果不佳，我们应该毫不内疚地放弃工作，重新开始，学到更多关于什么有效和什么无效的知识。就我个人而言，我经常在完成对领域逻辑的提取之前进行两到三次尝试。这就是修订控制系统让我们的生活变得更加轻松的地方；我们可以分阶段工作，只有在满意结果时才提交，如果需要从干净的状态重新开始，可以回滚到较早的阶段。
- en: Example Extraction
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取示例
- en: By way of example, recall the code we started with in [Appendix B](apb.xhtml
    "Appendix B. Code before Gateways"), *Code before Gateways*. Earlier in this chapter
    we mentioned that we had extracted embedded SQL statements to *ArticlesGateway*
    classes, ending up with the code in [Appendix C](apc.xhtml "Appendix C. Code after
    Gateways"), *Code after Gateways*. We now go from that to [Appendix D](apd.xhtml
    "Appendix D. Code after Transaction Scripts"), *Code after Transaction Scripts*
    where we have extracted the domain logic to an `ArticleTransactions` class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，回想一下我们在[附录B](apb.xhtml "附录B.网关之前的代码")中开始的代码，*网关之前的代码*。在本章的前面，我们提到我们已经将嵌入的SQL语句提取到*ArticlesGateway*类中，最终得到了[附录C](apc.xhtml
    "附录C.网关之后的代码")中的代码，*网关之后的代码*。现在我们从那里转到[附录D](apd.xhtml "附录D.事务脚本之后的代码")，*事务脚本之后的代码*，在那里我们已经将领域逻辑提取到一个`ArticleTransactions`类中。
- en: 'The extracted domain logic does not appear particularly complicated in its
    completed form, but actually doing the work turns out to be quite detailed. Review
    the [Appendix C](apc.xhtml "Appendix C. Code after Gateways"), *Code after Gateways*
    and compare to the [Appendix D](apd.xhtml "Appendix D. Code after Transaction
    Scripts"), *Code after Transaction Scripts*. Among other things, we should find
    the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 提取的领域逻辑在其完成形式中似乎并不特别复杂，但实际工作起来却非常详细。请查看[附录C](apc.xhtml "附录C.网关之后的代码")和[附录D](apd.xhtml
    "附录D.事务脚本之后的代码")进行比较。我们应该找到以下内容：
- en: 'We discovered two separate transactions being performed in the page script:
    one to submit a new article, and one to update an existing article. In turn, these
    each needed to operate on the user''s credit counts in the database, along with
    various data normalizing and support operations.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们发现页面脚本中执行了两个单独的事务：一个用于提交新文章，一个用于更新现有文章。依次，这些都需要在数据库中操作用户的信用计数，以及各种数据规范化和支持操作。
- en: We extracted the relevant domain logic to an `ArticleTransactions` class and
    two separate methods, one for creating and one for updating. We named the `ArticleTransactions`
    methods for the domain logic being performed, not for the implemenation of the
    underlying technical operations.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将相关的领域逻辑提取到了一个`ArticleTransactions`类和两个单独的方法中，一个用于创建，一个用于更新。我们为`ArticleTransactions`方法命名，以执行领域逻辑，而不是为底层技术操作的实现命名。
- en: Input filtering has been encapsulated as a support method in the `ArticleTransactions`
    class for reuse across both of the transaction methods.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入过滤已封装为`ArticleTransactions`类中的支持方法，以便在两个事务方法中重复使用。
- en: The new `ArticleTransactions` class receives `ArticlesGateway` and `UsersGateway`
    dependencies to manage the database interactions instead of making direct SQL
    calls.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的`ArticleTransactions`类接收`ArticlesGateway`和`UsersGateway`依赖项来管理数据库交互，而不是直接进行SQL调用。
- en: Several variables that were related only to the domain logic have been removed
    from the page script and placed into the `Transactions` class as properties.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些仅与领域逻辑相关的变量已从页面脚本中删除，并作为属性放入`Transactions`类中。
- en: The code in the original page script has been greatly reduced. It is now essentially
    an object creation and injection mechanism, passing user inputs to the domain
    layer and getting back data to output later.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始页面脚本中的代码已大大减少。现在它基本上是一个对象创建和注入机制，将用户输入传递到领域层，并在稍后获取数据进行输出。
- en: Because the domain logic is now encapsulated, the original code can no longer
    see the `$failure` variable as it gets modified throughout the transaction. That
    code must now get failure information from the `ArticleTransactions` class for
    later presentation.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于领域逻辑现在被封装起来，原始代码现在无法看到`$failure`变量，因为它在整个事务过程中被修改。该代码现在必须从`ArticleTransactions`类中获取失败信息，以供稍后呈现。
- en: 'After the extraction, we have a `classes/` directory structure that looks something
    like the following. This is a result of using a domain-oriented class structure
    when we extracted SQL to `Gateway` classes:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 提取后，我们有一个`classes/`目录结构，看起来类似以下内容。这是在我们将SQL提取到`Gateway`类时使用领域导向的类结构的结果：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This need not be our final refactoring. Further modifications of the `ArticleTransactions`
    are still possible. For example, instead of injecting a `UsersGateway`, it might
    make sense to extract various domain logic related to users into a `UserTransactions`
    class and inject that instead. There is still a lot of repetition between the
    `Transactions` methods. We also need better error checking and condition reporting
    in the `Transactions` methods. These and other refactorings are secondary, and
    will be both more noticeable and easier to deal with only after the primary extraction
    of domain logic.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这不一定是我们最终的重构。`ArticleTransactions`的进一步修改仍然是可能的。例如，与其注入`UsersGateway`，也许将与用户相关的各种领域逻辑提取到`UserTransactions`类中并注入可能更有意义。`Transactions`方法之间仍然存在很多重复。我们还需要更好的错误检查和条件报告在`Transactions`方法中。这些和其他重构是次要的，只有在主要提取领域逻辑之后才会更加明显和更容易处理。
- en: Spot check the remaining original code
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽查剩余的原始代码
- en: Once we have extracted one or more *Transactions* from the original code, we
    need to make sure the original code works when using the *Transactions* instead
    of the embedded domain logic. As before, we do this by running our pre-existing
    characterization tests. If we do not have characterization tests, we must browse
    to or otherwise invoke the changed code. If these tests fail, we rejoice! We have
    discovered that the extraction was flawed, and we have a chance to fix it before
    we deploy to production. If the "tests" pass, we likewise rejoice, and move on.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从原始代码中提取了一个或多个*Transactions*，我们需要确保在使用*Transactions*而不是嵌入式领域逻辑时，原始代码能够正常工作。与以前一样，我们通过运行我们预先存在的特性测试来做到这一点。如果我们没有特性测试，我们必须浏览或以其他方式调用已更改的代码。如果这些测试失败，我们会感到高兴！我们发现了提取的错误，并有机会在部署到生产之前修复它。如果“测试”通过，我们同样会感到高兴，并继续前进。
- en: Write tests for the extracted transactions
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为提取的事务编写测试
- en: We now know the original code works with the newly extracted *Transactions*
    logic. However, the new classes and methods need their own set of tests. As with
    everything else related to extracting domain logic, writing these tests is likely
    to be detailed and demanding. The logic is probably convoluted, with lots of branches
    and loops. We should not let this deter us from testing. At the very least, we
    need to write tests that cover the main cases of the domain logic.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道原始代码可以使用新提取的*Transactions*逻辑。然而，新的类和方法需要它们自己的一套测试。与提取领域逻辑相关的一切都一样，编写这些测试可能会很详细和苛刻。逻辑可能很复杂，有很多分支和循环。我们不应该因此而放弃测试。至少，我们需要编写覆盖领域逻辑的主要情况的测试。
- en: If necessary, we may refactor the extracted logic to separate methods that are
    themselves more easily testable. Breaking up the extracted logic will make it
    easier for us to see the flow and find repeated elements of logic. We must remember,
    though, that our goal is to maintain the existing behavior, not change the behavior
    presented by the legacy application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必要，我们可以重构提取的逻辑，将它们分开成更容易测试的方法。分解提取的逻辑将使我们更容易看到流程并找到重复的逻辑元素。但是，我们必须记住，我们的目标是维护现有的行为，而不是改变遗留应用程序呈现的行为。
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For insights and techniques on how to make the extracted logic more testable,
    please see *Refactoring* ([http://refactoring.com/](http://refactoring.com/))by
    Martin Fowler et al., as well as *Working Effectively With Legacy Code* ([https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/01311](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/01311))by
    Michael Feathers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何使提取的逻辑更具可测试性的见解和技术，请参阅Martin Fowler等人的*重构*（[http://refactoring.com/](http://refactoring.com/)）以及Michael
    Feathers的*与遗留代码有效地工作*（[https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/01311](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/01311)）。
- en: Spot check again, Commit, Push, Notify QA
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 再次抽查，提交，推送，通知QA
- en: Finally, because our testing and related refactoring of the extracted *Transactions*
    logic may have introduced some unexpected changes, we spot check the original
    code one more time using our characterization tests or by otherwise invoking the
    relevant code. If these fail, we rejoice! We have found out that our changes were
    not as good as we thought, and we have a chance to correct the code and tests
    before they get too far away from us.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们对提取的*Transactions*逻辑的测试和相关重构可能引入了一些意外的变化，我们再次使用我们的特性测试或以其他方式调用相关代码来抽查原始代码。如果这些失败，我们会感到高兴！我们发现了我们的更改并不像我们想象的那么好，我们有机会在代码和测试离我们太远之前纠正它们。
- en: When both the original code tests and the extracted *Transactions* tests pass,
    we rejoice again! We can now commit all of our new work, push it to the central
    repository, and notify QA that our modernized code is ready for them to review.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当原始代码测试和提取的*Transactions*测试都通过时，我们再次感到高兴！现在我们可以提交我们所有的新工作，将其推送到中央仓库，并通知QA我们的现代化代码已经准备好供他们审查。
- en: Do ... While
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Do ... While
- en: We begin the extraction process over again by looking for another *Gateway*
    usage outside a *Transactions* class. We continue extracting and testing until
    all *Gateway* calls occur inside *Transactions* classes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过寻找在*Transactions*类之外使用的另一个*Gateway*来重新开始提取过程。我们继续提取和测试，直到所有*Gateway*调用发生在*Transactions*类内部。
- en: Common Questions
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见问题
- en: Are we talking about SQL transactions?
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们是在谈论SQL事务吗？
- en: The term Transaction Script refers to an architectural pattern, and does not
    mean the the domain logic must be wrapped in an SQL transaction. It is easy to
    confuse the two ideas.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 事务脚本一词指的是一种架构模式，并不意味着领域逻辑必须包装在SQL事务中。很容易混淆这两个概念。
- en: Having said that, keeping SQL transactions in mind may help us when extracting
    domain logic. One useful rule-of-thumb is that pieces of domain logic should be
    split up according to how well they would fit inside a single SQL transaction.
    That hypothetical transaction would be committed, or rolled back, as an atomic
    whole.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，牢记SQL事务可能有助于我们提取领域逻辑。一个有用的经验法则是，领域逻辑的各个部分应该根据它们在单个SQL事务中的适应程度进行拆分。假设的事务将作为一个整体提交或回滚。
- en: This singularity-of-purpose will help us determine where the boundaries of our
    domain logic lie. We do not actually add SQL transactions, it is just that thinking
    in those terms can give us some insight as to the boundaries of the domain logic.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种目的的独特性将帮助我们确定领域逻辑的边界在哪里。我们实际上并没有添加SQL事务，只是以这种方式思考可以让我们对领域逻辑的边界有一些洞察。
- en: What about repeated Domain Logic?
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复的领域逻辑怎么办？
- en: When we extracted SQL statements to `Gateway` classes, we sometimes found queries
    that were similar but not exactly identical. We had to determine if there was
    a way to combine them into a single method or not.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将SQL语句提取到“Gateway”类时，有时会发现查询是相似但并非完全相同的。我们必须确定是否有办法将它们合并成一个方法。
- en: In the same way, we may discover that some parts of our legacy domain logic
    have been copied and pasted in two or more locations. When we find these, we have
    the same problem as with our `Gateway` classes. Are the pieces of logic similar
    enough to be combined into a single method, or must they be different methods
    (or even in completely different `Transactions`)?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可能会发现我们的传统领域逻辑的某些部分已经被复制并粘贴到两个或更多的位置。当我们发现这些情况时，我们与“Gateway”类有相同的问题。这些逻辑片段是否足够相似，可以合并成一个方法，还是必须是不同的方法（甚至完全不同的“Transactions”）？
- en: The answer here is it depends. In some cases the repeated code will be an obvious
    copy of logic elsewhere, meaning we can reuse existing `Transactions` methods.
    If not, we need to extract to a new `Transactions` class or method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 答案取决于具体情况。在某些情况下，重复的代码将是明显的逻辑复制，这意味着我们可以重用现有的“Transactions”方法。如果不是，我们需要提取到一个新的“Transactions”类或方法中。
- en: There is also a middle path, where the domain logic as a whole is different,
    but there are support elements of logic that are identical across different `Transactions`.
    In these cases, we can refactor the supporting logic as methods on an abstract
    base `Transactions` class, and then extend new `Transactions` from it. Alternatively,
    we can extract the logic to a supporting class and inject it into our `Transactions`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种中间路径，领域逻辑作为一个整体是不同的，但是在不同的“交易”中有相同的逻辑支持元素。在这些情况下，我们可以将支持逻辑重构为抽象基类“Transactions”类的方法，然后从中扩展新的“Transactions”。或者，我们可以将逻辑提取到一个支持类中，并将其注入到我们的“Transactions”中。
- en: Are printing and echoing part of Domain Logic?
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印和回显是否属于领域逻辑的一部分？
- en: Our `Transactions` classes should not be using `print` or `echo`. The domain
    logic should only return or retain data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“Transactions”类不应该使用“print”或“echo”。领域逻辑应该只返回或保留数据。
- en: When we discover output generation in the middle of our domain logic, we should
    extract that portion so that it lies outside of the domain logic. In general,
    this means collecting output in the `Transactions` class and then either returning
    it or making it available by a separate method. Leave output generation for the
    presentation layer.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发现领域逻辑中间存在输出生成时，我们应该提取该部分，使其位于领域逻辑之外。一般来说，这意味着在“Transactions”类中收集输出，然后通过一个单独的方法返回它或使其可用。将输出生成留给表示层。
- en: Can a transaction be a class instead of a Method?
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交易可以是一个类而不是一个方法吗？
- en: In the examples, we showed *Transactions* as a collection of methods related
    to a particular domain entity, such as *ArticleTransactions*. Each part of the
    domain logic related to that entity was wrapped in a class method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们展示了*Transactions*作为与特定领域实体相关的一组方法，例如*ArticleTransactions*。与该实体相关的领域逻辑的每个部分都包装在一个类方法中。
- en: However, it is also reasonable to break up domain logic into a one-class-per-transaction
    structure. Indeed, some transactions may be complex enough that they truly require
    their own separate classes. There is nothing wrong with using a single class to
    represent a single domain logic transaction.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将领域逻辑分解为每个交易一个类的结构也是合理的。事实上，一些交易可能足够复杂，以至于它们确实需要它们自己的单独类。使用单个类来表示单个领域逻辑交易没有任何问题。
- en: 'For example, the earlier *ArticleTransactions* class might be split into an
    abstract base class with support methods, and two concrete classes for each of
    the extracted pieces of domain logic. Each of the concrete classes extends the
    *AbstractArticleTransaction*, like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，之前的*ArticleTransactions*类可能被拆分为一个带有支持方法的抽象基类，以及为每个提取出的领域逻辑部分创建的两个具体类。每个具体类都扩展了*AbstractArticleTransaction*，如下所示：
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we use a one-class-per-transaction approach, what do we name the main method
    on the single-transaction class, the one that actually performs the transaction?
    If there is a common convention for main methods that already exist in our legacy
    codebase, we should adhere to that convention. Otherwise, we need to pick a single
    consistent method name. Personally, I enjoy co-opting the `__invoke()` magic method
    for this purpose, but you may wish to use `exec()` or some other appropriate term
    to indicate we are executing or otherwise performing the transaction.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们采用每个交易一个类的方法，我们应该如何命名单个交易类上的主要方法，实际执行交易的方法？如果我们的传统代码库中已经存在主要方法的常见约定，我们应该遵守该约定。否则，我们需要选择一个一致的方法名称。个人而言，我喜欢利用`__invoke()`魔术方法来实现这个目的，但您可能希望使用`exec()`或其他适当的术语来指示我们正在执行或以其他方式执行交易。
- en: What about Domain Logic in Gateway classes?
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “Gateway”类中的领域逻辑怎么办？
- en: When we extracted our SQL statements to `Gateway` classes, it is possible that
    we moved some domain logic into them instead of leaving that logic in its original
    location. At that earlier point in our refactoring work, it was very easy to confuse
    domain-level input filtering (which makes sure the data conforms to a domain-specific
    state) with database-level filtering (which makes sure the data is safe to use
    with the database).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将SQL语句提取到“Gateway”类时，有可能将一些领域逻辑移入其中，而不是保留在原始位置。在我们重构工作的早期阶段，很容易混淆领域级输入过滤（确保数据符合特定领域状态）与数据库级过滤（确保数据可以安全地与数据库一起使用）。
- en: Now we can more easily tell the difference between the two. If we discover that
    there is domain-level logic in our `Gateway` classes, we should probably extract
    it to our `Transactions` classes instead. We need to be sure to update the relevant
    tests as well.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更容易地区分这两者。如果我们发现我们的“网关”类中存在领域级别的逻辑，我们可能应该将其提取到我们的“交易”类中。我们需要确保相应的测试也要更新。
- en: What about Domain logic embedded in Non-Domain classes?
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非领域类中嵌入的领域逻辑怎么办？
- en: The examples in this chapter show domain logic embedded in page scripts. It
    is just as likely that we have domain logic embedded in classes as well. If the
    class can reasonably be considered part of the domain, and contains only domain-related
    logic, but is not named for the domain, it may be wise to move the class into
    the domain namespace.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例显示了嵌入在页面脚本中的领域逻辑。同样可能的是，我们的类中也嵌入了领域逻辑。如果该类可以合理地被视为领域的一部分，并且仅包含与领域相关的逻辑，但未命名为领域，将该类移动到领域命名空间可能是明智的。
- en: Otherwise, if the class has any responsibilities other than domain logic, we
    may proceed to extract the domain logic from it in the same way that we extracted
    logic from a page script. After the extraction, the original class will then need
    to have the relevant `Transactions` class injected as a dependency. The original
    class should then make calls to the `Transactions` as appropriate.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果该类除了领域逻辑之外还有其他责任，我们可以继续以与从页面脚本中提取逻辑相同的方式从中提取领域逻辑。提取后，原始类将需要将相关的“交易”类注入为依赖项。然后原始类应适当地调用“交易”。
- en: Review and next steps
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾和下一步
- en: At this point we have extracted the core of our legacy codebase, the domain
    logic that sits at the center our application, to its own separate and testable
    layer. This has been the most demanding of the steps in our modernization process,
    but it has been very much worth our time. We have not made many modifications
    or improvements to the domain logic itself. Any changes we have made have been
    just enough to get data into our new `Transactions` classes and then out again
    for later use.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经将我们遗留代码库的核心，即位于我们应用程序中心的领域逻辑，提取到了自己独立且可测试的层中。这是我们现代化过程中最具挑战性的步骤，但这绝对是值得我们花费时间的。我们并没有对领域逻辑本身进行太多修改或改进。我们所做的任何更改都只是足够将数据输入到我们的新“交易”类中，然后再次用于后续使用。
- en: In a lot of ways, all we have done is shuffle the logic around so that it is
    independently addressable. Although the domain logic itself may still have many
    problems, those problems are now *testable* problems. We can continue adding tests
    as needed to explore edge cases in our domain logic. If we need to add new domain
    logic, we can create or modify our `Transactions` classes and methods to encapsulate
    and test that logic.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多方面，我们所做的只是重新安排逻辑，使其能够独立地被访问。虽然领域逻辑本身可能仍然存在许多问题，但这些问题现在是*可测试*的问题。我们可以根据需要继续添加测试，以探索领域逻辑中的边缘情况。如果我们需要添加新的领域逻辑，我们可以创建或修改我们的“交易”类和方法来封装和测试该逻辑。
- en: The process of extracting domain logic to its own layer leaves us with a great
    foundation for further iterative refactoring of the domain model. If we choose
    to pursue it, that refactoring will lead us to a more appropriate architecture
    for the application domain logic. However, what that architecture will be depends
    on the application. For more information on developing a good domain model for
    our application, please read *Domain Driven Design* ([https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215))
    by Eric Evans.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将领域逻辑提取到自己的层中的过程为我们进一步迭代地重构领域模型奠定了良好的基础。如果我们选择追求这一点，这种重构将引导我们走向更适合应用领域逻辑的架构。然而，该架构将取决于应用程序。有关为我们的应用程序开发良好领域模型的更多信息，请阅读Eric
    Evans的《领域驱动设计》（[https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)）。
- en: With the extraction of our domain logic to its own layer, we can continue on
    to the next phase of our modernization process. At this point there are only a
    few concerns remaining in our original code. Of those concerns, we will next address
    the presentation layer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将领域逻辑提取到自己的层中，我们可以继续进行现代化过程的下一阶段。在这一点上，我们原始代码中只剩下了一些关注点。在这些关注点中，我们将下一个关注点放在呈现层上。
