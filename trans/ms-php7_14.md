# 使用包

现代 PHP 应用程序往往由大量文件组成。以 Magento 2 电子商务平台为例。一旦安装，其`vendor`目录包含超过三万个 PHP 类文件。它的庞大足以使任何人震惊。为什么会有这么多文件，人们可能会想？如今，使用其他开发人员在我们之前编写的现有库和包是流行的，甚至是强制性的。总是重新发明轮子并没有太多意义。这就是为什么像 Composer 这样的包管理器在 PHP 开发人员中如此受欢迎的原因。使用这些包管理器通常意味着将各种第三方包引入我们的项目。虽然这通常暗示着应用程序大小的增加，但它也允许我们快速启动应用程序开发。另一个好处是这些包由第三方持续维护，我们只需将其更新到我们的应用程序中。

在本章中，我们将研究 Composer，最受欢迎的 PHP 包管理器：

+   理解 Composer

+   理解 Packagist

+   使用第三方包

+   创建你自己的包

+   分发您的包

在前几章中，我们已经接触到了 Composer，因为我们使用了它的一些包。以下各节将在此基础上增加一些额外的清晰度，并展示我们如何创建自己的包。

# 理解 Composer

Composer 是 PHP 的*每个项目*包管理器。最初于 2011 年发布，它迅速赶上并成为 PHP 开发人员中最受欢迎的包管理器。仅仅通过查看其 GitHub 统计数据，我们就可以看到该项目正在由社区积极开发：

![](img/e14d7ade-f249-4709-80cf-7a592d78176f.png)

如今，它几乎成为每个流行的 PHP 项目的一个组成部分。安装 Composer 是一个相当简单的任务。假设我们正在使用新的 Ubuntu 16.10（Yakkety Yak）安装，以下命令概述了我们如何安装 Composer：

```php
sudo apt-get -y install composer

```

安装后运行`composer -v`应该显示类似以下截图的输出：

![](img/cad1b44a-b5ed-49bd-aa8e-6a2db623e449.png)

现在我们已经安装了它，使用 Composer 非常简单。假设我们有一个现有项目，我们想要添加 Twig 库，我们只需在项目根目录中运行以下命令：

```php
composer require "twig/twig:².0"

```

![](img/b1e995de-1231-4e0e-9e21-c040d510ad87.png)

执行后，会创建/修改两个文件和一个目录：`composer.json`，`composer.lock`和`vendor`。`vendor`目录是 Composer 放置我们选择安装的包的物理位置。我们本可以通过手动创建相同的`composer.json`文件并运行`composer install`命令来开始，内容如下：

```php
{
  "require": {
    "twig/twig": "².0"
  }
}

```

查看[`getcomposer.org/doc/04-schema.md`](https://getcomposer.org/doc/04-schema.md)获取有关可能的`composer.json`内容的完整信息。

现在我们可以轻松修改`index.php`或任何其他入口文件到我们的根项目目录，并通过添加以下条目来包含所有已安装的 composer 包：

```php
require_once __DIR__ . '/vendor/autoload.php';

```

`vendor/autoload.php`文件是由 composer 工具创建的，它处理了我们通过 composer 拉入的所有包的自动加载，内容如下：

```php
<?php

// autoload.php @generated by Composer

require_once __DIR__ . '/composer/autoload_real.php';

return ComposerAutoloaderInitea5a081b69b5068b6eadbd8b638d57b2::getLoader();

```

这个文件并不是我们真正需要关心的东西，除了知道它在哪里。

支持 PSR-4 和 PSR-0 自动加载，尽管 PSR-4 是推荐的方式，因为它提供了更大的易用性。

一旦我们将`/vendor/autoload.php`包含到我们的脚本中，所有拉入的包都可以在我们的应用程序中使用。无论是新项目还是现有项目，Composer 都可以很容易地向其中添加包。

全面了解 Composer 超出了本节的范围。有关 Composer 的更多详细信息，请参阅原始文档([`getcomposer.org/`](https://getcomposer.org/))。

# 了解 Packagist

就像 Git 和 GitHub 的关系一样，我们有 Composer 和 Packagist 的关系。虽然**Composer**本身是实际工具，**Packagist**是为 Composer 提供包的默认存储库服务。服务足够简单，让我们找到我们想要为项目使用的包。不需要深入了解内部情况，可以说 composer 工具知道在 Packagist 上托管的每个包的代码在哪里获取。

Packagist 存储库服务托管在[`packagist.org`](https://packagist.org)上：

![](img/06ab76e9-13ac-498e-9612-0c429beb57ab.png)

Composer 的受欢迎程度随时间的推移可以通过[`packagist.org/statistics`](https://packagist.org/statistics)页面轻松观察到，该页面显示了 Packagist 存储库中包的数量在几年内迅速增加的情况：

![](img/e496c0dd-e78a-408c-a8c9-730d7d9f968a.png)

# 使用第三方包

我们已经看到了通过以下两种选项之一安装 composer 包是多么容易：

+   执行诸如`require vendor/package:2.* vendor/package2:dev-master`之类的命令

+   在`composer.json`的`require`下添加包链接信息，并在控制台上执行`composer install`

如果不知道我们可能需要哪个包，我们可以使用[`packagist.org`](https://packagist.org)搜索工具来查找。例如，假设我们正在寻找具有电子邮件发送功能的包。这就是 Packagist 存储库的庞大规模可能需要我们一些时间来找到合适的包的地方。幸运的是，我们可以使用下载量排序或收藏夹排序来帮助自己：

![](img/857cc6de-49c9-441c-b7b8-5f67c1c7e198.png)

一旦单击单个包，我们就可以看到可以安装的可用版本：

![](img/e5a96eb1-a05f-4c45-a099-3a39c6647999.png)

在这种情况下运行`composer require swiftmailer/swiftmailer`将为我们提供最新的稳定版本 5.4.6。

安装后，可以通过在项目根目录中运行`composer update`命令来将包稍后更新为可能的新稳定版本。

# 创建您自己的包

使用`composer init`命令，我们可以启动交互式`composer.json`生成器，稍后我们将使用它来分发我们的包。交互式生成器提出了几个问题，如下所示：

![](img/ed12ecb8-3bdb-4ff8-afd7-0335ec6bb960.png)

我们在这里使用`foggyline`作为我们的供应商名称，而`mp7`（代表精通 PHP 7）被用作包名称。完成后，将生成具有以下内容的`composer.json`文件：

```php
{
"name": "foggyline/mp7",
"description": "Just a test package.",
"type": "library",
"license": "MIT",
"authors": [
    {
"name": "Branko Ajzele",
"email": "ajzele@gmail.com"
  }
  ],
"require": {}
}

```

现在，让我们继续创建相对于项目根目录的`src/Foggyline/MP7/Greeting/Goodbye.php`文件，其中包含以下内容：

```php
<?php   namespace FoggylineMP7Greeting;   class Welcome {
  public function generate($name)
 {  return 'Welcome ' . $name;
 } } 

```

这是我们即将分发为 composer 包的虚拟库类。在这样做之前，我们需要通过添加顶级`autoload`条目来修改`composer.json`，如下所示：

```php
"autoload": {
 "psr-4": {
 "FoggylineMP7": "src/Foggyline/MP7/"
  }
}

```

要测试`autoload`是否设置正确，我们运行`composer dump-autoload --optimize`控制台命令，并创建具有以下内容的`index.php`文件。我们故意使用完整路径到`MP7`目录，因为这将是我们的单独库，即包：

```php
<?php   require_once __DIR__ . '/vendor/autoload.php';   use FoggylineMP7GreetingWelcome;   $greeting = new Welcome();   echo $greeting->generate('John');

```

如果一切顺利，运行此脚本应该给我们一个欢迎约翰的输出。现在我们有了描述我们的项目的`composer.json`，以及包含我们的库代码的`src/Foggyline/MP7/`，我们可以继续并分发这个。

# 分发您的包

首先，我们需要将`composer.json`和我们的库代码从`src/Foggyline/MP7/`中推送到 GitHub 存储库。假设我们有一个空的 GitHub 存储库，比如`git@github.com:ajzele/foggyline_mp7.git`，等待我们，我们可以通过以下几个命令轻松地完成：

```php
git init
git remote add origin git@github.com:ajzele/foggyline_mp7.git
git add composer.json
git add src/Foggyline/MP7/
git commit -m "Initial commit"
git push origin master

```

这应该显示在 GitHub 上，如下所示：

![](img/14d542f0-2be1-44b5-b8a8-b146219792b7.png)

有了 GitHub 存储库中的文件，我们现在可以访问[`packagist.org`](https://packagist.org)页面并提交我们的包：

![](img/d39ee193-dbf3-4ca5-89d4-b45086c5ff40.png)

一旦检查完成，我们应该能够看到类似以下的屏幕：

![](img/9d66c52e-1665-4599-9939-859311798b0f.png)

一旦我们点击提交按钮，我们应该能够看到类似以下的屏幕：

![](img/f27f0f7d-a6b2-48e9-b585-64c8897a249d.png)

我们现在应该能够通过运行以下控制台命令在任何项目中使用`foggyline/mp7`包：

```php
composer require foggyline/mp7:dev-master

```

注意这里的`dev-master`后缀。我们的包只被标记为`dev-master`。这是因为我们的[`github.com/ajzele/foggyline_mp7`](https://github.com/ajzele/foggyline_mp7)存储库上没有定义标签。

让我们继续给我们的存储库添加一个`v1.5`标签。我们可以通过运行以下控制台命令来完成：

```php
git tag -a v1.5 -m "my version 1.4" 648e31cc4a
git push origin v1.5

```

由于我们要给已经提交的提交添加标签，我们使用提交 ID `648e31cc4a` 来附加标签。一旦标签被推送到 GitHub 存储库，我们可以回到 Packagist 并在包编辑屏幕上点击更新按钮。这应该立即更新包版本列表，显示`v1.5`：

![](img/85531944-605f-43c7-ab7f-39865a1256e9.png)

假设我们有一个项目目录，里面只有一个`index.php`文件，我们应该能够通过运行以下控制台命令来使用`foggyline/mp7`包：

```php
composer require foggyline/mp7

```

这应该导致一个目录结构，如下所示：

![](img/9a7b2a1d-4f9b-4334-9749-21b572c0d470.png)

然后，`index.php`脚本就可以通过包含`/vendor/autoload.php`来开始使用我们的 MP7 库。

# 摘要

在本章中，我们看了一下 PHP 最流行的包管理器 Composer。我们看到了如何轻松地向我们的应用程序添加第三方包，以及如何使用 Packagist 存储库分发我们自己的包。许多现代 PHP 应用程序依赖 Composer，这就是为什么了解如何充分利用它对我们日常开发工作至关重要。

接下来，我们将看一下适用于 PHP 应用程序的测试类型。
