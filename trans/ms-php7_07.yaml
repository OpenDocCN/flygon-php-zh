- en: Optimizing for High Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化高性能
- en: Throughout the years, PHP has grown into a remarkable language we use to build
    our web applications. An impressive number of language features, alongside countless
    libraries and frameworks, make our job ever so easier. We often write code which
    encompasses several layers of stack without giving it a second thought. This makes
    it easy to overlook one of the most important aspects of every application--performance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，PHP已经发展成为我们构建Web应用程序所使用的一种非凡语言。令人印象深刻的语言特性，以及无数的库和框架，使我们的工作变得更加容易。我们经常编写涵盖多层堆栈的代码，而不加思索。这使得很容易忽视每个应用程序最重要的方面之一--性能。
- en: 'While there are several aspects to performance that developers need to pay
    attention to, the end user is only interested in one - the time it takes for their
    web page to be loaded. This is really all that it comes down to. Nowadays, users expect
    their pages to load in less than 2 seconds. Anything more and we face decreased
    conversion, which often translates into serious financial loss when it comes to
    big e-commerce retailers:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然性能有几个方面需要开发人员注意，但最终用户只对一个方面感兴趣 - 网页加载所需的时间。这才是最重要的。如今，用户期望他们的页面在2秒内加载。如果超过这个时间，我们将面临转化率下降，这通常会导致大型电子商务零售商严重的财务损失：
- en: '"A 1 second delay in page response can result in a 7% reduction in conversions."  "If
    an e-commerce site is making $100,000 per day, a 1 second page delay could potentially
    cost you $2.5 million in lost sales every year."'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “页面响应延迟1秒可能导致转化率减少7%。”“如果一个电子商务网站每天赚取10万美元，1秒的页面延迟可能会导致您每年损失250万美元的销售额。”
- en: - kissmetrics.com
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: - kissmetrics.com
- en: 'In this chapter, we will address some of the areas of PHP that directly or
    indirectly impact the application performance and behavior:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一些直接或间接影响应用程序性能和行为的PHP领域：
- en: Max execution time
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大执行时间
- en: Memory management
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理
- en: File uploads
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件上传
- en: Session handling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话处理
- en: Output buffering
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出缓冲
- en: Disabling debug messages
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用调试消息
- en: Zend OPcache
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zend OPcache
- en: Concurrency
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发
- en: Max execution time
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最大执行时间
- en: The **maximum execution time** is one of the most common errors developers come across.
    By default, the maximum execution time of the PHP script executing in the browser
    is 30 seconds, unless we execute the script within the CLI environment, where
    there is no such limitation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**最大执行时间**是开发人员经常遇到的最常见错误之一。默认情况下，在浏览器中执行的PHP脚本的最大执行时间为30秒，除非我们在CLI环境中执行脚本，那里没有这样的限制。'
- en: 'We could easily test that through a simple example, given through the `index.php`
    and `script.php` files, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个简单的例子进行测试，通过`index.php`和`script.php`文件，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Executed from within the browser, this will return the following error:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中执行，将返回以下错误：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Executed from within the CLI environment, this will return the following output:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在CLI环境中执行，将返回以下输出：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Luckily for us, PHP provides two ways to control the timeout value:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，PHP提供了两种控制超时值的方法：
- en: Using the `max_execution_time` configuration directive (`php.ini` file, `ini_set()`
    function)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`max_execution_time`配置指令（`php.ini`文件，`ini_set()`函数）
- en: Using the `set_time_limit()` function
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`set_time_limit()`函数
- en: 'The `set_time_limit()` function use has an interesting implication. Let''s
    take a look at the following example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_time_limit()`函数的使用具有有趣的含义。让我们看看以下例子：'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding example will result in the following error:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子将导致以下错误：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Interestingly enough, the `set_time_limit()` function restarts the timeout counter
    from zero at the point where it was called. What this really means is that using
    the `set_time_limit()` function throughout the code, in a largely complex system,
    we can significantly extend the overall timeout beyond the initially imagined
    boundaries. This is quite dangerous, as PHP timeout is not the only timeout in
    the mix when it comes to delivering the final web page to a user's browser.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '有趣的是，`set_time_limit()`函数会从调用它的地方重新启动超时计数器。这实际上意味着，在一个非常复杂的系统中，通过在代码中多次使用`set_time_limit()`函数，我们可以显著扩展超时时间，超出最初设想的边界。这是非常危险的，因为PHP超时不是在向用户浏览器交付最终网页时唯一的超时。 '
- en: 'Web servers come with various timeout configurations of their own that might interrupt
    the PHP execution:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器具有各种超时配置，可能会中断PHP执行：
- en: 'Apache:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache：
- en: '`TimeOut` directive, defaults to 60 seconds'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimeOut`指令，默认为60秒'
- en: 'Nginx:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nginx：
- en: '`client_header_timeout` directive, defaults to 60 seconds'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client_header_timeout`指令，默认为60秒'
- en: '`client_body_timeout` directive, defaults to 60 seconds'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client_body_timeout`指令，默认为60秒'
- en: '`fastcgi_read_timeout` directive, defaults to 60 seconds'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fastcgi_read_timeout`指令，默认为60秒'
- en: While we can certainly control script timeouts within the browser context, the important
    question is *why would we want to do so*? Timeouts are usually a result of resource-intense
    operations, such as various non-optimized loops, data exports, imports, PDF file
    generations, and so on. The CLI environment, or ideally, dedicated services, should
    be our go-to when it comes to all resource-intense jobs. Whereas the browser environment's
    prime focus should be delivering pages to users in the shortest possible amount
    of time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在浏览器环境中控制脚本超时，但重要的问题是*为什么我们要这样做*？超时通常是资源密集型操作的结果，例如各种非优化循环，数据导出，导入，PDF文件生成等。CLI环境，或者理想情况下，专用服务，应该是我们处理所有资源密集型工作的首选。而浏览器环境的主要重点应该是以尽可能短的时间向用户提供页面。
- en: Memory management
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: Quite often, PHP developers need to deal with a large amount of data. While large
    is a relative term, memory is not. Certain combinations of functions and language
    constructs, when used irresponsibly, can clog our server memory in a matter of
    seconds.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: PHP开发人员经常需要处理大量数据。虽然“大量”是一个相对的术语，但内存不是。当不负责任地使用某些函数和语言结构的组合时，我们的服务器内存可能在几秒钟内被堵塞。
- en: 'Probably the most notorious function is `file_get_contents()`. This easy-to-use
    function literally grabs the content of an entire file and puts it into memory.
    To better understand the issue, let''s take a look at the following example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最臭名昭著的函数是`file_get_contents()`。这个易于使用的函数会将整个文件的内容放入内存中。为了更好地理解问题，让我们看看以下例子：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While this code is perfectly valid and working, it is a potential performance
    bottleneck. The `$content` variable will pull the content of the entire `users.csv`
    file into memory. While this could work for a small file size, of let's say a
    couple of megabytes, the code is not performance optimized. The moment `users.csv`
    starts to grow, we will begin experiencing memory issues.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码完全有效且可用，但它是潜在的性能瓶颈。`$content`变量将整个`users.csv`文件的内容加载到内存中。虽然这对于小文件大小可能有效，比如几兆字节，但这段代码并没有经过性能优化。一旦`users.csv`开始增长，我们将开始遇到内存问题。
- en: 'What can we do to mitigate the issue? We can rethink our approach to solving
    a problem. The moment we shift our mind into the *must optimize performance* mode,
    other solutions become clear. Instead of reading the content of an entire file
    into the variable, we can parse the file line by :'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取什么措施来减轻问题？我们可以重新思考解决问题的方法。一旦我们将思维转向“必须优化性能”模式，其他解决方案就会变得清晰。我们可以不将整个文件的内容读入变量，而是逐行解析文件。
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Instead of using  `file_get_contents()` and `str_getcsv()`, we focus onto using
    another set of functions, `fopen()` and `fgetcsv()`. The end result is absolutely the
    same, with the added benefit of being fully performance friendly. Using functions
    with handles, in this specific case, we have effectively assured that memory limitations
    are not an issue for our script.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用`file_get_contents()`和`str_getcsv()`，而是专注于使用另一组函数`fopen()`和`fgetcsv()`。最终结果完全相同，而且完全符合性能友好。在这种特定情况下使用带有句柄的函数，我们有效地确保了内存限制对我们的脚本不构成问题。
- en: 'The irresponsible use of loops is another common cause of memory :'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不负责任地使用循环是内存的另一个常见原因：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s go ahead and see a modified, memory-friendly example with the same effect:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续看一个修改后的、内存友好的例子，效果相同：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `fetchAll()` method is slightly faster than `fetch()`, but it requires more
    memory.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchAll()`方法比`fetch()`稍快，但需要更多内存。'
- en: 'When PHP hits the memory limit, it stops the script execution and throws the
    following error:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当PHP达到内存限制时，它会停止脚本执行并抛出以下错误：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Luckily, the `memory_limit` directive enables us to control the amount of memory
    available. The default `memory_limit` value is `128M`, which implies 128 megabytes
    of memory. The directive is `PHP_INI_ALL` changeable, which means that apart from
    setting it via the `php.ini` file, we can set it at runtime using `ini_set('memory_limit',
    '512M');`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`memory_limit`指令使我们能够控制可用内存量。默认的`memory_limit`值是`128M`，这意味着128兆字节的内存。该指令是`PHP_INI_ALL`可更改的，这意味着除了通过`php.ini`文件设置它外，我们还可以使用`ini_set('memory_limit',
    '512M');`在运行时设置它。
- en: 'Aside from tuning the `memory_limit` directive, PHP provides the following
    two functions that return memory usage information:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了调整`memory_limit`指令外，PHP提供了以下两个返回内存使用信息的函数：
- en: '`memory_get_usage()`: This returns the amount of memory currently allocated
    by our PHP script'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory_get_usage()`: 返回当前PHP脚本分配的内存量'
- en: '`memory_get_peak_usage()`: This returns the peak amount of memory allocated
    by our PHP script'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory_get_peak_usage()`: 返回PHP脚本分配的内存峰值'
- en: While we might be tempted to increase this value, we should think twice about
    doing so. The memory limit is per process, not per server. Web servers themselves
    can spin up several processes. Using large memory limit values can therefore clog
    our server. Aside from that, any script that might actually consume a large amount
    of memory is easily a candidate for performance optimization. Applying simple, thought-through
    techniques to our code can greatly reduce memory use.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可能会想要增加这个值，但我们应该三思而后行。内存限制是针对进程而不是服务器的。Web服务器本身可以启动多个进程。因此，使用大内存限制值可能会阻塞我们的服务器。除此之外，任何可能实际消耗大量内存的脚本都很容易成为性能优化的候选。对我们的代码应用简单而经过深思熟虑的技术可以大大减少内存使用。
- en: When it comes to actual memory management, things are pretty automated here.
    Unlike C language, where we get to manage memory ourselves, PHP uses garbage collection
    in combination with a reference counting mechanism. Without going into the ins
    and outs of the mechanism itself, it is suffice to say that variables are automatically
    released when they are not being used any more.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际内存管理方面，这里的情况相当自动化。与C语言不同，我们需要自己管理内存，PHP使用垃圾回收结合引用计数机制。不用深入机制本身的细节，可以说变量在不再使用时会自动释放。
- en: For more details on garbage collection, check out [http://php.net/manual/en/features.gc.php](http://php.net/manual/en/features.gc.php).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有关垃圾回收的更多详细信息，请查看[http://php.net/manual/en/features.gc.php](http://php.net/manual/en/features.gc.php)。
- en: File uploads
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件上传
- en: Uploading files is a common functionality to many PHP applications. So common
    that PHP provides a convenient global `$_FILES` variable we can use to access
    uploaded files, or errors behind the file upload tries.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上传文件是许多PHP应用程序的常见功能。PHP提供了一个方便的全局`$_FILES`变量，我们可以用它来访问上传的文件，或者在文件上传尝试后的错误。
- en: 'Let''s take a look at the following simple file upload form:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下简单的文件上传表单：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In order for PHP to pick up the files, we need to set the `form method` value
    to `post`, and `enctype` to `multipart/form-data`. Once submitted, PHP will pick
    it up and fill in the `$_FILES` variable appropriately:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让PHP获取文件，我们需要将`form method`的值设置为`post`，并将`enctype`设置为`multipart/form-data`。一旦提交，PHP将接收并适当填充`$_FILES`变量：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Without going into the details of the actual post-upload file management, it''s
    suffice to say that `$_FILES` contains enough information for us to either pick
    up and further manage files, or indicate a possible error code during upload.
    The following eight error codes can be returned:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在不涉及实际的上传后文件管理的细节的情况下，可以说`$_FILES`包含足够的信息，以便我们可以选择并进一步管理文件，或者在上传过程中指示可能的错误代码。以下八个错误代码可以返回：
- en: '`UPLOAD_ERR_OK`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPLOAD_ERR_OK`'
- en: '`UPLOAD_ERR_INI_SIZE`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPLOAD_ERR_INI_SIZE`'
- en: '`UPLOAD_ERR_FORM_SIZE`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPLOAD_ERR_FORM_SIZE`'
- en: '`UPLOAD_ERR_PARTIAL`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPLOAD_ERR_PARTIAL`'
- en: '`UPLOAD_ERR_NO_FILE`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPLOAD_ERR_NO_FILE`'
- en: '`UPLOAD_ERR_NO_TMP_DIR`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPLOAD_ERR_NO_TMP_DIR`'
- en: '`UPLOAD_ERR_CANT_WRITE`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPLOAD_ERR_CANT_WRITE`'
- en: '`UPLOAD_ERR_EXTENSION`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPLOAD_ERR_EXTENSION`'
- en: 'While all of the errors should be equally addressed, two of them (`UPLOAD_ERR_FORM_SIZE`
    and `UPLOAD_ERR_PARTIAL`) open up crucial performance questions: *how big a file
    can we upload* and *are there any timeouts in the process*?'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然所有错误应该得到同等对待，但其中两个（`UPLOAD_ERR_FORM_SIZE`和`UPLOAD_ERR_PARTIAL`）引发了关键的性能问题：*我们可以上传多大的文件*以及*在过程中是否存在任何超时*？ '
- en: 'The answer to these two questions can be found in configuration directives,
    some of which are directly related to file upload, while others are related to
    more general PHP options:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个问题的答案可以在配置指令中找到，其中一些直接与文件上传相关，而其他一些与更一般的PHP选项相关：
- en: '`session.gc_maxlifetime`: This is the number of seconds after which data will
    be seen as garbage and cleaned up; it defaults to 1,440 seconds'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.gc_maxlifetime`：这是数据被视为垃圾并清理的秒数；默认为1,440秒'
- en: '`session.cookie_lifetime`: This is the lifetime of the cookie in seconds; by
    default, the cookie is valid until the browser is closed'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.cookie_lifetime`：这是cookie的生存时间（以秒为单位）；默认情况下，cookie在浏览器关闭之前有效'
- en: '`max_input_time`: This is the maximum time in seconds a script is allowed to
    parse input data, such as POST; by default, this is turned off'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_input_time`：这是脚本允许解析输入数据（如POST）的最长时间（以秒为单位）；默认情况下，此功能已关闭'
- en: '`max_execution_time`: This is the maximum time a script is allowed to run before
    it is terminated; it defaults to 30 seconds'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_execution_time`：这是脚本允许运行的最长时间；默认为30秒'
- en: '`upload_max_filesize`: This is the maximum size of an uploaded file; it defaults
    to 2 megabytes (2M)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upload_max_filesize`：这是上传文件的最大大小；默认为2兆字节（2M）'
- en: '`max_file_uploads`: This is the maximum number of files allowed to be uploaded in
    a single request'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_file_uploads`：这是允许在单个请求中上传的最大文件数'
- en: '`post_max_size`: This is the maximum size of the post data allowed; it defaults
    to 8 megabytes (8M)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post_max_size`：这是允许的POST数据的最大大小；默认为8兆字节（8M）'
- en: 'Tweaking these options ensures that we avoid timeouts and planned size limits.
    To ensure that we can avoid the maximum file size limitation early in the process, `MAX_FILE_SIZE`
    can be used as a hidden form field:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 调整这些选项可以确保我们避免超时和计划的大小限制。为了确保我们可以在过程的早期避免最大文件大小限制，`MAX_FILE_SIZE`可以用作隐藏的表单字段：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `MAX_FILE_SIZE` field must precede any other file field a form might have.
    Its value stands for the maximum file size accepted by PHP.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAX_FILE_SIZE`字段必须位于表单可能具有的任何其他文件字段之前。它的值代表PHP接受的最大文件大小。'
- en: 'Trying to upload a file larger than defined by the `MAX_FILE_SIZE` hidden field
    would now result in a `$_FILES` variable similar to the one shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试上传大于`MAX_FILE_SIZE`隐藏字段定义的文件现在将导致类似于此处所示的`$_FILES`变量：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can see that the error has now turned to value `2`, which equals the `UPLOAD_ERR_FORM_SIZE`
    constant.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到错误现在已经变成了值`2`，这等于`UPLOAD_ERR_FORM_SIZE`常量。
- en: While normally we would address the limitations of default configuration through
    code optimization, file uploads are specific; in that, we really need to ensure
    that large file uploads are possible if needed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们会通过代码优化来解决默认配置的限制，但文件上传是特殊的；因此，我们确实需要确保如果需要的话可以上传大文件。
- en: Session handling
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话处理
- en: Sessions are an interesting mechanism in PHP, allowing us to maintain state
    in what is overall a stateless communication. We might visualize them as a *per-user
    serialized array of information* saved to a file. We use them to store user-specific information
    across various pages. By default, sessions rely on cookies, although, they can
    be configured to use the `SID` parameter in a browser.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 会话在PHP中是一个有趣的机制，允许我们在总体上是无状态的通信中保持状态。我们可以将它们视为保存在文件中的*每个用户序列化信息数组*。我们使用它们来在各个页面上存储用户特定的信息。默认情况下，会话依赖于cookie，尽管它们可以配置为在浏览器中使用`SID`参数。
- en: 'The cookie version of the PHP session works roughly as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: PHP会话的cookie版本大致如下：
- en: Read the session token from the cookie.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从cookie中读取会话令牌。
- en: Create or open an existing file on disk.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在磁盘上创建或打开现有文件。
- en: Lock the file for writing.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 锁定文件以进行写入。
- en: Read the content of the file.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取文件的内容。
- en: Put the file data into the global `$_SESSION` variable.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件数据放入全局`$_SESSION`变量中。
- en: Set caching headers.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置缓存头。
- en: Return the cookie to the client.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将cookie返回给客户端。
- en: On each page request, repeat steps 1-7.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个页面请求上，重复步骤1-7。
- en: The *SID version* of the PHP session works pretty much the same way, aside from
    the cookie part. The cookie here is replaced by the SID value we push via the
    URL.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: PHP会话的*SID版本*工作方式基本相同，除了cookie部分。这里的cookie被我们通过URL推送的SID值所取代。
- en: The session mechanism can be used for various things, some of which include
    user login mechanisms, storing minor data caches, parts of templates, and so on.
    Depending on the usage, this might bring up the question of *maximum session size*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 会话机制可用于各种事情，其中一些包括用户登录机制，存储小型数据缓存，模板的部分等。根据使用情况，这可能会引发“最大会话大小”的问题。
- en: By default, when a script executes, sessions are read from files into the memory. Therefore,
    the maximum size of a session file cannot exceed the `memory_limit` directive,
    which defaults to 128 megabytes. We could bypass this *default* session behavior
    by defining the custom session handlers. The `session_set_save_handler()` function
    allows us to register a custom session handler, which must comply to the `SessionHandlerInterface`
    interface. With custom session handlers, we are able to move away from the file
    mechanism to storing session data in the database. The added benefit of this is greater performance
    efficiency, as we are now able to create scalable PHP environments behind a load
    balancer where all application nodes connect to a central session server.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，脚本执行时，会将会话从文件读入内存。因此，会话文件的最大大小不能超过`memory_limit`指令，默认为128兆字节。我们可以通过定义自定义会话处理程序来绕过这种*默认*会话行为。`session_set_save_handler()`函数允许我们注册自定义会话处理程序，该处理程序必须符合`SessionHandlerInterface`接口。使用自定义会话处理程序，我们可以将会话数据存储在数据库中，从而实现更高的性能效率，因为我们现在可以在负载均衡器后面创建可扩展的PHP环境，其中所有应用程序节点连接到一个中央会话服务器。
- en: '**Redis** and **memcached** are two data stores that are quite popular among
    PHP developers. The **Magento 2** e-commerce platform supports both Redis and memcached for
    external session storage.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Redis和memcached是两种在PHP开发人员中非常流行的数据存储方式。Magento 2电子商务平台支持Redis和memcached用于外部会话存储。
- en: 'While the session storage plays a key role in terms of performance, there are
    a few configuration directives worth keeping an eye on:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 会话存储在性能方面起着关键作用，有一些配置指令值得关注：
- en: '`session.gc_probability`: This defaults to 1'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.gc_probability`: 这默认为1'
- en: '`session.gc_divisor`: This defaults to 100'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.gc_divisor`: 这默认为100'
- en: '`gc_maxlifetime`: This defaults to 1,440 seconds (24 minutes)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc_maxlifetime`: 这默认为1,440秒（24分钟）'
- en: The `gc_probability` and `gc_divisor` directives work in conjunction. Their
    ratio (*gc_probability/gc_divisor => 1/100 => 1%*) defines a probability of the
    garbage collector running on each `session_start()` call. Once the garbage collector
    is run, value of the `gc_maxlifetime` directive tells it if something should be
    seen as garbage and should be potentially cleaned up.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`gc_probability`和`gc_divisor`指令一起工作。它们的比率（*gc_probability/gc_divisor => 1/100
    => 1%*）定义了在每次`session_start()`调用时垃圾收集器运行的概率。一旦垃圾收集器运行，`gc_maxlifetime`指令的值告诉它是否应将某些内容视为垃圾并潜在地进行清理。'
- en: When it comes to high-performance sites, sessions can easily become a bottleneck.
    Thoughtful tuning and session storage selection can make just the right performance
    difference.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在高性能网站中，会话很容易成为瓶颈。深思熟虑的调整和会话存储选择可以带来恰到好处的性能差异。
- en: Output buffering
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出缓冲
- en: Output buffering is a PHP mechanism that controls the output of a script. Imagine
    we write down `echo 'test';` within our PHP script and do not see anything on
    screen. How is that possible? The answer is **o****utput buffering**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 输出缓冲是一种控制脚本输出的PHP机制。想象一下，我们在PHP脚本中写下`echo 'test';`，但屏幕上什么都看不到。这是怎么可能的？答案是**输出缓冲**。
- en: 'The following piece of code is a simple example of output buffering:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是输出缓冲的一个简单示例：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When executed within the CLI environment, we will first see `Chunk#1` come out
    after a few seconds, then a few seconds after, we will see `Chunk#3` come out,
    and, finally, a few more seconds after, we will see `Chunk#4` come out.  `Chunk#2`
    would never be output. This is quite a concept, given that we are used to having
    the `echo` construct outputting stuff just after it is called.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在CLI环境中执行时，我们首先会在几秒钟后看到`Chunk#1`，然后再过几秒钟，我们会看到`Chunk#3`，最后再过几秒钟，我们会看到`Chunk#4`。`Chunk#2`永远不会被输出。鉴于我们习惯于在调用后立即看到`echo`构造输出的内容，这是一个相当有意思的概念。
- en: 'There are several output buffering related functions, of which the following
    five are the most interesting ones:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个与输出缓冲相关的函数，其中以下五个是最有趣的：
- en: '`ob_start()`: This triggers a new buffer and creates stacked buffers if called
    after another *non-closed* buffer'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ob_start()`: 这会触发一个新的缓冲区，并在另一个*未关闭*缓冲区之后调用时创建堆叠的缓冲区'
- en: '`ob_end_flush()`: This outputs the topmost buffer and turns this output buffer
    off'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ob_end_flush()`: 这会输出顶部的缓冲区并关闭这个输出缓冲区'
- en: '`ob_end_clean()`: This cleans the output buffer and turns off output buffering'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ob_end_clean()`: 这会清除输出缓冲区并关闭输出缓冲'
- en: '`ob_get_contents()`: This returns the content of the output buffer'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ob_get_contents()`: 这会返回输出缓冲区的内容'
- en: '`ob_gzhandler()`: This is the callback function for use with `ob_start()`,
    to GZIP the output buffer'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ob_gzhandler()`: 这是与`ob_start()`一起使用的回调函数，用于对输出缓冲进行GZIP压缩'
- en: 'The following example demonstrates the stacked buffers:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了堆叠的缓冲区：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The entire output here is being withheld for roughly 8 seconds, after which
    all four `Chunk#...` strings are being output at once. This is because the `ob_end_flush()`
    function is the only one that sends the output to the console, whereas the `ob_end_flush()` function
    merely closes the buffer, passing it to the parent buffer present in the code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 整个输出在这里被暂停了大约8秒，之后所有四个`Chunk#...`字符串一次性输出。这是因为`ob_end_flush()`函数是唯一将输出发送到控制台的函数，而`ob_end_flush()`函数仅仅关闭缓冲区，并将其传递给代码中存在的父缓冲区。
- en: 'The use of the `ob_get_contents()` function can add further dynamic to output
    buffering, as shown in the following example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`ob_get_contents()`函数的使用可以为输出缓冲添加更多动态，如下例所示：'
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `ob_get_content()` function allows us to grab a string representation of
    content stored in the buffer. It is up to us to choose if we want to modify that
    content further, output it, or pass it on to other constructs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`ob_get_content()`函数允许我们获取缓冲区中存储的内容的字符串表示。我们可以选择是否要进一步修改该内容，输出它，或将其传递给其他结构。'
- en: How does all this apply to web pages? After all, we are interested in the performance
    of our scripts, mostly, in context of web pages. Without output buffering, HTML
    is sent to the browser in chunks as PHP progresses through our script. With output
    buffering, HTML is sent to the browser as one string at the end of our script.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些如何适用于网页？毕竟，我们主要关注我们脚本的性能，大多数情况下是在网页的上下文中。没有输出缓冲，HTML将随着PHP在脚本中的进行而以块的形式发送到浏览器。有了输出缓冲，HTML将在我们的脚本结束时作为一个字符串发送到浏览器。
- en: Keeping in mind that the `ob_start()` function accepts a callback function,
    we can use the callback function to further modify the output. This modification
    can be anything, either form of filtering or even compression.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`ob_start()`函数接受一个回调函数，我们可以使用回调函数进一步修改输出。这种修改可以是任何形式的过滤，甚至是压缩。
- en: 'The following example demonstrates the use of output filtering:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了输出过滤的使用：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Nowadays, however, we are not likely to write these kinds of structures ourselves,
    as the framework abstractions masquerade it for us.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，然而，我们不太可能自己编写这些结构，因为框架抽象为我们掩盖了它。
- en: Disabling debug messages
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用调试消息
- en: 'The Ubuntu Server is a popular, free, and open source Linux distribution that
    we can use to quickly set up a **LAMP** (**Linux, Apache, MySQL, PHP**) stack.
    The ease of installation and long-term support of Ubuntu Server makes it a popular
    choice among PHP developers. With a clean server installation, we can get the
    LAMP stack up and running just by executing the following commands:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu服务器是一种流行的、免费的、开源的Linux发行版，我们可以使用它快速设置**LAMP**（**Linux, Apache, MySQL,
    PHP**）堆栈。Ubuntu服务器的易安装性和长期支持使其成为PHP开发人员的热门选择。通过干净的服务器安装，我们可以通过执行以下命令快速启动和运行LAMP堆栈：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once these are done, visiting our external server IP address, we should see
    an Apache page, as shown in the following screenshot:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，访问我们的外部服务器IP地址，我们应该看到一个Apache页面，如下面的屏幕截图所示：
- en: '![](assets/65d05a45-40ba-469f-b2b8-2e510122490d.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/65d05a45-40ba-469f-b2b8-2e510122490d.jpg)'
- en: The HTML we are seeing in the browser originates from the `/var/www/html/index.html`
    file. After replacing `index.html` with `index.php`, we're good to play with the
    PHP code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在浏览器中看到的HTML源自`/var/www/html/index.html`文件。将`index.html`替换为`index.php`后，我们就可以使用PHP代码了。
- en: The reason for this Ubuntu Server-like introduction is to emphasize certain server defaults. Out
    of all configuration directives, we should never blindly accept defaults for *error
    logging* and *error displaying* directives without truly understanding them. Constant
    switching between development and production environments makes it way too easy
    to expose confidential information within the browser or miss logging the right
    error.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍Ubuntu服务器的原因是为了强调某些服务器默认值。在所有配置指令中，我们不应该盲目接受*错误记录*和*错误显示*指令的默认值，而不真正理解它们。在开发和生产环境之间不断切换使得在浏览器中暴露机密信息或错过记录正确错误变得太容易了。
- en: 'With that in mind, let''s assume we have the following broken `index.php` file
    on our freshly installed Ubuntu Server LAMP stack:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们假设我们在新安装的Ubuntu服务器LAMP堆栈上有以下损坏的`index.php`文件：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On trying to open this in the browser, Apache will send back `HTTP 500 Internal
    Server Error`, which, depending on the browser, might be visible to the end user,
    as shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在浏览器中打开时，Apache将返回`HTTP 500 Internal Server Error`，这取决于浏览器，可能会对最终用户可见，如下面的屏幕截图所示：
- en: '![](assets/4fab80d6-e7a8-43a9-b4e6-574dc6d457e6.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4fab80d6-e7a8-43a9-b4e6-574dc6d457e6.jpg)'
- en: 'Ideally, we would have our web server configured with a nicely styled generic
    error page, just to make it more user friendly. While the browser response might
    satisfy the end user, it certainly does not satisfy the developer in this case.
    The information returned does not indicate anything about the nature of the error,
    which makes it difficult to fix it. Luckily, for us, the default LAMP stack configuration
    in this case includes logging the error to a `/var/log/apache2/error.log` file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望我们的Web服务器配置了一个漂亮的通用错误页面，以使其更加用户友好。虽然浏览器的响应可能会满足最终用户，但在这种情况下，它确实不能满足开发人员。返回的信息并没有指示任何关于错误性质的信息，这使得难以修复。幸运的是，对于我们来说，在这种情况下默认的LAMP堆栈配置包括将错误记录到`/var/log/apache2/error.log`文件中：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'While this behavior is perfect for production, it is cumbersome for the development
    environment. When developing, we would really like our errors to show up in the
    browser, just to speed things up. PHP allows us to control the error reporting
    and logging behavior through several configuration directives, the following being
    the most important:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种行为对于生产环境来说是完美的，但对于开发环境来说却很麻烦。在开发过程中，我们真的希望我们的错误能够显示在浏览器中，以加快速度。PHP允许我们通过几个配置指令来控制错误报告和日志记录行为，以下是最重要的：
- en: '`error_reporting`: This is the error level we wish to monitor; we can use the
    pipe (`|`) operator to list several error-level constants. Its default value is `E_ALL
    & ~E_NOTICE & ~E_STRICT & ~E_DEPRECATED`.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error_reporting`：这是我们希望监视的错误级别；我们可以使用管道（`|`）运算符列出几个错误级别常量。它的默认值是`E_ALL & ~E_NOTICE
    & ~E_STRICT & ~E_DEPRECATED`。'
- en: '`display_errors`: This specifies if errors should be sent to the browser/CLI
    or be hidden from the user.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display_errors`：这指定是否将错误发送到浏览器/CLI或对用户隐藏。'
- en: '`error_log`: This is the file where we want to log PHP errors.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error_log`：这是我们想要记录PHP错误的文件。'
- en: '`log_errors`: This tells us if we should log the error to the `error_log` file.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log_errors`：这告诉我们是否应将错误记录到`error_log`文件中。'
- en: 'The available error-level constants are defined as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的错误级别常量定义如下：
- en: '`E_ERROR (1)`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_ERROR (1)`'
- en: '`E_WARNING (2)`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_WARNING (2)`'
- en: '`E_PARSE (4)`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_PARSE (4)`'
- en: '`E_NOTICE (8)`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_NOTICE (8)`'
- en: '`E_CORE_ERROR (16)`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_CORE_ERROR (16)`'
- en: '`E_CORE_WARNING (32)`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_CORE_WARNING (32)`'
- en: '`E_COMPILE_ERROR (64)`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_COMPILE_ERROR (64)`'
- en: '`E_COMPILE_WARNING (128)`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_COMPILE_WARNING (128)`'
- en: '`E_USER_ERROR (256)`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_USER_ERROR (256)`'
- en: '`E_USER_WARNING (512)`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_USER_WARNING (512)`'
- en: '`E_USER_NOTICE (1024)`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_USER_NOTICE (1024)`'
- en: '`E_STRICT (2048)`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_STRICT (2048)`'
- en: '`E_RECOVERABLE_ERROR (4096)`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_RECOVERABLE_ERROR (4096)`'
- en: '`E_DEPRECATED (8192)`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_DEPRECATED (8192)`'
- en: '`E_USER_DEPRECATED (16384)`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_USER_DEPRECATED (16384)`'
- en: '`E_ALL (32767)`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_ALL (32767)`'
- en: 'Using the `error_reporting()` and `ini_set()` functions, we can use some of
    these directives to configure logging and displaying during runtime:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`error_reporting()`和`ini_set()`函数，我们可以使用一些指令来配置日志和显示运行时的情况：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: careful using `ini_set()` for `display_errors` as it won't have any effect if
    the script has fatal errors, simply because runtime does not get executed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 小心使用`ini_set()`来设置`display_errors`，如果脚本有致命错误，它将不会产生任何效果，因为运行时不会被执行。
- en: Error displaying and error logging are two different mechanisms that work hand
    in hand with each other. While we are likely to benefit more from error displaying
    in development environments, error logging is the way to go for production environments.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 错误显示和错误日志记录是两种不同的机制，彼此协同工作。在开发环境中，我们可能更多地从错误显示中受益，而在生产环境中，错误日志记录是更好的选择。
- en: Zend OPcache
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zend OPcache
- en: One major downside of PHP is that it loads and parses the PHP script on every
    request. Written in plain text, the PHP code is first compiled to opcodes, then
    the opcodes are executed. While this performance impact might not be noticeable
    with small applications that have one or few scripts in total, it makes a big
    difference with larger platforms, such as Magento, Drupal, and so on.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的一个主要缺点是它在每个请求上加载和解析PHP脚本。PHP代码首先以纯文本形式编译为操作码，然后执行操作码。尽管这种性能影响在总共只有一个或几个脚本的小型应用中可能不会被注意到，但对于较大的平台（如Magento、Drupal等）来说，它会产生很大的影响。
- en: Starting from PHP 5.5, there is an out-of-the-box solution to this problem.
    The Zend OPcache extension addresses the repetitive compilation issue by storing
    the compiled opcodes in shared memory (RAM). Turning it on or off is simply a
    matter of changing the configuration directive.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从PHP 5.5开始，有一个开箱即用的解决方案。Zend OPcache扩展通过将编译后的操作码存储在共享内存（RAM）中来解决重复编译的问题。只需更改配置指令即可打开或关闭它。
- en: 'There are quite a few configuration directives, a few of which will get us
    started:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多配置指令，其中一些可以帮助我们入门：
- en: '`opcache.enable`: This defaults to 1 and is changeable via `PHP_INI_ALL`.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache.enable`：默认为1，可通过`PHP_INI_ALL`更改。'
- en: '`opcache.enable_cli`: This defaults to 0 and is changeable via `PHP_INI_SYSTEM`.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache.enable_cli`：默认为0，可通过`PHP_INI_SYSTEM`更改。'
- en: '`opcache.memory_consumption`: This defaults to 64 and is changeable via `PHP_INI_SYSTEM`,
    which defines the size of shared memory used by OPcache.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache.memory_consumption`：默认为64，可通过`PHP_INI_SYSTEM`更改，定义了OPcache使用的共享内存大小。'
- en: '`opcache.max_accelerated_files`: This defaults to 2000 and is changeable via
    `PHP_INI_SYSTEM`, which defines the maximum number of keys/scripts in the OPcache
    hash table. Its maximum value is 1000000.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache.max_accelerated_files`：默认为2000，可通过`PHP_INI_SYSTEM`更改，定义了OPcache哈希表中键/脚本的最大数量。其最大值为1000000。'
- en: '`opcache.max_wasted_percentage`: This defaults to 5 and is changeable via `PHP_INI_SYSTEM`,
    which defines the maximum percentage of wasted memory allowed before scheduling
    a restart.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache.max_wasted_percentage`：默认为5，可通过`PHP_INI_SYSTEM`更改，定义了允许浪费内存的最大百分比，然后安排重新启动。'
- en: While `opcache.enable` is flagged as `PHP_INI_ALL`, using `ini_set()` to enable
    it at runtime won't work. Only disabling it with `ini_set()` will work.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`opcache.enable`标记为`PHP_INI_ALL`，但在运行时使用`ini_set()`启用它是行不通的。只有使用`ini_set()`来禁用它才有效。
- en: 'Although fully automated, Zend OPcache also provides a few functions for us
    to use:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管完全自动化，Zend OPcache还为我们提供了一些函数：
- en: '`opcache_compile_file()`: This compiles and caches a script without executing
    it'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache_compile_file()`：这会编译并缓存一个脚本而不执行它'
- en: '`opcache_get_configuration()`: This fetches the OPcache configuration information'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache_get_configuration()`：这会获取OPcache配置信息'
- en: '`opcache_get_status()`: This fetches the OPcache information'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache_get_status()`：这会获取OPcache信息'
- en: '`opcache_invalidate()`: This invalidates OPcache'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache_invalidate()`：这会使OPcache失效'
- en: '`opcache_is_script_cached()`: This tells us if the script is cached via OPcache'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache_is_script_cached()`：这告诉我们脚本是否通过OPcache缓存'
- en: '`opcache_reset()`: This resets the OPcache cache'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opcache_reset()`：这会重置OPcache缓存'
- en: While it is unlikely we will use these methods on our own, they do come in handy
    for utility tools that deal with OPcache for us.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不太可能自己使用这些方法，但它们对于处理OPcache的实用工具非常有用。
- en: The opcache-gui tool shows OPcache statistics, settings, and cached files whilst providing
    a real-time update. This tool is available for download at [https://github.com/amnuts/opcache-gui](https://github.com/amnuts/opcache-gui).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: opcache-gui工具显示OPcache统计信息、设置和缓存文件，并提供实时更新。该工具可在[https://github.com/amnuts/opcache-gui](https://github.com/amnuts/opcache-gui)下载。
- en: One thing to be wary about with OPcache is its potential *cache slam* problem. Using
    the `memory_consumption`, `max_accelerated_files`, and `max_wasted_percentage`
    configuration directives, OPcache determines when it is time to flush the cache.
    When this happens, servers with large amounts of traffic are likely to experience
    a cache slam problem, with lots of requests simultaneously generating the same
    cache entries. Therefore, we should try to avoid frequent cache flushing. To do
    so, we can use the cache monitoring tool and tune the three configuration directives to
    suit our application size.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一件事是OPcache潜在的*缓存冲击*问题。通过`memory_consumption`、`max_accelerated_files`和`max_wasted_percentage`配置指令，OPcache确定何时需要刷新缓存。当这种情况发生时，具有大量流量的服务器可能会遇到缓存冲击问题，大量请求同时生成相同的缓存条目。因此，我们应该尽量避免频繁的缓存刷新。为此，我们可以使用缓存监控工具，并调整这三个配置指令以适应我们的应用程序大小。
- en: Concurrency
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发性
- en: While concurrency is a topic applicable to multiple layers of stack, there are
    a few configuration directives around web servers that every developer should
    be familiar with. Concurrency refers to handling multiple connections inside a
    web server. The two most popular web servers for PHP, Apache, and Nginx, both
    allow some basic configuration for handling multiple connections.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 并发性是一个适用于多层堆栈的主题，有一些关于Web服务器的配置指令，每个开发人员都应该熟悉。并发性指的是在Web服务器内处理多个连接。对于PHP来说，两个最受欢迎的Web服务器，Apache和Nginx，都允许一些基本配置来处理多个连接。
- en: While there are plenty of debates as to which server is faster, Apache with
    the MPM event module is pretty much on par with the Nginx performance.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有很多关于哪个服务器更快的争论，但带有MPM事件模块的Apache与Nginx的性能基本相当。
- en: 'The following directives dictate the Apache MPM event concurrency, and are
    therefore worth keeping an eye on:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指令规定了Apache MPM事件并发性，因此值得密切关注：
- en: '`ThreadsPerChild`: This is the number of threads created by each child process'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadsPerChild`：这是每个子进程创建的线程数'
- en: '`ServerLimit`: This is the limit on the configurable number of processes'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerLimit`：这是可配置的进程数量限制'
- en: '`MaxRequestWorkers`: This is the maximum number of connections to be processed
    simultaneously'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaxRequestWorkers`：这是同时处理的最大连接数'
- en: '`AsyncRequestWorkerFactor`: This is the limit on concurrent connections per
    process'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncRequestWorkerFactor`：这是每个进程的并发连接限制'
- en: 'An absolute maximum numbers of possible concurrent connections can be calculated
    using the following formula:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下公式计算可能的最大并发连接数：
- en: '*max_connections = (AsyncRequestWorkerFactor + 1) * MaxRequestWorkers*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最大连接数=（AsyncRequestWorkerFactor + 1）* MaxRequestWorkers
- en: The formula is quite simple; however, changing `AsyncRequestWorkerFactor` is
    not just a matter of punching in a higher configuration value. We would need to
    have a solid knowledge about the traffic hitting the web server, which implies
    extensive testing and data gathering.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式非常简单；但是，改变`AsyncRequestWorkerFactor`不仅仅是输入更高的配置值。我们需要对击中Web服务器的流量有扎实的了解，这意味着进行广泛的测试和数据收集。
- en: 'The following directives dictate the Nginx concurrency, and are therefore worth
    keeping an eye on:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指令规定了Nginx的并发性，因此值得密切关注：
- en: '`worker_processes`: This is the number of worker processes; it defaults to
    1'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`worker_processes`：这是工作进程的数量；默认为1'
- en: '`worker_connections`: This is the maximum number of simultaneous connections
    that can be opened by a worker process; it defaults to 512'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`worker_connections`：这是工作进程可以打开的最大同时连接数；默认为512'
- en: 'The ideal total number of users Nginx can serve comes down to the following
    formula:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx可以提供服务的理想总用户数可以归结为以下公式：
- en: '*max_connections = worker_processes * worker_connections*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最大连接数=工作进程*工作连接数
- en: Though we have barely scratched the surface of web server concurrency and the
    overall configuration directives for these two web servers, the preceding information
    should serve us as a starting point. While developers don't usually tune web servers,
    they should know when to flag misconfiguration that might impact their PHP application
    performance.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们只是初步了解了Web服务器并发性和这两个Web服务器的总体配置指令，但上述信息应该作为我们的起点。虽然开发人员通常不会调整Web服务器，但他们应该知道何时标记可能影响其PHP应用程序性能的错误配置。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Throughout this chapter, we have addressed some aspects of the PHP performance
    optimization. While these merely scratch the surface of the overall performance
    topic, they outline the most common areas every PHP developer should be deeply
    familiar with. The broad range of configuration directives allows us to tune application
    behavior that often works in tandem with the web server itself. The backbone of
    optimal performance, however, lies in the thoughtful use of resources across the
    stack, as we got to observe through the simple SQL query example.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经讨论了PHP性能优化的一些方面。虽然这些只是涉及整体性能主题的表面，但它们概述了每个PHP开发人员都应该深入了解的最常见领域。广泛的配置指令范围允许我们调整应用程序行为，通常与Web服务器本身协同工作。然而，最佳性能的支柱在于在整个堆栈中谨慎使用资源，正如我们通过简单的SQL查询示例所观察到的。
- en: Moving forward, we will look into serverless architecture, an emerging abstraction
    of the standard development environment.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究无服务器架构，这是标准开发环境的新兴抽象。
