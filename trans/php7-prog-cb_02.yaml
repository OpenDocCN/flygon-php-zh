- en: Chapter 2. Using PHP 7 High Performance Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。使用PHP 7高性能特性
- en: 'In this chapter we will discuss and understand the syntax differences between
    PHP 5 and PHP 7, featuring the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论并了解PHP 5和PHP 7之间的语法差异，包括以下内容：
- en: Understanding the abstract syntax tree
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解抽象语法树
- en: Understanding differences in parsing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解解析中的差异
- en: Understanding differences in `foreach()` handling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`foreach()`处理中的差异
- en: Improving performance using PHP 7 enhancements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PHP 7增强功能提高性能
- en: Iterating through a massive file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历大型文件
- en: Uploading a spreadsheet into a database
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将电子表格上传到数据库
- en: Recursive directory iterator
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归目录迭代器
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter we will move directly into PHP 7, presenting recipes that take
    advantage of new high performance features. First, however, we will present a
    series of smaller recipes that serve to illustrate the differences in how PHP
    7 handles parameter parsing, syntax, a `foreach()` loop, and other enhancements.
    Before we go into depth in this chapter, let's discuss some basic differences
    between PHP 5 and PHP 7.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将直接进入PHP 7，介绍利用新的高性能特性的配方。然而，我们将首先介绍一系列较小的配方，以说明PHP 7处理参数解析、语法、`foreach()`循环和其他增强功能的差异。在深入探讨本章内容之前，让我们讨论一些PHP
    5和PHP 7之间的基本差异。
- en: PHP 7 introduced a new layer referred to as the **Abstract Syntax Tree** (**AST**),
    which effectively decouples the parsing process from the pseudo-compile process.
    Although the new layer has little or no impact on performance, it gives the language
    a new uniformity of syntax, which was not possible previously.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7引入了一个新的层，称为**抽象语法树**（**AST**），它有效地将解析过程与伪编译过程分离。尽管新层对性能几乎没有影响，但它赋予了语言一种新的语法统一性，这在以前是不可能的。
- en: Another benefit of AST is the process of *dereferencing*. Dereferencing, simply
    put, refers to the ability to immediately acquire a property from, or run a method
    of, an object, immediately access an array element, and immediately execute a
    callback. In PHP 5 such support was inconsistent and incomplete. To execute a
    callback, for example, often you would first need to assign the callback or anonymous
    function to a variable, and then execute it. In PHP 7 you can execute it immediately.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: AST的另一个好处是*取消引用*的过程。取消引用简单地指的是立即从对象中获取属性或运行方法，立即访问数组元素，并立即执行回调的能力。在PHP 5中，这种支持是不一致和不完整的。例如，要执行回调，通常需要先将回调或匿名函数赋值给一个变量，然后执行它。在PHP
    7中，你可以立即执行它。
- en: Understanding the abstract syntax tree
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解抽象语法树
- en: As a developer, it might be of interest for you to be free from certain syntax
    restrictions imposed in PHP 5 and earlier. Aside from the uniformity of the syntax
    mentioned previously, where you'll see the most improvement in syntax is the ability
    to call any return value, which is **callable** by simply appending an extra set
    of parentheses. Also, you'll be able to directly access any array element when
    the return value is an array.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，你可能会对摆脱PHP 5及更早版本中施加的某些语法限制感兴趣。除了之前提到的语法的统一性外，你将看到语法最大的改进是能够调用任何返回值，只需在后面添加一组额外的括号。此外，当返回值是数组时，你将能够直接访问任何数组元素。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Any function or method that returns a callback can be immediately executed
    by simply appending parentheses `()` (with or without parameters). An element
    can be immediately dereferenced from any function or method that returns an array
    by simply indicating the element using square brackets `[];`. In the short (but
    trivial) example shown next, the function `test()` returns an array. The array
    contains six anonymous functions. `$a` has a value of `$t`. `$$a` is interpreted
    as `$test`:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何返回回调的函数或方法都可以通过简单地添加括号`()`（带或不带参数）立即执行。任何返回数组的函数或方法都可以通过使用方括号`[]`指示元素来立即取消引用。在下面显示的简短（但琐碎）示例中，函数`test()`返回一个数组。数组包含六个匿名函数。`$a`的值为`$t`。`$$a`被解释为`$test`：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'AST allows us to issue the `echo $$a()[1]()[2](100)` command. This is parsed
    left-to-right, which executes as follows:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AST允许我们发出`echo $$a()[1]()[2](100)`命令。这是从左到右解析的，执行如下：
- en: '`$$a()` interprets as `test()`, which returns an array'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$$a()`被解释为`test()`，返回一个数组'
- en: '`[1]` dereferences array element `1`, which returns a callback'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[1]`取消引用数组元素`1`，返回一个回调'
- en: '`()` executes this callback, which returns an array of two elements'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`()`执行此回调，返回一个包含两个元素的数组'
- en: '`[2]` dereferences array element `2`, which returns a callback'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[2]`取消引用数组元素`2`，返回一个回调'
- en: '`(100)` executes this callback, supplying a value of `100`, which returns `Level
    1/2:101`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(100)`执行此回调，提供值`100`，返回`Level 1/2:101`'
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Such a statement is not possible in PHP 5: a parse error would be returned.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 5中不可能有这样的语句：会返回解析错误。
- en: 'The following is a more substantive example that takes advantage of AST syntax
    to define a data filtering and validating class. First of all, we define the `Application\Web\Securityclass`.
    In the constructor, we build and define two arrays. The first array consists of
    filter callbacks. The second array has validation callbacks:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是一个更加实质性的例子，利用AST语法来定义数据过滤和验证类。首先，我们定义`Application\Web\Securityclass`。在构造函数中，我们构建并定义了两个数组。第一个数组由过滤回调组成。第二个数组有验证回调：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We want to be able to call this functionality in a *developer-friendly* manner.
    Thus, if we want to filter digits, then it would be ideal to run a command such
    as this:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望能以*开发人员友好*的方式调用此功能。因此，如果我们想要过滤数字，那么运行这样的命令将是理想的：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To accomplish this we define the magic method `__call()`, which gives us access
    to non-existent methods:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们定义了魔术方法`__call()`，它使我们能够访问不存在的方法：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We use `preg_match()` to match the `$method` param against `filter` or `validate`.
    The second sub-match will then be converted into an array key in either `$this->filter`
    or `$this->validate`. If both sub-patterns produce a sub-match, we assign the
    first sub-match to `$prefix`, and the second sub-match `$function`. These end
    up as variable parameters when executing the appropriate callback.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`preg_match()`来匹配`$method`参数与`filter`或`validate`。然后，第二个子匹配将被转换为`$this->filter`或`$this->validate`中的数组键。如果两个子模式都产生子匹配，我们将第一个子匹配分配给`$prefix`，将第二个子匹配分配给`$function`。这些最终成为执行适当回调时的变量参数。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Don''t go too crazy with this stuff!**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要对这些东西太疯狂！**'
- en: As you revel in your new found freedom of expression, made possible by AST,
    be sure to keep in mind that the code you end up writing could, in the long run,
    be extremely cryptic. This will ultimately cause long-term maintenance problems.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当您沉浸在AST所带来的新的表达自由中时，请务必记住，您最终编写的代码可能会变得极其晦涩。这最终将导致长期的维护问题。
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First of all, we create a sample file, `chap_02_web_filtering_ast_example.php,`
    to take advantage of the autoloading class defined in [Chapter 1](ch01.html "Chapter 1. Building
    a Foundation"), *Building the Foundation*, to obtain an instance of `Application\Web\Security`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个示例文件，`chap_02_web_filtering_ast_example.php`，以利用[第1章](ch01.html "第1章。建立基础")中定义的自动加载类，*构建基础*，以获得`Application\Web\Security`的实例：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we define a block of test data:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个测试数据块：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we call each filter and validator for each item of test data:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为每个测试数据项调用每个过滤器和验证器：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the output of some input strings:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些输入字符串的输出：
- en: '![How it works...](graphics/B05314_02_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_02_01.jpg)'
- en: See also
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information on AST, please consult the RFC that addresses the **Abstract
    Syntax Tree**, which can be viewed at [https://wiki.php.net/rfc/abstract_syntax_tree](https://wiki.php.net/rfc/abstract_syntax_tree).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有关AST的更多信息，请参阅涉及**抽象语法树**的RFC，可以在[https://wiki.php.net/rfc/abstract_syntax_tree](https://wiki.php.net/rfc/abstract_syntax_tree)上查看。
- en: Understanding differences in parsing
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解解析的差异
- en: In PHP 5, expressions on the right side of an assignment operation were parsed
    *right-to-left*. In PHP 7, parsing is consistently *left-to-right*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 5中，赋值操作的右侧表达式是从*右到左*解析的。在PHP 7中，解析是一致的*从左到右*。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'A variable-variable is a way of indirectly referencing a value. In the following
    example, first `$$foo` is interpreted as `${$bar}`. The final return value is
    thus the value of `$bar` instead of the direct value of `$foo` (which would be
    `bar`):'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量变量是间接引用值的一种方式。在下面的例子中，首先`$$foo`被解释为`${$bar}`。因此最终的返回值是`$bar`的值，而不是`$foo`的直接值（应该是`bar`）：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the next example we have a variable-variable `$$foo`, which references a
    multi-dimensional array with a `bar key` and a `baz sub-key`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们有一个变量变量`$$foo`，它引用一个具有`bar键`和`baz子键`的多维数组：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In PHP 5, parsing occurs right-to-left, which means the PHP engine would be
    looking for an `$foo array`, with a `bar key` and a `baz`. sub-key The return
    value of the element would then be interpreted to obtain the final value `${$foo['bar']['baz']}`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PHP 5中，解析是从右到左进行的，这意味着PHP引擎将寻找一个`$foo数组`，其中包含一个`bar键`和一个`baz子键`。然后，元素的返回值将被解释以获得最终值`${$foo['bar']['baz']}`。
- en: In PHP 7, however, parsing is consistently left-to-right, which means that `$foo`
    is interpreted first `($$foo)['bar']['baz']`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，在PHP 7中，解析是一致的，从左到右进行，这意味着首先解释`($$foo)['bar']['baz']`。
- en: 'In the next example you can see that `$foo->$bar[''bada'']` is interpreted
    quite differently in PHP 5, compared with PHP 7\. In the following example, PHP
    5 would first interpret `$bar[''bada'']`, and reference this return value against
    a `$foo object instance`. In PHP 7, on the other hand, parsing is consistently
    left-to-right, which means that `$foo->$bar` is interpreted first, and expects
    an array with a `bada element`. You will also note, incidentally, that this example
    uses the PHP 7 *anonymous class* feature:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个示例中，您可以看到在PHP 5中`$foo->$bar['bada']`的解释与PHP 7相比有很大不同。在下面的例子中，PHP 5首先会解释`$bar['bada']`，并将此返回值与`$foo对象实例`进行引用。另一方面，在PHP
    7中，解析是一致的，从左到右进行，这意味着首先解释`$foo->$bar`，并期望一个具有`bada元素`的数组。顺便说一句，这个例子还使用了PHP 7的*匿名类*特性：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The last example is the same as the one immediately above, except that the
    return value is expected to be a callback, which is then immediately executed
    as follows:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个示例与上面的示例相同，只是期望的返回值是一个回调，然后立即执行如下：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Place the code examples illustrated in 1 and 2 into a single PHP file that
    you can call `chap_02_understanding_diffs_in_parsing.php`. Execute the script
    first using PHP 5, and you will notice that a series of errors will result, as
    follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将1和2中的代码示例放入一个单独的PHP文件中，您可以将其命名为`chap_02_understanding_diffs_in_parsing.php`。首先使用PHP
    5执行该脚本，您将注意到会产生一系列错误，如下所示：
- en: '![How it works...](graphics/B05314_02_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_02_05.jpg)'
- en: 'The reason for the errors is that PHP 5 parses inconsistently, and arrives
    at the wrong conclusion regarding the state of the variable variables requested
    (as previously mentioned). Now you can go ahead and add the remaining examples,
    as shown in steps 5 and 6\. If you then run this script in PHP 7, the results
    described will appear, as shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的原因是PHP 5解析不一致，并且对所请求的变量变量的状态得出了错误的结论（如前所述）。现在，您可以继续添加剩余的示例，如步骤5和6所示。然后，如果您在PHP
    7中运行此脚本，将会出现所描述的结果，如下所示：
- en: '![How it works...](graphics/B05314_02_06.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_02_06.jpg)'
- en: See also
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information on parsing, please consult the RFC, which addresses **Uniform**
    **Variable Syntax**, and can be viewed at [https://wiki.php.net/rfc/uniform_variable_syntax](https://wiki.php.net/rfc/uniform_variable_syntax).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有关解析的更多信息，请参阅涉及**统一** **变量语法**的RFC，可以在[https://wiki.php.net/rfc/uniform_variable_syntax](https://wiki.php.net/rfc/uniform_variable_syntax)上查看。
- en: Understanding differences in foreach() handling
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解foreach（）处理中的差异
- en: In certain relatively obscure circumstances, the behavior of code inside a `foreach()`
    loop will vary between PHP 5 and PHP 7\. First of all, there have been massive
    internal improvements, which means that in terms of sheer speed, processing inside
    the `foreach()` loop will be much faster running under PHP 7, compared with PHP
    5\. Problems that are noticed in PHP 5 include the use of `current()`, and `unset()`
    on the array inside the `foreach()` loop. Other problems have to do with passing
    values by reference while manipulating the array itself.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些相对晦涩的情况下，`foreach（）`循环内部代码的行为在PHP 5和PHP 7之间会有所不同。首先，有了大量的内部改进，这意味着在`foreach（）`循环内部的处理在PHP
    7下的速度会比在PHP 5下快得多。在PHP 5中注意到的问题包括在`foreach（）`循环内部使用`current（）`和`unset（）`对数组的操作。其他问题涉及通过引用传递值同时操作数组本身。
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Consider the following block of code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下代码块：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In both PHP 5 and 7, the output would appear as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PHP 5和7中，输出如下：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you add an assignment before the loop, however, the behavior changes:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，在循环之前添加一个赋值，行为会改变：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Compare the output of PHP 5 and 7:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较PHP 5和7的输出：
- en: '| PHP 5 | PHP 7 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| PHP 5 | PHP 7 |'
- en: '| --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **1****3** | **1****2****3** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **1****3** | **1****2****3** |'
- en: 'Working with functions that reference the internal array pointer also caused
    inconsistent behavior in PHP 5\. Take the following code example:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理引用内部数组指针的函数在PHP 5中也导致不一致的行为。看下面的代码示例：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Every array has an internal pointer to its `current` element starting from `1`,
    `current()` returns the current element in an array.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组都有一个指向其“当前”元素的内部指针，从“1”开始，“current（）”返回数组中的当前元素。
- en: 'Notice that the output running in PHP 7 is normalized and consistent:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，在PHP 7中运行的输出是规范化和一致的：
- en: '| PHP 5 | PHP 7 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| PHP 5 | PHP 7 |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **1 - 2****2 - 3****3 - 0** | **1 - 1****2 - 1****3 - 1** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **1 - 2****2 - 3****3 - 0** | **1 - 1****2 - 1****3 - 1** |'
- en: 'Adding a new element inside the `foreach()` loop, once the array iteration
    by reference is complete, is also problematic in PHP 5\. This behavior has been
    made consistent in PHP 7\. The following code example demonstrates this:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foreach（）`循环中添加一个新元素，一旦引用数组迭代完成，也在PHP 5中存在问题。这种行为在PHP 7中已经变得一致。以下代码示例演示了这一点：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will observe the following output:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将观察到以下输出：
- en: '| PHP 5 | PHP 7 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| PHP 5 | PHP 7 |'
- en: '| --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **1 -** | **1 -****2-** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **1 -** | **1 -****2-** |'
- en: Another example of bad PHP 5 behavior addressed in PHP 7, during array iteration
    by reference, is the use of functions that modify the array, such as `array_push()`,
    `array_pop()`, `array_shift()`, and `array_unshift()`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PHP 5中解决的PHP 7中的另一个不良行为示例是通过引用遍历数组时，使用修改数组的函数，如`array_push（）`，`array_pop（）`，`array_shift（）`和`array_unshift（）`。
- en: 'Have a look at this example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个例子：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You will observe the following output:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将观察到以下输出：
- en: '| PHP 5 | PHP 7 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| PHP 5 | PHP 7 |'
- en: '| --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **1****2****1****1** | **1****2** |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **1****2****1****1** | **1****2** |'
- en: 'Finally, we have a case where you are iterating through an array by reference,
    with a nested `foreach()` loop, which itself iterates on the same array by reference.
    In PHP 5 this construct simply did not work. In PHP 7 this has been fixed. The
    following block of code demonstrates this behavior:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有一个情况，您正在通过引用遍历数组，并且有一个嵌套的`foreach（）`循环，它本身也通过引用在相同的数组上进行迭代。在PHP 5中，这种结构根本不起作用。在PHP
    7中，这个问题已经解决。以下代码块演示了这种行为：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And here is the output:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '| PHP 5 | PHP 7 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| PHP 5 | PHP 7 |'
- en: '| --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **0 - 0****0 - 1****0 - 3** | **0 - 0****0 - 1****0 - 3****3 - 0****3 -3**
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **0 - 0****0 - 1****0 - 3** | **0 - 0****0 - 1****0 - 3****3 - 0****3 -3**
    |'
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Add these code examples to a single PHP file, `chap_02_foreach.php`. Run the
    script under PHP 5 from the command line. The expected output is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些代码示例添加到一个名为`chap_02_foreach.php`的单个PHP文件中。从命令行下在PHP 5下运行脚本。预期输出如下：
- en: '![How it works...](graphics/B05314_02_07.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_02_07.jpg)'
- en: 'Run the same script under PHP 7 and notice the difference:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7下运行相同的脚本并注意差异：
- en: '![How it works...](graphics/B05314_02_08.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_02_08.jpg)'
- en: See also
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information, consult the RFC addressing this issue, which was accepted.
    A write-up on this RFC can be found at: [https://wiki.php.net/rfc/php7_foreach](https://wiki.php.net/rfc/php7_foreach).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅解决此问题的RFC，该RFC已被接受。可以在以下网址找到有关此RFC的介绍：[https://wiki.php.net/rfc/php7_foreach](https://wiki.php.net/rfc/php7_foreach)。
- en: Improving performance using PHP 7 enhancements
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP 7增强性能
- en: One trend that developers are taking advantage of is the use of **anonymous
    functions**. One classic problem, when dealing with anonymous functions, is to
    write them in such a way that any object can be bound to `$this` and the function
    will still work. The approach used in PHP 5 code is to use `bindTo()`. In PHP
    7, a new method, `call()`, was added, which offers similar functionality, but
    vastly improved performance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员正在利用的一个趋势是使用**匿名函数**。处理匿名函数时的一个经典问题是以这样的方式编写它们，以便任何对象都可以绑定到`$this`，并且函数仍然可以工作。PHP
    5代码中使用的方法是使用`bindTo（）`。在PHP 7中，添加了一个新方法`call（）`，它提供了类似的功能，但性能大大提高。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To take advantage of `call()`, execute an anonymous function in a lengthy loop.
    In this example, we will demonstrate an anonymous function, that scans through
    a log file, identifying IP addresses sorted by how frequently they appear:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用`call（）`，在一个漫长的循环中执行一个匿名函数。在这个例子中，我们将演示一个匿名函数，它通过扫描日志文件，识别按出现频率排序的IP地址：
- en: 'First, we define a `Application\Web\Access class`. In the constructor, we accept
    a filename as an argument. The log file is opened as an `SplFileObject` and assigned
    to `$this->log`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个`Application\Web\Access`类。在构造函数中，我们接受一个文件名作为参数。日志文件被打开为`SplFileObject`并分配给`$this->log`：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we define a generator that iterates through the file, line by line:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个遍历文件的生成器，逐行进行迭代：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we define a method that looks for, and extracts as a sub-match, an
    IP address:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义一个方法，查找并提取IP地址作为子匹配：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First of all, we define a calling program, `chap_02_performance_using_php7_enchancement_call.php`,
    that takes advantage of the autoloading class defined in [Chapter 1](ch01.html
    "Chapter 1. Building a Foundation") , *Building a Foundation,* to obtain an instance
    of `Application\Web\Access`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个调用程序`chap_02_performance_using_php7_enchancement_call.php`，利用[第1章](ch01.html
    "第1章。建立基础")中定义的自动加载类，*建立基础*，来获取`Application\Web\Access`的实例：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next we define the anonymous function, which processes one line in the log
    file. If an IP address is detected, it becomes a key in the `$frequency array`,
    and the current value for this key is incremented:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们定义匿名函数，它处理日志文件中的一行。如果检测到IP地址，它将成为`$frequency数组`中的一个键，并且增加这个键的当前值。
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We then loop through the iteration of lines in each log file found, processing
    IP addresses:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们循环遍历每个找到的日志文件中的行迭代，处理IP地址：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can actually do the same thing in PHP 5\. Two lines of code are required,
    however:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上你也可以在PHP 5中做同样的事情。但是需要两行代码：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Performance is 20% to 50% slower than using `call()` in PHP 7.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中，使用`call()`的性能比较使用`call()`慢20%到50%。
- en: 'Finally, we reverse-sort the array, but maintain the keys. The output is produced
    in a simple `foreach()` loop:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们对数组进行逆向排序，但保持键。输出是在一个简单的`foreach()`循环中产生的：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output will vary depending on which `access.log` you process. Here is a
    sample:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将根据你处理的`access.log`文件而有所不同。这里是一个示例：
- en: '![How it works...](graphics/B05314_02_02.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_02_02.jpg)'
- en: There's more...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Many of the PHP 7 performance improvements have nothing to do with new features
    and functions. Rather, they take the form of internal improvements, which are
    *invisible* until you start running your programs. Here is a short list of improvements
    that fall into this category:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 许多PHP 7性能改进与新功能和函数无关。相反，它们采取了内部改进的形式，直到你开始运行程序之前都是*不可见*的。以下是属于这一类别的改进的简短列表：
- en: '| Feature | More info: | Notes |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 更多信息： | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Fast parameter parsing | [https://wiki.php.net/rfc/fast_zpp](https://wiki.php.net/rfc/fast_zpp)
    | In PHP 5, parameters provided to functions have to be parsed for every single
    function call. The parameters were passed in as a string, and parsed in a manner
    similar to the `scanf()` function. In PHP 7 this process has been optimized and
    made much more efficient, resulting in a significant performance improvement.
    The improvement is difficult to measure, but seems to be in the region of 6%.
    |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: 快速参数解析 | [https://wiki.php.net/rfc/fast_zpp](https://wiki.php.net/rfc/fast_zpp)
    | 在PHP 5中，提供给函数的参数必须为每个函数调用进行解析。参数以字符串形式传递，并以类似于`scanf()`函数的方式进行解析。在PHP 7中，这个过程已经被优化，变得更加高效，导致了显著的性能提升。这种改进很难衡量，但似乎在6%左右。
- en: '| PHP NG | [https://wiki.php.net/rfc/phpng](https://wiki.php.net/rfc/phpng)
    | The PHP **NG** (**Next Generation**) initiative represents a rewrite of most
    of the PHP language. It retains existing functionality, but involves any and all
    time-savings and efficiency measures imaginable. Data structures have been compacted,
    and memory is used more efficiently. Just one change, which affects array handling,
    for example, has resulted in a significant performance increase, while at the
    same time greatly reducing memory usage. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: PHP NG | [https://wiki.php.net/rfc/phpng](https://wiki.php.net/rfc/phpng) |
    PHP **NG**（**Next Generation**）计划代表了对大部分PHP语言的重写。它保留了现有功能，但涉及了所有可能的时间节省和效率措施。数据结构已经被压缩，内存利用更加高效。例如，只有一个改变影响了数组处理，导致了显著的性能提升，同时大大减少了内存使用。
- en: '| Removing dead weight | [https://wiki.php.net/rfc/removal_of_dead_sapis_and_exts](https://wiki.php.net/rfc/removal_of_dead_sapis_and_exts)
    | There were approximately two dozen extensions that fell into one of these categories:
    deprecated, no longer maintained, unmaintained dependencies, or not ported to
    PHP 7\. A vote by the group of core developers determined to remove about 2/3
    or the extensions on the "short list". This results in reduced overhead and faster
    overall future development of the PHP language. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 去除死板 | [https://wiki.php.net/rfc/removal_of_dead_sapis_and_exts](https://wiki.php.net/rfc/removal_of_dead_sapis_and_exts)
    | 大约有二十多个扩展属于以下类别之一：已弃用、不再维护、未维护的依赖项，或者未移植到PHP 7。核心开发人员组的投票决定移除“短列表”上约2/3的扩展。这将减少开销，并加快PHP语言的未来整体发展速度。'
- en: Iterating through a massive file
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代处理大文件
- en: Functions such as `file_get_contents()` and `file()` are quick and easy to use
    however, owing to memory limitations, they quickly cause problems when dealing
    with massive files. The default setting for the `php.ini` `memory_limit` setting
    is 128 megabytes. Accordingly, any file larger than this will not be loaded.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`file_get_contents()`和`file()`之类的函数使用起来快速简单，但由于内存限制，它们在处理大文件时很快会出现问题。`php.ini`中`memory_limit`设置的默认值为128兆字节。因此，任何大于这个值的文件都不会被加载。
- en: Another consideration when parsing through massive files is how quickly does
    your function or class method produce output? When producing user output, for
    example, although it might at first glance seem better to accumulate output in
    an array. You would then output it all at once for improved efficiency. Unfortunately,
    this might have an adverse impact on the user experience. It might be better to
    create a **generator**, and use the `yield keyword` to produce immediate results.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析大文件时的另一个考虑是，你的函数或类方法产生输出的速度有多快？例如，在产生用户输出时，尽管一开始累积输出到一个数组中似乎更好。然后一次性输出以提高效率。不幸的是，这可能会对用户体验产生不利影响。也许更好的方法是创建一个**生成器**，并使用`yield关键字`产生即时结果。
- en: How to do it...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: As mentioned before, the `file*` functions (that is, `file_get_contents()`),
    are not suitable for large files. The simple reason is that these functions, at
    one point, have the entire contents of the file represented in memory. Accordingly,
    the focus of this recipe will be on the `f*` functions (that is, `fopen()`).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`file*`函数（即`file_get_contents()`）不适用于大文件。简单的原因是这些函数在某一点上会将整个文件内容表示在内存中。因此，本示例的重点将放在`f*`函数（即`fopen()`）上。
- en: 'In a slight twist, however, instead of using the `f*` functions directly, instead
    we will use the `SplFileObject` class, which is included in the **SPL** (**Standard
    PHP Library**):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有点不同的是，我们不直接使用`f*`函数，而是使用**SPL**（**标准PHP库**）中包含的`SplFileObject`类：
- en: 'First, we define a `Application\Iterator\LargeFile` class with the appropriate
    properties and constants:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个`Application\Iterator\LargeFile`类，具有适当的属性和常量：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We then define a `__construct()` method that accepts a filename as an argument
    and populates the `$file` property with an `SplFileObject` instance. This is also
    a good place to throw an exception if the file does not exist:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义了一个`__construct()`方法，接受文件名作为参数，并用`SplFileObject`实例填充`$file`属性。如果文件不存在，这也是抛出异常的好地方：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next we define a method `fileIteratorByLine()method` which uses `fgets()` to
    read one line of the file at a time. It''s not a bad idea to create a complimentary
    `fileIteratorByLength()`method that does the same thing but uses `fread()` instead.
    The method that uses `fgets()` would be suitable for text files that include linefeeds.
    The other method could be used if parsing a large binary file:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们定义了一个`fileIteratorByLine()method`方法，该方法使用`fgets()`逐行读取文件。创建一个类似的`fileIteratorByLength()`方法，但使用`fread()`来实现也是个不错的主意。使用`fgets()`的方法适用于包含换行符的文本文件。另一个方法可以用于解析大型二进制文件：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we define a `getIterator()`method that returns a `NoRewindIterator()`
    instance. This method accepts as arguments either `ByLine` or `ByLength`, which
    refer to the two methods defined in the previous step. This method also needs
    to accept `$numBytes` in case `ByLength` is called. The reason we need a `NoRewindIterator()`
    instance is to enforce the fact that we''re reading through the file only in one
    direction in this example:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个`getIterator()`方法，返回一个`NoRewindIterator()`实例。该方法接受`ByLine`或`ByLength`作为参数，这两个参数是指前一步骤中定义的两种方法。该方法还需要接受`$numBytes`，以防调用`ByLength`。我们需要一个`NoRewindIterator()`实例的原因是强制在这个例子中只能单向读取文件：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First of all, we take advantage of the autoloading class defined in [Chapter
    1](ch01.html "Chapter 1. Building a Foundation"), *Building a Foundation*, to
    obtain an instance of `Application\Iterator\LargeFile` in a calling program, `chap_02_iterating_through_a_massive_file.php`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们利用[第1章](ch01.html "第1章。建立基础")中定义的自动加载类，在调用程序`chap_02_iterating_through_a_massive_file.php`中获取`Application\Iterator\LargeFile`的实例：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, inside a `try {...} catch () {...}` block, we get an instance of a `ByLine`
    iterator:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`try {...} catch () {...}`块中，我们获取一个`ByLine`迭代器的实例：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We then provide an example of something useful to do, in this case, defining
    an average of words per line:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们提供了一个有用的示例，即定义每行的平均单词数：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We then end the `catch` block:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们结束`catch`块：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The expected output (too large to show here!) shows us that there are 566,095
    words in the project Gutenberg version of *War and Peace*. Also, we find the average
    number of words per line is eight.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出（太大无法在此显示！）显示了《战争与和平》古腾堡版本中有566,095个单词。此外，我们发现每行的平均单词数为八个。
- en: Uploading a spreadsheet into a database
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将电子表格上传到数据库
- en: Although PHP does not have any direct capability to read a specific spreadsheet
    format (that is, XLSX, ODS, and so on), it does have the ability to read **(CSV
    Comma Separated Values**) files. Accordingly, in order to process customer spreadsheets,
    you will need to either ask them to furnish their files in CSV format, or you
    will need to perform the conversion yourself.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然PHP没有直接读取特定电子表格格式（如XLSX、ODS等）的能力，但它可以读取**（CSV逗号分隔值**）文件。因此，为了处理客户的电子表格，您需要要求他们以CSV格式提供文件，或者您需要自行进行转换。
- en: Getting ready...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: 'When uploading a spreadsheet (that is, a CSV file) into a database, there are
    three major considerations:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将电子表格（即CSV文件）上传到数据库时，有三个主要考虑因素：
- en: Iterating through a (potentially) massive file
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历（可能）庞大的文件
- en: Extracting each spreadsheet row into a PHP array
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个电子表格行提取为PHP数组
- en: Inserting the PHP array into the database
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将PHP数组插入数据库
- en: Massive file iteration will be handled using the preceding recipe. We will use
    the `fgetcsv()` function to convert a CSV row into a PHP array. Finally, we will
    use the **(PDO PHP Data Objects**) class to make a database connection and perform
    the insert.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 庞大文件的迭代将使用前面的方法处理。我们将使用`fgetcsv()`函数将CSV行转换为PHP数组。最后，我们将使用**（PDO PHP数据对象**）类建立数据库连接并执行插入操作。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we define a `Application\Database\Connection` class that creates a PDO
    instance based on a set of parameters supplied to the constructor:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个`Application\Database\Connection`类，该类根据构造函数提供的一组参数创建一个PDO实例：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We then incorporate an instance of `Application\Iterator\LargeFile`. We add
    a new method to this class that is designed to iterate through CSV files:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们加入了一个`Application\Iterator\LargeFile`的实例。我们为这个类添加了一个新的方法，用于遍历CSV文件：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We also need to add `Csv` to the list of allowed iterator methods:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将`Csv`添加到允许的迭代器方法列表中：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First we define a config file,`/path/to/source/config/db.config.php`, that
    contains database connection parameters:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们定义一个配置文件，`/path/to/source/config/db.config.php`，其中包含数据库连接参数：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we take advantage of the autoloading class defined in [Chapter 1](ch01.html
    "Chapter 1. Building a Foundation"), *Building a Foundation*, to obtain an instance
    of `Application\Database\Connection` and `Application\Iterator\LargeFile`, defining
    a calling program, `chap_02_uploading_csv_to_database.php`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们利用[第1章](ch01.html "第1章。建立基础")中定义的自动加载类，*建立基础*，来获得`Application\Database\Connection`和`Application\Iterator\LargeFile`的实例，定义一个调用程序`chap_02_uploading_csv_to_database.php`：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After that, we set up a `try {...} catch () {...}` block, which catches `Throwable`.
    This allows us to `catch` both exceptions and errors:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们设置了一个`try {...} catch () {...}`块，其中捕获了`Throwable`。这使我们能够同时捕获异常和错误：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Inside the `try {...} catch () {...}` block we get an instance of the connection
    and large file iterator classes:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`try {...} catch () {...}`块中，我们获得连接和大文件迭代器类的实例：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We then take advantage of the PDO prepare/execute functionality. The SQL for
    the prepared statement uses `?` to represent values that are supplied in a loop:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们利用PDO准备/执行功能。准备好的语句的SQL使用`?`来表示在循环中提供的值：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We then use `foreach()` to loop through the file iterator. Each `yield` statement
    produces an array of values that represents a row in the database. We can then
    use these values with `PDOStatement::execute()` to execute the prepared statement,
    inserting the row of values into the database:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`foreach()`来循环遍历文件迭代器。每个`yield`语句产生一个值数组，表示数据库中的一行。然后我们可以使用这些值与`PDOStatement::execute()`一起使用，将这些值的行插入到数据库中执行准备好的语句：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can then examine the database to verify that the data was successfully inserted.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以检查数据库，以验证数据是否已成功插入。
- en: Recursive directory iterator
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归目录迭代器
- en: Getting a list of files in a directory is extremely easy. Traditionally, developers
    have used the `glob()` function for this purpose. To recursively get a list of
    all files and directories from a specific point in a directory tree is more problematic.
    This recipe takes advantage of an **(SPL Standard PHP Library**) class `RecursiveDirectoryIterator`,
    which will serve this purpose admirably.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 获取目录中文件的列表非常容易。传统上，开发人员使用`glob()`函数来实现这个目的。要从目录树中的特定点递归获取所有文件和目录的列表则更加棘手。这个方法利用了一个**（SPL标准PHP库）**类`RecursiveDirectoryIterator`，它将非常好地实现这个目的。
- en: What this class does is to parse the directory tree, finding the first child,
    then it follows the branches, until there are no more children, and then it stops!
    Unfortunately this is not what we want. Somehow we need to get the `RecursiveDirectoryIterator`
    to continue parsing every tree and branch, from a given starting point, until
    there are no more files or directories. It so happens there is a marvelous class,
    `RecursiveIteratorIterator`, that does exactly that. By wrapping `RecursiveDirectoryIterator`
    inside `RecursiveIteratorIterator,` we accomplish a complete traversal of any
    directory tree.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的作用是解析目录树，找到第一个子目录，然后沿着分支继续，直到没有更多的子目录，然后停止！不幸的是，这不是我们想要的。我们需要以某种方式让`RecursiveDirectoryIterator`继续解析每棵树和分支，从给定的起点开始，直到没有更多的文件或目录。碰巧有一个奇妙的类`RecursiveIteratorIterator`，它正好可以做到这一点。通过将`RecursiveDirectoryIterator`包装在`RecursiveIteratorIterator`中，我们可以完成对任何目录树的完整遍历。
- en: Tip
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Warning!**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！**'
- en: Be very careful where you start the filesystem traversal. If you start at the
    root directory, you could end up crashing your server as the recursion process
    will not stop until all files and directories have been located!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 非常小心地选择文件系统遍历的起点。如果您从根目录开始，您可能会导致服务器崩溃，因为递归过程将一直持续，直到找到所有文件和目录！
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we define a `Application\Iterator\Directory` class that defines the
    appropriate properties and constants and uses external classes:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个`Application\Iterator\Directory`类，该类定义了适当的属性和常量，并使用外部类：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The constructor creates a `RecursiveDirectoryIterator` instance inside `RecursiveIteratorIterator`
    based on a directory path:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数基于目录路径创建了一个`RecursiveDirectoryIterator`实例，该实例位于`RecursiveIteratorIterator`内部：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we decide what to do with the iteration. One possibility is to mimic
    the output of the Linux `ls -l -R` command. Notice that we use the `yield` keyword,
    effectively making this method into a **Generator**, which can then be called
    from the outside. Each object produced by the directory iteration is an SPL `FileInfo`
    object, which can give us useful information on the file. Here is how this method
    might look:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们决定如何处理迭代。一种可能性是模仿Linux的`ls -l -R`命令的输出。请注意，我们使用了`yield`关键字，有效地将此方法转换为**生成器**，然后可以从外部调用。目录迭代产生的每个对象都是一个SPL
    `FileInfo`对象，它可以为我们提供有关文件的有用信息。这个方法可能是这样的：
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You may have noticed that the method call includes a file pattern. We need
    a way of filtering the recursion to only include files that match. There is another
    iterator available from the SPL that perfectly suits this need: the `RegexIterator`
    class:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能已经注意到，方法调用包括文件模式。我们需要一种方法来过滤递归，只包括匹配的文件。SPL中还有另一个迭代器完全适合这个需求：`RegexIterator`类：
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, here is another method, but this time we will mimic the `dir /s` command:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这是另一种方法，但这次我们将模仿`dir /s`命令：
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'First of all, we take advantage of the autoloading class defined in [Chapter
    1](ch01.html "Chapter 1. Building a Foundation"), *Building a Foundation*, to
    obtain an instance of `Application\Iterator\Directory`, defining a calling program,
    `chap_02_recursive_directory_iterator.php`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们利用[第1章](ch01.html "第1章。建立基础")中定义的自动加载类，*建立基础*，来获得`Application\Iterator\Directory`的实例，定义一个调用程序`chap_02_recursive_directory_iterator.php`：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, in a `try {...} catch () {...}` block, we make a call to our two methods,
    using an example directory path:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`try {...} catch () {...}`块中，我们调用了我们的两个方法，使用一个示例目录路径：
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output for `ls()` will look something like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls()`的输出将如下所示：'
- en: '![How it works...](graphics/B05314_02_03.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_02_03.jpg)'
- en: 'The output for `dir()` will appear as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`dir()`的输出将如下所示：'
- en: '![How it works...](graphics/B05314_02_04.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_02_04.jpg)'
