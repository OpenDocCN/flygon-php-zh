- en: Chapter 5. Going Further
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。进一步
- en: In previous chapters we learned the basics of the Doctrine ORM. We are now able
    to create complex domain classes, generate underlying SQL tables, load data fixtures,
    and execute advanced queries. We know everything we need to know to develop the
    model layer of small web applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了Doctrine ORM的基础知识。我们现在能够创建复杂的领域类，生成底层SQL表，加载数据固定装置，并执行高级查询。我们知道了开发小型Web应用程序的模型层所需的一切知识。
- en: 'The library, however, provides more advanced features. In this chapter we will
    briefly cover various topics not addressed previously: inheritance, lifecycle
    callbacks, and native queries.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该库提供了更高级的功能。在本章中，我们将简要介绍以前未涉及的各种主题：继承、生命周期回调和本机查询。
- en: Implementing inheritance
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现继承
- en: Like all object-oriented programming languages, PHP is designed on top of the
    inheritance concept; however, relational databases are not. This is the common
    problem when mapping classes to tables.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有面向对象的编程语言一样，PHP是建立在继承概念之上的；然而，关系数据库不是。这是将类映射到表时的常见问题。
- en: 'The Doctrine ORM provides the following three ways to achieve inheritance:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine ORM提供了以下三种实现继承的方式：
- en: Mapped Superclasses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射的超类
- en: Single Table Inheritance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单表继承
- en: Class Table Inheritance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类表继承
- en: To learn about them, we will create three implementations of the same model,
    that is, for content authors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解它们，我们将创建相同模型的三个实现，即内容作者。
- en: Both posts and comments have authors. Authors must have a name and an e-mail
    address. Posts' authors (and only them) can also have an optional biography.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 帖子和评论都有作者。作者必须有姓名和电子邮件地址。帖子的作者（仅他们）还可以有一个可选的传记。
- en: 'To represent this, we will create two classes: `PostAuthor` and `CommentAuthor`.
    They both extend an abstract `Author` class. Each `Comment` entity is linked to
    a `CommentAuthor` class and each `Post` entity to a `PostAuthor` class.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示这一点，我们将创建两个类：`PostAuthor`和`CommentAuthor`。它们都扩展了一个抽象的`Author`类。每个`Comment`实体都与一个`CommentAuthor`类相关联，每个`Post`实体都与一个`PostAuthor`类相关联。
- en: Using Mapped Superclasses
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用映射的超类
- en: Mapped Superclasses are simple PHP classes that share mapped properties used
    by their descendant entities. Mapped Superclasses are not entities themselves.
    They are extended by entities.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 映射的超类是简单的PHP类，它们共享由它们的后代实体使用的映射属性。映射的超类本身不是实体。它们被实体扩展。
- en: Mapped Superclasses are never directly persisted to the database. They are not
    retrievable through the query builder and cannot be the inverse-side of an association.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 映射的超类永远不会直接持久化到数据库。它们不能通过查询构建器检索，并且不能成为关联的反向方。
- en: They are like any other PHP class extended by entities, except that they can
    hold properties that will be persisted by their descendants.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 它们就像任何其他PHP类一样，被实体扩展，只是它们可以持有将由它们的后代持久化的属性。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This type of inheritance is not well suited for this use case. Single Table
    Inheritance is better here.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的继承不适合这种用例。单表继承在这里更好。
- en: 'Start by creating the Mapped Superclass. Create a new abstract class called
    `Author` in the `Author.php` file at the location `src/Blog/Entity/`as shown in
    the following code:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建映射的超类。在`src/Blog/Entity/`位置的`Author.php`文件中创建一个名为`Author`的新抽象类，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Thanks to the `@MappedSuperclass` annotation, the mapped properties of the `Author`
    class inherited by `PostAuthor` and `CommentAuthor` classes will be taken into
    account by Doctrine.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`@MappedSuperclass`注释，`Author`类的映射属性被`PostAuthor`和`CommentAuthor`类继承的属性将被Doctrine考虑在内。
- en: Write getters for all the properties and setters for all except the `$id` instance.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有属性编写getter，并为除`$id`实例之外的所有属性编写setter。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, Doctrine Command-Line Tools were not able to generate
    getters and setters for a Mapped Superclass and suffered a bug when generating
    getters and setters for child classes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Doctrine命令行工具无法为映射的超类生成getter和setter，并且在为子类生成getter和setter时存在错误。
- en: 'Create a `PostAuthor.php` file in the same directory that contains the `PostAuthor`
    class as shown in the following code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含`PostAuthor`类的相同目录中创建一个名为`PostAuthor.php`的文件，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `PostAuthor` entity class extends the `Author` Mapped Superclass. `PostAuthor`
    holds specific data of posts'' authors: a `bio` property and a One-To-Many association
    to posts.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostAuthor`实体类扩展了`Author`映射的超类。`PostAuthor`保存了帖子作者的特定数据：一个`bio`属性和一个对帖子的一对多关联。'
- en: At the database level, a table called `PostAuthor` will be created with all
    the columns defined with the `@Column` annotation in `Author` and `PostAuthor`
    classes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库级别，将创建一个名为`PostAuthor`的表，其中包含`Author`和`PostAuthor`类中使用`@Column`注释定义的所有列。
- en: Write getters and setters for this class.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个类编写getter和setter。
- en: 'To make this association work, we need to add the code of the owning-side of
    the association to the `src/Blog/Entity/Post.php` file. To do this, add the following
    property:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个关联工作，我们需要将关联的拥有方的代码添加到`src/Blog/Entity/Post.php`文件中。为此，请添加以下属性：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You guessed it! Write the getter and setter for the preceding property.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你猜对了！为上述属性编写getter和setter。
- en: 'Now create a file called `CommentAuthor.php` in the same directory containing
    the `CommentAuthor` entity class as shown in the following code:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在包含`CommentAuthor`实体类的相同目录中创建一个名为`CommentAuthor.php`的文件，如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This entity class is very similar to the `PostAuthor` class, except that its
    association is related to `Comment` instead of `Post`, and it doesn't have a `bio`
    property.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实体类与`PostAuthor`类非常相似，只是它的关联与`Post`相关而不是`Comment`，并且它没有`bio`属性。
- en: Another table called `CommentAuthor` will be created in the database. This table
    will be completely independent of the `PostAuthor` table.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中将创建另一个名为`CommentAuthor`的表。这个表将完全独立于`PostAuthor`表。
- en: Write the getter and setter for the same property after adding the preceding
    code.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加上述代码后，为相同属性编写getter和setter。
- en: 'We also need to add the owning-side of the association. Open the `src/Blog/Entity/Comment.php`
    file and add the following properties:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要添加关联的拥有方。打开`src/Blog/Entity/Comment.php`文件并添加以下属性：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After you've completed the previous step, add the getter and setter.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成上一步后，添加getter和setter。
- en: 'To understand how this type of inheritance is handled by Doctrine, and to test
    our code, we will create a fixture by inserting sample data in the `src/DataFixtures/LoadAuthorData.php`
    file as shown by the following code:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了了解Doctrine如何处理这种类型的继承，并测试我们的代码，我们将通过在`src/DataFixtures/LoadAuthorData.php`文件中插入示例数据来创建一个fixture，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This fixture creates instances of `Post`, `PostAuthor`, `Comment`, and `CommentAuthor`
    and then persists them to the database.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个fixture创建了`Post`、`PostAuthor`、`Comment`和`CommentAuthor`的实例，然后将它们持久化到数据库中。
- en: 'Update the following schema:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新以下模式：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following ER diagram represents the schema that will be generated on using
    MySQL as DBMS:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下ER图表示在使用MySQL作为DBMS时将生成的模式：
- en: '![Using Mapped Superclasses](graphics/4104OS_05_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![使用映射超类](graphics/4104OS_05_01.jpg)'
- en: Even if the `PostAuthor` and `CommentAuthor` classes both inherit from the `Author`
    Mapped Superclass, their corresponding SQL schemas do not share anything and are
    not related.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`PostAuthor`和`CommentAuthor`类都继承自`Author`映射超类，它们对应的SQL模式没有共享任何内容，也没有关联。
- en: 'Then load the fixtures with the following command:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用以下命令加载fixture：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Use the SQLite client to show the inserted content in each table with the following
    command:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用SQLite客户端使用以下命令显示每个表中插入的内容：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After the preceding steps George''s and my details should appear as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述步骤之后，George和我的详细信息应该如下所示：
- en: '**1|L''homme le plus classe du monde|George Abitbol|gabitbol@example.com**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**1|L''homme le plus classe du monde|George Abitbol|gabitbol@example.com**'
- en: '**1|Kévin Dunglas|dunglas@gmail.com**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**1|Kévin Dunglas|dunglas@gmail.com**'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For practice, the UI of the author feature is used. An example is provided in
    the bonus code sample available on the Packt website.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习，使用了作者功能的UI。在Packt网站上提供了示例代码。
- en: Using Single Table Inheritance
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用单表继承
- en: With Single Table Inheritance, data of all the classes of the hierarchy will
    be stored in the same database table. A column for every property of every child
    class will be created.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单表继承，层次结构的所有类的数据将存储在同一个数据库表中。将为每个子类的每个属性创建一列。
- en: This mapping strategy suits very well for a simple type of hierarchy and performs
    well while querying both the same and different types of entities.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种映射策略非常适合简单类型的层次结构，并且在查询相同类型和不同类型的实体时表现良好。
- en: 'To change from Mapped Super Class to Single Table Inheritance, we will just
    make some modifications to the classes we just created:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要从映射超类更改为单表继承，我们只需对刚刚创建的类进行一些修改：
- en: 'Open the `src/Blog/Entity/Author.php` file and find the following snippet:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/Blog/Entity/Author.php`文件并找到以下片段：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Replace the preceding snippet with the following snippet:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下片段替换上述片段：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Update the schema and load the fixtures again with the following queries:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下查询更新模式并再次加载fixture：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following screenshot is the ER diagram for the Single Table Inheritance
    type:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是单表继承类型的ER图：
- en: '![Using Single Table Inheritance](graphics/4104OS_05_02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![使用单表继承](graphics/4104OS_05_02.jpg)'
- en: Data of both `PostAuthor` and `CommentAuthor` entities is now persisted in a
    unique database table called `Author`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`PostAuthor`和`CommentAuthor`实体的数据都存储在名为`Author`的唯一数据库表中。
- en: The entity type is identified in the table, thanks to a **discriminator column**
    added, and automatically managed, by Doctrine.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实体类型在表中通过**鉴别器列**进行标识，并由Doctrine自动管理。
- en: By default, this discriminator column is called `dtype` and the Doctrine type
    `string`. These values can be overridden thanks to the `@DiscriminatorColumn`
    annotation. This annotation should be used on the entity class marked with the
    `@InheritanceType` annotation (here, the `Author` class).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这个鉴别器列被称为`dtype`，Doctrine类型为`string`。这些值可以通过`@DiscriminatorColumn`注释进行覆盖。这个注释应该用在标有`@InheritanceType`注释的实体类上（这里是`Author`类）。
- en: 'The value stored in this column is used by Doctrine to determine the type of
    entity class to hydrate for a given database row. It defaults to the name of the
    entity class (not fully qualified) in lowercase. The used value for each entity
    class can also be overridden by adding an annotation on the parent entity class:
    `@DiscriminatorMap`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在此列中的值由Doctrine用于确定要为给定数据库行水合的实体类的类型。默认情况下，它是实体类的名称（不是完全限定的）的小写形式。每个实体类的使用值也可以通过在父实体类上添加注释`@DiscriminatorMap`来覆盖。
- en: 'All these annotations and the Single Table Inheritance type are documented
    at:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些注释和单表继承类型都在以下文档中有说明：
- en: '`http://docs.doctrine-project.org/en/latest/reference/inheritance-mapping.html#single-table-inheritance`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://docs.doctrine-project.org/en/latest/reference/inheritance-mapping.html#single-table-inheritance`'
- en: 'To look at the data we have inserted in the `Author` table with our fixtures,
    run the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们在`Author`表中插入的数据，运行以下命令：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result should be as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该如下：
- en: '**1|Kévin Dunglas|dunglas@gmail.com|commentauthor|**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**1|Kévin Dunglas|dunglas@gmail.com|commentauthor|**'
- en: '**2|George Abitbol|gabitbol@example.com|postauthor|L''homme le plus classe
    du monde**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**2|George Abitbol|gabitbol@example.com|postauthor|L''homme le plus classe
    du monde**'
- en: Using Class Table Inheritance
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类表继承
- en: The last strategy provided by Doctrine is the Class Table Inheritance. Data
    of each class of the hierarchy is stored in a specific database table. All the
    tables of the hierarchy are joined during the data retrieval time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine提供的最后一种策略是类表继承。层次结构的每个类的数据存储在特定的数据库表中。在数据检索时，层次结构的所有表都会被连接。
- en: Because of the massive use of joins, this strategy is less efficient than Single
    Table Inheritance, especially with Big Data. The more descendant classes you add,
    the more joins are needed to retrieve data, and the slower the querying.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于联接的大量使用，这种策略不如单表继承高效，特别是在处理大数据时。您添加的后代类越多，检索数据所需的联接就越多，查询速度就越慢。
- en: But because every entity class of the hierarchy is mapped to its own table,
    this strategy also allows great flexibility. Creating or modifying an entity class
    only affects its directly related database table. In cases where performance is
    not a priority and the data model is complex, this type of inheritance can be
    a solution to limit or avoid complex, and even risky, migrations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但是因为层次结构的每个实体类都映射到自己的表，这种策略也允许很大的灵活性。创建或修改实体类只会影响其直接相关的数据库表。在性能不是首要考虑因素，数据模型复杂的情况下，这种继承类型可以是限制或避免复杂甚至有风险的迁移的解决方案。
- en: 'As for Single Table Inheritance, we just need to make minor changes to create
    our `Author` data model using Class Table Inheritance with the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 至于单表继承，我们只需要进行一些小的更改，就可以使用类表继承创建我们的`Author`数据模型，具体步骤如下：
- en: 'Open the `src/Blog/Entity/Author.php` file and find the following `@InheritanceType`
    annotation we added to use Single Table Inheritance:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/Blog/Entity/Author.php`文件，并找到我们添加的`@InheritanceType`注释，以使用单表继承：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Replace the argument `SINGLE_TABLE` by the following argument:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将参数`SINGLE_TABLE`替换为以下参数：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Update the schema and load the fixtures, again with the following query:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用以下查询更新模式并加载数据：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following ER diagram represents the generated schema, again using MySQL:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下ER图表示生成的模式，再次使用MySQL：
- en: '![Using Class Table Inheritance](graphics/4104OS_05_03.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![使用类表继承](graphics/4104OS_05_03.jpg)'
- en: The `Author` table contains shared data between `PostAuthor` and `CommentAuthor`
    entity classes. These child classes only hold their specific data. Their `id`
    columns are foreign keys referencing the `id` column of the `Author` table. This
    allows data linking because the ID in a table storing data of descendant classes
    is the same as the ID in the table storing data of the top class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Author`表包含`PostAuthor`和`CommentAuthor`实体类之间的共享数据。这些子类只保存它们特定的数据。它们的`id`列是引用`Author`表的`id`列的外键。这允许数据链接，因为存储后代类数据的表中的ID与存储顶级类数据的表中的ID相同。'
- en: As for Single Table Inheritance, a discriminator column allows Doctrine to identify
    the entity class corresponding to the database table's rows. Their default names
    and values are the same. They can also be overridden through `@DicriminatorColumn`
    and `@DicriminatorMap` annotations on the topmost entity class of the hierarchy
    (here, `Author`).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 至于单表继承，鉴别器列允许Doctrine识别与数据库表行对应的实体类。它们的默认名称和值相同。它们也可以通过层次结构的顶级实体类（这里是`Author`）上的`@DicriminatorColumn`和`@DicriminatorMap`注释进行覆盖。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Class Table Inheritance allows referencing the topmost class of a hierarchy
    in associations, but the loading feature will not work anymore.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 类表继承允许在关联中引用层次结构的顶级类，但加载功能将不再起作用。
- en: For further information about Class Table Inheritance, refer to the documentation
    available at [http://docs.doctrine-project.org/en/latest/reference/inheritance-mapping.html#class-table-inheritance](http://docs.doctrine-project.org/en/latest/reference/inheritance-mapping.html#class-table-inheritance).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有关类表继承的更多信息，请参阅[http://docs.doctrine-project.org/en/latest/reference/inheritance-mapping.html#class-table-inheritance](http://docs.doctrine-project.org/en/latest/reference/inheritance-mapping.html#class-table-inheritance)上可用的文档。
- en: 'To show data we have inserted with fixtures in the `Author`, `CommentAuthor`
    and `PostAuthor` tables, run the following query with the SQLite client:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示我们在`Author`、`CommentAuthor`和`PostAuthor`表中插入的数据，使用SQLite客户端运行以下查询：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the expected result:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是预期结果：
- en: '**1|Kévin Dunglas|dunglas@gmail.com|commentauthor**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**1|Kévin Dunglas|dunglas@gmail.com|commentauthor**'
- en: '**2|George Abitbol|gabitbol@example.com|postauthor**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**2|George Abitbol|gabitbol@example.com|postauthor**'
- en: '**2|L''homme le plus classe du monde**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**2|世界上最有品味的人**'
- en: '**1**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**1**'
- en: Getting started with events
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用事件
- en: The Doctrine Common component comes with a built-in event system. It allows
    dispatching and subscribing to custom events, but its main purpose is to manage
    entity-related events.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine Common组件带有内置的事件系统。它允许分发和订阅自定义事件，但其主要目的是管理与实体相关的事件。
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started with Doctrine 2"), *Getting
    Started with Doctrine 2*, we learned about entity managers, entity states, and
    Unit Of Work. Entity Managers (and their underlying `UnitOfWork` objects) dispatch
    events when the state of the entity changes and when data is stored, updated,
    and removed from the database. They are called lifecycle events.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。开始使用Doctrine 2")中，*开始使用Doctrine 2*，我们学习了实体管理器、实体状态和工作单元。当实体的状态发生变化以及数据存储、更新和从数据库中删除时，实体管理器（及其底层的`UnitOfWork`对象）会分发事件。它们被称为生命周期事件。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Doctrine also emits some events not directly related to the entity lifecycle.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine还发出一些与实体生命周期无直接关的事件。
- en: 'Doctrine ORM provides the following bunch of lifecycle events:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine ORM提供了以下一系列的生命周期事件：
- en: '`preRemove`: This event occurs when the state of the entity is set to `removed`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preRemove`：此事件发生在实体的状态被设置为`removed`时'
- en: '`postRemove`: This event occurs after the removal of an entity''s data from
    the database'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postRemove`：此事件发生在从数据库中删除实体数据之后'
- en: '`prePersist`: This event occurs when the state of the entity passes from `new`
    to `managed`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prePersist`：此事件发生在实体的状态从`new`变为`managed`时'
- en: '`postPersist`: This event occurs after the `INSERT` SQL query has been executed'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postPersist`：此事件发生在`INSERT` SQL查询执行之后'
- en: '`preUpdate`: This event occurs before the `UPDATE` SQL query'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preUpdate`：此事件发生在`UPDATE` SQL查询之前'
- en: '`postUpdate`: This event occurs after the `UPDATE` SQL query'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postUpdate`：此事件发生在`UPDATE` SQL查询之后'
- en: '`postLoad`: This event occurs after the load or the refresh of the entity in
    the `EntityManager`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postLoad`：此事件发生在`EntityManager`中的实体加载或刷新之后'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full documentation of events (including the non-lifecycle one) on Doctrine
    ORM is available in the online documentation at [http://docs.doctrine-project.org/en/latest/reference/events.html](http://docs.doctrine-project.org/en/latest/reference/events.html).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine ORM的事件的完整文档（包括非生命周期事件）可在在线文档中找到：[http://docs.doctrine-project.org/en/latest/reference/events.html](http://docs.doctrine-project.org/en/latest/reference/events.html)。
- en: Lifecycle callbacks
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期回调
- en: Lifecycle callbacks are the easiest way to use these events. They allow executing
    methods directly defined in entity classes when the lifecycle event occurs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期回调是使用这些事件的最简单方法。它允许在生命周期事件发生时直接执行实体类中定义的方法。
- en: 'In our blog, we store the date of the publication of posts and comments. Thanks
    to lifecycle callbacks and to the `prePersist` event, it''s possible to automatically
    set this date the first time an entity is passed through the `persist()` method
    of its Entity Manager (when the state goes from `new` to `managed`):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的博客中，我们存储了帖子和评论的发布日期。由于生命周期回调和`prePersist`事件，可以在实体首次通过其实体管理器的`persist()`方法传递时自动设置此日期（当状态从`new`变为`managed`时）：
- en: Open the `Post.php` file in the `src/Blog/Entity/` folder and the `Comment.php`
    file in the `src/Blog/Entity/` folder.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/Blog/Entity/`文件夹中的`Post.php`文件和`src/Blog/Entity/`文件夹中的`Comment.php`文件。
- en: 'Add the following use statements to both the files:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下使用语句添加到这两个文件中：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Add the `@HasLifecycleCallbacks` annotations next to `@Entity` to both the files.
    This enables lifecycle callbacks in these two entity classes.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这两个文件的`@Entity`旁边添加`@HasLifecycleCallbacks`注释。这将在这两个实体类中启用生命周期回调。
- en: 'Then, add the following method to both the files, setting the publication date
    when the `prePersist` event occurs:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在这两个文件中添加以下方法，当`prePersist`事件发生时设置发布日期：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method is executed when a `Comment` or `Post` entity is passed through
    the `persist()` method of an entity manager. It sets the `publicationDate` property
    to the current time if it has not been already done.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Comment`或`Post`实体通过实体管理器的`persist()`方法传递时，将执行此方法。如果尚未执行，它将`publicationDate`属性设置为当前时间。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'These callback methods can take an optional argument, allowing access to the
    `EntityManager` and `UnitOfWork` (giving access to the underlying changeset) objects
    related to the entity which can be referenced at:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些回调方法可以接受一个可选参数，允许访问与实体相关的`EntityManager`和`UnitOfWork`（提供对底层更改集的访问）对象，可以在以下位置引用：
- en: '[http://docs.doctrine-project.org/en/latest/reference/events.html#lifecycle-callbacks-event-argument](http://docs.doctrine-project.org/en/latest/reference/events.html#lifecycle-callbacks-event-argument)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.doctrine-project.org/en/latest/reference/events.html#lifecycle-callbacks-event-argument](http://docs.doctrine-project.org/en/latest/reference/events.html#lifecycle-callbacks-event-argument)'
- en: Thanks to this tweak, we can remove calls using `setPublicationDate()` methods
    in `web/view-post.php` and `web/edit-post.php`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种调整，我们可以删除`web/view-post.php`和`web/edit-post.php`中使用`setPublicationDate()`方法的调用。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A popular library you should try is *Gediminas Morkevičius* `DoctrineExtensions`.
    It contains many useful behaviors for Doctrine, including, but not limited to,
    timestamps, translations, soft delete, and nested sets. The Doctrine extensions
    can be found at:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该尝试的一个受欢迎的库是*Gediminas Morkevičius*的`DoctrineExtensions`。它包含了许多对Doctrine有用的行为，包括但不限于时间戳，翻译，软删除和嵌套集。Doctrine扩展可以在以下位置找到：
- en: '[https://github.com/l3pp4rd/DoctrineExtensions](https://github.com/l3pp4rd/DoctrineExtensions)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/l3pp4rd/DoctrineExtensions](https://github.com/l3pp4rd/DoctrineExtensions)'
- en: Knowing about event listeners and event subscribers
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解事件监听器和事件订阅者
- en: 'Doctrine provides more powerful ways to deal with events: **event subscribers**
    and **event listeners**. Unlike lifecycle callbacks that are defined directly
    in entity classes, both must be defined in external classes. We will take a quick
    look at them.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine提供了更强大的处理事件的方式：**事件订阅者**和**事件监听器**。与生命周期回调直接在实体类中定义不同，这两者都必须在外部类中定义。我们将快速浏览一下它们。
- en: The main difference between listeners and subscribers is that listeners are
    attached to an event, and subscribers register themselves to events.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器和订阅者之间的主要区别在于监听器附加到事件，而订阅者注册自己到事件。
- en: 'Let''s create a listener that will strip some French insults from published
    comments in the `src/Blog/Event/InsultEventListener.php` file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个监听器，它将从`src/Blog/Event/InsultEventListener.php`文件中的已发布评论中删除一些法语侮辱词：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And now, we will create an event subscriber that will send an e-mail to a post
    author when a comment is posted in the `src/Blog/Event/MailAuthorOnCommentEventSubscriber.php`
    file, as shown in the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个事件订阅者，当在`src/Blog/Event/MailAuthorOnCommentEventSubscriber.php`文件中发布评论时，将向帖子作者发送电子邮件，如下所示：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Events' listener and subscriber methods' names must match the name of the events
    they want to catch. The entity related to the event and it's entity manager are
    available through the `$args` parameter. In our examples, we only used the entity.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的监听器和订阅者方法的名称必须与它们想要捕获的事件的名称匹配。与事件相关的实体及其实体管理器可通过`$args`参数获得。在我们的示例中，我们只使用了实体。
- en: Events' listeners and subscribers are only called when the event they have subscribed
    to is dispatched, whatever the type of entity. It's their responsibility to filter
    entities by type. This is why we use the `instanceof` keyword to check whether
    entities are of the type `Comment`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的监听器和订阅者只有在它们订阅的事件被分派时才会被调用，无论实体的类型如何。它们的责任是按类型过滤实体。这就是为什么我们使用`instanceof`关键字来检查实体是否是`Comment`类型。
- en: Unlike event listeners, event subscribers must implement the `EventSubscriber`
    interface. The `getSubscribedEvents()`method must return an array of events to
    listen to.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与事件监听器不同，事件订阅者必须实现`EventSubscriber`接口。`getSubscribedEvents()`方法必须返回要监听的事件数组。
- en: The last step is to register these events' listeners and subscribers through
    an Event Manager. Unlike for lifecycle callbacks, this is not handled automatically.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是通过事件管理器注册这些事件的监听器和订阅者。与生命周期回调不同，这不是自动处理的。
- en: 'Open the `src/bootstrap.php` file and add the following use statements:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`src/bootstrap.php`文件并添加以下使用语句：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then find the following line of code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后找到以下代码行：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Replace the preceding line with the following code snippet:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码片段替换上述行：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We instantiate an Event Manager, and we register our listener and our subscriber.
    For the listener, we need to tell for which events it should be called. The subscriber
    registers itself to events it is interested in.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实例化一个事件管理器，并注册我们的监听器和订阅者。对于监听器，我们需要告诉它应该调用哪些事件。订阅者会注册自己对其感兴趣的事件。
- en: The Event Manager object must be linked to the entity manager when it is created;
    this is why it is passed as the third argument of the `EntityManager::create()`
    static method (see [Chapter 1](ch01.html "Chapter 1. Getting Started with Doctrine
    2"), *Getting Started with Doctrine 2*).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建事件管理器对象时，它必须与实体管理器关联；这就是为什么它作为`EntityManager::create()`静态方法的第三个参数传递的（参见[第1章](ch01.html
    "第1章。开始使用Doctrine 2")，“开始使用Doctrine 2”）。
- en: Writing native queries
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写本地查询
- en: In the previous chapter, we learned how to create DQL queries through the `QueryBuilder`.
    But DQL has some limitations (that is, queries cannot contain subqueries in `FROM`
    and `JOIN` clauses), and sometimes you want to use specific features of your DBMS
    (that is, MySQL full-text search). In such cases you need to write native SQL
    queries.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何通过`QueryBuilder`创建DQL查询。但是DQL有一些限制（即查询不能包含`FROM`和`JOIN`子句中的子查询），有时您希望使用DBMS的特定功能（即MySQL全文搜索）。在这种情况下，您需要编写本地SQL查询。
- en: The NativeQuery class
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NativeQuery类
- en: The `NativeQuery` class allows you to execute native SQL queries and to get
    their results as Doctrine entities. Only `SELECT` queries are supported.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`NativeQuery`类允许您执行本地SQL查询并将其结果作为Doctrine实体获取。仅支持`SELECT`查询。'
- en: To experiment with this feature, we will create a new command that displays
    the 100 most recent comments. This can be useful to moderate them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试此功能，我们将创建一个新命令，显示最近的100条评论。这对于审核它们可能很有用。
- en: Create a file containing this new command called `last-comments.php` in the
    `bin/` directory of the app.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的`bin/`目录中创建一个名为`last-comments.php`的文件，其中包含此新命令。
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `ResultSetMappingBuilder` class is designed to map SQL query results to
    Doctrine entities. The call to its `addRootEntityFromClassMetadata()` method specifies
    the main entity class that will be hydrated (first parameter) as well as its internal
    alias (second parameter). Here it is `Comment`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSetMappingBuilder`类旨在将SQL查询结果映射到Doctrine实体。对其`addRootEntityFromClassMetadata()`方法的调用指定了将被填充的主实体类（第一个参数）以及其内部别名（第二个参数）。这里是`Comment`。'
- en: The `addJoinedEntityFromClassMetadata()` method permits you to populate an association
    of the root entity. The first parameter is the entity class. The second is the
    internal alias of this entity. The third is the internal alias of its parent entity.
    The fourth is the name of the relation in its parent entity class. And the last
    is an array of mappings between an entity's properties and SQL query aliases.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`addJoinedEntityFromClassMetadata()`方法允许您填充根实体的关联。第一个参数是实体类。第二个是此实体的内部别名。第三个是其父实体的内部别名。第四个是其父实体类中关系的名称。最后一个是实体属性和SQL查询别名之间的映射数组。'
- en: This last parameter is useful when SQL column names don't match entity's property
    names. Here, we use it to populate the `id` property of the related post with
    the `post_id` column of the `Comment` table.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当SQL列名与实体的属性名不匹配时，这个最后一个参数非常有用。在这里，我们使用它来用`Comment`表的`post_id`列填充相关帖子的`id`属性。
- en: Both `Comment` and `Post` database tables have columns called `body`, `publication_date`,
    and `author_id`. To get around this conflict, we map the `Post` entity properties
    respectively to `post_body`, `post_publication_date`, and `post_author_id` columns.
    You noticed that the SQL query doesn't return these columns. This is not a problem;
    they will be ignored.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comment`和`Post`数据库表都有名为`body`，`publication_date`和`author_id`的列。为了解决这个冲突，我们将`Post`实体属性分别映射到`post_body`，`post_publication_date`和`post_author_id`列。您注意到SQL查询没有返回这些列。这不是问题；它们将被忽略。'
- en: The `createNativeQuery()` method of the `EntityManager` takes the SQL query
    and the `ResultSetMappingBuilder` as parameters. Like DQL queries, SQL queries
    can use named parameters. They will automatically escape to prevent SQL injection
    attacks.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityManager`的`createNativeQuery()`方法接受SQL查询和`ResultSetMappingBuilder`作为参数。与DQL查询一样，SQL查询可以使用命名参数。它们将自动转义以防止SQL注入攻击。'
- en: Thanks to `NativeQuery` and `ResultSetMappingBuilder` classes, the result of
    the query is a collection of `Comment` entities (partially hydrated) with their
    related `Post` entity (having only the `id` property hydrated).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`NativeQuery`和`ResultSetMappingBuilder`类，查询的结果是一组`Comment`实体（部分填充），以及它们相关的`Post`实体（只填充`id`属性）。
- en: 'Run the following code to see the last 100 comments:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码以查看最近的100条评论：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Doctrine DBAL
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Doctrine DBAL
- en: Doctrine provides an even lower level way to issue native SQL queries. You can
    retrieve the underlying DBAL connection through the `EntityManager` and use it
    directly.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine提供了一种更低级的方法来发出本地SQL查询。您可以通过`EntityManager`检索底层的DBAL连接并直接使用它。
- en: This is useful to execute native `UPDATE` and `DELETE` queries and to retrieve
    data that is not intended to populate entities. Of course, do that only if you
    have a good reason or use DQL's `SELECT`, `UPDATE`, or `DELETE` queries instead.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于执行本地的`UPDATE`和`DELETE`查询以及检索不打算填充实体的数据非常有用。当然，只有在有充分理由或使用DQL的`SELECT`，`UPDATE`或`DELETE`查询时才这样做。
- en: To illustrate native queries through DBAL, we will create another command that
    displays some simple stats about our blog.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过DBAL说明本地查询，我们将创建另一个命令，显示有关我们的博客的一些简单统计信息。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As they don't use any DBMS-specific query, this command should be executed through
    ORM. Native queries are used here only to illustrate this feature.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们不使用任何特定于DBMS的查询，因此应通过ORM执行此命令。本例中仅使用本机查询来说明此功能。
- en: 'Create a file for this new command called `stats.php` in the `bin/` directory
    with the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bin/`目录中创建一个名为`stats.php`的新命令文件，其中包含以下代码：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We use the `EntityManager` to retrieve the underlying `Doctrine\DBAL\Connection`
    with the `getConnection()` method. DBAL's `Connection` is just a thin wrapper
    around `PDO` and its API is very similar. We use it to compute the total number
    and the last publication date of posts and comments.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`EntityManager`通过`getConnection()`方法检索底层的`Doctrine\DBAL\Connection`。DBAL的`Connection`只是`PDO`的一个薄包装，其API非常相似。我们用它来计算帖子和评论的总数以及最后的发布日期。
- en: 'To show them, run the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示它们，请运行以下命令：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'The last chapter was a quick overview of some advanced features of Doctrine:
    handling Inheritance though Mapped Superclass, Single Table Inheritance, and Class
    Table Inheritance; the Doctrine event system including lifecycle callbacks, listeners,
    and subscribers; and finally how to unleash the power of the underlying DBMS for
    specific use cases with native queries.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一章是Doctrine的一些高级功能的快速概述：通过映射的超类、单表继承和类表继承来处理继承；Doctrine事件系统，包括生命周期回调、监听器和订阅者；最后，如何利用底层DBMS的强大功能来处理特定用例的本机查询。
- en: Throughout this book, we have learned how to use the Doctrine ORM to create
    a stable model layer in our PHP applications. We are now familiar with concepts
    behind Doctrine components and we are able to smartly use its ORM. We also looked
    at the most powerful (but also complex) features, including entity managers and
    entity states, mapping information, associations, DQL, hydration, inheritance,
    events, and native queries. There is still a lot to learn, and many of these topics
    deserve a dedicated book of their own.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们学习了如何使用Doctrine ORM在我们的PHP应用程序中创建稳定的模型层。我们现在熟悉了Doctrine组件背后的概念，并且能够巧妙地使用其ORM。我们还研究了最强大（但也最复杂）的功能，包括实体管理器和实体状态、映射信息、关联、DQL、水合、继承、事件和本机查询。还有很多东西要学，其中许多主题都值得有专门的书籍。
- en: Again, the online documentation of the Doctrine project (available at [http://www.doctrine-project.org/](http://www.doctrine-project.org/))
    is comprehensive and full of advanced examples.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Doctrine项目的在线文档（可在[http://www.doctrine-project.org/](http://www.doctrine-project.org/)上找到）内容全面，包含了许多高级示例。
- en: Recall for the last time that to use Doctrine efficiently in production, a cache
    system (APC, Memcache, and Reddis), depending on your needs and of what is available
    on your server platform, must be used.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下最后一次，在生产中高效使用Doctrine，必须使用缓存系统（APC，Memcache和Reddis），这取决于您的需求和服务器平台上可用的内容。
- en: 'One last thing, Doctrine is free and open source software welcoming your contributions:
    bug reports and fixes, documentation, and adding new features.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事，Doctrine是免费和开源软件，欢迎您的贡献：错误报告和修复、文档和添加新功能。
