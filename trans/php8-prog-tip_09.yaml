- en: '*Chapter 7*: Avoiding Traps When Using PHP 8 Extensions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：在使用PHP 8扩展时避免陷阱'
- en: 'One of the main strengths of the **PHP: Hypertext Preprocessor** (**PHP**)
    language is its extensions. Changes to the PHP language introduced in PHP 8 also
    require extension development teams to update their extensions at the same time.
    In this chapter, you will learn which major changes to extensions have been made
    and how to avoid traps when updating an existing application to PHP 8.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**PHP：超文本预处理器**（**PHP**）语言的主要优势之一是它的扩展。在PHP 8中引入的对PHP语言的更改也要求扩展开发团队同时更新他们的扩展。在本章中，您将了解对扩展所做的主要更改以及如何避免在将现有应用程序更新到PHP
    8时出现陷阱。'
- en: Once you have finished reviewing the sample code and topics presented in this
    chapter, you will be able to prepare any existing PHP code for migration to PHP
    8\. In addition to learning about the changes to the various extensions, you will
    also gain deep insight into their operation. This ability will allow you to make
    informed decisions when using extensions in PHP 8.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成了对本章中提供的示例代码和主题的审阅，您将能够准备好将任何现有的PHP代码迁移到PHP 8。除了了解各种扩展的变化外，您还将深入了解它们的操作。这将使您能够在使用PHP
    8中的扩展时做出明智的决策。
- en: 'Topics covered in this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: Understanding the shift from resources to objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解从资源到对象的转变
- en: Learning about changes to **Extensible Markup Language** (**XML**) extensions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习有关**可扩展标记语言**（**XML**）扩展的变化
- en: Avoiding problems with the updated `mbstring` extension
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免更新的`mbstring`扩展出现问题
- en: Dealing with changes to the `gd` extension
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理`gd`扩展的变化
- en: Discovering changes to the `Reflection` extension
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现`Reflection`扩展的变化
- en: Working with other extension gotchas
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理其他扩展的陷阱
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To examine and run the code examples provided in this chapter, the minimum
    recommended hardware is outlined here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看并运行本章提供的代码示例，以下是最低推荐的硬件要求：
- en: x86_64-based desktop PC or laptop
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于x86_64的台式PC或笔记本电脑
- en: 1 **gigabyte** (**GB**) free disk space
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 **千兆字节**（**GB**）的免费磁盘空间
- en: 4 GB of **random-access memory** (**RAM**)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 GB的**随机存取存储器**（**RAM**）
- en: 500 **kilobits per second** (**Kbps**) or faster internet connection
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 500 **千位每秒**（**Kbps**）或更快的互联网连接
- en: 'In addition, you will need to install the following software:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您需要安装以下软件：
- en: Docker
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Docker Compose
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Please refer to the *Technical requirements* section of [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013),
    *Introducing New PHP 8 OOP Features,* for more information on Docker and Docker
    Compose installation, as well as how to build a Docker container like the one
    used to demonstrate the code used in this book. In this book, we refer to the
    directory in which you restored the sample code for this book as `/repo`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Docker和Docker Compose安装的更多信息，请参阅[*第1章*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013)的*技术要求*部分，*介绍新的PHP
    8面向对象编程功能*，以及如何构建一个类似于用于演示本书中使用的代码的Docker容器。在本书中，我们将您为本书恢复的示例代码的目录称为`/repo`。
- en: 'The source code for this chapter is located here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于此处：
- en: '[https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices/tree/main/ch07](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices/tree/main/ch07'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices/tree/main/ch07](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices/tree/main/ch07'
- en: )
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: We can now begin our discussion by examining the overall trend in PHP 8 toward
    objects rather than resources.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始讨论，在PHP 8中向对象而不是资源的整体趋势。
- en: Understanding the shift from resources to objects
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解从资源到对象的转变
- en: The PHP language has always had an uneasy relationship with **resources**. Resources
    represent a connection to an external system such as a file handle or a connection
    to a remote web service using the **client URL** (**cURL**) extension. One big
    problem with resources, however, is that they defy attempts at data typing. There's
    no way to distinguish a file handle from a `cURL` connection—they're both identified
    as resources.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: PHP语言一直与**资源**有着不稳定的关系。资源代表着与外部系统的连接，比如文件句柄或使用**客户端URL**（**cURL**）扩展连接到远程网络服务。然而，资源的一个大问题是，它们无法进行数据类型的区分。无法区分文件句柄和`cURL`连接——它们都被标识为资源。
- en: In PHP 8, a major effort has taken place to move away from resources and to
    replace them with objects. One of the earliest examples of this trend prior to
    PHP 8 is the `PDO` class. When you create a `PDO` instance, it automatically creates
    a database connection. Starting with PHP 8, many functions that previously produced
    a resource now produce an object instance instead. Let's start our discussion
    by having a look at extension functions that now produce objects rather than resources.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，已经进行了大力的努力，摆脱资源并用对象替换它们。在PHP 8之前这种趋势的最早例子之一是`PDO`类。当您创建一个`PDO`实例时，它会自动创建一个数据库连接。从PHP
    8开始，许多以前产生资源的函数现在产生对象实例。让我们开始讨论一下现在产生对象而不是资源的扩展函数。
- en: PHP 8 extension resource-to-object migration
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP 8扩展资源到对象的迁移
- en: It's important for you to be aware of which functions in PHP 8 now produce objects
    instead of resources. The good news is that the extension functions have also
    been rewritten to accommodate an object as an argument rather than a resource.
    The bad news is that there is a potential backward-compatible code break where
    you initialize the resource (now object) and test for success using the `is_resource()`
    function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道在PHP 8中哪些函数现在产生对象而不是资源。好消息是扩展函数也已经被重写，以适应对象作为参数而不是资源。坏消息是，在初始化资源（现在是对象）并使用`is_resource()`函数进行成功测试时，可能会出现向后兼容的代码中断。
- en: 'The following table summarizes the functions that formerly returned resources
    but now return object instances:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了以前返回资源但现在返回对象实例的函数：
- en: '![Table 7.1 – PHP 8 resource-to-object migration'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![表7.1 – PHP 8资源到对象的迁移'
- en: '](image/Table_7.1_B16992.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_7.1_B16992.jpg)'
- en: Table 7.1 – PHP 8 resource-to-object migration
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 - PHP 8资源到对象的迁移
- en: '*Table 7.1* serves as a valuable guide to functions that now produce objects
    rather than resources. Consult this table before you migrate any existing applications
    to PHP 8\. The next section gives you a detailed look at a potential backward-compatible
    code break and guidelines on how to adjust problematic code, before moving on
    to the benefits.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*表7.1*是一个宝贵的指南，列出了现在产生对象而不是资源的函数。在将任何现有应用程序迁移到PHP 8之前，请参考此表。接下来的部分将详细介绍潜在的向后兼容代码中断，并指导您如何调整有问题的代码，然后再介绍其优势。'
- en: Potential code break involving is_resource()
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 涉及is_resource()的潜在代码中断
- en: A problem you might face is that code written prior to PHP 8 assumes the functions
    listed in *Table 7.1* return a *resource*. Accordingly, clever developers were
    in the habit of using `is_resource()` as a test to see if a connection was successfully
    established.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会遇到的问题是，PHP 8之前编写的代码假定*表7.1*中列出的函数返回一个*资源*。因此，聪明的开发人员习惯于使用`is_resource()`来测试连接是否成功建立。
- en: Although this was an extremely sensible way to check, this technique now introduces
    a backward-compatible code break after a PHP 8 upgrade. The following example
    demonstrates this issue.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个非常明智的检查方式，但在PHP 8升级后，这种技术现在引入了一个向后兼容的代码中断。以下示例演示了这个问题。
- en: 'In this code example, a `cURL` connection is initialized for an external website.
    The next few lines test for success using the `is_resource()` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，为一个外部网站初始化了一个`cURL`连接。接下来的几行代码使用`is_resource()`函数测试成功与否：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following output from PHP 7 shows success:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自PHP 7的输出，显示成功：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of the same code running in PHP 8 is not successful, as we can see
    here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中运行相同代码的输出并不成功，如下所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output from PHP 8 is deceptive in that a connection *has* been established!
    Because the program code is checking to see if the `cURL` handle is a resource,
    however, the code throws an `Exception` error. The reason for the failure is because
    a `CurlHandle` instance is returned rather than a resource.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从PHP 8的输出来看，连接已经建立了！但是，由于程序代码正在检查`cURL`句柄是否是一个资源，因此代码会抛出一个`Exception`错误。失败的原因是因为返回的是一个`CurlHandle`实例，而不是一个资源。
- en: 'In this situation, you can avoid a code break and have the code run successfully
    in both PHP 8 and any earlier PHP version by substituting `!empty()` (not empty)
    in place of `is_resource()`, as shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以通过在`is_resource()`的位置使用`!empty()`（非空）来避免代码中断，并使代码在PHP 8和任何早期的PHP版本中成功运行，如下所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is the output of the code example running in PHP 7:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PHP 7中运行代码示例的输出：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the same code example running in PHP 8:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PHP 8中运行相同代码示例的输出：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see from both outputs, the code runs successfully: in PHP 7, `$ch`
    is a *resource*. In PHP 8, `$ch` is a `CurlHandle` instance. Now that you understand
    the potential issue regarding `is_resource()`, let''s have a look at the advantages
    that stem from this change.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从这两个输出中可以看到，代码都成功运行了：在PHP 7中，`$ch`是一个*资源*。在PHP 8中，`$ch`是一个`CurlHandle`实例。现在您已经了解了关于`is_resource()`的潜在问题，让我们来看看这种变化带来的优势。
- en: Advantages of objects over resources
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象相对于资源的优势
- en: Prior to PHP 8, there was no way to provide a data type when passing a resource
    into or returning a resource out of a function or method. A clear advantage in
    producing objects rather than resources is that you can take advantage of object
    type hints.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8之前，没有办法在将资源传递到函数或方法中或从函数或方法中返回资源时提供数据类型。产生对象而不是资源的明显优势是，您可以利用对象类型提示。
- en: 'To illustrate this advantage, imagine a set of **HyperText Transfer Protocol**
    (**HTTP**) client classes that implement a **strategy software design pattern**.
    One strategy involves using the `cURL` extension to send a message. Another strategy
    uses PHP streams, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个优势，想象一组实现**策略软件设计模式**的**超文本传输协议**（**HTTP**）客户端类。其中一种策略涉及使用`cURL`扩展来发送消息。另一种策略使用PHP流，如下所示：
- en: 'We start by defining an `Http/Request` class. The class constructor parses
    the given URL into its component parts, as illustrated in the following code snippet:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个`Http/Request`类。类构造函数将给定的URL解析为其组成部分，如下所示的代码片段所示：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we define a `CurlStrategy` class that uses the `cURL` extension to send
    a message. Note that the `__construct()` method uses constructor-argument promotion.
    You might also note that we provide a `CurlHandle` data type for the `$handle`
    argument. This is a tremendous advantage only available in PHP 8, and it ensures
    that any program creating an instance of this strategy class must provide the
    correct resource data type. The code is illustrated in the following snippet:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`CurlStrategy`类，它使用`cURL`扩展来发送消息。请注意，`__construct()`方法使用了构造函数参数推广。您可能还注意到，我们为`$handle`参数提供了一个`CurlHandle`数据类型。这是PHP
    8中独有的巨大优势，它确保了创建此策略类实例的任何程序都必须提供正确的资源数据类型。代码如下所示：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then define the actual logic used to send the message, as follows:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义了用于发送消息的实际逻辑，如下所示：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can then do the same thing with a `StreamsStrategy` class. Again, note in
    the following code snippet how we can use a class as a constructor-argument type
    hint to ensure proper usage of the strategy:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以使用`StreamsStrategy`类做同样的事情。再次注意下面的代码片段中如何使用类作为构造函数参数类型提示，以确保正确使用该策略：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then define a calling program that invokes both strategies and delivers
    the results. After setting up autoloading, we create a new `Http\Request` instance,
    supplying an arbitrary URL as an argument, as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个调用程序，调用两种策略并提供结果。在设置自动加载后，我们创建一个新的`Http\Request`实例，并提供一个任意的URL作为参数，如下所示：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we define a `StreamsStrategy` instance and send the request, as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`StreamsStrategy`实例并发送请求，如下所示：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then define a `CurlStrategy` instance and send the same request, as illustrated
    in the following code snippet:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个`CurlStrategy`实例并发送相同的请求，如下所示的代码片段所示：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output from both strategies is identical. Partial output is shown here
    (note that this example can only be used in PHP 8!):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 两种策略的输出是相同的。这里显示了部分输出（请注意，此示例仅适用于PHP 8！）：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s now have a look at another aspect of resource-to-object migration: its
    effect on iteration.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看资源到对象迁移的另一个方面：它对迭代的影响。
- en: Traversable to IteratorAggregate migration
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Traversable到IteratorAggregate的迁移
- en: The **Traversable** interface was first introduced in PHP 5\. It has no methods
    and was mainly created to allow objects to iterate using a simple `foreach()`
    loop. As PHP development continues to evolve, a need often arises to obtain the
    inner iterator. Accordingly, in PHP 8, many classes that formerly implemented
    `Traversable` now implement `IteratorAggregate` instead.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**Traversable**接口首次在PHP 5中引入。它没有方法，主要是为了允许对象使用简单的`foreach()`循环进行迭代。随着PHP的发展不断演进，通常需要获取内部迭代器。因此，在PHP
    8中，许多以前实现`Traversable`的类现在改为实现`IteratorAggregate`。'
- en: 'This doesn''t mean that the enhanced classes no longer support the abilities
    inherent in the `Traversable` interface. Quite the contrary: `IteratorAggregate`
    extends `Traversable`! This enhancement means that you can now call `getIterator()`
    on an instance of any of the affected classes. This is potentially of immense
    benefit as prior to PHP 8, there was no way to access the inner iterator used
    in the various extensions. The following table summarizes the extensions and classes
    affected by this enhancement:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着增强的类不再支持`Traversable`接口固有的能力。相反，`IteratorAggregate`扩展了`Traversable`！这一增强意味着您现在可以在任何受影响的类的实例上调用`getIterator()`。这可能是巨大的好处，因为在PHP
    8之前，没有办法访问各种扩展中使用的内部迭代器。以下表总结了受此增强影响的扩展和类：
- en: '![Table 7.2 – Classes that now implement IteratorAggregate instead of Traversable'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![表7.2 - 现在实现IteratorAggregate而不是Traversable的类'
- en: '](image/Figure_7.2_B16231.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.2_B16231.jpg)'
- en: Table 7.2 – Classes that now implement IteratorAggregate instead of Traversable
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.2 - 现在实现IteratorAggregate而不是Traversable的类
- en: 'In this section, you were introduced to a significant change introduced in
    PHP 8: the trend toward using objects rather than resources. One of the advantages
    you learned is that objects allow you greater control as compared to resources.
    Another advantage covered in this section is that the movement in PHP 8 toward
    `IteratorAggregate` allows access to built-in iterators that were previously inaccessible.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了PHP 8中引入的一个重大变化：向对象而不是资源的趋势。您学到的一个优势是，与资源相比，对象允许您更好地控制。本节涵盖的另一个优势是，PHP
    8中向`IteratorAggregate`的转变允许访问以前无法访问的内置迭代器。
- en: We now turn our attention to changes to XML-based extensions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将注意力转向基于XML的扩展的变化。
- en: Learning about changes to XML extensions
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习关于XML扩展的变化
- en: XML version 1.0 was introduced as a **World Wide Web Consortium** (**W3C**)
    specification in 1998\. XML bears some resemblance to **HyperText Markup Language**
    (**HTML**); however, the main purpose of XML is to provide a way to format data
    that's readable to both machines and humans. One of the reasons why XML is still
    widely used is because it's easily understandable and does a stellar job at representing
    tree-structured data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: XML版本1.0于1998年作为**万维网联盟**（**W3C**）规范引入。XML与**超文本标记语言**（**HTML**）有些相似；然而，XML的主要目的是提供一种使数据对机器和人类都可读的格式化方式。XML仍然被广泛使用的原因之一是因为它易于理解，并且在表示树形数据方面表现出色。
- en: PHP provides a number of extensions that allow you to both consume and produce
    XML documents. There have been a few changes introduced to many of these extensions
    in PHP 8\. For the most part, these changes are minor; however, it's important
    to be aware of these changes if you wish to be a well-rounded and informed PHP
    developer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: PHP提供了许多扩展，允许您消耗和生成XML文档。在PHP 8中，对许多这些扩展进行了一些更改。在大多数情况下，这些更改都很小；然而，如果您希望成为一个全面了解的PHP开发人员，了解这些更改是很重要的。
- en: Let's first have a look at changes to the `XMLWriter` extension.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下对`XMLWriter`扩展的变化。
- en: Examining XMLWriter extension differences
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查XMLWriter扩展的差异
- en: 'All `XMLWriter` extension procedural functions now accept and return `XMLWriter`
    objects instead of resources. If you have a look at the official PHP documentation
    for the `XMLWriter` extension, however, you''ll see no references to the procedural
    functions. The reason for this is twofold: first, the PHP language is slowly moving
    away from discrete procedural functions in favor of **object-oriented programming**
    (**OOP**).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`XMLWriter`扩展的过程式函数现在接受并返回`XMLWriter`对象，而不是资源。然而，如果您查看`XMLWriter`扩展的官方PHP文档，您将看不到有关过程式函数的引用。原因有两个：首先，PHP语言正在逐渐摆脱离散的过程式函数，转而支持**面向对象编程**（**OOP**）。
- en: The second reason is that `XMLWriter` procedural functions are in reality just
    wrappers for `XMLWriter` OOP methods! As an example, `xmlwriter_open_memory()`
    is a wrapper for `XMLWriter::openMemory()`, `xmlwriter_text()` is a wrapper for
    `XMLWriter::text()`, and so forth.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因是，`XMLWriter`过程式函数实际上只是`XMLWriter` OOP方法的包装！例如，`xmlwriter_open_memory()`是`XMLWriter::openMemory()`的包装，`xmlwriter_text()`是`XMLWriter::text()`的包装，依此类推。
- en: If you are really set on using the `XMLWriter` extension using procedural programming
    techniques, `xmlwriter_open_memory()` creates an `XMLWriter` instance in PHP 8
    rather than a resource. Likewise, all `XMLWriter` extension procedural functions
    work with `XMLWriter` instances rather than resources.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的打算使用过程式编程技术使用`XMLWriter`扩展，`xmlwriter_open_memory()`在PHP 8中创建一个`XMLWriter`实例，而不是一个资源。同样，所有`XMLWriter`扩展的过程式函数都使用`XMLWriter`实例而不是资源。
- en: 'As with any of the extensions mentioned in this chapter that now produce object
    instances rather than resources, a potential backward-compatible break is possible.
    An example of such a break would be where you are using `XMLWriter` procedural
    functions and `is_resource()` to check to see if a resource has been created.
    We do not show you an example here, as the problem and the solution are the same
    as described in the previous section: use `!empty()` instead of `is_resource()`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中提到的任何扩展一样，现在产生对象实例而不是资源的潜在向后兼容性破坏是可能的。这种破坏的一个例子是，当您使用`XMLWriter`过程函数和`is_resource()`来检查是否已创建资源时。我们在这里没有向您展示一个例子，因为问题和解决方案与前一节中描述的相同：使用`!empty()`而不是`is_resource()`。
- en: 'It is a *best practice* to use the `XMLWriter` extension OOP **application
    programming interface** (**API**) instead of the procedural API. Fortunately,
    the OOP API has been available since PHP 5.1\. Here is a sample XML file to be
    used in the next example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`XMLWriter`扩展的OOP **应用程序编程接口**（**API**）而不是过程API是一种*最佳实践*。幸运的是，OOP API自PHP
    5.1以来就已经可用。以下是下一个示例中要使用的示例XML文件：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The example shown here works in both PHP 7 and 8\. The purpose of this example
    is to use the `XMLWriter` extension to build the XML document shown previously.
    Here are the steps to accomplish this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的示例在PHP 7和8中都可以工作。此示例的目的是使用`XMLWriter`扩展来构建先前显示的XML文档。以下是完成此操作的步骤：
- en: 'We start by creating an `XMLWriter` instance. We then open a connection to
    shared memory and initialize the XML document type, as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个`XMLWriter`实例。然后打开到共享内存的连接，并初始化XML文档类型，如下所示：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Following this, we use `startElement()` to initialize the `fruit` root node,
    and add a child node item that has a value of `Apple`, as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`startElement()`来初始化`fruit`根节点，并添加一个值为`Apple`的子节点项，如下所示：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we add another child node item that has a value of `Banana`, as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加另一个值为`Banana`的子节点项，如下所示：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we close the `fruit` root node and end the XML document. The last
    command in the following code snippet displays the current XML document:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们关闭`fruit`根节点并结束XML文档。以下代码片段中的最后一个命令显示当前的XML文档：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the output of the example program running in PHP 7:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PHP 7中运行的示例程序的输出：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the desired XML document is produced. If we run the same program
    in PHP 8, the results are identical (not shown).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，生成了所需的XML文档。如果我们在PHP 8中运行相同的程序，结果是相同的（未显示）。
- en: We now turn our attention to changes to the `SimpleXML` extension.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将注意力转向`SimpleXML`扩展的更改。
- en: Working with changes to the SimpleXML extension
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理SimpleXML扩展的更改
- en: The `SimpleXML` extension is object-oriented and is widely used. Accordingly,
    it's vital that you learn about a couple of significant changes made to this extension
    in PHP 8\. The good news is that you won't have to rewrite any code! The even
    better news is that the changes substantially improve `SimpleXML` extension functionality.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleXML`扩展是面向对象的，被广泛使用。因此，了解在PHP 8中对该扩展进行的一些重大更改是至关重要的。好消息是，您不需要重写任何代码！更好的消息是，这些更改大大改善了`SimpleXML`扩展的功能。'
- en: As of PHP 8, the `SimpleXMLElement` class now implements the **Standard PHP
    Library** (**SPL**) `RecursiveIterator` interface and includes the functionality
    of the `SimpleXMLIterator` class. In PHP 8, `SimpleXMLIterator` is now an empty
    extension of `SimpleXMLElement`. This seemingly simple update assumes major significance
    when you consider that XML is often used to represent complex tree-structured
    data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从PHP 8开始，`SimpleXMLElement`类现在实现了**标准PHP库**（**SPL**）`RecursiveIterator`接口，并包括`SimpleXMLIterator`类的功能。在PHP
    8中，`SimpleXMLIterator`现在是`SimpleXMLElement`的一个空扩展。这个看似简单的更新在考虑到XML通常用于表示复杂的树形数据时具有重大意义。
- en: 'As an example, have a look at a partial view of a family tree for the *House
    of Windsor*, shown here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看一下*温莎王室*家族树的部分视图，如下所示：
- en: '![Figure 7.1 – Example of complex tree-structured data'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 - 复杂树形数据的示例'
- en: '](image/Figure_7.3_B16231.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.3_B16231.jpg)'
- en: Figure 7.1 – Example of complex tree-structured data
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 - 复杂树形数据的示例
- en: 'If we were to model this using XML, the document might look like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用XML对其进行建模，文档可能如下所示：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then develop code to parse the tree. In versions of PHP before PHP 8, however,
    we need to define a recursive function in order to parse the entire tree. To do
    so, we''ll follow these next steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们编写代码来解析树。然而，在PHP 8之前的版本中，我们需要定义一个递归函数来解析整个树。为此，我们将按照以下步骤进行：
- en: 'We start by defining a recursive function that displays the descendant''s name
    and spouse (if any), as illustrated in the following code snippet. This function
    also identifies the descendant''s gender and checks to see if there are any children.
    If the latter is `true`, the function then calls itself:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个递归函数，显示后代的姓名和配偶（如果有），如下面的代码片段所示。该函数还识别后代的性别，并检查是否有子女。如果后者为`true`，则函数会调用自身：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We then create a `SimpleXMLElement` instance from the external XML file and
    call the recursive function, as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们从外部XML文件创建一个`SimpleXMLElement`实例，并调用递归函数，如下所示：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code block works in both PHP 7 and PHP 8\. Here is the output running
    in PHP 7:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码块在PHP 7和PHP 8中都可以工作。以下是在PHP 7中运行的输出：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In PHP 8, however, because `SimpleXMLElement` now implements `RecursiveIterator`,
    the code to produce the same results is simpler.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PHP 8中，由于`SimpleXMLElement`现在实现了`RecursiveIterator`，生成相同结果的代码更简单了。
- en: 'As with the example shown earlier, we define a `SimpleXMLElement` instance
    from an external file. There is no need to define a recursive function, however—
    all we need to do is define a `RecursiveIteratorIterator` instance, as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前显示的示例一样，我们从外部文件定义了一个`SimpleXMLElement`实例。但是，我们无需定义递归函数，我们只需要定义一个`RecursiveIteratorIterator`实例，如下所示：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After that, all we need is a simple `foreach()` loop, with the same internal
    logic as in the preceding example. There''s no need to check to see if a branch
    node exists, nor is there a need for recursion—that''s taken care of by the `RecursiveIteratorIterator`
    instance! The code you''ll need is illustrated here:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们只需要一个简单的`foreach()`循环，内部逻辑与前面的示例相同。无需检查分支节点是否存在，也不需要递归 - 这由`RecursiveIteratorIterator`实例处理！您需要的代码如下所示：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output from this code example running in PHP 8 is shown here. As you can
    see, the output is exactly the same:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中运行此代码示例的输出如下所示。如您所见，输出完全相同：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Important note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please note as you run these examples using the Docker containers that the output
    shown here has been slightly modified to fit the page width.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在使用Docker容器运行这些示例时，这里显示的输出已经稍作修改以适应页面宽度。
- en: Let's now have a look at other XML extension changes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看其他XML扩展的更改。
- en: Understanding other XML extension changes
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解其他XML扩展的更改
- en: There have been a number of changes to other PHP 8 XML extensions. For the most
    part, the changes are minor and do not present a significant potential for a backward-compatible
    code break. However, we would be remiss if we did not address these additional
    changes. We recommend that you go through the remaining changes present in this
    subsection so that your awareness is raised. Using these XML extensions will empower
    you to troubleshoot application code that is behaving inconsistently after a PHP
    8 update.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 其他PHP 8 XML扩展已经进行了一些更改。在大多数情况下，这些更改都很小，并且不会对向后兼容的代码造成重大潜在破坏。然而，如果我们不解决这些额外的更改，那就不尽职了。我们建议您查看本小节中的其余更改，以提高您的意识。使用这些XML扩展将使您能够在PHP
    8更新后更有效地排除应用程序代码的不一致行为。
- en: Changes to the libxml extension
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: libxml扩展的更改
- en: The **libxml** extension leverages the **Expat C library**, providing XML parsing
    functions used by the various PHP XML extensions ([https://libexpat.github.io/](https://libexpat.github.io/)).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**libxml**扩展利用**Expat C库**，提供了各种PHP XML扩展使用的XML解析功能（[https://libexpat.github.io/](https://libexpat.github.io/)）。'
- en: There is a new requirement for the version of `libxml` installed on your server.
    The minimum version when running PHP 8 must be 2.9.0 (or above). One of the major
    benefits of this updated requirement is to increase protection against **XML external
    entity** (**XXE**) processing attacks.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您的服务器上安装的`libxml`版本有新的要求。在运行PHP 8时，最低版本必须为2.9.0（或更高）。此更新要求的主要好处之一是增加对**XML外部实体**（**XXE**）处理攻击的保护。
- en: The recommended minimum version of `libxml` disables the ability of PHP XML
    extensions that rely upon the `libxml` extension to load external XML entities
    by default. This, in turn, reduces the need for costly and time-consuming extra
    steps to protect against XXE attacks.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的`libxml`最低版本禁用了依赖`libxml`扩展加载外部XML实体的PHP XML扩展的能力。这反过来减少了对XXE攻击的昂贵和耗时的额外步骤的需求。
- en: Tip
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on XXE attacks, consult the **Open Web Application Security
    Project** (**OWASP**) using this link: [https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing](https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有关XXE攻击的更多信息，请参阅**开放式Web应用安全项目**（**OWASP**）[https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing](https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing)。
- en: Changes to the XMLReader extension
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XMLReader扩展的更改
- en: The `XMLReader` extension complements the `XMLWriter` extension. Where the `XMLWriter`
    extension is designed to produce an XML document, the `XMLReader` extension is
    designed to read.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLReader`扩展补充了`XMLWriter`扩展。`XMLWriter`扩展旨在生成XML文档，而`XMLReader`扩展旨在读取。'
- en: Two methods, `XMLReader::open()` and `XMLReader::xml()`, are now defined as
    **static methods**. You can still create `XMLReader` instances, but if you extend
    `XMLReader` and override either of these methods, be sure to declare them as static.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`XMLReader::open()`和`XMLReader::xml()`两个方法被定义为**静态方法**。您仍然可以创建`XMLReader`实例，但如果您扩展`XMLReader`并覆盖其中任何一个方法，请确保将它们声明为静态方法。
- en: Changes to the XMLParser extension
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XMLParser扩展的更改
- en: The `XMLParser` extension is one of the oldest PHP XML extensions. Accordingly,
    it almost entirely consists of procedural functions rather than classes and methods.
    In PHP 8, however, this extension follows a trend toward producing objects rather
    than resources. Thus, when you run `xml_parser_create()` or `xml_parser_create_ns()`,
    an `XMLParser` instance is created rather than a resource.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLParser`扩展是最古老的PHP XML扩展之一。因此，它几乎完全由过程函数组成，而不是类和方法。然而，在PHP 8中，这个扩展遵循了向生成对象而不是资源的趋势。因此，当您运行`xml_parser_create()`或`xml_parser_create_ns()`时，将创建一个`XMLParser`实例，而不是一个资源。'
- en: As mentioned in the *Potential code break involving is_resource()* section,
    all you need to do is to replace any checks using `is_resource()` with `!empty()`
    instead. Another side effect of resource-to-object migration is to make redundant
    the `xml_parser_free()` function. To deactivate the parser, simply use the `XmlParser`
    object.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如在*涉及is_resource()的潜在代码破坏*部分中所述，您只需要用`!empty()`替换任何使用`is_resource()`的检查。资源到对象迁移的另一个副作用是使`xml_parser_free()`函数变得多余。要停用解析器，只需使用`XmlParser`对象。
- en: Now that you have an understanding of the changes associated with XML extensions,
    this will help you to more efficiently parse and otherwise manage XML data. By
    taking advantage of the new features mentioned in this section, you can produce
    code that's much more efficient and that offers better performance than was possible
    prior to PHP 8\. Let's now have a look at the `mbstring` extension.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了与XML扩展相关的更改，这将帮助您更有效地解析和管理XML数据。通过利用本节中提到的新功能，您可以编写比在PHP 8之前更高效并且性能更好的代码。现在让我们来看看`mbstring`扩展。
- en: Avoiding problems with the updated mbstring extension
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免与更新后的mbstring扩展出现问题
- en: The `mbstring` extension was first introduced in PHP 4 and has been an active
    part of the language ever since. The original purpose of this extension was to
    provide support for the various Japanese character-encoding systems. Since that
    time, support for a wide variety of other encodings has been added—most notably,
    support for encodings based upon **Universal Coded Character Set 2** (**UCS-2**),
    **UCS-4**, **Unicode Transformation Format 8** (**UTF-8**), **UTF-16**, **UTF-32**,
    **Shift Japanese Industrial Standards** (**SJIS**), and **International Organization
    for Standardization 8859** (**ISO-8859**), among others.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`mbstring`扩展首次引入于PHP 4，并且自那时以来一直是语言的活跃部分。该扩展的最初目的是为各种日语字符编码系统提供支持。自那时以来，已添加了对各种其他编码的支持，其中最显着的是对基于**通用编码字符集2**（**UCS-2**）、**UCS-4**、**Unicode转换格式8**（**UTF-8**）、**UTF-16**、**UTF-32**、**Shift日本工业标准**（**SJIS**）和**国际标准化组织8859**（**ISO-8859**）等编码的支持。'
- en: 'If you aren''t sure which encodings are supported on your server, just run
    the `mb_list_encodings()` command, as follows (partial output shown):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定服务器支持哪些编码，只需运行`mb_list_encodings()`命令，如下所示（显示部分输出）：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see from the preceding output, in the PHP 7.1 Docker container we
    use for the book, 87 encodings are supported. In the PHP 8.0 Docker container
    (output not shown), 80 encodings are supported. Let's now have a look at the changes
    introduced in PHP 8, starting with the `mb_str*()` functions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看出，在我们用于本书的PHP 7.1 Docker容器中，支持87种编码。在PHP 8.0 Docker容器中（未显示输出），支持80种编码。现在让我们来看一下PHP
    8中引入的更改，首先是`mb_str*()`函数。
- en: Discovering needle-argument differences in mb_str*() functions
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现`mb_str*()`函数中的needle-argument差异
- en: In [*Chapter 6*](B16992_06_Final_JC_ePub.xhtml#_idTextAnchor129), *Understanding
    PHP 8 Functional Differences*, you learned how PHP 8 introduced changes to **needle-argument
    handling** in the core `str*pos()`, `str*str()`, and `str*chr()` functions. The
    two primary needle-argument differences are the ability to accept an empty needle
    argument and strict type checking to ensure the needle argument is a string only.
    In order to maintain consistency, PHP 8 introduces the same changes in the corresponding
    `mb_str*()` functions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B16992_06_Final_JC_ePub.xhtml#_idTextAnchor129)中，*了解PHP 8的功能差异*，您了解到PHP
    8如何改变了核心`str*pos()`、`str*str()`和`str*chr()`函数中的**needle-argument处理**。两个主要的needle-argument差异是能够接受空的needle参数和严格的类型检查，以确保needle参数只是一个字符串。为了保持一致性，PHP
    8在相应的`mb_str*()`函数中引入了相同的更改。
- en: Let's have a look at empty needle-argument handling first.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下空的needle-argument处理。
- en: mb_str*() function empty needle-argument handling
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`mb_str*()`函数空needle-argument处理'
- en: 'To keep the `mbstring` extension in line with this change to the core string
    functions, the following `mbstring` extension functions now allow an empty needle
    argument. It''s important to note that this doesn''t mean the argument can be
    omitted or is optional! What is meant by this change is that any value supplied
    as the needle argument can now also include what is considered *empty*. A good,
    quick way to learn what PHP considers to be empty can be found in the documentation
    for the `empty()` function ([https://www.php.net/empty](https://www.php.net/empty)).
    Here is a list of `mbstring` functions that now allow an empty needle-argument
    value:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`mbstring`扩展与核心字符串函数的更改保持一致，以下`mbstring`扩展函数现在允许空的needle参数。重要的是要注意，这并不意味着参数可以被省略或是可选的！这个更改的意思是，作为needle参数提供的任何值现在也可以包括被认为是*空*的值。了解PHP认为什么是空的一个好而快速的方法可以在`empty()`函数的文档中找到（[https://www.php.net/empty](https://www.php.net/empty)）。以下是现在允许空的needle-argument值的`mbstring`函数列表：
- en: '`mb_strpos()`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mb_strpos()`'
- en: '`mb_strrpos()`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mb_strrpos()`'
- en: '`mb_stripos()`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mb_stripos()`'
- en: '`mb_strripos()`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mb_strripos()`'
- en: '`mb_strstr()`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mb_strstr()`'
- en: '`mb_stristr()`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mb_stristr()`'
- en: '`mb_strrchr()`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mb_strrchr()`'
- en: '`mb_strrichr()`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mb_strrichr（）
- en: Tip
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Each of the eight `mbstring` extension functions mentioned here exactly parallels
    its core PHP counterpart function. For more information on these functions, have
    a look at this reference documentation: [https://www.php.net/manual/en/ref.mbstring.php](https://www.php.net/manual/en/ref.mbstring.php).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的八个`mbstring`扩展函数与其核心PHP对应函数完全相同。有关这些函数的更多信息，请参阅此参考文档：[https://www.php.net/manual/en/ref.mbstring.php](https://www.php.net/manual/en/ref.mbstring.php)。
- en: 'The short code example that follows illustrates empty needle handling in the
    eight aforementioned functions. Here are the steps leading to this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的简短代码示例说明了上述八个函数中的空needle处理。以下是导致这一步的步骤：
- en: 'First, we initialize a multi-byte text string. In the following example, this
    is a Thai language translation of *The quick brown fox jumped over the fence*.
    The needle argument is set to `NULL`, and an array of functions to test is initialized:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们初始化一个多字节文本字符串。在下面的示例中，这是*快速的棕色狐狸跳过了篱笆*的泰语翻译。needle参数设置为`NULL`，并初始化要测试的函数数组：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then define a `printf()` pattern, and loop through the functions to be tested.
    For each function call, we supply the text followed by an empty needle argument,
    as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个`printf()`模式，并循环遍历要测试的函数。对于每个函数调用，我们提供文本，然后是一个空的needle参数，如下所示：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output from PHP 7 is shown here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7的输出如下所示：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see, the output is blank, and, in some cases, a `Warning` message
    is issued. The output running in PHP 8 is radically different, as expected, as
    we can see here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，输出为空，并且在某些情况下会发出`Warning`消息。PHP 8中的输出与预期的完全不同，如下所示：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It's interesting to note that when this code runs in PHP 8, an empty needle
    argument returns a value of integer `0` for `mb_strpos()` and `mb_stripos()`,
    and integer `46` for `mb_strrpos()` and `mb_strripos()`. In PHP 8, an empty needle
    argument is interpreted as either the beginning or end of the string in this case.
    The result for both `mb_strstr()` and `mb_stristr()` is the entire string.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，当这段代码在PHP 8中运行时，空的针参数对于`mb_strpos()`和`mb_stripos()`返回整数`0`，对于`mb_strrpos()`和`mb_strripos()`返回整数`46`。在PHP
    8中，空的针参数在这种情况下被解释为字符串的开头或结尾。对于`mb_strstr()`和`mb_stristr()`的结果是整个字符串。
- en: mb_str*() function data type checking
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mb_str*()函数数据类型检查
- en: To maintain alignment with the core `str*()` functions, the needle argument
    must be of type string in the corresponding `mb_str*()` functions. If you supply
    an **American Standard Code for Information Interchange** (**ASCII**) value instead
    of a string, the affected functions will now throw an `ArgumentTypeError` error.
    No example is shown in this subsection, as [*Chapter 6*](B16992_06_Final_JC_ePub.xhtml#_idTextAnchor129),
    *Understanding PHP 8 Functional Differences,* already provides an example of this
    difference in the core `str*()` functions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与核心`str*()`函数保持一致，相应的`mb_str*()`函数中的针参数必须是字符串类型。如果你提供的是**美国信息交换标准代码**（ASCII）值而不是字符串，受影响的函数现在会抛出`ArgumentTypeError`错误。本小节不提供示例，因为[*第6章*]（B16992_06_Final_JC_ePub.xhtml#_idTextAnchor129），*理解PHP
    8的功能差异*，已经提供了核心`str*()`函数中这种差异的示例。
- en: Differences in mb_strrpos()
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mb_strrpos()的差异
- en: In earlier versions of PHP, you were allowed to pass a character encoding as
    a third argument to `mb_strrpos()` instead of an offset. This bad practice is
    no longer supported in PHP 8\. Instead, you can either supply `0` as a third argument
    or consider using PHP 8 *named arguments* (discussed in [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013),
    *Introducing New PHP 8 OOP Features*, in the *Understanding named arguments* section)
    to avoid having to supply a value as an optional parameter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的PHP版本中，你可以将字符编码作为`mb_strrpos()`的第三个参数而不是偏移量。这种不良做法在PHP 8中不再支持。相反，你可以将`0`作为第三个参数，或者考虑使用PHP
    8的*命名参数*（在[*第1章*]（B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013），*介绍新的PHP 8面向对象特性*，*理解命名参数*部分讨论）来避免必须提供一个可选参数的值。
- en: 'Let''s now look at a code example that demonstrates the differences in handling
    between PHP 7 and PHP 8\. Proceed as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看一个代码示例，演示了PHP 7和PHP 8处理方式的差异。按照以下步骤进行：
- en: 'We first define a constant to represent the character encoding we wish to use.
    A text string representing a Thai language translation for *The quick brown fox
    jumped over the fence* is assigned. We then use `mb_convert_encoding()` to ensure
    the correct encoding is used. The code is illustrated in the following snippet:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个常量来表示我们希望使用的字符编码。分配一个代表*The quick brown fox jumped over the fence*泰语翻译的文本字符串。然后我们使用`mb_convert_encoding()`来确保使用正确的编码。代码如下所示：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We then assign the Thai language translation of *fence* to `$needle` and echo
    the length of the string and the position of `$needle` in the text. We then invoke
    `mb_strrpos()` to find the last occurrence of `$needle`. Note in the following
    code snippet that we deliberately follow the bad practice of using the encoding
    as a third argument rather than an offset:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将*fence*的泰语翻译分配给`$needle`，并输出字符串的长度和`$needle`在文本中的位置。然后我们调用`mb_strrpos()`来找到`$needle`的最后一次出现。请注意在以下代码片段中，我们故意遵循了使用编码作为第三个参数而不是偏移量的不良做法：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output of this code example works perfectly in PHP 7, as we can see here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例在PHP 7中完美运行，如下所示：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see from the preceding output, the length of the multi-byte string
    is `46`, and the position of the needle is `30`. In PHP 8, on the other hand,
    we end up with a fatal `Uncaught TypeError` message, as seen here:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看到，多字节字符串的长度为`46`，针的位置为`30`。然而，在PHP 8中，我们得到了一个致命的`Uncaught TypeError`消息，如下所示：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see from the PHP 8 output, the third argument for `mb_strrpos()`
    must be an offset value in the form of an integer. A simple way to rewrite this
    example would be to take advantage of PHP 8 *named arguments*. Here is the rewritten
    line of code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从PHP 8的输出中可以看到，`mb_strrpos()`的第三个参数必须是一个整数形式的偏移值。重写这个例子的一个简单方法是利用PHP 8的*命名参数*。以下是重写的代码行：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The output is identical to the PHP 7 example and is not shown here. Let's now
    turn our attention to `mbstring` extension's **regular expression** (**regex**)-handling
    differences.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与PHP 7示例相同，这里不再显示。现在让我们转向`mbstring`扩展的**正则表达式**（**regex**）处理差异。
- en: Examining changes to mb_ereg*() functions
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查mb_ereg*()函数的变化
- en: The `mb_ereg*()` family of functions allows **regex** processing of strings
    encoded using multi-byte character sets. In contrast, the core PHP language provides
    the **Perl Compatible Regular Expressions** (**PCRE**) family of functions, with
    modern and more up-to-date functionality.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`mb_ereg*()`函数族允许对使用多字节字符集编码的字符串进行**regex**处理。相比之下，核心PHP语言提供了现代和更为更新的功能的**Perl兼容正则表达式**（**PCRE**）函数族。'
- en: If you add a `u` (lowercase letter *U*) modifier to a regex pattern when using
    the PCRE functions, any **UTF-8** encoded multi-byte character string is accepted.
    However, UTF-8 is the *only* multi-byte character encoding accepted. If you are
    dealing with other character encodings and wish to perform regex functionality,
    you will need to either convert to UTF-8 or use the `mb_ereg*()` family of functions.
    Let's now have a look at a number of changes to the `mb_ereg*()` family of functions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用PCRE函数时，如果在正则表达式模式中添加`u`（小写字母U）修饰符，则接受任何UTF-8编码的多字节字符串。然而，UTF-8是唯一被接受的多字节字符编码。如果你处理其他字符编码并希望执行正则表达式功能，你需要将其转换为UTF-8，或者使用`mb_ereg*()`函数族。现在让我们看看`mb_ereg*()`函数族的一些变化。
- en: Oniguruma library required in PHP 8
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP 8中需要Oniguruma库
- en: One change to this family of functions is in how your PHP installation is compiled.
    In PHP 8, your operating system must provide the `libonig` library. This library
    provides **Oniguruma** functionality. (See https://github.com/kkos/oniguruma for
    more information.) The older `--with-onig` PHP source-compile-configure option
    has been removed in favor of using `pkg-config` to detect `libonig`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这一系列函数的一个变化是你的PHP安装是如何编译的。在PHP 8中，你的操作系统必须提供`libonig`库。这个库提供了**Oniguruma**功能。（更多信息请参见https://github.com/kkos/oniguruma。）旧的`--with-onig`PHP源码编译配置选项已经被移除，取而代之的是使用`pkg-config`来检测`libonig`。
- en: Changes to mb_ereg_replace()
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mb_ereg_replace()的变化
- en: Formerly, you were able to supply an integer as an argument to `mb_ereg_replace()`.
    This argument was interpreted as an **ASCII code point**. In PHP 8, such an argument
    is now typecast as `string`. If you need an ASCII code point, you need to use
    `mb_chr()` instead. As the typecast to `string` is done silently, there is a potential
    backward-compatible code break, in that you won't see any `Notice` or `Warning`
    messages.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，你可以将整数作为`mb_ereg_replace()`的参数。这个参数被解释为**ASCII码点**。在PHP 8中，这样的参数现在被强制转换为`string`。如果你需要ASCII码点，你需要使用`mb_chr()`。由于强制转换为`string`是静默进行的，这可能会导致向后兼容的代码中断，因为你不会看到任何`Notice`或`Warning`消息。
- en: 'The following program code example illustrates the differences between PHP
    7 and PHP 8\. We''ll follow these next steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序代码示例说明了PHP 7和PHP 8之间的区别。我们将按照以下步骤进行：
- en: 'First, we define the encoding to be used and assign the Thai translation of
    *Two quick brown foxes jumped over the fence* as a multi-byte string to `$text`.
    Next, we use `mb_convert_encoding()` to ensure that the proper encoding is used.
    We then set `mb_ereg*` to the chosen encoding, using `mb_regex_encoding()`. The
    code is illustrated in the following snippet:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义要使用的编码，并将“Two quick brown foxes jumped over the fence”的泰语翻译作为多字节字符串赋给`$text`。接下来，我们使用`mb_convert_encoding()`来确保使用正确的编码。然后，我们使用`mb_regex_encoding()`将`mb_ereg*`设置为所选的编码。代码如下所示：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We then call `mb_ereg_replace()` and supply as a first argument an integer
    value `50`, and replace it with the string `"3"`. Both the original and modified
    strings are echoed. You can view the code here:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们调用`mb_ereg_replace()`，并将整数值`50`作为第一个参数，并用字符串`"3"`替换它。原始字符串和修改后的字符串都被输出。你可以在这里查看代码：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that the first argument for `mb_ereg_replace()` should be a string, but
    we supply an integer instead. In versions of the `mbstring` extension prior to
    PHP 8, if an integer is supplied as the first argument, it's treated as an ASCII
    code point.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`mb_ereg_replace()`的第一个参数应该是一个字符串，但我们却提供了一个整数。在PHP 8之前的`mbstring`扩展版本中，如果提供整数作为第一个参数，它会被视为ASCII码点。
- en: 'If we run this code example in PHP 7, the number `50` is interpreted as the
    ASCII code point value for `"2"`, as expected, as we can see here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在PHP 7中运行这个代码示例，数字`50`会被解释为`"2"`的ASCII码点值，正如我们所期望的那样，如下所示：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you can see from the preceding output, the number `2` is replaced by the
    number `3`. In PHP 8, however, the number `50` is typecast into a string. As this
    source string doesn''t contain the number `50`, no replacements are made, as we
    can see here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看到，数字`2`被数字`3`替换。然而，在PHP 8中，数字`50`被强制转换为字符串。由于源字符串不包含数字`50`，所以没有进行替换，如下所示：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The danger here is that if your code relies upon this silent interpretation
    process, your application might either fail or exhibit inconsistent behavior.
    You'll also note a lack of `Notice` or `Warning` messages. PHP 8 relies upon the
    developer to supply the correct arguments!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的危险在于，如果你的代码依赖于这种静默解释过程，你的应用可能会失败或表现出不一致的行为。你还会注意到缺少`Notice`或`Warning`消息。PHP
    8依赖于开发人员提供正确的参数！
- en: 'The *best practice*, if you do actually need to use an ASCII code point, is
    to use `mb_chr()` to produce the desired search string. The modified code example
    might look like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*最佳实践*，如果你确实需要使用ASCII码点，就要使用`mb_chr()`来生成所需的搜索字符串。修改后的代码示例可能如下所示：'
- en: '`$mod1 = mb_ereg_replace(mb_chr(50), ''3'', $str);`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`$mod1 = mb_ereg_replace(mb_chr(50), ''3'', $str);`'
- en: You now have an idea about what changed in the `mbstring` extension. Without
    this information, you could easily end up writing faulty code. Developers who
    are unaware of this information might end up making mistakes in PHP 8, such as
    assuming the `mbstring` aliases are still in place. Such mistaken understanding
    can easily cause hours of lost time tracking down errors in program code following
    a PHP 8 migration.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了`mbstring`扩展中的变化。没有这些信息，你可能会轻易地写出错误的代码。不了解这些信息的开发人员可能会在PHP 8中犯错，比如假设`mbstring`的别名仍然存在。这样错误的理解很容易导致在PHP
    8迁移后花费数小时来追踪程序代码中的错误。
- en: 'It''s now time to have a look at another extension with major changes: the
    GD extension.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看另一个有重大变化的扩展了：GD扩展。
- en: Dealing with changes to the GD extension
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理GD扩展的变化
- en: The **GD extension** is an image-manipulation extension that leverages the `GD`
    library. GD originally stood for **GIF Draw**. Oddly, the `GD` library had to
    withdraw support for the **Graphics Interchange Format** (**GIF**) after Unisys
    revoked the open source license for the compression technology used when generating
    GIFs. After 2004, however, the Unisys patent on this technology expired and GIF
    support was restored. As it stands today, the PHP `GD` extension offers support
    for the **Joint Photographic Experts Group** (**JPEG** or **JPG**), **Portable
    Network Graphic** (**PNG**), **GIF**, **X BitMap** (**XBM**), **X PixMap** (**XPM**),
    **Wireless Bitmap** (**WBMP**), **WebP**, and **Bitmap** (**BMP**) formats.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**GD扩展**是一个图像处理扩展，利用了`GD`库。GD最初代表**GIF Draw**。奇怪的是，`GD`库在Unisys撤销生成GIF时使用的压缩技术的开源许可证后，不得不撤回对**Graphics
    Interchange Format**（**GIF**）的支持。然而，2004年之后，Unisys对这项技术的专利已经过期，GIF支持得以恢复。截至目前，PHP
    `GD`扩展支持**Joint Photographic Experts Group**（**JPEG**或**JPG**）、**Portable Network
    Graphic**（**PNG**）、**GIF**、**X BitMap**（**XBM**）、**X PixMap**（**XPM**）、**Wireless
    Bitmap**（**WBMP**）、**WebP**和**Bitmap**（**BMP**）格式。'
- en: Tip
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: For more information on the GD library, see [https://libgd.github.io/](https://libgd.github.io/).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有关GD库的更多信息，请参阅[https://libgd.github.io/](https://libgd.github.io/)。
- en: Let's now have a look at the impact of resource-to-object migration on the `GD`
    extension.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看资源到对象迁移对`GD`扩展的影响。
- en: GD extension resource-to-object migration
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GD扩展资源到对象迁移
- en: As with other PHP extensions that previously used *resources*, the `GD` extension
    has also primarily migrated from `resource` to `object`. As mentioned in the *PHP
    8 extension resource-to-object migration* section, all of the `imagecreate*()`
    functions now produce `GdImage` objects rather than resources.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前使用*资源*的其他PHP扩展一样，`GD`扩展也主要从`resource`迁移到`object`。如*PHP 8扩展资源到对象迁移*部分所述，所有`imagecreate*()`函数现在产生`GdImage`对象而不是资源。
- en: 'For an example of how this might present a code break after a PHP 8 migration,
    run these examples in two different browser tabs (on your local computer) and
    compare the difference. First, we run the PHP 7 example using this URL: [http://172.16.0.77/ch07/php7_gd_is_resource.php](http://172.16.0.77/ch07/php7_gd_is_resource.php).
    Here is the result:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，这可能在PHP 8迁移后导致代码中断，可以在两个不同的浏览器标签中运行这些示例（在本地计算机上），并比较差异。首先，我们使用此URL运行PHP
    7示例：[http://172.16.0.77/ch07/php7_gd_is_resource.php](http://172.16.0.77/ch07/php7_gd_is_resource.php)。这是结果：
- en: '![Figure 7.2 – PHP 7 GD image resource'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 - PHP 7 GD图像资源'
- en: '](image/Figure_7.4_B16231.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.4_B16231.jpg)'
- en: Figure 7.2 – PHP 7 GD image resource
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 - PHP 7 GD图像资源
- en: 'As you can see from the preceding output, a `resource` extension is identified,
    but there''s no descriptive information. Now, let''s run the PHP 8 example using
    this URL: http://172.16.0.88/ch07/php8_gd_is_resource.php. Here is the result:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述输出中可以看出，识别出了一个`resource`扩展，但没有描述性信息。现在，让我们使用此URL运行PHP 8示例：http://172.16.0.88/ch07/php8_gd_is_resource.php。这是结果：
- en: '![Figure 7.3 – PHP 8 GD image object instance'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 - PHP 8 GD图像对象实例'
- en: '](image/Figure_7.5_B16231.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.5_B16231.jpg)'
- en: Figure 7.3 – PHP 8 GD image object instance
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 - PHP 8 GD图像对象实例
- en: The output from PHP 8 not only identifies the return type as a `GdImage` instance
    but also displays descriptive information below the image.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从PHP 8的输出中不仅可以识别返回类型为`GdImage`实例，还可以在图像下方显示描述性信息。
- en: We now turn our attention to other `GD` extension changes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将注意力转向其他`GD`扩展的变化。
- en: GD extension compile flag changes
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GD扩展编译标志更改
- en: The `GD` extension not only leverages the GD library but a number of supporting
    libraries as well. These libraries are needed to provide support for the various
    graphics formats. Previously, when compiling a custom version of PHP from the
    source code, you needed to specify the location of the libraries for *JPEG*, *PNG*,
    *XPM*, and *VPX* formats. In addition, as compression is an important aspect in
    reducing the overall final file size, the location of `ZLIB` was needed as well.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`GD`扩展不仅利用GD库，还利用一些支持库。这些库需要提供对各种图形格式的支持。以前，在从源代码编译自定义版本的PHP时，您需要指定*JPEG*、*PNG*、*XPM*和*VPX*格式的库位置。此外，由于压缩是减少最终文件大小的重要方面，因此还需要`ZLIB`的位置。 '
- en: When compiling PHP 8 from source, there are a number of significant configuration
    flag changes that were first introduced in PHP 7.4 and subsequently carried into
    PHP 8\. The primary change is that you no longer need to specify the directory
    where libraries are located. PHP 8 now locates libraries using the `pkg-config`
    operating system equivalent.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在从源代码编译PHP 8时，有一些重要的配置标志更改，这些更改首先出现在PHP 7.4中，随后被带入PHP 8。主要变化是您不再需要指定库所在的目录。PHP
    8现在使用`pkg-config`操作系统等效工具来定位库。
- en: 'The following table summarizes compile flag changes. These flags are used with
    the `configure` utility just prior to the actual compile process itself:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表总结了编译标志的更改。这些标志与`configure`实用程序一起使用，就在实际编译过程之前：
- en: '![Table 7.3 – GD compile option changes'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![表7.3 - GD编译选项更改'
- en: '](image/Figure_7.6_B16231.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.6_B16231.jpg)'
- en: Table 7.3 – GD compile option changes
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.3 - GD编译选项更改
- en: You will note from the table that for the most part, most `--with-*-dir` options
    are replaced with `--with-*`. Also, *PNG* and *ZLIB* support is now automatic;
    however, you must have `libpng` and `zlib` installed on your operating system.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到表中，大部分`--with-*-dir`选项都被替换为`--with-*`。此外，*PNG*和*ZLIB*支持现在是自动的；但是，您必须在操作系统上安装`libpng`和`zlib`。
- en: We will now have a look at other minor changes to the `GD` extension.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看看`GD`扩展的其他较小变化。
- en: Other GD extension changes
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他GD扩展变化
- en: Aside from the major changes described in the previous section, a number of
    other minor changes have taken place, in the form of function signature changes
    and a new function. Let's start this discussion by having a look at the `imagecropauto()`
    function.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前一节描述的主要变化外，还发生了一些其他较小的变化，包括函数签名的变化和一个新函数。让我们从查看`imagecropauto()`函数开始讨论。
- en: 'Here is the old function signature for `imagecropauto()`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`imagecropauto()`的旧函数签名：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In PHP 8, the `$image` parameter is now of type `GdImage`. The `$mode` parameter
    now defaults to an `IMG_CROP_DEFAULT` predefined constant.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，`$image`参数现在是`GdImage`类型。`$mode`参数现在默认为`IMG_CROP_DEFAULT`预定义常量。
- en: 'Another change affects the `imagepolygon()`, `imageopenpolygon()`, and `imagefilledpolygon()`
    functions. Here is the old function signature for `imagepolygon()`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个变化影响了`imagepolygon()`，`imageopenpolygon()`和`imagefilledpolygon()`函数。这是`imagepolygon()`的旧函数签名：
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In PHP 8, the `$num_points` parameter is now optional. If omitted, the number
    of points is calculated as follows: `count($points)/2`. However, this means that
    the number of elements in the `$points` array must be an even number!'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，`$num_points`参数现在是可选的。如果省略，点数将计算如下：`count($points)/2`。但是，这意味着`$points`数组中的元素数量必须是偶数！
- en: 'The last significant change is the addition of a new function, `imagegetinterpolation()`.
    Here is its function signature:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个重要的变化是添加了一个新函数`imagegetinterpolation()`。这是它的函数签名：
- en: '`imagegetinterpolation(GdImage $image) : int`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`imagegetinterpolation(GdImage $image) : int`'
- en: The return value is an integer that, in and of itself, isn't very useful. However,
    if you examine the documentation for the `imagesetinterpolation()` function (https://www.php.net/manual/en/function.imagesetinterpolation.php),
    you will see a list of interpolation method code along with an explanation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值是一个整数，本身并不是非常有用。但是，如果您查看`imagesetinterpolation()`函数的文档（https://www.php.net/manual/en/function.imagesetinterpolation.php），您将看到一系列插值方法代码以及解释。
- en: You now have an idea of which changes were introduced in the `GD` extension.
    We next examine changes to the `Reflection` extension.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了`GD`扩展引入的更改。接下来我们将检查`Reflection`扩展的更改。
- en: Discovering changes to the Reflection extension
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现Reflection扩展的更改
- en: The **Reflection extension** is used to perform *introspection* on objects,
    classes, methods, and functions, among other things. `ReflectionClass` and `ReflectionObject`
    produce information on a class or an object instance respectively. `ReflectionFunction`
    provides information on procedural-level functions. In addition, the `Reflection`
    extension has a set of secondary classes produced by the main classes mentioned
    just now. These secondary classes include `ReflectionMethod`, produced by `ReflectionClass::getMethod()`,
    `ReflectionProperty`, produced by `ReflectionClass::getProperty()`, and so forth.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**Reflection扩展**用于对对象、类、方法和函数等进行*内省*。`ReflectionClass`和`ReflectionObject`分别提供有关类或对象实例的信息。`ReflectionFunction`提供有关过程级函数的信息。此外，`Reflection`扩展还有一组由刚才提到的主要类产生的辅助类。这些辅助类包括`ReflectionMethod`，由`ReflectionClass::getMethod()`产生，`ReflectionProperty`，由`ReflectionClass::getProperty()`产生，等等。'
- en: 'You might wonder: *Who uses this extension?* The answer is: any application
    that needs to perform analysis on an external set of classes. This might include
    software that performs automated **code generation**, **testing**, or **documentation
    generation**. Classes that perform **hydration** (populating objects from arrays)
    also benefit from the `Reflection` extension.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想：*谁使用这个扩展？*答案是：任何需要对外部一组类执行分析的应用。这可能包括执行自动**代码生成**、**测试**或**文档生成**的软件。执行**hydration**（从数组中填充对象）的类也受益于`Reflection`扩展。
- en: Tip
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'We do not have enough room in the book to cover every single `Reflection` extension
    class and method. If you wish to get more information, please have a look at the
    documentation reference here: [https://www.php.net/manual/en/book.reflection.php](https://www.php.net/manual/en/book.reflection.php).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中没有足够的空间来涵盖每一个`Reflection`扩展类和方法。如果您希望获得更多信息，请查看这里的文档参考：[https://www.php.net/manual/en/book.reflection.php](https://www.php.net/manual/en/book.reflection.php)。
- en: Let's now have a look at a `Reflection` extension usage example.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个`Reflection`扩展的使用示例。
- en: Reflection extension usage
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Reflection扩展的使用
- en: 'We will now show a code example that demonstrates how the `Reflection` extension
    might be used to generate **docblocks** (a `docblock` is a PHP comment that uses
    a special syntax to denote the purpose of a method, its incoming parameters, and
    return value). Here are the steps leading to this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示一个代码示例，演示了如何使用`Reflection`扩展来生成**docblocks**（`docblock`是使用特殊语法来表示方法目的、其传入参数和返回值的PHP注释）。以下是导致这一步的步骤：
- en: 'We first define a `__construct()` method that creates a `ReflectionClass` instance
    of the target class, as follows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个`__construct()`方法，创建目标类的`ReflectionClass`实例，如下所示：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We then define a `check()` method that grabs all the class methods, returning
    an array of `ReflectionMethod` instances, as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个`check()`方法，获取所有类方法，返回一个`ReflectionMethod`实例数组，如下所示：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We then loop through all the methods and use `getDocComment()` to check to
    see if a `docblock` already exists, as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们循环遍历所有方法，并使用`getDocComment()`来检查是否已经存在`docblock`，如下所示：
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If a `docblock` does not already exist, we start a new one and then call `getParameters()`,
    which returns an array of `ReflectionParameter` instances, as illustrated in the
    following code snippet:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`docblock`不存在，我们将开始一个新的`docblock`，然后调用`getParameters()`，它返回一个`ReflectionParameter`实例数组，如下面的代码片段所示：
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If we do have parameters, we gather information for display, as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有参数，我们收集用于显示的信息，如下所示：
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We then set the return type and assign the `docblock` to a `$methods` array
    that is then returned, as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们设置返回类型，并将`docblock`分配给一个`$methods`数组，然后返回，如下所示：
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now the new `docblock` checking class is complete, we define a calling program,
    as shown in the following code snippet. The calling program targets a `/repo/src/Php7/Reflection/Test.php`
    class (not shown here). This class has a mixture of methods with parameters and
    return values:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在新的`docblock`检查类已经完成，我们定义一个调用程序，如下面的代码片段所示。调用程序针对`/repo/src/Php7/Reflection/Test.php`类（此处未显示）。这个类具有一些带有参数和返回值的方法的混合：
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output of the calling program is shown here:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 调用程序的输出如下所示：
- en: '[PRE50]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see, this class forms the basis of potentially automatic documentation
    or a code-generation application.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个类构成了潜在的自动文档或代码生成应用的基础。
- en: Let's now have a look at `Reflection` extension improvements.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`Reflection`扩展的改进。
- en: Learning about Reflection extension improvements
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解Reflection扩展的改进
- en: There have also been a number of improvements to the `Reflection` extension
    that might be important for you to know about. Please bear in mind that, although
    there are a limited number of developers who use the `Reflection` extension, you
    might one day find yourself in a situation where you are working with code that
    uses this extension. If you notice odd behavior after a PHP 8 upgrade, the material
    covered in this section gives you a head start in the troubleshooting process.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflection`扩展还进行了一些改进，这些改进可能对您很重要。请记住，虽然使用`Reflection`扩展的开发人员数量有限，但您可能有一天会发现自己在处理使用此扩展的代码的情况。如果您在PHP
    8升级后注意到异常行为，本节介绍的内容将让您在故障排除过程中提前了解情况。'
- en: ReflectionType modifications
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ReflectionType修改
- en: The `ReflectionType` class is now abstract in PHP 8\. When you use the `ReflectionProperty::getType()`
    or `ReflectionFunction::getReturnType()` methods, you might note that a `ReflectionNamedType`
    instance is returned. This change does not affect the normal functioning of your
    program code, unless you are relying upon a `ReflectionType` instance being returned.
    However, `ReflectionNamedType` extends `ReflectionType`, so any `instanceof` operations
    will not be affected.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，`ReflectionType`类现在是抽象的。当您使用`ReflectionProperty::getType()`或`ReflectionFunction::getReturnType()`方法时，您可能会注意到返回一个`ReflectionNamedType`实例。这种变化不会影响您程序代码的正常运行，除非您依赖于返回`ReflectionType`实例。但是，`ReflectionNamedType`扩展了`ReflectionType`，因此`instanceof`操作不会受到影响。
- en: It's also worth noting that the `isBuiltIn()` method has been moved from `ReflectionType`
    to `ReflectionNamedType`. Again, since `ReflectionNamedType` extends `ReflectionType`,
    this should not present any backward-compatible break in your current code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`isBuiltIn()`方法已经从`ReflectionType`移动到`ReflectionNamedType`。同样，由于`ReflectionNamedType`扩展了`ReflectionType`，这不应该在您当前的代码中造成任何向后兼容的问题。
- en: ReflectionParameter::*DefaultValue* methods enhanced
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ReflectionParameter::*DefaultValue*方法增强
- en: 'In earlier versions of PHP, `ReflectionParameter` methods pertaining to default
    values were unable to reflect internal PHP functions. This has changed in PHP
    8\. The following `ReflectionParameter` methods are now also able to return default
    value information from internal functions:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期版本的PHP中，关于默认值的`ReflectionParameter`方法无法反映内部PHP函数。在PHP 8中，以下`ReflectionParameter`方法现在也能够从内部函数返回默认值信息：
- en: '`getDefaultValue()`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDefaultValue()`'
- en: '`getDefaultValueConstantName()`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDefaultValueConstantName()`'
- en: '`isDefaultValueAvailable()`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isDefaultValueAvailable()`'
- en: '`isDefaultValueConstant()`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isDefaultValueConstant()`'
- en: 'As you can see from the list, the method names are self-explanatory. We''ll
    now show a code example that makes use of these enhancements. Here are the steps
    leading to this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表中可以看出，方法名称是不言自明的。我们现在将展示一个使用这些增强功能的代码示例。以下是导致这一步的步骤：
- en: 'First, we define a function that accepts a `ReflectionParameter` instance and
    returns an array with the parameter name and default value, as follows:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个函数，接受一个`ReflectionParameter`实例，并返回一个包含参数名称和默认值的数组，如下所示：
- en: '[PRE51]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we define a `switch()` statement to sanitize the options, as follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`switch()`语句来清理选项，如下所示：
- en: '[PRE52]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We then determine which function to reflect and pull its parameters. In the
    following example, we reflect `setcookie()`:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们确定要反射的函数并提取其参数。在下面的例子中，我们反射`setcookie()`：
- en: '[PRE53]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We then loop through the array of `ReflectionParameter` instances and produce
    an output, as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们循环遍历`ReflectionParameter`实例的数组并产生输出，如下所示：
- en: '[PRE54]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here is the output running in PHP 7:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PHP 7中运行的输出：
- en: '[PRE55]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The result is always `No Default` because, in PHP 7 and earlier, the `Reflection`
    extension is unable to read defaults for internal PHP functions. The PHP 8 output,
    on the other hand, is much more accurate, as we can see here:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 结果始终是`No Default`，因为在PHP 7及更早版本中，`Reflection`扩展无法读取内部PHP函数的默认值。另一方面，PHP 8的输出要准确得多，正如我们在这里所看到的：
- en: '[PRE56]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see from the output, the `Reflection` extension in PHP 8 is able
    to accurately report on internal function default values!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，PHP 8中的`Reflection`扩展能够准确报告内部函数的默认值！
- en: Let's now have a look at other `Reflection` extension changes.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看其他`Reflection`扩展的变化。
- en: Other Reflection extension changes
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他反射扩展的更改
- en: In PHP versions prior to PHP 8, `ReflectionMethod::isConstructor()` and `ReflectionMethod::isDestructor()`
    were unable to reflect magic methods defined in interfaces. In PHP 8, these two
    methods now return `TRUE` for the corresponding magic methods defined in interfaces.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8之前的PHP版本中，`ReflectionMethod::isConstructor()`和`ReflectionMethod::isDestructor()`无法反映在接口中定义的魔术方法。在PHP
    8中，这两个方法现在对接口中定义的相应魔术方法返回`TRUE`。
- en: 'When using the `ReflectionClass::getConstants()` or `ReflectionClass::getReflectionConstants()`
    methods, a new `$filter` parameter has now been added. The parameter allows you
    to filter the results by visibility level. Accordingly, the new parameter can
    accept any of the following newly added predefined constants:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`ReflectionClass::getConstants()`或`ReflectionClass::getReflectionConstants()`方法时，现在添加了一个新的`$filter`参数。该参数允许您按可见性级别过滤结果。因此，新参数可以接受以下任何新添加的预定义常量之一：
- en: '`ReflectionClassConstant::IS_PUBLIC`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReflectionClassConstant::IS_PUBLIC`'
- en: '`ReflectionClassConstant::IS_PROTECTED`'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReflectionClassConstant::IS_PROTECTED`'
- en: '`ReflectionClassConstant::IS_PRIVATE`'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReflectionClassConstant::IS_PRIVATE`'
- en: You now have an idea of how to use the `Reflection` extension and what to expect
    after a PHP 8 migration. It's time to have a look at a number of other extensions
    that saw changes in PHP 8.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何使用`Reflection`扩展以及在PHP 8迁移后可以期待什么。现在是时候看看在PHP 8中发生了变化的其他扩展了。
- en: Working with other extension gotchas
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理其他扩展的注意事项
- en: PHP 8 introduced a number of other noteworthy changes to several PHP extensions
    other than the ones already discussed in this chapter. As we have stressed time
    and again in this book, it's extremely important for your future career as a PHP
    developer to be aware of these changes.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8引入了一些其他PHP扩展的值得注意的变化，除了本章已经讨论过的扩展。正如我们在本书中一再强调的那样，了解这些变化对于您作为PHP开发人员的未来职业非常重要。
- en: Let's first have a look at changes to database extensions.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看数据库扩展的变化。
- en: New database extension operating system library requirements
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的数据库扩展操作系统库要求
- en: 'Any developer using **MySQL**, **MariaDB**, **PostgreSQL**, or **PHP Data Objects**
    (**PDO**) needs to be aware of new requirements for supporting operating system
    libraries. The following table summarizes the new minimum versions required in
    PHP 8:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用**MySQL**、**MariaDB**、**PostgreSQL**或**PHP数据对象**（**PDO**）的开发人员都需要注意支持操作系统库的新要求。以下表格总结了PHP
    8中所需的新最低版本：
- en: '![Table 7.4 – PHP 8 database library requirements'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![表7.4 – PHP 8数据库库要求'
- en: '](image/Figure_7.7_B16231.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.7_B16231.jpg)'
- en: Table 7.4 – PHP 8 database library requirements
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.4 – PHP 8数据库库要求
- en: As you can see from the preceding table, there are two main library changes.
    `libpq` affects both the `PostgreSQL` extension and the driver for the `PDO` extension.
    `libmysqlclient` is the library used by both the **MySQL Improved** (**MySQLi**)
    extension and as the MySQL driver for the `PDO` extension. It should also be noted
    that if you are using MariaDB, a popular open source version of MySQL, the new
    minimum `MySQL` library requirement applies to you as well.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 从上表可以看出，有两个主要的库更改。`libpq`影响了`PostgreSQL`扩展和`PDO`扩展的驱动程序。`libmysqlclient`是**MySQL
    Improved** (**MySQLi**)扩展和`PDO`扩展的MySQL驱动程序使用的库。还应该注意，如果您使用的是MariaDB，MySQL的一个流行的开源版本，新的最低`MySQL`库要求也适用于您。
- en: Now that you are aware of database extension changes, we next turn our attention
    to the ZIP extension.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您已经了解了数据库扩展的变化，接下来我们将把注意力转向ZIP扩展。
- en: Reviewing changes to the ZIP extension
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查ZIP扩展的变化
- en: The ZIP **extension** is used to programmatically create and manage compressed
    archive files, leveraging the `libzip` operating system library. Other compression
    extensions exist, such as **Zlib**, **bzip2**, **LZF**, **PHP Archive Format**
    (**phar**), and **Roshal Archive Compressed** (**RAR**); however, none of the
    other extensions offers the rich range of functionality offered by the `ZIP` extension.
    Also, for the most part, the other extensions are special-purpose and are generally
    unsuitable for generic ZIP file management.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ZIP扩展用于以编程方式创建和管理压缩的存档文件，利用`libzip`操作系统库。还存在其他压缩扩展，如**Zlib**、**bzip2**、**LZF**、**PHP
    Archive Format** (**phar**)和**Roshal Archive Compressed** (**RAR**)；然而，其他扩展都没有`ZIP`扩展提供的丰富功能范围。此外，大多数情况下，其他扩展都是专用的，通常不适用于通用ZIP文件管理。
- en: Let's first have a look at the most notable change to this extension.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下这个扩展最显著的变化。
- en: Dealing with ZIP extension OOP migration
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理ZIP扩展的OOP迁移
- en: The biggest change to the ZIP extension is one that presents a potentially massive
    backward-compatible code break down the road. As of PHP 8, the procedural API
    (all procedural functions) has been deprecated! Although this does not affect
    any code at present, all ZIP extension functions will eventually be removed from
    the language.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ZIP扩展最大的变化是可能会在未来引入一个巨大的向后兼容的代码破坏。从PHP 8开始，过程API（所有过程函数）已被弃用！尽管目前不会影响任何代码，但所有ZIP扩展函数最终将从语言中移除。
- en: 'The *best practice* is to migrate any `ZIP` extension procedural code over
    to the OOP API using the `ZipArchive` class. The following code example illustrates
    how to migrate from procedural code to object code, opening a `test.zip` file
    and producing a list of entries:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*最佳实践*是将任何`ZIP`扩展的过程代码迁移到使用`ZipArchive`类的OOP API。以下代码示例说明了如何从过程代码迁移到对象代码，打开一个`test.zip`文件并生成条目列表：'
- en: '[PRE57]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here is the output running in PHP 7:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PHP 7中运行的输出：
- en: '[PRE58]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As you can see from the preceding output, a total of `27` entries are found.
    (Also, note that not all ZIP file entries are shown.) If we try the same code
    example in PHP 8, however, we get a very different result, as we can see here:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的输出可以看出，一共找到了`27`个条目。（还要注意并非所有ZIP文件条目都显示。）然而，如果我们在PHP 8中尝试相同的代码示例，结果会大不相同，如下所示：
- en: '[PRE59]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see from the preceding PHP 8 output, the code example works, but
    a series of deprecation `Notice` messages are issued.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的PHP 8输出可以看出，代码示例可以工作，但会发出一系列弃用的`Notice`消息。
- en: 'Here is how you need to write the same code example in PHP 8:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您需要在PHP 8中编写相同代码示例的方式：
- en: '[PRE60]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The output (not shown) is exactly the same as for the previous example. Interestingly,
    the rewritten example also works in PHP 7! It's also worth noting that in PHP
    8, you can get a count of the total number of entries (per directory) using `ZipArchive::count()`.
    You may also have noticed that to check to see if the ZIP archive is opened properly,
    in PHP 8 you can no longer use `is_resource()`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 输出（未显示）与之前的示例完全相同。有趣的是，重写的示例在PHP 7中也可以工作！还值得注意的是，在PHP 8中，您可以使用`ZipArchive::count()`来获取总条目数（每个目录）。您可能还注意到，在PHP
    8中，您不能再使用`is_resource()`来检查ZIP存档是否正确打开。
- en: New ZipArchive class methods
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的ZipArchive类方法
- en: 'In addition to resource-to-object migration, a number of improvements have
    been made to the `ZipArchive` class. One such improvement is that the following
    new methods have been added:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从资源到对象的迁移，`ZipArchive`类还进行了一些改进。其中一个改进是添加了以下新方法：
- en: '`setMtimeName()`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setMtimeName()`方法'
- en: '`setMtimeIndex()`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setMtimeIndex()`'
- en: '`registerProgressCallback()`'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerProgressCallback()`'
- en: '`registerCancelCallback()`'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerCancelCallback()`'
- en: '`replaceFile()`'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replaceFile()`'
- en: '`isCompressionMethodSupported()`'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isCompressionMethodSupported()`'
- en: '`isEncryptionMethodSupported()`'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEncryptionMethodSupported()`'
- en: The method names are self-explanatory. `Mtime` refers to **modification time**.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名称不言自明。`Mtime`指的是**修改时间**。
- en: New options for addGlob() and addPattern()
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`addGlob()`和`addPattern()`的新选项'
- en: 'The `ZipArchive::addGlob()` and `ZipArchive::addPattern()` methods have a new
    set of options. These two methods are similar in that both are used to add files
    to the archive. The difference is that `addGlob()` uses the same file pattern
    as the core PHP `glob()` command, whereas `addPattern()` filters files using a
    regex. The new set of options is summarized here:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`ZipArchive::addGlob()`和`ZipArchive::addPattern()`方法有一组新的选项。这两种方法都用于向存档中添加文件。不同之处在于`addGlob()`使用与核心PHP的`glob()`命令相同的文件模式，而`addPattern()`使用正则表达式过滤文件。这里总结了一组新的选项：'
- en: '`flags`: Lets you combine the appropriate class constants using *bitwise operators*'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`：让您使用*位运算符*组合适当的类常量'
- en: '`comp_method`: Specifies the compression method using any of the `ZipArchive::CM_*`
    constants as an argument'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comp_method`：使用任何`ZipArchive::CM_*`常量作为参数指定压缩方法'
- en: '`comp_flags`: Specifies compression flags using the desired `ZipArchive::FL_*`
    constant(s)'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comp_flags`：使用所需的`ZipArchive::FL_*`常量来指定压缩标志'
- en: '`enc_method`: Lets you specify the desired character encoding (using any of
    the `ZipArchive::FL_ENC_*` flags)'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enc_method`：允许您指定所需的字符编码（使用任何 `ZipArchive::FL_ENC_*` 标志）'
- en: '`enc_password`: Lets you specify the encryption password if it is set for this
    ZIP archive'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enc_password`：允许您指定 ZIP 存档的加密密码（如果设置了）'
- en: It's also worth mentioning here that the `remove_path` option prior to PHP 8
    had to be a valid directory path. As of PHP 8, this option is a simple string
    that represents characters to be removed. This allows you to remove filename prefixes
    as well as undesired directory paths.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里还值得一提的是，在 PHP 8 之前的 `remove_path` 选项必须是一个有效的目录路径。从 PHP 8 开始，这个选项是一个简单的字符串，表示要删除的字符。这使您能够删除文件名前缀以及不需要的目录路径。
- en: 'While we are still examining options, it''s worth noting that two new encoding
    method class constants have been added: `ZipArchive::EM_UNKNOWN` and `ZipArchive::EM_TRAD_PKWARE`.
    Also, a new `lastId` property has been added so that you are able to determine
    the index value of the last ZIP archive entry.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们仍在研究选项，值得注意的是添加了两个新的编码方法类常量：`ZipArchive::EM_UNKNOWN` 和 `ZipArchive::EM_TRAD_PKWARE`。此外，添加了一个新的
    `lastId` 属性，以便您能够确定最后一个 ZIP 存档条目的索引值。
- en: Other ZipArchive method changes
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他 ZipArchive 方法的更改
- en: 'In addition to the changes mentioned earlier, a few other `ZipArchive` methods
    have changed in PHP 8\. In this section, we summarize other `ZipArchive` method
    changes, as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的更改之外，PHP 8 中还有一些其他 `ZipArchive` 方法已经改变。在本节中，我们总结了其他 `ZipArchive` 方法的更改，如下：
- en: '`ZipArchive::extractTo()` previously used the current date and time for the
    modification time. As of PHP 8, this method restores the original file modification
    time.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZipArchive::extractTo()` 以前使用当前日期和时间作为修改时间。从 PHP 8 开始，这个方法恢复了原始文件的修改时间。'
- en: '`ZipArchive::getStatusString()` returns results even after `ZipArchive::close()`
    has been invoked.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZipArchive::getStatusString()` 在调用 `ZipArchive::close()` 后仍然返回结果。'
- en: '`ZipArchive::addEmptyDir()`, `ZipArchive::addFile()`, and `ZipArchive::addFromString()`
    methods all have a new `flags` argument. You can use any of the appropriate `ZipArchive::FL_*`
    class constants, combined using bitwise operators.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZipArchive::addEmptyDir()`、`ZipArchive::addFile()` 和 `ZipArchive::addFromString()`
    方法都有一个新的 `flags` 参数。您可以使用任何适当的 `ZipArchive::FL_*` 类常量，并使用位运算符进行组合。'
- en: '`ZipArchive::open()` can now open an empty (zero-byte) file.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZipArchive::open()` 现在可以打开一个空的（零字节）文件。'
- en: Now you have an idea of the changes and improvements that have been introduced
    to the `ZIP` extension, let's examine changes in the area of regular expressions.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了引入到 `ZIP` 扩展中的更改和改进，让我们来看看正则表达式领域的更改。
- en: Examining PCRE extension changes
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 PCRE 扩展的更改
- en: The **PCRE** extension contains a number of functions designed to perform pattern
    matching using *regular expressions.* The term *regular* *expression* is commonly
    shortened to *regex*. A **regex** is a string that describes another string. Here
    are some changes to note in the `PCRE` extension.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**PCRE** 扩展包含了一些设计用于使用 *正则表达式* 进行模式匹配的函数。术语 *regular* *expression* 通常被缩写为 *regex*。**regex**
    是描述另一个字符串的字符串。以下是 `PCRE` 扩展中需要注意的一些更改。'
- en: Invalid escape sequences in patterns are no longer interpreted as literals.
    In the past, you could use an `X` modifier; however, that modifier is now ignored
    in PHP 8\. Happily, to assist you with internal PCRE pattern-analysis errors,
    a new `preg_last_error_msg()` function has been added that returns a human-readable
    message when PCRE errors are encountered.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 模式中的无效转义序列不再被解释为文字。过去，您可以使用 `X` 修饰符；然而，在 PHP 8 中，该修饰符被忽略。令人高兴的是，为了帮助您处理内部 PCRE
    模式分析错误，添加了一个新的 `preg_last_error_msg()` 函数，当遇到 PCRE 错误时返回一个人类可读的消息。
- en: The `preg_last_error()` function allows you to determine whether or not an internal
    PCRE error occurred during pattern analysis. This function only returns an integer,
    however. Prior to PHP 8, it was up to the developer to look up the code and to
    figure out the actual error.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`preg_last_error()` 函数允许您确定在模式分析期间是否发生了内部 PCRE 错误。然而，这个函数只返回一个整数。在 PHP 8 之前，开发人员需要查找代码并找出实际的错误。'
- en: Tip
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'A list of error codes returned by `preg_last_error()` can be found here:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`preg_last_error()` 返回的错误代码列表可以在这里找到：'
- en: '[https://www.php.net/manual/en/function.preg-last-error.php#refsect1-function.preg-last-error-returnvalues](https://www.php.net/manual/en/function.preg-last-error.php#refsect1-function.preg-last-error-returnvalues)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.php.net/manual/en/function.preg-last-error.php#refsect1-function.preg-last-error-returnvalues](https://www.php.net/manual/en/function.preg-last-error.php#refsect1-function.preg-last-error-returnvalues)'
- en: 'A brief code example follows that illustrates the aforementioned issues. Here
    are the steps leading to this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个简短的代码示例，说明了前面提到的问题。以下是导致这一问题的步骤：
- en: 'First, we define a function that performs a match and checks to see if any
    errors have occurred, as follows:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个执行匹配并检查是否发生任何错误的函数，如下：
- en: '[PRE61]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We then create a pattern that deliberately contains a `\8+` invalid escape
    sequence, as follows:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个故意包含 `\8+` 无效转义序列的模式，如下：
- en: '[PRE62]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, we define a pattern that deliberately causes PCRE to exceed its backtrace
    limit, as follows:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个故意导致 PCRE 超出回溯限制的模式，如下：
- en: '[PRE63]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here is the output in PHP 7.1:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 PHP 7.1 中的输出：
- en: '[PRE64]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As you can see from the preceding output, the invalid pattern is treated as
    a literal value 8\. Because 8 exists in the string, a match is considered found.
    As for the second pattern, the backtrace limit is exceeded; however, PHP 7.1 is
    unable to report the problem, forcing you to look it up.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看到，无效的模式被视为文字值 8。因为 8 存在于字符串中，所以被认为找到了匹配项。至于第二个模式，回溯限制被超出；然而，PHP 7.1
    无法报告这个问题，迫使您自行查找。
- en: 'The output in PHP 8 is quite different, as seen here:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 8 中的输出是完全不同的，如下所示：
- en: '[PRE65]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As you can see from the preceding output, PHP 8 produces a `Warning` message.
    You can also see that `preg_last_error_msg()` produces a useful message. Let's
    now have a look at the **Internationalization** (**Intl**) extension.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看到，PHP 8 产生了一个 `Warning` 消息。您还可以看到 `preg_last_error_msg()` 产生了一个有用的消息。现在让我们来看看
    **Internationalization** (**Intl**) 扩展。
- en: Working with Intl extension changes
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理Intl扩展的变化
- en: The **Intl extension** consists of several classes that handle a number of application
    aspects that might change depending on the locale. The various classes handle
    such tasks as internationalized number and currency formatting, text parsing,
    calendar generation, time and date formatting, and character-set conversion, among
    other things.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**Intl扩展**由几个类组成，处理可能根据区域设置而变化的一些应用方面。各种类处理国际化数字和货币格式化、文本解析、日历生成、时间和日期格式化以及字符集转换等任务。'
- en: 'The main change introduced to the Intl extension in PHP 8 is the following
    new date formats:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8中引入到Intl扩展的主要更改是以下新的日期格式：
- en: '`IntlDateFormatter::RELATIVE_FULL`'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntlDateFormatter::RELATIVE_FULL`'
- en: '`IntlDateFormatter::RELATIVE_LONG`'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntlDateFormatter::RELATIVE_LONG`'
- en: '`IntlDateFormatter::RELATIVE_MEDIUM`'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntlDateFormatter::RELATIVE_MEDIUM`'
- en: '`IntlDateFormatter::RELATIVE_SHORT`'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntlDateFormatter::RELATIVE_SHORT`'
- en: 'A code example follows, showing the new formats. Here are the steps leading
    to this:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个代码示例，显示了新的格式。以下是导致这一步的步骤：
- en: 'First, we define a `DateTime` instance and an array containing the new format
    codes, as follows:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个`DateTime`实例和一个包含新格式代码的数组，如下所示：
- en: '[PRE66]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We then loop through the formats and echo the output, as follows:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们循环遍历格式并输出结果，如下所示：
- en: '[PRE67]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This example doesn''t work in PHP 7\. Here is the output from PHP 8:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在PHP 7中不起作用。以下是PHP 8的输出：
- en: '[PRE68]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As you can see, the new relative date formats work quite well! We now briefly
    return to the `cURL` extension.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，新的相对日期格式运行得相当不错！现在我们简要地回到`cURL`扩展。
- en: Understanding cURL extension changes
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解cURL扩展的变化
- en: The `cURL` extension leverages `libcurl` (http://curl.haxx.se/) to provide powerful
    and highly efficient HTTP client capabilities. In PHP 8, you must have `libcurl`
    version 7.29 (or above) installed on your server's operating system.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`cURL`扩展利用`libcurl`（http://curl.haxx.se/）提供强大和高效的HTTP客户端功能。在PHP 8中，你必须在服务器的操作系统上安装版本为7.29（或更高版本）的`libcurl`。'
- en: Another difference in PHP 8 is that this extension now uses objects rather than
    resources. This change was described earlier in this chapter, in *Table 7.1*,
    *PHP 8 resource-to-object migration*. An example was shown in the *Potential code
    break involving is_resource()* section. A side effect of this change is that any
    of the `curl*close()` functions are redundant, as the connection is closed when
    the object is unset or otherwise goes out of scope.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8中的另一个不同之处是这个扩展现在使用对象而不是资源。这个变化在本章前面已经描述过，在*表7.1*，*PHP 8资源到对象的迁移*中。在*潜在的涉及is_resource()的代码中断*部分展示了一个例子。这个变化的一个副作用是任何`curl*close()`函数都是多余的，因为当对象未设置或者超出范围时连接会被关闭。
- en: Let's now have a look at changes to the `COM` extension.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看`COM`扩展的变化。
- en: Reviewing COM extension changes
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查COM扩展的变化
- en: '**Component Object Model** (**COM**) is a Windows-only extension that enables
    programming code written in one language to call and interoperate with code written
    in any other COM-aware programming language. This information is important for
    any PHP developers who plan to develop PHP applications that run on Windows servers.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件对象模型**（**COM**）是一个仅适用于Windows的扩展，它使得用一种语言编写的编程代码能够调用和与用任何其他支持COM的编程语言编写的代码进行交互。对于计划在Windows服务器上运行的PHP开发人员来说，这些信息非常重要。'
- en: The most significant change to the `COM` extension is that case sensitivity
    is now automatically enforced. Accordingly, you can no longer import from type
    libraries any constants that are case-insensitive. In addition, you can no longer
    specify `$case_insensitive`, the second argument to the `com_load_typelib()` function,
    as `FALSE`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`COM`扩展的最重要的变化是现在自动强制大小写敏感性。因此，你不能再从类型库中导入任何大小写不敏感的常量。此外，你也不能再将`$case_insensitive`作为`FALSE`作为`com_load_typelib()`函数的第二个参数。'
- en: 'Along these lines, `COM` extension `php.ini` settings that deal with case sensitivity
    have been altered. These include the following:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，处理大小写敏感性的`COM`扩展`php.ini`设置已经发生了变化。这些包括以下内容：
- en: '`com.autoregister_casesensitive`: Permanently enabled in PHP 8.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.autoregister_casesensitive`：在PHP 8中永久启用。'
- en: '`com.typelib_file`: Any type libraries whose names end with either `#cis` or
    `#case_insensitive` no longer cause the constants to be treated as case-insensitive.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.typelib_file`：任何类型库的名称以`#cis`或`#case_insensitive`结尾的不再导致常量被视为大小写不敏感。'
- en: One change is a new `php.ini` setting, `com.dotnet_version`. This setting sets
    the **.NET** version to use for dotnet objects. We now examine other extension
    changes of note.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 一个变化是一个新的`php.ini`设置，`com.dotnet_version`。这个设置用于设置要用于dotnet对象的**.NET**版本。我们现在来检查其他值得注意的扩展变化。
- en: Examining other extension changes
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查其他扩展的变化
- en: 'There are a few other changes to other PHP extensions that deserve a mention.
    *Table 7.5*, shown next, summarizes these changes:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他PHP扩展的变化值得一提。接下来显示的*表7.5*总结了这些变化：
- en: '![Table 7.5 – PHP 8 database library requirements'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '![表7.5 – PHP 8数据库库要求'
- en: '](image/Figure_7.8_B16231.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.8_B16231.jpg)'
- en: Table 7.5 – PHP 8 database library requirements
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.5 – PHP 8数据库库要求
- en: You now have an idea about changes to extensions in PHP 8\. This wraps up the
    chapter. Now, it's time for a recap!
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对PHP 8中扩展的变化有了一个概念。这就结束了本章。现在，是时候进行总结了！
- en: Summary
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: One of the most important concepts you learned in this chapter is a general
    trend away from resources and toward objects. You learned where this trend is
    noticeable in the various PHP extensions covered in this chapter, and how to develop
    workarounds to avoid problems in code that relies upon resources. You also learned
    how to detect and develop code to address changes in XML extensions, especially
    in the `SimpleXML` and `XMLWriter` extensions.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到的最重要的概念之一是从资源向对象的一般趋势。你学会了在本章涵盖的各种PHP扩展中注意到这种趋势的地方，以及如何开发解决方案来避免依赖资源的代码中出现问题。你还学会了如何检测和开发代码来解决XML扩展中的变化，特别是在`SimpleXML`和`XMLWriter`扩展中。
- en: Another important extension with significant changes covered in this chapter
    is the `mbstring` extension. You learned to detect code that relies upon changed
    `mbstring` functionality. As you learned, changes to the `mbstring` extension
    for the most part mirror changes made to the equivalent core PHP string functions.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还涵盖了一个重要的扩展，即`mbstring`扩展，其中有重大变化。您学会了检测依赖于已更改的`mbstring`功能的代码。正如您所了解的，`mbstring`扩展的更改在很大程度上反映了对等核心PHP字符串函数的更改。
- en: You also learned about major changes to the `GD`, `Reflection`, and `ZIP` extensions.
    In this chapter, you also learned about changes to a number of database extensions,
    as well as a medley of additional extension changes to note. All in all, with
    the awareness you will have gained by reading this chapter and by studying the
    examples, you are now in a better position to prevent your applications from failing
    after you have performed a PHP 8 upgrade.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 您还了解了`GD`、`Reflection`和`ZIP`扩展的重大变化。在本章中，您还了解了对一些数据库扩展的更改，以及需要注意的其他扩展变化。总的来说，通过阅读本章并学习示例，您现在更有能力在进行PHP
    8升级后防止应用程序出现故障。
- en: In the next chapter, you will learn about functionality that has been deprecated
    or removed in PHP 8.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解到在PHP 8中已被弃用或移除的功能。
