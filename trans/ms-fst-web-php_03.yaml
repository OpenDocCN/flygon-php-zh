- en: Harnessing the Power of PHP 7 Data Structures and Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用PHP 7数据结构和函数的强大功能
- en: In this chapter, we will learn how to harness PHP 7's performance boosts using
    most of its key optimizations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何利用PHP 7的性能优化。
- en: Also, we will explore how better understanding data structures and datatypes,
    and how using simplified functions can help a PHP application's global performance
    along its critical execution path.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将探讨更好地理解数据结构和数据类型，以及如何使用简化的函数可以帮助PHP应用程序在其关键执行路径上提高全局性能。
- en: Moreover, we will learn how it is best to avoid using inefficient structures,
    like most dynamic ones, in our PHP code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将学习如何避免在PHP代码中使用效率低下的结构，比如大多数动态结构。
- en: Finally, although PHP is not a functional language, we will see how some functional
    techniques can be of immediate help when optimizing PHP code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽管PHP不是一种函数式语言，但我们将看到一些函数式技术在优化PHP代码时可以立即提供帮助。
- en: 'Thus, in this chapter, we will cover the following points:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下几点：
- en: PHP 7 optimizations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 7的优化
- en: Identifying possible optimizations and avoiding dynamic structures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别可能的优化并避免动态结构
- en: Functional programming and memoization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程和记忆化
- en: PHP 7 optimizations
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP 7的优化
- en: PHP 7 is in itself a major optimization. A good part of PHP's code base was
    rewritten for this release and most official benchmarks show that, generally speaking,
    almost any PHP code will run about two times faster or more with PHP 7 than with
    previous versions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7本身就是一个重大的优化。PHP的大部分代码库都是为了这个版本而重写的，大多数官方基准测试显示，一般来说，几乎任何PHP代码在PHP 7上运行的速度都比以前的版本快两倍或更多。
- en: PHP is programmed in C and optimizing the performance of Zend's **Ahead-Of-Time**
    (**AOT**) compiler depends ultimately on using the C compiler's internal logic
    in an optimized way. This latest version of PHP is the result of many years of
    research and experiments by Zend. The greater part of these optimizations was
    implemented by eliminating the performance overhead generated by certain PHP internal
    structural constructs and data structures. According to *Dmitry Stogov[1]*, *a
    typical real-life PHP application spends about 20% of the CPU time in the memory
    manager, 10% doing hash table operations, 30% in internal functions and only 30%
    in the VM.* In order to optimize the execution of PHP code, PHP 7's new version
    of the Zend Engine had to start by representing source code in an **Abstract Syntax
    Tree** (**AST**), thus allowing the engine to generate better quality **Intermediate
    Representations** (**IR**) of the source code and, since PHP 7.1, to be able to
    remove dead code and reduce as many expressions as possible to their static representation
    through **Static Single Assignment** (**SSA**) form and type inference. In turn,
    this allows the engine to only allocate necessary data structures to the stack
    instead of the heap in memory at runtime.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: PHP是用C编程的，优化Zend的**Ahead-Of-Time**（**AOT**）编译器的性能最终取决于以优化的方式使用C编译器的内部逻辑。PHP
    7的最新版本是Zend多年研究和实验的结果。这些优化的大部分是通过消除由某些PHP内部结构构造和数据结构产生的性能开销来实现的。根据*Dmitry Stogov[1]*的说法，*典型的现实生活中的PHP应用程序大约有20%的CPU时间用于内存管理器，10%用于哈希表操作，30%用于内部函数，只有30%用于虚拟机。*为了优化PHP代码的执行，PHP
    7的Zend引擎的新版本必须首先将源代码表示为**抽象语法树**（**AST**），从而使引擎能够生成更高质量的**中间表示**（**IR**）源代码，并且自PHP
    7.1以来，能够删除死代码并尽可能将许多表达式转换为它们的静态表示形式，通过**静态单赋值**（**SSA**）形式和类型推断。反过来，这使得引擎只需在运行时将必要的数据结构分配到堆栈而不是内存中的堆中。
- en: This is very important in order to understand the rest of this chapter, as it
    allows us to see why datatype juggling and dynamic structures in general will
    create most of the overhead by bloating memory allocation at runtime, why certain
    data structures had to be re-implemented to allow for C-level performance and
    why immutability is a developer's ally when trying to achieve better code performance.
    Let's have a look at these elements more closely.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于理解本章的其余部分非常重要，因为它让我们看到为什么数据类型转换和动态结构通常会通过在运行时膨胀内存分配来创建大部分开销，为什么必须重新实现某些数据结构以实现C级性能，以及为什么不可变性是开发人员在努力实现更好代码性能时的盟友。让我们更仔细地看看这些元素。
- en: Strict typing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 严格类型
- en: When a language is dynamically typed, that is to say, it has loosely typed variables,
    it provides a higher level of abstraction that boosts the developer's productivity,
    but doesn't offer the best performance since its compiler has more work to do
    when trying to determine the datatypes of its variables. It comes as no surprise
    that strongly typed languages have always had better performance at runtime than
    loosely typed ones. This conclusion was confirmed by Facebook's HipHop project,
    which conducted benchmark tests with different languages and came to the conclusion
    that statically compiled languages always execute more quickly and consume less
    memory than dynamic ones.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当一种语言是动态类型的，也就是说，它具有松散类型的变量，它提供了更高级的抽象，提高了开发人员的生产力，但在尝试确定变量的数据类型时，编译器需要更多的工作，因此性能并不是最佳的。毫不奇怪，强类型语言在运行时的性能总是比松散类型的语言更好。这个结论得到了Facebook的HipHop项目的证实，该项目对不同语言进行了基准测试，并得出结论：静态编译的语言总是比动态语言执行更快，消耗的内存也更少。
- en: 'Although PHP 7 is still a loosely typed language, it now offers the possibility
    to strict type variables and function signatures. This can be easily tested by
    executing the following code example. Let''s run the following code to see its
    current performance:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管PHP 7仍然是一种松散类型的语言，但现在它提供了严格类型化变量和函数签名的可能性。可以通过执行以下代码示例来轻松测试。让我们运行以下代码来查看其当前性能：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here are the results of running this script using `Blackfire.io`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`Blackfire.io`运行此脚本的结果：
- en: '![](assets/f09bed69-e006-4a81-a39f-ad95751fbe9e.png)The profiling report when
    omitting to do strict typing of variables and function signatures'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 省略变量和函数签名的严格类型化时的分析报告
- en: 'Now, let''s replace the code with the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用以下代码替换原来的代码：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we execute it, we will immediately see the difference in performance:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行它，我们会立即看到性能上的差异：
- en: '![](assets/694aceeb-df0c-4312-ac07-845f920538f7.png)The profiling report when
    strict typing variables and function signatures'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/694aceeb-df0c-4312-ac07-845f920538f7.png)在严格类型变量和函数签名的性能分析报告'
- en: 'The performance boost can also be seen using the `microtime()` function. Let''s
    run both versions of our script and see the result:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`microtime()`函数也可以看到性能提升。让我们运行我们脚本的两个版本，看看结果：
- en: '![](assets/6eceebe1-668a-4c3c-8749-bb70f9ff3648.png)Comparing script performance
    with the microtime() function'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6eceebe1-668a-4c3c-8749-bb70f9ff3648.png)使用microtime()函数比较脚本性能'
- en: In order to fully benefit from PHP's new AST and SSA features, developers should
    try to strictly type variables and function signatures as much as possible. This
    will become especially true when the Zend Engine gets, in future releases, a **Just-In-Time**
    (**JIT**) compiler as this will allow for further optimizations solely based on
    type inference.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用PHP的新AST和SSA功能，开发人员应尽可能严格地对变量和函数签名进行类型限定。当Zend引擎在未来版本中获得**即时**（**JIT**）编译器时，这将变得尤为重要，因为这将允许基于类型推断进行进一步的优化。
- en: Also, an added bonus of strict typing is that it lets the compiler manage an
    aspect of code quality by eliminating the necessity of having unit tests that
    simply make sure that functions are behaving as expected when receiving unexpected
    inputs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 严格类型的另一个附加优势是，它让编译器管理代码质量的一个方面，消除了需要进行单元测试来确保函数在接收到意外输入时表现如预期的必要性。
- en: Immutable and packed arrays
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变和紧凑数组
- en: 'As we will see later in this chapter, immutability not only helps the developer
    lessen his cognitive burden while programming and makes for better quality code
    and better unit tests in general, but will also allow for better code optimizations
    by the compiler. As of PHP 7, any static array is cached by OPcache and a pointer
    to the array is shared with any part of the code that tries to access it. Moreover,
    PHP 7 offers a very important optimization for packed arrays, which are arrays
    that are indexed with ascending integers only. Let''s take the following code
    and execute it against PHP 5.6 and then PHP 7 with OPcache enabled:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章后面看到的，不可变性不仅有助于开发人员在编程时减轻认知负担，提高代码质量和一般单元测试的质量，而且还将允许编译器进行更好的代码优化。从PHP
    7开始，任何静态数组都会被OPcache缓存，并且指向数组的指针将与尝试访问它的代码的任何部分共享。此外，PHP 7为紧凑数组提供了一个非常重要的优化，这些数组只使用升序整数进行索引。让我们拿以下代码来对比在启用OPcache的PHP
    5.6和PHP 7上执行的结果：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we run the previous code with PHP 5.6, we consume almost 7.4 MB of memory
    and the elapsed time is 0.005 seconds:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用PHP 5.6运行之前的代码，我们会消耗近7.4MB的内存，耗时为0.005秒：
- en: '![](assets/df382441-74a2-45f4-92f1-fc2e750ab0d2.png)The results when running
    the script against PHP 5.6'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/df382441-74a2-45f4-92f1-fc2e750ab0d2.png)在PHP 5.6上运行脚本时的结果'
- en: 'If we run the same code with PHP 7, we get the following result:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用PHP 7运行相同的代码，我们会得到以下结果：
- en: '![](assets/49b7fa67-c85d-412a-8889-450f65f22082.png)The results when running
    the same script against PHP 7.1'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/49b7fa67-c85d-412a-8889-450f65f22082.png)在PHP 7.1上运行相同脚本时的结果'
- en: The results are impressive. The same script is 40 times faster and consumes
    almost 10 times less memory. Immutable arrays therefore provide more speed and
    developers should avoid modifying large arrays and encourage the use of packed
    arrays as much as possible when dealing with large arrays in order to optimize
    memory allocation and maximize speed at runtime.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 结果令人印象深刻。相同的脚本快了40倍，内存消耗几乎减少了10倍。因此，不可变数组提供了更快的速度，开发人员应该避免修改大数组，并在处理大数组时尽可能使用紧凑数组，以优化内存分配并最大化运行时速度。
- en: Memory allocation of integers and floats
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数和浮点数的内存分配
- en: 'Another optimization introduced by PHP 7 is the reuse of previously allocated
    variable containers. If you need to create a large number of variables, you should
    try to reuse them, as PHP 7''s compiler will avoid reallocating memory and reuse
    the memory slots that are already allocated. Let''s have a look at the following
    example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7引入的另一个优化是重用先前分配的变量容器。如果你需要创建大量的变量，你应该尝试重用它们，因为PHP 7的编译器将避免重新分配内存，并重用已经分配的内存槽。让我们看下面的例子：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s run this code against PHP 5.6 and PHP 7 in order to see the difference
    in memory consumption. Let''s start with PHP 5.6:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这段代码，以便看到内存消耗的差异。让我们从PHP 5.6开始：
- en: '![](assets/2473ad97-fcf2-4790-bbbf-f365b20254a6.png)The results when running
    the script against PHP 5.6'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2473ad97-fcf2-4790-bbbf-f365b20254a6.png)在PHP 5.6上运行脚本时的结果'
- en: 'Now, let''s run the same script with PHP 7:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用PHP 7运行相同的脚本：
- en: '![](assets/7b7954ca-cba2-44a4-b588-c7efb8e78b2d.png)The results when running
    the same script against PHP 7.1'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/7b7954ca-cba2-44a4-b588-c7efb8e78b2d.png)在PHP 7.1上运行相同脚本时的结果'
- en: As you can see, the results show us that memory consumption was reduced by almost
    a third. Although this goes against the very principle of the immutability of
    variables, it is still a very important optimization when you must allocate a
    large number of variables in memory.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，结果显示内存消耗减少了近三分之一。尽管这违背了变量不可变的原则，但当你必须在内存中分配大量变量时，这仍然是一个非常重要的优化。
- en: String interpolation and concatenation
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串插值和连接
- en: 'In PHP 7, string interpolation has been optimized with a new string analysis
    algorithm. This means that string interpolation is now much faster than concatenation
    and that what used to be true about concatenation and performance is no longer
    the case. Let''s take the following code example in order to measure the new algorithm''s
    performance:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中，使用新的字符串分析算法对字符串插值进行了优化。这意味着字符串插值现在比连接快得多，过去关于连接和性能的说法不再成立。让我们拿以下代码示例来衡量新算法的性能：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here are the performance measurements when running this code against PHP 5.6:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行这段代码时，以下是对PHP 5.6的性能测量：
- en: '![](assets/aff9b54f-71a9-43e0-8a4c-ddd1dc2dda5b.png)The results when running
    the script against PHP 5.6'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/aff9b54f-71a9-43e0-8a4c-ddd1dc2dda5b.png)针对PHP 5.6运行相同脚本的结果'
- en: 'And here is the same script with PHP 7:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用PHP 7的相同脚本：
- en: '![](assets/a82a65f3-b669-4d74-9811-9ff5d1bc9e49.png)The results when running
    the same script against PHP 7.1'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a82a65f3-b669-4d74-9811-9ff5d1bc9e49.png)针对PHP 7.1运行相同脚本的结果'
- en: PHP 7 is about three to four times faster and consumes more than a third less
    memory. The lesson to be learned here is to try using PHP 7's string interpolation
    algorithm as much as possible when dealing with strings.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7大约快三到四倍，并且消耗的内存比少了三分之一。这里要学到的教训是，在处理字符串时，尽量使用PHP 7的字符串插值算法。
- en: Parameter references
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数引用
- en: 'Even though it is best to avoid passing a variable by reference to a function
    in order to avoid altering your application''s state outside of the function,
    PHP 7 makes it possible to pass variables by reference to functions in a highly
    optimized way even if the reference is a mismatch. Let''s take the following code
    example in order to better understand how PHP 7 is much more efficient in doing
    so than PHP 5:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管最好避免将变量通过引用传递给函数，以避免在函数外部改变应用程序的状态，但PHP 7使得以高度优化的方式传递变量给函数成为可能，即使引用不匹配。让我们看下面的代码示例，以更好地理解PHP
    7在这方面比PHP 5更有效率：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s run this code with the PHP 5 binary:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用PHP 5二进制运行这段代码：
- en: '![](assets/68ecb6f7-c0d3-4e15-9be6-4de0b577dcb6.png)The results when running
    the script against PHP 5.6'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/68ecb6f7-c0d3-4e15-9be6-4de0b577dcb6.png)针对PHP 5.6运行脚本的结果'
- en: 'Here is the result when executing the same code with PHP 7:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行相同的代码时，PHP 7的结果如下：
- en: '![](assets/817ef153-f0e1-44f3-b593-8c1d37f9f150.png)The results when running
    the same script against PHP 7.1'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/817ef153-f0e1-44f3-b593-8c1d37f9f150.png)针对PHP 7.1运行相同脚本的结果'
- en: The results are once more very impressive as PHP 7 does the same work with almost
    a third less memory allocation and 1,000 times faster! What is happening under
    the hood is that PHP 7 no longer makes copies in memory of variables when a reference
    mismatch occurs. Thus, the new compiler avoids bloating memory allocation for
    nothing and speeds up the execution of any PHP script where reference mismatches
    are an issue.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7的结果再次非常令人印象深刻，它几乎以三分之一的内存分配和1000倍的速度完成了相同的工作！在幕后发生的是，当引用不匹配时，PHP 7不再在内存中复制变量。因此，新的编译器避免了为无用的内存分配膨胀，并加快了任何PHP脚本的执行，其中引用不匹配是一个问题。
- en: Identifying more possible optimizations
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别更多可能的优化。
- en: When optimizing an application, you will start by identifying the most time-consuming
    functions, especially along the application's critical path. As stated in a previous
    chapter, most of those functions will be I/O functions as these are always the
    most expensive operations for a computer to execute. Most of the time you will
    see the possibility to optimize loops and reduce the number of system calls, but
    you will soon realize that I/O operations remain costly no matter what optimizations
    you wish to bring to them. Sometimes, though, you might run into very slow PHP
    structures that can simply be replaced with faster ones, or you may realize that
    poorly designed code can easily be refactored to be less resource-hungry, such
    as when replacing a dynamic structure with a simpler static one.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化应用程序时，您将首先确定最耗时的函数，特别是沿着应用程序的关键路径。正如前一章所述，大多数这些函数将是I/O函数，因为这些函数对计算机来说总是最昂贵的操作。大多数情况下，您会看到优化循环和减少系统调用的可能性，但很快您会意识到，无论您希望对其进行何种优化，I/O操作始终是昂贵的。不过，有时您可能会遇到非常慢的PHP结构，可以简单地用更快的结构替换，或者您可能会意识到，设计不良的代码可以很容易地重构为更节约资源，比如用更简单的静态结构替换动态结构。
- en: 'Indeed, dynamic structures should be avoided unless absolutely necessary. We
    will now have a look at a very simple example. We will program the same functionality
    four times, but with three different approaches: functional and dynamic, functional
    and static, and finally, structural and static. Let''s start with the functional
    and dynamic approach:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，除非绝对必要，应避免使用动态结构。现在我们来看一个非常简单的例子。我们将使用三种不同的方法编写相同的功能四次：函数和动态、函数和静态，最后是结构和静态。让我们从函数和动态方法开始：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code creates an array with 1,000 elements by calling the same closure
    recursively. If we run this code, we get the following result:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过递归调用相同的闭包来创建一个包含1,000个元素的数组。如果我们运行这段代码，我们会得到以下结果：
- en: '![](assets/310cd67e-f945-42ef-9ed8-f35f6e010b06.png)Time elapsed and memory
    consumed when running the script programmed with the functional and dynamic approach'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/310cd67e-f945-42ef-9ed8-f35f6e010b06.png)使用函数和动态方法编写的脚本运行时所消耗的时间和内存'
- en: 'Let''s have a look at the results of running this script using `Blackfire.io`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`Blackfire.io`运行此脚本的结果：
- en: '![](assets/865efdb5-9f6d-4340-acfc-691e6fd1940a.png)The profiling report when
    running the script programmed with the functional and dynamic approach'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/865efdb5-9f6d-4340-acfc-691e6fd1940a.png)使用函数和动态方法编写的脚本运行时的性能报告'
- en: 'Let''s code the same functionality, but in a more static fashion with a classic
    named function instead:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以更静态的方式编写相同的功能，使用经典的命名函数：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we execute this version of our code, we obtain the following result:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行这个版本的代码，我们会得到以下结果：
- en: '![](assets/1d09776a-1981-4715-a040-1409ede0791b.png)Time elapsed and memory
    consumed when running the script programmed with the functional and static approach'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/1d09776a-1981-4715-a040-1409ede0791b.png)使用函数和静态方法编写的脚本运行时所消耗的时间和内存'
- en: 'Running the script with the `Blackfire.io` profiler yields these results:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Blackfire.io`分析器运行脚本产生了以下结果：
- en: '![](assets/532b428d-1d99-4a5a-bf3d-814a59bb8755.png)The profiling report when
    running the script programmed with the functional and static approach'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/532b428d-1d99-4a5a-bf3d-814a59bb8755.png)使用函数和静态方法编写的脚本运行时的性能报告'
- en: 'Finally, let''s program this functionality again, but in a very structural
    and static way by using a `for` loop instead of tail-calling the function recursively:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们再次以非常结构化和静态的方式编写这个功能，而不是通过尾递归调用函数：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here are the results after executing this latest version of the code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行代码的最新版本后，以下是结果：
- en: '![](assets/38692ba5-dce2-4731-82d6-a4e9ac58f5fb.png)Time elapsed and memory
    consumed when running the script programmed with the structural and static approach'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/38692ba5-dce2-4731-82d6-a4e9ac58f5fb.png)运行使用结构化和静态方法编程的脚本时所消耗的时间和内存'
- en: 'Here are the results of profiling this version of the script with `Blackfire.io`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Blackfire.io`对这个脚本版本进行分析的结果如下：
- en: '![](assets/8e1edd60-f97e-4acc-bce6-dc8d84e5a2a5.png)The profiling report when
    running the script programmed with the structural and static approach'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/8e1edd60-f97e-4acc-bce6-dc8d84e5a2a5.png)运行使用结构化和静态方法编程的脚本时的分析报告'
- en: 'The results clearly show that the structural approach is the fastest. If we
    now go a little further down the structural route, with only a hint of functional
    programming, and try using a generator to create the array iteratively, we should
    not be surprised by the high performance results that we will get. Here is the
    last version of our code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 结果清楚地显示了结构化方法是最快的。如果我们现在沿着结构化的路线再走一小步，只是稍微使用一点功能性编程，并尝试使用生成器来迭代创建数组，我们对将获得的高性能结果不应感到惊讶。以下是我们代码的最新版本：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the result when running the latest version of our code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行我们代码的最新版本的结果：
- en: '![](assets/c3201960-6ec7-4e70-92cb-98af3f9ca57a.png)Time elapsed and memory
    consumed when running the script programmed with a very structural and static
    approach'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c3201960-6ec7-4e70-92cb-98af3f9ca57a.png)运行使用非常结构化和静态方法编程的脚本时所消耗的时间和内存'
- en: 'Here are the results with `Blackfire.io`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Blackfire.io`的结果如下：
- en: '![](assets/f6f60c39-b8b5-4b8a-91fa-6b5cb6076733.png)The profiling report when
    running the script programmed with a very structural and static approach'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/f6f60c39-b8b5-4b8a-91fa-6b5cb6076733.png)运行使用非常结构化和静态方法编程的脚本时的分析报告'
- en: The results clearly show how this last version of our code really outperforms
    the other ones. Indeed, PHP is still a very structural language as its compiler
    still does not fully optimize tail-recursion calls and does take less time to
    complete the execution of a program if it is coded in a structural way. Does this
    mean that PHP will never be a functional language and that it is best to avoid
    programming in a functional way in PHP? The short answer is no. Also, does this
    mean that functional programming with PHP is a thing of the future only? Again,
    the answer is no. There are certain functional programming techniques that we
    can use immediately and that will help our scripts be more performant. Let's have
    a look at one in particular, which is memoization.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 结果清楚地显示了我们代码的这个最新版本确实优于其他版本。事实上，PHP仍然是一种非常结构化的语言，因为它的编译器仍然没有完全优化尾递归调用，并且如果以结构化方式编写程序，则完成程序执行所需的时间更短。这是否意味着PHP永远不会成为一种功能性语言，最好避免在PHP中以功能性方式编程？简短的答案是否定的。这是否意味着使用PHP进行功能性编程只是未来的事情？同样，答案也是否定的。有一些功能性编程技术可以立即使用，并且将帮助我们的脚本更具性能。让我们特别看一下其中一种技术，即记忆化。
- en: Functional programming and memoization
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程和记忆化
- en: PHP is an imperative and not a declarative language, which means that programming
    is done using statements that alter the state of the program, just like other
    languages in the C family, and it is not composed of stateless expressions or
    declarations, like SQL for example. Though PHP is primarily a structural (procedural)
    and object-oriented programming language, we have seen, since PHP 5.3, more and
    more requests for change that asked for more and more structures that are functional
    in nature, such as generators and lambda functions (anonymous functions). Nevertheless,
    PHP remains for now a structural language in nature, especially when it comes
    to performance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: PHP是一种命令式而不是声明式语言，这意味着编程是通过改变程序状态的语句来完成的，就像C语言系列中的其他语言一样，它不是由无状态表达式或声明组成的，比如SQL。尽管PHP主要是一种结构化（过程式）和面向对象的编程语言，但自PHP
    5.3以来，我们已经看到越来越多的请求要求更多的功能性结构，比如生成器和lambda函数（匿名函数）。然而，就性能而言，PHP目前仍然是一种结构化语言。
- en: This being said, most functional programming techniques will yield fruit a few
    years from now, but there are still some functional programming techniques that
    can be used immediately in PHP that will improve performance as soon as you implement
    them in the code base of a project. One such technique is memoization.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，大多数功能性编程技术将在未来几年内产生成果，但仍然有一些功能性编程技术可以立即在PHP中使用，一旦在项目的代码库中实施，就会提高性能。其中一种技术就是记忆化。
- en: Memoization is a functional programming technique in which the result of an
    expensive functional computation is stored and reused each time it is called within
    the same program. The idea is to return the static value of a function when it
    receives a certain input. Obviously, to avoid the invalidation of values, the
    function should be referentially transparent, which means that it should always
    return the same output when given a specific input. Of course, this comes in handy
    when you realize that a referentially transparent function is called many times
    along the critical path of an application and is computed every time. Memoization
    is an easy optimization to implement as it simply creates a cache to store the
    results of the computation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化是一种函数式编程技术，它将昂贵的函数计算的结果存储并在同一程序中每次调用时重复使用。其思想是在接收特定输入时返回函数的静态值。显然，为了避免值的失效，函数应该是引用透明的，这意味着当给定特定输入时，它应该始终返回相同的输出。当你意识到引用透明函数在应用程序的关键路径上被多次调用并且每次都被计算时，这就派上了用场。记忆化是一种简单的优化实现，因为它只是创建一个缓存来存储计算的结果。
- en: 'Let''s look at a simple example that will help us easily grasp the idea behind
    it. Let''s say we have the following code along the critical path of an application:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的例子，这将帮助我们轻松地理解其背后的思想。假设我们有以下代码沿着应用程序的关键路径：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we see that the same function is called recursively many times. Moreover,
    it is a referentially transparent function. Therefore, it is a perfect candidate
    for memoization.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到同一个函数被递归调用了很多次。而且，它是一个引用透明的函数。因此，它是记忆化的一个完美候选者。
- en: 'Let''s start by checking its performance. If we execute the code, we will get
    the following result:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查其性能开始。如果我们执行代码，我们将得到以下结果：
- en: '![](assets/4111c620-6852-4dc9-8a5a-88e2e5370845.png)The results before implementing
    memoization'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/4111c620-6852-4dc9-8a5a-88e2e5370845.png)在实施记忆化之前的结果'
- en: 'Now, let''s implement a cache to memoize the results:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实施一个缓存来记忆化结果：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here are the results when executing this new version of the same code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行相同代码的新版本时的结果：
- en: '![](assets/c8626594-4df0-4a81-9a97-cc503216f617.png)The results after implementing
    memoization'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c8626594-4df0-4a81-9a97-cc503216f617.png)在实施记忆化后的结果'
- en: As we can see, the PHP script now runs much faster. The more often a referentially
    transparent function is called along the critical path of your application, the
    more the speed will increase when using memoization. Let's have a look at our
    script's performance using `Blackfire.io`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，PHP脚本现在运行得更快了。当在应用程序的关键路径上调用引用透明函数的次数越多时，使用记忆化时速度就会增加得越多。让我们使用`Blackfire.io`来查看我们脚本的性能。
- en: 'Here are the results when executing the script without memoization:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在没有使用记忆化时执行脚本的结果：
- en: '![](assets/d9cbb171-7264-4da1-ab25-a6137c8c10a7.png)The profiling report when
    not using memoization'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/d9cbb171-7264-4da1-ab25-a6137c8c10a7.png)在不使用记忆化时的性能分析报告'
- en: 'Here are the results with memoization:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用记忆化后的结果：
- en: '![](assets/30e818e4-d067-4b3c-ac71-7a3317063b81.png)The profiling report when
    using memoization'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/30e818e4-d067-4b3c-ac71-7a3317063b81.png)使用记忆化时的性能分析报告'
- en: The comparison shows that the memoized version of the script runs about eight
    times faster and consumes a third less memory. An important gain in performance
    for such an easy implementation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 比较显示，脚本的记忆化版本运行大约快了八倍，并且消耗的内存少了三分之一。对于这样一个简单的实现来说，性能上的重要提升。
- en: 'One final question concerning memoization might be: can we cache the result
    between runs of the same script? Of course we can. It is up to you to determine
    the best way to cache it. You can use any standard way of caching a result. Also,
    there is at least one library that you can use to cache memoized results in PHP.
    You will find it at the following address: [https://github.com/koktut/php-memoize](https://github.com/koktut/php-memoize).
    Please be aware that this library would not have been a good option for our last
    script as it doesn''t work well with recursive tail-calls.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 关于记忆化的最后一个问题可能是：我们可以在同一个脚本的多次运行之间缓存结果吗？当然可以。由你来确定最佳的缓存方式。你可以使用任何标准的缓存结果的方式。此外，至少有一个库可以用来在PHP中缓存记忆化的结果。你可以在以下地址找到它：[https://github.com/koktut/php-memoize](https://github.com/koktut/php-memoize)。请注意，这个库对于我们上一个脚本来说不是一个好的选择，因为它与递归尾调用不兼容。
- en: Summary
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how PHP 7 is an optimization in itself, how
    avoiding dynamic structures in general will always boost the performance of your
    PHP scripts and how certain functional programming techniques such as memoization
    can be strong allies when optimizing code performance.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了PHP 7本身是一个优化，如何避免一般动态结构总是会提升PHP脚本的性能，以及某些函数式编程技术，比如记忆化，在优化代码性能时可以是强大的盟友。
- en: In the next chapter, we will learn how to cope with input and output (I/O) poor
    latency by learning about generators and asynchronous non-blocking code, multithreading
    with the POSIX threads (`pthreads`) library and multitasking with the `ReactPHP`
    library.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过学习生成器和异步非阻塞代码、使用POSIX线程（`pthreads`）库进行多线程处理，以及使用`ReactPHP`库进行多任务处理来应对输入和输出（I/O）延迟较大的情况。
- en: Reference
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考
- en: '[http://news.php.net/php.internals/73888](http://news.php.net/php.internals/73888)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://news.php.net/php.internals/73888](http://news.php.net/php.internals/73888)'
