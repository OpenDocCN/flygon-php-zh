- en: Chapter 8.  Building a Parser and Interpreter for a Custom Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。为自定义语言构建解析器和解释器
- en: Extensibility and adaptability are often the required features in enterprise
    applications. Often, it is useful and practical-or even an actual feature requirement
    by users-to change an application's behavior and business rules at runtime. Imagine,
    for example, an e-commerce application in which sales representatives can configure
    business rules themselves; for example, when the system should offer free shipping
    for a purchase or should apply a certain discount when some special conditions
    are met (offer free shipping when the purchase amount exceeds 150 Euros , and
    the customer has already made two or more purchases in the past or has been a
    customer for more than a year).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性和适应性通常是企业应用程序中所需的功能。通常，动态更改应用程序的行为和业务规则是有用的、实际的，甚至是用户的实际功能要求。例如，想象一下，一个电子商务应用程序中，销售代表可以自行配置业务规则；例如，当系统应该为购买提供免费运输或者在满足某些特殊条件时应用一定的折扣（当购买金额超过150欧元时提供免费运输，并且客户已经在过去进行了两次或更多次购买，或者已经是客户超过一年）。
- en: By experience, rules such as these tend to get ridiculously complex (offer a
    discount when the customer is male and is older than 35 years and has two kids
    and a cat named Mr. Whiskers and placed the purchase order on a cloudless full-moon
    night) and may change frequently. For this reason, as a developer, you might actually
    be glad to offer your user a possibility to configure rules such as these for
    themselves, instead of having to update, test, and redeploy the application every
    time one of these rules changes. A feature like this is called **end-user development**
    and is often implemented using  **domain-specific languages**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 根据经验，这些规则往往变得非常复杂（当客户是男性且年龄超过35岁并且有两个孩子和一只名叫Whiskers先生的猫，并且在一个没有云的满月之夜下放置购买订单时提供折扣），并且可能经常发生变化。因此，作为开发人员，您可能会很高兴为用户提供配置此类规则的可能性，而不是每次这些规则之一发生变化时都必须更新、测试和重新部署应用程序。这样的功能称为**最终用户开发**，通常使用**特定领域语言**来实现。
- en: Domain-specific languages are languages that are tailored for one specific application
    domain (in contrast to general-purpose languages, such as C, Java or-you guessed
    it-PHP). In this chapter, we will build our own parser for a small expression
    language that can be used to configure business rules in enterprise applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 特定领域语言是针对特定应用领域定制的语言（与通用语言相对，如C、Java或者您猜对了PHP）。在本章中，我们将为企业应用程序中的业务规则构建自己的小型表达式语言的解析器。
- en: For this, we'll need to recapitulate how a parser works and how formal languages
    are described using formal grammars.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要回顾解析器的工作原理以及如何使用形式语法描述形式语言。
- en: How interpreters and compilers work
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释器和编译器的工作原理
- en: Interpreters and compilers read programs that are formulated in a programming
    language. They either execute them directly (interpreters) or first convert them
    into a machine language or another programming language (compilers). Both interpreters
    and compilers usually have (among others) two components called **lexer** and
    **parser**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器和编译器读取用编程语言编写的程序。它们可以直接执行它们（解释器），或者首先将它们转换为机器语言或另一种编程语言（编译器）。解释器和编译器通常都有（除其他外）称为**词法分析器**和**解析器**的两个组件。
- en: '![How interpreters and compilers work](graphics/image_08_001.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![解释器和编译器的工作原理](graphics/image_08_001.jpg)'
- en: This is a basic architecture of a compiler or interpreter
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是编译器或解释器的基本架构
- en: An interpreter may omit the code generation and run the parsed program directly
    without a dedicated compilation step.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器可能省略代码生成，并直接运行解析后的程序，而无需专门的编译步骤。
- en: 'The **lexer** (also called **scanner** or **tokenizer**) dissects an input
    program into its smallest possible parts, the so-called tokens. Each token consists
    of a token class (for example, numerical value or variable identifier) and the
    actual token contents. For example, a lexer for a calculator given the input string
    `2 + (3 * a)` might generate the following list of tokens (each having a token
    class and value):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**词法分析器**（也称为**扫描器**或**标记器**）将输入程序分解为可能的最小部分，即所谓的标记。每个标记由标记类（例如，数值或变量标识符）和实际的标记内容组成。例如，给定输入字符串`2
    + (3 * a)`的计算器的词法分析器可能生成以下标记列表（每个标记都有一个标记类和值）：'
- en: Number ("`2`")
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字（“`2`”）
- en: Addition operator ("`+`")
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加法运算符（“`+`”）
- en: Opening bracket ("`(`")
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开放括号（“`（`”）
- en: Number ("`3`")
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字（“`3`”）
- en: Multiplication operator ("`*`")
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 乘法运算符（“`*`”）
- en: Variable identifier ("`a`")
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量标识符（“`a`”）
- en: Closing bracket ("`)`")
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 闭合括号（“`）`”）
- en: 'In the next step, the **parser** takes the token streams and tries to derive
    the actual program structure from this stream. For this, the parser needs to be
    programmed with a set of rules that describe the input language, a grammar. In
    many cases, a parser generates a data structure that represents the input program
    in a structured tree; the so-called syntax tree. For example, the input string
    `2 + (3 * a)` generates the following syntax tree:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，**解析器**获取令牌流并尝试从该流中推导出实际的程序结构。为此，解析器需要使用一组描述输入语言的规则，即语法。在许多情况下，解析器生成表示结构化树中的输入程序的数据结构；所谓的语法树。例如，输入字符串`2
    + (3 * a)`生成以下语法树：
- en: '![How interpreters and compilers work](graphics/image_08_002.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![解释器和编译器的工作原理](graphics/image_08_002.jpg)'
- en: An Abstract Syntax Tree (AST) that can be generated from the expression 2 +
    (3 * a)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从表达式2 +（3 * a）生成的抽象语法树（AST）
- en: Note that there are programs that will pass the lexical analysis, but in the
    following step, they are recognized as syntactically wrong by the parser. For
    example, the input string called `2 + ( 1` would pass the lexer (and generate
    a token list such as `{Number(2), Addition Operator, Opening bracket, Number(1)}`),
    but it is obviously syntactically wrong as the opening bracket does not make any
    sense without a matching closing bracket (assuming that the parser uses the grammar
    universally recognized for mathematical expressions; in other grammars, `2+(1`
    might actually be a syntactically valid expression)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有些程序将通过词法分析，但在下一步中，它们被解析器识别为语法错误。例如，名为`2 + ( 1`的输入字符串将通过词法分析（并生成诸如`{Number(2),
    Addition Operator, Opening bracket, Number(1)}`的标记列表），但显然在语法上是错误的，因为没有匹配的闭括号（假设解析器使用了普遍认可的数学表达式语法；在其他语法中，`2+(1`实际上可能是一个语法上有效的表达式）
- en: Languages and grammars
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言和语法
- en: In order for a parser to be able to understand a program, it needs a formal
    description of that language-a grammar. In this chapter, we will work with a so-called
    **parsing expression grammar** (**PEG**). A PEG is (relatively) easy to define
    and there are libraries that can generate a parser for a given grammar automatically.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使解析器能够理解程序，它需要该语言的正式描述-语法。在本章中，我们将使用所谓的**解析表达式语法**（**PEG**）。PEG（相对）容易定义，并且有一些库可以自动生成给定语法的解析器。
- en: A grammar consists of **terminal symbols** and **non-terminal symbols**. A non-terminal
    symbol is a symbol that maybe composed of several other symbols, following certain
    rules (**production rules**). For example, a grammar could contain a *number*
    as non-terminal symbol. Each number could be defined as an arbitrary-length sequence
    of digits. As a digit could then be any of the characters from 0 to 9 (with each
    of the actual digits being a terminal symbol).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 语法由**终结符号**和**非终结符号**组成。非终结符号是一个可能由几个其他符号组成的符号，遵循某些规则（**产生规则**）。例如，语法可以包含一个*数字*作为非终结符号。每个数字可以被定义为任意长度的数字序列。然后，一个数字可以是0到9中的任何字符（实际数字中的每个数字都是终结符号）。
- en: 'Let''s try to describe the structure of numbers (and then building on this
    mathematical expressions in general) formally. Let''s start by describing how
    a number looks like. Each number consists of one or more digits, so let''s start
    by describing digits and numbers:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着正式描述数字的结构（然后在此基础上构建数学表达式）。让我们从描述数字的外观开始。每个数字由一个或多个数字组成，所以让我们从描述数字和数字开始：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, Digit is our first non-terminal symbol. The first rule of our
    grammar states that any of the characters 0 to 9 is a digit. In this example,
    the characters '0' to '9' are terminal symbols, the smallest possible building
    blocks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Digit是我们的第一个非终结符号。我们语法的第一个规则规定0到9中的任何字符都是数字。在这个例子中，字符'0'到'9'是终结符号，是最小的可能的构建块。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'In practice, many Parser generators will allow you to use regular expressions
    to match terminal symbols. In the previous example, instead of enumerating all
    possible digits, you could then simply state this: `Digit: /[0-9]/`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，许多解析器生成器允许您使用正则表达式来匹配终结符号。在前面的例子中，您可以简单地陈述这一点，而不是列举所有可能的数字：`Digit: /[0-9]/`'
- en: 'The second rule of our grammar states that a `Number` (our second non-terminal
    symbol) consists of one or more `Digit` symbols (the `+` means repeat once or
    more). Using the same way, we could also expand the grammar to also support decimal
    numbers:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们语法的第二条规则规定`Number`（我们的第二个非终结符号）由一个或多个`Digit`符号组成（`+`表示重复一次或多次）。以同样的方式，我们也可以扩展语法以支持小数：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we''ve introduced two new non-terminal symbols: `Integer` and `Decimal`.
    `Integer` is simply a sequence of digits, while a `Decimal` may start with any
    number of digits (or none at all, which means that a value such as `.12` would
    also be a valid number), then a dot and then one or more digits. In contrast to
    the `+` operator ("repeat once or more") already used above, the `*` operator
    means "none or once or more". The production rule for `Number` now states that
    a number can either be a decimal number or an integer.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们引入了两个新的非终结符号：`Integer`和`Decimal`。`Integer`只是一个数字序列，而`Decimal`可以以任意数量的数字开头（或者根本不开头，这意味着像`.12`这样的值也是一个有效的数字），然后是一个点，然后是一个或多个数字。与上面已经使用的`+`运算符（“重复一次或更多次”）不同，`*`运算符表示“没有或一次或多次”。`Number`的产生规则现在说明一个数字可以是一个小数或一个整数。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Order is important here; given an input string of `3.14`, the integer rule would
    match the `3` of this input string, while the Decimal rule would match the entire
    string. So, in this case it's safer to first try to parse the number as a decimal,
    and when that fails, parse the number as an integer.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序在这里很重要；给定输入字符串`3.14`，整数规则将匹配此输入字符串的`3`，而小数规则将匹配整个字符串。因此，在这种情况下，最好首先尝试将数字解析为小数，当失败时再将数字解析为整数。
- en: 'Right now, this grammar describes only positive numbers. However, it can easily
    be modified to also support negative numbers:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个语法只描述了正数。但是，它可以很容易地修改为支持负数。
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `?` character used in this example states that a symbol is optional. This
    means that both an integer and a decimal number can now optionally start with
    a `-` character.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中使用的`?`字符表示一个符号是可选的。这意味着整数和小数现在可以选择以`-`字符开头。
- en: 'We can now continue to define more rules for our grammar. For example, we could
    add a new rule that describes a multiplication:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续为我们的语法定义更多规则。例如，我们可以添加一个描述乘法的新规则：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As a division is basically the same operation as a multiplication (and has
    the same operator precedence), we can treat both cases with the same rule:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于除法基本上是与乘法相同的操作（并且具有相同的运算符优先级），我们可以使用相同的规则处理这两种情况：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As soon as you add a rule for sums to your grammar, it''s important to consider
    the order of operations (multiplication first, then addition). Let''s define a
    new rule called `Sum` (again, covering both addition and subtraction with one
    rule):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在语法中添加了求和的规则，就重要考虑操作的顺序（先乘法，然后加法）。让我们定义一个名为`Sum`的新规则（再次使用一个规则来涵盖加法和减法）：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This may seem counter intuitive, at first. After all, a sum does not really
    need to consist of two products. However, as our `Product` rule uses `*` as a
    quantifier, it will also match single numbers, allowing expressions such as `5
    + 4` to be parsed as `Product + Product`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这乍一看可能有些反直觉。毕竟，一个总和实际上不需要由两个乘积组成。但是，由于我们的`Product`规则使用`*`作为量词，它也将匹配单个数字，从而允许诸如`5
    + 4`之类的表达式被解析为`Product + Product`。
- en: 'For our grammar to become complete, we still need the ability to parse nested
    statements. As it is, our grammar is able to parse statements such as `2 * 3`,
    `2 + 3`. Even `2 + 3 * 4` will be parsed correctly as `2 + (3 * 4)` (and not `(2
    + 3) * 4`). However, a statement such as `(2 + 3) * 4` does not match any rule
    of our grammar. After all, the `Product` rule states that a product is any number
    of `Number`s joined by `*` characters; since a bracket-enclosed sum does not match
    the `Number` rule, the `Product` rule will not match either. To solve this problem,
    we''ll introduce two new rules:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的语法完整，我们仍然需要能够解析嵌套语句。目前，我们的语法可以解析诸如`2 * 3`、`2 + 3`之类的语句。甚至`2 + 3 * 4`也将被正确解析为`2
    + (3 * 4)`（而不是`(2 + 3) * 4`）。但是，像`(2 + 3) * 4`这样的语句不匹配我们语法的任何规则。毕竟，`Product`规则规定了一个乘积是由`*`字符连接的任意数量的`Number`；由于括号括起来的求和不匹配`Number`规则，因此`Product`规则也不会匹配。为了解决这个问题，我们将引入两个新规则：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With the new `Value` rule, we can adjust the `Product` rule to match either
    regular numbers or bracket-enclosed exceptions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有了新的`Value`规则，我们可以调整`Product`规则以匹配常规数字或括号括起来的例外：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, you will find a complete grammar necessary for describing mathematical
    expressions. It does not support any kind of variables or logical statements yet,
    but it will be a reasonable starting point for our own parser that we''ll build
    in the remainder of this chapter:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将找到描述数学表达式所需的完整语法。它目前还不支持任何类型的变量或逻辑语句，但它将是我们在本章剩余部分中构建的自己的解析器的合理起点：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Your first PEG parser
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第一个PEG解析器
- en: Building a tokenizer and parser from scratch is a very tedious task. Luckily,
    many libraries exist that you can use to generate a parser automatically from
    some kind of formal grammar definition.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始构建标记生成器和解析器是一项非常繁琐的任务。幸运的是，存在许多库可以根据某种形式的形式语法定义自动生成解析器。
- en: 'In PHP, you can use the `hafriedlander/php-peg` library to generate the PHP
    code for a parser for any kind of formal language that can be described by a parsing
    expression grammar. For this, create a new project directory and create a new
    `composer.json` file with the following contents:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，您可以使用`hafriedlander/php-peg`库根据解析表达式语法生成任何形式语言的解析器的PHP代码。为此，创建一个新的项目目录，并创建一个包含以下内容的新`composer.json`文件：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the `hafriedlander/php-peg` library does not use a PSR-0 or PSR-4
    autoloader, but it ships its own class loader instead. Because of this, you cannot
    use composer's built-in PSR-0/4 class loader and need to manually include the
    package's autoloader.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`hafriedlander/php-peg`库不使用PSR-0或PSR-4自动加载程序，而是使用自己的类加载程序。因此，您不能使用composer内置的PSR-0/4类加载程序，需要手动包含该软件包的自动加载程序。
- en: Similar to the previous chapters, we'll be using `Packt\Chp8\DSL` as a base
    namespace for our PSR-4 class loader based in the `src/` directory. This means
    that a PHP class called `Packt\Chp8\DSL\Foo\Bar` should be located in the `src/Foo/Bar.php`
    file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的章节类似，我们将使用`Packt\Chp8\DSL`作为基本命名空间，用于基于`src/`目录的PSR-4类加载器。这意味着名为`Packt\Chp8\DSL\Foo\Bar`的PHP类应该位于`src/Foo/Bar.php`文件中。
- en: When working with PHP PEG, you write a parser as a regular PHP class that contains
    the grammar in a special kind of comment. This class is used as an input file
    for the actual parser generator, which then generates the actual parser source
    code. The file type for the parser input file is typically `.peg.inc`. The parser
    class has to extend the `hafriedlander\Peg\Parser\Basic` class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用PHP PEG时，您将解析器编写为一个包含特殊类型注释中的语法的常规PHP类。此类用作实际解析器生成器的输入文件，然后生成实际的解析器源代码。解析器输入文件的文件类型通常为`.peg.inc`。解析器类必须扩展`hafriedlander\Peg\Parser\Basic`类。
- en: 'Our parser will have the `Packt\Chp8\DSL\Parser\Parser` class name. It will
    be stored in the `src/Parser/Parser.peg.inc` file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解析器将使用`Packt\Chp8\DSL\Parser\Parser`类名。它将存储在`src/Parser/Parser.peg.inc`文件中：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the comment within the class that starts with the `/*!*` characters. This
    special comment block will be picked up by the parser generator and needs to contain
    the grammar from which the parser will be generated.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意类中以`/*!*`字符开头的注释。这个特殊的注释块将被解析器生成器捕获，并且需要包含解析器将被生成的语法。
- en: 'You can then build the actual parser (which will be stored in the file `src/Parser/Parser.php`,
    where it will be able to be picked up by the composer class loader) using the
    PHP-PEG CLI script:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用PHP-PEG CLI脚本构建实际的解析器（它将存储在文件`src/Parser/Parser.php`中，并且可以被composer类加载器捕获）：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `-d pcre.jit=0` flag is required to fix a PHP 7-related bug in the PEG package.
    Disabling the `pcre.jit` flag may have an impact on the program's performance;
    however this flag must only be disabled when the parser is generated. The generated
    parser will not be affected by the `pcre.jit` flag.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用`-d pcre.jit=0`标志来修复与PHP 7相关的PEG包中的错误。禁用`pcre.jit`标志可能会影响程序的性能；但是只有在生成解析器时才能禁用此标志。生成的解析器不会受到`pcre.jit`标志的影响。
- en: 'Currently, the parser generation will fail with an error, because the parser
    class does not yet contain a valid grammar. This can easily be changed; add the
    following lines to the special comment (starting with `/*!*`) in your parser input
    file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，解析器生成将因为解析器类尚未包含有效的语法而失败。这很容易改变；在你的解析器输入文件的特殊注释（以`/*!*`开头）中添加以下行：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You will note that this is exactly the example grammar for matching numbers
    that we've used in the previous section. This means that after rebuilding the
    parser, you will have a parser that knows how numbers look like and can recognize
    them. Admittedly, this is not enough. But we can build on it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这正是我们在前一节中用来匹配数字的示例语法。这意味着重新构建解析器后，你将拥有一个知道数字长什么样并能够识别它们的解析器。诚然，这还不够。但我们可以继续完善。
- en: 'Rebuild your parser by running the `cli.php` script as shown previously and
    continue by creating a test script called `test.php` in your project directory:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`cli.php`脚本重新构建你的解析器，然后在项目目录中创建一个名为`test.php`的测试脚本：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Remember, the `Packt\Chp8\DSL\Parser\Parser` class was automatically generated
    from your `Parser.peg.inc` input file. The class inherits the `hafriedlander\Peg\Parser\Basic`
    class, which also provides the constructor. The constructor accepts an expression
    that the parser should parse.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`Packt\Chp8\DSL\Parser\Parser`类是从你的`Parser.peg.inc`输入文件自动生成的。该类继承了`hafriedlander\Peg\Parser\Basic`类，后者也提供了构造函数。构造函数接受一个表达式，解析器应该解析这个表达式。
- en: For each non-terminal symbol that is defined in your grammar, the parser will
    contain a function named `match_[symbol name]()` (so, for example, `match_Number`)
    that will match the input string against the given rule.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的语法中定义的每个非终结符号，解析器将包含一个名为`match_[符号名称]()`的函数（例如，`match_Number`），该函数将根据给定的规则匹配输入字符串。
- en: 'In our example, `$result1` is the matching result against a valid number (or,
    in general, an input string that''s matched by the parser''s grammar), while the
    input string of `$result2` is obviously not a number and should not be matched
    by the grammar. Let''s have a look at the output of this test script:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`$result1`是与有效数字（或者一般来说，由解析器语法匹配的输入字符串）匹配的结果，而`$result2`的输入字符串显然不是一个数字，不应该被语法匹配。让我们来看看这个测试脚本的输出：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, parsing the first input string returns an array that contains
    both the matching rule and the string that was matched by the rule. If the rule
    did not match (as for example in `$result2`), the `match_*` functions will always
    return `false`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，解析第一个输入字符串返回一个包含匹配规则和被规则匹配的字符串的数组。如果规则没有匹配（例如在`$result2`中），`match_*`函数将始终返回`false`。
- en: 'Let''s continue by adding the remainder of the rules that we''ve already seen
    in the previous section. These will allow our parser to not only parse numbers
    but entire mathematical expressions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加我们在前一节中已经看到的规则的其余部分。这将使我们的解析器不仅能够解析数字，还能够解析整个数学表达式：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Pay special attention to the `> `characters in this code example. Those are
    a special symbol provided by the parser generator that matches whitespace sequences
    of any length. In some grammars, whitespaces might matter, but when parsing mathematical
    expressions, you typically do not care if someone enters `2+3` or `2 + 3`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，特别注意`>`字符。这些是由解析器生成器提供的特殊符号，可以匹配任意长度的空白序列。在一些语法中，空格可能很重要，但在解析数学表达式时，通常不在乎某人输入`2+3`还是`2
    + 3`。
- en: 'Rebuild your parser and adjust your test script to test these new rules:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建你的解析器，并调整你的测试脚本来测试这些新规则：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Pay special attention to the last line. Obviously, the `(1 + 2)) * 3` expression
    is syntactically wrong, because it contains more closing brackets than opening
    brackets. However, the output of the `match_Expr` function for this input statement
    will be the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意最后一行。显然，`(1 + 2)) * 3`表达式在语法上是错误的，因为它包含的右括号比左括号多。然而，对于这个输入语句，`match_Expr`函数的输出将是以下内容：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, the input string still matched the `Expr` rule, just not the
    entire string. The first part of the string, `(1 + 2)`, is syntactically correct
    and mated by the `Expr` rule. This is very important to keep in mind when working
    with the PEG parser. If a rule does not match the entire input string, the parser
    will still match as much of the input as it can. It's up to you, as a user of
    this parser, to determine if a partial match is a good thing or not (in our case,
    this should probably trigger an error, as a partially matched expression would
    result in very strange results and undoubtedly be very surprising for a user).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，输入字符串仍然匹配了`Expr`规则，只是没有匹配整个字符串。字符串的第一部分，`(1 + 2)`，在语法上是正确的，并且符合`Expr`规则。这在使用PEG解析器时非常重要。如果一个规则不能匹配整个输入字符串，解析器仍然会尽可能匹配输入的尽可能多的部分。这取决于你作为解析器的用户来确定部分匹配是好事还是坏事（在我们的情况下，这可能会触发错误，因为部分匹配的表达式会导致非常奇怪的结果，无疑会让用户感到非常惊讶）。
- en: Evaluating expressions
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估表达式
- en: Up until now, we've only used our custom-built PEG parser to check if an input
    string conforms to a given grammar (meaning, we can *tell* if an input string
    contains a valid mathematical expression or not). The next logical step is to
    actually evaluate these expressions (for example, determining that `'(1 + 2) *
    3'` evaluates to `'9'`).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用我们自己构建的PEG解析器来检查输入字符串是否符合给定的语法（也就是说，我们可以*告诉*输入字符串是否包含有效的数学表达式）。下一个逻辑步骤是实际评估这些表达式（例如，确定`'(1
    + 2) * 3'`的值为`'9'`）。
- en: 'As you have already seen, each `match_*` function returns an array with additional
    information on the matched string. Within the parser, you can register custom
    functions that will be called when a given symbol is matched. Let''s start with
    something simple and try to convert numbers that are matched by our grammar to
    actual PHP integer or float values. For this, start by modifying the `Integer`
    and `Decimal` rules in your grammar as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经看到的，每个`match_*`函数都返回一个包含有关匹配字符串的附加信息的数组。在解析器内，您可以注册自定义函数，当匹配给定符号时将调用这些函数。让我们从简单的事情开始，尝试将由我们的语法匹配的数字转换为实际的PHP整数或浮点值。为此，请首先修改您的语法中的`Integer`和`Decimal`规则如下：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s have a look at what''s happening here. In each rule, you can specify
    names for subpatterns within the rule. For example, the pattern `Digit+` in the
    `Integer` rule gets the name called `value` assigned. As soon as the parser finds
    a string matching this pattern, it will call the function with the same name supplied
    below the `Integer` rule. The function will be called with two parameters: the
    `&$result` parameter will be the array returned by the actual `match_Number` function
    later. As you can see, the parameter is passed as reference and you can modify
    it within the value function. The `$sub` parameter contains the result array of
    the subpattern (which, in any case, contains a property `text` from which you
    can access the actual text contents of the matched subpattern).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里发生了什么。在每个规则中，您可以为规则内的子模式指定名称。例如，在`Integer`规则中的模式`Digit+`被分配了名为`value`的名称。一旦解析器找到与此模式匹配的字符串，它将调用在`Integer`规则下方提供的同名函数。该函数将被调用并传入两个参数：`&$result`参数将是稍后由实际的`match_Number`函数返回的数组。正如您所看到的，该参数被作为引用传递，您可以在值函数内对其进行修改。`$sub`参数包含子模式的结果数组（无论如何，它都包含一个`text`属性，您可以从中访问匹配的子模式的实际文本内容）。
- en: In this case, we simply use PHP's built-in functions to convert the number within
    the text to an actual `int` or `float` variable. However, this is only possible
    because our custom grammar and PHP coincidentally represent numbers the same way,
    allowing us to use the PHP interpreter to convert these values to actual numeric
    values.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们简单地使用PHP的内置函数将文本中的数字转换为实际的`int`或`float`变量。然而，这仅仅是因为我们的自定义语法和PHP巧合地以相同的方式表示数字，从而使我们能够使用PHP解释器将这些值转换为实际的数值。
- en: 'If you are using a non-terminal symbol in one of your rules, it is not necessary
    to explicitly specify a subpattern name; you can simply use the symbol name as
    a function name. This can be done in the `Number` rule:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在规则中使用非终结符号，则无需显式指定子模式名称；您可以简单地使用符号名称作为函数名称。这可以在`Number`规则中完成：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Again, the `$sub` parameter contains the result array from matching the subpattern.
    In this case, this means the result array returned by the `match_Decimal` and
    `match_Integer` functions that you've modified yourself previously.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`$sub`参数包含匹配子模式的结果数组。在这种情况下，这意味着您之前修改过的`match_Decimal`和`match_Integer`函数返回的结果数组。
- en: 'This will get a little more complex with the `Product` and `Sum` rules. Start
    by adding labels to the individual parts of your `Product` rule:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`Product`和`Sum`规则中变得更加复杂。首先，通过为`Product`规则的各个部分添加标签来开始：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Continue by adding the respective rule functions to the rule:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 继续通过向规则添加相应的规则函数来进行：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Sum` rule can be modified respectively:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sum`规则可以相应地进行修改：'
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Lastly, you still need to modify the `Value` and `Expr` rules:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您仍然需要修改`Value`和`Expr`规则：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Using these new functions in your parser, it will now be able to evaluated
    parsed expressions on the fly (note that we''re not following the *traditional*
    compiler architecture here, as parsing and execution are not treated as separate
    steps, but rather both be done in the same pass). Re-build your parser class using
    the `cli.php` script and adjust your test script to test some expressions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的解析器中的这些新函数，现在它将能够在解析表达式的同时进行评估（请注意，我们在这里不遵循*传统*编译器架构，因为解析和执行不被视为分开的步骤，而是在同一步骤中完成）。使用`cli.php`脚本重新构建您的解析器类，并调整您的测试脚本以测试一些表达式：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Running your test script will provide the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 运行您的测试脚本将提供以下输出：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Building an Abstract Syntax Tree
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建抽象语法树
- en: 'Currently, our parser interprets the input code and evaluates it in the same
    pass. Most compilers and interpreters; however, create an intermediate data structure
    before actually running the program: an **Abstract Syntax Tree** (**AST**). Using
    an AST offers some interesting possibilities; for example, it provides you with
    a structured representation of your program that you can then analyze. Also, you
    can use the AST and transform it back into a text-based program (maybe of another
    language).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的解析器在同一步骤中解释输入代码并对其进行评估。然而，大多数编译器和解释器在实际运行程序之前会创建一个中间数据结构：**抽象语法树**（**AST**）。使用AST提供了一些有趣的可能性；例如，它为您提供了程序的结构化表示，然后您可以对其进行分析。此外，您可以使用AST并将其转换回基于文本的程序（可能是另一种语言）。
- en: 'An AST is a tree that represents the structure of a program. The first step
    to building an AST-based parser is to design the tree''s object model: which classes
    are needed and in which way are they associated to another. The following figure
    shows the first draft for an object model that can be used to describe mathematical
    expressions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: AST是表示程序结构的树。构建基于AST的解析器的第一步是设计树的对象模型：需要哪些类以及它们如何相互关联。以下图显示了用于描述数学表达式的对象模型的初步草案：
- en: '![Building an Abstract Syntax Tree](graphics/image_08_003.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![构建抽象语法树](graphics/image_08_003.jpg)'
- en: The (preliminary) object model for our Abstract Syntax Tree
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: （初步）抽象语法树的对象模型
- en: 'In this model, nearly all classes implement the `Expression` interface. This
    interface prescribes the `evaluate()` method, which can be provided by the implementations
    of this interface to actually execute the operation modeled by the respective
    tree node. Let''s start by implementing the `Packt\Chp8\DSL\AST\Expression` interface:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中，几乎所有的类都实现了`Expression`接口。这个接口规定了`evaluate()`方法，这个方法可以由接口的实现来执行实际的操作，模拟相应的树节点。让我们从实现`Packt\Chp8\DSL\AST\Expression`接口开始：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next step is the `Number` class with its two subclasses: `Integer` and
    `Decimal`. As we''re going to be using PHP 7''s type hinting feature, and both
    the `Integer` and `Decimal` classes work exclusively with either the `int` or
    `float` variables; we cannot make much use of inheritance, forcing us to leave
    the `Number` class empty:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Number`类及其两个子类：`Integer`和`Decimal`。由于我们将使用PHP 7的类型提示功能，而`Integer`和`Decimal`类只能使用`int`或`float`变量，我们无法充分利用继承，不得不将`Number`类留空：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `Integer` class can be initialized with a PHP integer value. As this class
    models a literal integer value; the only thing that the `evaluate()` method needs
    to do in this class is to return this value again:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Integer`类可以用PHP整数值初始化。由于这个类模拟了一个字面整数值；在这个类中，`evaluate()`方法需要做的唯一一件事情就是再次返回这个值：'
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `Decimal` class can be implemented the same way; in this case, simply use
    `float` instead of `int` as type hints:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Decimal`类可以以相同的方式实现；在这种情况下，只需使用`float`而不是`int`作为类型提示：'
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For the classes `Addition`, `Subtraction`, `Multiplication` and `Division`,
    we''ll be using a common base class, `Packt\Chp8\DSL\AST\BinaryOperation`. This
    class will hold the constructor that you then won''t have to implement over and
    over again:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Addition`、`Subtraction`、`Multiplication`和`Division`类，我们将使用一个共同的基类`Packt\Chp8\DSL\AST\BinaryOperation`。这个类将包含构造函数，这样你就不必一遍又一遍地实现它了：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Implementing the actual classes modeling the operations becomes easy. Let''s
    consider the `Addition` class as an example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 实现实际的操作类变得很容易。让我们以`Addition`类为例：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The remaining classes called `Subtraction`, `Multiplication` and `Division`
    can be implemented in a way similar to the `Addition` class. For the sake of brevity,
    the actual implementation of these classes is left as an exercise for you.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的类`Subtraction`、`Multiplication`和`Division`可以以类似于`Addition`类的方式实现。为了简洁起见，这些类的实际实现留给你作为练习。
- en: What's left now is to actually build the AST in the parser. This is relatively
    easy, as we can now simply modify the already existing hook functions that are
    called by the parser when individual rules are matched.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是在解析器中实际构建AST。这相对容易，因为我们现在可以简单地修改解析器调用的已经存在的挂钩函数，当匹配到单个规则时。
- en: 'Let''s start with the rules for parsing numbers:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从解析数字的规则开始：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When the `Integer` or `Decimal` rule matches, we create a new AST node of the
    `Integer` or `Decimal` class and save it in the return array's node property.
    When the `Number` rule matches, we simply take over the already created node stored
    in the matched symbol.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Integer`或`Decimal`规则匹配时，我们创建一个`Integer`或`Decimal`类的新AST节点，并将其保存在返回数组的`node`属性中。当`Number`规则匹配时，我们只需接管已经创建的节点存储在匹配符号中。
- en: 'We can adjust the `Product` rule in a similar way:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以类似的方式调整`Product`规则：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As our AST model treats operations such as multiplications strictly as binary
    operations, the parser will deconstruct input expressions such as `1 * 2 * 3 *
    4` into a chain of binary multiplications (similar to `1 * (2 * (3 * 4))` as shown
    in the following figure):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的AST模型严格将乘法等操作视为二进制操作，解析器将把输入表达式（如`1 * 2 * 3 * 4`）拆分成一系列二进制乘法（类似于`1 * (2
    * (3 * 4))`，如下图所示）：
- en: '![Building an Abstract Syntax Tree](graphics/image_08_004.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![构建抽象语法树](graphics/image_08_004.jpg)'
- en: The expression 1 * 2 * 3 * 4 as a syntax tree
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式1 * 2 * 3 * 4的语法树
- en: 'Continue by adjusting your `Sum` rule in the same way:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 继续以相同的方式调整你的`Sum`规则：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, all that''s left is to read the created AST node in the `Value` and `Expr`
    rules is follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的就是按照以下方式在`Value`和`Expr`规则中读取创建的AST节点：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In your test script, you can now test if the AST is correctly built by extracting
    the `node` property from the `match_Expr()` function''s return value. You can
    then get the expression''s result by calling the `evaluate()` method on the AST''s
    root node:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试脚本中，你现在可以通过从`match_Expr()`函数的返回值中提取`node`属性来测试AST是否正确构建。然后，你可以通过在AST的根节点上调用`evaluate()`方法来获得表达式的结果：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that the two expressions in this test script should yield two different
    syntax trees (both shown in the following figure) and evaluate to 7 and 9, respectively.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个测试脚本中的两个表达式应该产生两个不同的语法树（都显示在下图中），并分别求值为7和9。
- en: '![Building an Abstract Syntax Tree](graphics/image_08_005.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![构建抽象语法树](graphics/image_08_005.jpg)'
- en: The two syntax trees resulting from parsing the 1+2*' and (1+2)*' expressions
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 解析1+2*'和(1+2)*'表达式得到的两个语法树
- en: Building a better interface
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个更好的接口
- en: Right now, the parser that we have built is not really easy to use. In order
    to use the parser correctly, a user (in this context, read "user" as "another
    developer that uses your parser") has to call the `match_Expr()` method (which
    is just one of many public `match_*` functions offered by the parser that are
    not actually supposed to be called by external users), extract the `node` property
    from the returned array, and then call the evaluate function on the root node
    contained in this property. Also, the parser also matches partial strings (remember
    the example `(1 + 2)) * 3`, which was recognized as partially correct by our parser),
    which might really surprise some users.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们构建的解析器并不是真正易于使用的。为了正确使用解析器，用户（在这个上下文中，将“用户”解释为“使用你的解析器的另一个开发人员”）必须调用`match_Expr()`方法（这只是解析器提供的许多公共`match_*`函数之一，实际上不应该被外部用户调用），从返回的数组中提取`node`属性，然后在这个属性中包含的根节点上调用`evaluate`函数。此外，解析器还匹配部分字符串（记住我们的解析器认为`(1
    + 2)) * 3`这个例子部分正确），这可能会让一些用户感到非常惊讶。
- en: 'This reason is enough to extend our project by a new class that encapsulates
    these quirks and to offer a cleaner interface to our parser. Let''s create a new
    class, `Packt\Chp8\DSL\ExpressionBuilder`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原因足以通过一个新的类来扩展我们的项目，这个类封装了这些怪癖，并为我们的解析器提供了一个更清晰的接口。让我们创建一个新的类，`Packt\Chp8\DSL\ExpressionBuilder`：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In this example, we''re checking if the entire string could be parsed by asserting
    that the matched string returned by the parser is actually equal to the input
    string (and not just a substring). If this is the case (or if the expression could
    not be parsed at all, and the result is just false), an instance of `Packt\Chp8\DSL\Exception\ParsingException`
    is thrown. This exception class is not yet defined; for now, it can simply inherit
    the base exception class and does not need to contain any custom logic:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在检查整个字符串是否可以通过断言来解析，即匹配解析器返回的字符串实际上等于输入字符串（而不仅仅是子字符串）。如果是这种情况（或者如果表达式根本无法解析，结果只是false），则会抛出`Packt\Chp8\DSL\Exception\ParsingException`的实例。这个异常类尚未定义；目前，它可以简单地继承基本异常类，不需要包含任何自定义逻辑：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The new `ExpressionBuilder` class now offers you a more concise way to parse
    and evaluate expressions. For example, you can now use the following construct
    in your `test.php` script:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`ExpressionBuilder`类现在为您提供了一种更简洁的方法来解析和评估表达式。例如，您现在可以在您的`test.php`脚本中使用以下结构：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Evaluating variables
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估变量
- en: So far, our parser can evaluate static expressions, starting with simple ones
    such as `3` (which evaluates, what a surprise, to 3) up to arbitrarily complicated
    ones such as `(5 + 3.14) * (14 + (29 - 2 * 3.918))` (which, by the way, evaluates
    to 286.23496). However, all of these expressions are static; they will always
    evaluate to the same result.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的解析器可以评估静态表达式，从简单的表达式开始，比如`3`（评估结果是3），到任意复杂的表达式，比如`(5 + 3.14) * (14
    + (29 - 2 * 3.918))`（顺便说一句，评估结果是286.23496）。然而，所有这些表达式都是静态的；它们总是评估为相同的结果。
- en: In order to make this more dynamic, we will now extend our grammar to allow
    variables. An example of an expression with variables is `3 + a`, which could
    then be evaluated multiple times with different values for `a`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这更加动态，我们现在将扩展我们的语法以允许变量。一个带有变量的表达式的例子是`3 + a`，然后可以使用不同的值多次评估`a`。
- en: 'This time, let''s start by modifying the object model for the syntax tree.
    First, we''ll need a new node type, `Packt\Chp8\DSL\AST\Variable`, allowing for
    example the `3 + a` expression to generate the following syntax tree:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，让我们从修改语法树的对象模型开始。首先，我们需要一个新的节点类型，`Packt\Chp8\DSL\AST\Variable`，例如允许`3 +
    a`表达式生成以下语法树：
- en: '![Evaluating variables](graphics/image_08_006.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![Evaluating variables](graphics/image_08_006.jpg)'
- en: The syntax tree generated from the expression 3 + a
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从表达式3 + a生成的语法树
- en: 'There''s also a second problem: contrary to the `Number` nodes or arithmetic
    operations that use **Number** nodes, we cannot simply compute the numeric value
    of a **Variable** node (after all, it could have any value - that''s the point
    of a variable). So when evaluating an expression, we''ll also need to pass information
    on which variables exists and what values they have. For this, we''ll simply extend
    the `evaluate()` function defined in the `Packt\Chp8\DSL\AST\Expression` interface
    by an additional parameter:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第二个问题：与使用**Number**节点的`Number`节点或算术运算相反，我们不能简单地计算**Variable**节点的数值（毕竟，它可以有任何值
    - 这就是变量的意义）。因此，在评估表达式时，我们还需要传递关于哪些变量存在以及它们具有什么值的信息。为此，我们将通过额外的参数简单地扩展`Packt\Chp8\DSL\AST\Expression`接口中定义的`evaluate()`函数：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Changing the interface definition necessitates changing all classes that implement
    this interface. In the `Number` subclasses (`Integer` and `Decimal`), you can
    add the new parameter and simply ignore it. The value of a static number does
    not depend on the values of any variables at all. The following code example shows
    this change in the `Packt\Chp8\DSL\AST\Integer` class, but it remembers to change
    the `Decimal` class in the same way as well:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 更改接口定义需要更改所有实现此接口的类。在`Number`子类（`Integer`和`Decimal`）中，您可以添加新参数并简单地忽略它。静态数字的值根本不依赖于任何变量的值。下面的代码示例展示了`Packt\Chp8\DSL\AST\Integer`类中的这种变化，但请记住也要以同样的方式更改`Decimal`类：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the `BinaryOperation` subclasses (`Addition`, `Subtraction`, `Multiplication`,
    and `Division`), the values of defined variables also do not really matter. But
    we need to pass them to the subnodes of these nodes. The following example shows
    this change in the `Packt\Chp8\DSL\AST\Addition` class, but it remembers to also
    change the `Subtraction`, `Multiplication`, and `Division` classes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BinaryOperation`子类（`Addition`，`Subtraction`，`Multiplication`和`Division`）中，定义的变量的值也并不重要。但是我们需要将它们传递给这些节点的子节点。下面的例子展示了`Packt\Chp8\DSL\AST\Addition`类中的这种变化，但请记住也要相应地更改`Subtraction`，`Multiplication`和`Division`类：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we can now declare our `Packt\Chp8\DSL\AST\Variable` class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们现在可以声明我们的`Packt\Chp8\DSL\AST\Variable`类：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Within this class'' `evaluate()` method, you can look up the actual value that
    this variable currently has. If a variable is not defined (read: does not exist
    in the `$variables` argument), we''ll raise an instance of the (not-yet-implemented)
    `Packt\Chp8\DSL\Exception\UndefinedVariableException` to let the user know something''s
    wrong.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类的`evaluate()`方法中，您可以查找这个变量当前的实际值。如果一个变量没有定义（即：在`$variables`参数中不存在），我们将引发一个（尚未实现的）`Packt\Chp8\DSL\Exception\UndefinedVariableException`的实例，以让用户知道出了问题。
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: How you handle undefined variables in your custom language is completely up
    to you. Instead of triggering errors, you could also change the `Variable` class'
    `evaluate()` method to return a default value such as 0 (or anything else) when
    an undefined variable is evaluated. However, using an undefined variable is probably
    unintentional, and simply continuing with a default value would probably be very
    surprising for your users.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何处理自定义语言中未定义的变量完全取决于你。你也可以改变`Variable`类的`evaluate()`方法，在评估未定义的变量时返回一个默认值，比如0（或其他任何值）。然而，使用未定义的变量可能是无意的，简单地继续使用默认值可能会让你的用户感到非常惊讶。
- en: 'The `UndefinedVariableException` class can simply extend the regular `Exception`
    class:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`UndefinedVariableException`类可以简单地扩展常规的`Exception`类：'
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we need to adjust the parser''s grammar to actually recognize variables
    in expressions. For this, our grammar needs two additional symbols:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要调整解析器的语法以实际识别表达式中的变量。为此，我们的语法需要两个额外的符号：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, you''ll need to extend the `Value` rule. Currently, `Value` can be either
    a `Number` symbol, or an `Expr` wrapped in braces. Now, you need to also allow
    variables:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要扩展`Value`规则。目前，`Value`可以是`Number`符号，或者用括号括起来的`Expr`。现在，你还需要允许变量：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Rebuild your parser using PHP-PEG''s `cli.php` script, and add a few calls
    to your `test.php` script to test this new feature:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PHP-PEG的`cli.php`脚本重新构建你的解析器，并在`test.php`脚本中添加一些调用来测试这个新功能：
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These should evaluate to 3, 29, and -1 respectively. You can also try evaluating
    the expression without passing any variables, which should (rightfully so) result
    in an `UndefinedVariableException` being thrown.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应该分别评估为3、29和-1。你也可以尝试在不传递任何变量的情况下评估表达式，这应该（理所当然地）导致抛出`UndefinedVariableException`。
- en: Adding logical expressions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加逻辑表达式
- en: Currently, our language only supports numerical expressions. Another useful
    addition would be to support Boolean expressions that do not evaluate to numeric
    values but to *true* or *false*. Possible examples would include expressions such
    as `3 = 4` (which would always evaluate to *false*), `2 < 4` (which would always
    evaluate to *true*), or `a <= 5` (which depends on the value of variable `a`).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的语言只支持数值表达式。另一个有用的补充是支持布尔表达式，这些表达式不会评估为数值，而是*true*或*false*。可能的例子包括诸如`3
    = 4`（这将始终评估为*false*）、`2 < 4`（这将始终评估为*true*）或`a <= 5`（这取决于变量`a`的值）的表达式。
- en: Comparisons
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较
- en: 'As before, let''s start by extending the object model of our syntax tree. We''ll
    start with an **Equals** node that represents an equality check between two expressions.
    Using this node, the `1 + 2 = 4 - 1` expression would produce the following syntax
    tree (and should of course eventually evaluate to *true*):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，让我们从扩展语法树的对象模型开始。我们将从一个表示两个表达式之间相等检查的**Equals**节点开始。使用这个节点，`1 + 2 = 4
    - 1`表达式将产生以下语法树（当然最终应该评估为*true*）：
- en: '![Comparisons](graphics/image_08_007.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![比较](graphics/image_08_007.jpg)'
- en: The syntax tree that should result from parsing the 1 + 2 = 4 - 1 expression
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 应该从解析1 + 2 = 4 - 1表达式得到的语法树
- en: 'For this, we will implement the `Packt\Chp8\DSL\AST\Equals` class. This class
    can inherit the `BinaryOperation` class that we implemented earlier:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将实现`Packt\Chp8\DSL\AST\Equals`类。这个类可以继承我们之前实现的`BinaryOperation`类：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'While we''re at it, we can also implement the `NotEquals` node at the same
    time:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们也可以同时实现`NotEquals`节点：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the next step, we''ll need to adjust our parser''s grammar. First, we need
    to change the grammar to differentiate between numerical and Boolean expressions.
    For this, we''ll rename the `Expr` symbol to `NumExpr` in the entire grammar.
    This affects the `Value` symbol:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要调整我们解析器的语法。首先，我们需要改变语法以区分数值和布尔表达式。为此，我们将在整个语法中将`Expr`符号重命名为`NumExpr`。这会影响`Value`符号：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Of course, you''ll also need to change the `Expr` rule itself:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你还需要改变`Expr`规则本身：
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we can define a rule for equality (and also non-equality):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以定义一个相等（以及不相等）的规则：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that this rule got a bit more complicated in this case, as it supports
    multiple operators. However, these rules are now relatively easy to be extended
    by more operators (when we're checking non-equality things such as "greater than"
    or "smaller than" might be the next logical steps). The `ComparisonOperator` symbol,
    which is defined first, matches all kinds of comparison operators and the `Comparison`
    rule that uses this symbol to match the actual expressions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，这个规则变得有点复杂，因为它支持多个运算符。然而，这些规则现在相对容易通过更多的运算符进行扩展（当我们检查非相等的事物时，如"大于"或"小于"可能是下一个逻辑步骤）。首先定义的`ComparisonOperator`符号匹配所有类型的比较运算符，而使用这个符号来匹配实际表达式的`Comparison`规则。
- en: 'Lastly, we can add a new `BoolExpr` symbol, and also define the `Expr` symbol
    again:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加一个新的`BoolExpr`符号，并重新定义`Expr`符号：
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When calling the `match_Expr()` function, our parser will now match both numeric
    and Boolean expressions. Rebuild your parser using PHP-PEG''s `cli.php` script,
    and add a few new calls to your `test.php` script:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`match_Expr()`函数时，我们的解析器现在将匹配数值和布尔表达式。使用PHP-PEG的`cli.php`脚本重新构建你的解析器，并在`test.php`脚本中添加一些新的调用：
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: These expressions should evaluate to *false*, *true*, and *false* respectively.
    The numeric expressions that you've added before should continue to work as before.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表达式应该分别评估为*false*、*true*和*false*。你之前添加的数值表达式应该继续像以前一样工作。
- en: Similar to this, you could now add additional comparison operators, such as
    `>`, `>=`, `<`, or `<=` to your grammar. Since the implementation of these operators
    would be largely identical to the `=` and `|=` operations, we'll leave it as an
    exercise for you.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于这样，你现在可以向你的语法中添加额外的比较运算符，比如`>`、`>=`、`<`或`<=`。由于这些运算符的实现基本上与`=`和`|=`操作相同，我们将把它作为一个练习留给你。
- en: The "and" and "or" operators
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '"and"和"or"运算符'
- en: Another important feature in order to fully support logical expressions is the
    ability to combine logical expressions via the "and" and "or" operators. As we
    are developing our language with an end user in mind, we'll build our language
    to actually support `and` and `or` as logical operators (in contrast to the ubiquitous
    `&&` and `||` that you find in many general-purpose programming language that
    are derived from the C syntax).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全支持逻辑表达式，另一个重要特性是能够通过“and”和“or”运算符组合逻辑表达式。由于我们正在为最终用户开发我们的语言，我们将构建我们的语言以实际支持`and`和`or`作为逻辑运算符（与许多通用编程语言中的`&&`和`||`相反，这些语言都是从C语法派生而来）。
- en: 'Again, let''s start by implementing the respective node types for the syntax
    tree. We will need node types modeling both the `and` and `or` operation so that
    a statement such as `a = 1` or `b = 2` will be parsed into the following syntax
    tree:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们从实现语法树的相应节点类型开始。我们需要建模“and”和“or”操作的节点类型，这样一个语句，比如`a = 1`或`b = 2`，将被解析成以下语法树：
- en: '![The "and" and "or" operators](graphics/image_08_008.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![The "and" and "or" operators](graphics/image_08_008.jpg)'
- en: The syntax tree resulting from parsing a=1 or b=2
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 解析a=1 or b=2得到的语法树
- en: 'Begin by implementing the `Packt\Chp8\DSL\AST\LogicalAnd` class (we cannot
    use *And* as a class name, because that''s a reserved word in PHP):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先实现`Packt\Chp8\DSL\AST\LogicalAnd`类（我们不能使用*And*作为类名，因为在PHP中这是一个保留字）：
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: For the `or` operator, you can also implement the `Packt\Chp8\DSL\AST\LogicalOr`
    class the same way.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`or`运算符，你也可以用同样的方式实现`Packt\Chp8\DSL\AST\LogicalOr`类。
- en: When working with the `and` and `or` operators, you will need to think about
    operator precedence. While operator precedence is well defined for arithmetic
    operations, this is not the case for logical operators. For example, the statement
    `a and b or c and d` could be interpreted as `(((a and b) or c) and d)` (same
    precedence, left to right), or just as well as `(a and b) or (c and d)` (precedence
    on `and`) or `(a and (b or c)) and d` (precedence on `or`). However, most programming
    languages treat the `and` operator with the highest precedence, so barring any
    other convention it makes sense to stick with this tradition.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`and`和`or`运算符时，你需要考虑运算符优先级。虽然算术运算的运算符优先级已经定义得很好，但逻辑运算符却不是这样。例如，语句`a and b
    or c and d`可以被解释为`(((a and b) or c) and d)`（相同的优先级，从左到右），或者同样可以被解释为`(a and b)
    or (c and d)`（`and`的优先级），或者`(a and (b or c)) and d`（`or`的优先级）。然而，大多数编程语言将`and`运算符视为最高优先级，因此除非有其他约定，否则坚持这一传统是有道理的。
- en: 'The following figure shows the syntax trees that result from applying this
    precedence on the `a=1 and b=2 or b=3` and `a=1 and (b=2 or b=3)` statements:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了将这种优先级应用于`a=1 and b=2 or b=3`和`a=1 and (b=2 or b=3)`语句得到的语法树：
- en: '![The "and" and "or" operators](graphics/image_08_009.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![The "and" and "or" operators](graphics/image_08_009.jpg)'
- en: The syntax trees resulting form parsing a=1 and b=2 or b=3 and a=1 and (b=2
    or b=3)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 解析a=1 and b=2 or b=3 and a=1 and (b=2 or b=3)得到的语法树
- en: We will need a few new rules in our grammar for this. First of all, we need
    a new symbol representing a Boolean value. For now, such a Boolean value may either
    be a comparison or any Boolean expression wrapped in brackets.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的语法需要一些新的规则。首先，我们需要一个表示布尔值的新符号。目前，这样的布尔值可以是一个比较，也可以是用括号括起来的任何布尔表达式。
- en: '[PRE56]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Do you remember how we implemented operator precedence previously using the
    `Product` and `Sum` rules? We can implement the `And` and `Or` rules the same
    way:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们之前如何使用“Product”和“Sum”规则实现了运算符优先级吗？我们可以用同样的方式实现“And”和“Or”规则：
- en: '[PRE57]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'After this, we can extend the `BoolExpr` rule to also match `Or` expressions
    (and since a single `And` symbol also matches the `Or` rule, a single `And` symbol
    will also be a `BoolExpr`):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以扩展`BoolExpr`规则，使其也匹配`Or`表达式（由于单个`And`符号也匹配`Or`规则，单个`And`符号也将是`BoolExpr`）：
- en: '[PRE58]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can now add a few new test cases to your `test.php` script. Play around
    with variables and pay special attention to how operator precedence is resolved:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在你的`test.php`脚本中添加一些新的测试用例。尝试使用变量，并特别注意运算符优先级是如何解析的：
- en: '[PRE59]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Conditions
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件
- en: 'Now that our language supports (arbitrarily complex) logical expressions, we
    can use these to implement another important feature: conditional statements.
    Our language currently supports only expressions that evaluate to a single numeric
    or the Boolean value; we''ll now implement a variant of the ternary operator,
    which is also known in PHP:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的语言支持（任意复杂的）逻辑表达式，我们可以使用这些来实现另一个重要的特性：条件语句。我们的语言目前只支持评估为单个数字或布尔值的表达式；我们现在将实现三元运算符的变体，这在PHP中也是众所周知的：
- en: '[PRE60]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As our language is targeted at end users, we''ll use a more readable syntax,
    which will allow statements such as `when <condition> then <value> else <value>`.
    In our syntax tree, constructs such as these will be represented by the `Packt\Chp8\DSL\AST\Condition`
    class:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的语言面向最终用户，我们将使用更易读的语法，这将允许诸如`when <condition> then <value> else <value>`的语句。在我们的语法树中，这些构造将由`Packt\Chp8\DSL\AST\Condition`类表示：
- en: '[PRE61]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This means that, for example, the `when a > 2 then a * 1.5 else a * 2` expression
    should be parsed into the following syntax tree:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，例如`when a > 2 then a * 1.5 else a * 2`表达式应该被解析成以下语法树：
- en: '![Conditions](graphics/image_08_010.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![Conditions](graphics/image_08_010.jpg)'
- en: 'In theory, our language should also support complex expressions in the condition
    or the then/else part, allowing statements such as `when (a > 2 or b = 2) then
    (2 * a + 3 * b) else (3 * a - b)` or even nested statements such as `when a=2
    then (when b=2 then 1 else 2) else 3`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们的语言还应该支持条件或then/else部分中的复杂表达式，允许诸如`when (a > 2 or b = 2) then (2 * a +
    3 * b) else (3 * a - b)`或甚至嵌套语句，比如`when a=2 then (when b=2 then 1 else 2) else
    3`：
- en: '![Conditions](graphics/image_08_011.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![Conditions](graphics/image_08_011.jpg)'
- en: 'Continue by adding a new symbol and rule to your parser''s grammar:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 继续通过向解析器的语法中添加新的符号和规则：
- en: '[PRE62]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Also, adjust the `BoolExpr` rule to also match conditions. In this case, the
    order is important: if you''re putting the `Or` or `Comparison` symbol first in
    the `BoolExpr` rule, the rule might interpret when as a variable name, instead
    of a conditional expression.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 还要调整`BoolExpr`规则以匹配条件。在这种情况下，顺序很重要：如果您首先将`Or`或`Comparison`符号放在`BoolExpr`规则中，规则可能会将`when`解释为变量名，而不是条件表达式。
- en: '[PRE63]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Again, rebuild your parser using PHP-PEG''s **cli.php** script, and add a few
    test statements to your test script to test the new grammar rules:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用PHP-PEG的**cli.php**脚本重新构建您的解析器，并在测试脚本中添加一些测试语句以测试新的语法规则：
- en: '[PRE64]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: These test cases should evaluate to 3.14, 4, and 6 respectively.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试案例应该分别评估为3.14、4和6。
- en: Working with structured data
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用结构化数据
- en: So far, our custom expression language has only supported very simple variables-numbers
    and Boolean values. However, in real applications, this is often not so simple.
    When using an expression language to offer programmable business rules, you will
    often be working with structured data. For example, consider an e-commerce system
    in which a back-office user has the possibility to define under which conditions
    a discount should be offered to a user and what amount of a purchase should be
    discounted (the following figure shows a hypothetical example of how such a feature
    might actually look in an application).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的自定义表达式语言只支持非常简单的变量-数字和布尔值。然而，在实际应用中，情况通常并不那么简单。当使用表达式语言提供可编程的业务规则时，您通常会使用结构化数据。例如，考虑一个电子商务系统，其中后台用户有可能定义在哪些条件下向用户提供折扣以及折扣的购买金额（以下图显示了这样一个功能在应用程序中实际上可能看起来的假设示例）。
- en: Typically, you do not know beforehand how a user is going to use this feature.
    Using only numerical variables, you'd have to pass a whole set of variables when
    evaluating the expression, on the off chance that the user might be using one
    or two of them. Alternatively, you could pass an entire domain object (for example,
    a PHP object representing a shopping cart and maybe another one representing the
    customer), as variable into the expression and give the user the option to access
    properties or call methods of these objects.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您事先不知道用户将如何使用此功能。仅使用数字变量，您将不得不在评估表达式时传递整套变量，以防用户可能使用其中一两个。或者，您可以将整个域对象（例如，表示购物车的PHP对象，也许还有另一个表示客户的对象）作为变量传递到表达式中，并给用户访问这些对象的属性或调用方法的选项。
- en: 'A feature such as this would allow a user to use expressions such as `cart.value`
    in an expression. When evaluating this expression, this could be translated to
    either a direct property access (if the `$cart` variable does have a publicly
    accessible `$value` property), or a call to a `getValue()` method:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的功能将允许用户在表达式中使用`cart.value`等表达式。在评估此表达式时，这可以被转换为直接属性访问（如果`$cart`变量确实具有公开访问的`$value`属性），或者调用`getValue()`方法：
- en: '![Working with structured data](graphics/image_08_012.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![使用结构化数据](graphics/image_08_012.jpg)'
- en: An example of how structured data could be used as variables in an enterprise
    e-commerce application
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化数据如何在企业电子商务应用程序中用作变量的示例
- en: 'For this, we''ll need to modify our AST object model a bit. We''ll introduce
    a new node type, `Packt\Chp8\DSL\AST\PropertyFetch`, which models a named property
    being fetched from a variable. However, we need to consider that these property
    fetches need to be chained, for example, in expressions such as `cart.customer.contact.firstname`.
    This expression should be parsed into the following syntax tree:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要稍微修改我们的AST对象模型。我们将引入一个新的节点类型，`Packt\Chp8\DSL\AST\PropertyFetch`，它模拟了从变量中获取的命名属性。但是，我们需要考虑这些属性获取需要被链接，例如，在表达式中，如`cart.customer.contact.firstname`。这个表达式应该被解析成以下语法树：
- en: '![Working with structured data](graphics/image_08_013.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![使用结构化数据](graphics/image_08_013.jpg)'
- en: For this, we'll redefine the `Variable` node type that we added before. Rename
    the `Variable` class to `NamedVariable` and add a new interface named `Variable`.
    This interface can then be implemented by both the `NamedVariable` class and the
    `PropertyFetch` class. The `PropertyFetch` class can then accept a `Variable`
    instance as its left operator.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将重新定义之前添加的`Variable`节点类型。将`Variable`类重命名为`NamedVariable`，并添加一个名为`Variable`的新接口。然后，这个接口可以被`NamedVariable`类和`PropertyFetch`类同时实现。`PropertyFetch`类可以接受`Variable`实例作为其左操作数。
- en: 'Start by renaming the `Packt\Chp8\DSL\AST\Variable` class to `Packt\Chp8\DSL\AST\NamedVariable`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将`Packt\Chp8\DSL\AST\Variable`类重命名为`Packt\Chp8\DSL\AST\NamedVariable`：
- en: '[PRE65]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, add the new interface called `Packt\Chp8\DSL\AST\Variable`. It does not
    need to contain any code; we''ll use it just for type hinting:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加名为`Packt\Chp8\DSL\AST\Variable`的新接口。它不需要包含任何代码；我们将仅用于类型提示：
- en: '[PRE66]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Continue by adding the `Packt\Chp8\DSL\AST\PropertyFetch` new class:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 继续添加`Packt\Chp8\DSL\AST\PropertyFetch`新类：
- en: '[PRE67]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Lastly, modify the `Variable` rule in your parser''s grammar:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在解析器的语法中修改`Variable`规则：
- en: '[PRE68]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Using this rule, the `Variable` symbol can consist of multiple property names
    chained together with the `.` character. The rule functions will then build a
    `NamedVariable` node for the first property name, and then work this node into
    a chain of the `PropertyFetch` nodes for subsequent properties.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此规则，`Variable`符号可以由多个用`.`字符链接在一起的属性名称组成。然后，规则函数将为第一个属性名称构建一个`NamedVariable`节点，然后将此节点作为`PropertyFetch`节点的链的一部分处理后续属性。
- en: 'As usual, rebuild your parser and add a few lines to your test script:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，重新构建您的解析器，并在测试脚本中添加几行：
- en: '[PRE69]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Working with objects
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对象
- en: Getting end users to grasp the concept of data structures is no easy task. While
    the concept of *objects* having *properties* (for instance, a customer having
    a first name and a last name) is usually easy to convey, you probably would not
    bother end users with things like data encapsulation and object methods.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让最终用户理解数据结构的概念并不容易。虽然*对象*具有*属性*的概念（例如，客户具有名字和姓氏）通常很容易传达，但您可能不会让最终用户关注数据封装和对象方法之类的事情。
- en: Because of this, it might be useful to hide the intricacies of data access from
    your end user; if a user want to access a customer's first name, they should be
    able to write `customer.firstname`, even if the actual property of the underlying
    object is protected, and you would usually need to call a `getFirstname()` method
    to read this property. Since getter functions typically follow certain naming
    patterns, our parser can automatically translate expressions such as `customer.firstname`
    to method calls such as `$customer->getFirstname()`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，隐藏数据访问的复杂性可能是有用的；如果用户想要访问客户的名字，他们应该能够编写`customer.firstname`，即使底层对象的实际属性是受保护的，并且通常需要调用`getFirstname()`方法来读取此属性。由于获取器函数通常遵循某些命名模式，我们的解析器可以自动将诸如`customer.firstname`之类的表达式转换为诸如`$customer->getFirstname()`之类的方法调用。
- en: 'To implement this feature, we need to extend the `evaluate` method of `PropertyFetch`
    by a few special cases:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此功能，我们需要通过一些特殊情况来扩展`PropertyFetch`的`evaluate`方法：
- en: '[PRE70]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Using this implementation, an expression such as `customer.firstname` will first
    check if the customer object implements a `getFirstname()`method that can be called.
    Should this not be the case, the interpreter will check for an `isFirstname()`
    method (which does not make sense in this case, but could be useful as getter
    functions, for Boolean properties are often named `isSomething` instead of `getSomething`).
    If no `isFirstname()` method exists either, the interpreter will look for an accessible
    property named `firstname`, and then as a last resort simply return null.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此实现，例如`customer.firstname`这样的表达式将首先检查客户对象是否实现了可以调用的`getFirstname()`方法。如果不是这种情况，解释器将检查是否存在`isFirstname()`方法（在这种情况下没有意义，但作为获取器函数可能很有用，因为布尔属性通常被命名为`isSomething`而不是`getSomething`）。如果也不存在`isFirstname()`方法，解释器将查找名为`firstname`的可访问属性，然后作为最后的手段简单地返回null。
- en: Optimizing the interpreter by adding a compiler
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过添加编译器来优化解释器
- en: Our parser now works as it should, and you could use it in any kind of application
    to offer very flexible customization options to the end user. However, the parser
    does not work very efficiently. In general, parsing expressions are computationally
    expensive, and in most use cases, it is reasonable to assume that the actual expressions
    that you're working with do not change with every request (or at least, are evaluated
    more often than they are changed).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解析器现在可以正常工作，并且您可以在任何类型的应用程序中使用它，为最终用户提供非常灵活的定制选项。但是，解析器的效率并不高。一般来说，解析表达式是计算密集型的，在大多数情况下，可以合理地假设您正在处理的实际表达式不会在每个请求中更改（或者至少比它们更改的频率更高）。
- en: Because of this, we can optimize the parser's performance by adding a caching
    layer to our interpreter. Of course, we cannot cache the actual evaluation results
    of an expression; after all, these could change when they are interpreted with
    different variables.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过向我们的解释器添加缓存层来优化解析器的性能。当然，我们无法缓存表达式的实际评估结果；毕竟，当使用不同的变量解释它们时，这些结果可能会发生变化。
- en: What we're going to do in this section is add a compiler feature to our parser.
    For each parsed expression, our parser generates an AST that represents the structure
    of this expression. You can now use this syntax tree to translate the expression
    into any other programming language, for example, to PHP.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们要做的是向我们的解析器添加一个编译器功能。对于每个解析的表达式，我们的解析器生成一个代表该表达式结构的AST。您现在可以使用此语法树将表达式转换为任何其他编程语言，例如PHP。
- en: 'Consider the `2 + 3 * a` expression. This expression generates the following
    syntax tree:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`2 + 3 * a`表达式。此表达式生成以下语法树：
- en: '![Optimizing the interpreter by adding a compiler](graphics/image_08_014.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![通过添加编译器来优化解释器](graphics/image_08_014.jpg)'
- en: In our AST model, this corresponds to an instance of the `Packt\Chp8\DSL\AST\Addition`
    class, holding a reference to an instance of the `Packt\Chp8\DSL\AST\Number` class
    and the `Packt\Chp8\DSL\AST\Product` class (and so forth).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的AST模型中，这对应于`Packt\Chp8\DSL\AST\Addition`类的一个实例，其中包含对`Packt\Chp8\DSL\AST\Number`类和`Packt\Chp8\DSL\AST\Product`类（等等）的引用。
- en: 'We cannot implement a compiler feature to translate this expressions back into
    PHP code (after all, PHP does support simple arithmetic operations, too), which
    might look like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法实现编译器功能将这些表达式转换回PHP代码（毕竟，PHP也支持简单的算术运算），可能看起来像这样：
- en: '[PRE71]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The PHP code that is generated in this way could then be saved in files for
    later lookup. If the parser gets passed an expression that is already cached,
    it could simply load the saved PHP files in order to not actually parse the expression
    again.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式生成的PHP代码可以保存在文件中以供以后查找。如果解析器传递了一个已经缓存的表达式，它可以简单地加载保存的PHP文件，以便不实际解析表达式。
- en: 'To implement this feature, we''ll need to have the possibility to convert each
    node in a syntax tree into a corresponding PHP expression. For this, let''s start
    by extending our `Packt\Chp8\DSL\AST\Expression` interface by a new method:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此功能，我们需要有可能将语法树中的每个节点转换为相应的PHP表达式。为此，让我们通过一个新方法扩展我们的`Packt\Chp8\DSL\AST\Expression`接口：
- en: '[PRE72]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The downside of this approach is that you''ll now need to implement this method
    for each and every single one of the classes that implement this interface. Let''s
    start with something simple: the `Packt\Chp8\DSL\AST\Number` class. As each `Number`
    implementation will always evaluate to the same number (3 will always evaluate
    to 3 and never to 4), we can simply return the numeric value:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，您现在需要为实现此接口的每个类实现此方法。让我们从简单的东西开始：`Packt\Chp8\DSL\AST\Number`类。由于每个`Number`实现始终会评估为相同的数字（3始终会评估为3而不会评估为4），我们可以简单地返回数字值：
- en: '[PRE73]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'As for the remaining node types, we''ll need methods that return an implementation
    of each expression type in PHP. For example, for the `Packt\Chp8\DSL\AST\Addition`
    class, we could add the following `compile()` method:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 至于剩余的节点类型，我们将需要返回每种表达式类型在PHP中的实现的方法。例如，对于`Packt\Chp8\DSL\AST\Addition`类，我们可以添加以下`compile()`方法：
- en: '[PRE74]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Proceed similarly for the remaining arithmetic operations: `Subtraction`, `Multiplication`,
    and `Division`, and also the logical operations such as `Equals`, `NotEquals`,
    `And`, and `Or`.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于剩余的算术运算，如`Subtraction`、`Multiplication`和`Division`，以及`Equals`、`NotEquals`、`And`和`Or`等逻辑运算，也要采取类似的方法。
- en: 'For the `Condition` class, you can use PHP''s ternary operator:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Condition`类，您可以使用PHP的三元运算符：
- en: '[PRE75]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `NamedVariable` class is difficult to adjust; the class'' `evaluate()`
    method currently throws `UnknownVariableException` when a non-existing variable
    is referenced. However, our `compile()` method needs to return a single PHP expression.
    And looking up a value and also throwing an exception cannot be done in a single
    expression. Luckily, you can instantiate classes and call methods on them:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`NamedVariable`类很难调整；类的`evaluate()`方法当前在引用不存在的变量时会抛出`UnknownVariableException`。但是，我们的`compile()`方法需要返回一个单一的PHP表达式。查找值并抛出异常不能在单个表达式中完成。幸运的是，您可以实例化类并在其上调用方法：'
- en: '[PRE76]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Using this workaround, the `a * 3` expression would be compiled to the following
    PHP code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种解决方法，`a * 3`表达式将被编译为以下PHP代码：
- en: '[PRE77]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This just leaves the `PropertyFetch` class. You might remember that this class
    was a bit more complex than the other node types, as it implemented quite a few
    different contingencies on how to look up properties from objects. In theory,
    this logic could be implemented in a single expression using ternary operators.
    This would result in the `foo.bar` expression being compiled to the following
    monstrosity:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这只留下了`PropertyFetch`类。您可能还记得，这个类比其他节点类型更复杂，因为它实现了如何从对象中查找属性的许多不同情况。理论上，这个逻辑可以使用三元运算符在单个表达式中实现。这将导致`foo.bar`表达式被编译为以下怪物：
- en: '[PRE78]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In order to prevent the compiled code from getting overly complicated, it''s
    easier to refactor the `PropertyFetch` class a little bit. You can extract the
    actual property lookup method in a static method that can be called from both
    the `evaluate()` method and the `compiled` code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止编译后的代码变得过于复杂，最好稍微重构`PropertyFetch`类。您可以将实际的属性查找方法提取到一个静态方法中，该方法可以从`evaluate()`方法和`compiled`代码中调用：
- en: '[PRE79]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This way, the `foo.bar` expression will simply evaluate to this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`foo.bar`表达式将简单地评估为：
- en: '[PRE80]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In the next step, we can add an alternative to the previously introduced `ExpressionBuilder`
    class that transparently compiles expressions, saves them in a cache, and reuses
    the compiled versions when necessary.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们可以为先前介绍的`ExpressionBuilder`类添加一个替代方案，该方案可以透明地编译表达式，将它们保存在缓存中，并在必要时重用已编译的版本。
- en: 'We''ll call this class `Packt\Chp8\DSL\CompilingExpressionBuilder`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称这个类为`Packt\Chp8\DSL\CompilingExpressionBuilder`：
- en: '[PRE81]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: As we don't want to re-implement the `ExpressionBuilder's` parsing logic, this
    class takes an instance of `ExpressionBuilder` as a dependency. When a new expression
    is parsed that is not yet present in the cache, this inner expression builder
    will be used to actually parse this expression.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望重新实现`ExpressionBuilder`的解析逻辑，因此该类将`ExpressionBuilder`的实例作为依赖项。当解析尚未存在于缓存中的新表达式时，将使用内部表达式构建器来实际解析此表达式。
- en: 'Let''s continue by adding a `parseExpression` method to this class:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续向这个类添加一个`parseExpression`方法：
- en: '[PRE82]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Let''s have a look at what happens in this method: first, the actual input
    string is used to calculate a hash value, uniquely identifying this expression.
    If a file with this name exists in the cache directory, it will be included as
    a PHP file, and the file''s return value will return as the method''s return value:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个方法中发生了什么：首先，实际的输入字符串用于计算哈希值，唯一标识此表达式。如果缓存目录中存在具有此名称的文件，则将其包含为PHP文件，并将文件的返回值作为方法的返回值返回：
- en: '[PRE83]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: As the method's type hint specified that the method needs to return an instance
    of the `Packt\Chp8\DSL\AST\Expression` interface, the generated cache files also
    need to return an instance of this interface.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 由于方法的类型提示指定方法需要返回`Packt\Chp8\DSL\AST\Expression`接口的实例，生成的缓存文件也需要返回此接口的实例。
- en: If no compiled version of the expression could be found, the expression is parsed
    as usual by the inner expression builder. This expression is then compiled to
    a PHP expression using the `compile()` method. This PHP code snippet is then used
    to write the actual cache file. In this file, we're creating a new anonymous class
    that implements the expression interface, and in its `evaluate()` method contains
    the compiled expression.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到表达式的编译版本，则该表达式将像内部表达式构建器一样通常解析。然后使用`compile()`方法将此表达式编译为PHP表达式。然后使用此PHP代码片段来编写实际的缓存文件。在此文件中，我们创建一个实现表达式接口的新匿名类，并且在其`evaluate()`方法中包含编译后的表达式。
- en: Tip
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Anonymous classes are a feature added in PHP 7\. This feature allows you to
    create objects that implement an interface or extend an existing class without
    needing to explicitly define a named class for this. Syntactically, this feature
    can be used as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类是PHP 7中添加的一个功能。此功能允许您创建实现接口或扩展现有类的对象，而无需明确定义此类的命名类。在语法上，此功能可以如下使用：
- en: '`$a = new class implements SomeInterface {` `    public function test() {`
    `        echo ''Hello'';` `    }` `};` `$a->test();`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`$a = new class implements SomeInterface {` `    public function test() {`
    `        echo ''Hello'';` `    }` `};` `$a->test();`'
- en: 'This means that the `foo.bar * 3` expression would create a cache file with
    the following PHP code as its contents:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`foo.bar * 3`表达式将创建一个缓存文件，其中包含以下PHP代码：
- en: '[PRE84]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Interestingly, the PHP interpreter itself works much the same way. Before actually
    executing PHP code, the PHP interpreter compiles the code into an intermediate
    representation or Bytecode, which is then interpreted by the actual interpreter.
    In order to not parse the PHP source code over and over again, the compiled bytecode
    is cached; this is how PHP's opcode cache works.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，PHP解释器本身的工作方式与此类似。在实际执行PHP代码之前，PHP解释器将代码编译为中间表示或字节码，然后由实际解释器解释。为了不一遍又一遍地解析PHP源代码，编译后的字节码被缓存；这就是PHP的操作码缓存的工作原理。
- en: 'As we''re saving our compiled expressions as PHP code, these will also be compiled
    into PHP bytecode and cached in the opcode cache for even more performance again.
    For example, the previous cached expression''s evaluate method evaluates to the
    following PHP bytecode:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将编译的表达式保存为PHP代码，这些表达式也将被编译为PHP字节码，并缓存在操作码缓存中，以再次提高性能。例如，先前缓存的表达式的evaluate方法评估为以下PHP字节码：
- en: '![Optimizing the interpreter by adding a compiler](graphics/image_08_015.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![通过添加编译器来优化解释器](graphics/image_08_015.jpg)'
- en: The PHP bytecode generated by the PHP interpreter
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: PHP解释器生成的PHP字节码
- en: Verifying performance improvements
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证性能改进
- en: The motivation for implementing the compilation to PHP was to increase the parser's
    performance. As a last step, we'll now try to verify that the caching layer does
    actually increase the performance of the parser.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 实现将编译到PHP的动机是为了提高解析器的性能。作为最后一步，我们现在将尝试验证缓存层是否确实提高了解析器的性能。
- en: 'For this, you can use the **PHPBench** package that you can install using composer:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您可以使用**PHPBench**包，您可以使用composer安装：
- en: '[PRE85]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: PHPBench offers a framework for benchmarking single units of code in isolation
    (in that respect being similar to PHPUnit, only for benchmarks instead of tests).
    Each benchmark is a PHP class that contains scenarios as methods. The name of
    each scenario method needs to start with `bench`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: PHPBench提供了一个框架，用于在隔离中对单个代码单元进行基准测试（在这方面类似于PHPUnit，只是用于基准测试而不是测试）。每个基准测试都是一个包含场景的PHP类作为方法。每个场景方法的名称需要以`bench`开头。
- en: 'Start by creating a `bench.php` file in your root directory with the following
    contents:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在根目录中创建一个`bench.php`文件，内容如下：
- en: '[PRE86]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You can then run this benchmark using the following command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用以下命令运行此基准测试：
- en: '[PRE87]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This should generate a report such as the following one:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下报告：
- en: '![Verifying performance improvements](graphics/image_08_016.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![验证性能改进](graphics/image_08_016.jpg)'
- en: 'Currently, PHPBench runs the benchmark function exactly once and measures the
    time that it took to execute this function. In this case, it is about 2 milliseconds.
    This is not very precise, because micro-measurements such as these can vary quite
    a lot, depending on other things happening on your computer at the same time.
    For this reason, it''s usually better to execute the benchmark function multiple
    times (let''s say, a few hundred or thousand times) and then compute the average
    execution time. Using PHPBench, you can do this easily by adding a `@Revs(5000)`
    annotation to your benchmark class'' DOC comment:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，PHPBench仅运行基准函数一次，并测量执行此函数所需的时间。在这种情况下，大约为2毫秒。这并不是非常精确，因为这样的微量测量可能会有很大的变化，取决于同时发生在计算机上的其他事情。因此，通常最好多次执行基准函数（比如说，几百次或几千次），然后计算平均执行时间。使用PHPBench，您可以通过在基准类的DOC注释中添加`@Revs(5000)`注释来轻松实现这一点：
- en: '[PRE88]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This annotation will cause PHPBench to actually run this benchmark function
    5000 times and then compute the average runtime.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 此注释将导致PHPBench实际运行此基准函数5000次，然后计算平均运行时间。
- en: 'Let''s also add a second scenario in which we''re using the new `CompilingExpressionBuilder`
    with the same expression:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还添加第二个场景，其中我们使用相同的表达式使用新的`CompilingExpressionBuilder`：
- en: '[PRE89]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Run the benchmark again; this time benchmarking both parsers and with 5000
    iterations:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行基准测试；这次对两个解析器进行基准测试，并进行5000次迭代：
- en: '![Verifying performance improvements](graphics/image_08_017.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![验证性能改进](graphics/image_08_017.jpg)'
- en: As you can see here, parsing and evaluating the `a = 2` expression takes our
    regular parser about 349 microseconds, on average (and about 20 megabytes of RAM).
    Using the compiling parser takes only about 33 microseconds (that's a runtime
    reduction of about 90%) and only 5 MB's of RAM (or about 71%).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，解析和评估`a=2`表达式需要我们的常规解析器平均约349微秒（大约20兆字节的RAM）。使用编译解析器只需要约33微秒（运行时间减少约90%），只需要5兆字节的RAM（或约71%）。
- en: Now, `a=2` might not really be the most representative benchmark, because actual
    expressions used in a real-life use case might get a little more complex.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，“a=2”可能并不是最具代表性的基准，因为在实际使用情况中使用的实际表达式可能会变得更加复杂。
- en: 'For a more realistic benchmark, let''s add two more scenarios, this time with
    a more complex expression:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行更真实的基准测试，让我们添加另外两种情景，这次使用更复杂的表达式：
- en: '[PRE90]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Run the benchmark again and have a new look at the results:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行基准测试，并查看结果：
- en: '![Verifying performance improvements](graphics/image_08_018.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![验证性能改进](graphics/image_08_018.jpg)'
- en: That's even better than before! Using the regular parser for parsing the `when
    (customer.age = 1 and cart.value = 200) then cart.value * 0.1 else cart.value
    * 0.2` expression takes about 2.5 milliseconds (remember we were talking about
    *microseconds* in the last benchmark), while only 50 microseconds are using the
    optimized parser! That's an improvement of about 98%.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至比以前更好！使用常规解析器解析`when (customer.age = 1 and cart.value = 200) then cart.value
    * 0.1 else cart.value * 0.2`表达式大约需要2.5毫秒（请记住我们上次基准测试中谈到的*微秒*），而使用优化解析器只需要50微秒！这是约98%的改进。
- en: Summary
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use the PHP-PEG library to implement a parser,
    interpreter, and compiler for a custom expression language. You also learned how
    to define grammars for such languages and how you can use them to develop domain-specific
    languages. These can be used to offer end-user development features in large software
    systems, which allow users to customize their software's business rules to a large
    extent.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用PHP-PEG库实现自定义表达式语言的解析器、解释器和编译器。您还学习了如何为这样的语言定义语法，以及如何使用它们来开发特定领域的语言。这些可以用于在大型软件系统中提供最终用户开发功能，允许用户在很大程度上自定义其软件的业务规则。
- en: Dynamically modifying a program using domain-specific languages can be a strong
    selling point, especially in enterprise systems. They allow users to modify a
    program's behavior by themselves, without having to wait for a developer to change
    a business rule and trigger a lengthy release process. This way, new business
    rules can be implemented quickly and allow your customers to react quickly to
    changing requirements.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定领域语言动态修改程序可以成为一个强有力的卖点，特别是在企业系统中。它们允许用户自行修改程序的行为，而无需等待开发人员更改业务规则并触发漫长的发布流程。这样，新的业务规则可以快速实施，使您的客户能够迅速应对不断变化的需求。
