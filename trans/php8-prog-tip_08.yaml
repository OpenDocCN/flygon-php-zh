- en: '*Chapter 6*: Understanding PHP 8 Functional Differences'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*：了解 PHP 8 的功能差异'
- en: In this chapter, you will learn about potential backward-compatible breaks at
    the PHP 8 command, or functional, level. This chapter presents important information
    that highlights potential pitfalls when migrating existing code to PHP 8\. The
    information presented in this chapter is critical to know so that you can produce
    reliable PHP code. After working through the concepts in this chapter, you'll
    be in a better position to write code that produces precise results and avoids
    inconsistencies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解 PHP 8 命令或功能级别可能出现的向后兼容性破坏。本章提供了重要信息，突出了将现有代码迁移到 PHP 8 时可能出现的潜在问题。本章中提供的信息对于您了解如何编写可靠的
    PHP 代码至关重要。通过学习本章中的概念，您将更好地编写能够产生精确结果并避免不一致性的代码。
- en: 'Topics covered in this chapter include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: Learning key advanced string handling differences
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习关键的高级字符串处理差异
- en: Understanding PHP 8 string-to-numeric comparison improvements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 PHP 8 中字符串到数字比较的改进
- en: Handling differences in arithmetic, bitwise, and concatenation operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理算术、位和连接操作的差异
- en: Taking advantage of locale independence
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用地区独立性
- en: Handling arrays in PHP 8
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 PHP 8 中的数组
- en: Mastering changes in security functions and settings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握安全功能和设置的变化
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To examine and run the code examples provided in this chapter, the minimum
    recommended hardware is the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查和运行本章提供的代码示例，最低推荐的硬件配置如下：
- en: An x86_64-based desktop PC or laptop
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 x86_64 的台式机或笔记本电脑
- en: 1 gigabyte (GB) of free disk space
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 千兆字节（GB）的可用磁盘空间
- en: 4 GB of RAM
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 GB 的 RAM
- en: A 500 kilobits per second (Kbps) or faster internet connection
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每秒 500 千位（Kbps）或更快的互联网连接
- en: 'In addition, you will need to install the following software:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还需要安装以下软件：
- en: Docker
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Docker Compose
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Please refer to the *Technical requirements* section in [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013),
    *Introducing New PHP 8 OOP Features,* for more information on Docker and Docker
    Compose installation, as well as how to build the Docker container used to demonstrate
    the code explained in this book. In this book, we refer to the directory in which
    you restored the sample code for this book as `/repo`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Docker 和 Docker Compose 的安装以及如何构建用于演示本书中所解释的代码的 Docker 容器的更多信息，请参阅[*第 1 章*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013)
    中的 *技术要求* 部分。在本书中，我们将您为本书恢复的示例代码所在的目录称为 `/repo`。
- en: 'The source code for this chapter is located here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于此处：
- en: https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices。
- en: We can now begin our discussion by examining the differences in string handling
    introduced in PHP 8.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始讨论，通过检查 PHP 8 中引入的字符串处理差异来了解。
- en: Learning key advanced string handling differences
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习关键的高级字符串处理差异
- en: String functions in general have been tightened and normalized in PHP 8\. You
    will find that usage is more heavily restricted in PHP 8, which ultimately forces
    you to produce better code. We can say that the nature and order of string function
    arguments is much more uniform in PHP 8, which is why we say that the PHP core
    team has normalized usage.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，PHP 8 中的字符串函数已经在安全性和规范性上得到加强。您会发现在 PHP 8 中使用更受限制，这最终迫使您编写更好的代码。我们可以说，在
    PHP 8 中，字符串函数参数的性质和顺序更加统一，这就是为什么我们说 PHP 核心团队已经规范了使用。
- en: These improvements are especially evident when dealing with numeric strings.
    Other changes in PHP 8 string handling involve minor changes to arguments. In
    this section, we introduce you to the key changes in how PHP 8 handles strings.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些改进在处理数字字符串时尤为明显。PHP 8 字符串处理的其他变化涉及参数的轻微更改。在本节中，我们向您介绍 PHP 8 处理字符串的关键变化。
- en: It's important to understand not only the handling improvements introduced in
    PHP 8 but also to understand the deficiencies in string handling prior to PHP
    8.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要了解 PHP 8 中引入的处理改进，也要了解 PHP 8 之前字符串处理的不足之处。
- en: Let's first have a look at an aspect of PHP 8 string handling in functions that
    search for embedded strings.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下 PHP 8 中字符串处理的一个方面，即搜索嵌入字符串的函数。
- en: Handling changes to the needle argument
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理针参数的更改
- en: 'A number of PHP string functions search for the presence of a substring within
    a larger string. These functions include `strpos()`, `strrpos()`, `stripos()`,
    `strripos()`, `strstr()`, `strchr()`, `strrchr()`, and `stristr()`. All of these
    functions have these two parameters in common: the **needle** and the **haystack**.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 PHP 字符串函数搜索较大字符串中子字符串的存在。这些函数包括 `strpos()`、`strrpos()`、`stripos()`、`strripos()`、`strstr()`、`strchr()`、`strrchr()`
    和 `stristr()`。所有这些函数都有两个共同的参数：**needle** 和 **haystack**。
- en: Differentiating between the needle and the haystack
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区分针和草堆
- en: 'To illustrate the difference between the needle and the haystack, have a look
    at the function signature for `strpos()`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明针和草堆之间的差异，看一下 `strpos()` 的函数签名：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`$haystack` is the target of the search. `$needle` is the substring to be sought.
    The `strpos()` function returns the position of the substring within the search
    target. If the substring is not found, the Boolean `FALSE` is returned. The other
    `str*()` functions produce different types of output that we will not detail here.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`$haystack` 是搜索的目标。`$needle` 是要查找的子字符串。`strpos()` 函数返回搜索目标中子字符串的位置。如果未找到子字符串，则返回布尔值
    `FALSE`。其他 `str*()` 函数产生不同类型的输出，我们在这里不详细介绍。'
- en: Two key changes in how PHP 8 handles the needle argument have the potential
    to break an application migrated to PHP 8\. These changes apply to situations
    where the needle argument is not a string or where the needle argument is empty.
    Let's have a look at non-string needle argument handling first.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8处理needle参数的两个关键变化可能会破坏迁移到PHP 8的应用程序。这些变化适用于needle参数不是字符串或needle参数为空的情况。让我们先看看如何处理非字符串needle参数。
- en: Dealing with non-string needle arguments
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理非字符串needle参数
- en: Your PHP application might not be taking the proper precautions to ensure that
    the needle argument to the `str*()` functions mentioned here is always a string.
    If that is the case, in PHP 8, the needle argument will now *always be interpreted*
    as a string rather than an ASCII code point.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您的PHP应用程序可能没有采取适当的预防措施，以确保这里提到的`str*()`函数的needle参数始终是一个字符串。如果是这种情况，在PHP 8中，needle参数现在将*始终被解释*为字符串而不是ASCII码点。
- en: If you need to supply an ASCII value, you must use the `chr()` function to convert
    it to a string. In the following example, the ASCII value for `LF` (`"\n"`) is
    used instead of a string. In PHP 7 or below, `strpos()` performs an internal conversion
    before running the search. In PHP 8, the number is simply typecast into a string,
    yielding unexpected results.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要提供ASCII值，必须使用`chr()`函数将其转换为字符串。在以下示例中，使用`LF`（`"\n"`）的ASCII值代替字符串。在PHP 7或更低版本中，`strpos()`在运行搜索之前执行内部转换。在PHP
    8中，该数字只是简单地转换为字符串，产生意想不到的结果。
- en: 'Here is a code example that searches for the presence of `LF` within a string.
    However, note that instead of providing a string as an argument, an integer with
    a value of `10` is provided:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是搜索字符串中`LF`存在的代码示例。但请注意，提供的参数不是字符串，而是一个值为`10`的整数：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here are the results of the code sample running in PHP 7:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PHP 7中运行代码示例的结果：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And here are the results of the same code block running in PHP 8:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PHP 8中运行相同代码块的结果：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, comparing the output in PHP 7 with the output in PHP 8, the
    same code block yields radically different results. This is an extremely difficult
    potential code break to spot as no `Warnings` or `Errors` are generated.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，比较PHP 7中的输出与PHP 8中的输出，相同的代码块产生了截然不同的结果。这是一个极其难以发现的潜在代码破坏，因为没有生成`Warnings`或`Errors`。
- en: 'The best practice is to apply a `string` type hint to the needle argument of
    any function or method that incorporates one of the PHP `str*()` functions. If
    we rewrite the previous example, the output is consistent in both PHP 7 and PHP
    8\. Here is the same example rewritten using a type hint:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是对任何包含PHP `str*()`函数之一的函数或方法的needle参数应用`string`类型提示。如果我们重写前面的例子，输出在PHP 7和PHP
    8中是一致的。以下是使用类型提示重写的相同示例：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, in either version of PHP, this is the output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在任何版本的PHP中，这是输出：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By declaring `strict_types=1`, and by adding a type hint of `string` before
    the `$needle` argument, any developer who misuses your code receives a clear indication
    that this practice is not acceptable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过声明`strict_types=1`，并在`$needle`参数之前添加`string`类型提示，任何错误使用你的代码的开发人员都会清楚地知道这种做法是不可接受的。
- en: Let's now have a look at what happens in PHP 8 when the needle argument is missing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看当needle参数丢失时，PHP 8会发生什么。
- en: Handling empty needle arguments
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理空needle参数
- en: Another major change in the `str*()` function is that the needle argument can
    now be empty (for example, anything that would make the `empty()` function return
    `TRUE`). This presents *significant* potential for backward compatibility breaks.
    In PHP 7, if the needle argument is empty, the return value from `strpos()` would
    be the Boolean `FALSE`, whereas, in PHP 8, the empty value is first converted
    to a string, thereby producing entirely different results.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`str*()`函数的另一个重大变化是，needle参数现在可以为空（例如，任何使`empty()`函数返回`TRUE`的内容）。这对向后兼容性破坏具有*重大*潜力。在PHP
    7中，如果needle参数为空，`strpos()`的返回值将是布尔值`FALSE`，而在PHP 8中，空值首先被转换为字符串，从而产生完全不同的结果。'
- en: It's extremely important to be aware of this potential code break if you plan
    to update your PHP version to 8\. An empty needle argument is difficult to spot
    when reviewing code manually. This is a situation where a solid set of unit tests
    is needed to ensure a smooth PHP migration.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划将PHP版本更新到8，那么意识到这种潜在的代码破坏是非常重要的。在手动审查代码时，很难发现空的needle参数。这是需要一组可靠的单元测试来确保平稳的PHP迁移的情况。
- en: 'To illustrate the potential problem, consider the following example. Assume
    that the needle argument is empty. In this situation, a traditional `if()` check
    to see whether the `strpos()` result is not identical to `FALSE` produces different
    results between PHP 7 and 8\. Here is the code example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明潜在的问题，请考虑以下示例。假设needle参数为空。在这种情况下，传统的`if()`检查`strpos()`结果是否与`FALSE`不相同，在PHP
    7和8之间产生不同的结果。以下是代码示例：
- en: 'First, we define a function that reports whether or not the needle value is
    found in the haystack using `strpos()`. Note the strict type check against the
    Boolean `FALSE`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个函数，使用`strpos()`报告针值是否在haystack中找到。注意对布尔值`FALSE`进行严格类型检查：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We then define the haystack as a string with letters and numbers. The needle
    argument is provided in the form of an array of values that are all considered
    empty:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将haystack定义为一个包含字母和数字的字符串。needle参数以所有被视为空的值的数组形式提供：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output in PHP 7 appears as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中的输出如下：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After a set of `Warnings`, the final output appears. As you can see from the
    output, the return value from `strpos($haystack, $search)` is consistently the
    Boolean `FALSE` in PHP 7.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列`Warnings`之后，最终的输出出现了。从输出中可以看出，在PHP 7中，`strpos($haystack, $search)`的返回值始终是布尔值`FALSE`。
- en: 'The output running the same code in PHP 8, however, is radically different.
    Here is the output from PHP 8:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PHP 8中运行相同的代码的输出却截然不同。以下是PHP 8的输出：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In PHP 8, the empty needle argument is first silently converted to a string.
    None of the needle values return the Boolean `FALSE`. This causes the function
    to report that the needle has been found. This is certainly not the desired result.
    In the case of the number `0`, however, it is contained in the haystack, resulting
    in a value of `19` being returned.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，空的needle参数首先被悄悄地转换为字符串。没有一个needle值返回布尔值`FALSE`。这导致函数报告找到了needle。这显然不是期望的结果。然而，对于数字`0`，它包含在haystack中，导致返回值为`19`。
- en: Let's have a look at how this problem might be addressed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何解决这个问题。
- en: Solving the problem using str_contains()
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用str_contains()解决问题
- en: 'The intent of the code block shown in the previous section is to determine
    whether or not the haystack contains the needle. `strpos()` is not the right tool
    to accomplish this task! Have a look at the same function using `str_contains()`
    instead:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中显示的代码块的目的是确定haystack是否包含needle。`strpos()`不是完成此任务的正确工具！看看使用`str_contains()`的相同函数：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we then run the modified code in PHP 8, we get results similar to those
    received from PHP 7:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在PHP 8中运行修改后的代码，我们会得到与从PHP 7收到的结果类似的结果：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You might ask why is it that the number `0` is not found in the string? The
    answer is that `str_contains()` does a stricter search. Integer `0` is not the
    same as the string `"0"`! Let's now have a look at the `v*printf()` family; another
    family of string functions that exerts stricter control over its arguments in
    PHP 8.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问为什么数字`0`在字符串中找不到？答案是`str_contains()`进行了更严格的搜索。整数`0`与字符串`"0"`不同！现在让我们看看`v*printf()`系列函数；PHP
    8中对其参数施加更严格的控制的另一个字符串函数系列。
- en: Dealing with v*printf() changes
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理v*printf()的变化
- en: 'The `v*printf()` family of functions is a subset of the `printf()` family of
    functions that include `vprintf()`, `vfprintf()`, and `vsprintf()`. The difference
    between this subset and the main family is that the `v*printf()` functions are
    designed to accept an array as an argument rather than an unlimited series of
    arguments. Here is a simple example that illustrates the difference:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`v*printf()`系列函数是`printf()`系列函数的一个子集，包括`vprintf()`、`vfprintf()`和`vsprintf()`。这个子集与主要系列之间的区别在于，`v*printf()`函数被设计为接受一个数组作为参数，而不是无限系列的参数。以下是一个简单的示例，说明了这种区别：'
- en: 'First, we define a set of arguments that will be inserted into a pattern, `$patt`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一组参数，这些参数将被插入到一个模式`$patt`中：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We then execute a `printf()` statement using a series of arguments:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用一系列参数执行一个`printf()`语句：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We then define the arguments as an array, `$arr`, and use `vprintf()` to produce
    the same result:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将参数定义为一个数组`$arr`，并使用`vprintf()`来产生相同的结果：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the output of the program running in PHP 8\. The output is the same
    running in PHP 7 (not shown):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PHP 8中运行程序的输出。在PHP 7中运行的输出相同（未显示）：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, the output of both functions is identical. The only usage difference
    is that `vprintf()` accepts the parameters in the form of an array.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，两个函数的输出是相同的。唯一的使用区别是`vprintf()`以数组形式接受参数。
- en: Prior versions of PHP allowed a developer to play *fast and loose* with arguments
    presented to the `v*printf()` family of functions. In PHP 8, the data type of
    the arguments is now strictly enforced. This only presents a problem where code
    controls do not exist to ensure that an array is presented. Another even more
    important difference is that PHP 7 will allow `ArrayObject` with `v*printf()`,
    whereas PHP 8 will not.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的早期版本允许开发人员在`v*printf()`系列函数中玩得*快速和松散*。在PHP 8中，参数的数据类型现在受到严格执行。这只在代码控制不存在以确保提供数组的情况下才会出现问题。另一个更重要的区别是，PHP
    7允许`ArrayObject`与`v*printf()`一起使用，而PHP 8则不允许。
- en: 'In the example shown here, PHP 7 issues a `Warning`, whereas PHP 8 throws an
    `Error`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里显示的示例中，PHP 7会发出一个“警告”，而PHP 8会抛出一个“错误”：
- en: 'First, we define the pattern and the source array:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义模式和源数组：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We then define a test data array in order to test which arguments are accepted
    by `vsprintf()`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个测试数据数组，以测试`vsprintf()`接受哪些参数：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then define a `foreach()` loop that goes through the test data and exercises
    `vsprintf()`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个`foreach()`循环，遍历测试数据并使用`vsprintf()`：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the output running in PHP 7:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PHP 7中运行的输出：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see from the output, both the array and `ArrayObject` arguments
    are accepted in PHP 7\. Here is the same code example running in PHP 8:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，在PHP 7中，数组和`ArrayObject`参数都被接受。以下是在PHP 8中运行相同代码示例的结果：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As expected, the PHP 8 output is much more consistent. In PHP 8, the `v*printf()`
    functions are strictly typed to accept only an array as an argument. Unfortunately,
    there's a real possibility you may have been using `ArrayObject`. This is easily
    addressed by simply using the `getArrayCopy()` method on the `ArrayObject` instance,
    which returns an array.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，PHP 8的输出更加一致。在PHP 8中，`v*printf()`函数被严格类型化，只接受数组作为参数。不幸的是，您可能一直在使用`ArrayObject`。这可以通过简单地在`ArrayObject`实例上使用`getArrayCopy()`方法来解决，该方法返回一个数组。
- en: 'Here is the rewritten code that works in both PHP 7 and PHP 8:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PHP 7和PHP 8中都有效的重写代码：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that you have an idea where to look for a potential code break when using
    the `v*printf()` functions, let's turn our attention to differences in how string
    functions with a null length argument work in PHP 8.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道在使用`v*printf()`函数时可能出现代码中断的地方，让我们将注意力转向PHP 8中空长度参数的字符串函数的工作方式的差异。
- en: Working with null length arguments in PHP 8
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在PHP 8中处理空长度参数
- en: 'In PHP 7 and earlier, a `NULL` length argument resulted in an empty string.
    In PHP 8, a `NULL` length argument is now treated the same as if the length argument
    is omitted. Functions affected include the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7及更早版本中，`NULL`长度参数导致空字符串。在PHP 8中，`NULL`长度参数现在被视为与省略长度参数相同。受影响的函数包括以下内容：
- en: '`substr()`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`substr()`'
- en: '`substr_count()`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`substr_count()`'
- en: '`substr_compare()`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`substr_compare()`'
- en: '`iconv_substr()`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iconv_substr()`'
- en: 'In the example shown next, PHP 7 returns an empty string whereas PHP 8 returns
    the remainder of the string. This has a high potential for a code break if the
    result of the operation is used to confirm or deny the existence of the substring:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，PHP 7 返回空字符串，而 PHP 8 返回字符串的其余部分。如果操作的结果用于确认或否定子字符串的存在，则可能会导致代码中断：
- en: 'First, we define a haystack and needle. We then run `strpos()` to get the position
    of the needle in the haystack:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个 haystack 和 needle。然后，我们运行 `strpos()` 来获取 needle 在 haystack 中的位置：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we pull out the substring, deliberately leaving the length argument undefined:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们提取子字符串，故意不定义长度参数：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is the output running in PHP 7:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7 中的输出如下：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As expected, PHP 7 issues a `Notice`. However, as an empty string is returned
    due to the `NULL` length argument, the search result is incorrect. Here is the
    same code running in PHP 8:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，PHP 7 发出“注意”。然而，由于 `NULL` 长度参数返回空字符串，搜索结果是不正确的。以下是在 PHP 8 中运行相同代码的输出：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: PHP 8 issues a `Warning` and returns the remainder of the string. This is consistent
    with the behavior where the length argument is entirely omitted. If your code
    relies upon an empty string being returned, a potential code break exists after
    a PHP 8 update.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8 发出“警告”并返回字符串的其余部分。这与完全省略长度参数的行为一致。如果您的代码依赖于返回空字符串，则在 PHP 8 更新后可能存在潜在的代码中断。
- en: Let's now have a look at another situation where PHP 8 has made string handling
    more uniform in the `implode()` function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看另一种情况，在这种情况下，PHP 8 使 `implode()` 函数中的字符串处理更加统一。
- en: Examining changes to implode()
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 implode() 的更改
- en: 'Two widely used PHP functions perform array to string conversion and the reverse:
    `explode()` converts a string to an array, and `implode()` converts an array to
    a string. However, there lurks a deep dark secret with the `implode()` function:
    its two parameters can be expressed in any order!'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 两个广泛使用的 PHP 函数执行数组到字符串的转换和反向转换：`explode()` 将字符串转换为数组，而 `implode()` 将数组转换为字符串。然而，`implode()`
    函数隐藏着一个深不可测的秘密：它的两个参数可以以任何顺序表达！
- en: Please bear in mind that when PHP was first introduced in 1994, the initial
    goal was to make it as easy to use as possible. This approach succeeded, to the
    point where PHP is the language of choice on over 78% of all web servers today
    according to a recent survey of server-side programming languages conducted by
    w3techs. (https://w3techs.com/technologies/overview/programming_language)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当 PHP 在 1994 年首次推出时，最初的目标是尽可能地易于使用。这种方法取得了成功，以至于根据 w3techs 最近进行的服务器端编程语言调查，PHP
    是今天所有 Web 服务器中的首选语言，占比超过 78%。（https://w3techs.com/technologies/overview/programming_language）
- en: 'However, in the interests of consistency, it makes sense to align the parameters
    of the `implode()` function with its mirror twin, `explode()`. Accordingly, arguments
    supplied to `implode()` must now be in this order:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了保持一致性，将 `implode()` 函数的参数与其镜像函数 `explode()` 对齐是有意义的。因此，现在必须按照这个顺序提供给 `implode()`
    的参数：
- en: '`implode(<GLUE STRING>, <ARRAY>);`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`implode(<GLUE STRING>, <ARRAY>);`'
- en: 'Here is the code example that calls the `implode()` function with arguments
    in either order:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是调用 `implode()` 函数的代码示例，参数可以以任何顺序传递：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see from the PHP 7 output below, both echo statements produce results:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，从 PHP 7 的输出中可以看到，两个 echo 语句都产生了结果：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In PHP 8, only the first statement succeeds, as shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 8 中，只有第一条语句成功，如下所示：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It will be extremely difficult to spot where `implode()` is receiving parameters
    in the wrong order. The best way to be forewarned prior to a PHP 8 migration would
    be to make a note of all classes of PHP files that use `implode()`. Another suggestion
    would be to take advantage of the PHP 8 *named arguments* feature (covered in
    [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013), *Introducing New
    PHP 8 OOP Features*).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 很难发现 `implode()` 接收参数的顺序错误的地方。在进行 PHP 8 迁移之前，最好的方法是记录所有使用 `implode()` 的 PHP
    文件类别。另一个建议是利用 PHP 8 的*命名参数*功能（在[*第 1 章*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013)中介绍了*PHP
    8 新的面向对象特性*）。
- en: Learning about constants usage in PHP 8
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习 PHP 8 中常量的使用
- en: One of the truly outrageous capabilities of PHP prior to version 8 was the ability
    to define *case-insensitive* constants. In the beginning, when PHP was first introduced,
    many developers were writing lots of PHP code with a notable absence of any sort
    of coding standard. The objective at the time was just to *make it work*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 8 之前的一个真正令人震惊的功能是能够定义*不区分大小写*的常量。在 PHP 刚推出时，许多开发人员写了大量 PHP 代码，但明显缺乏任何编码标准。当时的目标只是*让它工作*。
- en: In line with the general trend toward enforcing good coding standards, this
    ability was deprecated in PHP 7.3 and removed in PHP 8\. A backward-compatible
    break might appear if you are using `define()` with the third parameter set to
    `TRUE`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与强制执行良好的编码标准的一般趋势一致，这种能力在 PHP 7.3 中已被弃用，并在 PHP 8 中移除。如果您将 `define()` 的第三个参数设置为
    `TRUE`，则可能会出现向后兼容的中断。
- en: 'The example shown here works in PHP 7, but not entirely in PHP 8:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的示例在 PHP 7 中有效，但在 PHP 8 中并非完全有效：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In PHP 7, all lines of code work as written. Here is the output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 7 中，所有代码行都按原样工作。输出如下：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Please note that the third argument of `define()` was deprecated in PHP 7.3\.
    Accordingly, if you run this code example in PHP 7.3 or 7.4, the output is identical
    with the addition of a `Deprecation` notice.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，PHP 7.3 中的 `define()` 的第三个参数已被弃用。因此，如果您在 PHP 7.3 或 7.4 中运行此代码示例，则输出与添加“弃用”通知相同。
- en: 'In PHP 8, however, quite a different result is produced, as shown here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 PHP 8 中，产生了完全不同的结果，如下所示：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you might expect, lines 7, 8, and 9 produce the expected result. The last
    line, however, throws a fatal `Error`, because constants in PHP 8 are now case-sensitive.
    Also, a `Warning` is issued for the third `define()` statement as the third parameter
    is ignored in PHP 8.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能期望的那样，第 7、8 和 9 行产生了预期的结果。然而，最后一行会抛出致命的“错误”，因为 PHP 8 中的常量现在区分大小写。此外，第三个
    `define()` 语句会发出“警告”，因为在 PHP 8 中忽略了第三个参数。
- en: You now have an idea about key string handling differences introduced in PHP
    8\. We next turn our attention to changes in how numeric strings are compared
    with numbers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在对PHP 8中引入的关键字符串处理差异有了了解。接下来，我们将关注数字字符串与数字的比较方式的变化。
- en: Understanding PHP 8 string-to-numeric comparison improvements
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解PHP 8中字符串转换为数值的改进
- en: Comparing two numeric values has never been an issue in PHP. A comparison between
    two strings is also not an issue. A problem arises in non-strict comparisons between
    strings and numeric data (hardcoded numbers, or variables containing data of the
    `float` or `int` type). In such cases, PHP will *always* convert the string to
    a numeric value if a non-strict comparison is executed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中比较两个数值从来都不是问题。比较两个字符串也不是问题。问题出现在字符串和数值数据（硬编码数字，或包含`float`或`int`类型数据的变量）之间的非严格比较中。在这种情况下，如果执行非严格比较，PHP将*始终*将字符串转换为数值。
- en: The *only* time a string-to-numeric conversion is 100% successful is when the
    string only contains numbers (or numeric values such as plus, minus, or the decimal
    separator). In this section, you learn how to protect against inaccurate non-strict
    comparisons involving strings and numeric data. Mastering the concepts presented
    in this chapter is critical if you wish to produce code with consistent and predictable
    behavior.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串转换为数值的*唯一*成功情况是当字符串只包含数字（或数字值，如加号、减号或小数点）时。在本节中，您将学习如何防止涉及字符串和数值数据的不准确的非严格比较。如果您希望编写具有一致和可预测行为的代码，掌握本章介绍的概念至关重要。
- en: Before we get into the details of string-to-numeric comparisons, we need to
    first gain an understanding of what is meant by a non-strict comparison.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解字符串转换为数值的比较细节之前，我们首先需要了解什么是非严格比较。
- en: Learning about strict and non-strict comparisons
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习严格和非严格比较
- en: The concept of **type juggling** is an essential part of the PHP language. This
    capability was built into the language literally from its first day. Type juggling
    involves performing an internal data type conversion before performing an operation.
    This ability is critical to the success of the language.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型转换**的概念是PHP语言的一个重要部分。这种能力从语言诞生的第一天起就内置在语言中。类型转换涉及在执行操作之前执行内部数据类型转换。这种能力对语言的成功至关重要。'
- en: PHP was originally devised to perform in a web environment and needed a way
    to handle data transmitted as part of an HTTP packet. HTTP headers and bodies
    are transmitted as text and are received by PHP as strings stored in a set of
    **super-globals**, including `$_SERVER`, `$_GET`, `$_POST,` and so forth. Accordingly,
    the PHP language needs a quick way to deal with string values when performing
    operations that involve numbers. This is the job of the type-juggling process.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: PHP最初是为在Web环境中执行而设计的，并且需要一种处理作为HTTP数据包的一部分传输的数据的方式。HTTP头部和正文以文本形式传输，并由PHP作为存储在一组**超全局变量**中的字符串接收，包括`$_SERVER`、`$_GET`、`$_POST`等。因此，PHP语言在执行涉及数字的操作时需要一种快速处理字符串值的方式。这就是类型转换过程的工作。
- en: 'A **strict comparison** is one that first checks the data type. If the data
    types match, the comparison proceeds. Operators that invoke a strict comparison
    include `===` and `!==`, among others. Certain functions have an option to enforce
    a strict data type. One example is `in_array()`. If the third argument is set
    to `TRUE`, a strict-type search ensues. Here is the method signature for `in_array()`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**严格比较**首先检查数据类型。如果数据类型匹配，则进行比较。触发严格比较的运算符包括`===`和`!==`等。某些函数有选项来强制使用严格数据类型。`in_array()`就是一个例子。如果第三个参数设置为`TRUE`，则进行严格类型搜索。以下是`in_array()`的方法签名：'
- en: '`in_array(mixed $needle, array $haystack, bool $strict = false)`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`in_array(mixed $needle, array $haystack, bool $strict = false)`'
- en: A **non-strict comparison** is where no data type check is made prior to comparison.
    Operators that perform non-strict comparisons include `==`, `!=`, `<`, and `>`,
    among others. It's worth noting that the `switch {}` language construct performs
    non-strict comparisons in its `case` statements. Type juggling is performed if
    a non-strict comparison is made that involves operands of different data types.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**非严格比较**是指在比较之前不进行数据类型检查。执行非严格比较的运算符包括`==`、`!=`、`<`和`>`等。值得注意的是，`switch {}`语言结构在其`case`语句中执行非严格比较。如果进行涉及不同数据类型的操作数的非严格比较，将执行类型转换。'
- en: Let's now have a detailed look at numeric strings.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们详细看一下数字字符串。
- en: Examining numeric strings
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查数字字符串
- en: A **numeric string** is a string that contains only numbers or numeric characters,
    such as the plus sign (`+`), minus sign (`-`), and decimal separator.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字字符串**是只包含数字或数字字符的字符串，例如加号（`+`）、减号（`-`）和小数点。'
- en: Important note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It should be noted that PHP 8 internally uses the period character (`.`) as
    the decimal separator. If you need to render numbers in locales that do not use
    the period as a decimal separator (for example, in France, the comma (`,`) is
    used as the decimal separator), use the `number_format()` function (see https://www.php.net/number_format).
    Please have a look at the *Taking advantage of locale independence* section in
    this chapter for more information.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，PHP 8内部使用句点字符（`.`）作为小数点分隔符。如果您需要在不使用句点作为小数点分隔符的区域呈现数字（例如，在法国，逗号（`,`）被用作小数点分隔符），请使用`number_format()`函数（请参阅https://www.php.net/number_format）。有关更多信息，请查看本章中关于*利用区域独立性*部分。
- en: Numeric strings can also be composed using **engineering notation** (also called
    **scientific notation**). A **non-well-formed** numeric string is a numeric string
    containing values other than digits, the plus sign, minus sign, or decimal separator.
    A **leading-numeric** string starts with a numeric string but is followed by non-numeric
    characters. Any string that is neither *numeric* nor *leading-numeric* is considered
    **non-numeric** by the PHP engine.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 数字字符串也可以使用**工程表示法**（也称为**科学表示法**）来组成。**非格式良好**的数字字符串是包含除数字、加号、减号或小数分隔符之外的值的数字字符串。**前导数字**字符串以数字字符串开头，但后面跟着非数字字符。PHP引擎认为任何既不是*数字*也不是*前导数字*的字符串都被视为**非数字**。
- en: 'In previous versions of PHP, type juggling inconsistently parsed strings containing
    numbers. In PHP 8, only numeric strings can be cleanly converted to a number:
    no leading or trailing whitespace or other non-numeric characters can be present.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的PHP版本中，类型转换不一致地解析包含数字的字符串。在PHP 8中，只有数字字符串可以被干净地转换为数字：不能存在前导或尾随空格或其他非数字字符。
- en: 'As an example, have a look at the difference in how PHP 7 and 8 handle numeric
    strings in this code sample:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看一下PHP 7和8在此代码示例中处理数字字符串的差异：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is the output running in PHP 7:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PHP 7中运行的输出：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see from the output, PHP 7 considers a string with a trailing space
    to be non-well-formed. However, a string with a *leading* space is considered
    well-formed and passes through without generating a `Notice`. A string with non-whitespace
    characters is still processed but merits a `Notice`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，PHP 7认为带有尾随空格的字符串是非格式良好的。然而，带有*前导*空格的字符串被认为是格式良好的，并且可以通过而不生成`Notice`。包含非空白字符的字符串仍然会被处理，但会产生一个`Notice`。
- en: 'Here is the same code example running in PHP 8:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PHP 8中运行的相同代码示例：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: PHP 8 is much more consistent in that numeric strings that contain either leading
    or trailing spaces are treated equally, and no `Notices` or `Warnings` are generated.
    However, the last string, formerly a `Notice` in PHP 7, now generates a `Warning`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8在这一点上更加一致，包含前导或尾随空格的数字字符串被平等对待，并且不会生成`Notices`或`Warnings`。然而，最后一个字符串，在PHP
    7中曾经是一个`Notice`，现在会生成一个`Warning`。
- en: Tip
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can read about numeric strings in the PHP documentation here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在PHP文档中阅读有关数字字符串的内容：
- en: https://www.php.net/manual/en/language.types.numeric-strings.php
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: https://www.php.net/manual/en/language.types.numeric-strings.php
- en: 'For more information on type juggling, have a look at the following URL:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有关类型转换的更多信息，请查看以下网址：
- en: https://www.php.net/manual/en/language.types.type-juggling.php
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: https://www.php.net/manual/en/language.types.type-juggling.php
- en: Now that you have an idea of what is considered a well-formed and non-well-formed
    numeric string, let's turn our attention to the more serious issue of potential
    backward-compatible breaks when dealing with numeric strings in PHP 8.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道什么是格式良好和非格式良好的数字字符串，让我们把注意力转向在PHP 8中处理数字字符串时可能出现的更严重的向后兼容中断问题。
- en: Detecting backward-compatible breaks involving numeric strings
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测涉及数字字符串的向后兼容中断
- en: You must understand where there is potential for your code to break following
    a PHP 8 upgrade. In this subsection, we show you a number of extremely subtle
    differences that can have large consequences.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须了解在PHP 8升级后，您的代码可能会出现潜在的中断。在本小节中，我们向您展示了一些极其微妙的差异，这些差异可能会产生重大后果。
- en: 'Potential code breaks could surface any time a non-well-formed numeric string
    is used:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候都可能出现潜在的代码中断，当使用非格式良好的数字字符串时：
- en: With `is_numeric()`
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`is_numeric()`
- en: In a string offset (for example, `$str['4x']`)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字符串偏移量中（例如，`$str['4x']`）
- en: With bitwise operators
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用位运算符
- en: When incrementing or decrementing a variable whose value is a non-well-formed
    numeric string
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在增加或减少值为非格式良好的数字字符串的变量时
- en: 'Here are some suggestions to fix your code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些修复代码的建议：
- en: Consider using `trim()` on numeric strings that might include leading or trailing
    white space (for example, numeric strings embedded within posted form data).
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑在可能包含前导或尾随空格的数字字符串上使用`trim()`（例如，嵌入在发布的表单数据中的数字字符串）。
- en: If your code relies upon strings that start with a number, use an explicit typecast
    to ensure that the number is correctly interpolated.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的代码依赖以数字开头的字符串，请使用显式类型转换来确保数字被正确插入。
- en: Do not rely upon an empty string (for example, `$str = ''`) to cleanly convert
    to 0.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要依赖空字符串（例如，`$str = ''`）干净地转换为0。
- en: 'In this following code example, a non-well-formed string with a trailing space
    is assigned to `$age`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，将一个带有尾随空格的非格式良好字符串分配给`$age`：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When we run this code in PHP 7, `is_numeric()` returns `TRUE`. Here is the
    PHP 7 output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在PHP 7中运行这段代码时，`is_numeric()`返回`TRUE`。以下是PHP 7的输出：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'On the other hand, when we run this code in PHP 8, `is_numeric()` returns `FALSE`
    as the string is not considered numeric. Here is the PHP 8 output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们在PHP 8中运行这段代码时，`is_numeric()`返回`FALSE`，因为该字符串不被视为数字。以下是PHP 8的输出：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, string handling differences between PHP 7 and PHP 8 can cause
    applications to behave differently, with potentially disastrous results. Let's
    now have a look at inconsistent results involving well-formed strings.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，PHP 7和PHP 8之间的字符串处理差异可能导致应用程序的行为不同，可能会产生灾难性的结果。现在让我们看一下涉及格式良好字符串的不一致结果。
- en: Dealing with inconsistent string-to-numeric comparison results
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理不一致的字符串到数字比较结果
- en: To complete a non-strict comparison involving string and numeric data, the PHP
    engine first performs a type-juggling operation that internally converts the string
    to a number before performing the comparison. Even a well-formed numeric string,
    however, can yield results that would be viewed as nonsensical from a human perspective.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成涉及字符串和数字数据的非严格比较，PHP引擎首先执行类型转换操作，将字符串在内部转换为数字，然后执行比较。然而，即使是格式良好的数字字符串，也可能产生从人类角度看起来荒谬的结果。
- en: 'As an example, have a look at this code sample:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看一下这个代码示例：
- en: 'First we perform a non-strict comparison between a variable, `$zero`, with
    a value of zero and a variable, `$string`, with a value of ABC:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们对一个变量`$zero`（值为零）和一个变量`$string`（值为ABC）进行了非严格比较：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following non-strict comparison uses `in_array()` to locate a value of
    zero in the `$array` array:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下非严格比较使用`in_array()`在`$array`数组中查找零值：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we perform a non-strict comparison between a leading-numeric string,
    `42abc88`, and a hardcoded number, `42`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们对一个以数字开头的字符串`42abc88`和一个硬编码数字`42`进行了非严格比较：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The results running in PHP 7 defy human comprehension! Here are the PHP 7 results:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中运行的结果令人难以理解！以下是PHP 7的结果：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: From a human perspective, none of these results make any sense! From the computer's
    perspective, on the other hand, it makes perfect sense. The string `ABC`, when
    converted to a number, ends up with a value of zero. Likewise, when the array
    search is made, each array element, having only a string value, ends up being
    interpolated as zero.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从人类的角度来看，这些结果都毫无意义！然而，从计算机的角度来看，这是完全合理的。字符串`ABC`在转换为数字时，最终的值为零。同样，当进行数组搜索时，每个只有字符串值的数组元素最终都被插值为零。
- en: The case of the leading-numeric string is a bit trickier. In PHP 7, the interpolation
    algorithm converts numeric characters until the first non-numeric character is
    encountered. Once that happens, the interpolation stops. Accordingly, the string
    `42abc88` becomes an integer, `42`, for comparison purposes. Now let's have a
    look at how PHP 8 handles string-to-numeric comparisons.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以数字开头的字符串的情况有点棘手。在PHP 7中，插值算法会将数字字符转换为第一个非数字字符出现之前。一旦发生这种情况，插值就会停止。因此，字符串`42abc88`在比较目的上变成了整数`42`。现在让我们看看PHP
    8如何处理字符串到数字的比较。
- en: Understanding comparison changes made in PHP 8
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解PHP 8中的比较变化
- en: In PHP 8, if a string is compared with a number, only numeric strings are considered
    valid for comparison. Strings in exponential notation are also considered valid
    for comparison, as well as numeric strings with leading or trailing whitespace.
    It's extremely important to note that PHP 8 makes this determination *before*
    converting the string.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，如果将字符串与数字进行比较，只有数字字符串才被视为有效比较。指数表示法中的字符串也被视为有效比较，以及具有前导或尾随空格的数字字符串。非常重要的是要注意，PHP
    8在转换字符串之前就做出了这一决定。
- en: 'Have a look at the output of the same code example described in the previous
    subsection (*Dealing with inconsistent string-to-numeric comparison results*),
    running in PHP 8:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下在上一小节中描述的相同代码示例的输出（*处理不一致的字符串到数字比较结果*），在PHP 8中运行：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So, as you can see from the output, there is a massive potential for your application
    to change its behavior following a PHP 8 upgrade. As a final note in PHP 8 string
    handling, let's look at how you can avoid upgrade issues.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从输出中可以看出，您的应用程序在进行PHP 8升级后有巨大的潜力改变其行为。在PHP 8字符串处理的最后说明中，让我们看看如何避免升级问题。
- en: Avoiding problems during a PHP 8 upgrade
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免在PHP 8升级期间出现问题
- en: The main issue you face is the difference in how PHP 8 handles non-strict comparisons
    that involve operands with different data types. If one operand is either `int`
    or `float`, and the other operand is `string`, you have a potential problem post-upgrade.
    If the string is a valid numeric string, the non-strict comparison will proceed
    without any issues.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您面临的主要问题是PHP 8如何处理涉及不同数据类型的非严格比较的差异。如果一个操作数是`int`或`float`，另一个操作数是`string`，那么在升级后可能会出现问题。如果字符串是有效的数字字符串，则非严格比较将进行而不会出现任何问题。
- en: 'The following operators are affected: `<=>`, `==`, `!=`, `>`, `>=`, `<`, and
    `<=`. The following functions are affected if the option flags are set to default:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下运算符受到影响：`<=>`、`==`、`!=`、`>`、`>=`、`<`和`<=`。如果选项标志设置为默认值，则以下函数会受到影响：
- en: '`in_array()`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in_array()`'
- en: '`array_search()`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array_search()`'
- en: '`array_keys()`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array_keys()`'
- en: '`sort()`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort()`'
- en: '`rsort()`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rsort()`'
- en: '`asort()`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asort()`'
- en: '`arsort()`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arsort()`'
- en: '`array_multisort()`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array_multisort()`'
- en: Tip
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on improved numeric string handling in PHP 8, refer to
    the following link: https://wiki.php.net/rfc/saner-numeric-strings. A related
    PHP 8 change is documented here: [https://wiki.php.net/rfc/string_to_number_comparison](https://wiki.php.net/rfc/string_to_number_comparison).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PHP 8中改进的数字字符串处理的更多信息，请参阅以下链接：https://wiki.php.net/rfc/saner-numeric-strings。相关的PHP
    8变化在此处记录：[https://wiki.php.net/rfc/string_to_number_comparison](https://wiki.php.net/rfc/string_to_number_comparison)。
- en: The best practice is to minimize PHP type juggling by providing type hints for
    functions or methods. You can also force the data type before the comparison.
    Finally, consider making use of strict comparisons, although this might not be
    suitable in all situations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是通过为函数或方法提供类型提示来最小化PHP类型转换。您还可以在比较之前强制数据类型。最后，考虑使用严格比较，尽管这在所有情况下可能并不适用。
- en: Now that you have an understanding of how to properly handle comparisons involving
    numeric strings in PHP 8, let's now have a look at PHP 8 changes involving arithmetic,
    bitwise, and concatenation operations.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何在PHP 8中正确处理涉及数字字符串的比较，现在让我们看看涉及算术、位和连接操作的PHP 8变化。
- en: Handling differences in arithmetic, bitwise, and concatenation operations
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理算术、位和连接操作的差异
- en: Arithmetic, bitwise, and concatenation operations are at the heart of any PHP
    application. In this section, you learn about hidden dangers that might arise
    in these simple operations following a PHP 8 migration. You must learn about the
    changes made in PHP 8 so that you can avoid a potential code break in your application.
    Because these operations are so ordinary, without this knowledge, you will be
    hard pressed to discover post-migration errors.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 算术、位和连接操作是任何PHP应用程序的核心。在本节中，您将了解在PHP 8迁移后这些简单操作可能出现的隐藏危险。您必须了解PHP 8中的更改，以便避免应用程序出现潜在的代码错误。因为这些操作是如此普通，如果没有这些知识，您将很难发现迁移后的错误。
- en: Let's first have a look at how PHP handles non-scalar data types in arithmetic
    and bitwise operations.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看PHP在算术和位操作中如何处理非标量数据类型。
- en: Handling non-scalar data types in arithmetic and bitwise operations
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理算术和位操作中的非标量数据类型
- en: Historically, the PHP engine has been very *forgiving* about using mixed data
    types in an arithmetic or bitwise operation. We've already had a look at comparison
    operations that involve *numeric*, *leading-numeric*, and *non-numeric* strings
    and numbers. As you learned, when a non-strict comparison is used, PHP invokes
    type juggling to convert the string to a number before performing the comparison.
    A similar action takes place when PHP performs an arithmetic operation that involves
    numbers and strings.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，PHP引擎对在算术或位操作中使用混合数据类型非常“宽容”。我们已经看过涉及*数字*、*前导数字*和*非数字*字符串和数字的比较操作。正如您所了解的，当使用非严格比较时，PHP会调用类型转换将字符串转换为数字，然后执行比较。当PHP执行涉及数字和字符串的算术操作时，也会发生类似的操作。
- en: Prior to PHP 8, **non-scalar data types** (data types other than `string`, `int`,
    `float`, or `boolean`) were allowed in an arithmetic operation. PHP 8 has clamped
    down on this bad practice, and no longer allows operands of the `array`, `resource`,
    or `object` type. PHP 8 consistently throws a `TypeError` when the non-scalar
    operands are used in an arithmetic operation. The only exception to this general
    change is that you can still perform arithmetic operations where all operands
    are of the `array` type.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8之前，**非标量数据类型**（除了`string`、`int`、`float`或`boolean`之外的数据类型）允许在算术操作中使用。PHP
    8已经严格限制了这种不良做法，不再允许`array`、`resource`或`object`类型的操作数。当非标量操作数用于算术操作时，PHP 8始终会抛出`TypeError`。这一般变化的唯一例外是，您仍然可以执行所有操作数都是`array`类型的算术操作。
- en: Tip
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For further information on the vital change in arithmetic and bitwise operations,
    have a look here: https://wiki.php.net/rfc/arithmetic_operator_type_checks.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有关算术和位操作中重要变化的更多信息，请参阅此处：https://wiki.php.net/rfc/arithmetic_operator_type_checks。
- en: 'Here is a code example to illustrate arithmetic operator handling differences
    in PHP 8:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个代码示例，用于说明PHP 8中算术运算符处理的差异：
- en: 'First, we define sample non-scalar data to test in an arithmetic operation:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义样本非标量数据以在算术操作中进行测试：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We then attempt to add the integer `99` to a resource, object, and to perform
    a modulus operation on an array:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们尝试将整数`99`添加到资源、对象，并对数组执行模数运算：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we add two arrays together:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将两个数组相加：
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When we run the code example, note how PHP 7 performs silent conversions and
    allows the operations to continue:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码示例时，请注意PHP 7如何执行静默转换并允许操作继续进行：
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: What is particularly astonishing is how we can perform a modulus operation against
    an array! When adding a value to an object, a `Notice` is generated in PHP 7\.
    However, PHP type juggles the object to an integer with a value of `1`, giving
    a result of `100` to the arithmetic operation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 特别令人惊讶的是我们如何对数组执行模数运算！在PHP 7中，向对象添加值会生成一个`Notice`。但是，在PHP中，对象被类型转换为具有值`1`的整数，从而使算术操作的结果为`100`。
- en: 'The output running the same code sample in PHP 8 is quite different:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中运行相同的代码示例的输出非常不同：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see from the output, PHP 8 consistently throws a `TypeError`, except
    when adding two arrays. In both outputs, you may observe that when adding two
    arrays, the second operand is ignored. If the objective is to combine the two
    arrays, you must use `array_merge()` instead.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，PHP 8始终会抛出`TypeError`，除非添加两个数组。在两个输出中，您可能会观察到当添加两个数组时，第二个操作数被忽略。如果目标是合并两个数组，则必须使用`array_merge()`。
- en: Let's now turn our attention to a potentially significant change in PHP 8 string
    handling pertaining to the order of precedence.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们关注PHP 8中与优先级顺序相关的字符串处理的潜在重大变化。
- en: Examining changes in the order of precedence
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查优先级顺序的变化
- en: 'The **order of precedence**, also known as the *order of operations*, or *operator
    precedence*, is a mathematical concept established in the late 18th and early
    19th centuries. PHP also adopted the mathematical operator precedence rules, with
    a unique addition: the concatenate operator. An assumption was made by the founders
    of the PHP language that the concatenate operator had equal precedence over the
    arithmetic operators. This assumption was never challenged until the arrival of
    PHP 8.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**优先级顺序**，也称为*操作顺序*或*运算符优先级*，是在18世纪末和19世纪初确立的数学概念。PHP还采用了数学运算符优先级规则，并增加了一个独特的内容：连接运算符。PHP语言的创始人假设连接运算符具有与算术运算符相等的优先级。直到PHP
    8的到来，这一假设从未受到挑战。'
- en: In PHP 8, arithmetic operations are given precedence over concatenation. The
    concatenate operator demotion now places it below the bit shift operators (`<<`
    and `>>`). There is a potential backward-compatible break in any place where you
    don't use parentheses to clearly define mixed arithmetic and concatenate operations.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，算术操作的优先级高于连接。连接运算符的降级现在将其置于位移运算符（`<<`和`>>`）之下。在任何不使用括号明确定义混合算术和连接操作的地方，都存在潜在的向后兼容性中断。
- en: This change, in itself, will not throw an `Error` or generate `Warnings` or
    `Notices`, and thereby presents the potential for a hidden code break.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化本身不会引发`Error`，也不会生成`Warnings`或`Notices`，因此可能导致潜在的代码中断。
- en: Tip
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on the reasoning for this change, refer to the following
    link:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此更改的原因的更多信息，请参阅以下链接：
- en: https://wiki.php.net/rfc/concatenation_precedence
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: https://wiki.php.net/rfc/concatenation_precedence
- en: 'The following example most clearly shows the effect of this change:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例最清楚地显示了这种变化的影响：
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here is the output of this simple statement in PHP 7:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PHP 7中对这个简单语句的输出：
- en: '[PRE49]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In PHP 7, because the concatenate operator has equal precedence over the addition
    operator, the string `The sum of 2 + 2 is:` is first concatenated with the integer
    value `2`. The new string is then type juggled to an integer, generating a `Warning`.
    The value of the new string is evaluated at `0`, which is then added to integer
    `2`, producing the output of `2`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中，因为连接运算符的优先级与加法运算符相等，字符串`The sum of 2 + 2 is:`首先与整数值`2`连接。然后将新字符串类型转换为整数，生成一个`Warning`。新字符串的值计算为`0`，然后加到整数`2`上，产生输出`2`。
- en: 'In PHP 8, however, the addition takes place first, after which the result is
    concatenated with the initial string. Here is the result running in PHP 8:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PHP 8中，首先进行加法，然后将结果与初始字符串连接。这是在PHP 8中运行的结果：
- en: '[PRE50]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see from the output, the result is much closer to human expectations!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从输出中看到的，结果更接近人类的期望！
- en: 'One more illustration should drive home the differences demoting the concatenate
    operator can make. Have a look at this line of code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个例子，说明降级连接运算符可能产生的差异。看看这行代码：
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here is the result running in PHP 7:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在PHP 7中运行的结果：
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'PHP 7 performs the concatenation first, producing a string, `111`. This is
    type juggled and added to integer `222`, resulting in a final value integer, `333`.
    Here is the result running in PHP 8:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7首先进行连接，产生一个字符串`111`。这被类型转换并加到整数`222`上，产生最终值整数`333`。这是在PHP 8中运行的结果：
- en: '[PRE53]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In PHP 8, the second string, `11`, is type juggled and added to integer `222`,
    producing an interim value, `233`. This is type juggled to a string and prepended
    with `1`, resulting in a final string value of `1233`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，第二个字符串`11`被类型转换并加到整数`222`上，产生一个中间值`233`。这被类型转换为字符串，并以`1`开头，最终产生一个字符串值`1233`。
- en: 'Now that you are aware of changes to arithmetic, bitwise, and concatenation
    operations in PHP 8, let''s have a look at a new trend introduced in PHP 8: locale
    independence.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了PHP 8中算术、位和连接操作的变化，让我们来看看PHP 8中引入的一个新趋势：区域设置独立性。
- en: Taking advantage of locale independence
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用区域设置独立性
- en: In versions of PHP prior to PHP 8, several string functions and operations were
    tied to the **locale**. The net effect was that numbers were internally stored
    differently depending on the locale. This practice introduced subtle inconsistencies
    that were extremely difficult to detect. After reviewing the material presented
    in this chapter, you will be in a better position to detect potential application
    code changes following a PHP 8 upgrade, thereby avoiding application failure.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8之前的版本中，几个字符串函数和操作与**区域设置**相关。其净效果是，根据区域设置的不同，数字在内部存储方式不同。这种做法引入了微妙的不一致，极其难以检测。在阅读本章介绍的材料后，您将更好地了解在PHP
    8升级后检测潜在应用程序代码更改的潜力，从而避免应用程序失败。
- en: Understanding the problems associated with locale dependence
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解与区域设置依赖相关的问题
- en: The unfortunate side effect of locale dependence in earlier PHP versions was
    inconsistent results when typecasting from `float` to `string` and then back again.
    Inconsistencies were also seen when a `float` value was concatenated to a `string`.
    Certain optimizing operations performed by *OpCache* resulted in the concatenation
    operation occurring before the locale had been set, yet another way in which inconsistent
    results might be produced.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的PHP版本中，区域设置依赖的不幸副作用是从`float`到`string`的类型转换，然后再次转换时产生不一致的结果。当将`float`值连接到`string`时，也会出现不一致。由*OpCache*执行的某些优化操作导致连接操作发生在设置区域设置之前，这是产生不一致结果的另一种方式。
- en: In PHP 8, vulnerable operations and functions are now locale-independent. What
    this means is that all float values are now stored using a period as the decimal
    separator. The default locale is no longer inherited from the environment by default.
    If you need the default locale to be set, you must now explicitly call `setlocale()`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，易受攻击的操作和函数现在与区域设置无关。这意味着所有浮点值现在都使用句点作为小数分隔符进行存储。默认区域设置不再默认从环境中继承。如果需要设置默认区域设置，现在必须显式调用`setlocale()`。
- en: Reviewing functions and operations affected by locale independence
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查受区域设置独立性影响的函数和操作
- en: Most PHP functions are not affected by the switch to locale independence for
    the simple reason that locale is irrelevant to that function or extension. Furthermore,
    most PHP functions and extensions are already locale-independent. Examples include
    the `PDO` extension, along with functions such as `var_export()` and `json_encode()`,
    and the `printf()` family.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数PHP函数不受区域设置独立性切换的影响，因为该函数或扩展与区域设置无关。此外，大多数PHP函数和扩展已经是区域设置独立的。例如`PDO`扩展，以及`var_export()`和`json_encode()`等函数，以及`printf()`系列。
- en: 'Functions and operations affected by locale independence include the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 受区域设置独立性影响的函数和操作包括以下内容：
- en: '`(string) $float`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(string) $float`'
- en: '`strval($float)`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strval($float)`'
- en: '`print_r($float)`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_r($float)`'
- en: '`var_dump($float)`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var_dump($float)`'
- en: '`debug_zval_dump($float)`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug_zval_dump($float)`'
- en: '`settype($float, "string")`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`settype($float, "string")`'
- en: '`implode([$float])`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`implode([$float])`'
- en: '`xmlrpc_encode($float)`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xmlrpc_encode($float)`'
- en: 'Here is a code example that illustrates handling differences due to locale
    independence:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例代码，说明了由于区域设置独立性而产生的差异的处理：
- en: 'First, we define an array of locales to test. The locales chosen use different
    ways to represent the decimal portion of a number:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个要测试的区域设置数组。所选的区域设置使用不同的方式来表示数字的小数部分：
- en: '[PRE54]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We then loop through the locales, set the locale, and perform a float-to-string
    followed by a string-to-float conversion, echoing the results at each step:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们循环遍历区域设置，设置区域设置，并执行从浮点数到字符串的转换，然后再从字符串到浮点数的转换，同时在每一步打印结果：
- en: '[PRE55]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we run this example in PHP 7, note the result:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在PHP 7中运行这个例子，请注意结果：
- en: '[PRE56]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see from the output, the number is stored internally using a period
    for a decimal separator for `en_GB`, whereas the comma is used for locales `fr_FR`
    and `de_DE`. However, when the string is converted back to a number, the string
    is treated as a leading-numeric string if the decimal separator is not a period.
    In two of the locales, the presence of the comma stops the conversion process.
    The net effect is that the decimal portion is dropped and precision is lost.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，对于`en_GB`，数字在内部使用句点作为小数分隔符存储，而对于`fr_FR`和`de_DE`等地区，逗号用于分隔。然而，当将字符串转换回数字时，如果小数分隔符不是句点，字符串将被视为前导数字字符串。在两个地区中，逗号的存在会停止转换过程。其结果是小数部分被丢弃，精度丢失。
- en: 'The results when running the same code sample in PHP 8 are shown here:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中运行相同代码示例的结果如下：
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In PHP 8, no precision is lost and the number is consistently represented using
    a period for the decimal separator, regardless of the locale.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，没有丢失精度，无论地区如何，数字都会一致地使用句点作为小数分隔符来表示。
- en: Please note that you can still represent a number according to its locale by
    using the `number_format()` function, or by using the `NumberFormatter` class
    (from the `Intl` extension). It's interesting to note that the `NumberFormatter`
    class stores numbers internally in a locale-independent manner!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您仍然可以使用`number_format()`函数或使用`NumberFormatter`类（来自`Intl`扩展）根据其地区表示数字。有趣的是，`NumberFormatter`类以与地区无关的方式在内部存储数字！
- en: Tip
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information, have a look at this article: https://wiki.php.net/rfc/locale_independent_float_to_string.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请查看这篇文章：https://wiki.php.net/rfc/locale_independent_float_to_string。
- en: For more information on international number formatting, refer to the following
    link:https://www.php.net/manual/en/class.numberformatter.php
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有关国际数字格式化的更多信息，请参阅以下链接：https://www.php.net/manual/en/class.numberformatter.php
- en: Now that you are aware of the locale-independent aspects present in PHP 8, we
    need to have a look at changes in array handling.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了PHP 8中存在的与地区无关的方面，我们需要看一下数组处理的变化。
- en: Handling arrays in PHP 8
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PHP 8中处理数组
- en: Aside from improvements in performance, the two main changes in PHP 8 array
    handling pertain to the handling of negative offsets and curly brace (`{}`) usage.
    Since both of these changes could result in application code breaks following
    a PHP 8 migration, it's important to cover them here. Awareness of the issues
    presented here gives you a better chance to get broken code working again in short
    order.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 除了性能的改进之外，PHP 8数组处理的两个主要变化涉及处理负偏移和花括号(`{}`)的使用。由于这两个变化可能导致在PHP 8迁移后应用代码中断，因此重要的是在这里进行介绍。了解这里提出的问题可以让你更有机会在短时间内使中断的代码重新运行。
- en: Let's have a look at negative array offset handling first.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看一下负数组偏移处理。
- en: Dealing with negative offsets
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理负偏移
- en: When assigning a value to an array in PHP, if you do not specify an index, PHP
    will automatically assign one for you. The index chosen in this manner is an integer
    that represents a value one higher than the highest currently assigned integer
    key. If no integer index key has yet been assigned, the automatic index assignment
    algorithm starts at zero.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中为数组分配值时，如果不指定索引，PHP会自动为您分配一个。以这种方式选择的索引是一个整数，表示比当前分配的整数键高一个值。如果尚未分配整数索引键，自动索引分配算法将从零开始。
- en: In PHP 7 and below, however, this algorithm is not applied consistently in the
    case of a negative integer index. If a numeric array started with a negative number
    for its index, auto-indexing jumps to zero (`0`) regardless of what the next number
    would ordinarily be. In PHP 8, on the other hand, automatic indexing consistently
    increments by a value of `+1` regardless of whether the index is a negative or
    positive integer.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PHP 7及更低版本中，对于负整数索引，这种算法并不一致。如果一个数字数组以负数作为索引开始，自动索引会跳到零(`0`)，而不管下一个数字通常是什么。另一方面，在PHP
    8中，自动索引始终以`+1`的值递增，无论索引是负数还是正数。
- en: A possible backward-compatible code break is present if your code relies upon
    auto-indexing, and any of the starting indices are negative numbers. Detection
    of this issue is difficult as auto-indexing occurs silently, without any `Warnings`
    or `Notices`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码依赖于自动索引，并且起始索引是负数，那么可能会出现向后兼容的代码中断。检测这个问题很困难，因为自动索引会在没有任何`警告`或`通知`的情况下悄悄发生。
- en: 'The following code example illustrates the difference in behavior between PHP
    7 and PHP 8:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了PHP 7和PHP 8之间行为差异：
- en: 'First, we define an array with only negative integers as indexes. We use `var_dump()`
    to reveal this array:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个只有负整数作为索引的数组。我们使用`var_dump()`来显示这个数组：
- en: '[PRE58]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We then define a second array and initialize the first index to `-3`. We then
    add additional array elements, but without specifying an index. This causes auto-indexing
    to occur:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义第二个数组，并将第一个索引初始化为`-3`。然后我们添加额外的数组元素，但没有指定索引。这会导致自动索引发生：
- en: '[PRE59]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If we then run the program in PHP 7, note that the first array is rendered
    correctly. It''s entirely possible to have negative array indexes in PHP 7 and
    earlier as long as they''re directly assigned. Here is the output:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在PHP 7中运行程序，注意第一个数组被正确渲染。在PHP 7及更早版本中，只要直接分配，就可以有负数组索引。以下是输出：
- en: '[PRE60]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: However, as you can see from the second `var_dump()` output, automatic array
    indexing skips to zero regardless of the previous high value.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，正如你从第二个`var_dump()`输出中看到的，自动数组索引会跳过零，而不管先前的高值是多少。
- en: 'In PHP 8, on the other hand, you can see that the output is consistent. Here''s
    the PHP 8 output:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，在PHP 8中，你可以看到输出是一致的。以下是PHP 8的输出：
- en: '[PRE61]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As you can see from the output, the array indexes are automatically assigned,
    incremented by a value of `1`, making the two arrays identical.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输出中可以看出，数组索引是自动分配的，递增了`1`，使得两个数组相同。
- en: Tip
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on this enhancement, have a look at this article: https://wiki.php.net/rfc/negative_array_index.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此增强功能的更多信息，请参阅此文章：https://wiki.php.net/rfc/negative_array_index。
- en: 'Now that you are aware of the potential code break regarding auto-assignment
    of indexes involving negative values, let''s turn our attention to the other area
    of interest: the use of curly braces.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经意识到了涉及负值自动赋值索引的潜在代码中断，让我们把注意力转向另一个感兴趣的领域：花括号的使用。
- en: Handling curly brace usage changes
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理花括号使用变化
- en: Curly braces (`{}`) are a familiar sight for any developer creating PHP code.
    The PHP language, written in C, makes extensive use of C syntax, including curly
    braces. It is well known that curly braces are used to delineate blocks of code
    in control structures (for example, `if {}`), in loops (for example, `for () {}`),
    in functions (for example, `function xyz() {}`), and classes.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号（`{}`）对于创建PHP代码的任何开发人员来说都是一个熟悉的视觉。PHP语言是用C语言编写的，广泛使用C语法，包括花括号。众所周知，花括号用于在控制结构（例如，`if
    {}`）、循环（例如，`for () {}`）、函数（例如，`function xyz() {}`）和类中界定代码块。
- en: In this subsection, however, we will restrict our examination of curly brace
    usage to that associated with variables. One potentially significant change in
    PHP 8 is the use of curly braces to identify an array element. The use of curly
    braces to designate array offsets is now deprecated as of PHP 8.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本小节中，我们将把对花括号的使用的研究限制在与变量相关的方面。PHP 8中一个可能重大的变化是使用花括号来标识数组元素。在PHP 8中，使用花括号来指定数组偏移已经被弃用。
- en: 'The old usage has been highly contentious given the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于以下原因，旧的用法一直备受争议：
- en: Its use can easily be confused with the use of curly braces inside doubly quoted
    strings.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的使用很容易与双引号字符串中的花括号的使用混淆。
- en: Curly braces cannot be used to make array assignments.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花括号不能用于进行数组赋值。
- en: Accordingly, the PHP core team needed to either make the use of curly braces
    consistent with square brackets (`[ ]`) ... or just get rid of this curly brace
    usage. The final decision was to remove support for curly braces with arrays.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，PHP核心团队需要使花括号的使用与方括号（`[ ]`）一致...或者干脆摒弃这种花括号的使用。最终决定是移除对数组的花括号支持。
- en: Tip
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on the background behind the change, refer to the following
    link: https://wiki.php.net/rfc/deprecate_curly_braces_array_access.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更改背后的背景信息，请参阅以下链接：https://wiki.php.net/rfc/deprecate_curly_braces_array_access。
- en: 'Here is a code example that illustrates the point:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个说明这一点的代码示例：
- en: 'First, we define an array of callbacks that illustrate removed or illegal curly
    brace usage:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个回调函数数组，说明了已删除或非法使用花括号的情况：
- en: '[PRE62]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We then loop through the callbacks using a `try`/`catch` block to capture errors
    that are thrown:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用`try`/`catch`块循环遍历回调函数以捕获抛出的错误：
- en: '[PRE63]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If we run the example in PHP 7, the first callback works. The second and third
    cause a `ParseError` to be thrown:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在PHP 7中运行这个例子，第一个回调函数可以工作。第二个和第三个会抛出`ParseError`：
- en: '[PRE64]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'When we run the same example in PHP 8, however, none of the examples work.
    Here is the PHP 8 output:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们在PHP 8中运行相同的例子时，没有一个例子能工作。以下是PHP 8的输出：
- en: '[PRE65]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This potential code break is easy to detect. However, because your code has
    many curly braces, you might have to wait for the fatal `Error` to be thrown to
    capture the code break.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这种潜在的代码中断很容易检测到。然而，由于你的代码中有许多花括号，你可能不得不等待致命的`Error`被抛出来捕获代码中断。
- en: Now that you have an idea of changes in array handling in PHP 8, let's have
    a look at changes in security-related functions.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了PHP 8中数组处理的变化，让我们来看看与安全相关函数的变化。
- en: Mastering changes in security functions and settings
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握安全函数和设置的变化
- en: 'Any changes to PHP security features are worth noting. Unfortunately, given
    the state of the world today, attacks on any web-facing code are a given. Accordingly,
    in this section, we address several changes to security-related PHP functions
    in PHP 8\. The changed functions affected include the following:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对PHP安全功能的更改都值得注意。不幸的是，鉴于当今世界的状况，对任何面向网络的代码的攻击是必然的。因此，在本节中，我们将讨论PHP 8中与安全相关的函数的几处变化。受影响的变化函数包括以下内容：
- en: '`assert()`'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert()`'
- en: '`password_hash()`'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password_hash()`'
- en: '`crypt()`'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crypt()`'
- en: In addition, there was a change in how PHP 8 treats any functions defined in
    the `php.ini` file using the `disable_functions` directive. Let's have a look
    at this directive to begin with.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，PHP 8对于在`php.ini`文件中使用`disable_functions`指令定义的任何函数的处理方式也发生了变化。让我们首先看一下这个指令。
- en: Understanding changes in disabled functions handling
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解禁用函数处理的变化。
- en: Web hosting companies often offer heavily discounted **shared hosting** packages.
    Once a customer signs up, the IT staff at the hosting company creates an account
    on the shared server, assigns a disk quota to control disk space usage, and creates
    a **virtual host** definition on the web service. The problem such hosting companies
    face, however, is that allowing unrestricted access to PHP poses a security risk
    to both the shared hosting company as well as other users on the same server.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Web托管公司通常提供大幅折扣的**共享托管**套餐。一旦客户注册，托管公司的IT工作人员会在共享服务器上创建一个帐户，分配一个磁盘配额来控制磁盘空间的使用，并在Web服务上创建一个**虚拟主机**定义。然而，这些托管公司面临的问题是，允许对PHP的无限制访问对共享托管公司以及同一服务器上的其他用户构成安全风险。
- en: To address this issue, IT staff often assign a comma-separated list of functions
    to the `php.ini` directive, **disable_functions**. In so doing, any function on
    this list cannot be used in PHP code running on that server. Functions that typically
    end up on this list are those that allow operating system access, such as `system()`
    or `shell_exec()`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，IT工作人员经常将一个逗号分隔的函数列表分配给`php.ini`指令**disable_functions**。这样做，列表中的任何函数都不能在运行在该服务器上的PHP代码中使用。通常会出现在这个列表上的函数是那些允许操作系统访问的函数，比如`system()`或`shell_exec()`。
- en: Only internal PHP functions can end up on this list. Internal functions are
    those included in the PHP core as well as functions provided via extensions. User-defined
    functions are not affected by this directive.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 只有内部PHP函数才会出现在这个列表上。内部函数是指包括在PHP核心中以及通过扩展提供的函数。用户定义的函数不受此指令影响。
- en: Examining disabled functions' handling differences
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查禁用函数处理的差异
- en: In PHP 7 and earlier, disabled functions could not be re-defined. In PHP 8,
    disabled functions are treated as if they never existed, which means re-definition
    is possible.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7及更早版本中，禁用的函数无法重新定义。在PHP 8中，禁用的函数被视为从未存在过，这意味着重新定义是可能的。
- en: Important note
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Just because you can redefine the disabled function in PHP 8 *does not* mean
    that the original functionality has been restored!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中重新定义禁用的函数*并不意味着*原始功能已经恢复！
- en: To illustrate this concept, we first add this line to the `php.ini` file:`disable_functions=system.`
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个概念，我们首先将这行添加到`php.ini`文件中：`disable_functions=system.`
- en: 'Note that we need to add this to *both* Docker containers (both PHP 7 and PHP
    8) in order to complete the illustration. The commands to update the `php.ini`
    files are shown here:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要将此内容添加到*两个* Docker容器（PHP 7和PHP 8）中，以完成说明。更新`php.ini`文件的命令如下所示：
- en: '[PRE66]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If we then attempt to use the `system()` function, the attempt fails in both
    PHP 7 and PHP 8\. Here, we show the output from PHP 8:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用`system()`函数，则在PHP 7和PHP 8中都会失败。这里，我们展示了PHP 8的输出：
- en: '[PRE67]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We then define some program code that redefines the banned function:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义一些重新定义被禁止函数的程序代码：
- en: '[PRE68]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As you can see from the code example, we''ve created a function that mimics
    the behavior of an `ls -l` Linux system call, but only uses safe PHP functions
    and classes. If we try to run this in PHP 7, however, a fatal `Error` is thrown.
    Here is the PHP 7 output:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码示例中可以看出，我们创建了一个模仿`ls -l`Linux系统调用行为的函数，但只使用安全的PHP函数和类。然而，如果我们尝试在PHP 7中运行这个函数，会抛出致命的`Error`。以下是PHP
    7的输出：
- en: '[PRE69]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In PHP 8, however, our function redefinition succeeds, as shown here:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PHP 8中，我们的函数重新定义成功，如下所示：
- en: '[PRE70]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You now have an idea of how to work with disabled functions. Next, let's have
    a look at changes to the vital `crypt()` function.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何处理禁用的函数了。接下来，让我们看看对重要的`crypt()`函数的更改。
- en: Learning about changes to the crypt() function
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解`crypt()`函数的更改
- en: The **crypt()** function has been a staple of PHP hash generation since PHP
    version 4\. One of the reasons for its resilience is because it has so many options.
    If your code uses `crypt()` directly, you'll be pleased to note that if an unusable
    **salt** value is provided, Defense Encryption Standard (**DES**), long considered
    broken, is *no longer* the fallback in PHP 8! The salt is also sometimes referred
    to as the **initialization vector** (**IV**).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**crypt()**函数自PHP 4版本以来一直是PHP哈希生成的重要组成部分。它之所以如此坚固，是因为它有很多选项。如果你的代码直接使用`crypt()`，你会高兴地注意到，在PHP
    8中，如果提供了一个不可用的**salt**值，那么防御加密标准（**DES**），长期以来被认为是破解的，*不再*是PHP 8的回退！盐有时也被称为**初始化向量**（**IV**）。'
- en: 'Another important change involves the **rounds** value. A *round* is like shuffling
    a deck of cards: the more times you shuffle, the higher the degree of randomization
    (unless you''re dealing with a Las Vegas card shark!). In cryptography, blocks
    are analogous to cards. During each round, a cryptographic function is applied
    to each block. If the cryptographic function is simple, the hash can be generated
    more quickly; however, a larger number of rounds are required to fully randomize
    the blocks.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的变化涉及**rounds**值。*round*就像洗牌一副牌：洗牌的次数越多，随机化程度就越高（除非你在和拉斯维加斯的牌手打交道！）。在密码学中，块类似于卡片。在每一轮中，密码函数被应用于每个块。如果密码函数很简单，哈希可以更快地生成；然而，需要更多的轮次来完全随机化块。
- en: The **SHA-1** (**Secure Hash Algorithm**) family uses a fast but simple algorithm,
    and thus requires more rounds. The SHA-2 family, on the other hand, uses a more
    complex hashing function, which takes more resources, but fewer rounds.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**SHA-1**（安全哈希算法）系列使用快速但简单的算法，因此需要更多的轮次。另一方面，SHA-2系列使用更复杂的哈希函数，需要更多的资源，但更少的轮次。'
- en: When using the PHP `crypt()` function in conjunction with `CRYPT_SHA256`, (SHA-2
    family), PHP 8 will no longer silently resolve the `rounds` parameter to the closest
    limit. Instead, `crypt()` will fail with a `*0` return, matching `glibc` behavior.
    In addition, in PHP 8, the second argument (the salt), is now mandatory.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 当在PHP 8中与`CRYPT_SHA256`（SHA-2系列）一起使用PHP `crypt()`函数时，`crypt()`将不再默默解析`rounds`参数到最接近的限制。相反，`crypt()`将以`*0`返回失败，与`glibc`的行为相匹配。此外，在PHP
    8中，第二个参数（盐）现在是强制性的。
- en: 'The following example illustrates the differences between PHP 7 and PHP 8 when
    using the `crypt()` function:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了在使用`crypt()`函数时PHP 7和PHP 8之间的差异：
- en: 'First, we define variables representing an unusable salt value, and an illegal
    number of rounds:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了代表不可用盐值和非法轮次数的变量：
- en: '[PRE71]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We then create two hashes using the `crypt()` function. In the first usage,
    `$default` is the result after supplying an invalid salt argument. The second
    usage, `$sha256`, provides a valid salt value, but an invalid number of rounds:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用`crypt()`函数创建两个哈希。在第一种用法中，提供了一个无效的盐参数后，`$default`是结果。第二种用法中，`$sha256`提供了一个有效的盐值，但是一个无效的轮次数：
- en: '[PRE72]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here is the output of the code example running in PHP 7:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PHP 7中运行代码示例的输出：
- en: '[PRE73]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Notice how PHP 7 silently modifies the original request. In the first case,
    `crypt()` falls back to `DES` (!). In the second case, PHP 7 silently alters the
    `rounds` value from `1` to the nearest limit of `1000`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，PHP 7会默默修改原始请求。在第一种情况下，`crypt()`回退到`DES`（！）。在第二种情况下，PHP 7会默默地将`rounds`值从`1`修改为最接近的限制值`1000`。
- en: 'The same code running in PHP 8, on the other hand, fails and returns `*0`,
    as shown here:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在PHP 8中运行相同的代码会失败并返回`*0`，如下所示：
- en: '[PRE74]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As we have stressed repeatedly in this book, when PHP makes assumptions for
    you, ultimately you end up with bad code that produces inconsistent results. In
    the code example just shown, the best practice would be to define a class method
    or function that exerts greater control over its parameters. In this manner, you
    can validate the parameters and avoid having to rely upon PHP assumptions.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书中一再强调的，当PHP为您做出假设时，最终您会得到产生不一致结果的糟糕代码。在刚刚展示的代码示例中，最佳实践是定义一个类方法或函数，对其参数施加更大的控制。通过这种方式，您可以验证参数，避免依赖PHP的假设。
- en: Next, we take a look at changes to the `password_hash()` function.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看`password_hash()`函数的变化。
- en: Dealing with changes to password_hash()
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理`password_hash()`的变化
- en: 'Over the years, so many developers had misused `crypt()` that the PHP core
    team decided to add a wrapper function, `password_hash()`. This proved to be a
    smashing success and is now one of the most widely used security functions. Here
    is the function signature for `password_hash()`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，许多开发人员错误使用了`crypt()`，因此PHP核心团队决定添加一个包装函数`password_hash()`。这被证明是一个巨大的成功，现在是最广泛使用的安全函数之一。这是`password_hash()`的函数签名：
- en: '[PRE75]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Algorithms currently supported include **bcrypt**, **Argon2i**, and **Argon2id**.
    It''s recommended that you use the predefined constants for algorithms: `PASSWORD_BCRYPT`,
    `PASSWORD_ARGON2I`, and `PASSWORD_ARGON2ID`. The `PASSWORD_DEFAULT` algorithm
    is currently set to `bcrypt`. Options vary according to the algorithm. If you
    use either `PASSWORD_BCRYPT` or the `PASSWORD_DEFAULT` algorithms, the options
    include `cost` and `salt`.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 目前支持的算法包括**bcrypt**、**Argon2i**和**Argon2id**。建议您使用预定义的算法常量：`PASSWORD_BCRYPT`、`PASSWORD_ARGON2I`和`PASSWORD_ARGON2ID`。`PASSWORD_DEFAULT`算法当前设置为`bcrypt`。选项根据算法而异。如果您使用`PASSWORD_BCRYPT`或`PASSWORD_DEFAULT`算法，选项包括`cost`和`salt`。
- en: Conventional wisdom suggests that it's better to use the randomly generated
    `salt` created by the `password_hash()` function. In PHP 7, the `salt` option
    was deprecated and is now ignored in PHP 8\. This won't cause a backward-compatible
    break unless you're relying on `salt` for some other reason.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 传统智慧认为最好使用`password_hash()`函数创建的随机生成的`salt`。在PHP 7中，`salt`选项已被弃用，并且在PHP 8中被忽略。这不会造成向后兼容的断裂，除非您因其他原因依赖`salt`。
- en: 'In this code example, a non-random salt value is used:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，使用了一个非随机的salt值：
- en: '[PRE76]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In the PHP 7 output, a deprecation `Notice` is issued:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7的输出中，发出了一个弃用的`Notice`：
- en: '[PRE77]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You'll also note from the PHP 7 output that the non-random `salt` value is clearly
    visible. One other thing to note is that when `password_get_info()` is executed,
    the `algo` key shows an integer value that corresponds to one of the predefined
    algorithm constants.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从PHP 7的输出中注意到非随机的`salt`值是清晰可见的。还有一件事要注意的是，当执行`password_get_info()`时，`algo`键显示一个整数值，对应于预定义的算法常量之一。
- en: 'The PHP 8 output is somewhat different, as seen here:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8的输出有些不同，如下所示：
- en: '[PRE78]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You can see that the `salt` value was ignored, and a random `salt` used instead.
    Instead of a `Notice`, PHP 8 issues a `Warning` regarding the use of the `salt`
    option. Another point to note from the output is that when `password_get_info()`
    is called, the `algorithm` key returns a string rather than an integer in PHP
    8\. This is because the predefined algorithm constants are now string values that
    correspond to their signature when used in the `crypt()` function.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`salt`值被忽略，而是使用随机的`salt`。PHP 8不再发出`Notice`，而是发出关于使用`salt`选项的`Warning`。从输出中还要注意的一点是，当调用`password_get_info()`时，`algorithm`键返回的是一个字符串，而不是PHP
    8中的整数。这是因为预定义的算法常量现在是与在`crypt()`函数中使用时对应的字符串值。
- en: The last function we will examine, in the next subsection, is `assert()`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中检查的最后一个函数是`assert()`。
- en: Learning about changes to assert()
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解`assert()`的变化
- en: The `assert()` function is normally associated with testing and diagnostics.
    We include it in this subsection, as it often has security implications. Developers
    sometimes use this function when attempting to trace potential security vulnerabilities.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert()`函数通常与测试和诊断相关联。我们在本小节中包含它，因为它经常涉及安全性问题。开发人员有时在尝试跟踪潜在的安全漏洞时使用这个函数。'
- en: To use the `assert()` function, you must first enable it by adding a `php.ini`
    file setting `zend.assertions=1`. Once enabled, you can place one or more `assert()`
    function calls at any place within your application code.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`assert()`函数，您必须首先通过添加`php.ini`文件设置`zend.assertions=1`来启用它。一旦启用，您可以在应用程序代码的任何地方放置一个或多个`assert()`函数调用。
- en: Understanding changes to assert() usage
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解`assert()`的用法变化
- en: 'As of PHP 8, it''s no longer possible to present `assert()` with string arguments
    to be evaluated: instead, you must provide an expression. This presents a potential
    code break because in PHP 8, the string is treated as an expression, and therefore
    always resolves to the Boolean `TRUE`. Also, both the `assert.quiet_eval` `php.ini`
    directive, and the `ASSERT_QUIET_EVAL` pre-defined constant used with `assert_options()`,
    have been removed in PHP 8 as they now have no effect.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 从PHP 8开始，不再可能向`assert()`提供要评估的字符串参数：相反，您必须提供一个表达式。这可能会导致代码断裂，因为在PHP 8中，该字符串被视为一个表达式，因此总是解析为布尔值`TRUE`。此外，`assert.quiet_eval`的`php.ini`指令和与`assert_options()`一起使用的`ASSERT_QUIET_EVAL`预定义常量在PHP
    8中已被移除，因为它们现在没有效果。
- en: 'To illustrate the potential problem, we first activate assertions by setting
    the `php.ini` directive, `zend.assertions=1`. We then define an example program
    as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明潜在的问题，我们首先通过设置`php.ini`指令`zend.assertions=1`来激活断言。然后我们定义一个示例程序如下：
- en: 'We use `ini_set()` to cause `assert()` to throw an exception. We also define
    a variable, `$pi`:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`ini_set()`来导致`assert()`抛出一个异常。我们还定义了一个变量`$pi`：
- en: '[PRE79]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We then attempt an assertion as an expression, `$pi === M_PI`:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们尝试一个断言作为一个表达式，`$pi === M_PI`：
- en: '[PRE80]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In the last `try`/`catch` block, we attempt an assertion as a string:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后的`try`/`catch`块中，我们尝试一个断言作为一个字符串：
- en: '[PRE81]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'When we run the program in PHP 7, everything works as expected:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在PHP 7中运行程序时，一切都按预期工作：
- en: '[PRE82]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The value of `M_PI` comes from the math extension, and is far more accurate
    than simply dividing 22 by 7! Accordingly, both assertions throw an exception.
    In PHP 8, however, the output is significantly different:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`M_PI`的值来自数学扩展，比简单地将22除以7要准确得多！因此，两个断言都会引发异常。然而，在PHP 8中，输出显著不同：'
- en: '[PRE83]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The assertion as a string is interpreted as an expression. Because the string
    is not empty, the Boolean result is `TRUE`, returning a false positive. If your
    code relies upon the result of an assertion as a string, it is bound to fail.
    As you can see from the PHP 8 output, however, an assertion as an expression works
    the same in PHP 8 as in PHP 7.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串作为断言解释为表达式。因为字符串不为空，布尔结果为`TRUE`，返回了一个错误的结果。如果您的代码依赖于将字符串作为断言的结果，它注定会失败。然而，从PHP
    8的输出中可以看出，作为表达式的断言在PHP 8中与PHP 7中的工作方式相同。
- en: Tip
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Best practice: Do not use `assert()` in production code. If you do use `assert()`,
    always provide an expression, not a string.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践：不要在生产代码中使用`assert()`。如果您使用`assert()`，请始终提供一个表达式，而不是一个字符串。
- en: Now that you have an idea of changes to security-related functions, we bring
    this chapter to a close.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了与安全相关函数的更改，我们结束本章。
- en: Summary
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about differences in string handling between PHP
    8 and earlier versions, and how to develop workarounds that address differences
    in string handling. As you learned, PHP 8 exerts greater control over the data
    types of string function arguments, as well as introducing consistency in what
    happens if an argument is missing or null. As you learned, a big problem with
    earlier versions of PHP is that several assumptions were silently made on your
    behalf, resulting in a huge potential for unexpected results.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了PHP 8和早期版本之间字符串处理的差异，以及如何开发解决字符串处理差异的解决方法。正如您所了解的，PHP 8对字符串函数参数的数据类型施加了更大的控制，并且在参数缺失或为空时引入了一致性。正如您所了解的，早期版本的PHP存在一个大问题，即在您的代表下悄悄地做出了几个假设，导致了意想不到的结果的巨大潜力。
- en: In this chapter, we also highlighted issues involving comparisons between numeric
    strings and numeric data. You learned not only about numeric strings, type-juggling,
    and non-strict comparisons, but also how PHP 8 corrects flaws inherent in numeric
    string handling that were present in earlier versions. Another topic covered in
    this chapter demonstrated potential issues having to do with how several operators
    behave differently in PHP 8\. You learned how to spot potential problems and were
    given best practices to improve the resilience of your code.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还强调了涉及数字字符串和数字数据之间比较的问题。您不仅了解了数字字符串、类型转换和非严格比较，还了解了PHP 8如何纠正早期版本中存在的数字字符串处理中的缺陷。本章还涵盖了关于PHP
    8中几个运算符行为不同的潜在问题。您学会了如何发现潜在问题，并获得了改进代码弹性的最佳实践。
- en: This chapter also addressed how a number of PHP functions retained dependence
    upon the locale setting, and how this problem has been addressed in PHP 8\. You
    learned that in PHP 8, floating-point representations are now uniform and no longer
    dependent upon the locale. You also learned about changes in how PHP 8 addresses
    array elements as well as changes in several security-related functions.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还解决了许多PHP函数保留对区域设置的依赖性的问题，以及在PHP 8中如何解决了这个问题。您了解到，在PHP 8中，浮点表示现在是统一的，不再依赖于区域设置。您还了解了PHP
    8如何处理数组元素以及几个与安全相关的函数的更改。
- en: The tips, tricks, and techniques covered in this chapter raise awareness of
    inconsistent behavior in earlier versions of PHP. With this new awareness, you
    are in a better position to gain greater control over the use of PHP code. You
    are also now in a better position to detect situations that could lead to potential
    code breaks following a PHP 8 migration, giving you an advantage over other developers,
    and ultimately leading you to write PHP code that performs reliably and consistently.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的技巧和技术提高了对早期版本PHP中不一致行为的认识。有了这种新的认识，您将更好地控制PHP代码的使用。您现在也更有能力检测可能导致在PHP 8迁移后出现潜在代码中断的情况，这使您比其他开发人员更具优势，并最终使您编写的PHP代码能够可靠且一致地运行。
- en: The next chapter shows you how to avoid potential code breaks involving changes
    to PHP extensions.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将向您展示如何避免涉及对PHP扩展进行更改的潜在代码中断。
