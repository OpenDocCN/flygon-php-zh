- en: Chapter 10. Extract Presentation Logic to View Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。将演示逻辑提取到视图文件中
- en: When it comes to page scripts in legacy applications, it is very common to see
    business logic intertwined with presentation logic. For example, the page script
    does some setup work, then includes a header template, makes a call to the database,
    outputs the results, calculates some values, prints the calculated values, writes
    the values back to the database, and includes a footer template.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统应用程序中的页面脚本方面，很常见看到业务逻辑与演示逻辑交织在一起。例如，页面脚本做一些设置工作，然后包含一个头部模板，调用数据库，输出结果，计算一些值，打印计算出的值，将值写回数据库，并包含一个页脚模板。
- en: We have made some steps toward decoupling these concerns by extracting a domain
    layer for our legacy application. However, calls to the domain layer and other
    business logic within the page scripts are still mixed in with the presentation
    logic. Among other things, this intermingling of concerns makes it difficult to
    test the different aspects of our legacy application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经采取了一些步骤，通过提取传统应用程序的域层，来解耦这些关注点。然而，在页面脚本中对域层的调用和其他业务逻辑仍然与演示逻辑混合在一起。除其他外，这种关注点的交织使得难以测试我们传统应用程序的不同方面。
- en: In this chapter, we will separate all of our presentation logic to its own layer
    so we can test it separately from our business logic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将把所有的演示逻辑分离到自己的层中，这样我们就可以单独测试它，而不受业务逻辑的影响。
- en: Embedded presentation logic
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式演示逻辑
- en: For an example of embedded presentation logic, we can take a look at [Appendix
    E](ape.xhtml "Appendix E. Code before Collecting Presentation Logic"), *Code before
    Collecting*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为嵌入式演示逻辑的示例，我们可以看一下[附录E](ape.xhtml "附录E.收集演示逻辑之前的代码")*收集演示逻辑之前的代码*。
- en: Presentation Logic. The code shows a page script that has been refactored to
    use domain *Transactions*, but it still has some presentation logic entangled
    within the rest of the code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 演示逻辑。该代码显示了一个已经重构为使用域*Transactions*的页面脚本，但仍然在其余代码中存在一些演示逻辑。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**What Is The Difference Between Presentation and Business Logic?**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**演示逻辑和业务逻辑之间有什么区别？**'
- en: For our purposes, presentation logic includes any and all code that generates
    output sent to the user (such as a browser or mobile client). This includes not
    only `echo` and `print` but also `header()` and `setcookie()`. Each of these generates
    some form of output. "Business logic," on the other hand, is everything else.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，演示逻辑包括生成发送给用户（如浏览器或移动客户端）的任何和所有代码。这不仅包括`echo`和`print`，还包括`header()`和`setcookie()`。每个都会生成某种形式的输出。另一方面，“业务逻辑”是其他所有内容。
- en: The key to decoupling the presentation logic from the business logic is to put
    the code for them into separate scopes. The script should first perform all of
    the business logic, then pass the results over to the presentation logic. When
    that is complete, we will be able to test our presentation logic separately from
    our business logic.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将演示逻辑与业务逻辑解耦的关键是将它们的代码放入单独的范围中。脚本应首先执行所有业务逻辑，然后将结果传递给演示逻辑。完成后，我们将能够单独测试我们的演示逻辑，而不受业务逻辑的影响。
- en: To achieve this separation of scope, we will move toward using a `Response`
    object in our page scripts. All of our presentation logic will be executed from
    within a `Response` instance, instead of directly in the page script. Doing so
    will provide the scope separation that we need to decouple all output generation,
    including HTTP headers and cookies, from the rest of the page script.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种范围的分离，我们将朝着在我们的页面脚本中使用`Response`对象的方向发展。我们所有的演示逻辑将在`Response`实例内执行，而不是直接在页面脚本中执行。这样做将为我们提供我们需要的范围分离，包括HTTP头和cookie在内的所有输出生成，与页面脚本的其余部分分离开来。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Why A Response Object?**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么使用Response对象？**'
- en: Often, when we think of presentation, we think of a view or a template system
    that renders content for us. However, these kinds of systems do not usually encapsulate
    the full set of output that will be sent to the user. We need to output not just
    HTTP bodies, but HTTP headers as well. In addition, we need to be able to test
    that the correct headers have been set, and that the content has been generated
    properly. As such, the `Response` object is a better fit at this point than a
    view or template system alone. For our `Response` object, we will use the class
    provided at [http://mlaphp.com/code](http://mlaphp.com/code). Note that we will
    be including files within a *Response* context, which means that the methods on
    that object will be available to `include` files running "inside" that object.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们想到演示时，我们会想到一个视图或模板系统，为我们呈现内容。然而，这些类型的系统通常不会封装将发送给用户的完整输出集。我们不仅需要输出HTTP主体，还需要输出HTTP头。此外，我们需要能够测试是否设置了正确的头部，并且内容已经生成正确。因此，在这一点上，`Response`对象比单独的视图或模板系统更合适。对于我们的`Response`对象，我们将使用[http://mlaphp.com/code](http://mlaphp.com/code)提供的类。请注意，我们将在*Response*上下文中包含文件，这意味着该对象上的方法将对在该对象“内部”运行的`include`文件可用。
- en: The Extraction process
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取过程
- en: Extracting presentation logic is not as difficult as extracting domain logic.
    However, it does require careful attention and lots of testing along the way.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 提取演示逻辑并不像提取域逻辑那么困难。然而，它需要仔细的注意和大量的测试。
- en: 'In general, the process is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，流程如下：
- en: Find a page script that contains presentation logic mixed in with the rest of
    the code.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个包含演示逻辑混合在其余代码中的页面脚本。
- en: In that script, rearrange the code to collect all presentation logic into a
    single block *after* all the other logic in the file, then spot check the rearranged
    code.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个脚本中，重新排列代码，将所有演示逻辑收集到文件中所有其他逻辑之后的一个单独的块中，然后对重新排列的代码进行抽查。
- en: Extract the block of presentation logic to a view file to be delivered via a
    `Response`, and spot check the script again to make sure the script works correctly
    with the new `Response`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将演示逻辑块提取到视图文件中，通过`Response`进行交付，并再次对脚本进行抽查，以确保脚本能够正确地与新的`Response`一起工作。
- en: Add proper escaping to the presentation logic and spot check again.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对演示逻辑进行适当的转义并再次进行抽查。
- en: Commit the new code, push to the common repository, and notify QA.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交新代码，推送到公共存储库，并通知QA。
- en: Begin again with the next page script that contains presentation logic mixed
    in with other non-presentation code.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新开始包含演示逻辑混合在其他非演示代码中的下一个页面脚本。
- en: Search for Embedded presentation logic
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索嵌入式演示逻辑
- en: In general, it should be easy for us to find presentation logic in our legacy
    application. At this point we should be familiar enough with the codebase to have
    a good idea where the page scripts generate output.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们应该很容易找到我们遗留应用程序中的演示逻辑。在这一点上，我们应该对代码库足够熟悉，以便大致知道页面脚本生成的输出在哪里。
- en: If we need a jump-start, we can use our project-wide search facility to find
    all occurrences of `echo`, `print`, `printf`, `header`, `setcookie`, and `setrawcookie`.
    Some of these may occur in class methods; we will address that at a later point.
    For now, we will concentrate on page scripts where these calls occur.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要一个快速启动，我们可以使用项目范围的搜索功能来查找所有`echo`、`print`、`printf`、`header`、`setcookie`和`setrawcookie`的出现。其中一些可能出现在类方法中；我们将在以后解决这个问题。现在，我们将集中精力在页面脚本上，这些调用发生在这些调用发生的地方。
- en: Rearrange the Page script and Spot Check
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新排列页面脚本并进行抽查
- en: Now that we have a candidate page script, we need to rearrange the code so there
    is a clear demarcation between the presentation logic and everything else. For
    our example here, we will use the code in [Appendix E](ape.xhtml "Appendix E. Code
    before Collecting Presentation Logic"), *Code before Collecting*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个候选的页面脚本，我们需要重新排列代码，以便演示逻辑和其他所有内容之间有一个清晰的分界线。在这个例子中，我们将使用[附录E](ape.xhtml
    "附录 E. 收集演示逻辑之前的代码")中的代码，*收集之前的代码*。
- en: First, we go to the bottom of the file and add a `/* PRESENTATION */` comment
    as the final line. We then go back to the top of the file. Working line-by-line
    and block-by-block, we move all presentation logic to the end of the file after
    our `/* PRESENTATION */` comment. When we are done, the part before the `/* PRESENTATION
    */` comment should consist only of business logic, and the part after should consist
    only of presentation logic.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们转到文件底部，并在最后一行添加一个`/* PRESENTATION */`注释。然后我们回到文件顶部。逐行和逐块地工作，将所有演示逻辑移动到文件末尾，在我们的`/*
    PRESENTATION */`注释之后。完成后，`/* PRESENTATION */`注释之前的部分应该只包含业务逻辑，之后的部分应该只包含演示逻辑。
- en: 'Given our starting code in [Appendix E](ape.xhtml "Appendix E. Code before
    Collecting Presentation Logic"), *Code before Collecting*, we should end up with
    something more like the code in [Appendix F](apf.xhtml "Appendix F. Code after
    Collecting Presentation Logic"), *Code after Collecting*. In particular, note
    that we have the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们在[附录E](ape.xhtml "附录 E. 收集演示逻辑之前的代码")中的起始代码，*收集之前的代码*，我们应该最终得到类似[附录F](apf.xhtml
    "附录 F. 收集演示逻辑之后的代码")中的代码，*收集之后的代码*。特别要注意的是，我们有以下内容：
- en: Moved variables not used by the business logic, such as `$current_page`, down
    the presentation block
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将业务逻辑未使用的变量，如`$current_page`，移到演示块下
- en: Moved the `header.php` include down to the presentation block
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`header.php`包含移到演示块下
- en: Moved logic and conditions acting only on presentation variables, such as the
    `if` that sets the `$page_title`, to the presentation block
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将仅对演示变量起作用的逻辑和条件，如设置`$page_title`的`if`，移到演示块中
- en: Replaced `$_SERVER['PHP_SELF']` with an `$action` variable
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用一个`$action`变量替换`$_SERVER['PHP_SELF']`
- en: Replaced `$_GET['id']` with an `$id` variable
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用一个`$id`变量替换`$_GET['id']`
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When creating the presentation block, we should be careful to follow all the
    lessons we learned from earlier chapters about dependency injection. Even though
    the presentation code is a block within a file (not a class) we should treat the
    block as if it is a class method. Among other things, this means no use of globals,
    superglobals, or the `new` keyword. This will make things easier on us when we
    extract the presentation block to a view file later.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建演示块时，我们应该小心遵循我们从早期章节中学到的所有课程。即使演示代码是文件中的一个块（而不是一个类），我们也应该将该块视为类方法。除其他事项外，这意味着不使用全局变量、超全局变量或`new`关键字。这将使我们在以后将演示块提取到视图文件时更容易。
- en: Now that we have rearranged the page script so that all presentation logic is
    collected at the end, we need to spot check to make sure the page script still
    works properly. As usual, we do this by running our pre-existing characterization
    tests, if we have any. If not, we must browse to or otherwise invoke the changed
    code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经重新排列了页面脚本，使得所有演示逻辑都集中在最后，我们需要进行抽查，以确保页面脚本仍然正常工作。通常情况下，我们通过运行我们预先存在的特性测试来做到这一点。如果没有，我们必须浏览或以其他方式调用已更改的代码。
- en: If the page does not generate the same output as before, our rearrangement has
    changed the logic somehow. We need to undo and redo the rearrangement until the
    page works as it should.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果页面生成的输出与以前不同，我们的重新排列在某种程度上改变了逻辑。我们需要撤消并重新进行重新排列，直到页面按照应该的方式工作。
- en: Once our spot check is successful, we may wish to commit our changes so far.
    If our next set of changes goes badly, we can revert the code to this point as
    a known working state.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的抽查成功，我们可能希望提交到目前为止的更改。如果我们接下来的一系列更改出现问题，我们可以将代码恢复到这一点作为已知的工作状态。
- en: Extract Presentation to View file and Spot Check
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取演示到视图文件并进行抽查
- en: Now that we have a working page script with all the presentation logic in a
    single block, we will extract that entire block to its own file, and then use
    a `Response` to execute the extracted logic.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个带有所有演示逻辑的工作页面脚本，我们将把整个块提取到自己的文件中，然后使用`Response`来执行提取的逻辑。
- en: Create a views/ Directory
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个views/目录
- en: 'First, we need a place to put view files in our legacy application. While I
    prefer to keep presentation logic near the business logic, that kind of arrangement
    will make trouble for us in later modernization steps. As such, we will create
    a new directory in our legacy application called `views/` and place our view files
    there. This directory should be at the same level as our `classes/` and `tests/`
    directories. For example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个地方来放置我们传统应用程序中的视图文件。虽然我更喜欢将呈现逻辑保持在业务逻辑附近，但这种安排将给我们在以后的现代化步骤中带来麻烦。因此，我们将在我们的传统应用程序中创建一个名为`views/`的新目录，并将我们的视图文件放在那里。该目录应该与我们的`classes/`和`tests/`目录处于同一级别。例如：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Pick a View File name
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择一个视图文件名称
- en: Now that we have a place to save our view files, we need to pick a file name
    for the presentation logic we are about to extract. The view file should be named
    for the page script, in a path under `views/` that matches the page script path.
    For example, if we are extracting presentation from a page script at `/foo/bar/baz.php`,
    the target view file should be saved at `/views/foo/bar/baz.php`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个保存视图文件的地方，我们需要为即将提取的呈现逻辑选择一个文件名。视图文件应该以页面脚本命名，在`views/`下的路径应与页面脚本路径匹配。例如，如果我们从`/foo/bar/baz.php`页面脚本中提取呈现，目标视图文件应保存在`/views/foo/bar/baz.php`。
- en: Sometimes it is useful to use an extension other than just `.php` for our view
    files. I have found it can be helpful to use an extension that indicates the view
    format. For example, a view that generates HTML may end in `.html.php`, while
    a view that generates JSON may end in `.json.php`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，除了`.php`之外，使用其他扩展名对于我们的视图文件也是有用的。我发现使用一个指示视图格式的扩展名可能会有所帮助。例如，生成HTML的视图可能以`.html.php`结尾，而生成JSON的视图可能以`.json.php`结尾。
- en: Move Presentation Block to View file
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将呈现块移动到视图文件中
- en: Next, we cut the presentation block from the page script, and paste it into
    our new view file as-is.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从页面脚本中剪切呈现块，并将其原样粘贴到我们的新视图文件中。
- en: Then, in place of the original presentation block in the page script, we create
    a `Response` object in our page script and point it to our view file with `setView()`.
    We also set up an empty call to `setVars()` for later, and finally call the `send()`
    method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在页面脚本中原始的呈现块的位置，我们在新的视图文件中创建一个`Response`对象，并用`setView()`指向我们的视图文件。我们还为以后设置了一个空的`setVars()`调用，最后调用了`send()`方法。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We should *always* use the same variable name for the *Response* object in all
    of our page scripts. All the examples here will use the name `$response`. This
    is not because the name `$response` is special, but because this level of consistency
    will be very important in a later chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该*始终*在所有页面脚本中使用相同的变量名来表示*Response*对象。这里的所有示例都将使用名称`$response`。这不是因为名称`$response`很特别，而是因为这种一致性在以后的章节中将非常重要。
- en: 'For example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At this point, we have successfully decoupled the presentation logic from the
    page script. We can remove the `/* PRESENTATION */` comment. It has served its
    purpose and is no longer needed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已成功将呈现逻辑与页面脚本解耦。我们可以删除`/* PRESENTATION */`注释。它已经达到了它的目的，不再需要。
- en: However, this decoupling fundamentally breaks the presentation logic, because
    the view file depends on variables from the page script. With that in mind, we
    begin a spot check-and-modify cycle. We browse to or otherwise invoke the page
    script and discover that a particular variable is not available to the presentation.
    We add it to the `setVars()` array, and spot check again. We continue adding variables
    to the `setVars()` array until the view file has everything it needs, and our
    spot check runs become completely successful.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种解耦基本上破坏了呈现逻辑，因为视图文件依赖于页面脚本中的变量。考虑到这一点，我们开始进行抽查和修改周期。我们浏览或以其他方式调用页面脚本，并发现特定变量对于呈现不可用。我们将其添加到`setVars()`数组中，并再次进行抽查。我们继续向`setVars()`数组添加变量，直到视图文件拥有所需的一切，我们的抽查运行变得完全成功。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For this part of the process, it would be best if we set `error_reporting(E_ALL)`.
    That way we will get a PHP notice for every uninitialized variable in the presentation
    logic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程的这一部分，最好设置`error_reporting(E_ALL)`。这样我们将得到每个未初始化变量在呈现逻辑中的PHP通知。
- en: 'Given our earlier examples in [Appendix E](ape.xhtml "Appendix E. Code before
    Collecting Presentation Logic"), *Code before Collecting* and [Appendix F](apf.xhtml
    "Appendix F. Code after Collecting Presentation Logic"), *Code after Collecting*,
    we end up at [Appendix G](apg.xhtml "Appendix G. Code after Response View File"),
    *Code after Response View File*. We can see that the `articles.html.php` view
    file needed four variables: `$id, $failure`, `$input`, and `$action`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们之前在[附录E](ape.xhtml "附录E.收集呈现逻辑之前的代码")中的示例，*收集之前的代码*和[附录F](apf.xhtml "附录F.收集呈现逻辑之后的代码")中的示例，*收集之后的代码*，我们最终到达[附录G](apg.xhtml
    "附录G.响应视图文件之后的代码")，*响应视图文件之后的代码*。我们可以看到`articles.html.php`视图文件需要四个变量：`$id, $failure`,
    `$input`, 和 `$action`：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once we have a working page script, we may wish to commit our work yet again
    so that we have a known correct state to which we can revert later, if needed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个工作的页面脚本，我们可能希望再次提交我们的工作，以便以后如果需要，我们有一个已知正确的状态可以回滚。
- en: Add Proper Escaping
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加适当的转义
- en: Unfortunately, most legacy applications pay little or no attention to output
    security. One of the most common vulnerabilities is **cross-site scripting** (**XSS**).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，大多数传统应用程序很少或根本不关注输出安全性。最常见的漏洞之一是**跨站脚本**（**XSS**）。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What Is XSS?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是XSS？
- en: Cross-site scripting is an attack that is made possible by user input being
    sent back to the browser unescaped. For example, an attacker can enter maliciously-crafted
    JavaScript code into a form input or an HTTP header. If that value is then delivered
    back to the browser without being escaped, the browser will execute that JavaScript
    code. This has the potential to open the client browser to further attacks. For
    more information, please see the *OWASP entry on XSS* ([https://www.owasp.org/index.php/Cross-site_Scripting_%28XSS%29](https://www.owasp.org/index.php/Cross-site_Scripting_%28XSS%29)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站脚本攻击是一种可能是由用户输入导致的攻击。例如，攻击者可以在表单输入或HTTP标头中输入恶意构造的JavaScript代码。如果该值然后在未经逃逸的情况下传递回浏览器，浏览器将执行该JavaScript代码。这有可能使客户端浏览器暴露于进一步的攻击。有关更多信息，请参阅*OWASP关于XSS的条目*
    ([https://www.owasp.org/index.php/Cross-site_Scripting_%28XSS%29](https://www.owasp.org/index.php/Cross-site_Scripting_%28XSS%29))。
- en: The defense against XSS is to escape all variables all the time for the context
    in which they are used. If a variable is used as HTML content, it needs to be
    escaped as HTML content; if a variable is used in an HTML attribute, it needs
    to be escaped as such, and so on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 防御XSS的方法是始终为使用的上下文逃逸所有变量。如果一个变量用作HTML内容，它需要作为HTML内容进行逃逸；如果一个变量用作HTML属性，它需要逃逸为HTML属性，依此类推。
- en: Defending against XSS requires diligence on the part of the developer. If we
    remember one thing about escaping output, it should be the `htmlspecialchars()`
    function. Using this function appropriately will save us from most, but not all,
    XSS exploits.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 防御XSS需要开发人员的勤奋。如果我们记住逃逸输出的一件事，那就应该是`htmlspecialchars()`函数。适当使用此函数将使我们免受大多数XSS攻击的侵害。
- en: 'When using `htmlspecialchars()`, we must be sure to pass a quotes constant
    and a character set each time. Thus, it is not enough to call `htmlspecialchars($unescaped_text)`.
    We must call `htmlspecialchars($unescaped_text, ENT_QUOTES, ''UTF-8'')`. So, output
    that looks like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`htmlspecialchars()`时，我们必须确保每次传递引号常量和字符集。因此，仅调用`htmlspecialchars($unescaped_text)`是不够的。我们必须调用`htmlspecialchars($unescaped_text,
    ENT_QUOTES, 'UTF-8')`。因此，输出看起来像这样：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This needs to be escaped like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要像这样进行逃逸：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Any time we send unescaped output, we need to be aware that we are likely opening
    up a security hole. As such, we must apply escaping to every variable we use for
    output.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们发送未经逃逸的输出时，我们需要意识到我们很可能会打开一个安全漏洞。因此，我们必须对我们用于输出的每个变量应用逃逸。
- en: 'Calling `htmlspecialchars()` repeatedly this way can be cumbersome, so the
    `Response` class provides an `esc()` method as an alias to `htmlspecialchars()`
    with reasonable settings:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式重复调用`htmlspecialchars()`可能很麻烦，因此`Response`类提供了一个`esc()`方法，作为`htmlspecialchars()`的别名，并带有合理的设置：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Be aware that escaping via `htmlspecialchars()` is only a starting point. While
    escaping itself is simple to do, it can be difficult to know the appropriate escaping
    technique for a particular context.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过`htmlspecialchars()`进行逃逸只是一个起点。虽然逃逸本身很简单，但很难知道特定上下文的适当逃逸技术。
- en: Unfortunately, it is outside the scope of this book to provide a thorough overview
    of escaping and other security techniques. For more information, and for a good
    stand-alone escaping tool, please see the *Zend\Escaper* ([https://framework.zend.com/manual/2.2/en/modules/zend.escaper](https://framework.zend.com/manual/2.2/en/modules/zend.escaper))
    library.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，本书的范围不包括提供逃逸和其他安全技术的全面概述。有关更多信息以及一个很好的独立逃逸工具，请参阅*Zend\Escaper* ([https://framework.zend.com/manual/2.2/en/modules/zend.escaper](https://framework.zend.com/manual/2.2/en/modules/zend.escaper))
    库。
- en: After we escape all output in the `Response` view file, we can move along to
    testing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们逃逸`Response`视图文件中的所有输出之后，我们可以继续进行测试。
- en: Write View File Tests
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写视图文件测试
- en: Writing tests for view files presents some unique challenges. Until this chapter,
    all of our tests have been against classes and class methods. Because our view
    files are, well, *files*, we need to place them into a slightly different testing
    structure.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为视图文件编写测试提出了一些独特的挑战。在本章之前，我们所有的测试都是针对类和类方法的。因为我们的视图文件是*文件*，所以我们需要将它们放入稍微不同的测试结构中。
- en: The tests/views/ directory
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tests/views/目录
- en: 'First, we need to create a `views/` subdirectory in our `tests/` directory.
    After that, our `tests/` directory should look something like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的`tests/`目录中创建一个`views/`子目录。之后，我们的`tests/`目录应该看起来像这样：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we need to modify the `phpunit.xml` file so it knows to scan through
    the new `views/` subdirectory for tests:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改`phpunit.xml`文件，以便它知道要扫描新的`views/`子目录进行测试：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Writing a View File Test
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写视图文件测试
- en: Now that we have a location for our view file tests, we need to write one.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了视图文件测试的位置，我们需要编写一个。
- en: Although we are testing a file, PHPUnit requires each test to be a class. As
    a result, we will name our test for the view file being tested, and place it in
    a subdirectory under `tests/views/` that mimics the original view file location.
    For example, if we have a view file at `views/foo/bar/baz.html.php`, we would
    create a test file at `tests/views/foo/bar/BazHtmlTest.php`. Yes, this is a bit
    ugly, but it will help us keep track of which tests map to which views.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们正在测试一个文件，但是PHPUnit要求每个测试都是一个类。因此，我们将为正在测试的视图文件命名我们的测试，并将其放在`tests/views/`目录下，该目录模仿原始视图文件的位置。例如，如果我们有一个视图文件位于`views/foo/bar/baz.html.php`，我们将在`tests/views/foo/bar/`创建一个测试文件`BazHtmlTest.php`。是的，这有点丑陋，但这将帮助我们跟踪哪些测试与哪些视图相对应。
- en: In our test class, we will create a `Response` instance like the one at the
    end of our page script. We will pass into it the view file path and the needed
    variables. We will finally require the view, then check the output and headers
    to see if the view works correctly.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试类中，我们将创建一个`Response`实例，就像我们页面脚本末尾的那个一样。我们将传递视图文件路径和所需的变量。最后，我们将要求视图，然后检查输出和标头，以查看视图是否正常工作。
- en: 'Given our `articles.html.php` file, our initial test might look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的`articles.html.php`文件，我们的初始测试可能如下所示：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Why Use requireView() Instead Of send()?**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么使用requireView()而不是send()?**'
- en: If we use `send()` the `Response` will output the view file results, instead
    of leaving them in a buffer for us to inspect. Calling `requireView()` invokes
    the view file but returns the results instead of generating output.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`send()`，`Response`将输出视图文件的结果，而不是将它们留在缓冲区供我们检查。调用`requireView()`会调用视图文件，但返回结果而不是生成输出。
- en: When we run this test, it will fail. We rejoice, because the `$expect` value
    is empty, but the output should have a lot of content in it. This is the correct
    behavior. (If the test passes, something is probably wrong.)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个测试时，它会失败。我们会感到高兴，因为`$expect`的值为空，但输出应该有很多内容。这是正确的行为。（如果测试通过，可能有什么地方出错了。）
- en: Asserting Correctness Of Content
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 断言内容的正确性
- en: Now we need our test to look at the output to see if it is correct.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要我们的测试来查看输出是否正确。
- en: The simplest way to do this is to dump the actual `$this->output` string and
    copy its value to the `$expect` variable. If the output string is relatively short,
    an `assertSame($expect, $this->output)` to make sure they are identical should
    be perfectly sufficient for our purposes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是转储实际的`$this->output`字符串，并将其值复制到`$expect`变量中。如果输出字符串相对较短，使用`assertSame($expect,
    $this->output)`来确保它们是相同的应该完全足够。
- en: However, if anything changes with any of the other files that our main view
    file includes, then the test will fail. The failure will occur not because the
    main view has changed, but because a related view has changed. That is not the
    kind of failure that helps us.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们主视图文件包含的任何其他文件发生了变化，那么测试将失败。失败不是因为主视图已经改变，而是因为相关视图已经改变。这不是对我们有帮助的失败。
- en: In the case of large output strings, we can look for an expected substring and
    make sure it it is present in the actual output. Then when the test fails it will
    be related to the particular substring for which we are testing, not to the entire
    output string a a whole.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型输出字符串，我们可以查找预期的子字符串，并确保它在实际输出中存在。然后，当测试失败时，它将与我们正在测试的特定子字符串相关，而不是整个输出字符串。
- en: For example, we can use `strpos()` to see if a particular string is in the output.
    If the haystack of `$this->output` does not contain the `$expect` needle, `strpos()`
    will return a boolean `false`. Any other value means the `$needle` is present.
    (This logic is easier to read if we write our own custom assertion method.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用`strpos()`来查看特定字符串是否在输出中。如果`$this->output`的大堆中不包含`$expect`针，`strpos()`将返回布尔值`false`。任何其他值都表示`$needle`存在。（如果我们编写自己的自定义断言方法，这种逻辑更容易阅读。）
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This approach has the benefit of being very straightforward, but may not be
    suitable for complex assertions. We may wish to count the number of times an element
    occurs, or to assert that the HTML has a particular structure without referencing
    the contents of that structure, or to check that an element appears in the right
    place in the output.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处是非常直接，但可能不适用于复杂的断言。我们可能希望计算元素出现的次数，或者断言HTML具有特定的结构而不引用该结构的内容，或者检查元素是否出现在输出的正确位置。
- en: For these more-complex content assertions, PHPUnit has an `assertSelectEquals()`
    assertion, along with other related `assertSelect*()` methods. These work by using
    CSS selectors to check different parts of the output, but can be difficult to
    read and understand.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些更复杂的内容断言，PHPUnit有一个`assertSelectEquals()`断言，以及其他相关的`assertSelect*()`方法。这些方法通过使用CSS选择器来检查输出的不同部分，但可能难以阅读和理解。
- en: Alternatively, we may prefer to install `Zend\Dom\Query` for finer manipulation
    of the DOM tree. This library also works by using CSS selectors to pick apart
    the content. It returns `DOM` nodes and node lists, which makes it very useful
    for testing the content in a fine-grained manner.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可能更喜欢安装`Zend\Dom\Query`来更精细地操作DOM树。这个库也通过使用CSS选择器来拆分内容。它返回`DOM`节点和节点列表，这使得它非常适用于以细粒度的方式测试内容。
- en: Unfortunately, I cannot give concrete advice on which of these approaches is
    best for you. I suggest starting with an approach similar to the `assertOutputHas()`
    method above, and moving along to the `Zend\Dom\Query` approach when it becomes
    obvious that you need a more powerful system.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我无法就哪种方法对您最好给出具体建议。我建议从上面的`assertOutputHas()`方法类似的方法开始，当明显需要更强大的系统时，再转向`Zend\Dom\Query`方法。
- en: After we have written tests that confirm the presentation works as it should,
    we move on to the last part of the process.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写了确认演示工作正常的测试之后，我们继续进行流程的最后一部分。
- en: Commit, Push, Notify QA
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提交，推送，通知QA
- en: At this point we should have passing tests for the page script and for the extracted
    presentation logic. We now commit all our code and tests, push them to the common
    repository, and notify QA that we are ready for them to look over the new work.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该对页面脚本和提取的演示逻辑进行了测试。现在我们提交所有的代码和测试，将它们推送到公共存储库，并通知QA我们已经准备好让他们审查新的工作。
- en: Do ... While
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Do ... While
- en: We continue to search for presentation logic mixed in with business logic in
    our page scripts. When we have extracted all presentation logic to view files
    via `Response` objects, we are done.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续在页面脚本中寻找混合业务逻辑和演示逻辑。当我们通过`Response`对象将所有演示逻辑提取到视图文件中时，我们就完成了。
- en: Common Questions
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见问题
- en: What about Headers and Cookies?
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于头部和Cookies呢？
- en: In the above examples we paid attention only to output from `echo` and `print`.
    However, it is often the case that a page script will also set HTTP headers via
    `header()`, `setcookie()`, and `setrawcookie()`. These, too, generate output.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们只关注了`echo`和`print`的输出。然而，通常情况下，页面脚本还会通过`header()`、`setcookie()`和`setrawcookie()`设置HTTP头部。这些也会生成输出。
- en: Dealing with these output methods can be problematic. Whereas the `Response`
    class uses `output buffering` to capture `echo` and `print` into return values,
    there is no similar option for buffering calls to `header()` and related functions.
    Because the output from these functions is not buffered, we cannot easily test
    to see what's going on.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些输出方法可能会有问题。`Response`类使用`输出缓冲`将`echo`和`print`捕获到返回值中，但对于`header()`和相关函数的调用，没有类似的选项。因为这些函数的输出没有被缓冲，我们无法轻松地测试看到发生了什么。
- en: This is one place where having a `Response` object really helps us. The class
    comes with methods that buffer the `header()` and related native PHP functions,
    but do not call those functions until `send()` time. This allows us to capture
    the inputs to these calls and test them before they are actually activated.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`Response`对象真正帮助我们的地方。该类带有缓冲`header()`和相关本机PHP函数的方法，但直到`send()`时才调用这些函数。这使我们能够捕获这些调用的输入并在它们实际激活之前进行测试。
- en: 'For example, say we have some code like this in a contrived view file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们在一个虚构的视图文件中有这样的代码：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Among other things, we cannot test that the headers are what we expect them
    to be. PHP has already sent them to the client.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除其他事项外，我们无法测试头部是否符合预期。PHP已经将它们发送给客户端。
- en: When using a view file with a *Response* object, we can prefix the native function
    calls with `$this->` to call a *Response* method instead of the native PHP function.
    The *Response* methods buffer the arguments to the native calls instead of making
    the calls directly. This allows us to inspect the arguments before they are delivered
    as output.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用*Response*对象的视图文件时，我们可以使用`$this->`前缀来调用*Response*方法，而不是本机PHP函数。*Response*方法缓冲本机调用的参数，而不是直接进行调用。这使我们能够在它们作为输出之前检查参数。
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because the view file is being executed inside the *Response* instance, it has
    access to `$this` for the `Response` properties and methods. The `header()`, `setcookie()`,
    and `setrawcookie()` methods on the `Response` object have the exact same signatures
    as the native PHP methods, but capture the inputs into a property for later output
    instead of generating output immediately.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因为视图文件是在*Response*实例内执行的，所以它可以访问`$this`来获取`Response`属性和方法。`Response`对象上的`header()`、`setcookie()`和`setrawcookie()`方法具有与本机PHP方法完全相同的签名，但是它们将输入捕获到属性中以便稍后输出，而不是立即生成输出。
- en: We can now test the `Response` object to check the HTTP body as well as the
    HTTP headers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试`Response`对象来检查HTTP正文以及HTTP头部。
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *Response* `getHeaders()` method returns an array of sub-arrays. Each sub-array
    has an element 0 indicating the native PHP function name to be called, and the
    remaining elements are arguments to the function. These are the function calls
    that will be made at `send()` time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*Response*的`getHeaders()`方法返回一个子数组的数组。每个子数组都有一个元素0，表示要调用的本机PHP函数名称，其余元素是函数的参数。这些是将在`send()`时调用的函数调用。'
- en: What if we already have a Template system?
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果我们已经有一个模板系统呢？
- en: Many times, a legacy application will have a view or template system already
    in place. If so, it may be sufficient to keep using the existing template system
    instead of introducing a new `Response` class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，遗留应用程序已经有一个视图或模板系统。如果是这样，保持使用现有的模板系统可能就足够了，而不是引入新的`Response`类。
- en: 'If we decide to keep an existing template system, the other steps in this chapter
    still apply. We need to move all of the template calls to a single location at
    the end of the page script, disentangling all of the template interactions from
    the rest of the business logic. We can then display the template at the end of
    the page script. For example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定保留现有的模板系统，则本章的其他步骤仍然适用。我们需要将所有模板调用移动到页面脚本末尾的一个位置，将所有模板交互与其他业务逻辑分离。然后我们可以在页面脚本末尾显示模板。例如：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we are not sending HTTP headers, this approach is just as testable as using
    a `Response` object. However, if we mix in calls to `header()` and related functions,
    our testability will be more limited.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不发送HTTP头部，这种方法与使用`Response`对象一样具有可测试性。然而，如果我们混合调用`header()`和相关函数，我们的可测试性将更受限制。
- en: 'In the interest of future-proofing our legacy code, we may move the template
    logic to a view file, and interact with a `Response` object in our page script
    instead. For example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了未来保护我们的遗留代码，我们可以将模板逻辑移到视图文件中，并在页面脚本中与`Response`对象交互。例如：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This allows us to keep using the existing template logic and files, while adding
    testability for HTTP headers via the `Response` object.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够继续使用现有的模板逻辑和文件，同时通过`Response`对象为HTTP头部添加可测试性。
- en: For consistency's sake, we should either use the existing template system or
    wrap all template logic in view files via `Response` objects. We should not use
    the template system in some page scripts and the `Response` object in others.
    In later chapters, it will be important that we have a single way of interacting
    with the presentation layer in our page scripts.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致，我们应该使用现有的模板系统或者通过`Response`对象在视图文件中包装所有模板逻辑。我们不应该在一些页面脚本中使用模板系统，在其他页面脚本中使用`Response`对象。在后面的章节中，我们在页面脚本中与呈现层交互的方式将变得很重要。
- en: What about Streaming Content?
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流式内容怎么办？
- en: Most of the time, our presentation is small enough that it can be buffered into
    memory by PHP until it is ready to send. However, sometimes our legacy application
    may need to send large amounts of data, such as a file that is tens or hundreds
    of megabytes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们的呈现内容足够小，可以由PHP缓冲到内存中，直到准备发送。然而，有时我们的遗留应用程序可能需要发送大量数据，比如几十或几百兆字节的文件。
- en: 'Reading a large file into memory so that we can output it to the user is usually
    not a good approach. Instead, we stream the file: we read a small piece of the
    file and send it to the user, then read the next small piece and send it to the
    user, and so on until the whole file has been delivered. That way, we never have
    to keep the entire file in memory.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将大文件读入内存，以便我们可以将其输出给用户通常不是一个好的方法。相反，我们流式传输文件：我们读取文件的一小部分并将其发送给用户，然后读取下一小部分并将其发送给用户，依此类推，直到整个文件被传送。这样，我们就不必将整个文件保存在内存中。
- en: The examples so far have only dealt with buffering a view into memory and then
    outputting it all at once, not with streaming. It would be a poor approach for
    our view file to read the entire resource into memory and then output it. At the
    same time, we need to make sure headers are delivered before any streamed content.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，示例只处理了将视图缓冲到内存中，然后一次性输出，而不是流式传输。对于视图文件来说，将整个资源读入内存然后输出是一个不好的方法。与此同时，我们需要确保在任何流式内容之前传送标头。
- en: The `Response` object has a method to handle this situation. The `Response`
    method `setLastCall()` allows us to set a user-defined function (a callable) to
    invoke after requiring the view file and sending the headers. With this, we can
    pass a class method that will stream the resource out for us.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response`对象有一个处理这种情况的方法。`Response`方法`setLastCall()`允许我们设置一个用户定义的函数（可调用的），以在需要视图文件并发送标头后调用。有了这个，我们可以传递一个类方法来为我们流式传输资源。'
- en: 'For example, say we need to stream out a large image file. We can write a class
    like the following to handle the stream logic:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们需要流式传输一个大图像文件。我们可以编写一个类来处理流逻辑，如下所示：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There is much to be desired here, such as error checking and better resource
    handling, but it accomplishes the purpose for our example.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有很多需要改进的地方，比如错误检查和更好的资源处理，但它完成了我们示例的目的。
- en: 'We can then create an instance of the *FileStreamer* in our page script, and
    the view file can use it as the callable argument for `setLastCall()`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在页面脚本中创建一个*FileStreamer*的实例，视图文件可以将其用作`setLastCall()`的可调用参数：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At `send()` time, the `Response` will require the view file, which sets a header
    and the last call with arguments. The `Response` then sends the headers and the
    captured output of the view (which in this case is nothing). Finally, it invokes
    the callable and arguments from `setLastCall()`, which streams out the file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在`send()`时，`Response`将需要视图文件，设置一个标头和最后一个调用的参数。然后，`Response`发送标头和视图的捕获输出（在这种情况下是空的）。最后，它调用`setLastCall()`中的可调用和参数，流式传输文件。
- en: What if we have lots of Presentation variables?
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果我们有很多演示变量怎么办？
- en: In the example code from this chapter, we had only a handful of variables to
    pass to the presentation logic. Unfortunately, it is more likely that there will
    be 10 or 20 or more variables to pass. This is usually because the presentation
    is composed of several `include` files, each of which needs its own variables.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例代码中，我们只有少数变量需要传递给演示逻辑。不幸的是，更有可能的情况是需要传递10个、20个或更多的变量。这通常是因为演示由几个`include`文件组成，每个文件都需要自己的变量。
- en: These extra variables are usually needed for things like the site header, navigation,
    and footer portions. Because we have decoupled the business logic from the presentation
    logic and are executing the presentation logic in a separate scope, we have to
    pass in all the variables needed for all the `include` files.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的变量通常用于诸如站点标题、导航和页脚部分之类的内容。因为我们已经将业务逻辑与演示逻辑解耦，并在一个单独的范围内执行演示逻辑，所以我们必须传递所有`include`文件所需的变量。
- en: 'Say we have a view file that includes a `header.php` file, like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说我们有一个视图文件，其中包括一个`header.php`文件，就像这样：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our page script will have to pass `$page_title`, `$page_style`, and `$site_nav`
    variables in order for the header to display properly. This is a relatively tame
    case; there could be many more variables than this.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的页面脚本将不得不传递`$page_title`、`$page_style`和`$site_nav`变量，以便页眉正确显示。这是一个相对温和的情况；可能会有更多的变量。
- en: One solution is to collect commonly-used variables into one or more objects
    of their own. We can then pass those common-use objects into the `_Response_`
    for the view file to use. For example, header-specific display variables can be
    placed in a `HeaderDisplay` class, which can then be passed to the `_Response_`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是将常用变量收集到一个或多个自己的对象中。然后我们可以将这些常用对象传递给`Response`供视图文件使用。例如，特定于页眉的显示变量可以放在`HeaderDisplay`类中，然后传递给`Response`。
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can then modify the `header.php` file to use the *HeaderDisplay* object,
    and the page script can pass an instance of *HeaderDisplay* instead of all the
    separate header-related variables.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以修改`header.php`文件以使用*HeaderDisplay*对象，页面脚本可以传递*HeaderDisplay*的实例，而不是所有单独的与页眉相关的变量。
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Once we begin collecting related variables into classes, we will begin to see
    how we can collect presentation logic into methods on those classes, and thereby
    reduce the amount of logic in our view files. For example, it should not be hard
    for us to imagine a `getNav()` method on the *HeaderDisplay* class that returns
    the proper HTML for our navigation widgets.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始将相关变量收集到类中，我们将开始看到如何将演示逻辑收集到这些类的方法中，从而减少视图文件中的逻辑量。例如，我们应该很容易想象在*HeaderDisplay*类上有一个`getNav()`方法，它返回我们导航小部件的正确HTML。
- en: What about class methods that generate output?
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 那么生成输出的类方法怎么办？
- en: In the example code for this chapter, we concentrated on presentation logic
    in page scripts. However, it may be the case that domain classes or other support
    classes use `echo` or `header()` to generate output. Because output generation
    must be restricted to the presentation layer, we need to find a way to remove
    these calls without breaking our legacy application. Even classes that are intended
    for presentation purposes should not generate output on their own.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例代码中，我们集中在页面脚本中的呈现逻辑。然而，可能情况是，领域类或其他支持类使用`echo`或`header()`来生成输出。因为输出生成必须限制在呈现层，我们需要找到一种方法来移除这些调用，而不破坏我们的遗留应用程序。即使是用于呈现目的的类也不应该自行生成输出。
- en: The solution here is to convert each use of `echo`, `print`, and so on to a
    `return`. We can then either output the result immediately, or capture the result
    into a variable and output it later.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的解决方案是将每个`echo`、`print`等的使用转换为`return`。然后我们可以立即输出结果，或者将结果捕获到一个变量中，稍后再输出。
- en: 'For example, say we have a class method that looks like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个类方法看起来像这样：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can convert it to something like this instead (and remember to add escaping!):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其转换为类似于这样的东西（并记得添加转义！）：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What about Business Logic Mixed into the presentation?
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务逻辑混入呈现逻辑怎么办？
- en: When rearranging the page script to separate the business logic from the presentation
    logic, we may discover that the presentation code makes calls to *Transactions*
    or other classes or resources. This is a pernicious form of mixing concerns, since
    the presentation is dependent on the results of these calls.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当重新排列页面脚本以将业务逻辑与呈现逻辑分开时，我们可能会发现呈现代码调用*Transactions*或其他类或资源。这是一种混合关注点的恶劣形式，因为呈现依赖于这些调用的结果。
- en: If the called code is specifically for output, then there's no problem; we can
    leave the calls in place. But if the called code interacts with an external resource
    such as a database or a network connection, we have a mixing of concerns that
    needs to be separated.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果被调用的代码专门用于输出，那么就没有问题；我们可以保留调用。但是，如果被调用的代码与数据库或网络连接等外部资源进行交互，那么我们就需要分离关注点。
- en: The solution is to extract an equivalent set of business logic calls from the
    presentation logic, capture the results to a variable, and then pass that variable
    to the presentation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是从呈现逻辑中提取出一组等效的业务逻辑调用，将结果捕获到一个变量中，然后将该变量传递给呈现。
- en: 'For a contrived example, the following mixed code makes database calls and
    then presents them in a single loop:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 举个假设的例子，以下混合代码进行数据库调用，然后在一个循环中呈现它们：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Ignore for a moment that we need to solve the N+1 query problem presented in
    the example, and that this might better be solved at the *Transactions* level.
    How can we disentangle the presentation from the data retrieval?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时忽略我们需要解决示例中提出的N+1查询问题，以及这可能更好地在*Transactions*级别解决。我们如何将呈现与数据检索分离？
- en: 'In this case, we build an equivalent set of code to capture the needed data,
    then pass that data to the presentation logic, and apply proper escaping:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们构建了一组等效的代码来捕获所需的数据，然后将该数据传递给呈现逻辑，并应用适当的转义。
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Yes, we end up looping over the same data twice -- once in the business logic,
    and once in the presentation logic. While this may reasonably be called inefficient
    in some ways, efficiency is not our primary goal. Separation of concerns is our
    primary goal, and this approach achieves that nicely.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们最终会两次循环相同的数据——一次在业务逻辑中，一次在呈现逻辑中。虽然从某些方面来说，这可能被称为低效，但效率不是我们的主要目标。关注点的分离是我们的主要目标，这种方法很好地实现了这一点。
- en: What if a page contains only presentation logic?
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果一个页面只包含呈现逻辑呢？
- en: Some of the pages in our legacy application may consist mostly or entirely of
    presentation code. In these cases, it may seem like we don't need a *Response*
    object.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遗留应用程序中的一些页面可能主要或完全由呈现代码组成。在这些情况下，似乎我们不需要*Response*对象。
- en: However, even these page scripts should be converted to use a *Response* and
    a view file. A later step in our modernization process is going to require a consistent
    interface to the results of our page scripts, and our *Response* object is the
    way to ensure that consistency.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使这些页面脚本也应该转换为使用*Response*和视图文件。我们现代化过程中的后续步骤将需要一个一致的接口来处理我们的页面脚本的结果，我们的*Response*对象是确保这种一致性的方法。
- en: Review and next steps
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查和下一步
- en: We have now gone through all of our page scripts and extracted the presentation
    logic to a series of separate files. The presentation code is now executed in
    a scope completely independent from the page script. This makes it very easy for
    us to see the remaining logic of the script, as well as test the presentation
    logic independently.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经浏览了所有的页面脚本，并将呈现逻辑提取到一系列单独的文件中。呈现代码现在在一个完全独立于页面脚本的范围内执行。这使我们非常容易看到脚本的剩余逻辑，并独立测试呈现逻辑。
- en: With the presentation logic extracted to its own layer, our page scripts are
    dwindling in size. All that remains in them is some setup work and the action
    logic needed to prepare a response.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将呈现逻辑提取到自己的层中后，我们的页面脚本正在减小。它们中所剩的只是一些设置工作和准备响应所需的操作逻辑。
- en: Our next step, then, is to extract the remaining action logic from our page
    scripts to a series of controller classes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们的下一步是将页面脚本中剩余的操作逻辑提取到一系列控制器类中。
