- en: Chapter 10. Looking at Advanced Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。查看高级算法
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Using getters and setters
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用getter和setter
- en: Implementing a linked list
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现链表
- en: Building a bubble sort
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建冒泡排序
- en: Implementing a stack
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现堆栈
- en: Building a binary search class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建二分搜索类
- en: Implementing a search engine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现搜索引擎
- en: Displaying a multi-dimensional array and accumulating totals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示多维数组并累积总数
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we cover recipes that implement various advanced algorithms
    such as linked list, bubble sort, stacks, and binary search. In addition, we cover
    getters and setters, as well as implementing a search engine and displaying values
    from a multi-dimensional array with accumulated totals.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了实现各种高级算法的配方，例如链表、冒泡排序、堆栈和二分搜索。此外，我们还涵盖了getter和setter，以及实现搜索引擎和显示来自多维数组的值并累积总数。
- en: Using getters and setters
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用getter和setter
- en: At first glance, it would seemingly make sense to define classes with `public`
    properties, which can then be directly read or written. It is considered a best
    practice, however, to make properties `protected`, and to then define a **getter**
    and **setter** for each. As the name implies, a *getter* retrieves the value of
    a property. A *setter* is used to set the value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，似乎定义具有`public`属性的类，然后可以直接读取或写入这些属性是有意义的。然而，最佳做法是将属性定义为`protected`，然后为每个属性定义**getter**和**setter**。顾名思义，*getter*用于检索属性的值。*setter*用于设置值。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Define properties as `protected` to prevent accidental *outside* access. Use
    `public` get* and set* methods to provide access to these properties. In this
    manner, not only can you more precisely control access, but you can also make
    formatting and data type changes to the properties while getting and setting them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将属性定义为`protected`以防止意外*外部*访问。使用`public` get*和set*方法来访问这些属性。通过这种方式，不仅可以更精确地控制访问，还可以在获取和设置它们时进行格式和数据类型的更改。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Getters and setters provide additional flexibility when getting or setting values.
    You are able to add an additional layer of logic if needed, something which would
    not be possible if you were to directly read or write a public property. All you
    need to do is to create a public method with a prefix of either `get` or `set`.
    The name of the property becomes the suffix. It is a convention to make the first
    letter of the variable uppercase. Thus, if the property is `$testValue`, the getter
    would be `getTestValue()`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Getter和setter在获取或设置值时提供了额外的灵活性。如果需要，您可以添加额外的逻辑层，这是直接读取或写入公共属性时无法实现的。您只需要创建一个以`get`或`set`为前缀的公共方法。属性的名称成为后缀。约定是将变量的第一个字母大写。因此，如果属性是`$testValue`，getter将是`getTestValue()`。
- en: 'In this example, we define a class with a protected property, `$date`. Notice
    that the `get` and `set` methods allow for treatment as either a `DateTime` object
    or as a string. The value is actually stored in any event as a `DateTime` instance:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此示例中，我们定义了一个具有受保护属性`$date`的类。请注意，`get`和`set`方法允许将其视为`DateTime`对象或字符串。无论如何，该值实际上都存储为`DateTime`实例。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Getters and setters allow you to filter or sanitize the data coming in or going
    out. In the following example, there are two properties, `$intVal` and `$arrVal`,
    which are set to a default initial value of `NULL`. Notice that not only are the
    return values for the getters data-typed, but they also provide defaults. The
    setters also either enforce the incoming data-type, or type-cast the incoming
    value to a certain data-type:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Getter和setter允许您过滤或清理传入或传出的数据。在下面的示例中，有两个属性`$intVal`和`$arrVal`，它们被设置为默认初始值`NULL`。请注意，getter的返回值不仅是数据类型化的，而且还提供了默认值。setter也要么强制执行传入的数据类型，要么将传入的值强制转换为特定的数据类型：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you have a class with lots and lots of properties, it might become tedious
    to define a distinct getter and setter for each property. In this case, you can
    define a kind of *fallback* using the magic method `__call()`. The following class
    defines nine different properties. Instead of having to define nine getters and
    nine setters, we define a single method, `__call()`, which makes a determination
    whether or not the usage is `get` or `set`. If `get`, it retrieves the key from
    an internal array. If `set`, it stores the value in the internal array.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个类有很多属性，为每个属性定义一个明确的getter和setter可能会变得乏味。在这种情况下，可以使用魔术方法`__call()`定义一种*回退*。以下类定义了九个不同的属性。我们不必定义九个getter和九个setter，而是定义一个名为`__call()`的方法，该方法确定使用是`get`还是`set`。如果是`get`，它会从内部数组中检索键。如果是`set`，它会将值存储在内部数组中。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `__call()`method is a magic method which is executed if an application makes
    a call to a non-existent method.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`__call()`方法是一个魔术方法，如果应用程序调用不存在的方法，则会执行该方法。'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Copy the code mentioned in step 1 into a new file, `chap_10_oop_using_getters_and_setters.php`.
    To test the class, add the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将步骤1中提到的代码复制到一个新文件`chap_10_oop_using_getters_and_setters.php`中。要测试该类，请添加以下内容：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the output (shown next), you can see that the `$date` property can be set
    using either a `string` or an actual `DateTime` instance. When `getDate()` is
    executed, you can return either a `string` or a `DateTime` instance, depending
    on the value of the `$asString` flag:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的输出中，您可以看到`$date`属性可以使用`string`或实际的`DateTime`实例进行设置。当执行`getDate()`时，可以根据`$asString`标志的值返回`string`或`DateTime`实例：
- en: '![How it works...](graphics/B05314_10_12.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_10_12.jpg)'
- en: 'Next, have a look at the code defined in step 2\. Copy this code into a file,
    `chap_10_oop_using_getters_and_setters_defaults.php`, and add the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，看一下步骤2中定义的代码。将此代码复制到一个名为`chap_10_oop_using_getters_and_setters_defaults.php`的文件中，并添加以下内容：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see from the following output, setting a *proper* integer value works
    as expected. A non-numeric value defaults to `0`. Interestingly, if you supply
    a Boolean `TRUE` as an argument to `setIntVal()`, it is interpolated to `1`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下输出中可以看出，设置*正确*的整数值会按预期工作。非数字值默认为`0`。有趣的是，如果您将布尔值`TRUE`作为`setIntVal()`的参数，它会被插入为`1`。
- en: 'If you call `getArrVal()` without setting a value, the default is an empty
    array. Setting an array value works as expected. However, if you supply a non-array
    value as an argument, the type hint of the array causes a `TypeError` to be thrown,
    which can be caught as shown here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在不设置值的情况下调用`getArrVal()`，默认值是一个空数组。设置数组值会按预期工作。但是，如果您将非数组值作为参数提供，数组的类型提示会导致抛出`TypeError`，可以像这样捕获：
- en: '![How it works...](graphics/B05314_10_13.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_10_13.jpg)'
- en: 'Finally, take the `LotsProps` class defined in step 3 and place it in a separate
    file, `chap_10_oop_using_getters_and_setters_magic_call.php`. Now add code to
    set values. What will happen, of course, is that the magic method `__call()` is
    invoked. After running `preg_match()`, the remainder of the non-existent property,
    after the letters `set`, will become a key in the internal array `$values`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将步骤3中定义的`LotsProps`类放在一个单独的文件`chap_10_oop_using_getters_and_setters_magic_call.php`中。现在添加代码来设置值。当然，会调用魔术方法`__call()`。运行`preg_match()`后，不存在的属性的剩余部分，在`set`字母之后，将成为内部数组`$values`中的一个键：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can then define HTML that displays the values using the corresponding `get`
    methods. These will in turn return keys from the internal array:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以定义显示值的HTML，使用相应的`get`方法。这些方法将返回内部数组的键：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the final output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终输出：
- en: '![How it works...](graphics/B05314_10_14.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_10_14.jpg)'
- en: Implementing a linked list
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现链表
- en: A linked list is where one list contains keys that point to keys in another
    list. An analogy, in database terms, would be where you have a table that contains
    data, and a separate index that points to the data. One index might produce a
    list of items by ID. Another index might yield a list according to title and so
    on. The salient feature of the linked list is that you do not have to touch the
    original list of items.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 链表是一个列表包含指向另一个列表键的列表。类似地，在数据库术语中，您可以有一个包含数据的表，以及一个指向数据的单独索引。一个索引可以按ID生成项目列表。另一个索引可能根据标题产生列表等等。链表的显着特点是您不必触及原始项目列表。
- en: 'For example, in the diagram shown next, the primary list contains ID numbers
    and the names of fruits. If you were to directly output the primary list, the
    fruit names would display in this order: **Apple**, **Grape**, **Banana**, **Orange**,
    **Cherry**. If you were to use the linked list as an index, on the other hand,
    the resulting output of fruit names would be **Apple**, **Banana**, **Cherry**,
    **Grape**, and **Orange**:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在接下来显示的图表中，主列表包含ID号码和水果的名称。如果您直接输出主列表，水果名称将按照以下顺序显示：**苹果**，**葡萄**，**香蕉**，**橙子**，**樱桃**。另一方面，如果您使用链表作为索引，结果输出的水果名称将是**苹果**，**香蕉**，**樱桃**，**葡萄**和**橙子**。
- en: '![Implementing a linked list](graphics/B05314_10_01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![实现链表](graphics/B05314_10_01.jpg)'
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'One of the primary uses of a linked list is to produce a display of items in
    a different order. One approach would be to create an iteration of key value pairs,
    where the key represents the new order, and the value contains the value of the
    key in the primary list. Such a function might look like this:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链表的主要用途之一是以不同的顺序显示项目。一种方法是创建键值对的迭代，其中键表示新顺序，值包含主列表中键的值。这样的函数可能如下所示：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We use an anonymous function to generate the new key in order to provide extra
    flexibility. You will also notice that we do a sort by key (`ksort()`) so that
    the linked list iterates in key order.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用匿名函数生成新的键，以提供额外的灵活性。您还会注意到我们按键排序(`ksort()`)，以便链表按键顺序迭代。
- en: 'All we need to do to use the linked list is to iterate through it, but produce
    results from the primary list, `$customer` in this example:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要通过链表进行迭代，但是从主列表`$customer`中产生结果：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that in no way do we touch the primary list. This allows us to generate
    multiple linked lists, each representing a different order, while retaining our
    original set of data.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，我们绝对不会触及主列表。这使我们能够生成多个链表，每个链表代表不同的顺序，同时保留我们的原始数据集。
- en: 'Another important use of a linked list is for the purposes of filtering. The
    technique is similar to that shown previously. The only difference is that we
    expand the `buildLinkedList()` function, adding a filter column and filter value:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链表的另一个重要用途是用于过滤。该技术与之前显示的类似。唯一的区别是我们扩展了`buildLinkedList()`函数，添加了一个过滤列和过滤值：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We only include items in the linked list where the value represented by `$filterCol`
    in the primary list matches `$filterVal`. The iteration logic is the same as that
    shown in step 2.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只在链表中包含与主列表中的`$filterCol`表示的值匹配的值。迭代逻辑与步骤2中显示的相同。
- en: 'Finally, another form of linked list is the *doubly* linked list. In this case,
    the list is constructed in such a manner that the iteration can occur in either
    a forward or reverse direction. In the case of PHP, we are fortunate to have an
    SPL class, `SplDoublyLinkedList`, which neatly does the trick. Here is a function
    that builds a doubly linked list:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，另一种形式的链表是*双向*链表。在这种情况下，列表构造成可以向前或向后进行迭代。在PHP的情况下，我们很幸运地拥有一个SPL类`SplDoublyLinkedList`，它可以很好地完成这项任务。以下是构建双向链表的函数：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The terminology for `SplDoublyLinkedList` can be misleading. `SplDoublyLinkedList::top()`
    actually points to the *end* of the list, whereas `SplDoublyLinkedList::bottom()`
    points to the *beginning*!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`SplDoublyLinkedList`的术语可能会产生误导。`SplDoublyLinkedList::top()`实际上指向列表的*末尾*，而`SplDoublyLinkedList::bottom()`指向*开始*！'
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Copy the code shown in the first bullet into a file, `chap_10_linked_list_include.php`.
    In order to demonstrate the use of a linked list, you will need a source of data.
    For this illustration, you can make use of the `customer.csv` file that was mentioned
    in earlier recipes. It is a CSV file with the following columns:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将第一个项目中显示的代码复制到一个文件`chap_10_linked_list_include.php`中。为了演示链表的使用，您需要一个数据源。在这个示例中，您可以使用先前配方中提到的`customer.csv`文件。它是一个CSV文件，包含以下列：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can add the following functions to the include file mentioned previously
    to generate a primary list of customers, and to display information about them.
    Note that we use the first column, id as the primary key:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将以下函数添加到先前提到的包含文件中，以生成客户的主列表，并显示有关它们的信息。请注意，我们使用第一列id作为主键：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can then define a calling program, `chap_10_linked_list_in_order.php`,
    which includes the file defined previously, and reads `customer.csv`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以定义一个调用程序`chap_10_linked_list_in_order.php`，其中包括先前定义的文件，并读取`customer.csv`：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can then define an anonymous function that will produce a key in the linked
    list. In this illustration, define a function that breaks down column 1 (name)
    into first and last names:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以定义一个将在链表中生成一个键的匿名函数。在这个示例中，定义一个将第一列（名称）分解为名和姓的函数：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can then call the function to build the linked list, and use `printCustomer()`
    to display the results:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以调用函数来构建链表，并使用`printCustomer()`来显示结果：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is how the output might appear:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出可能会出现的方式：
- en: '![How it works...](graphics/B05314_10_02.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_10_02.jpg)'
- en: 'To produce a filtered result, modify `buildLinkedList()` as discussed in step
    4\. You can then add logic that checks to see whether the value of the filter
    column matches the value in the filter:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成过滤结果，请修改`buildLinkedList()`，如步骤4中所述。然后可以添加逻辑来检查过滤列的值是否与过滤器中的值匹配：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There's more...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'PHP 7.1 introduced the use of `[ ]` as an alternative to `list()`. If you look
    at the anonymous function mentioned previously, you could rewrite this in PHP
    7.1 as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7.1引入了使用`[ ]`作为`list()`的替代方法。如果您查看先前提到的匿名函数，您可以在PHP 7.1中将其重写如下：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For more information, see [https://wiki.php.net/rfc/short_list_syntax](https://wiki.php.net/rfc/short_list_syntax).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参见[https://wiki.php.net/rfc/short_list_syntax](https://wiki.php.net/rfc/short_list_syntax)。
- en: Building a bubble sort
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建冒泡排序
- en: The classic **bubble sort** is an exercise often assigned to university students.
    Nonetheless, it's important to master this algorithm as there are many occasions
    where built-in PHP sorting functions do not apply. An example would be sorting
    a multi-dimensional array where the sort key is not the first column.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的**冒泡排序**经常分配给大学生练习。尽管如此，掌握这个算法很重要，因为有许多情况下内置的PHP排序函数不适用。一个例子是对多维数组进行排序，其中排序键不是第一列。
- en: The way the bubble sort works is to recursively iterate through the list and
    swap the current value with the next value. If you want items to be in ascending
    order, the swap occurs if the next item is less than the current item. For descending
    order, the swap occurs if the reverse is true. The sort is concluded when no more
    swaps occur.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序的工作方式是通过递归迭代列表并交换当前值和下一个值。如果要使项目按升序排列，则如果下一个项目小于当前项目，则进行交换。对于降序排序，如果相反情况为真，则进行交换。当不再发生交换时，排序结束。
- en: 'In the following diagram, after the first pass, **Grape** and **Banana** are
    swapped, as are **Orange** and **Cherry**. After the 2nd pass, **Grape** and **Cherry**
    are swapped. No more swaps occur on the last pass, and the bubble sort ends:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，第一次通过后，**Grape**和**Banana**被交换，**Orange**和**Cherry**也被交换。第二次通过后，**Grape**和**Cherry**被交换。在最后一次通过中不再发生交换，冒泡排序结束：
- en: '![Building a bubble sort](graphics/B05314_10_03.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![构建冒泡排序](graphics/B05314_10_03.jpg)'
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We do not want to actually *move* the values around in the array; that would
    be horribly expensive in terms of resource usage. Instead, we will use a **linked
    list**, discussed in the previous recipe.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不想实际*移动*数组中的值；这在资源使用方面将是非常昂贵的。相反，我们将使用在前面的配方中讨论的**链表**。
- en: First we build a linked list using the `buildLinkedList()` function discussed
    in the previous recipe.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用在前面的配方中讨论的`buildLinkedList()`函数构建一个链表。
- en: 'We then define a new function, `bubbleSort()`, which accepts the linked list
    by reference, the primary list, a sort field, and a parameter that represents
    sort order (ascending or descending):'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个新函数`bubbleSort()`，它接受引用的链表，主列表，排序字段和表示排序顺序（升序或降序）的参数：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The variables needed include one that represents the number of iterations,
    the number of swaps, and an iterator based upon the linked list:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所需的变量包括代表迭代次数的变量，交换次数的变量，以及基于链表的迭代器：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the `while()` loop, we only proceed if the iteration is still `valid`, which
    is to say still in progress. We then obtain the current key and value, and the
    next key and value. Note the extra `if()` statement to ensure the iteration is
    still valid (that is, to make sure we don''t drop off the end of the list!):'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while()`循环中，只有在迭代仍然有效时才继续进行，也就是说仍在进行中。然后我们获取当前键和值，以及下一个键和值。请注意额外的`if()`语句以确保迭代仍然有效（也就是说，确保我们不会掉出列表的末尾！）：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next we check to see whether the sort is to be ascending or descending. Depending
    on the direction, we check to see whether the next value is greater than, or less
    than, the current value. The result of the comparison is stored in `$expr`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查排序是升序还是降序。根据方向，我们检查下一个值是大于还是小于当前值。比较的结果存储在`$expr`中：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the value of `$expr` is `TRUE`, and we have valid current and next keys,
    the values are swapped in the linked list. We also increment `$swaps`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`$expr`的值为`TRUE`，并且我们有有效的当前键和下一个键，则交换链表中的值。我们还增加`$swaps`：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, if any swaps have occurred, we need to run through the iteration again,
    until there are no more swaps. Accordingly, we make a recursive call to the same
    method:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果发生了任何交换，我们需要再次运行迭代，直到没有更多的交换。因此，我们对同一个方法进行递归调用：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The *real* return value is the re-organized linked list. We also return the
    number of iterations just for reference:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*真正*的返回值是重新组织的链表。我们还返回迭代的次数，仅供参考：'
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Add the `bubbleSort()` function discussed previously to the include file created
    in the previous recipe. You can use the same logic discussed in the previous recipe
    to read the `customer.csv` file, producing a primary list:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前讨论的`bubbleSort()`函数添加到上一篇教程中创建的包含文件中。您可以使用前一篇教程中讨论的相同逻辑来读取`customer.csv`文件，生成一个主列表：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can then produce a linked list using the first column as a sort key:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用第一列作为排序键来生成一个链表：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, call the `bubbleSort()` function, providing the linked list and customer
    list as arguments. You can also provide a sort column, in this illustration column
    2, that represents the account balance, using the letter `''A''` to indicate ascending
    order. The `printCustomer()` function can be used to display output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用`bubbleSort()`函数，提供链表和客户列表作为参数。您还可以提供一个排序列，在本示例中是列2，表示账户余额，使用字母'A'表示升序。`printCustomer()`函数可用于显示输出：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is an example of the output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出的示例：
- en: '![How it works...](graphics/B05314_10_04.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_10_04.jpg)'
- en: Implementing a stack
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现堆栈
- en: A **stack** is a simple algorithm normally implemented as **Last In First Out**
    (**LIFO**). Think of a stack of books sitting on a library table. When the librarian
    goes to restore the books to their place, the topmost book is processed first,
    and so on in order, until the book at the bottom of the stack has been replaced.
    The topmost book was the last one to be placed on the stack, thus last in first
    out.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆栈**是一种简单的算法，通常实现为**后进先出**（**LIFO**）。想象一下一堆书放在图书馆的桌子上。当图书管理员去把书放回原位时，首先处理的是最顶部的书，依此类推，直到堆栈底部的书被替换。最顶部的书是最后放在堆栈上的，因此后进先出。'
- en: In programming terms, a stack is used to temporarily store information. The
    retrieval order facilitates retrieving the most recent item first.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程术语中，堆栈用于临时存储信息。检索顺序有助于首先检索最近的项目。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First we define a class, `Application\Generic\Stack`. The core logic is encapsulated
    in an SPL class, `SplStack`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个`Application\Generic\Stack`类。核心逻辑封装在SPL类`SplStack`中：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next we define a property to represent the stack, and set up an `SplStack`
    instance:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个表示堆栈的属性，并设置一个`SplStack`实例：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After that we define methods to add and remove from the stack, the classic
    `push()` and `pop()` methods:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义了从堆栈中添加和删除的方法，经典的`push()`和`pop()`方法：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also throw in an implementation of `__invoke()` that returns an instance
    of the `stack` property. This allows us to use the object in a direct function
    call:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还添加了一个`__invoke()`的实现，返回`stack`属性的实例。这允许我们在直接函数调用中使用对象：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'One possible use for a stack is to store messages. In the case of messages,
    it is usually desirable to retrieve the latest first, thus it is a perfect use
    case for a stack. Define the `Application\Generic\Stack` class as discussed in
    this recipe. Next, define a calling program that sets up autoloading and creates
    an instance of the `stack`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈的一个可能用途是存储消息。在消息的情况下，通常希望首先检索最新的消息，因此这是堆栈的一个完美用例。按照本教程中讨论的内容定义`Application\Generic\Stack`类。接下来，定义一个调用程序，设置自动加载并创建`stack`的实例：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To do something with the stack, store a series of messages. As you would most
    likely store messages at different points in your application, you can use `sleep()`
    to simulate other code running:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要对堆栈执行操作，存储一系列消息。由于您很可能会在应用程序的不同点存储消息，因此可以使用`sleep()`来模拟其他代码的运行：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, simply iterate through the stack to retrieve messages. Note that you
    can call the stack object as if it were a function, which returns the `SplStack`
    instance:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，只需遍历堆栈以检索消息。请注意，您可以调用堆栈对象，就像它是一个函数一样，它返回`SplStack`实例：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here is the expected output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是预期输出：
- en: '![How it works...](graphics/B05314_10_05.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_10_05.jpg)'
- en: Building a binary search class
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建二进制搜索类
- en: Conventional searches often proceed through the list of items in a sequential
    manner. This means that the maximum possible number of items to be searched could
    be the same as the length of the list! This is not very efficient. If you need
    to expedite a search, consider implementing a *binary* search.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 传统搜索通常按顺序遍历项目列表。这意味着要搜索的最大可能数量的项目可能与列表的长度相同！这并不是很有效。如果需要加快搜索速度，请考虑实现*二进制*搜索。
- en: 'The technique is quite simple: you find the midpoint in the list, and determine
    whether the search item is less than, equal to, or greater than the midpoint item.
    If less, you set the upper limit to the midpoint, and search only the first half
    of the list. If greater, set the lower limit to the midpoint, and search only
    the last half of the list. You would then proceed to divide the list into 1/4,
    1/8, 1/16, and so on, until the search item is found (or not).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术非常简单：找到列表中点，并确定搜索项是小于、等于还是大于中点项。如果小于，则将上限设置为中点，并仅搜索列表的前半部分。如果大于，则将下限设置为中点，并仅搜索列表的后半部分。然后继续将列表分成1/4、1/8、1/16等，直到找到搜索项（或没有找到）。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to note that although the maximum number of comparisons is considerably
    smaller than a sequential search (*log n + 1* where *n* is the number of elements
    in the list, and *log* is the binary logarithm), the list involved in the search
    must first be sorted, which of course downgrades performance.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，尽管比较的最大次数远远小于顺序搜索（*log n + 1*，其中*n*是列表中的元素数，*log*是二进制对数），但参与搜索的列表必须首先排序，这当然会降低性能。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We first construct a search class, `Application\Generic\Search`, which accepts
    the primary list as an argument. As a control, we also define a property, `$iterations`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先构建一个搜索类`Application\Generic\Search`，它接受主列表作为参数。作为控制，我们还定义一个属性`$iterations`：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next we define a method, `binarySearch()`, which sets up the search infrastructure.
    The first order of business is to build a separate array, `$search`, where the
    key is a composite of the columns included in the search. We then sort by key:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个方法`binarySearch()`，它设置了搜索基础设施。首要任务是构建一个单独的数组`$search`，其中键是搜索中包含的列的组合。然后我们按键排序：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We then pull out the keys into another array, `$binary`, so that we can perform
    the binary sort based on numeric keys. We then call `doBinarySearch()`, which
    results in a key from our intermediary array `$search`, or a Boolean, `FALSE`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将键提取到另一个数组`$binary`中，以便我们可以根据数字键执行二进制排序。然后我们调用`doBinarySearch()`，它会从我们的中间数组`$search`中得到一个键，或一个布尔值`FALSE`：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The first `doBinarySearch()` initializes a series of parameters. `$iterations`,
    `$found`, `$loop`, `$done`, and `$max` are all used to prevent an endless loop.
    `$upper` and `$lower` represent the slice of the list to be examined:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`doBinarySearch()`初始化一系列参数。`$iterations`，`$found`，`$loop`，`$done`和`$max`都用于防止无限循环。`$upper`和`$lower`表示要检查的列表切片：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We then implement a `while()` loop and set the midpoint:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们实现一个`while()`循环并设置中点：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We now get to use the new PHP 7 **spaceship operator**, which gives us, in
    a single comparison, less than, equal to, or greater than. If less, we set the
    upper limit to the midpoint. If greater, the lower limit is adjusted to the midpoint.
    If equal, we''re done and home free:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用新的PHP 7 **太空船操作符**，它在单个比较中给出小于、等于或大于。如果小于，则将上限设置为中点。如果大于，则将下限调整为中点。如果相等，则完成：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now for a bit of loop control. We increment the number of iterations and make
    sure it does not exceed the size of the list. If so, something is definitely wrong
    and we need to bail out. Otherwise, we check to see whether the upper and lower
    limits are the same more than twice in a row, in which case the search item has
    not been found. Then we store the number of iterations and return whatever was
    found (or not):'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是一点循环控制。我们增加迭代次数，并确保它不超过列表的大小。如果超过了，肯定有问题，我们需要退出。否则，我们检查上限和下限是否连续两次相同，如果是，则搜索项未找到。然后我们存储迭代次数并返回找到的内容（或未找到）：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, implement the `Application\Generic\Search` class defining the methods
    described in this recipe. Next, define a calling program, `chap_10_binary_search.php`,
    which sets up autoloading and reads the `customer.csv` file as a search target
    (as discussed in the previous recipe):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，实现`Application\Generic\Search`类，定义本教程中描述的方法。接下来，定义一个调用程序`chap_10_binary_search.php`，它设置自动加载并将`customer.csv`文件读取为搜索目标（如前一教程中所讨论的）：
- en: '[PRE43]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can then create a new `Search` instance, and specify an item somewhere
    in the middle of the list. In this illustration, the search is based on column
    1, customer name, and the item is `Todd Lindsey`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以创建一个新的`Search`实例，并在列表的中间某个位置指定一个项目。在本示例中，搜索基于列1，即客户名称，项目为`Todd Lindsey`：
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For illustration, add this line just before `switch()` in `Application\Generic\Search::doBinarySearch()`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，在`Application\Generic\Search::doBinarySearch()`中的`switch()`之前添加此行：
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output is shown here. Notice how the upper, middle, and lower limits adjust
    until the item is found:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示。请注意，上限、中间和下限会调整，直到找到项目：
- en: '![How it works...](graphics/B05314_10_06.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_10_06.jpg)'
- en: See also
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information on binary search, there is an excellent article on Wikipedia
    that goes through the basic math at [https://en.wikipedia.org/wiki/Binary_search_algorithm](https://en.wikipedia.org/wiki/Binary_search_algorithm).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有关二进制搜索的更多信息，请参阅维基百科上的一篇优秀文章，其中介绍了基本数学内容[https://en.wikipedia.org/wiki/Binary_search_algorithm](https://en.wikipedia.org/wiki/Binary_search_algorithm)。
- en: Implementing a search engine
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施搜索引擎
- en: In order to implement a search engine, we need to make provision for multiple
    columns to be included in the search. In addition, it's important to recognize
    that the search item might be found in the middle of the field, and that very
    rarely will users provide enough information for an exact match. Accordingly,
    we will rely heavily on the SQL `LIKE %value%` clause.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现搜索引擎，我们需要为多个列的搜索做好准备。此外，重要的是要认识到搜索项可能在字段的中间找到，并且用户很少提供足够的信息进行精确匹配。因此，我们将大量依赖SQL的`LIKE
    %value%`子句。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we define a basic class to hold search criteria. The object contains
    three properties: the key, which ultimately represents a database column; the
    operator (`LIKE`, `<`, `>`, and so on); and optionally an item. The reason why
    an item is optional is that some operators, such as `IS NOT NULL`, do not require
    specific data:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个基本类来保存搜索条件。该对象包含三个属性：键，最终表示数据库列；运算符（`LIKE`，`<`，`>`等）；和可选的项目。项目是可选的原因是一些运算符，如`IS
    NOT NULL`，不需要特定的数据：
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next we need to define a class, `Application\Database\Search\Engine`, and provide
    the necessary class constants and properties. The difference between `$columns`
    and `$mapping` is that `$columns` holds information that will ultimately appear
    in an HTML `SELECT` field (or the equivalent). For security reasons, we do not
    want to expose the actual names of the database columns, thus the need for another
    array `$mapping`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一个类`Application\Database\Search\Engine`，并提供必要的类常量和属性。`$columns`和`$mapping`之间的区别在于`$columns`保存的信息最终将出现在HTML的`SELECT`字段（或等效字段）中。出于安全原因，我们不希望公开数据库列的实际名称，因此需要另一个数组`$mapping`：
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we define a set of operators we are willing to support. The key represents
    actual SQL. The value is what will appear in the form:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一组我们愿意支持的运算符。键表示实际的SQL。值是表单中将出现的内容：
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The constructor accepts a database connection instance as an argument. For
    our purposes, we will use `Application\Database\Connection`, defined in [Chapter
    5](ch05.html "Chapter 5. Interacting with a Database"), *Interacting with a Database*.
    We also need to provide the name of the database table, as well as `$columns`,
    an array of arbitrary column keys and labels, which will appear in the HTML form.
    This will reference `$mapping`, where the key matches `$columns`, but where the
    value represents actual database column names:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数接受数据库连接实例作为参数。为了我们的目的，我们将使用[第5章](ch05.html "第5章。与数据库交互")中定义的`Application\Database\Connection`。我们还需要提供数据库表的名称，以及`$columns`，一个任意列键和标签的数组，这些将出现在HTML表单中。这将引用`$mapping`，其中键与`$columns`匹配，但值表示实际的数据库列名：
- en: '[PRE49]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After the constructor, we provide a series of useful getters and setters:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数之后，我们提供一系列有用的getter和setter：
- en: '[PRE50]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Probably the most critical method is the one that builds the SQL statement
    to be prepared. After the initial `SELECT` setup, we add a `WHERE` clause, using
    `$mapping` to add the actual database column name. We then add the operator and
    implement `switch()` which, based on the operator, may or may not add a named
    placeholder that will represent the search item:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能最关键的方法是构建要准备的SQL语句。在初始`SELECT`设置之后，我们添加一个`WHERE`子句，使用`$mapping`添加实际的数据库列名。然后添加操作符并实现`switch()`，根据操作符，可能会或可能不会添加一个表示搜索项的命名占位符：
- en: '[PRE51]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now that the core `SELECT` has been defined, we remove any trailing `OR` keywords,
    and add a clause that causes the result to be sorted according to the search column.
    The statement is then sent to the database to be prepared:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在核心的`SELECT`已经定义，我们删除任何尾随的`OR`关键字，并添加一个导致结果根据搜索列排序的子句。然后将该语句发送到数据库进行准备：
- en: '[PRE52]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We are now ready to move on to the main show, the `search()` method. We accept
    an `Application\Database\Search\Criteria` object as an argument. This ensures
    that we have an item key and operator at a minimum. To be on the safe side, we
    add an `if()` statement to check these properties:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备转向主要的展示，`search()`方法。我们接受一个`Application\Database\Search\Criteria`对象作为参数。这确保我们至少有一个项目键和操作符。为了安全起见，我们添加了一个`if()`语句来检查这些属性：
- en: '[PRE53]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We then call `prepareStatement()` using `try` / `catch` to trap errors:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们调用`prepareStatement()`使用`try` / `catch`来捕获错误：
- en: '[PRE54]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next we build an array of parameters that will be supplied to `execute()`.
    The key represents the database column name that was used as a placeholder in
    the prepared statement. Note that instead of using `=`, we use the `LIKE %value%
    construct`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们构建一个将提供给`execute()`的参数数组。键表示在准备语句中用作占位符的数据库列名。请注意，我们使用`=`而不是`LIKE %value%构造`：
- en: '[PRE55]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The statement is executed, and the results returned using the `yield` keywords,
    which effectively turns this method into a generator:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该语句被执行，并使用`yield`关键字返回结果，这有效地将此方法转换为生成器：
- en: '[PRE56]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Place the code discussed in this recipe in the files `Criteria.php` and `Engine.php`
    under `Application\Database\Search`. You can then define a calling script, `chap_10_search_engine.php`,
    which sets up autoloading. You can take advantage of the `Application\Database\Connection`
    class discussed in [Chapter 5](ch05.html "Chapter 5. Interacting with a Database"),
    *Interacting with a Database*, and the form element classes covered in [Chapter
    6](ch06.html "Chapter 6. Building Scalable Websites"), *Building Scalable Websites*:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将本章中讨论的代码放在`Application\Database\Search`下的文件`Criteria.php`和`Engine.php`中。然后可以定义一个调用脚本`chap_10_search_engine.php`，设置自动加载。您可以利用[第5章](ch05.html
    "第5章。与数据库交互")中讨论的`Application\Database\Connection`类，*与数据库交互*，以及[第6章](ch06.html
    "第6章。构建可扩展的网站")中涵盖的表单元素类，*构建可扩展的网站*：
- en: '[PRE57]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can now define which database columns will appear in the form, and a matching
    mapping file:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以定义哪些数据库列将出现在表单中，以及匹配的映射文件：
- en: '[PRE58]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can now set up the database connection and create the search engine instance:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以设置数据库连接并创建搜索引擎实例：
- en: '[PRE59]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In order to display the appropriate drop-down `SELECT` elements, we define
    wrappers and elements based on `Application\Form\*` classes:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示适当的下拉`SELECT`元素，我们基于`Application\Form\*`类定义包装器和元素：
- en: '[PRE60]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We then get input parameters (if defined), set form element options, create
    search criteria, and run the search:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们获取输入参数（如果已定义），设置表单元素选项，创建搜索条件并运行搜索：
- en: '[PRE61]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The display logic mainly orients towards rendering the form. A more thorough
    presentation is discussed in [Chapter 6](ch06.html "Chapter 6. Building Scalable
    Websites"), *Building Scalable Websites*, but we show the core logic here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 显示逻辑主要是朝向呈现表单。更详细的介绍在[第6章](ch06.html "第6章。构建可扩展的网站")中讨论，*构建可扩展的网站*，但我们在这里展示核心逻辑：
- en: '[PRE62]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here is sample output from a browser:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是浏览器中的示例输出：
- en: '![How it works...](graphics/B05314_10_07.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_10_07.jpg)'
- en: Displaying a multi-dimensional array and accumulating totals
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示多维数组和累积总数
- en: How to properly display data from a multi-dimensional array has been a classic
    problem for any web developer. For illustration, assume you wish to display a
    list of customers and their purchases. For each customer, you wish to show their
    name, phone number, account balance, and so on. This already represents a two
    dimensional array where the *x* axis represents customers and the *y* axis represents
    data for that customer. Now add in purchases and you have a third axis! How can
    you represent a 3D model on a 2D screen? One possible solution would be to incorporate
    "hidden" division tags with a simple JavaScript visibility toggle.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如何正确显示多维数组中的数据一直是任何Web开发人员的经典问题。举例来说，假设您希望显示客户及其购买的列表。对于每个客户，您希望显示他们的姓名，电话号码，账户余额等。这已经代表了一个二维数组，其中*x*轴代表客户，*y*轴代表该客户的数据。现在加入购买，您就有了第三个轴！如何在二维屏幕上表示3D模型？一个可能的解决方案是使用简单的JavaScript可见性切换来结合“隐藏”的分区标签。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First we need to generate a 3D array from a SQL statement that uses a number
    of `JOIN` clauses. We will use the `Application/Database/Connection` class introduced
    in [Chapter 1](ch01.html "Chapter 1. Building a Foundation"), *Building a Foundation,*
    to formulate an appropriate SQL query. We leave two parameters open, `min` and
    `max`, in order to support pagination. Unfortunately, we cannot use a simple `LIMIT`
    and `OFFSET` in this case, as the number of rows will vary depending on the number
    of purchases for any given customer. Accordingly, we can restrict the number of
    rows by placing restrictions on the customer ID that presumably (hopefully) is
    incremental. To make this work properly, we also need to set the primary `ORDER`
    to customer ID:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要从使用多个`JOIN`子句的SQL语句中生成一个3D数组。我们将使用在[第1章](ch01.html "第1章。建立基础")中介绍的`Application/Database/Connection`类，*建立基础*，来制定一个适当的SQL查询。我们留下两个参数`min`和`max`，以支持分页。不幸的是，在这种情况下，我们不能简单地使用`LIMIT`和`OFFSET`，因为行数将取决于任何给定顾客的购买数量。因此，我们可以通过对顾客ID的限制来限制行数，假设（希望）是递增的。为了使这个功能正常工作，我们还需要将主要的`ORDER`设置为顾客ID：
- en: '[PRE63]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next we can implement a form of pagination, based on restrictions on the customer
    ID, using simple `$_GET` parameters. Note that we add an extra check to make sure
    the value of `$prev` does not go below zero. You might consider adding another
    control that ensures the value of `$next` does not go beyond the last customer
    ID. In this illustration, we just allow it to increment:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们可以实现基于顾客ID的分页形式，使用简单的`$_GET`参数进行限制。请注意，我们添加了额外的检查，以确保`$prev`的值不会低于零。您可能考虑添加另一个控件，以确保`$next`的值不会超出最后一个顾客ID。在这个例子中，我们只允许它递增：
- en: '[PRE64]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We then calculate the values for `$min` and `$max`, and prepare and execute
    the SQL statement:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们计算`$min`和`$max`的值，并准备并执行SQL语句：
- en: '[PRE65]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A `while()` loop can be used to fetch results. We use a simple fetch mode of
    `PDO::FETCH_ASSOC` for the purpose of this example. Using the customer ID as a
    key, we store basic customer information as array parameters. We then store an
    array of purchase information in a sub-array, `$results[$key][''purchases''][]`.
    When the customer ID changes, it''s a signal to store the same information for
    the next customer. Note that we accumulate totals per customer in an array key
    total:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`while()`循环可以用来获取结果。我们在这个例子中使用了`PDO::FETCH_ASSOC`的简单获取模式。我们使用顾客ID作为键，将基本顾客信息存储为数组参数。然后我们在一个子数组中存储一组购买信息，`$results[$key]['purchases'][]`。当顾客ID改变时，这是一个信号，表示要为下一个顾客存储相同的信息。请注意，我们在一个数组键total中累积每个顾客的总数：
- en: '[PRE66]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next we implement the view logic. First, we start with a block that displays
    primary customer information:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们实现视图逻辑。首先，我们从显示主要顾客信息的块开始：
- en: '[PRE67]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next comes the logic to display a list of purchases for this customer:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是显示该顾客的购买列表的逻辑：
- en: '[PRE68]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'For the purposes of pagination, we then add buttons to represent *previous*
    and *next*:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了分页的目的，我们添加按钮来表示*上一个*和*下一个*：
- en: '[PRE69]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The result so far, unfortunately, is nowhere near neat and tidy! Accordingly
    we add a simple JavaScript function to toggle the visibility of a `<div>` tag
    based on its `id` attribute:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，结果非常不整洁！因此，我们添加了一个简单的JavaScript函数，根据其`id`属性切换`<div>`标签的可见性：
- en: '[PRE70]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next we wrap the purchases table inside an initially invisible `<div>` tag.
    Then, we can place a limit of how many sub-rows are initially visible, and add
    a link that *reveals* the remaining purchase data:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们将购买表格包裹在最初不可见的`<div>`标签中。然后，我们可以设置初始可见的子行数的限制，并添加一个*显示*剩余购买数据的链接：
- en: '[PRE71]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We then add a button that, when clicked, reveals the hidden `<div>` tag:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加一个按钮，当点击时，会显示隐藏的`<div>`标签：
- en: '[PRE72]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How it works...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Place the code described in steps 1 to 5 into a file, `chap_10_html_table_multi_array_hidden.php`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 将步骤1到5中描述的代码放入一个文件`chap_10_html_table_multi_array_hidden.php`中。
- en: 'Just inside the `while()` loop, add the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while()`循环的内部，添加以下内容：
- en: '[PRE73]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Just after the `while()` loop, add an `exit` command. Here is the output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while()`循环之后，添加一个`exit`命令。以下是输出：
- en: '![How it works...](graphics/B05314_10_08.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_10_08.jpg)'
- en: You will notice that the basic customer information, such as the ID and name,
    repeats for each result row, but purchase information, such as transaction and
    product title, varies. Go ahead and remove the `printf()` statement.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到基本的顾客信息，如ID和姓名，会重复出现在每个结果行中，但购买信息，如交易和产品标题，会有所不同。继续并删除`printf()`语句。
- en: 'Replace the `exit` command with the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换`exit`命令：
- en: '[PRE74]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here is how the newly composed 3D array looks:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 新组成的3D数组如下所示：
- en: '![How it works...](graphics/B05314_10_09.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_10_09.jpg)'
- en: 'You can now add the display logic shown in steps 5 to 7\. As mentioned, although
    you are now showing all data, the visual display is not helpful. Now go ahead
    and add the refinements mentioned in the remaining steps. Here is how the initial
    output might appear:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以添加步骤5到7中显示逻辑。虽然您现在显示了所有数据，但视觉显示并不有用。现在继续添加剩下步骤中提到的改进。这是初始输出可能会出现的样子：
- en: '![How it works...](graphics/B05314_10_15.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_10_15.jpg)'
- en: 'When the **Purchases** button is clicked, initial purchase info appears. If
    the link to **More** is clicked, the remaining purchase information shows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击**购买**按钮时，初始购买信息会出现。如果点击**更多**的链接，剩余的购买信息会显示：
- en: '![How it works...](graphics/B05314_10_11.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_10_11.jpg)'
