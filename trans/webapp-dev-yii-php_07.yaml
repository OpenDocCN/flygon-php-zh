- en: Chapter 7. User Access Control
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 用户访问控制
- en: 'User-based web applications, like our TrackStar application, typically need
    to control access to certain functionality based on who is making the request.
    When we speak of *user access control*, we are referring, at a high level, to
    some questions the application needs to ask when requests are being made. These
    questions are:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基于用户的Web应用程序，如我们的TrackStar应用程序，通常需要根据请求的发起者来控制对某些功能的访问。当我们谈论*用户访问控制*时，我们在高层次上指的是应用程序在进行请求时需要询问的一些问题。这些问题是：
- en: Who is making the request?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁在发起请求？
- en: Does that user have the appropriate permission to access the requested functionality?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该用户是否有适当的权限来访问所请求的功能？
- en: The answers to these questions help the application respond appropriately.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案有助于应用程序做出适当的响应。
- en: The work completed in [Chapter 6](ch06.html "Chapter 6. User Management and
    Authentication"), *User Management and Authorization* provides our application
    with the ability to answer the first of these questions. The application now allows
    users to establish their own authentication credentials and validates the username
    and password when a user logs in. After a successful login, the application knows
    exactly who is making subsequent requests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。用户管理和授权")中完成的工作为我们的应用程序提供了回答这些问题的能力。应用程序现在允许用户建立自己的身份验证凭据，并在用户登录时验证用户名和密码。成功登录后，应用程序确切地知道谁在发起后续的请求。
- en: In this chapter, we will focus on helping the application answer the second
    question. Once the user has provided appropriate identification, the application
    needs a way to determine if they also have permission to perform the requested
    action. We'll extend our basic authorization model by taking advantage of Yii's
    user access control features. Yii provides both a **simple access control filter**
    as well as a more sophisticated **Role Based Access Control** (**RBAC**) implementation
    as a means to help us address our user authorization requirements. We'll take
    a closer look at both of these as we work to implement the user access requirements
    for the TrackStar application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于帮助应用程序回答第二个问题。一旦用户提供了适当的身份识别，应用程序需要一种方法来确定他们是否也有权限执行所请求的操作。我们将通过利用Yii的用户访问控制功能来扩展我们的基本授权模型。Yii提供了**简单的访问控制过滤器**以及更复杂的**基于角色的访问控制**（**RBAC**）实现，以帮助我们满足用户授权的要求。在实现TrackStar应用程序的用户访问要求时，我们将更仔细地研究这两者。
- en: Feature planning
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能规划
- en: 'When we first introduced our TrackStar application back in [Chapter 3](ch03.html
    "Chapter 3. The TrackStar Application"), *The TrackStar Application*, we mentioned
    the application has two high-level user states, namely anonymous and authenticated.
    This simply makes a distinction between a user that has successfully logged in
    (authenticated), and one who has not (anonymous). We also introduced the idea
    of authenticated users having different roles within a project. Within a specific
    project, a user can be in one of the following three roles:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第3章](ch03.html "第3章。TrackStar应用程序")中首次介绍我们的TrackStar应用程序时，我们提到应用程序有两个高级用户状态，即匿名和已验证。这只是区分了已成功登录（已验证）和未登录（匿名）的用户。我们还介绍了已验证用户在项目内拥有不同角色的概念。在特定项目中，用户可以担任以下三种角色之一：
- en: A **project owner** has *all* administrative access to the project
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目所有者**对项目拥有*全部*的管理访问权限'
- en: A **project member** has *some* administrative access, but has more limited
    access compared to the project owner
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目成员**具有*一些*管理访问权限，但与项目所有者相比，访问权限更有限'
- en: A **project reader** has *read-only* access. Such users cannot change the content
    of a project
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目读者**具有*只读*访问权限。这样的用户无法更改项目的内容'
- en: The focus of this chapter is to implement an approach to manage the access control
    granted to application users. We need a way to create and manage our roles and
    permissions, assign them to users, and enforce the access control rules we want
    for each user role.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是实施一种管理授予应用程序用户的访问控制的方法。我们需要一种方式来创建和管理我们的角色和权限，将它们分配给用户，并强制我们对每个用户角色想要的访问控制规则。
- en: 'In order to achieve the goals outlined earlier, we will focus on the following
    throughout this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现前面概述的目标，我们将在本章中专注于以下内容：
- en: Implement a strategy to force the user to log in before gaining access to any
    project or issue-related functionality
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施一种策略，强制用户在获得任何项目或问题相关功能的访问权限之前先登录
- en: Create user roles and associate those roles with a specific permission structure
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户角色并将这些角色与特定的权限结构关联起来
- en: Implement the ability to assign users to roles (and their associated permissions)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现将用户分配到角色（及其相关权限）的能力
- en: Ensure our role and permission structure exists on a per-project basis (that
    is, allow users to have different permissions within different projects)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们的角色和权限结构存在于每个项目的基础上（即允许用户在不同项目中拥有不同的权限）
- en: Implement the ability to associate users to projects and at the same time to
    roles within that project
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现将用户关联到项目以及同时关联到项目内的角色的能力
- en: Implement the necessary authorization access checking throughout the application
    to appropriately grant or deny access to the application user based on their permissions
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整个应用程序中实施必要的授权访问检查，以根据其权限适当地授予或拒绝应用程序用户的访问权限
- en: Luckily, Yii comes with a lot of built-in functionality to help us implement
    these requirements. So, let's get started.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Yii自带了许多内置功能，帮助我们实现这些要求。所以，让我们开始吧。
- en: Access control filter
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问控制过滤器
- en: We first introduced *filters* back in [Chapter 5](ch05.html "Chapter 5. Managing
    Issues"), *Managing Issues* when we enforced a valid project context before allowing
    issue functionality to be used. If you recall, we added a class method filter
    `filterProjectContext()` to the `IssueController` class as a way to ensure we
    had a valid project context before we performed any actions on an Issue entity.
    Yii provides a similar approach for handling simple access control on an action-by-action
    basis within controllers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](ch05.html "第5章 管理问题")中首次介绍了*filters*，当我们在允许使用问题功能之前强制执行有效的项目上下文时。如果您还记得，我们在`IssueController`类中添加了一个类方法过滤器`filterProjectContext()`，以确保在对问题实体执行任何操作之前，我们有一个有效的项目上下文。Yii提供了一种类似的方法，用于在控制器中逐个操作处理简单的访问控制。
- en: 'The Yii framework provides a filter called `accessControl` *.* This filter
    can be directly used in controller classes to provide an authorization scheme
    to verify whether or not a user can access a specific controller action. In fact,
    the astute reader will remember that when we were implementing the `projectContext`
    filter back in [Chapter 5](ch05.html "Chapter 5. Managing Issues"), *Managing
    Issues*, we noticed that this access control filter was already included in the
    filters list for both our `IssueController` and `ProjectController` classes, as
    follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Yii框架提供了一个名为`accessControl`的过滤器。这个过滤器可以直接在控制器类中使用，以提供一个授权方案，用于验证用户是否可以访问特定的控制器操作。实际上，敏锐的读者会记得，当我们在[第5章](ch05.html
    "第5章 管理问题")中实现`projectContext`过滤器时，我们注意到这个访问控制过滤器已经包含在我们的`IssueController`和`ProjectController`类的过滤器列表中，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This was included in the autogenerated code produced by using the Gii CRUD code
    generator tool. The autogenerated code also overrides the `accessRules()` method,
    which is necessary in order to use the access control filter. It is in this method
    where you define the actual authorization rules.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用Gii CRUD代码生成工具生成的自动生成代码中包含的。自动生成的代码还覆盖了`accessRules()`方法，这是必要的，以便使用访问控制过滤器。在这个方法中，您定义实际的授权规则。
- en: The default implementation for our CRUD actions is set up to allow anyone to
    view a list of existing issues and projects. However, it restricts the access
    of creating and updating to authenticated users, and further restricts the delete
    action to a special *admin* user. You might remember that when we first implemented
    CRUD operations on projects, we had to log in before we were able to create new
    ones. The same was true when dealing with issues and again with users. The mechanism
    controlling this authorization and access is exactly this access control filter.
    Let's take a closer look at this implementation within the `ProjectController.php`
    class file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的CRUD操作的默认实现设置为允许任何人查看现有问题和项目的列表。但是，它限制了创建和更新的访问权限，只允许经过身份验证的用户，并进一步将删除操作限制为特殊的*admin*用户。您可能还记得，当我们首次在项目上实现CRUD操作时，我们必须先登录才能创建新项目。在处理问题和用户时也是如此。控制这种授权和访问的机制正是这个访问控制过滤器。让我们更仔细地看一下`ProjectController.php`类文件中的这个实现。
- en: 'There are two methods relevant to access control in the `ProjectController`
    class: `filters()` and `accessRules()`. The `filters()` method configures the
    filter:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProjectController`类中有两个与访问控制相关的方法：`filters()`和`accessRules()`。`filters()`方法配置过滤器。'
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And the `accessRules()` method, which is used to define the authorization rules
    used by the access filter, is shown as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`accessRules()` 方法用于定义访问过滤器使用的授权规则，如下所示：'
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `filters()` method is already familiar to us. It is where we specify all
    the filters to be used in the controller class. In this case, we have only one,
    `accessControl`, which refers to a filter provided by the Yii framework. This
    filter uses the other method, `accessRules()`, which defines the rules that drive
    the access restrictions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`filters()` 方法对我们来说已经很熟悉了。在这里，我们指定控制器类中要使用的所有过滤器。在这种情况下，我们只有一个`accessControl`，它是Yii框架提供的一个过滤器。这个过滤器使用另一个方法`accessRules()`，它定义了驱动访问限制的规则。'
- en: In the `accessRules()` method, there are four rules specified. Each rule is
    represented as an array. The first element of the array is either *allow* or *deny*.
    These indicate the granting or denying of access respectively. The rest of the
    array consists of `name=>value` pairs specifying the remaining parameters of the
    rule.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`accessRules()`方法中，指定了四条规则。每条规则都表示为一个数组。数组的第一个元素要么是*allow*，要么是*deny*。它们分别表示授予或拒绝访问。数组的其余部分由`name=>value`对组成，指定了规则的其余参数。
- en: 'Let''s look at the first rule defined earlier:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看一下之前定义的第一条规则：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This rule allows the `actionIndex()` and `actionView()` controller actions to
    be executed by any user. The asterisk (`*`), used in the value for the `'users'`
    element, is a special character used to specify any user (anonymous, authenticated,
    or otherwise).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则允许任何用户执行`actionIndex()`和`actionView()`控制器操作。在`'users'`元素的值中使用的星号(`*`)是一种用于指定任何用户（匿名、经过身份验证或其他方式）的特殊字符。
- en: 'Now let''s look at the second rule defined:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下定义的第二条规则：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This allows for any authenticated user to access the `actionCreate()` and `actionUpdate()`
    controller actions. The `@` special character is a way to specify any authenticated
    user.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许任何经过身份验证的用户访问`actionCreate()`和`actionUpdate()`控制器操作。`@`特殊字符是一种指定任何经过身份验证的用户的方式。
- en: 'The third rule is defined in the following code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第三条规则在以下代码片段中定义：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This rule specifies that a specific user, named `admin`, is allowed access to
    the `actionAdmin()` and `actionDelete()` controller actions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则指定了一个名为`admin`的特定用户被允许访问`actionAdmin()`和`actionDelete()`控制器操作。
- en: 'Finally, let''s have a closer look at the fourth rule:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们更仔细地看一下第四条规则：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This rule denies all users access to all controller actions. We'll elaborate
    on this one a little more in a minute.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则拒绝所有用户访问所有控制器操作。我们稍后会更详细地解释这一点。
- en: 'Access rules can be defined using a number of context parameters. The rules
    mentioned earlier are specifying actions and users to create the rule context,
    but there are several other parameters you can use. A few of these are given as
    follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用多个上下文参数来定义访问规则。前面提到的规则正在指定动作和用户来创建规则上下文，但是还有其他几个参数可以使用。以下是其中一些：
- en: '**Controllers**: Specifies an array of controller IDs to which the rule should
    apply.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：指定规则应用的控制器 ID 数组。'
- en: '**Roles**: Specifies a list of authorization items (roles, operations, and
    permissions) to which the rule applies. This makes use of the RBAC feature we
    will be discussing in the next section.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色**：指定规则适用的授权项（角色、操作和权限）列表。这利用了我们将在下一节讨论的 RBAC 功能。'
- en: '**IPs**: Specifies a list of client IP addresses to which this rule applies.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IP 地址**：指定此规则适用的客户端 IP 地址列表。'
- en: '**Verbs**: Specifies which HTTP request types (GET, POST, and so on) apply
    to this rule.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动词**：指定适用于此规则的 HTTP 请求类型（GET、POST 等）。'
- en: '**Expression**: Specifies a PHP expression whose value indicates whether or
    not the rule should be applied.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表达式**：指定一个 PHP 表达式，其值指示是否应用规则。'
- en: '**Actions**: Specifies the action method, by use of the corresponding action
    ID, to which the rule should match.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作**：通过相应的动作 ID 指定动作方法，该规则应匹配到该动作。'
- en: '**Users**: Specifies the users to which the rule should apply. The current
    application user''s name attribute is used for matching. The following three special
    characters can also be used here:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：指定规则应用的用户。当前应用用户的名称属性用于匹配。这里也可以使用以下三个特殊字符：'
- en: '*****: any user'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*****：任何用户'
- en: '**?**: anonymous users'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**?**：匿名用户'
- en: '**@**: authenticated users'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**@**：认证用户'
- en: If no users are specified, the rule will apply to all users.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定用户，规则将适用于所有用户。
- en: The access rules are evaluated one by one in the order they are specified. The
    first rule that matches the current pattern determines the authorization result.
    If this rule is an allow rule, the action can be executed; if it is a `deny` rule,
    the action cannot be executed; if none of the rules match the context, the action
    can still be executed. It is for this reason that the fourth rule mentioned earlier
    is defined. If we did not define a rule that denied all actions to all users at
    the end of our rules list, then we would not achieve our desired access restrictions.
    As an example, take the second rule. It specifies that authenticated users are
    allowed access to the `actioncreate()` and `actionUpdate()` actions. However,
    it does not stipulate that anonymous users be denied access. It says nothing about
    anonymous users. The fourth rule mentioned earlier ensures that all other requests
    that do not match one of the first three specific rules be denied access.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 访问规则按照它们被指定的顺序逐一进行评估。与当前模式匹配的第一个规则确定授权结果。如果这个规则是一个允许规则，那么动作可以被执行；如果它是一个“拒绝”规则，那么动作就不能被执行；如果没有规则匹配上下文，动作仍然可以被执行。这就是前面提到的第四条规则的定义原因。如果我们没有在规则列表的末尾定义一个拒绝所有用户的规则，那么我们就无法实现我们期望的访问限制。举个例子，看看第二条规则。它指定认证用户可以访问
    `actioncreate()` 和 `actionUpdate()` 动作。然而，它并没有规定匿名用户被拒绝访问。它对匿名用户什么也没说。前面提到的第四条规则确保了所有其他不匹配前三个具体规则的请求被拒绝访问。
- en: With this already in place, altering our application to deny access to all project,
    issue, and user related functionality for anonymous users is a snap. All we have
    to do is change the special character "`*`" of the users array value to the "`@`"
    special character. This will only allow authenticated users to access the `actionIndex()`
    and `actionView()` controller actions. All other actions are already restricted
    to authenticated users.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，对匿名用户拒绝访问所有项目、问题和用户相关功能的应用程序进行更改就很容易。我们只需要将用户数组值的特殊字符“*”更改为“@”特殊字符。这将只允许认证用户访问
    `actionIndex()` 和 `actionView()` 控制器动作。所有其他动作已经限制为认证用户。
- en: Now, we could make this change, three times, in each of our project, issue,
    and user controller class files. However, we have a base controller class from
    which each of these extend, namely the `Controller` class in the file `protected/components/Controller.php`.
    So, we can add our CRUD access rules in this one file, and then remove it from
    each of the child classes. We can also take advantage of the `controllers` context
    parameter when defining our rules so that it will only apply to these three controllers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的项目、问题和用户控制器类文件中每次进行三次更改。然而，我们有一个基础控制器类，每个类都是从中扩展出来的，即文件 `protected/components/Controller.php`
    中的 `Controller` 类。因此，我们可以在这一个文件中添加我们的 CRUD 访问规则，然后从每个子类中删除它。我们还可以在定义规则时利用 `controllers`
    上下文参数，以便它只适用于这三个控制器。
- en: 'First, let''s add the necessary method to our base controller class. Open up
    `protected/components/Controller.php` and add the following method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在我们的基础控制器类中添加必要的方法。打开 `protected/components/Controller.php` 并添加以下方法：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The highlighted code in the previous code snippet shows the changes we made.
    We have added the `controllers` parameter to each of our rules and changed the
    users for the index and view actions to only allow authenticated users.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码片段中突出显示的代码显示了我们所做的更改。我们已经为每个规则添加了 `controllers` 参数，并将索引和查看动作的用户更改为只允许认证用户。
- en: Now we can remove this method from each of the specified controllers. Open up
    all three of the `ProjectController.php`, `IssueController.php`, and `UserController.php`
    files and remove their respective `accessRules()` methods.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从每个指定的控制器中删除这个方法。打开 `ProjectController.php`、`IssueController.php` 和 `UserController.php`
    三个文件，并删除它们各自的 `accessRules()` 方法。
- en: After making these changes, the application will require a login prior to accessing
    any of our *project*, *issue*, or *user* functionality. We still allow anonymous
    user access to the `SiteController` class action methods, which we kept because
    this is where our login actions are located. We obviously have to be able to access
    the login page if we are not already logged in.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 做出这些更改后，应用程序将在访问我们的*项目*、*问题*或*用户*功能之前要求登录。我们仍然允许匿名用户访问`SiteController`类的操作方法，因为这是我们的登录操作所在的地方。显然，如果我们尚未登录，我们必须能够访问登录页面。
- en: Role based access control
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于角色的访问控制
- en: Now that we have used the simple access control filter to limit access to authenticated
    users, we need to turn focus to meeting some more specific access control needs
    of our application. As we mentioned, users will play certain roles within a project.
    The project will have users of type *owner*, who can be thought of as project
    administrators. They will be granted all access to manipulate the project. The
    project will also have users of type *member*, who will be granted some access
    to project functionality, but a proper subset of what owners are able to perform.
    Finally, the project can have users of type *reader*, who are only able to view
    project-related content and not alter it in any way. To achieve this type of access
    control based on the role of a user, we turn to the Role Based Access Control
    feature of Yii, also referred to more simply as RBAC.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用简单的访问控制过滤器限制了经过身份验证的用户的访问权限，我们需要转而关注满足应用程序更具体的访问控制需求。正如我们提到的，用户将在项目中扮演特定的角色。项目将有*所有者*类型的用户，可以被视为项目管理员。他们将被授予操纵项目的所有访问权限。项目还将有*成员*类型的用户，他们将被授予对项目功能的一些访问权限，但是比所有者能够执行的操作要少。最后，项目可以有*读者*类型的用户，他们只能查看与项目相关的内容，而不能以任何方式更改它。为了根据用户的角色实现这种类型的访问控制，我们转向Yii的基于角色的访问控制功能，也简称为RBAC。
- en: RBAC is an established approach in computer systems security to managing the
    access permissions of authenticated users. In short, the RBAC approach defines
    roles within an application. Permissions to perform certain operations are also
    defined and then associated with roles. Users are then assigned to a role and
    through the role association, acquire the permissions defined for that role. There
    is plenty of documentation available for the curious reader about the general
    RBAC concept and approach. Wikipedia, for example, [http://en.wikipedia.org/wiki/Role-based_access_control](http://en.wikipedia.org/wiki/Role-based_access_control).
    We'll focus on the specifics of Yii's implementation of the RBAC approach.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC是计算机系统安全中管理经过身份验证用户的访问权限的一种成熟方法。简而言之，RBAC方法在应用程序中定义角色。还定义了执行某些操作的权限，然后将其与角色关联起来。然后将用户分配给一个角色，并通过角色关联获得为该角色定义的权限。对于对RBAC概念和方法感兴趣的读者，有大量的文档可供参考。例如维基百科，[http://en.wikipedia.org/wiki/Role-based_access_control](http://en.wikipedia.org/wiki/Role-based_access_control)。我们将专注于Yii对RBAC方法的具体实现。
- en: Yii's implementation of RBAC is simple, elegant, and powerful. At the foundation
    of RBAC in Yii is the idea of the **authorization item** . The authorization item
    is simply a permission to do things in the application. These permissions can
    be categorized as *roles*, *tasks*, or *operations*, and, as such, form a permission
    hierarchy. Roles can consist of tasks (or other roles), tasks can consist of operations
    (or other tasks), and operations are the most granular permission level.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Yii对RBAC的实现简单、优雅且强大。在Yii中，RBAC的基础是**授权项**的概念。授权项简单地是应用程序中执行操作的权限。这些权限可以被归类为*角色*、*任务*或*操作*，因此形成了一个权限层次结构。角色可以包括任务（或其他角色），任务可以包括操作（或其他任务），操作是最粒度的权限级别。
- en: For example, in our TrackStar application, we need a role of type *owner*. So,
    we would create an authorization item of type *role* and call it "owner". This
    role could then consist of tasks such as a "user management" and "issue management".
    These tasks could then further consist of the atomic operations that make up these
    tasks. Continuing the example, the "user management" task could consist of the
    operations "create new user", "edit user", and "delete user". This hierarchy allows
    for inheritance of these permissions so that, given this example, if a user is
    assigned to the owner role, they inherit the permission to perform create, edit,
    and delete operations on the user.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的TrackStar应用程序中，我们需要一个*所有者*类型的角色。因此，我们将创建一个*角色*类型的授权项，并将其命名为“所有者”。然后，这个角色可以包括诸如“用户管理”和“问题管理”之类的任务。这些任务可以进一步包括组成这些任务的原子操作。继续上面的例子，“用户管理”任务可以包括“创建新用户”、“编辑用户”和“删除用户”操作。这种层次结构允许继承这些权限，因此，以这个例子为例，如果一个用户被分配到所有者角色，他们就会继承对用户执行创建、编辑和删除操作的权限。
- en: Typically in RBAC, you assign a user to one or more roles and the user inherits
    the permissions that have been assigned to those roles. This holds true for RBAC
    in Yii as well. However, in Yii, we can associate users to any authorization item,
    not just the ones of type *role*. This allows us the flexibility to associate
    a specific permission to a user at any level of granularity. If we only want to
    grant the "delete user" operation to a specific user, and not give them all the
    access that an owner role would have, we can simply associate the user to this
    atomic operation. This makes RBAC in Yii very flexible.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在RBAC中，通常你会将用户分配给一个或多个角色，用户会继承这些角色被分配的权限。在Yii中也是如此。然而，在Yii中，我们可以将用户与任何授权项关联，而不仅仅是*角色*类型的授权项。这使我们能够灵活地将特定权限与用户关联在任何粒度级别上。如果我们只想将“删除用户”操作授予特定用户，而不是给予他们所有者角色所具有的所有访问权限，我们可以简单地将用户与这个原子操作关联起来。这使得Yii中的RBAC非常灵活。
- en: Configuring the authorization manager
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置授权管理器
- en: Before we can establish an authorization hierarchy, assign users to roles, and
    perform access permission checking, we need to configure the authorization manager
    application component, `authManager`. This component is responsible for storing
    the permission data and managing the relationships between permissions. It also
    provides the methods to check whether or not a user has access to perform a particular
    operation. Yii provides two types of authorization managers `CPhpAuthManager`
    and `CDbAuthManager`. `CPhpAuthManager` uses a PHP script file to store the authorization
    data. `CDbAuthManager`, as you might have guessed, stores the authorization data
    in a database. The `authManager` is configured as an application component. Configuring
    the authorization manager consists simply of specifying which of these two types
    to use and then setting its initial class property values.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以建立授权层次结构，将用户分配给角色，并执行访问权限检查之前，我们需要配置授权管理器应用程序组件`authManager`。这个组件负责存储权限数据和管理权限之间的关系。它还提供了检查用户是否有权执行特定操作的方法。Yii提供了两种类型的授权管理器`CPhpAuthManager`和`CDbAuthManager`。`CPhpAuthManager`使用PHP脚本文件来存储授权数据。`CDbAuthManager`，正如你可能已经猜到的，将授权数据存储在数据库中。`authManager`被配置为一个应用程序组件。配置授权管理器只需要简单地指定使用这两种类型中的哪一种，然后设置它的初始类属性值。
- en: 'We''ll use the database implementation for our application. To make this configuration,
    open up the main configuration file, `protected/config/main.php`, and add the
    following to the application components array:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用数据库实现我们的应用程序。为了进行这个配置，打开主配置文件`protected/config/main.php`，并将以下内容添加到应用程序组件数组中：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This establishes a new application component named `authManager`, specifies
    the class type to be `CDbAuthManager`, and sets the `connectionID` class property
    to be our database connection component. Now we can access this anywhere in our
    application using `Yii::app()->authManager`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这建立了一个名为`authManager`的新应用程序组件，指定了类类型为`CDbAuthManager`，并将`connectionID`类属性设置为我们的数据库连接组件。现在我们可以在我们的应用程序的任何地方使用`Yii::app()->authManager`来访问它。
- en: Creating the RBAC database tables
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建RBAC数据库表
- en: As mentioned, the `CDbAuthManager` class uses database tables to store the permission
    data. It expects a specific schema. That schema is identified in the framework
    file `YiiRoot/framework/web/auth/schema.sql`. It is a simple, yet elegant, schema
    consisting of three tables, `AuthItem`, `AuthItemChild`, and `AuthAssignment`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`CDbAuthManager`类使用数据库表来存储权限数据。它期望一个特定的模式。该模式在框架文件`YiiRoot/framework/web/auth/schema.sql`中被识别。这是一个简单而优雅的模式，由三个表`AuthItem`，`AuthItemChild`和`AuthAssignment`组成。
- en: The `AuthItem` table holds the information defining the authorization item that
    is the role, task, or operation. The `AuthItemChild` table houses the parent/child
    relationships that form our hierarchy of authorization items. Finally, the `AuthAssignment`
    table is an association table that holds the association between a user and an
    authorization item.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthItem`表保存了定义角色、任务或操作的授权项的信息。`AuthItemChild`表存储了形成我们授权项层次结构的父/子关系。最后，`AuthAssignment`表是一个关联表，保存了用户和授权项之间的关联。'
- en: 'So, we need to add this table structure to our database. Just as we have done
    previously, we''ll use database migrations to make these changes. From the command
    line, navigate to the `/protected` directory of the TrackStar application, and
    create the migration:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要将这个表结构添加到我们的数据库中。就像我们之前做过的那样，我们将使用数据库迁移来进行这些更改。从命令行，导航到TrackStar应用程序的`/protected`目录，并创建迁移：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will create a new migration file under the `protected/migrations/` directory
    named according to the migration file naming conventions (for example, `m120619_015239_create_rbac_tables.php`).
    Implement the `up()` and `down()` migration methods as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`protected/migrations/`目录下创建一个根据迁移文件命名约定命名的新迁移文件（例如，`m120619_015239_create_rbac_tables.php`）。实现`up()`和`down()`迁移方法如下：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After you save these changes, run the migration to create the needed structure:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这些更改后，运行迁移以创建所需的结构：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once the necessary structure is created, you will see a message `Migrated up
    successfully` on the screen.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦必要的结构被创建，你会在屏幕上看到一个`成功迁移`的消息。
- en: 'Since we stayed with our database table naming conventions, we need to alter
    our `authManager` component configuration to specify our specific table names.
    Open up `/protected/config/main.php`, and add the table name specification to
    the `authManager` component:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们遵循了数据库表命名约定，我们需要修改我们的`authManager`组件配置，以指定我们特定的表名。打开`/protected/config/main.php`，并将表名规范添加到`authManager`组件中：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now the authorization manager component will know exactly which tables we want
    it to use to manage our authorization structure.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在授权管理器组件将确切地知道我们希望它使用哪些表来管理我们的授权结构。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you need a reminder on how to use Yii database migrations, refer back to
    [Chapter 4](ch04.html "Chapter 4. Project CRUD"), *Project CRUD* where this concept
    was first introduced.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要关于如何使用Yii数据库迁移的提醒，请参考[第4章](ch04.html "第4章。项目CRUD")，*项目CRUD*，这个概念是在那里首次介绍的。
- en: Creating the RBAC authorization hierarchy
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建RBAC授权层次结构
- en: 'After adding these tables to our `trackstar` database, we need to populate
    them with our roles and permissions. We will do this using the API provided by
    the `authmanager` component. To keep things simple, we are going to only define
    roles and basic operations. We will not set up any formal RBAC tasks for now.
    The following diagram displays the basic hierarchy we wish to define:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`trackstar`数据库中添加了这些表之后，我们需要用我们的角色和权限填充它们。我们将使用`authmanager`组件提供的API来做到这一点。为了保持简单，我们只会定义角色和基本操作。我们现在不会设置任何正式的RBAC任务。以下图显示了我们希望定义的基本层次结构：
- en: '![Creating the RBAC authorization hierarchy](graphics/8727_07_01.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![创建RBAC授权层次结构](graphics/8727_07_01.jpg)'
- en: The diagram shows the top-down inheritance. So, owners have all the permissions
    listed in the Owner box, plus they inherit all the permissions from both the member
    and reader roles. Likewise, member inherits permissions from reader. What we now
    need to do is establish this permission hierarchy in the application. As previously
    mentioned, one way to do this is to write code to utilize the `authManager` API.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了自上而下的继承关系。因此，所有者拥有所有在所有者框中列出的权限，同时继承来自成员和读者角色的所有权限。同样，成员继承自读者的权限。现在我们需要做的是在应用程序中建立这种权限层次结构。如前所述，实现这一点的一种方法是编写代码来利用`authManager`
    API。
- en: 'As an example of using the API, the following code creates a new role and a
    new operation, and then adds the relationship between the role and the permission:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用API的示例代码如下，它创建了一个新角色和一个新操作，然后添加了角色和权限之间的关系：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Walking through this code, we first get an instance of the `authManager`. We
    then use its `createRole()`, `createOperation()`, and `addChild()` API methods
    to create a new `owner` role, and a new operation named `createProject`. We then
    add the permission to the owner role. This only demonstrates the creation of a
    small part of our needed hierarchy; all of the remaining relationships we outlined
    in the previous diagram need to be created in a similar manner.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这段代码，我们首先获得了`authManager`的实例。然后我们使用它的`createRole()`、`createOperation()`和`addChild()`API方法来创建一个新的`owner`角色和一个名为`createProject`的新操作。然后我们将权限添加到所有者角色。这只是演示了我们需要的层次结构的一小部分的创建；我们在前面的图表中概述的所有其余关系都需要以类似的方式创建。
- en: We could create a new database migration, and place our code there in order
    to populate our permission hierarchy. However, we are going to take a different
    approach in order to demonstrate using console commands in your Yii applications.
    We are going to write a simple shell command to be executed at the command line.
    This will extend the command options of the `yiic` command-line tool we used to
    create our initial application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个新的数据库迁移，并将我们的代码放在那里以填充我们的权限层次结构。然而，为了演示在Yii应用程序中使用控制台命令，我们将采取不同的方法。我们将编写一个简单的shell命令，在命令行上执行。这将扩展我们用于创建初始应用程序的`yiic`命令行工具的命令选项。
- en: Writing a console application command
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写控制台应用程序命令
- en: We introduced the `yiic` command-line tool back in [Chapter 2](ch02.html "Chapter 2. Getting
    Started"), *Getting Started*, when we created a new "Hello, World!" application,
    and again in [Chapter 4](ch04.html "Chapter 4. Project CRUD"), *Project CRUD*
    when we used it to initially create the structure of our TrackStar web application.
    We have continued to use it when creating and running our database migrations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](ch02.html "第2章。入门")*入门*中介绍了`yiic`命令行工具，当我们创建了一个新的“Hello, World!”应用程序时，以及在[第4章](ch04.html
    "第4章。项目CRUD")*项目CRUD*中，当我们用它来最初创建我们的TrackStar web应用程序的结构时。在创建和运行数据库迁移时，我们继续使用它。
- en: The `yiic` tool is a console application in Yii that executes tasks in the form
    of commands. We have used the `webapp` command to create new applications, and
    the `migrate` command to create new migration files and execute our database migrations.
    Console applications in Yii are easily extended by writing custom commands, and
    this is exactly what we are going to do. We are going to extend the `yiic` command
    tool set by writing a new command-line tool to allow us to build our RBAC authorization.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`yiic`工具是Yii中的一个控制台应用程序，用于以命令形式执行任务。我们已经使用`webapp`命令创建新的应用程序，并使用`migrate`命令创建新的迁移文件并执行数据库迁移。Yii中的控制台应用程序可以通过编写自定义命令轻松扩展，这正是我们要做的。我们将通过编写一个新的命令行工具来扩展`yiic`命令工具集，以便我们可以构建RBAC授权。'
- en: Writing a new command for a console application is quite simple. A command is
    simply a class that extends from `CConsoleCommand`. It works similarly to a controller
    class in that it will parse the input command-line options and dispatch the request
    to the specified action within the command class, the default being `actionIndex()`.
    The name of the class should be exactly the same as the desired command name,
    followed by "Command". In our case, our command will simply be "Rbac", so we'll
    name our class `RbacCommand`. Lastly, in order to make this command available
    to the `yiic` console application, we need to save our class into the `/protected/commands/`
    directory, which is the default location for console commands.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为控制台应用程序编写新命令非常简单。命令只是一个从`CConsoleCommand`扩展的类。它的工作方式类似于控制器类，它将解析输入的命令行选项，并将请求分派到命令类中指定的操作，其默认为`actionIndex()`。类的名称应该与所需的命令名称完全相同，后面跟着“Command”。在我们的情况下，我们的命令将简单地是“Rbac”，所以我们将我们的类命名为`RbacCommand`。最后，为了使这个命令可用于`yiic`控制台应用程序，我们需要将我们的类保存到`/protected/commands/`目录中，这是控制台命令的默认位置。
- en: So, create a new file `/protected/commands/RbacCommand.php`. The contents for
    this file are too long to be included, but can be easily obtained from the downloadable
    code for this chapter, or from [gist.github.com/jeffwinesett](http://gist.github.com/jeffwinesett).
    The individual snippet for this is available at [https://gist.github.com/3779677](https://gist.github.com/3779677).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建一个新文件`/protected/commands/RbacCommand.php`。这个文件的内容太长，无法包含在内，但可以从本章的可下载代码或[gist.github.com/jeffwinesett](http://gist.github.com/jeffwinesett)中轻松获取。这个代码片段可以在[https://gist.github.com/3779677](https://gist.github.com/3779677)中找到。
- en: The comments in the downloadable code should help tell the story of what is
    happening here. We override the base class implementation of `getHelp()`to add
    an additional description line. We'll show how to display the help in a minute.
    All of the real action happens in the two actions we added, `actionIndex()` and
    `actionDelete()`. The former creates our RBAC hierarchy, and the latter removes
    it. They both ensure the application has a vaild `authManager` application component
    defined. Then both actions allow the user to have a last chance to cancel the
    request before proceeding. If the user of this command indicates they want to
    continue, the request will proceed. Both of our actions will proceed to clear
    all previously entered data in the RBAC tables and the `actionIndex()` method
    will create a new authorization hierarchy. The hierarchy that is created here
    is exactly the one we discussed previously.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可下载代码中的注释应该有助于讲述这里发生的事情。我们重写了`getHelp()`的基类实现，以添加一个额外的描述行。我们将在一分钟内展示如何显示帮助。所有真正的操作都发生在我们添加的两个操作`actionIndex()`和`actionDelete()`中。前者创建我们的RBAC层次结构，后者删除它。它们都确保应用程序有一个定义的有效`authManager`应用程序组件。然后，这两个操作允许用户在继续之前有最后一次取消请求的机会。如果使用此命令的用户表示他们想要继续，请求将继续。我们的两个操作都将继续清除RBAC表中先前输入的所有数据，而`actionIndex()`方法将创建一个新的授权层次结构。这里创建的层次结构正是我们之前讨论的那个。
- en: We can see that, even based on our fairly simple hierarchy, there is still a
    significant amount of code needed. Typically, one would need to develop a more
    intuitive **Graphical User Interface** (**GUI**) wrapped around these authorization
    manager APIs to provide an easy interface to manage roles, tasks, and operations.
    The approach we have taken here is a great solution for establishing a quick RBAC
    permission structure, but not ideal for the long-term maintenance of a permission
    structure that might change significantly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，即使基于我们相当简单的层次结构，仍然需要大量的代码。通常，需要开发一个更直观的**图形用户界面**（**GUI**）来包装这些授权管理器API，以提供一个易于管理角色、任务和操作的界面。我们在这里采取的方法是建立快速RBAC权限结构的好解决方案，但不适合长期维护可能会发生重大变化的权限结构。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In a real-world application, you will most likely need a different, more interactive
    tool to help maintain the RBAC relationships. The Yii extension library ([http://www.yiiframework.com/extensions/](http://www.yiiframework.com/extensions/))
    does provide some packaged solutions for this.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用程序中，您很可能需要一个不同的、更交互式的工具来帮助维护RBAC关系。Yii扩展库（[http://www.yiiframework.com/extensions/](http://www.yiiframework.com/extensions/)）提供了一些打包的解决方案。
- en: 'With this file in place, if we now ask the `yiic` tool for help, we''ll see
    our new command as one of the available options:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个文件，如果我们现在询问`yiic`工具帮助，我们将看到我们的新命令作为可用选项之一：
- en: '![Writing a console application command](graphics/8727_07_03.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![编写控制台应用程序命令](graphics/8727_07_03.jpg)'
- en: 'Our `rbac` does show up in the list. However, before we can try to execute
    it, we need to configure the `authManager` for our console application. As you
    may recall, when running console applications, a different configuration file
    is loaded, namely `/protected/config/console.php`. We need to add the same `authManager`
    component to this file as we did previously to the `main.php` configuration file.
    Open up `console.php` and add the following to the components list:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`rbac`显示在列表中。但是，在我们尝试执行之前，我们需要为控制台应用程序配置`authManager`。您可能还记得，运行控制台应用程序时，会加载不同的配置文件，即`/protected/config/console.php`。我们需要在这个文件中添加与之前添加到`main.php`配置文件相同的`authManager`组件。打开`console.php`并将以下内容添加到组件列表中：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With this in place, we can now try out our new command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以尝试我们的新命令：
- en: '![Writing a console application command](graphics/8727_07_04.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![编写控制台应用程序命令](graphics/8727_07_04.jpg)'
- en: 'This is exactly the help text that we added to our `getHelp()` method in our
    command class. You can certainly be more verbose and add more detail as desired.
    Let''s actually run the command. Since `actionIndex()` is the default, we don''t
    have to specify the action:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在命令类的`getHelp()`方法中添加的帮助文本。您当然可以更详细地添加更多细节。让我们实际运行命令。由于`actionIndex()`是默认值，我们不必指定操作：
- en: '![Writing a console application command](graphics/8727_07_05.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![编写控制台应用程序命令](graphics/8727_07_05.jpg)'
- en: Our command has completed and we have added the appropriate data to our new
    database tables to generate our authorization hierarchy.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的命令已经完成，并且我们已经向新的数据库表中添加了适当的数据，以生成我们的授权层次结构。
- en: 'Since we also added an `actionDelete()` method to remove our hierarchy, you
    can try that one out as well:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还添加了一个`actionDelete()`方法来删除我们的层次结构，您也可以尝试一下：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once you are done trying these out, make sure you run the command again to add
    the hierarchy, as we need it to be in place as we continue.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试这些操作完成后，确保再次运行命令以添加层次结构，因为我们需要它继续存在。
- en: Assigning users to roles
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配用户到角色
- en: 'Everything we have done thus far establishes an authorization hierarchy, but
    it does not yet assign permissions to users. We accomplish this by assigning users
    to one of the three roles we created, *owner*, *member*, or *reader*. For example,
    if we wanted to associate the user whose unique user ID is `1` with the `member`
    role, we would execute the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的一切都建立了一个授权层次结构，但尚未为用户分配权限。我们通过将用户分配到我们创建的三个角色之一，*owner*、*member*或*reader*来实现这一点。例如，如果我们想要将唯一用户ID为`1`的用户与`member`角色关联，我们将执行以下操作：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once these relationships are established, checking a user''s access permission
    is a simple matter. We simply ask the application user component whether or not
    the current user has the permission. For example, if we wanted to check whether
    or not the current user is allowed to create a new issue, we could do so with
    the following syntax:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了这些关系，检查用户的访问权限就变得很简单。我们只需询问应用程序用户组件当前用户是否具有权限。例如，如果我们想要检查当前用户是否被允许创建新问题，我们可以使用以下语法：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, we assigned user ID `1` to the role of `member` and since in
    our authorization hierarchy the member role inherits the `createIssue` permission,
    this `if()` statement would evaluate to `true`, assuming we were logged in to
    the application as user `1`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将用户ID `1`分配给`成员`角色，由于在我们的授权层次结构中，成员角色继承了`createIssue`权限，假设我们以用户`1`的身份登录到应用程序中，这个`if()`语句将评估为`true`。
- en: We will be adding this authorization assignment logic as part of the business
    logic executed when adding a new member to a project. We'll be adding a new form
    that allows us to add users to projects, and the ability to choose a role as part
    of the process. But first we need to address one other aspect of how user roles
    need to be implemented within this application, namely, they need to apply on
    a per-project basis.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在向项目添加新成员时添加此授权分配逻辑作为业务逻辑的一部分。我们将添加一个新表单，允许我们将用户添加到项目中，并在此过程中选择角色。但首先，我们需要解决用户角色需要在每个项目基础上实施的另一个方面。
- en: Adding RBAC roles to users on a per-project basis
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在每个项目基础上为用户添加RBAC角色
- en: We now have a basic RBAC authorization model in place, but these relationships
    apply to the application as a whole. Our needs for the TrackStar application are
    slightly more complex. We need to assign roles to users within the context of
    projects, not just globally across the application. We need to allow users to
    be in different roles, depending on the project. For example, a user may be in
    the `reader` role of one project, a `member` of a second project, and an `owner`
    of some third project. Users can be associated with many projects, and the role
    they are assigned needs to be specific to the project.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经建立了一个基本的RBAC授权模型，但这些关系适用于整个应用程序。TrackStar应用程序的需求稍微复杂一些。我们需要在项目的上下文中为用户分配角色，而不仅仅是在整个应用程序中全局地分配。我们需要允许用户在不同的项目中担任不同的角色。例如，用户可能是一个项目的“读者”角色，第二个项目的“成员”角色，以及第三个项目的“所有者”角色。用户可以与许多项目相关联，并且他们被分配的角色需要特定于项目。
- en: 'The RBAC framework in Yii does not have anything built-in that we can take
    advantage of to meet this requirement. The RBAC model is only intended to establish
    relationships between roles and permissions. It does not know (nor should it)
    anything about our TrackStar projects. In order to achieve this extra dimension
    to our authorization hierarchy, we need to alter our database structure to contain
    an association between a user, project, and role. If you recall from back in [Chapter
    5](ch05.html "Chapter 5. Managing Issues"), *Managing Issues* we have already
    created a table, `tbl_project_user_assignment`, to hold the association between
    a user and a project. We can alter this table to also contain the role assigned
    to the user within the project. We''ll add a new migration to alter our table:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Yii中的RBAC框架没有内置的东西可以满足这个要求。RBAC模型只旨在建立角色和权限之间的关系。它不知道（也不应该知道）我们的TrackStar项目的任何信息。为了实现我们授权层次结构的这个额外维度，我们需要改变我们的数据库结构，以包含用户、项目和角色之间的关联。如果您还记得[第5章](ch05.html
    "第5章 管理问题")中的内容，*管理问题*，我们已经创建了一个名为`tbl_project_user_assignment`的表，用于保存用户和项目之间的关联。我们可以修改这个表，以包含用户在项目中分配的角色。我们将添加一个新的迁移来修改我们的表：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now open up the newly created migration file and implement the following `up()`
    and `down()` methods:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开新创建的迁移文件，并实现以下`up()`和`down()`方法：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally run the migration:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后运行迁移：
- en: '![Adding RBAC roles to users on a per-project basis](graphics/8727_07_06.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![在每个项目基础上为用户添加RBAC角色](graphics/8727_07_06.jpg)'
- en: You will see the message `Migrated up successfully` at the end of the screen.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在屏幕底部看到消息“成功迁移”。
- en: Now our table is set up to allow us to make the role association along with
    the association between a user and a project.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的表已经设置好，可以允许我们进行角色关联以及用户和项目之间的关联。
- en: Adding RBAC business rules
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加RBAC业务规则
- en: While the database table shown earlier will hold the basic information to answer
    the question as to whether a user is assigned to a role within the context of
    a particular project, we still need our RBAC `auth` hierarchy to answer questions
    concerning whether or not a user has permission to perform a certain functionality.
    Although the RBAC model in Yii does not know about our TrackStar projects, it
    does have a very powerful feature of which we can take advantage. When you create
    authorization items or assign an item to a user, you can associate a snippet of
    PHP code that will be executed during the `Yii::app()->user->checkAccess()` call.
    When defined, this bit of code must return `true` before the user would be granted
    that permission.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然之前显示的数据库表将保存基本信息，以回答用户是否在特定项目的上下文中被分配了角色的问题，但我们仍然需要我们的RBAC“auth”层次结构来回答关于用户是否有权限执行某个功能的问题。尽管Yii中的RBAC模型不知道我们的TrackStar项目，但它具有一个非常强大的功能，我们可以利用它。当您创建授权项或将项分配给用户时，您可以关联一小段PHP代码，该代码将在`Yii::app()->user->checkAccess()`调用期间执行。一旦定义，这段代码必须在用户被授予权限之前返回`true`。
- en: One example of the usefulness of this feature is in the context of applications
    that allow users to maintain personal profile information. Often in this case,
    the application would like to ensure that a user has the permission to update
    only their own profile information and no one else's. In this case we could create
    an authorization item called "updateProfile", and then associate a business rule
    that checks if the current user's ID is the same as the user ID associated with
    the profile information.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能的一个例子是在允许用户维护个人资料信息的应用程序中。在这种情况下，应用程序希望确保用户只有权限更新自己的个人资料信息，而不是其他人的。在这种情况下，我们可以创建一个名为“updateProfile”的授权项，然后关联一个业务规则，检查当前用户的ID是否与与个人资料信息相关联的用户ID相同。
- en: In our case, we are going to associate a business rule with the role assignment.
    When we assign a user to a specific role, we will also associate a business rule
    that will check the relationship within the context of the project. The `checkAccess()`
    method also allows us to pass in an array of additional parameters for the business
    rule to use to perform its logic. We'll use this to pass in the current project
    context so that the business rule can call a method on the `Project` AR class
    in order to determine whether or not the user is assigned to that role within
    that project.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将为角色分配关联一个业务规则。当我们将用户分配给特定角色时，我们还将关联一个业务规则，该规则将在项目的上下文中检查关系。`checkAccess()`方法还允许我们传递一个附加参数数组，供业务规则使用以执行其逻辑。我们将使用这个来传递当前项目上下文，以便业务规则可以调用`Project`
    AR类的方法，以确定用户是否在该项目中被分配到该角色。
- en: 'The business rule we''ll create will be slightly different for each role assignment.
    For example, the one we''ll use when assigning a user to the owner role will look
    like the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每个角色分配创建稍有不同的业务规则。例如，当将用户分配给所有者角色时，我们将使用以下规则：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The ones for the roles `member` and `reader` will be similar.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 角色`成员`和`读者`的方法将会相似。
- en: 'We will also have to pass in the project context when we call the `checkAccess()`
    method. So now when checking if a user has access to, for example, the `createIssue`
    operation, the code would look like the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`checkAccess()`方法时，我们还需要传递项目上下文。因此，现在在检查用户是否有权限执行例如`createIssue`操作时，代码将如下所示：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the previous code, the `$project` variable is the `Project` AR class instance
    associated with the current project context (remember that almost all functionality
    in our application occurs within the context of a project). This class instance
    is what is used in the business rule. The business rule calls a method, `Project::isUserInRole()`,
    in order to determine if the user is in the role for the specific project.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`$project`变量是与当前项目上下文相关联的`Project` AR类实例（请记住，我们应用程序中的几乎所有功能都发生在项目的上下文中）。这个类实例是业务规则中使用的。业务规则调用`Project::isUserInRole()`方法，以确定用户是否在特定项目的角色中。
- en: Implementing the new project AR methods
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现新的项目AR方法
- en: Now that we have altered our database structure to house the relationship between
    user, role, and project, we need to implement the required logic to manage and
    verify the data in this table. We will be adding public methods to the project
    AR class to handle adding and removing data from this table as well as verifying
    the existence of rows.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修改了数据库结构，以容纳用户、角色和项目之间的关系，我们需要实现所需的逻辑来管理和验证该表中的数据。我们将在项目AR类中添加公共方法，以处理从该表中添加和删除数据以及验证行的存在。
- en: 'We need to add the public method to the `Project` AR class that will take in
    a role name and a user ID and create the association between role, user, and project.
    Open up the `protected/models/Project.php` file and add the following method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`Project` AR类中添加一个公共方法，该方法将接受角色名称和用户ID，并创建角色、用户和项目之间的关联。打开`protected/models/Project.php`文件，并添加以下方法：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here we are using the Yii framework query builder approach to directly insert
    into the database table, rather than using the active record approach. Since `tbl_project_user_assignement`
    is just an association table, and does not represent a main domain object of our
    model, it is sometimes easier to manage the data in these types of tables in a
    more direct manner than using the active record approach.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Yii框架的查询构建器方法直接插入数据库表，而不是使用活动记录方法。由于`tbl_project_user_assignement`只是一个关联表，并不代表我们模型的主要领域对象，因此有时更容易以更直接的方式管理这些类型表中的数据，而不是使用活动记录方法。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on using Query Builder in Yii, visit:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在Yii中使用查询构建器的更多信息，请访问：
- en: '[http://www.yiiframework.com/doc/guide/1.1/en/database.query-builder](http://www.yiiframework.com/doc/guide/1.1/en/database.query-builder)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.yiiframework.com/doc/guide/1.1/en/database.query-builder](http://www.yiiframework.com/doc/guide/1.1/en/database.query-builder)'
- en: We'll also need to be able to remove a user from a project, and in doing so,
    remove the association between a user and the project. So, let's also add a method
    to do that.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要能够从项目中删除用户，并在这样做时，删除用户和项目之间的关联。因此，让我们也添加一个执行此操作的方法。
- en: 'Add the following method to the `Project` AR class:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Project` AR类中添加以下方法：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This simply deletes the row from the table that houses the association between
    the role, the user, and the project.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是从包含角色、用户和项目之间关联的表中删除行。
- en: We have now implemented the methods for adding and removing our associations.
    We need to add functionality to determine whether or not a given user is associated
    with a role within the project. We will also add this as a public method to our
    `Project` AR class.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了添加和删除关联的方法。我们需要添加功能来确定给定用户是否与项目内的角色相关联。我们还将这作为公共方法添加到我们的`Project` AR类中。
- en: 'Add the following method to the bottom of the `Project` AR model class:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Project` AR模型类的底部添加以下方法：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This method is showing how to execute the SQL directly, rather than using the
    query builder. The query builder is very useful, but for simple queries, it is
    sometimes easier to just execute the SQL directly, utilizing Yii's Data Access
    Objects (DAO).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法展示了如何直接执行SQL，而不是使用查询构建器。查询构建器非常有用，但对于简单的查询，直接执行SQL有时更容易，利用Yii的数据访问对象（DAO）。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on Yii''s Data Access Objects and directly executing SQL
    in Yii, see:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Yii的数据访问对象和在Yii中直接执行SQL的更多信息，请参阅：
- en: '[http://www.yiiframework.com/doc/guide/1.1/en/database.dao](http://www.yiiframework.com/doc/guide/1.1/en/database.dao)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.yiiframework.com/doc/guide/1.1/en/database.dao](http://www.yiiframework.com/doc/guide/1.1/en/database.dao)'
- en: Adding users to projects
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将用户添加到项目中
- en: Now we need to put all of this together. In [Chapter 6](ch06.html "Chapter 6. User
    Management and Authentication"), *User Management and Authorization* we added
    the ability to create new users of the application. However, we do not yet have
    a way to assign users to specific projects, and further, assign them to roles
    within these projects. Now that we have our RBAC approach in place, we need to
    build this new functionality.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要把所有这些放在一起。在[第6章](ch06.html "第6章。用户管理和认证")中，*用户管理和授权*中，我们添加了创建应用程序新用户的功能。然而，我们还没有办法将用户分配给特定的项目，并进一步将他们分配到这些项目中的角色。现在我们已经有了RBAC方法，我们需要构建这个新功能。
- en: The implementation of this functionality involves several coding changes. However,
    we have provided similar examples of the type of changes needed, and have covered
    all of the related concepts when implementing functionality in previous chapters.
    Consequently, we will move pretty quickly through this, and pause only briefly
    to highlight just a few things we have not yet seen. At this point, the reader
    should be able to make all of these changes without much help, and is encouraged
    to do so as a hands-on exercise. To further encourage this exercise, we'll first
    list everything we are going to do to fulfill this new feature requirement. You
    can then close the book and try some of these out yourself before looking further
    down at our implementation.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能的实现涉及几个编码更改。然而，我们已经提供了类似的需要的更改的示例，并在之前的章节中涵盖了所有相关的概念。因此，我们将快速地进行这个过程，并且只是简要地强调一些我们还没有看到的东西。此时，读者应该能够在没有太多帮助的情况下进行所有这些更改，并被鼓励以实践的方式这样做。为了进一步鼓励这种练习，我们将首先列出我们要做的一切来满足这个新的功能需求。然后你可以关闭书本，在查看我们的实现之前尝试一些这样的操作。
- en: 'To achieve this goal we will perform the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，我们将执行以下操作：
- en: Add a public static method called `getUserRoleOptions()` to the `Project` model
    class that returns a valid list of role options using the `auth` manager's `getRoles()`
    method. We will use this to populate a roles selection drop-down field in the
    form, so that we can select the user role when adding a new user to a project.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Project`模型类中添加一个名为`getUserRoleOptions()`的新公共静态方法，该方法使用`auth`管理器的`getRoles()`方法返回一个有效的角色选项列表。我们将使用这个方法来填充表单中的角色选择下拉字段，以便在向项目添加新用户时选择用户角色。
- en: Add a new public method called `isUserInProject($user)` to the `Project` model
    class to determine if a user is already associated with a project. We will use
    this in our validation rules upon form submission so that we don't attempt to
    add a duplicate user to a project.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Project`模型类中添加一个名为`isUserInProject($user)`的新公共方法，以确定用户是否已经与项目关联。我们将在表单提交时使用这个方法来进行验证规则，以便我们不会尝试将重复的用户添加到项目中。
- en: Add a new form model class called `ProjectUserForm`, extending from `CFormModel`
    for a new input form model. Add to this form model class three attributes, namely
    `$username`, `$role`, and `$project`. Also add validation rules to ensure that
    both the username and the role are required input fields, and that the username
    should further be validated via a custom `verify()` class method.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`ProjectUserForm`的新表单模型类，继承自`CFormModel`，用于新的输入表单模型。在这个表单模型类中添加三个属性，即`$username`、`$role`和`$project`。还要添加验证规则，以确保用户名和角色都是必需的输入字段，并且用户名应该通过自定义的`verify()`类方法进行进一步验证。
- en: This verify method should attempt to create a new UserAR class instance by finding
    a user matching the input username. If the attempt was successful, it should continue
    to associate the user to a project using the `assignUser($userId, $role)`method
    that we already added earlier. We will also need to associate the user to the
    role in our RBAC hierarchy implemented earlier in this chapter. If no user was
    found matching the username, it needs to set and return an error. (If needed,
    review the `LoginForm::authenticate()`method as an example of a custom validation
    rule method.)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个验证方法应该尝试通过查找与输入用户名匹配的用户来创建一个新的UserAR类实例。如果尝试成功，它应该继续使用我们之前添加的`assignUser($userId,
    $role)`方法将用户关联到项目。我们还需要在本章前面实现的RBAC层次结构中将用户与角色关联起来。如果没有找到与用户名匹配的用户，它需要设置并返回一个错误。（如果需要，可以查看`LoginForm::authenticate()`方法作为自定义验证规则方法的示例。）
- en: Add a new view file under views/project called `adduser.php` to display our
    new form for adding users to projects. This form only needs two input fields,
    *username* and *role*. The role should be a drop-down choice listing.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在views/project下添加一个名为`adduser.php`的新视图文件，用于显示我们向项目添加用户的新表单。这个表单只需要两个输入字段，*用户名*和*角色*。角色应该是一个下拉选择列表。
- en: Add a new controller action method called `actionAdduser()` to the `ProjectController`
    class and alter its `accessRules()` method to ensure it is accessible by authenticated
    members. This new action method is responsible for rendering the new view to display
    the form and handle the post back when the form is submitted.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProjectController`类中添加一个名为`actionAdduser()`的新控制器动作方法，并修改其`accessRules()`方法以确保经过身份验证的成员可以访问它。这个新的动作方法负责呈现新的视图来显示表单，并在提交表单时处理后退。
- en: Again, we encourage the reader to attempt these changes on their own first.
    We list our code changes in the following sections.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 再次鼓励读者首先尝试自己进行这些更改。我们在以下部分列出了我们的代码更改。
- en: Altering the project model class
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改项目模型类
- en: 'To the `Project` class, we add two new public methods, one of them static so
    it can be called without the need for a specific class instance:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Project`类，我们添加了两个新的公共方法，其中一个是静态的，因此可以在不需要特定类实例的情况下调用：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Adding the new form model class
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新的表单模型类
- en: Just as it was used in the approach for the login form, we are going to create
    a new form model class as a central place to house our form input parameters and
    to centralize the validation. This is a fairly simple class that extends from
    the Yii class `CFormModel` and has attributes that map to our form input fields,
    as well as one to hold the valid project context. We need the project context
    to be able to add users to projects. The entire class is too long to list here,
    but can be easily obtained from the downloadable code that accompanies this chapter.
    The standalone snippet is available at [https://gist.github.com/3779690](http://
    https://gist.github.com/3779690).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在登录表单的方法中使用的那样，我们将创建一个新的表单模型类，作为存放我们的表单输入参数和集中验证的中心位置。这是一个相当简单的类，它继承自Yii类`CFormModel`，并具有映射到我们表单输入字段的属性，以及一个用于保存有效项目上下文的属性。我们需要项目上下文来能够向项目添加用户。整个类太长了，无法在这里列出，但可以轻松从本章附带的可下载代码中获取。独立的代码片段可以在[https://gist.github.com/3779690](http://
    https://gist.github.com/3779690)上找到。
- en: 'In the following code snippet, we have listed just the parts we have not seen
    before:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们列出了我们以前没有见过的部分：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For simplicity, in the `createUsernameList()` method, we are selecting *all*
    users from the database to use for the username list. If there are a large number
    of users, this may result in suboptimal performance. To optimize performance,
    you may need to filter and limit this in cases where there are a large number
    of users.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，在`createUsernameList()`方法中，我们选择从数据库中选择*所有*用户来用于用户名列表。如果有大量用户，这可能会导致性能不佳。为了优化性能，在用户数量较多的情况下，您可能需要对其进行过滤和限制。
- en: 'The part of the downloadable code that we listed above is the `assign()` method
    where we are adding a bizRule to the association between the user and role in
    RBAC:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在可下载的代码部分中列出的部分是`assign()`方法，我们在其中为用户和角色之间的关联添加了一个bizRule：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We create an instance of the `Authmanager` class that we used to establish the
    assignment of the user to the role. However, before we make that assignment, we
    create the business rule. The business rule uses the `$params` array by first
    checking the existence of a `project` element in the array, and then calls the
    `isUserInRole()` method on the project AR class, which is the value of that array
    element. We explicitly pass in the role name to this method. We then call the
    `AuthManager::assign()` method to make the association between the user and the
    role.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`Authmanager`类的实例，用于建立用户与角色的分配。然而，在进行分配之前，我们需要创建业务规则。业务规则使用`$params`数组，首先检查数组中是否存在`project`元素，然后在项目AR类上调用`isUserInRole()`方法，该方法是该数组元素的值。我们明确向这个方法传递角色名。然后我们调用`AuthManager::assign()`方法来建立用户与角色之间的关联。
- en: We have also added a simple public method, `createUsernameList()`, to return
    an array of all the usernames in the database. We will use this array to populate
    the data of one of Yii's UI widgets, `CJuiAutoComplete`, which we will use for
    the username input form element. As its name suggests, as we type in the input
    form field, it will provide choice suggestions based on the elements in this array.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个简单的公共方法`createUsernameList()`，返回数据库中所有用户名的数组。我们将使用这个数组来填充Yii的UI小部件`CJuiAutoComplete`的数据，我们将用它来填充用户名输入表单元素。正如它的名字所示，当我们在输入表单字段中输入时，它将根据这个数组中的元素提供选择建议。
- en: Adding the new action method to the project controller
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向项目控制器添加新的动作方法
- en: 'We need a controller action to handle the initial request to display the form
    for adding a new user to a project. We placed this in the `ProjectController`
    class and named it `actionAdduser()`. The code for this is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个控制器动作来处理显示向项目添加新用户的表单的初始请求。我们将其放在`ProjectController`类中，并命名为`actionAdduser()`。其代码如下：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is all pretty familiar to us at this point. It handles both the initial
    `GET` request to display the form as well as the `POST` request after the form
    is submitted. It follows very much the same approach as our `SiteController::actionLogin()`
    method. The highlighted code in the previous code snippet is, however, something
    we have not seen before. If the submitted form request is successful, it sets
    what is called a **flash message**. A flash message is a temporary message stored
    briefly in the session. It is only available in the current and the next requests.
    Here we are using the `setFlash()` method of our `CWebUser` application user component
    to store a temporary message that the request was successful. When we talk about
    the view in the next section, we will see how to access this message and display
    it to the user.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们来说都很熟悉。它处理了显示表单的初始`GET`请求，以及表单提交后的`POST`请求。它非常类似于我们的`SiteController::actionLogin()`方法。然而，在上一个代码片段中突出显示的代码是我们以前没有见过的。如果提交的表单请求成功，它会设置一个称为**flash
    message**的东西。Flash message是一个临时消息，暂时存储在会话中。它只在当前和下一个请求中可用。在这里，我们使用我们的`CWebUser`应用用户组件的`setFlash()`方法来存储一个临时消息，表示请求成功。当我们在下一节讨论视图时，我们将看到如何访问此消息并将其显示给用户。
- en: 'One other change we have to make is to the base controller class method `Controller::accessRules()`.
    As you recall, we added our access rules to this base class so that they apply
    to each of our user, issue, and project controller classes. We need to add in
    this new action name to the basic access rules list so that a logged in user is
    allowed to access this action:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的另一个更改是基本控制器类方法`Controller::accessRules()`。您还记得，我们将访问规则添加到这个基类中，以便它们适用于我们的每个用户、问题和项目控制器类。我们需要将这个新动作名称添加到基本访问规则列表中，以便允许已登录用户访问此动作：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Adding the new view file to display the form
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新的视图文件来显示表单
- en: 'Our new action method is calling `->render(''adduser'')` to render a view file,
    so we need to get that created. The following is the full listing of our implementation
    for `protected/views/project/adduser.php`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新动作方法调用`->render('adduser')`来渲染一个视图文件，所以我们需要创建一个。以下是我们对`protected/views/project/adduser.php`的实现的完整列表：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have seen most of this before. We are defining active labels and active form
    elements that tie directly to our `ProjectUserForm` form model class. We populate
    our dropdown using the static method we implemented earlier on the project model
    class. We populate our Zii library autocomplete widget (`CJuiAutoComplete`) data
    with the method `createUsernameList()` we added to the project user form model
    class. We also added a simple link to the menu options to take us back to the
    project details page.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以前大部分都见过了。我们正在定义活动标签和活动表单元素，这些元素直接与我们的`ProjectUserForm`表单模型类相关联。我们使用我们在项目模型类上早期实施的静态方法填充下拉菜单。我们使用`createUsernameList()`方法填充我们的Zii库自动完成小部件（`CJuiAutoComplete`）数据，该方法已添加到项目用户表单模型类中。我们还在菜单选项中添加了一个简单的链接，以便返回到项目详细信息页面。
- en: The highlighted code in the previous code snippet is new to us. This is an example
    of using the flash message that we introduced and used in the `actionAdduser()`
    method. We access the message we set using `setFlash()` by asking the same user
    component if it has a flash message, using `hasFlash('succcess')`. We feed the
    `hasFlash()` method the exact name we gave it when we set the message. This is
    a nice way to present the user with some simple feedback about their previous
    request.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码片段中突出显示的代码对我们来说是新的。这是一个示例，说明了我们在`actionAdduser()`方法中引入并使用的闪烁消息。我们通过询问同一用户组件是否有闪烁消息（使用`hasFlash('succcess')`）来访问我们使用`setFlash()`设置的消息。我们向`hasFlash()`方法提供了我们在设置消息时给它的确切名称。这是向用户提供有关其先前请求的一些简单反馈的好方法。
- en: 'One other small change we made was to add a simple link from the project details
    page so we could access this from the application. The following highlighted line
    was added to the project `view.php` view file''s menu array:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的另一个小改变是在项目详细信息页面中添加了一个简单的链接，以便我们可以从应用程序中访问它。以下突出显示的行已添加到项目`view.php`视图文件的菜单数组中：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This gives us access to the new form when viewing the details of a project.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们在查看项目详细信息时可以访问新表单。
- en: Putting it all together
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有内容放在一起
- en: 'With all of these changes in place, we can navigate to our new form by viewing
    one of the project details pages. For example, when viewing project ID #1 via
    `http://localhost/trackstar/index.php?r=project/view&id=1`, in the right-hand
    side column menu of operations is a hyperlink **[Add User To Project]** and clicking
    on that link should display the following page:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些变化，我们可以通过查看项目详细信息页面之一来导航到我们的新表单。例如，当通过`http://localhost/trackstar/index.php?r=project/view&id=1`查看项目ID＃1时，在右侧列操作菜单中有一个超链接**[将用户添加到项目]**，单击该链接应显示以下页面：
- en: '![Putting it all together](graphics/8727_07_02.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![将所有内容放在一起](graphics/8727_07_02.jpg)'
- en: You can use the forms we have built previously to create new projects and users
    to ensure you have a few of them added to the application. Then you can play around
    with adding users to projects. As you type in the **Username** field, you will
    see suggestions for autocompletion. If you attempt to add a user that is not in
    the user database table, you should see an error telling you so. If you attempt
    to enter a user that has already been added to the project, you will receive an
    error telling you so. And upon successful additions, you will see a short flash
    message indicating success.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用我们以前构建的表单来创建新项目和用户，以确保将其中一些添加到应用程序中。然后，您可以尝试将用户添加到项目中。当您在**用户名**字段中输入时，您将看到自动完成的建议。如果您尝试添加一个不在用户数据库表中的用户，您应该会看到一个告诉您的错误。如果您尝试输入已添加到项目中的用户，您将收到一个告诉您的错误。在成功添加后，您将看到一个指示成功的简短闪烁消息。
- en: Now that we have the ability to assign users to projects and add them to our
    RBAC authorization hierarchy, we should alter our logic for when we are adding
    a new project. When a new project is added, it should assign the user who is adding
    the project as the `owner` of the project. This way, the creator of the project
    will have full administrative access to the project. I will leave this as homework
    for the reader. You can view a solution to this exercise by downloading the available
    source code for the TrackStar application that accompanies this book.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了将用户分配给项目并将它们添加到我们的RBAC授权层次结构的能力，我们应该改变我们添加新项目时的逻辑。添加新项目时，应将添加项目的用户分配为项目的“所有者”。这样，项目的创建者将对项目拥有完全的管理访问权限。我将把这留给读者作业。您可以通过下载附带本书的TrackStar应用程序的可用源代码来查看此练习的解决方案。
- en: Checking authorization level
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查授权级别
- en: The last thing we need to do to complete what we set out to do in this chapter
    is to add the authorization checks for the different functionality we have implemented.
    Earlier in this chapter we outlined, and then implemented, the RBAC authorization
    hierarchy for the different roles we have. Everything is in place to allow or
    deny access to functionality based on the permissions that have been granted to
    users within projects, with one exception. We have not yet implemented the authorization
    checks necessary when attempting to request functionality. The application is
    still using the simple access filter that is defined on each of our project, issue,
    and user controllers. We'll do this for one of our permissions and then leave
    the remaining implementation as an exercise for the reader.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章中我们设定的任务的最后一件事是为我们实现的不同功能添加授权检查。在本章的早些时候，我们概述并实施了我们拥有的不同角色的RBAC授权层次结构。一切都已准备就绪，以允许或拒绝基于已授予项目内用户的权限的功能访问，但有一个例外。当尝试请求功能时，我们尚未实施必要的授权检查。该应用程序仍在使用在我们的项目、问题和用户控制器上定义的简单访问过滤器。我们将为我们的权限之一执行此操作，然后将其余实现留给读者作为练习。
- en: 'We see from looking back at our authorization hierarchy that only project owners
    should be able to add new users to a project. So, let''s add this authorization
    check. We''ll hide the link for adding a user on the project details page unless
    the current user is in the *owner* role for that project (before implementing,
    you should make sure you have added at least one owner and one member or reader
    to a project so you can test them when complete). Open up the `protected/views/project/view.php`
    view file where we placed the link in the menu items for adding a new user. Remove
    that array element from the menu array items, and then push it on the end of the
    array only if the `checkAccess()` method returns `true`. The following code shows
    how the menu items should be defined:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们的授权层次结构，我们可以看到只有项目所有者才能向项目添加新用户。因此，让我们添加这个授权检查。除非当前用户在该项目的*owner*角色中，否则我们将隐藏项目详情页面上添加用户的链接（在实施之前，您应该确保您已经向项目添加了至少一个所有者和一个成员或读者，以便在完成后进行测试）。打开`protected/views/project/view.php`视图文件，在那里我们放置了添加新用户的菜单项。从菜单数组项中删除该数组元素，然后只有当`checkAccess()`方法返回`true`时，才将其推送到数组的末尾。以下代码显示了菜单项应该如何定义：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This implements the same approach we discussed earlier in the chapter. We call
    `checkAccess()` on the current user and send in the name of the permission we
    want to check. Also, since our roles are within the context of projects, we send
    in the project model instance as an array input. This will allow the business
    rule to execute, which has been defined in the authorization assignment. Now if
    we log in as a project owner for a particular project and navigate to that project
    details page, we'll see the menu option for adding a new user to the project.
    Conversely, if we log in as a user in the `member` or `reader` role of that same
    project, and again navigate to the details page, this link will not display.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这实现了我们在本章中讨论过的相同方法。我们在当前用户上调用`checkAccess()`并发送我们想要检查的权限的名称。此外，由于我们的角色是在项目的上下文中的，我们将项目模型实例作为数组输入发送。这将允许已在授权分配中定义的业务规则执行。现在，如果我们以特定项目的项目所有者身份登录，并导航到该项目的详情页面，我们将看到添加新用户到项目的菜单选项。相反，如果我们以同一项目的`member`或`reader`角色的用户身份登录，并再次导航到详情页面，这个链接将不会显示。
- en: 'This, of course, will not prevent a savvy user from gaining access to this
    functionality by navigating using the URL directly. For example, even while logged
    in to the application as a user in the `reader` role for, say, project #1, if
    I navigate directly to `http://localhost/trackstar/index.php?r=project/adduser&id=1`
    I can still access the form.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不会阻止一个精明的用户通过直接使用URL导航来获得这个功能。例如，即使作为项目＃1的`reader`角色的用户登录到应用程序，如果我直接导航到`http://localhost/trackstar/index.php?r=project/adduser&id=1`，我仍然可以访问表单。
- en: 'To prevent this, we need to add our access check directly to the action method
    itself. So, in the `ProjectController::actionAdduser()` method in the project
    controller class, we can add the check:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，我们需要直接将我们的访问检查添加到动作方法本身。因此，在项目控制器类中的`ProjectController::actionAdduser()`方法中，我们可以添加检查：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now when we attempt to access this URL directly, we will be denied access unless
    we are in the project *owner* role for the project.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们尝试直接访问这个URL时，除非我们是项目的*owner*角色，否则我们将被拒绝访问。
- en: We won't go through implementing the access checks for all of the other functionality.
    Each would be implemented in a similar manner. We leave this as an exercise for
    the reader. This implementation is not necessary in order to continue to follow
    along with the remaining code examples throughout the book.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会逐个实现所有其他功能的访问检查。每个都将以类似的方式实现。我们把这留给读者作为一个练习。这个实现对于继续跟随本书中剩余的代码示例并不是必需的。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have covered a lot in this chapter. First we were introduced to the basic
    access control filter that Yii provides as one method to allow and deny access
    to specific controller action methods. We used this approach to ensure that users
    be logged in to that application before gaining access to any of the main functionality.
    We then took a detailed walk through Yii's RBAC model, which allows for a much
    more sophisticated approach to access control. We built an entire user authorization
    hierarchy based on application roles. In the process, we were introduced to writing
    console applications in Yii, and to some of the benefits of this wonderful feature.
    We then built in new functionality to allow the addition of users to projects
    and being able to assign them to appropriate roles within those projects. Finally,
    we discovered how to implement the needed access checks throughout the application
    to utilize the RBAC hierarchy to appropriately grant/deny access to feature functionality.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容。首先，我们介绍了Yii提供的基本访问控制过滤器，作为允许和拒绝对特定控制器动作方法访问的一种方法。我们使用这种方法来确保用户在获得任何主要功能的访问权限之前必须登录到该应用程序。然后，我们详细介绍了Yii的RBAC模型，它允许更复杂的访问控制方法。我们基于应用程序角色构建了整个用户授权层次结构。在这个过程中，我们介绍了在Yii中编写控制台应用程序，并介绍了这一出色功能的一些好处。然后，我们增加了新功能，允许向项目添加用户，并能够将他们分配到这些项目中的适当角色。最后，我们发现了如何在整个应用程序中实现所需的访问检查，以利用RBAC层次结构来适当地授予/拒绝功能功能的访问权限。
- en: In the next chapter, we are going to add even more functionality for users,
    one of which is the ability to leave comments on our project issues.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为用户添加更多功能，其中之一是能够在我们的项目问题上留下评论。
