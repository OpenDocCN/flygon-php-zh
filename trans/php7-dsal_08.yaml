- en: Exploring Search Options
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索搜索选项
- en: Along with sorting, searching is one of the most used algorithms in the programming
    world. Whether we are searching our phone book, e-mails, database, or files, we
    are actually performing some sort of search technique to locate the item we wish
    to find. It is imperative that searching and sorting are the two most important
    components of programming. In this chapter, you will learn about different searching
    techniques and how efficient they are. We will also learn about different ways
    of searching tree data structures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除了排序，搜索是编程世界中最常用的算法之一。无论是搜索电话簿、电子邮件、数据库还是文件，我们实际上都在执行某种搜索技术来定位我们希望找到的项目。搜索和排序是编程中最重要的两个组成部分。在本章中，您将学习不同的搜索技术以及它们的效率。我们还将学习有关搜索树数据结构的不同搜索方式。
- en: Linear searching
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性搜索
- en: 'One of the most common ways of performing a search is to compare each item
    with the one we are looking for. This is known as linear search or sequential
    search. It is the most basic way of performing a search. If we consider that we
    have *n* items in a list, in the worst case, we have to search *n* items to find
    a particular item. We can iterate through a list or array to find an item. Let''s
    consider the following example:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 执行搜索的最常见方式之一是将每个项目与我们要查找的项目进行比较。这被称为线性搜索或顺序搜索。这是执行搜索的最基本方式。如果我们考虑列表中有*n*个项目，在最坏的情况下，我们必须搜索*n*个项目才能找到特定的项目。我们可以遍历列表或数组来查找项目。让我们考虑以下例子：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have a function named `search` , which takes two arguments. One is the list
    of numbers, and the other is the number we are looking for in the list. We are
    running a for loop to iterate through each item in the list and compare them with
    our item. If a match is found, we return true and do not continue with the search.
    However, if the loop ends and nothing is found, we return false at the end of
    the function definition. Let''s use the `search` function to find something using
    the following program:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`search`的函数，它接受两个参数。一个是数字列表，另一个是我们要在列表中查找的数字。我们运行一个for循环来遍历列表中的每个项目，并将它们与我们的项目进行比较。如果找到匹配项，我们返回true并且不继续搜索。然而，如果循环结束并且没有找到任何东西，我们在函数定义的末尾返回false。让我们使用`search`函数来使用以下程序查找一些东西：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we are generating a random array using PHP's built-in function range,
    with a range of 1 to 200 inclusive. Each item will have a gap of 5 like 1, 6,
    11, 16, and so on; then we are searching 31, which is in the list as we have 6,
    11, 16, 21, 26, 31, and so on. However, if we want to search for 32 or 33, then
    the item will not be found. So, for this case, our output will be `Found` .
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用PHP的内置函数range生成一个随机数组，范围是1到200。每个项目的间隔为5，如1、6、11、16等；然后我们搜索31，在列表中有6、11、16、21、26、31等。然而，如果我们要搜索32或33，那么项目将找不到。因此，对于这种情况，我们的输出将是`Found`。
- en: 'One thing we need to remember here is that we are not worried about whether
    our list is in any particular order or organized in a certain way. If the item
    we are looking for is in the first position, that will be the best result. The
    worst result can be the last item or an item that is not in the list. In both
    cases, we have to iterate over all *n* items of the list. Here is the complexity
    for linear/sequential search:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住的一件事是，我们不必担心我们的列表是否按任何特定顺序或特定方式组织。如果我们要查找的项目在第一个位置，那将是最好的结果。最坏的结果可能是最后一个项目或不在列表中的项目。在这两种情况下，我们都必须遍历列表的所有*n*个项目。以下是线性/顺序搜索的复杂性：
- en: '| Best time complexity | `O(1)` |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 最佳时间复杂度 | `O(1)` |'
- en: '| Worst time complexity | `O(n)` |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 最坏时间复杂度 | `O(n)` |'
- en: '| Average time complexity | `O(n)` |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 平均时间复杂度 | `O(n)` |'
- en: '| Space complexity (worst case) | `O(1)` |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 空间复杂度（最坏情况） | `O(1)` |'
- en: As we can see, the average or worst time complexity for a linear search is `O(n)`
    , and that does not change how we order the list of items. Now, if the items in
    the array are sorted in a particular order, then we might not have to do a linear
    search, and we can get a better result by doing a selective or calculative search.
    The most popular and well-known search algorithm is "binary search". Yes, it sounds
    like the binary search tree you learned in [Chapter 6](text00138.html) , *Understanding
    and Implementing Trees* , but we can use this algorithm without even constructing
    a binary search tree. So, let's explore this.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，线性搜索的平均或最坏时间复杂度为`O(n)`，这并不会改变我们对项目列表的排序方式。现在，如果数组中的项目按特定顺序排序，那么我们可能不必进行线性搜索，而可以通过选择性或计算性搜索获得更好的结果。最流行和知名的搜索算法是"二分搜索"。是的，这听起来像你在[第6章](text00138.html)中学到的二分搜索树，*理解和实现树*，但我们甚至可以在不构建二分搜索树的情况下使用这个算法。所以，让我们来探索一下。
- en: Binary search
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二分搜索
- en: 'Binary search is a very popular search algorithm in the programming world.
    In sequential search, we started from the beginning and scanned through each item
    to find the desired one. However, if the list is already sorted, then we do not
    need to search from the beginning or the end of the list. In a binary search algorithm,
    we start with the middle of the list, check whether the item in the middle is
    smaller or greater than the item we are looking for, and decide which way to go.
    This way, we divide the list by half and discard one half completely, just like
    the following image:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索是编程世界中非常流行的搜索算法。在顺序搜索中，我们从开头开始扫描每个项目以找到所需的项目。然而，如果列表已经排序，那么我们就不需要从列表的开头或结尾开始搜索。在二分搜索算法中，我们从列表的中间开始，检查中间的项目是比我们要找的项目小还是大，并决定要走哪条路。这样，我们将列表分成两半，并丢弃一半，就像下面的图片一样：
- en: '![](Image00063.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00063.jpg)'
- en: If we look at the preceding image, we have a sorted (ascending order) list of
    numbers in an array. We want to know whether item **7** is in the array or not.
    Since the array has 17 items (0 to 16 index), we will first go to the middle index,
    which is the eighth index for this example. Now, the eighth index has a value
    of **14** , which is greater than the value we are searching for, which is **7**
    . This means that if **7** is present in this array, it is to the left of **14**
    , since the numbers are already sorted. So, we are discarding the array from the
    eighth index to the sixteenth index as the number cannot be in that part of the
    array. Now, we repeat the same process and take the middle of the remaining part
    of the array, which is the third element of the remaining part. Now, the third
    element has a value of **6** , which is less than **7** . As a result, the item
    we are looking for is on the right-hand side of the third element, not on its
    left.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看前面的图片，我们有一个按升序排序的数字列表。我们想知道项目**7**是否在数组中。由于数组有17个项目（0到16索引），我们将首先转到中间索引，对于这个示例来说是第八个索引。现在，第八个索引的值为**14**，大于我们要搜索的值**7**。这意味着如果**7**在这个数组中，它在**14**的左边，因为数字已经排序。因此，我们放弃了从第八个索引到第十六个索引的数组，因为数字不能在数组的那一部分。现在，我们重复相同的过程，并取数组剩余部分的中间部分，即剩余部分的第三个元素。现在，第三个元素的值为**6**，小于**7**。因此，我们要找的项目在剩余部分的第三个元素的右侧，而不是左侧。
- en: Now, we will check the fourth element to the seventh element of the array, with
    the middle element to now point at the fifth element. The fifth element value
    is **8** , which is more than **7** , the one we are looking for. So, we have
    to consider the left-hand side of the fifth element to find the item we are looking.
    This time, we have only two items remaining for the array to check, and the elements
    are fourth and fifth elements. As we are moving to the left, we will check the
    fourth element, and we see the value matches with **7** , which we are looking
    for. If the fourth index value was not **7** , the function will return false
    as there are no more elements left for checking. If we look at the arrow marks
    in the preceding image, we can see that within four steps, we have found the value
    we are looking for, whereas we had to take 17 steps to check all 17 numbers in
    a linear search function in a worst case situation. This is known as a binary
    search, or half-interval search, or logarithmic search.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检查数组的第四个元素到第七个元素，中间元素现在指向第五个元素。第五个元素的值为**8**，大于**7**，我们要找的值。因此，我们必须考虑第五个元素的左侧来找到我们要找的项目。这次，我们只剩下两个项目要检查，即第四个和第五个元素。当我们向左移动时，我们将检查第四个元素，我们看到值与我们要找的**7**匹配。如果第四个索引值不是**7**，函数将返回false，因为没有更多的元素可以检查。如果我们看一下前面图片中的箭头标记，我们可以看到在四步内，我们已经找到了我们要找的值，而在线性搜索函数中，我们需要花17步来检查所有17个数字，这是最坏情况下的二分搜索，或半间隔搜索，或对数搜索。
- en: 'As we have seen in our last image, we have to divide our initial list into
    halves and continue until we reach a point where we cannot make any further division
    to find our item. We can use an iterative way or recursive way to perform the
    division part. We will actually use both ways. So, let''s first define the pseudocode
    of a binary search in the iterative way:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一张图片中看到的，我们必须将初始列表分成两半，并继续直到达到一个不能再进一步分割以找到我们的项目的地步。我们可以使用迭代方式或递归方式来执行分割部分。我们将实际上使用两种方式。因此，让我们首先定义迭代方式中的二分搜索的伪代码：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we look at the pseudocode, we can see that we are adjusting our low and
    high based on our mid value. If the value we are looking for is greater than what
    we have in mid, we are adjusting the lower bound to be `mid+1` . If it''s less
    than the mid value, then we are setting the higher value as `mid-1` . It continues
    until the lower value becomes bigger than the higher value or the item is found.
    If the item is not found, we return false at the end of the function. Now, let''s
    implement the pseudocode using PHP:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下伪代码，我们可以看到我们根据中间值调整了低和高。如果我们要查找的值大于中间值，我们将调整下界为`mid+1`。如果小于中间值，则将上界设置为`mid-1`。直到下界变大于上界或找到项目为止。如果未找到项目，我们在函数末尾返回false。现在，让我们使用PHP实现伪代码：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In our implementation, we have followed most of the pseudocode in the preceding
    page. Now, let''s run the code with two searches, where we know one value is in
    the list and one is not in the list:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，我们遵循了前一页中的大部分伪代码。现在，让我们运行两次搜索的代码，我们知道一个值在列表中，一个值不在列表中：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As we know from our previous linear search code, `31` is in the list, and it
    should show `Found` . However, `500` is not in the list, and it should show `Not
    found` . If we run the code, here is the output we will see in our console:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前的线性搜索代码，`31`在列表中，应该显示`Found`。然而，`500`不在列表中，应该显示`Not found`。如果我们运行代码，这是我们在控制台中看到的输出：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will now write the recursive algorithm for the binary search, which can
    also be handy for us. The pseudocode will require us to send extra arguments every
    time we call the function. We need to send the low and high with every recursive
    call, which we did not do for the iterative one:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将为二分搜索编写递归算法，这对我们也很方便。伪代码将要求我们在每次调用函数时发送额外的参数。我们需要在每次递归调用时发送低和高，这是迭代调用中没有做的：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can see from the preceding pseudocode that we are now having low and high
    as parameters, and in each call, the new values are sent as arguments. We have
    the boundary condition where we are checking whether the low is bigger than the
    high. The code looks smaller and cleaner compared to the iterative one. Now, let''s
    implement this using PHP 7:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的伪代码中我们可以看到，现在我们有低和高作为参数，在每次调用中，新值作为参数发送。我们有边界条件，检查低是否大于高。与迭代的代码相比，代码看起来更小更干净。现在，让我们使用PHP
    7来实现这个：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s use the following code to run this search recursively:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下代码来递归运行这个搜索：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see from the preceding code, we sent `0` and `count($numbers)-1` in
    each call of recursive binary search for the first time. Then, this high and low
    is auto-adjusted on each recursive call based on the mid value. So, we have seen
    both the iterative and recursive implementation of binary search. Based on our
    needs, we can use any one of these in our program. Now, let's analyze the binary
    search algorithm and find out how it is better than our linear or sequential search
    algorithm.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从前面的代码中看到的，我们在递归二分搜索的每次调用中发送`0`和`count($numbers)-1`。然后，这个高和低在每次递归调用时根据中间值自动调整。因此，我们已经看到了二分搜索的迭代和递归实现。根据我们的需求，我们可以在程序中使用其中一个。现在，让我们分析二分搜索算法，并找出它为什么比我们的线性或顺序搜索算法更好。
- en: Analysis of binary search algorithm
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二分搜索算法的分析
- en: 'So far, we have seen that for each iteration, we are dividing the list by half
    and discarding one half completely for searching. This makes our list look like
    *n/2* , *n/4* , *n/8* , and so on after 1, 2, and 3 iterations, respectively.
    So, we can say that after Kth iteration, *n/2^k* items will be left. We can easily
    say that, the last iteration occurs when *n/2^k = 1* , or we can say that, *2^K
    = n* . So, taking log from both side yields, *k = log(n)* , which is the worst
    case running time for binary search algorithm. Here is the complexity for binary
    search algorithm:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到，对于每次迭代，我们都将列表分成一半，并丢弃一半进行搜索。这使得我们的列表在1、2和3次迭代后看起来像*n/2*、*n/4*、*n/8*，依此类推。因此，我们可以说，在第K次迭代后，将剩下*n/2^k*个项目。我们可以轻松地说，最后一次迭代发生在*n/2^k
    = 1*时，或者我们可以说，*2^K = n*。因此，从两边取对数得到，*k = log(n)*，这是二分搜索算法的最坏情况运行时间。以下是二分搜索算法的复杂性：
- en: '| Best time complexity | `O(1)` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 最佳时间复杂度 | `O(1)` |'
- en: '| Worst time complexity | `O(log n)` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 最坏时间复杂度 | `O(log n)` |'
- en: '| Average time complexity | `O(log n)` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 平均时间复杂度 | `O(log n)` |'
- en: '| Space complexity (worst case) | `O(1)` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 空间复杂度（最坏情况） | `O(1)` |'
- en: If our array or list is already sorted, it is always preferred to apply binary
    search for better performance. Now, whether the list is sorted in the ascending
    order or descending order, it can have some impact on our calculation of low and
    high. The logic we have seen so far is for the ascending order. If an array is
    sorted in the descending order, the logic will be swapped where greater than will
    become less than, and vice versa. One thing to notice here is that the binary
    search algorithm provides us with the index we have found of the search item.
    However, there might be some cases where we not only need to know whether the
    number exists, but also to find the first appearance or last appearance in the
    list. If we use binary search algorithm, then it will return true or maximum index
    number, where the search algorithm found the number. However, it might not be
    the first appearance or last appearance. For that, we will modify the binary search
    algorithm a little, which we will call repetitive binary search tree algorithm.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的数组或列表已经排序，总是更倾向于应用二分搜索以获得更好的性能。现在，无论列表是按升序还是降序排序，都会对我们计算的低和高产生一些影响。到目前为止，我们看到的逻辑是针对升序的。如果数组按降序排序，逻辑将被交换，大于将变成小于，反之亦然。这里需要注意的一点是，二分搜索算法为我们提供了搜索项的索引。然而，可能有一些情况，我们不仅需要知道数字是否存在，还需要找到列表中的第一次出现或最后一次出现。如果我们使用二分搜索算法，它将返回true或最大索引号，搜索算法找到数字的地方。然而，这可能不是第一次出现或最后一次出现。为此，我们将稍微修改二分搜索算法，称之为重复二叉搜索树算法。
- en: Repetitive binary search tree algorithm
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复二叉搜索树算法
- en: 'Consider the following image. We have an array with repetitive items. If we
    try to find the first appearance of **2** from the array, binary search algorithm
    from the last section will give us the fifth element. However, from the following
    image, we can see clearly it is not the fifth element; instead, it is the second
    element, which is the correct answer. So, a modification is required in our binary
    search algorithm. The modification will be a repetitive searching until we reach
    the first appearance:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图片。我们有一个包含重复项的数组。如果我们尝试从数组中找到**2**的第一次出现，上一节的二分搜索算法将给我们第五个元素。然而，从下面的图片中，我们可以清楚地看到它不是第五个元素；相反，它是第二个元素，这才是正确的答案。因此，我们需要对我们的二分搜索算法进行修改。修改将是重复搜索，直到我们找到第一次出现：
- en: '![](Image00064.gif)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00064.gif)'
- en: 'Here is the modified solution using iterative approach:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用迭代方法的修改后的解决方案：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As we can see, first we are checking whether the mid has the value we are looking
    for. If it is true, then we are assigning the middle index as first occurrence,
    and we will search the left of the middle element to check for any occurrences
    of the number we are looking for. We then continue the iteration until we have
    searched each index (`$low` is greater than `$high` ). If no further occurrence
    is found, then the variable first occurrence will have the value of the first
    index where we found the item. If not, we are returning `-1` as usual. Let''s
    run the following code to check whether our results are correct or not:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，首先我们要检查中间值是否是我们要找的值。如果是真的，那么我们将中间索引分配为第一次出现，并且我们将搜索中间元素的左侧以检查我们要找的数字的任何出现。然后我们继续迭代，直到我们搜索了每个索引（`$low`大于`$high`）。如果没有找到进一步的出现，那么第一次出现的变量将具有我们找到该项的第一个索引的值。如果没有，我们像往常一样返回`-1`。让我们运行以下代码来检查我们的结果是否正确：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we have an array with repetitive values of 2, 3, 4, and 5\. We want to
    search the array and find the position or index where the value has appeared for
    the first time. For example, if we are searching `2` in a regular binary search
    function, it will return eighth as the position where it found the value `2` .
    In our case, we are actually looking for the second index, which actually holds
    the first appearance of item `2` . Our function `repetitiveBinarySearch` does
    exactly that, and we are storing the return position to a variable called `$pos`
    . We are showing the output if the number is found along with the position. Now,
    if we run the preceding code in our console, we will have the following output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个包含重复值的数组，值为2、3、4和5。我们想搜索数组，并找到值第一次出现的位置或索引。例如，如果我们在一个常规的二分搜索函数中搜索 `2`，它会返回第八个位置，即它找到值
    `2` 的位置。在我们的情况下，我们实际上是在寻找第二个索引，它实际上保存了项目 `2` 的第一次出现。我们的函数 `repetitiveBinarySearch`
    正是这样做的，我们将返回的位置存储到一个名为 `$pos` 的变量中。如果找到数字，我们将显示输出以及位置。现在，如果我们在控制台中运行前面的代码，我们将得到以下输出：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This matches our expected results. So, we can say we now have a repetitive binary
    search algorithm to find first and last occurrences of an item from a given sorted
    list. This might be a very handy function to solve many problems.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这符合我们的预期结果。因此，我们现在有了一个重复的二分搜索算法，用于查找给定排序列表中项目的第一次和最后一次出现。这可能是一个非常方便的函数来解决许多问题。
- en: So far, from our examples and analysis, we can conclude that binary searching
    is definitely faster than linear searching. However, the major prerequisite is
    to have the list sorted before applying binary search. Applying binary search
    in an unsorted array will lead us to inaccurate results. There can be situations
    where we receive an array and we are not sure whether the array is sorted or not.
    Now, the question is, "Should we sort the array first and apply binary search
    algorithm in such cases? Or should we just run a linear search algorithm to find
    an item?" Let's discuss this a little, so that we know how to handle such situations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，从我们的例子和分析来看，我们可以得出结论，二分搜索肯定比线性搜索更快。然而，主要的前提是在应用二分搜索之前对列表进行排序。在未排序的数组中应用二分搜索会导致我们得到不准确的结果。有时候我们会收到一个数组，而我们不确定这个数组是否已经排序。现在，问题是，“在这种情况下，我们应该先对数组进行排序然后应用二分搜索算法吗？还是应该只运行线性搜索算法来找到一个项目？”让我们讨论一下这个问题，这样我们就知道如何处理这种情况。
- en: Searching an unsorted array - should we sort first?
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索一个未排序的数组 - 我们应该先排序吗？
- en: So now, we are in a situation where we have an array with *n* items and they
    are not sorted. Since we know binary search is faster, we have decided to sort
    it first and then search for the item using a binary search. If we do so, we have
    to remember that the best sorting algorithms have a worst time complexity of `O(nlog
    n)` , and for binary search, the worst case complexity is `O(log n)` . So, if
    we sort and then apply the binary search, the complexity will be `O(n log n)`
    as it is the biggest one compared to `O(log n)` . However, we also know that for
    any linear or sequential search (sorted or unsorted), the worst time complexity
    is `O(n)` , which is much better than `O(n log n)` . Based on the complexity comparison
    of `O(n)` and `O(n log n)` , we can clearly say that performing a linear search
    is a better option if the array is not sorted.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在，我们处于这样一种情况：我们有一个包含 *n* 个项目的数组，它们没有排序。由于我们知道二分搜索更快，我们决定先对其进行排序，然后使用二分搜索来搜索项目。如果我们这样做，我们必须记住，最好的排序算法的最坏时间复杂度为
    `O(nlog n)`，而对于二分搜索，最坏情况的复杂度为 `O(log n)`。因此，如果我们先排序然后应用二分搜索，复杂度将为 `O(n log n)`，因为这是与
    `O(log n)` 相比最大的。然而，我们也知道，对于任何线性或顺序搜索（无论是排序还是未排序），最坏的时间复杂度都是 `O(n)`，这比 `O(n log
    n)` 要好得多。根据 `O(n)` 和 `O(n log n)` 的复杂度比较，我们可以清楚地说，如果数组没有排序，执行线性搜索是一个更好的选择。
- en: Let's consider another situation where we need to search a given array a multiple
    number of times. Let's denote *k* as the number of times we want to search the
    array. If *k* is 1, then we can easily apply our linear approach discussed in
    the last paragraph. It will be fine if the value of *k* is smaller compared to
    the size of the array, which is denoted by *n* . However, if the value of *k*
    is closer or bigger than *n* , then we have some problems applying the linear
    approach here.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一种情况，我们需要多次搜索一个给定的数组。让我们用 *k* 表示我们想要搜索数组的次数。如果 *k* 为1，那么我们可以轻松地应用上一段讨论的线性方法。如果
    *k* 的值相对于数组的大小 *n* 来说比较小，那么也没问题。然而，如果 *k* 的值接近或大于 *n*，那么我们在这里应用线性方法就会有一些问题。
- en: Let's assume that *k = n* , then for *n* time, linear search will have a complexity
    of `O(n² )` . Now, if we go for the sort and then search option then even if *k*
    is bigger, the onetime sorting will take `O(n log n)` time complexity. Then, each
    search will take `O(log n)` , and *n* times searching will have a worst case of
    `O(n log n)` complexity. If we take the worst running case here, we will have
    `O(n log n)` for sorting and searching *k* items, which is better than sequential
    searching.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *k = n*，那么对于 *n* 次搜索，线性搜索的复杂度将为 `O(n²)`。现在，如果我们选择排序然后搜索，即使 *k* 更大，一次排序也只需要
    `O(n log n)` 的时间复杂度。然后，每次搜索只需要 `O(log n)`，而 *n* 次搜索的最坏情况复杂度为 `O(n log n)`。如果我们在这里考虑最坏的情况，那么对于排序和搜索
    *k* 个项目，我们将得到 `O(n log n)`，这比顺序搜索要好。
- en: So, we can come to the conclusion that if a number of search operations is smaller
    compared to the size of the array, it is better not to sort the array and perform
    the sequential search. However, if the number of search operation is bigger compared
    to the size of array, it is better to sort the array first and then apply the
    binary search.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以得出结论：如果搜索操作的次数较小，与数组的大小相比，最好不要对数组进行排序，而是执行顺序搜索。然而，如果搜索操作的次数较大，与数组的大小相比，最好先对数组进行排序，然后应用二分搜索。
- en: 'Over the years, the binary search algorithm evolved and came up with different
    variations. Instead of choosing the middle index every time, we can make calculative
    decisions to choose which index we should use next. That is what makes these variations
    work efficiently. We will now talk about two such variations of binary search
    algorithm: interpolation search and exponential search.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，二分搜索算法不断发展，并出现了不同的变体。我们可以通过计算决策来选择下一个应该使用的索引，而不是每次选择中间索引。这就是这些变体能够高效工作的原因。现在我们将讨论二分搜索算法的两种变体：插值搜索和指数搜索。
- en: Interpolation search
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值搜索
- en: 'In binary search algorithm, we always start with the middle of the array to
    start the searching process. If an array is uniformly distributed and we are looking
    for an item, which, may be close to the end of array, then searching from the
    middle might not sound like a good choice to us. Interpolation search can be very
    helpful in such cases. Interpolation search is an improvement over binary search
    algorithm. Interpolation search may go to different location based on the value
    of the searched key. For example, if we are searching a key that is close to the
    beginning of the array, it will go to the first part of the array instead of starting
    from the middle. The position is calculated using a probe position calculator
    equation, which looks like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在二分搜索算法中，我们总是从数组的中间开始搜索过程。如果数组是均匀分布的，并且我们正在寻找一个可能接近数组末尾的项目，那么从中间开始搜索可能对我们来说并不是一个好选择。在这种情况下，插值搜索可能非常有帮助。插值搜索是对二分搜索算法的改进。插值搜索可能根据搜索关键字的值而转到不同的位置。例如，如果我们正在搜索一个接近数组开头的关键字，它将转到数组的第一部分，而不是从中间开始。位置是使用探测位置计算器方程计算的，如下所示：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we can see, we are going from our generic `mid = (low+high)/2` equation
    to a more complex looking equation. This formula will return a higher value if
    the searched key is closer to `arr[high]` and a much lower value if the key is
    closer to `arr[low]` . Now, let''s implement this search method with the help
    of our binary search code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们从通用的 `mid = (low+high)/2` 方程转变为一个更复杂的方程。如果搜索的关键字更接近 `arr[high]`，这个公式将返回一个更高的值，如果关键字更接近
    `arr[low]`，则返回一个更低的值。现在，让我们借助我们的二分搜索代码来实现这种搜索方法：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we are calculating in a different way. Though it is taking more computational
    steps, the good part is that if the list is uniformly distributed, then the average
    complexity of this algorithm is `O(log (log n))` , which is much better compared
    to binary search's complexity of `O(log n)` . Also, we have to be careful if the
    distributions of the keys are not uniform. In this case, the performance of the
    interpolation search could degrade.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以一种不同的方式进行计算。尽管它需要更多的计算步骤，但好处是，如果列表是均匀分布的，那么该算法的平均复杂度为 `O(log (log n))`，这与二分搜索的复杂度
    `O(log n)` 相比要好得多。此外，我们必须小心，如果关键字的分布不均匀，插值搜索的性能可能会下降。
- en: Now, we will explore another variation of binary search known as exponential
    search, which can improve the algorithm.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨另一种二分搜索的变体，称为指数搜索，它可以改进算法。
- en: Exponential search
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指数搜索
- en: 'In binary search, we are searching the whole list for a given key. Exponential
    search improves binary search by deciding the lower and upper bound of the search
    so that we do not end up searching the whole list. It improves the number of comparisons
    we need to find an element. The search is done in the following two steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在二分搜索中，我们为给定的关键字搜索整个列表。指数搜索通过决定搜索的下限和上限来改进二分搜索，以便我们不会最终搜索整个列表。它改进了我们需要找到一个元素所需的比较次数。搜索分为以下两个步骤：
- en: We determine the bound size by looking for the first exponent *k* where the
    value of *2^k* is greater than the search item. Now, *2^k* and *2^(k-1)* become
    the upper bound and lower bound, respectively.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过寻找第一个指数 *k*，其中 *2^k* 的值大于搜索项，来确定边界大小。现在，*2^k* 和 *2^(k-1)* 分别成为上限和下限。
- en: Apply binary search algorithm for the bound *2^k* and *2^(k-1)* .
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 *2^k* 和 *2^(k-1)* 进行二分搜索算法。
- en: 'Let''s now implement the exponential search using our recursive `binarySearch`
    function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用我们的递归 `binarySearch` 函数来实现指数搜索：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, in step one, we are taking *i* steps to determine the boundary. So, the
    algorithm takes `O(log i)` complexity. We have to remember that here, *i* is much
    smaller than *n* . Then, we are doing a binary search with a bound of *2^j* to
    *2^(j-1)* where *j = log i* . We know binary search takes `O(log n)` complexity
    where *n* is the size of the list. However, since we are doing a smaller bound
    search, we are actually searching *2 ^(log i) \ - 2 ^(log i) - 1 = 2 ^(log i -
    1)* size. So, the complexity of this bound will be log *(2 ^(log i - 1) ) = log
    (i) - 1 = O(log i)* .
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们需要 *i* 步来确定边界。因此，该算法的复杂度为 `O(log i)`。我们必须记住，这里的 *i* 要远小于 *n*。然后，我们使用
    *2^j* 到 *2^(j-1)* 进行二分搜索，其中 *j = log i*。我们知道二分搜索的复杂度为 `O(log n)`，其中 *n* 是列表的大小。然而，由于我们正在进行较小范围的搜索，实际上我们搜索的是
    *2 ^(log i) \ - 2 ^(log i) - 1 = 2 ^(log i - 1)* 大小。因此，这个边界的复杂度将是 log *(2 ^(log
    i - 1) ) = log (i) - 1 = O(log i)*。
- en: 'So, the complexity of the exponential search is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，指数搜索的复杂性如下：
- en: '| Best time complexity | `O(1)` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 最佳时间复杂度 | `O(1)` |'
- en: '| Worst time complexity | `O(log i)` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 最坏时间复杂度 | `O(log i)` |'
- en: '| Average time complexity | `O(log i)` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 平均时间复杂度 | `O(log i)` |'
- en: '| Space complexity (worst case) | `O(1)` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 空间复杂度（最坏情况） | `O(1)` |'
- en: Search using hash table
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用哈希表进行搜索
- en: 'Hash table can be a very efficient data structure when it comes to search operations.
    Since hash tables store data in an associative manner, if we know where to look
    for the data, we can easily get the data quickly. In the hash table, each data
    has a unique index associated with it. If we know which index to look at, we can
    find the key very easily. Usually, in other programming languages, we have to
    use a separate hash function to calculate the hash index to store the value. The
    hash function is designed to generate the same index for the same key and also
    avoid collision. However, one of the great features of PHP is that PHP array itself
    is a hash table, in its underlying C implementation. Since an array is dynamic,
    we do not have to worry about the size of array or overflow array with many values.
    We need to store the values in an associative array so that we can associate the
    value with a key. The key can be the value itself if it is a string or an integer.
    Let''s run an example to understand searching with a hash table:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表在搜索操作时可以是非常高效的数据结构。由于哈希表以关联方式存储数据，如果我们知道在哪里查找数据，我们可以很容易地快速获取数据。在哈希表中，每个数据都有一个与之关联的唯一索引。如果我们知道要查看哪个索引，我们可以很容易地找到键。通常，在其他编程语言中，我们必须使用单独的哈希函数来计算哈希索引以存储值。哈希函数旨在为相同的键生成相同的索引，并避免冲突。然而，PHP的一个伟大特性是PHP数组本身就是一个哈希表，在其底层C实现中。由于数组是动态的，我们不必担心数组的大小或溢出数组的值。我们需要将值存储在关联数组中，以便我们可以将值与键关联起来。如果是字符串或整数，键可以是值本身。让我们运行一个例子来理解使用哈希表进行搜索：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have just built a simple random associative array where value and key are
    the same. Since we are using PHP array, though value can have a range of 1 to
    500, the actual array size is anything from 10 to 30\. If it were in any other
    language, we would have constructed an array with a size of 501 to accommodate
    this value to be a key. That is why the hash function is used to calculate the
    index. If we want, we can also use the PHP''s built-in function for hashing:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚构建了一个简单的随机关联数组，其中值和键是相同的。由于我们使用的是PHP数组，尽管值可以在1到500的范围内，实际数组大小可以是10到30之间的任何值。如果是在其他语言中，我们将构建一个大小为501的数组来容纳这个值作为键。这就是为什么要使用哈希函数来计算索引。如果需要的话，我们也可以使用PHP的内置哈希函数：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first parameter takes the type of algorithm we want to use for hashing.
    We can choose from md5, sha1, sha256, crc32, and so on. Each of the algorithms
    produces a fixed length hash output, which we can use as key for our hash table.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数采用我们想要用于哈希的算法类型。我们可以选择md5、sha1、sha256、crc32等。每个算法都会产生一个固定长度的哈希输出，我们可以将其用作哈希表的键。
- en: If we look at our searching part, we can see that we are actually checking the
    associated index directly. This makes our searching in complexity `O(1)` . In
    PHP, it might be beneficial to use the hash table for quick searching even without
    using the hash function. However, we can always use the hash function if we want.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下我们的搜索部分，我们可以看到我们实际上是直接检查相关的索引。这使得我们的搜索复杂度为`O(1)`。在PHP中，使用哈希表进行快速搜索可能是有益的，即使不使用哈希函数。但是，如果需要的话，我们总是可以使用哈希函数。
- en: So far, we have covered searching based on arrays and linear structures. We
    will now shift our focus to hierarchical data structure searching such as searching
    trees and graphs. Though we have not discussed graphs yet (we will discuss them
    in the next chapter), we will keep our focus on tree searching, which can also
    be applied in graph searching.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了基于数组和线性结构的搜索。现在我们将把重点转移到层次化数据结构搜索，比如搜索树和图。虽然我们还没有讨论图（我们将在下一章讨论），但我们将把重点放在树搜索上，这也可以应用于图搜索。
- en: Tree searching
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树搜索
- en: One of the best ways to search hierarchical data is to create a search tree.
    In [Chapter 6](text00138.html) , *Understanding and Implementing Trees* , we saw
    how to construct a binary search tree and increase the efficiency in searching.
    We have also discovered different ways to traverse a tree. Now, we will explore
    the two most popular ways of searching a tree structure commonly known as breadth
    first search (BFS) and depth first search (DFS).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索层次化数据的最佳方法之一是创建搜索树。在[第6章](text00138.html)中，*理解和实现树*，我们看到了如何构建二叉搜索树并提高搜索效率。我们还发现了遍历树的不同方法。现在，我们将探索两种最流行的搜索树结构的方式，通常称为广度优先搜索（BFS）和深度优先搜索（DFS）。
- en: Breadth first search
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广度优先搜索
- en: 'In a tree structure, a root is connected to its child node, and each child
    node can be represented as a tree. We have already seen this in [Chapter 6](text00138.html)
    , *Understanding and Implementing Trees* . In a breadth first search, popularly
    known as BFS, we start from a node (mostly root node) and first visit all adjacent
    or neighbor nodes before visiting the other neighbor nodes. In other words, we
    have to move level by level while we are applying BFS. As we search level by level,
    this technique is known as breadth first search. In the following tree structure,
    we can use BFS:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在树结构中，根节点连接到其子节点，每个子节点都可以表示为一棵树。我们在[第6章](text00138.html)中已经看到了这一点，*理解和实现树*。在广度优先搜索中，通常称为BFS，我们从一个节点（通常是根节点）开始，首先访问所有相邻或邻居节点，然后再访问其他邻居节点。换句话说，我们必须逐层移动，而我们应用BFS。由于我们逐层搜索，这种技术被称为广度优先搜索。在下面的树结构中，我们可以使用BFS：
- en: '![](Image00065.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00065.jpg)'
- en: 'For this tree, the BFS will follow the nodes like this: ![](Image00066.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这棵树，BFS将按照以下节点进行：![](Image00066.jpg)
- en: 'The pseudocode of BFS will look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: BFS的伪代码如下：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can see that we have kept one queue for tracking which nodes we need to visit.
    We can keep another queue to hold the sequence of visits and return it to show
    the visit sequence. Now, we will implement the BFS using PHP 7.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们保留了一个队列来跟踪我们需要访问的节点。我们可以保留另一个队列来保存访问的顺序，并将其返回以显示访问顺序。现在，我们将使用PHP 7来实现BFS。
- en: Implementing breadth first search
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现广度优先搜索
- en: 'Since we have not covered the graph in detail so far, we will keep our implementation
    for BFS and DFS strictly for tree structure. Also, we will use the generic tree
    structure we have seen in [Chapter 6](text00138.html) , *Understanding and Implementing
    Trees* , (not even binary tree). We will use the same `TreeNode` class to define
    our nodes and relationship with children. So, let''s now define the `Tree` class
    with BFS functionality:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有详细介绍图，因此我们将严格将BFS和DFS的实现保留在树结构中。此外，我们将使用我们在[第6章](text00138.html)中看到的通用树结构，*理解和实现树*，（甚至不是二叉树）。我们将使用相同的`TreeNode`类来定义我们的节点和与子节点的关系。因此，现在让我们定义具有BFS功能的`Tree`类：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We have implemented the BFS method inside the tree class. We are taking the
    root node as the starting point for the breadth first search. Here, we have two
    queues: one for keeping the nodes that we need to visit, and one for nodes which
    we have visited. We are also returning the visited queue at the end of the method.
    Let''s now imitate the tree we have seen at the beginning of the section. We want
    to put the data just like the tree shown in the image and also check whether the
    BFS actually returns our expected pattern of; ![](Image00066.jpg) :'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在树类内部实现了BFS方法。我们以根节点作为广度优先搜索的起点。在这里，我们有两个队列：一个用于保存我们需要访问的节点，另一个用于我们已经访问的节点。我们还在方法的最后返回了访问的队列。现在让我们模仿一下我们在本节开头看到的树。我们想要像图中显示的树一样放置数据，并检查BFS是否实际返回我们期望的模式：![](Image00066.jpg)：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We are building the whole tree structure here by creating nodes and attaching
    them to root and other nodes. Once the tree is done, we are calling the `BFS`
    method to find the full sequence of traversal. The `while` loop at the end is
    printing sequences of our visited nodes. Here is the output of the preceding code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里通过创建节点并将它们附加到根和其他节点来构建整个树结构。一旦树完成，我们就调用`BFS`方法来找到遍历的完整序列。最后的`while`循环打印了我们访问的节点序列。以下是前面代码的输出：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have received our expected result. Now, if we want to search to find whether
    a node is there or not, we can add a simple condition check for our `$current`
    node value. If it matches, then we can return the visited queue.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经收到了我们期望的结果。现在，如果我们想搜索以查找节点是否存在，我们可以为我们的`$current`节点值添加一个简单的条件检查。如果匹配，那么我们可以返回访问的队列。
- en: The BFS has a worst complexity of **O** (*|V| + |E|* ), where *V* is the number
    of vertices or nodes and *E* is the number of edges or connections between the
    nodes. For space complexity, worst case is **O** (*|V|* ).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: BFS的最坏复杂度为**O**(*|V| + |E*),其中*V*是顶点或节点的数量，*E*是节点之间的边或连接的数量。对于空间复杂度，最坏情况是**O**(*|V|*)。
- en: The graph BFS is similar, but with a minor difference. Since the graph can be
    cyclic (can create a loop), we need to make sure we are not visiting the same
    node again and again to create an infinite loop. In order to avoid revisiting
    graph nodes, we have to keep track of the node we have visited. For marking a
    visited node, we can either use a queue, or use a graph coloring algorithm. We
    will explore this in the next chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图的BFS类似，但有一点不同。由于图可能是循环的（可以创建循环），我们需要确保我们不会一遍又一遍地访问相同的节点以创建无限循环。为了避免重新访问图节点，我们必须跟踪我们已经访问的节点。为了标记已访问的节点，我们可以使用队列，或使用图着色算法。我们将在下一章中探讨这一点。
- en: Depth first search
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度优先搜索
- en: 'Depth first search, or DFS, is a search technique where we start searching
    from a node and go as deep as possible to the node from the target node through
    the branches. DFS is different from BFS, and we try to dig deeper instead of spreading
    out first. DFS grows vertically and backtracks when it reaches the end of the
    branch and moves the next available adjacent nodes until the search is over. We
    can take the same tree image from the last section, which is shown as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索，或DFS，是一种搜索技术，我们从一个节点开始搜索，并尽可能深入到目标节点通过分支。DFS不同于BFS，我们尝试更深入地挖掘而不是首先扩散。DFS垂直增长，并在到达分支的末端时回溯，并移动到下一个可用的相邻节点，直到搜索结束。我们可以从上一节中取相同的树图像，如下所示：
- en: '![](Image00067.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00067.jpg)'
- en: 'If we apply DFS here, the traversal will be ![](Image00068.jpg) . We start
    from the root and then visit the first child, which is **3** . However, instead
    of going to **10** like the BFS, we will explore the child nodes of **3** and
    do this repeatedly until we reach the bottom of the branch. In BFS, we had taken
    the iterative approach. For DFS, we will take the recursive approach. Let''s now
    write the pseudocode for DFS:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这里应用DFS，遍历将是![](Image00068.jpg)。我们从根开始，然后访问第一个子节点，即**3**。然而，与BFS不同，我们将探索**3**的子节点，并重复此过程，直到达到分支的底部。在BFS中，我们采用了迭代方法。对于DFS，我们将采用递归方法。现在让我们为DFS编写伪代码：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Implementing depth first search
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现深度优先搜索
- en: 'The pseudocode for DFS looks straightforward. In order to track the sequence
    of node visits, we need to use a queue, which will track the nodes inside our
    `Tree` class. Here is our implementation of `Tree` class with recursive DFS:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: DFS的伪代码看起来很简单。为了跟踪节点访问的顺序，我们需要使用一个队列，它将跟踪我们`Tree`类内部的节点。以下是我们带有递归DFS的`Tree`类的实现：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As we can see, we have added one extra property in the tree class `$visited`
    to keep track of the visited nodes. When we are calling the `DFS` method, we are
    adding the node to the queue. Now, if we use the same tree structure from the
    previous section, and just add the DFS call and fetch the visited part, it will
    look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们在树类中添加了一个额外的属性`$visited`来跟踪访问的节点。当我们调用`DFS`方法时，我们将节点添加到队列中。现在，如果我们使用上一节中的相同树结构，只需添加DFS调用并获取访问部分，它将如下所示：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Since DFS does not return anything, we are using the class property `visited`
    to get the queue so that we can show the sequence of visited nodes. If we run
    this program in console, we will have the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DFS不返回任何内容，我们使用类属性`visited`来获取队列，以便我们可以显示访问节点的序列。如果我们在控制台中运行此程序，将会得到以下输出：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The results correspond to what was expected. If we need an iterative solution
    for DFS, we have to remember that we need to use stack instead of queue to track
    the next node to visit. However, as stack follows the LIFO principle, for our
    mentioned graph image, the output will be different from our initial thought.
    Here is the implementation using the iterative approach:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 结果符合预期。如果我们需要DFS的迭代解决方案，我们必须记住，我们需要使用堆栈而不是队列来跟踪下一个要访问的节点。然而，由于堆栈遵循LIFO原则，对于我们提到的图像，输出将与我们最初的想法不同。以下是使用迭代方法的实现：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It looks very similar to our iterative BFS algorithm. The main difference is
    the use of stack data structure instead of queue data structure to store the visited
    nodes. It will also have an impact on the output. The preceding code will produce
    the output `8 → 10 → 14 → 13 → 3 → 6 → 7 → 4 → 1` . This is different from our
    previous output shown in the last section. As we are using stack, the output is
    actually correct. We are using stack to push the child nodes of a particular node.
    For our root node, which has value **8** , we have the first child node with value
    of **3** . It is pushed to the stack, and then, the second child node of root
    has the value of **10** and is also pushed to the stack. Since value **10** was
    pushed last, it will come first, following the LIFO principle of stack. So, the
    ordering is always going to be starting from the last branch to the first branch
    if we are using stack. However, if we want to keep the node ordering from left
    to right, then we need to make a small adjustment in our DFS code. Here is the
    code block with the change:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来与我们的迭代BFS算法非常相似。主要区别在于使用堆栈数据结构而不是队列数据结构来存储已访问的节点。这也会对输出产生影响。前面的代码将产生输出`8
    → 10 → 14 → 13 → 3 → 6 → 7 → 4 → 1`。这与上一节中显示的先前输出不同。由于我们使用堆栈，输出实际上是正确的。我们使用堆栈来推入特定节点的子节点。对于我们的根节点，其值为**8**，我们有值为**3**的第一个子节点。它被推入堆栈，然后，根的第二个子节点的值为**10**，也被推入堆栈。由于值**10**是最后被推入的，它将首先出现，遵循堆栈的LIFO原则。因此，如果我们使用堆栈，顺序始终将从最后的分支开始到第一个分支。然而，如果我们想要保持节点的顺序从左到右，那么我们需要在DFS代码中进行一些小的调整。以下是带有更改的代码块：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The only difference from the previous code block is that we are adding the
    following line before visiting the child nodes from a particular node:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个代码块的唯一区别是，在访问特定节点的子节点之前，我们添加了以下行：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Since stack does the Last-In, First-Out (LIFO), by reversing, we are making
    sure the first node is visited first, as we reversed the order. In fact, it will
    simply work as a queue. This will produce the desired sequence as shown in the
    DFS section. If we have a binary tree, then we do it easily without requiring
    any reversal as we can choose to push the right child first, followed by the left
    child node to pop the left child first.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于堆栈执行后进先出（LIFO）的操作，通过反转，我们确保首先访问第一个节点，因为我们已经反转了顺序。实际上，它将简单地作为队列工作。这将产生DFS部分所示的期望顺序。如果我们有一棵二叉树，那么我们可以很容易地做到这一点，而不需要任何反转，因为我们可以选择先推入右子节点，然后再推入左子节点以先弹出左子节点。
- en: DFS has a worst complexity of **O** (*|V| + |E|* ), where *V* is the number
    of vertices or nodes and *E* is the number of edges or connections between the
    nodes. For space complexity, the worst case is **O** (*|V|* ), which is similar
    to BFS.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: DFS的最坏复杂度为**O**（*|V| + |E|*），其中*V*是顶点或节点的数量，*E*是节点之间的边或连接的数量。对于空间复杂度，最坏情况是**O**（*|V|*），这与BFS类似。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed different searching algorithms and their complexities.
    You learned how to improve searching with a hash table to get a constant time
    result. We also explored BFS and DFS, two of the most important methods for hierarchical
    data searching. We will use similar concepts for graph data structure, which we
    are about to explore in the next chapter. Graph algorithms are crucial for solving
    many problems and are used heavily in the programming world. Let's get going with
    another interesting topic - the graph.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了不同的搜索算法及其复杂性。您学会了如何通过哈希表来改进搜索，以获得恒定的时间结果。我们还探讨了BFS和DFS，这两种是层次数据搜索中最重要的方法之一。我们将使用类似的概念来探索下一章中即将探讨的图数据结构。图算法对于解决许多问题至关重要，并且在编程世界中被广泛使用。让我们继续探讨另一个有趣的主题
    - 图。
