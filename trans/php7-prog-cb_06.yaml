- en: Chapter 6. Building Scalable Websites
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。构建可扩展的网站
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a generic form element generator
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个通用的表单元素生成器
- en: Creating an HTML radio element generator
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个HTML单选按钮元素生成器
- en: Creating an HTML select element generator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个HTML选择元素生成器
- en: Implementing a form factory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个表单工厂
- en: Chaining `$_POST` filters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接`$_POST`过滤器
- en: Chaining `$_POST` validators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接`$_POST`验证器
- en: Tying validation to a form
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将验证与表单绑定
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will show you how to build classes that generate HTML form
    elements. The generic element generator can be used for text, text areas, passwords,
    and similar HTML input types. After that, we will show variations that allow you
    to pre-configure the element with an array of values. The form factory recipe
    will bring all these generators together, allowing you to render an entire form
    using a single configuration array. Finally, we introduce recipes that allow filtering
    and the validation of incoming `$_POST` data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示如何构建生成HTML表单元素的类。通用元素生成器可用于文本、文本区域、密码和类似的HTML输入类型。之后，我们将展示允许您使用值数组预配置元素的变体。表单工厂配方将把所有这些生成器结合在一起，允许您使用单个配置数组渲染整个表单。最后，我们介绍允许过滤和验证传入`$_POST`数据的配方。
- en: Creating a generic form element generator
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个通用的表单元素生成器
- en: 'It''s pretty easy to create a function that simply outputs a form input tag
    such as `<input type="text" name="whatever" >`. In order to make a form generator
    generically useful, however, we need to think about the bigger picture. Here are
    some other considerations over and above the basic input tag:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个简单的函数来输出一个表单输入标签，比如`<input type="text" name="whatever" >`。然而，为了使表单生成器通用有用，我们需要考虑更大的问题。除了基本的输入标签之外，我们还需要考虑一些其他方面：
- en: The form `input` tag and its associated HTML attributes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单`input`标签及其相关的HTML属性
- en: A label that tells the user what information they are entering
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉用户他们正在输入什么信息的标签
- en: The ability to display entry errors following validation (more on that later!)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示验证后的输入错误的能力（稍后详细介绍！）
- en: Some sort of wrapper, such as a `<div>` tag, or an HTML table `<td>` tag
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某种包装器，比如`<div>`标签，或者HTML表格`<td>`标签
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we define a `Application\Form\Generic` class. This will also later serve
    as a base class for specialized form elements:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个`Application\Form\Generic`类。这也将作为专门的表单元素的基类：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we define some class constants, which will be generally useful in form
    element generation.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一些类常量，这些常量在表单元素生成中通常很有用。
- en: 'The first three will become keys associated with the major components of a
    single form element. We then define supported input types and defaults:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前三个将成为与单个表单元素的主要组件相关联的键。然后我们定义支持的输入类型和默认值：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, we can define properties and a constructor that sets them.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以定义属性和设置它们的构造函数。
- en: 'In this example, we require two properties, `$name` and `$type`, as we cannot
    effectively use the element without these attributes. The other constructor arguments
    are optional. Furthermore, in order to base one form element on another, we include
    a provision whereby the second argument, `$type`, can alternatively be an instance
    of `Application\Form\Generic`, in which case we simply run the *getters* (discussed
    later) to populate properties:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们需要两个属性`$name`和`$type`，因为没有这些属性我们无法有效地使用元素。其他构造函数参数是可选的。此外，为了基于另一个表单元素，我们包括一个规定，第二个参数`$type`可以替代地是`Application\Form\Generic`的实例，这样我们只需运行*getters*（稍后讨论）来填充属性：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that `$wrappers` has three primary subkeys: `INPUT`, `LABEL`, and `ERRORS`.
    This allows us to define separate wrappers for labels, the input tag, and errors.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`$wrappers`有三个主要的子键：`INPUT`、`LABEL`和`ERRORS`。这使我们能够为标签、输入标签和错误定义单独的包装器。
- en: Before defining the core methods that will produce HTML for the label, input
    tag, and errors, we should define a `getWrapperPattern()` method, which will produce
    the appropriate *wrapping* tags for the label, input, and error display.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义将生成标签、输入标签和错误的HTML的核心方法之前，我们应该定义一个`getWrapperPattern()`方法，它将为标签、输入和错误显示产生适当的*包装*标签。
- en: 'If, for example, the wrapper is defined as `<div>`, and its attributes include
    `[''class'' => ''label'']`, this method will return a `sprintf()` format pattern
    that looks like this: `<div class="label">%s</div>`. The final HTML produced for
    the label, for example, would then replace `%s`.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，如果包装器被定义为`<div>`，并且它的属性包括`['class' => 'label']`，这个方法将返回一个看起来像这样的`sprintf()`格式模式：`<div
    class="label">%s</div>`。例如，标签的最终HTML将替换`%s`。
- en: 'Here is how the `getWrapperPattern()` method might look:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getWrapperPattern()`方法可能如下所示：'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We are now ready to define the `getLabel()` method. All this method needs to
    do is to plug the label into the wrapper using `sprintf()`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备定义`getLabel()`方法。这个方法所需要做的就是使用`sprintf()`将标签插入包装器中：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In order to produce the core `input` tag, we need a way to assemble the attributes.
    Fortunately, this is easily accomplished as long as they are supplied to the constructor
    in the form of an associative array. All we need to do, in this case, is to define
    a `getAttribs()` method that produces a string of key-value pairs separated by
    a space. We return the final value using `trim()` to remove excess spaces.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了生成核心的`input`标签，我们需要一种方法来组装属性。幸运的是，只要它们以关联数组的形式提供给构造函数，这是很容易实现的。在这种情况下，我们只需要定义一个`getAttribs()`方法，它产生由空格分隔的键值对的字符串。我们使用`trim()`来去除多余的空格并返回最终值。
- en: 'If the element includes either the `value` or `href` attribute, for security
    reasons we should escape the values on the assumption that they are, or could
    be, user-supplied (and therefore suspect). Accordingly, we need to add an `if`
    statement that checks and then uses `htmlspecialchars()` or `urlencode()`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果元素包括`value`或`href`属性，出于安全原因，我们应该对值进行转义，假设它们是用户提供的（或可能是）（因此可疑）。因此，我们需要添加一个`if`语句来检查，然后使用`htmlspecialchars()`或`urlencode()`：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For the core input tag, we split the logic into two separate methods. The primary
    method, `getInputOnly()`, produces *only* the HTML input tag. The second method,
    `getInputWithWrapper()`, produces the input embedded in a wrapper. The reason
    for the split is that when creating spin-off classes, such as a class to generate
    radio buttons, we will not need the wrapper:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于核心输入标记，我们将逻辑分为两个独立的方法。主要方法“getInputOnly()”仅生成HTML输入标记。第二个方法“getInputWithWrapper()”生成包含在包装器中的输入。拆分的原因是在创建分支类时，例如生成单选按钮的类，我们将不需要包装器：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We now define a method that displays element validation errors. We will assume
    that the errors will be supplied in the form of an array. If there are no errors,
    we return an empty string. Otherwise, errors are rendered as `<ul><li>error 1</li><li>error
    2</li></ul>` and so on:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们定义一个显示元素验证错误的方法。我们假设错误将以数组的形式提供。如果没有错误，我们返回一个空字符串。否则，错误将呈现为“<ul><li>error
    1</li><li>error 2</li></ul>”等等：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For certain attributes, we might need more finite control over various aspects
    of the property. As an example, we might need to add a single error to the already
    existing array of errors. Also, it might be useful to set a single attribute:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于某些属性，我们可能需要更精细的控制属性的各个方面。例如，我们可能需要将一个错误添加到已经存在的错误数组中。此外，设置单个属性可能很有用：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we define getters and setters that allow us to retrieve or set the
    values of properties. For example, you might have noticed that the default value
    for `$pattern` is `<input type="%s" name="%s" %s>`. For certain tags (for example,
    `select` and `form` tags), we will need to set this property to a different value:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义获取器和设置器，允许我们检索或设置属性的值。例如，您可能已经注意到“$pattern”的默认值是“<input type="%s" name="%s"
    %s>”。对于某些标签（例如“select”和“form”标签），我们需要将此属性设置为不同的值：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We also need to add methods that will give the label value (not the HTML),
    as well as the errors array:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要添加一些方法，用于提供标签值（而不是HTML）以及错误数组：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Be sure to copy all the preceding code into a single `Application\Form\Generic`
    class. You can then define a `chap_06_form_element_generator.php` calling script
    that sets up autoloading and anchors the new class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将所有前面的代码复制到一个单独的“Application\Form\Generic”类中。然后，您可以定义一个“chap_06_form_element_generator.php”调用脚本，设置自动加载并锚定新类：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, define the wrappers. For illustration, we''ll use HTML table data and
    header tags. Note that the label uses `TH`, whereas input and errors use `TD`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义包装器。作为示例，我们将使用HTML表数据和标题标签。请注意，标签使用“TH”，而输入和错误使用“TD”：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can now define an email element by passing parameters to the constructor:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过向构造函数传递参数来定义电子邮件元素：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, define the password element using setters:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用setter定义密码元素：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lastly, be sure to define a submit button:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请确保定义一个提交按钮：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The actual display logic might look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的显示逻辑可能如下所示：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is the actual output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实际的输出：
- en: '![How it works...](graphics/B05314_06_01.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_06_01.jpg)'
- en: Creating an HTML radio element generator
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HTML单选按钮元素生成器
- en: 'A radio button element generator will share similarities with the generic HTML
    form element generator. As with any generic element, a set of radio buttons needs
    the ability to display an overall label and errors. There are two major differences,
    however:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 单选按钮元素生成器将与通用HTML表单元素生成器共享相似之处。与任何通用元素一样，一组单选按钮需要能够显示整体标签和错误。然而，有两个主要区别：
- en: Typically, you will want two or more radio buttons
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，您会希望有两个或更多的单选按钮
- en: Each button needs to have its own label
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个按钮都需要有自己的标签
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First of all, create a new `Application\Form\Element\Radio` class that extends
    `Application\Form\Generic`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的“Application\Form\Element\Radio”类，它扩展了“Application\Form\Generic”：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, we define class constants and properties that pertain to the special needs
    of a set of radio buttons.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义与一组单选按钮的特殊需求相关的类常量和属性。
- en: 'In this illustration, we will need a `spacer`, which will be placed between
    the radio button and its label. We also need to decide whether to place the radio
    button label before or after the actual button, thus, we use the `$after` flag.
    If we need a default, or if we are re-displaying existing form data, we need a
    way of designating the selected key. Finally, we need an array of options from
    which we will populate the list of buttons:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们需要一个“spacer”，它将放置在单选按钮和其标签之间。我们还需要决定是在实际按钮之前还是之后放置单选按钮标签，因此我们使用“$after”标志。如果我们需要一个默认值，或者如果我们重新显示现有的表单数据，我们需要一种指定选定键的方法。最后，我们需要一个选项数组，我们将从中填充按钮列表：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Given that we are extending `Application\Form\Generic`, we have the option of
    expanding the `__construct()` method, or, alternatively, simply defining a method
    that can be used to set specific options. For this illustration, we have chosen
    the latter course.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鉴于我们正在扩展“Application\Form\Generic”，我们可以扩展“__construct()”方法，或者简单地定义一个可用于设置特定选项的方法。对于本示例，我们选择了后者。
- en: To ensure the property `$this->options` is populated, the first parameter (`$options`)
    is defined as mandatory (without a default). All other parameters are optional.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保属性“$this->options”被填充，第一个参数（$options）被定义为强制性的（没有默认值）。所有其他参数都是可选的。
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, we are ready to override the core `getInputOnly()` method.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们准备覆盖核心的“getInputOnly()”方法。
- en: 'We save the `id` attribute into an independent variable, `$baseId`, and later
    combine it with `$count` so that each `id` attribute is unique. If the option
    associated with the selected key is defined, it is assigned as the value; otherwise,
    we use the default:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将“id”属性保存到一个独立的变量“$baseId”中，然后将其与“$count”组合，以便每个“id”属性都是唯一的。如果与选定键关联的选项已定义，则将其分配为值；否则，我们使用默认值：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inside the `foreach()` loop we check to see if the key is the one selected.
    If so, the `checked` attribute is added for that radio button. We then call the
    parent class `getInputOnly()` method to return the HTML for each button. Note
    that the `value` attribute of the input element is the options array key. The
    button label is the options array element value:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foreach()`循环中，我们检查键是否是所选的键。如果是，就为该单选按钮添加`checked`属性。然后，我们调用父类的`getInputOnly()`方法来返回每个按钮的HTML。请注意，输入元素的`value`属性是选项数组键。按钮标签是选项数组元素值：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Copy the preceding code into a new `Radio.php` file in the `Application/Form/Element`
    folder. You can then define a `chap_06_form_element_radio.php` calling script
    that sets up autoloading and anchors the new class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码复制到`Application/Form/Element`文件夹中的新`Radio.php`文件中。然后，您可以定义一个`chap_06_form_element_radio.php`调用脚本，设置自动加载并锚定新类：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, define the wrappers using the `$wrappers` array defined in the previous
    recipe.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用前一个配方中定义的`$wrappers`数组来定义包装器。
- en: 'Then you can define a `$status` array and create an element instance by passing
    parameters to the constructor:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以定义一个`$status`数组，并通过向构造函数传递参数来创建一个元素实例：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now you can see if there is any status input from `$_GET` and set the options.
    Any input will become the selected key. Otherwise, the selected key is the default:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以查看是否有来自`$_GET`的状态输入，并设置选项。任何输入都将成为选定的键。否则，选定的键是默认值：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lastly, don''t forget to define a submit button:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不要忘记定义一个提交按钮：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The display logic might look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 显示逻辑可能如下所示：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is the actual output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实际输出：
- en: '![How it works...](graphics/B05314_06_02.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_06_02.jpg)'
- en: There's more...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A checkbox element generator would be almost identical to the HTML radio button
    generator. The main difference is that a set of checkboxes can have more than
    one value checked. Accordingly, you would use PHP array notation for the element
    names. The element type should be `Generic::TYPE_CHECKBOX`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 复选框元素生成器几乎与HTML单选按钮生成器相同。主要区别在于一组复选框可以有多个选中的值。因此，您将使用PHP数组表示法来表示元素名称。元素类型应为`Generic::TYPE_CHECKBOX`。
- en: Creating an HTML select element generator
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HTML选择元素生成器
- en: Generating an HTML single select element is similar to the process of generating
    radio buttons. The tags are structured differently, however, in that both a `SELECT`
    tag and a series of `OPTION` tags need to be generated.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 生成HTML单选元素类似于生成单选按钮的过程。然而，标签的结构不同，因为需要生成`SELECT`标签和一系列`OPTION`标签。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: First of all, create a new `Application\Form\Element\Select` class that extends
    `Application\Form\Generic`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的`Application\Form\Element\Select`类，它扩展了`Application\Form\Generic`。
- en: 'The reason why we extend `Generic` rather than `Radio` is because the structuring
    of the element is entirely different:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之所以扩展`Generic`而不是`Radio`是因为元素的结构完全不同：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The class constants and properties will only need to add slightly to `Application\Form\Generic`.
    Unlike radio buttons or checkboxes, there is no need to account for *spacers*
    or the placement of the selected text:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类常量和属性只需要稍微添加到`Application\Form\Generic`。与单选按钮或复选框不同，不需要考虑*间隔符*或所选文本的放置：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we turn our attention to setting options. As an HTML select element can
    select single or multiple values, the `$selectedKey` property could be either
    a string or an array. Accordingly, we do not add a **type hint** for this property.
    It is important, however, that we identify whether or not the `multiple` attribute
    has been set. This can be obtained from a `$this->attributes` property via inheritance
    from the parent class.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将注意力转向设置选项。由于HTML选择元素可以选择单个或多个值，因此`$selectedKey`属性可以是字符串或数组。因此，我们不为此属性添加**类型提示**。然而，重要的是要确定是否已设置`multiple`属性。这可以通过从父类继承的`$this->attributes`属性获得。
- en: 'If the `multiple` attribute has been set, it''s important to formulate the
    `name` attribute as an array. Accordingly, we would append `[]` to the name if
    this were the case:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已设置`multiple`属性，则将`name`属性构造为数组非常重要。因此，如果是这种情况，我们将在名称后附加`[]`：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In PHP, if the HTML select `multiple` attribute has been set, and the `name`
    attribute is not specified as an array, only a single value will be returned!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，如果已设置HTML选择`multiple`属性，并且`name`属性未指定为数组，则只会返回单个值！
- en: Before we can define the core `getInputOnly()` method, we need to define a method
    to generate the `select` tag. We then return the final HTML using `sprintf()`,
    using `$pattern`, `$name`, and the return value of `getAttribs()` as arguments.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以定义核心的`getInputOnly()`方法之前，我们需要定义一个方法来生成`select`标签。然后，我们使用`sprintf()`返回最终的HTML，使用`$pattern`，`$name`和`getAttribs()`的返回值作为参数。
- en: 'We replace the default value for `$pattern` with `<select name="%s" %s>`. We
    then loop through the attributes, adding them as key-value pairs with spaces in
    between:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用`<select name="%s" %s>`替换了`$pattern`的默认值。然后，我们循环遍历属性，将它们作为键值对添加到空格之间：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Next, we define a method to obtain the `option` tags that will be associated
    with the `select` tag.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个方法来获取与`select`标签关联的`option`标签。
- en: 'As you will recall, the *key* from the `$this->options` array represents the
    return value, whereas the *value* part of the array represents the text that will
    appear on screen. If `$this->selectedKey` is in array form, we check to see if
    the value is in the array. Otherwise, we assume `$this-> selectedKey` is a string
    and we simply determine if it is equal to the key. If the selected key matches,
    we add the `selected` attribute:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所记得的，`$this->options`数组中的*键*表示返回值，而数组的*值*部分表示将显示在屏幕上的文本。如果`$this->selectedKey`是数组形式，我们检查值是否在数组中。否则，我们假设`$this->
    selectedKey`是一个字符串，我们只需确定它是否等于键。如果选定的键匹配，我们添加`selected`属性：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finally we are ready to override the core `getInputOnly()` method.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们准备覆盖核心的`getInputOnly()`方法。
- en: 'You will note that the logic for this method only needs to capture the return
    values from the `getSelect()` and `getOptions()` methods described in the preceding
    code. We also need to add the closing `</select>` tag:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到，此方法的逻辑只需要捕获前面代码中描述的`getSelect()`和`getOptions()`方法的返回值。我们还需要添加闭合的`</select>`标签：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Copy the code described above into a new `Select.php` file in the `Application/Form/Element`
    folder. Then define a `chap_06_form_element_select.php` calling script that sets
    up autoloading and anchors the new class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述代码复制到`Application/Form/Element`文件夹中的新`Select.php`文件中。然后定义一个`chap_06_form_element_select.php`调用脚本，设置自动加载并锚定新类：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, define the wrappers using the array `$wrappers` defined in the first
    recipe. You can also use the `$statusList` array defined in the *Creating an HTML
    radio element generator* recipe. You can then create instances of `SELECT` elements.
    The first instance is single select, and the second is multiple:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用第一个配方中定义的数组`$wrappers`来定义包装器。您还可以使用*创建HTML单选按钮元素生成器*配方中定义的`$statusList`数组。然后，您可以创建`SELECT`元素的实例。第一个实例是单选，第二个是多选：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'See if there is any status input from `$_GET` and set the options. Any input
    will become the selected key. Otherwise, the selected key is the default. As you
    will recall, the second instance is multiple select, so the value obtained from
    `$_GET` and the default setting should both be in the form of an array:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`$_GET`中是否有状态输入，并设置选项。任何输入都将成为选定的键。否则，选定的键是默认的。正如您所记得的，第二个实例是多选，因此从`$_GET`获取的值和默认设置都应该是数组形式：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Lastly, be sure to define a submit button (as shown in the *Creating a generic
    form element generator* recipe of this chapter).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保定义一个提交按钮（如本章*创建通用表单元素生成器*配方中所示）。
- en: 'The actual display logic is identical to the radio button recipe, except that
    we need to render two separate HTML select instances:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的显示逻辑与单选按钮配方相同，只是我们需要呈现两个单独的HTML选择实例：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is the actual output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实际输出：
- en: '![How it works...](graphics/B05314_06_04.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_06_04.jpg)'
- en: 'Also, you can see how the elements appear in the *view source* page:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以看到元素如何出现在*查看源代码*页面中：
- en: '![How it works...](graphics/B05314_06_05.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_06_05.jpg)'
- en: Implementing a form factory
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施表单工厂
- en: The purpose of a form factory is to generate a usable form object from a single
    configuration array. The form object should have the ability to retrieve the individual
    elements it contains so that output can be generated.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 表单工厂的目的是从单个配置数组生成可用的表单对象。表单对象应具有检索其包含的各个元素的能力，以便可以生成输出。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, let''s create a class called `Application\Form\Factory` to contain the
    factory code. It will have only one property, `$elements`, with a getter:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为`Application\Form\Factory`的类来包含工厂代码。它只有一个属性`$elements`，带有一个getter：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Before we define the primary form generation method, it's important to consider
    what configuration format we plan to receive, and what exactly the form generation
    will produce. For this illustration, we will assume that the generation will produce
    a `Factory` instance, with an `$elements` property. This property would be an
    array of `Application\Form\Generic` or `Application\Form\Element` classes.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义主要的表单生成方法之前，重要的是考虑我们计划接收的配置格式，以及表单生成将产生什么。在本示例中，我们假设生成将产生一个具有`$elements`属性的`Factory`实例。该属性将是`Application\Form\Generic`或`Application\Form\Element`类的数组。
- en: We are now ready to tackle the `generate()` method. This will cycle through
    the configuration array, creating the appropriate `Application\Form\Generic` or
    `Application\Form\Element\*` objects, which in turn will be stored in the `$elements`
    array. The new method will accept the configuration array as an argument. It is
    convenient to define this method as static so that we can generate as many instances
    as are needed using different blocks of configuration.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备着手编写`generate()`方法。这将循环遍历配置数组，创建适当的`Application\Form\Generic`或`Application\Form\Element\*`对象，然后将其存储在`$elements`数组中。新方法将接受配置数组作为参数。将此方法定义为静态的是方便的，这样我们可以使用不同的配置块生成所需的实例。
- en: 'We create an instance of `Application\Form\Factory`, and then we start looping
    through the configuration array:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个`Application\Form\Factory`的实例，然后开始循环遍历配置数组：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we check for parameters that are optional in the constructor for the
    `Application\Form\Generic` class:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查`Application\Form\Generic`类构造函数中的可选参数：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now that all the constructor parameters are in place, we can create the form
    element instance, which is then stored in `$elements`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，所有构造函数参数都就位了，我们可以创建表单元素实例，然后将其存储在`$elements`中：
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we turn our attention to options. If the `options` parameter is set,
    we extract the array values into variables using `list()`. We then test the element
    type using `switch()` and run `setOptions()` with the appropriate number of parameters:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将注意力转向选项。如果设置了`options`参数，我们使用`list()`将数组值提取到变量中。然后，我们使用`switch()`测试元素类型，并使用适当数量的参数运行`setOptions()`：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we return the form object and close out the method:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们返回表单对象并关闭方法：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Theoretically, at this point, we could easily render the form in our view logic
    by simply iterating through the array of elements and running the `render()` method.
    The view logic might look like this:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理论上，在这一点上，我们可以通过简单地迭代元素数组并运行`render()`方法来在视图逻辑中轻松呈现表单。视图逻辑可能如下所示：
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Finally, we return the form object and close out the method.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们返回表单对象并关闭方法。
- en: 'Next, we need to define a discrete `Form` class under `Application\Form\Element`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`Application\Form\Element`下定义一个独立的`Form`类：
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Returning to the `Application\Form\Factory` class, we now need to define a
    simple method that returns a `sprintf()` wrapper pattern that will serve as an
    envelope for input. As an example, if the wrapper is `div` with an attribute `class="test"`
    we would produce this pattern: `<div class="test">%s</div>`. Our content would
    then be substituted in place of `%s` by the `sprintf()` function:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`Application\Form\Factory`类，现在我们需要定义一个简单的方法，返回一个`sprintf()`包装器模式，作为输入的信封。例如，如果包装器是带有属性`class="test"`的`div`，我们将产生这个模式：`<div
    class="test">%s</div>`。然后我们的内容将被`sprintf()`函数替换为`%s`：
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, we are ready to define a method that does overall form rendering.
    We obtain wrapper `sprintf()` patterns for each form row. We then loop through
    the elements, render each one, and wrap the output in the row pattern. Next, we
    generate an `Application\Form\Element\Form` instance. We then retrieve the form
    wrapper `sprintf()` pattern and check the `form_tag_inside_wrapper` flag, which
    tells us whether we need to place the form tag inside or outside the form wrapper:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们准备定义一个执行整体表单渲染的方法。我们为每个表单行获取包装器`sprintf()`模式。然后我们循环遍历元素，渲染每个元素，并将输出包装在行模式中。接下来，我们生成一个`Application\Form\Element\Form`实例。然后我们检索表单包装器`sprintf()`模式，并检查`form_tag_inside_wrapper`标志，该标志告诉我们是否需要将表单标签放在表单包装器内部还是外部：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作...
- en: Referring to the preceding code, create the `Application\Form\Factory` and `Application\Form\Element\Form`
    classes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 参考前面的代码，创建`Application\Form\Factory`和`Application\Form\Element\Form`类。
- en: 'Next, you can define a `chap_06_form_factor.php` calling script that sets up
    autoloading and anchors the new class:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以定义一个`chap_06_form_factor.php`调用脚本，设置自动加载并锚定新类：
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Next, define the wrappers using the `$wrappers` array defined in the first recipe.
    You can also use the `$statusList` array defined in the second recipe.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用第一个配方中定义的`$wrappers`数组来定义包装器。您还可以使用第二个配方中定义的`$statusList`数组。
- en: See if there is any status input from `$_POST`. Any input will become the selected
    key. Otherwise, the selected key is the default.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 查看是否有来自`$_POST`的状态输入。任何输入都将成为所选键。否则，所选键是默认值。
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now you can define the overall form configuration. The `name` and `attributes`
    parameters are used to configure the `form` tag itself. The other two parameters
    represent form-level and row-level wrappers. Lastly, we provide a `form_tag_inside_wrapper`
    flag to indicate that the form tag should *not* appear inside the wrapper (that
    is, `<table>`). If the wrapper was `<div>`, we would set this flag to `TRUE`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以定义整体表单配置。`name`和`attributes`参数用于配置`form`标签本身。另外两个参数代表表单级别和行级别的包装器。最后，我们提供一个`form_tag_inside_wrapper`标志，以指示表单标签不应出现在包装器内部（即`<table>`）。如果包装器是`<div>`，我们将将此标志设置为`TRUE`：
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, define an array that holds parameters for each form element to be created
    by the factory. The array key becomes the name of the form element, and must be
    unique:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个数组，其中包含由工厂创建的每个表单元素的参数。数组键成为表单元素的名称，并且必须是唯一的：
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Lastly, be sure to generate the form:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保生成表单：
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The actual display logic is extremely simple, as we simply call the form level
    `render()` method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的显示逻辑非常简单，因为我们只需调用表单级别的`render()`方法：
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here is the actual output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实际输出：
- en: '![How it works...](graphics/B05314_06_06.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_06_06.jpg)'
- en: Chaining $_POST filters
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用$_POST过滤器链接
- en: Proper filtering and validation is a common problem when processing data submitted
    by users from an online form. It is arguably also the number one security vulnerability
    for a website. Furthermore, it can be quite awkward to have the filters and validators
    scattered all over the application. A chaining mechanism would resolve these issues
    neatly, and would also allow you to exert control over the order in which the
    filters and validators are processed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理用户从在线表单提交的数据时，适当的过滤和验证是一个常见的问题。这可以说也是网站的头号安全漏洞。此外，将过滤器和验证器分散在整个应用程序中可能会相当尴尬。链接机制将整洁地解决这些问题，并且还允许您控制过滤器和验证器处理的顺序。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: There is a little-known PHP function, `filter_input_array()`, that, at first
    glance, seems well suited for this task. Looking more deeply into its functionality,
    however, it soon becomes apparent that this function was designed in the early
    days, and is not up to modern requirements for protection against attack and flexibility.
    Accordingly, we will instead present a much more flexible mechanism based on an
    array of callbacks performing filtering and validation.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个鲜为人知的PHP函数`filter_input_array()`，乍一看似乎非常适合这个任务。然而，深入了解其功能后，很快就会发现这个函数是在早期设计的，并不符合对抗攻击和灵活性的现代要求。因此，我们将提出一个基于执行过滤和验证的回调数组的更加灵活的机制。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The difference between *filtering* and *validation* is that filtering can potentially
    remove or transform values. Validation, on the other hand, tests data using criteria
    appropriate to the nature of the data, and returns a boolean result.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*过滤*和*验证*之间的区别在于，过滤可能会删除或转换值。另一方面，验证使用与数据性质相适应的标准测试数据，并返回布尔结果。'
- en: In order to increase flexibility, we will make our base filter and validation
    classes relatively light. By this, we mean *not* defining any specific filters
    or validation methods. Instead, we will operate entirely on the basis of a configuration
    array of callbacks. In order to ensure compatibility in filtering and validation
    results, we will also define a specific result object, `Application\Filter\Result`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了增加灵活性，我们将使我们的基本过滤器和验证类相对轻量。这意味着*不*定义任何特定的过滤器或验证方法。相反，我们将完全基于回调的配置数组进行操作。为了确保过滤和验证结果的兼容性，我们还将定义一个特定的结果对象`Application\Filter\Result`。
- en: 'The primary function of the `Result` class will be to hold a `$item` value,
    which would be the filtered value or a boolean result of validation. Another property,
    `$messages`, will hold an array of messages populated during the filtering or
    validation operation. In the constructor, the value supplied for `$messages` is
    formulated as an array. You might observe that both properties are defined `public`.
    This is to facilitate ease of access:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Result`类的主要功能将是保存`$item`值，这将是过滤后的值或验证的布尔结果。另一个属性`$messages`将保存在过滤或验证操作期间填充的消息数组。在构造函数中，为`$messages`提供的值被制定为一个数组。您可能会注意到这两个属性都被定义为`public`。这是为了方便访问：'
- en: '[PRE53]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We also define a method that allows us to merge this `Result` instance with
    another. This is important as at some point we will be processing the same value
    through a chain of filters. In such a case, we want the newly filtered value to
    overwrite the existing one, but we want the messages to be merged:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还定义了一种方法，允许我们将这个`Result`实例与另一个实例合并。这很重要，因为在某个时候，我们将通过一系列过滤器处理相同的值。在这种情况下，我们希望新过滤的值覆盖现有的值，但希望消息被合并：
- en: '[PRE54]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, to finish the methods for this class, we add a method that merges
    validation results. The important consideration here is that *any* value of `FALSE`,
    up or down the validation chain, must cause the *entire* result to be `FALSE`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了完成这个类的方法，我们添加了一个合并验证结果的方法。这里需要考虑的重要问题是，*任何*值为`FALSE`，无论是在验证链上还是下来，都必须导致*整个*结果为`FALSE`：
- en: '[PRE55]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, to make sure that the callbacks produce compatible results, we will define
    an `Application\Filter\CallbackInterface` interface. You will note that we are
    taking advantage of the PHP 7 ability to data type the return value to ensure
    that we are getting a `Result` instance in return:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为了确保回调产生兼容的结果，我们将定义一个`Application\Filter\CallbackInterface`接口。您会注意到我们正在利用PHP
    7能够对返回值进行数据类型化，以确保我们得到一个`Result`实例作为返回值：
- en: '[PRE56]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Each callback should reference the same set of messages. Accordingly, we define
    a `Application\Filter\Messages` class with a series of static properties. We provide
    methods to set all messages, or just one message. The `$messages` property has
    been made `public` for easier access:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个回调应引用相同的消息集。因此，我们使用`Application\Filter\Messages`类定义了一系列静态属性。我们提供了设置所有消息或只设置一个消息的方法。`$messages`属性已经被设置为`public`以便更容易访问：
- en: '[PRE57]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We are now in a position to define a `Application\Web\AbstractFilter` class
    that implements core functionality. As mentioned previously, this class will be
    relatively *lightweight* and we do not need to worry about specific filters or
    validators as they will be supplied through configuration. We use the `UnexpectedValueException`
    class, provided as part of the PHP 7 **Standard PHP Library** (**SPL**), in order
    to throw a descriptive exception in case one of the callbacks does not implement
    `CallbackInterface`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义一个实现核心功能的`Application\Web\AbstractFilter`类。如前所述，这个类将相对*轻量级*，我们不需要担心特定的过滤器或验证器，因为它们将通过配置提供。我们使用`UnexpectedValueException`类，作为PHP
    7 **标准PHP库**（**SPL**）的一部分，以便在其中一个回调没有实现`CallbackInterface`时抛出一个描述性异常：
- en: '[PRE58]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'First, we define useful class constants that hold various *housekeeping* values.
    The last four shown here control the format of messages to be displayed, and how
    to describe *missing* data:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了一些有用的类常量，其中包含各种*管理*值。这里显示的最后四个控制要显示的消息格式，以及如何描述*缺失*数据：
- en: '[PRE59]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, we define core properties. `$separator` is used in conjunction with filtering
    and validation messages. `$callbacks` represents the array of callbacks that perform
    filtering and validation. `$assignments` map data fields to filters and/or validators.
    `$missingMessage` is represented as a property so that it can be overwritten (that
    is, for multi-language websites). Finally, `$results` is an array of `Application\Filter\Result`
    objects and is populated by the filtering or validation operation:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了核心属性。`$separator`与过滤和验证消息一起使用。`$callbacks`表示执行过滤和验证的回调数组。`$assignments`将数据字段映射到过滤器和/或验证器。`$missingMessage`表示为属性，以便可以覆盖它（即用于多语言网站）。最后，`$results`是一个`Application\Filter\Result`对象数组，并由过滤或验证操作填充：
- en: '[PRE60]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'At this point, we can build the `__construct()` method. Its main function is
    to set the array of callbacks and assignments. It also either sets values or accepts
    defaults for the separator (used in message display), and the *missing* message:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以构建`__construct()`方法。它的主要功能是设置回调和赋值的数组。它还设置值或接受分隔符（用于消息显示）和*missing*消息的默认值：
- en: '[PRE61]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, we define a series of methods that allow us to set or remove callbacks.
    Notice that we allow the getting and setting of a single callback. This is useful
    if you have a generic set of callbacks, and need to modify just one. You will
    also note that `setOneCall()` checks to see if the callback implements `CallbackInterface`.
    If it does not, an `UnexpectedValueException` is thrown:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一系列方法，允许我们设置或移除回调。请注意，我们允许获取和设置单个回调。如果您有一组通用的回调，并且只需要修改一个回调，这将非常有用。您还会注意到`setOneCall()`检查回调是否实现了`CallbackInterface`。如果没有，将抛出`UnexpectedValueException`：
- en: '[PRE62]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Methods for results processing are quite simple. For convenience, we added
    `getItemsAsArray()`, otherwise `getResults()` will return an array of `Result`
    objects:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果处理的方法非常简单。为了方便起见，我们添加了`getItemsAsArray()`，否则`getResults()`将返回一个`Result`对象数组：
- en: '[PRE63]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Retrieving messages is just a matter of looping through the array of `$this
    ->results` and extracting the `$messages` property. For convenience, we also added
    `getMessageString()` with some formatting options. To easily produce an array
    of messages, we use the PHP 7 `yield from` syntax. This has the effect of turning
    `getMessages()` into a **delegating generator**. The array of messages becomes
    a **sub-generator**:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索消息只是循环遍历`$this ->results`数组并提取`$messages`属性。为了方便起见，我们还添加了`getMessageString()`，其中包含一些格式选项。为了轻松生成消息数组，我们使用了PHP
    7的`yield from`语法。这使得`getMessages()`成为一个**委托生成器**。消息数组成为一个**子生成器**：
- en: '[PRE64]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Lastly, we define a mixed group of useful getters and setters:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义一组有用的getter和setter：
- en: '[PRE65]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Filtering and validation, although often performed together, are just as often
    performed separately. Accordingly, we define discrete classes for each. We''ll
    start with `Application\Filter\Filter`. We make this class extend `AbstractFilter`
    in order to provide the core functionality described previously:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤和验证，虽然经常一起执行，但同样经常分开执行。因此，我们为每个定义离散的类。我们将从`Application\Filter\Filter`开始。我们使这个类扩展`AbstractFilter`，以提供先前描述的核心功能：
- en: '[PRE66]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Within this class we define a core `process()` method that scans an array of
    data and applies filters as per the array of assignments. If there are no assigned
    filters for this data set, we simply return `NULL`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类中，我们定义了一个核心的`process()`方法，它扫描数据数组并根据分配数组应用过滤器。如果对这个数据集没有分配过滤器，我们只需返回`NULL`：
- en: '[PRE67]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Otherwise, we initialize `$this->results` to an array of `Result` objects where
    the `$item` property is the original value from `$data`, and the `$messages` property
    is an empty array:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们将`$this->results`初始化为一个`Result`对象数组，其中`$item`属性是来自`$data`的原始值，`$messages`属性是一个空数组：
- en: '[PRE68]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We then make a copy of `$this->assignments` and check to see if there are any
    *global* filters (identified by the ''`*`'' key. If so, we run `processGlobal()`
    and then unset the ''`*`'' key:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们复制`$this->assignments`并检查是否有任何*全局*过滤器（由'`*`'键标识）。如果有，我们运行`processGlobal()`然后取消'`*`'键：
- en: '[PRE69]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, we loop through any remaining assignments, calling `processAssignment()`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们循环遍历任何剩余的分配，调用`processAssignment()`：
- en: '[PRE70]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As you will recall, each *assignment* is keyed to the data field, and represents
    an array of callbacks for that field. Thus, in `processGlobalAssignment()` we
    need to loop through the array of callbacks. In this case, however, because these
    assignments are *global*, we also need to loop through the *entire* data set,
    and apply each global filter in turn:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所记得的，每个*assignment*都是针对数据字段的键，并表示该字段的回调数组。因此，在`processGlobalAssignment()`中，我们需要循环遍历回调数组。然而，在这种情况下，因为这些分配是*全局*的，我们还需要循环遍历*整个*数据集，并依次应用每个全局过滤器：
- en: '[PRE71]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The tricky bit is this line of code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 棘手的部分是这行代码：
- en: '[PRE72]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Remember, each callback is actually an anonymous class that defines the PHP
    magic `__invoke()` method. The arguments supplied are the actual data item to
    be filtered, and an array of parameters. By running `$this->callbacks[$callback['key']]()`
    we are in fact magically calling `__invoke()`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个回调实际上是一个匿名类，定义了PHP魔术`__invoke()`方法。提供的参数是要过滤的实际数据项和参数数组。通过运行`$this->callbacks[$callback['key']]()`，我们实际上是在神奇地调用`__invoke()`。
- en: 'When we define `processAssignment()`, in a manner akin to `processGlobalAssignment()`,
    we need to execute each remaining callback assigned to each data key:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们定义`processAssignment()`时，类似于`processGlobalAssignment()`的方式，我们需要执行分配给每个数据键的每个剩余回调：
- en: '[PRE73]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important that any filtering operation that alters the original user-supplied
    data should display a message indicating that a change was made. This can become
    part of an audit trail to safeguard you against potential legal liability when
    a change is made without user knowledge or consent.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 任何改变原始用户提供的数据的过滤操作都应显示一个消息，指示已进行更改，这可以成为审计跟踪的一部分，以保护您免受潜在的法律责任，当更改在用户不知情或未经同意的情况下进行时。
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Create an `Application\Filter` folder. In this folder, create the following
    class files, using code from the preceding steps:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`Application\Filter`文件夹。在这个文件夹中，使用前面步骤中的代码创建以下类文件：
- en: '| Application\Filter\* class file | Code described in these steps |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| Application\Filter\*类文件 | 在这些步骤中描述的代码 |'
- en: '| --- | --- |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Result.php` | 3 - 5 |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `Result.php` | 3 - 5 |'
- en: '| `CallbackInterface.php` | 6 |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `CallbackInterface.php` | 6 |'
- en: '| `Messages.php` | 7 |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `Messages.php` | 7 |'
- en: '| `AbstractFilter.php` | 8 - 15 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `AbstractFilter.php` | 8 - 15 |'
- en: '| `Filter.php` | 16 - 22 |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `Filter.php` | 16 - 22 |'
- en: 'Next, take the code discussed in step 5, and use it to configure an array of
    messages in a `chap_06_post_data_config_messages.php` file. Each callback references
    the `Messages::$messages` property. Here is a sample configuration:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，获取步骤5中讨论的代码，并将其用于在`chap_06_post_data_config_messages.php`文件中配置消息数组。每个回调引用`Messages::$messages`属性。以下是一个示例配置：
- en: '[PRE74]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Next, create a `chap_06_post_data_config_callbacks.php` callback configuration
    file that contains configuration for filtering callbacks, as described in step
    4\. Each callback should follow this generic template:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个`chap_06_post_data_config_callbacks.php`回调配置文件，其中包含过滤回调的配置，如步骤4中所述。每个回调应遵循这个通用模板：
- en: '[PRE75]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The callbacks themselves must implement the interface and return a `Result`
    instance. We can take advantage of the PHP 7 **anonymous class** capability by
    having our callbacks return an anonymous class that implements `CallbackInterface`.
    Here is how an array of filtering callbacks might look:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 回调本身必须实现接口并返回一个`Result`实例。我们可以利用PHP 7的**匿名类**功能，让我们的回调返回一个实现`CallbackInterface`的匿名类。以下是一个过滤回调数组可能的样子：
- en: '[PRE76]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'For test purposes, we will use the prospects table as a target. Instead of
    providing data from `$_POST`, we will construct an array of *good* and *bad* data:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，我们将使用prospects表作为目标。我们将构建一个*好*和*坏*数据的数组，而不是从`$_POST`提供数据：
- en: '![How it works...](graphics/B05314_06_10.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_06_10.jpg)'
- en: 'You can now create a `chap_06_post_data_filtering.php` script that sets up
    autoloading, includes the messages and callbacks configuration files:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以创建一个`chap_06_post_data_filtering.php`脚本，设置自动加载，包括消息和回调配置文件：
- en: '[PRE77]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You then need to define *assignments* that represent a mapping between the
    data fields and filter callbacks. Use the `*` key to define a *global* filter
    that applies to all data:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要定义*assignments*，表示数据字段和过滤回调之间的映射关系。使用`*`键来定义适用于所有数据的*全局*过滤器：
- en: '[PRE78]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Next, define *good* and *bad* test data:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义*好*和*坏*的测试数据：
- en: '[PRE79]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Finally, you can create an `Application\Filter\Filter` instance, and test the
    data:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以创建一个`Application\Filter\Filter`实例，并测试数据：
- en: '[PRE80]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Processing *good* data produces no messages other than one indicating that
    the value for the *float* field was converted from string to `float`. The *bad*
    data, on the other hand, produces the following output:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 处理*好*的数据除了指示*float*字段的值从字符串转换为`float`之外，不会产生任何消息。另一方面，*坏*的数据产生以下输出：
- en: '![How it works...](graphics/B05314_06_11.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_06_11.jpg)'
- en: You will also notice that tags were removed from `first_name`, and that both
    `last_name` and `city` were truncated.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到`first_name`中的标记已被移除，并且`last_name`和`city`都被截断。
- en: There's more...
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `filter_input_array()` function takes two arguments: the input source (in
    the form of a pre-defined constant used to indicate one of the `$_*` PHP super-globals,
    that is, `$_POST`), and an array of matching field definitions as keys and filters
    or validators as values. This function performs not only filtering operations,
    but validation as well. The flags labeled *sanitize* are actually filters.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter_input_array()`函数接受两个参数：输入源（以预定义的常量形式表示`$_*` PHP超全局变量之一，即`$_POST`），以及匹配字段定义的数组作为键和过滤器或验证器作为值。此函数不仅执行过滤操作，还执行验证操作。标记为*sanitize*的标志实际上是过滤器。'
- en: See also
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Documentation and examples of `filter_input_array()` can be found at [http://php.net/manual/en/function.filter-input-array.php](http://php.net/manual/en/function.filter-input-array.php).
    You might also have a look at the different types of *filters* that are available
    on [http://php.net/manual/en/filter.filters.php](http://php.net/manual/en/filter.filters.php).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[http://php.net/manual/en/function.filter-input-array.php](http://php.net/manual/en/function.filter-input-array.php)找到`filter_input_array()`的文档和示例。您还可以查看[http://php.net/manual/en/filter.filters.php](http://php.net/manual/en/filter.filters.php)上可用的不同类型的*过滤器*。
- en: Chaining $_POST validators
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将$_POST验证器链接在一起
- en: The *heavy lifting* for this recipe has already been accomplished in the preceding
    recipe. Core functionality is defined by `Application\Filter\AbstractFilter`.
    The actual validation is performed by an array of validating callbacks.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的*重要工作*已经在前面的示例中完成。核心功能由`Application\Filter\AbstractFilter`定义。实际的验证是由一系列验证回调执行的。
- en: How to do it...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Look over the preceding recipe, *Chaining $_POST filters*. We will be using
    all of the classes and configuration files in this recipe, except where noted
    here.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看前面的示例，*链接$_POST过滤器*。我们将在这个示例中使用所有的类和配置文件，除非在这里另有说明。
- en: 'To begin, we define a configuration array of validation callbacks. As with
    the preceding recipe, each callback should implement `Application\Filter\CallbackInterface`,
    and should return an instance of `Application\Filter\Result`. Validators would
    take this generic form:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个验证回调的配置数组。与前面的示例一样，每个回调都应实现`Application\Filter\CallbackInterface`，并应返回`Application\Filter\Result`的实例。验证器将采用这种通用形式：
- en: '[PRE81]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Next, we define a `Application\Filter\Validator` class, which loops through
    the array of assignments, testing each data item against its assigned validator
    callbacks. We make this class extend `AbstractFilter` in order to provide the
    core functionality described previously:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`Application\Filter\Validator`类，它循环遍历赋值数组，测试每个数据项是否符合其分配的验证器回调。我们使这个类扩展`AbstractFilter`，以提供先前描述的核心功能：
- en: '[PRE82]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Within this class, we define a core `process()` method that scans an array
    of data and applies validators as per the array of assignments. If there are no
    assigned validators for this data set, we simply return the current status of
    `$valid` (which is `TRUE`):'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类中，我们定义了一个核心的`process()`方法，它扫描数据数组并根据赋值数组应用验证器。如果对于这个数据集没有分配验证器，我们只需返回`$valid`的当前状态（即`TRUE`）：
- en: '[PRE83]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Otherwise, we initialize `$this->results` to an array of `Result` objects where
    the `$item` property is set to `TRUE`, and the `$messages` property is an empty
    array:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们将`$this->results`初始化为一个`Result`对象数组，其中`$item`属性设置为`TRUE`，`$messages`属性为空数组：
- en: '[PRE84]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We then make a copy of `$this->assignments` and check to see if there are any
    *global* filters (identified by the ''`*`'' key). If so, we run `processGlobal()`
    and then unset the ''`*`'' key:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们复制`$this->assignments`并检查是否有*全局*过滤器（由'`*`'键标识）。如果有，我们运行`processGlobal()`，然后取消'`*`'键：
- en: '[PRE85]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Finally, we loop through any remaining assignments, calling `processAssignment()`.
    This is an ideal place to check to see if any fields present in the assignments
    array is missing from the data. Note that we set `$valid` to `FALSE` if any validation
    callback returns `FALSE`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们循环遍历任何剩余的赋值，调用`processAssignment()`。这是一个理想的地方，用来检查赋值数组中是否缺少数据中存在的任何字段。请注意，如果任何验证回调返回`FALSE`，我们将`$valid`设置为`FALSE`：
- en: '[PRE86]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As you will recall, each *assignment* is keyed to the data field, and represents
    an array of callbacks for that field. Thus, in `processGlobalAssignment()`, we
    need to loop through the array of callbacks. In this case, however, because these
    assignments are *global*, we also need to loop through the *entire* data set,
    and apply each global filter in turn.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所记得的，每个*赋值*都与数据字段相关联，并表示该字段的回调数组。因此，在`processGlobalAssignment()`中，我们需要循环遍历回调数组。然而，在这种情况下，因为这些赋值是*全局*的，我们还需要循环遍历*整个*数据集，并依次应用每个全局过滤器。
- en: 'In contrast to the equivalent `Application\Filter\Fiter::processGlobalAssignment()`
    method, we need to call `mergeValidationResults()`. The reason for this is that
    if the value of `$result->item` is already `FALSE`, we need to ensure that it
    does not subsequently get overwritten by a value of `TRUE`. Any validator in the
    chain that returns `FALSE` must overwrite any other validation result:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与等效的`Application\Filter\Fiter::processGlobalAssignment()`方法相比，我们需要调用`mergeValidationResults()`。原因是，如果`$result->item`的值已经是`FALSE`，我们需要确保它不会随后被`TRUE`的值覆盖。链中返回`FALSE`的任何验证器都必须覆盖任何其他验证结果：
- en: '[PRE87]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'When we define `processAssignment()`, in a manner akin to `processGlobalAssignment()`,
    we need to execute each remaining callback assigned to each data key, again calling
    `mergeValidationResults()`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们定义`processAssignment()`时，类似于`processGlobalAssignment()`，我们需要执行分配给每个数据键的每个剩余回调，再次调用`mergeValidationResults()`：
- en: '[PRE88]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: How it works...
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As with the preceding recipe, be sure to define the following classes:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的配方一样，请确保定义以下类：
- en: '`Application\Filter\Result`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Filter\Result`'
- en: '`Application\Filter\CallbackInterface`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Filter\CallbackInterface`'
- en: '`Application\Filter\Messages`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Filter\Messages`'
- en: '`Application\Filter\AbstractFilter`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application\Filter\AbstractFilter`'
- en: You can use the `chap_06_post_data_config_messages.php` file, also described
    in the previous recipe.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用前一配方中描述的`chap_06_post_data_config_messages.php`文件。
- en: Next, create a `Validator.php` file in the `Application\Filter` folder. Place
    the code described in step 3 to 10.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`Application\Filter`文件夹中创建一个`Validator.php`文件。放置步骤3到10中描述的代码。
- en: 'Next, create a `chap_06_post_data_config_callbacks.php` callback configuration
    file that contains configurations for validation callbacks, as described in step
    2\. Each callback should follow this generic template:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个包含验证回调配置的`chap_06_post_data_config_callbacks.php`回调配置文件，如步骤2中描述的那样。每个回调应遵循这个通用模板：
- en: '[PRE89]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now you can create a `chap_06_post_data_validation.php` calling script that
    initializes autoloading and includes the configuration scripts:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以创建一个`chap_06_post_data_validation.php`调用脚本，该脚本初始化自动加载并包含配置脚本：
- en: '[PRE90]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Next, define an array of assignments, mapping data fields to validator callback
    keys:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个分配数组，将数据字段映射到验证器回调键：
- en: '[PRE91]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'For test data, use the same *good* and *bad* data defined in the `chap_06_post_data_filtering.php`
    file described in the previous recipe. After that, you are in a position to create
    an `Application\Filter\Validator` instance, and test the data:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试数据，请使用在前一配方中描述的`chap_06_post_data_filtering.php`文件中定义的相同的*good*和*bad*数据。之后，您可以创建一个`Application\Filter\Validator`实例，并测试数据：
- en: '[PRE92]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'As expected, the *good* data does not produce any validation errors. The *bad*
    data, on the other hand, generates the following output:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，*good*数据不会产生任何验证错误。另一方面，*bad*数据会生成以下输出：
- en: '![How it works...](graphics/B05314_06_13.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_06_13.jpg)'
- en: Notice that the *missing* fields, `address` and `state_province` validate `FALSE`,
    and return the missing item message.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*missing*字段`address`和`state_province`验证为`FALSE`，并返回缺少项目消息。
- en: Tying validation to a form
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将验证与表单绑定
- en: When a form is first rendered, there is little value in having a form class
    (such as `Application\Form\Factory`, described in the previous recipe) tied to
    a class that can perform filtering or validation (such as the `Application\Filter\*`
    described in the previous recipe). Once the form data has been submitted, however,
    interest grows. If the form data fails validation, the values can be filtered,
    and then re-displayed. Validation error messages can be tied to form elements,
    and rendered next to form fields.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单首次呈现时，将表单类（如前一配方中描述的`Application\Form\Factory`）与可以执行过滤或验证的类（如前一配方中描述的`Application\Filter\*`）绑定是没有太大价值的。但是，一旦表单数据被提交，兴趣就增加了。如果表单数据未通过验证，可以对值进行过滤，然后重新显示。验证错误消息可以与表单元素绑定，并在表单字段旁边呈现。
- en: How to do it...
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First of all, be sure to implement the classes defined in the *Implementing
    a Form Factory*, *Chaining $_POST Filters*, and *Chaining $_POST Validators* recipes.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保实现*实现表单工厂*、*链接$_POST过滤器*和*链接$_POST验证器*配方中定义的类。
- en: 'We will now turn our attention to the `Application\Form\Factory` class, and
    add properties and setters that allow us to attach instances of `Application\Filter\Filter`
    and `Application\Filter\Validator`. We also need define `$data`, which will be
    used to retain the filtered and/or validated data:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将注意力转向`Application\Form\Factory`类，并添加属性和setter，允许我们附加`Application\Filter\Filter`和`Application\Filter\Validator`的实例。我们还需要定义`$data`，用于保留过滤和/或验证的数据：
- en: '[PRE93]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Next, we define a `validate()` method that calls the `process()` method of
    the embedded `Application\Filter\Validator` instance. We check to see if `$data`
    and `$validator` exist. If not, the appropriate exceptions are thrown with instructions
    on which method needs to be run first:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`validate()`方法，该方法调用嵌入的`Application\Filter\Validator`实例的`process()`方法。我们检查`$data`和`$validator`是否存在。如果不存在，将抛出适当的异常，并提供哪个方法需要首先运行的说明：
- en: '[PRE94]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'After calling the `process()` method, we associate validation result messages
    with form element messages. Note that the `process()` method returns a boolean
    value that represents the overall validation status of the data set. When the
    form is re-displayed following failed validation, error messages will appear next
    to each element:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`process()`方法后，我们将验证结果消息与表单元素消息关联起来。请注意，`process()`方法返回一个布尔值，表示数据集的整体验证状态。当表单在验证失败后重新显示时，错误消息将出现在每个元素旁边：
- en: '[PRE95]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In a similar manner, we define a `filter()` method that calls the `process()`
    method of the embedded `Application\Filter\Filter` instance. As with the `validate()`
    method described in step 3, we need to check for the existence of `$data` and
    `$filter`. If either is missing, we throw a `RuntimeException` with the appropriate
    message:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们定义了一个`filter()`方法，该方法调用嵌入的`Application\Filter\Filter`实例的`process()`方法。与步骤3中描述的`validate()`方法一样，我们需要检查`$data`和`$filter`的存在。如果缺少任一项，我们将抛出一个带有适当消息的`RuntimeException`：
- en: '[PRE96]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We then run the `process()` method, which produces an array of `Result` objects
    where the `$item` property represents the end result of the filter chain. We then
    loop through the results, and, if the corresponding `$element` key matches, set
    the `value` attribute to the filtered value. We also add any messages resulting
    from the filtering process. When the form is then re-displayed, all value attributes
    will display filtered results:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们运行`process()`方法，该方法生成一个`Result`对象数组，其中`$item`属性表示过滤器链的最终结果。然后我们遍历结果，如果相应的`$element`键匹配，将`value`属性设置为过滤后的值。我们还添加了过滤过程中产生的任何消息。然后重新显示表单时，所有值属性都将显示过滤后的结果：
- en: '[PRE97]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: How it works...
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You can start by making the changes to `Application\Form\Factory` as described
    above. For a test target you can use the prospects database table shown in the
    *How it works...* section of the *Chaining $_POST filters* recipe. The various
    column settings should give you an idea of which form elements, filters, and validators
    to define.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从对`Application\Form\Factory`进行上述更改开始。作为测试目标，您可以使用*如何工作...*部分中显示的潜在客户数据库表的内容。各种列设置应该让您了解要定义哪些表单元素、过滤器和验证器。
- en: 'As an example, you can define a `chap_06_tying_filters_to_form_definitions.php`
    file, which will contain definitions for form wrappers, elements, and filter assignments.
    Here are some examples:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以定义一个`chap_06_tying_filters_to_form_definitions.php`文件，其中包含表单包装、元素和过滤器分配的定义。以下是一些示例：
- en: '[PRE98]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You can use the already existing `chap_06_post_data_config_callbacks.php` and
    `chap_06_post_data_config_messages.php` files described in the previous recipes.
    Finally, define a `chap_06_tying_filters_to_form.php` file that sets up autoloading
    and includes these three configuration files:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用先前配方中描述的已经存在的`chap_06_post_data_config_callbacks.php`和`chap_06_post_data_config_messages.php`文件。最后，定义一个`chap_06_tying_filters_to_form.php`文件，设置自动加载并包含这三个配置文件：
- en: '[PRE99]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Next, you can create instances of the form factory, filter, and validator classes:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以创建表单工厂、过滤器和验证器类的实例：
- en: '[PRE100]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'You can then check to see if there is any `$_POST` data. If so, perform validation
    and filtering:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以检查是否有任何`$_POST`数据。如果有，执行验证和过滤：
- en: '[PRE101]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The view logic is extremely simple: just render the form. Any validation messages
    and values for the various elements will be assigned as part of validation and
    filtering:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 视图逻辑非常简单：只需呈现表单。任何验证消息和各种元素的值都将作为验证和过滤的一部分分配：
- en: '[PRE102]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Here is an example using bad form data:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用不良表单数据的示例：
- en: '![How it works...](graphics/B05314_06_14.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_06_14.jpg)'
- en: 'Notice the filtering and validation messages. Also notice the bad tags:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 注意过滤和验证消息。还要注意不良标签：
- en: '![How it works...](graphics/B05314_06_15.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_06_15.jpg)'
