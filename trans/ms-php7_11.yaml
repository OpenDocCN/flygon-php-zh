- en: Building Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建服务
- en: A great deal of modern applications use **HTTP** (**Hypertext Transfer Protocol**)
    nowadays. This stateless, application-layer protocol allows us to exchange messages
    between distributed systems. The message exchange process can be observed through
    a client-server computing model as it happens in the form of the request-response
    type of messages. This allows us to easily write a service, or web service to
    be more specific, that triggers various operations on server and feedback data
    back to the client.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序大量使用**HTTP**（**超文本传输协议**）。这种无状态的应用层协议允许我们在分布式系统之间交换消息。消息交换过程可以通过客户端-服务器计算模型观察到，因为它以请求-响应类型的消息形式发生。这使我们能够轻松地编写一个服务，或者更具体地说，一个Web服务，触发服务器上的各种操作并将反馈数据返回给客户端。
- en: 'In this chapter, we will take a closer look at this client-server relationship
    through the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过以下部分更仔细地研究这种客户端-服务器关系：
- en: Understanding the client-server relationship
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解客户端-服务器关系
- en: 'Working with SOAP:'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SOAP进行工作：
- en: XML extensions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML扩展
- en: Creating server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建服务器
- en: Creating WSDL file
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建WSDL文件
- en: Creating client
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建客户端
- en: 'Working with REST:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用REST进行工作：
- en: JSON extensions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON扩展
- en: Creating server
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建服务器
- en: Creating client
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建客户端
- en: 'Working with Apache Thrift (RPC):'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apache Thrift（RPC）进行工作：
- en: Installing Apache Thrift
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Apache Thrift
- en: Defining service
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义服务
- en: Creating server
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建服务器
- en: Creating client
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建客户端
- en: Understanding microservices
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解微服务
- en: Understanding the client-server relationship
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解客户端-服务器关系
- en: 'To easily visualize the client-server relationship and the request-response
    type of messaging, we can think of a mobile currency application acting as a client
    and some remote website, such as `http://api.fixer.io/`, being the server. The
    server exposes one or more URL endpoints, allowing communication exchange, such
    as `http://api.fixer.io/latest?symbols=USD,GBP`. The mobile application can easily
    issue a HTTP `GET http://api.fixer.io/latest?symbols=GBP,HRK,USD` request, which then
    results in a response like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易地可视化客户端-服务器关系和请求-响应类型的消息传递，我们可以将一个移动货币应用程序视为客户端，而一些远程网站，比如`http://api.fixer.io/`，作为服务器。服务器公开一个或多个URL端点，允许通信交换，比如`http://api.fixer.io/latest?symbols=USD,GBP`。移动应用程序可以轻松发出HTTP
    `GET http://api.fixer.io/latest?symbols=GBP,HRK,USD`请求，然后得到如下响应：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The HTTP `GET` keyword is used to denote the type of operation we want to perform
    on the receiver located on the remote (server) system that we contact via URL.
    The response contains JSON-formatted data, which our mobile currency application
    can easily digest and make use of. This specific message exchange example is what
    we flag as **representational state transfer** (**REST**) or RESTful service.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP的`GET`关键字用于表示我们要在通过URL联系的远程（服务器）系统上执行的操作类型。响应包含JSON格式的数据，我们的移动货币应用程序可以轻松解析和使用。这个特定的消息交换示例是我们所谓的**表述状态转移**（**REST**）或RESTful服务。
- en: The REST service itself is not a protocol; it is an architectural style on top
    of HTTP's stateless protocol and standard operations (GET, POST, PUT, DELETE,
    and so on). There is much more to it, than showcased in this simple example, as
    we will get to see later on in the *Working with REST* section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务本身不是一种协议；它是建立在HTTP无状态协议和标准操作（GET、POST、PUT、DELETE等）之上的一种架构风格。在这个简单的例子中展示的只是冰山一角，我们将在*使用REST*部分后面看到更多。
- en: There are other forms of services that go beyond being just an architectural
    style, such as the SOAP service and Apache Thrift service. While they come with
    their own sets of protocols, they also play nicely with HTTP.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他形式的服务，超越了仅仅是一种架构风格，比如SOAP服务和Apache Thrift服务。虽然它们有自己的协议集，但它们也可以与HTTP很好地配合。
- en: Working with SOAP
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SOAP进行工作
- en: '**SOAP** (**Simple Object Access Protocol**) is an XML-based message exchange protocol
    that relies on application layer protocols such as HTTP for message negotiation
    and transmission. The **World Wide Web Consortium** (**W3C**) maintains SOAP specification.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOAP**（**简单对象访问协议**）是一种基于XML的消息交换协议，依赖于应用层协议（如HTTP）进行消息协商和传输。**万维网联盟**（**W3C**）维护SOAP规范。'
- en: The SOAP specifications document is available at [https://www.w3.org/TR/soap/](https://www.w3.org/TR/soap/).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP规范文档可在[https://www.w3.org/TR/soap/](https://www.w3.org/TR/soap/)找到。
- en: 'The SOAP message is an XML document comprised of `Envelope`, `Header`, `Body`,
    and `Fault` elements:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP消息是由`Envelope`、`Header`、`Body`和`Fault`元素组成的XML文档：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`Envelope` is a required element of each SOAP request, as it envelops an entire
    SOAP message. Similarly, the `Body` element is also required as it contains request
    and response information.  `Header` and `Fault`, on the other hand, are optional
    elements. Using merely XML-based request-response messages, we can establish client-server
    communication over HTTP. While trading XML messages may look simple, it can become
    cumbersome when one has to deal with a large number of method calls and data types.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Envelope`是每个SOAP请求的必需元素，因为它包含整个SOAP消息。同样，`Body`元素也是必需的，因为它包含请求和响应信息。另一方面，`Header`和`Fault`是可选元素。仅使用基于XML的请求-响应消息，我们可以通过HTTP建立客户端-服务器通信。虽然交换XML消息看起来很简单，但当一个人必须处理大量的方法调用和数据类型时，这可能会变得繁琐。'
- en: This is where WSDL comes in play. WSDL is an interface definition language that
    can be used to define a web service's data types and operations. The W3C maintains
    WSDL specification.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是WSDL发挥作用的地方。WSDL是一种接口定义语言，用于定义Web服务的数据类型和操作。W3C维护WSDL规范。
- en: The WSDL specification document is available at [https://www.w3.org/TR/wsdl](https://www.w3.org/TR/wsdl).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: WSDL规范文档可在[https://www.w3.org/TR/wsdl](https://www.w3.org/TR/wsdl)找到。
- en: 'A total of six major elements are used to describe the service, as per the
    following partial example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下部分示例，一共使用了六个主要元素来描述服务：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While WSDL is not required for our service to be operational, it certainly comes
    in handy for clients consuming our SOAP service. Sadly, PHP lacks any official
    tooling for easy generation of WSDL files based on the PHP classes that our SOAP
    service uses. This makes it tedious and time consuming for PHP developers to write
    WSDL files manually, which is why some developers tend to overlook the WSDL completely.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然WSDL对于我们的服务的运行并不是必需的，但对于使用我们的SOAP服务的客户端来说，它肯定很方便。遗憾的是，PHP缺乏基于SOAP服务使用的PHP类轻松生成WSDL文件的官方工具。这使得PHP开发人员手动编写WSDL文件变得繁琐和耗时，这就是为什么一些开发人员倾向于完全忽略WSDL。
- en: Temporarily putting the WSDL file generation aside, it's safe to say that the only
    really challenging part of the SOAP service is writing and reading XML messages.
    This is where PHP extensions come in handy.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时将WSDL文件生成放在一边，可以说SOAP服务中唯一真正具有挑战性的部分是编写和读取XML消息。这就是PHP扩展派上用场的地方。
- en: XML extensions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML扩展
- en: 'There are several ways to read and write XML documents in PHP, including regular
    expressions and specialized classes and methods. The regex approach is error-prone,
    especially with complex XML documents, which is why the use of extensions is advised.
    PHP provides several extensions for this purpose, the most common ones being as
    follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中有几种读取和写入XML文档的方法，包括正则表达式和专门的类和方法。正则表达式方法容易出错，特别是对于复杂的XML文档，因此建议使用扩展。PHP为此提供了几种扩展，最常见的是以下几种：
- en: '**XMLWriter**: This allows us to generate streams or files of XML data'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XMLWriter**：这允许我们生成XML数据的流或文件'
- en: '**XMLReader**: This allows to read the XML data'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XMLReader**：这允许读取XML数据'
- en: '**SimpleXML**: This converts XML to an object and allows for an object to be
    processed with normal property selectors and array iterators'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SimpleXML**：这将XML转换为对象，并允许使用常规属性选择器和数组迭代器处理对象'
- en: '**DOM**: This allows us to operate on XML documents through the DOM API'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DOM**：这允许我们通过DOM API操作XML文档'
- en: 'The basics of dealing with an XML document are about proper reading and writing
    of its elements and attributes. Let''s assume the following `simple.xml` document:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 处理XML文档的基础是正确读取和写入其元素和属性。让我们假设以下的`simple.xml`文档：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using `XMLWriter`, we can create the identical document by running the following
    code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`XMLWriter`，我们可以通过运行以下代码创建相同的文档：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can see that writing down the necessary XML was a relatively straightforward
    operation with `XMLWriter`. The `XMLWriter` extension makes our code a bit hard
    to read at first. All those `startElement()` and `endElement()` methods make it
    a bit tedious to figure out where each element in XML resides. It takes a bit
    of getting used to it. However, it does allow us to easily generate simple XML
    documents. Using `XMLReader`, we can now output the `Customer John, at age 34,
    living at The Address #1`string based on data from the given XML document using
    the following code block:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以看到，使用`XMLWriter`写下必要的XML是一个相对简单的操作。`XMLWriter`扩展使我们的代码一开始有点难以阅读。所有这些`startElement()`和`endElement()`方法使得弄清楚XML中的每个元素有点乏味。需要一点时间来适应它。但是，它确实允许我们轻松生成简单的XML文档。使用`XMLReader`，我们现在可以根据给定XML文档中的数据输出`Customer
    John, at age 34, living at The Address #1`字符串，使用以下代码块：'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Although the code itself looks pretty simple, the `while` loop reveals an interesting nature
    of `XMLReader`. The `XMLReader` reads the XML document top to bottom. While this approach
    is a great choice for efficiently parsing large and complex XML documents in a stream-based manner,
    it seems a bit of an overkill for simpler XML documents.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码本身看起来非常简单，但`while`循环揭示了`XMLReader`的一个有趣的特性。`XMLReader`从上到下读取XML文档。虽然这种方法对于以流为基础高效解析大型和复杂的XML文档是一个很好的选择，但对于更简单的XML文档来说似乎有点过度。
- en: 'Let''s see how `SimpleXML` handles writing of the same `simple.xml` file. The
    following code generates nearly the same XML content as `XMLWriter`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`SimpleXML`如何处理写入相同的`simple.xml`文件。以下代码生成的XML内容几乎与`XMLWriter`相同：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The difference here is that we cannot specifically pass `<![CDATA[...]]>` to
    our elements. There are workarounds using the `dom_import_simplexml()` function,
    but that''s a function from the `DOM` extension. Not that there is anything bad
    about it, but let''s keep our examples nicely separated. Now that we know we can
    write XML documents with `SimpleXML`, let''s see about reading from them. Using
    `SimpleXML`, we can now output the same `Customer John, at age 34, living at The
    Address #1` string using the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '这里的区别在于我们无法将`<![CDATA[...]]>`直接传递给我们的元素。有一些使用`dom_import_simplexml()`函数的变通方法，但那是来自`DOM`扩展的函数。并不是说这有什么不好，但让我们保持我们的示例清晰分离。现在我们知道我们可以使用`SimpleXML`编写XML文档，让我们看看如何从中读取。使用`SimpleXML`，我们现在可以使用以下代码输出相同的`Customer
    John, at age 34, living at The Address #1`字符串：'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The XML reading process seems somewhat shorter with `SimpleXML` than it is with `XMLReader`,
    although none of the examples have any error handling in them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SimpleXML`读取XML的过程似乎比使用`XMLReader`要短一些，尽管这些示例都没有任何错误处理。
- en: 'Let''s take a look at using the `DOMDocument` class to write down an XML document:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`DOMDocument`类来写下一个XML文档：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, let''s see how `DOMDocument` handles the reading of XML documents:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`DOMDocument`如何处理读取XML文档：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `DOM` and `SimpleXMLElement` extensions make it quite easy to read the values
    from the XML document, as long as we are confident about the integrity of its
    structure. When dealing with XML documents, we should evaluate our use case based
    on factors such as document size. While the `XMLReader` and `XMLWriter` classes
    are more verbose to deal with, they tend to be more performance efficient when
    used properly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`DOM`和`SimpleXMLElement`扩展使从XML文档中读取值变得非常容易，只要我们对其结构的完整性有信心。在处理XML文档时，我们应该根据诸如文档大小之类的因素评估我们的用例。虽然`XMLReader`和`XMLWriter`类在处理时更冗长，但在正确使用时它们往往更高效。'
- en: Now that we have gained a basic insight into dealing with XML documents in PHP,
    let's create our first SOAP server.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对在PHP中处理XML文档有了基本的了解，让我们创建我们的第一个SOAP服务器。
- en: Creating server
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务器
- en: The PHP `soap` extension provides `SoapClient` and `SoapServer` classes. We
    can use the `SoapServer` class to set up a SOAP service server with or without
    a WSDL service description file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: PHP `soap`扩展提供了`SoapClient`和`SoapServer`类。我们可以使用`SoapServer`类来设置具有或不具有WSDL服务描述文件的SOAP服务服务器。
- en: When used without WSDL (non-WSDL mode), `SoapClient` and `SoapServer` use a common
    exchange format, which removes the need for a WSDL file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有WSDL（非WSDL模式）的情况下使用`SoapClient`和`SoapServer`使用一个常见的交换格式，这消除了对WSDL文件的需求。
- en: 'Before moving forward, we should make sure we have the `soap` extension installed.
    We can do so by observing the output of the `php -m` console command or taking
    a look at the `phpinfo()` function output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们应该确保已安装了`soap`扩展。我们可以通过观察`php -m`控制台命令的输出或查看`phpinfo()`函数的输出来实现：
- en: '![](assets/00c54baf-529e-4228-8d4d-cf18b4a4aefe.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/00c54baf-529e-4228-8d4d-cf18b4a4aefe.png)'
- en: 'With the soap extension available and loaded, we can prepare our `soap-service`
    project directory as per the following structure:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有了可用和加载的soap扩展，我们可以按照以下结构准备我们的`soap-service`项目目录：
- en: '![](assets/c2b3e4f3-786f-49c3-9a32-a6643d21490a.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c2b3e4f3-786f-49c3-9a32-a6643d21490a.png)'
- en: Moving forward, we will assume that the web server is configured to serve content
    from the `soap-service/server` directory to [http://soap-service.server](http://soap-service.server) requests,
    and content from the `soap-service/client` directory to [http://soap-service.client](http://soap-service.client) requests.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 继续向前，我们将假设Web服务器配置为从`soap-service/server`目录提供内容到[http://soap-service.server](http://soap-service.server)请求，并从`soap-service/client`目录提供内容到[http://soap-service.client](http://soap-service.client)请求。
- en: 'Let''s create a small SOAP service with two different classes, each with the
    same `welcome()` method. We can start off by creating the `soap-service/server/services/Foggyline/Customer.php`
    file with the following content:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个小的SOAP服务，其中包含两个不同的类，每个类都有相同的`welcome()`方法。我们可以首先创建`soap-service/server/services/Foggyline/Customer.php`文件，内容如下：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s create the `soap-service/server/services/Foggyline/User.php` file
    with the following content:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建`soap-service/server/services/Foggyline/User.php`文件，内容如下：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With the two classes in place, let''s create a proxy class to wrap around them.
    We do so by creating the `soap-service/server/ServiceProxy.php` file with the
    following content:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个类，让我们创建一个代理类来包装它们。我们通过创建`soap-service/server/ServiceProxy.php`文件来实现：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have our proxy class, we can create the actual `SoapServer` instance.
    We do so by creating the `soap-service/server/index.php` file with the following
    content:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了代理类，我们可以创建实际的`SoapServer`实例。我们通过创建`soap-service/server/index.php`文件来实现：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we are instantiating the `SoapServer` instance, passing it null for the `$wsdl`
    parameter and only a `'uri'` option under the `$options` parameter. The URI must
    be specified in a non-wsdl mode. We then use the `setClass()` instance method
    to set the class that will handle incoming SOAP requests. Unfortunately, we cannot
    pass an array of classes or call the `setClass()` method multiple times to add
    several different handling classes at once, which is why we created the `ServiceProxy`
    class to wrap around both `Customer` and `User` classes. Finally, we called the
    `handle()` method of the `$server` instance, which handles a SOAP request. At
    this point, our SOAP service server should be fully operational.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实例化`SoapServer`实例，将null传递给`$wsdl`参数，并在`$options`参数下只传递一个`'uri'`选项。URI必须在非wsdl模式下指定。然后我们使用`setClass()`实例方法来设置处理传入SOAP请求的类。不幸的是，我们不能传递一个类数组或多次调用`setClass()`方法一次添加多个不同的处理类，这就是为什么我们创建了`ServiceProxy`类来包装`Customer`和`User`类。最后，我们调用了`$server`实例的`handle()`方法，处理SOAP请求。此时，我们的SOAP服务服务器应该是完全可操作的。
- en: Creating WSDL file
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建WSDL文件
- en: 'However, before we move onto the client, let''s take a quick look at WSDL.
    The `@soap` tag used on the `ServiceProxy` class methods has nothing to do with
    the functioning of `SoapServer` as it is now. We used it merely because of the php2wsdl
    library that enables us to auto-generate a WSDL file based on the provided class. The php2wsdl
    library is provided as a composer package, which means we can install it by simply
    running the following command within the `soap-service/server` directory:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在转向客户端之前，让我们快速看一下WSDL。`ServiceProxy`类方法上使用的`@soap`标签与`SoapServer`的功能无关。我们之所以使用它，仅仅是因为php2wsdl库使我们能够根据提供的类自动生成WSDL文件。php2wsdl库作为一个composer包提供，这意味着我们可以通过在`soap-service/server`目录中简单运行以下命令来安装它：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once installed, we can create the `soap-service\server\wsdl-auto-gen.php` file
    with the following content:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，我们可以创建`soap-service\server\wsdl-auto-gen.php`文件，内容如下：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once we execute `wsdl-auto-gen.php`, either in the console or in the browser,
    it will generate the `soap-service/server/wsdl.xml` file with the following content:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在控制台或浏览器中执行`wsdl-auto-gen.php`，它将生成`soap-service/server/wsdl.xml`文件，内容如下：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is quite a long file to write manually. The benefit of it is that various
    third-party tools and other language libraries can easily consume our service
    once we set the WSDL file. As an example, this is a screenshot of the Wizdler
    extension for the Chrome browser, interpreting the WSDL file content:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当长的文件需要手动编写。好处是一旦设置了WSDL文件，各种第三方工具和其他语言库就可以轻松消费我们的服务。例如，这是Chrome浏览器的Wizdler扩展的屏幕截图，解释了WSDL文件的内容：
- en: '![](assets/eb1e49d7-b0ef-4cba-9ae6-26abab4a028d.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/eb1e49d7-b0ef-4cba-9ae6-26abab4a028d.png)'
- en: 'With WSDL in place, we can now easily modify the `soap-service/server/index.php`
    file as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有了WSDL，我们现在可以轻松修改`soap-service/server/index.php`文件如下：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we have the SOAP server bits sorted out, let's create a client.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了SOAP服务器的问题，让我们创建一个客户端。
- en: Creating client
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建客户端
- en: 'Creating a SOAP client in PHP is a relatively simple task when we are using
    the `SoapClient` class. Let''s create the `soap-service/client/index.php` file
    with the following content:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中创建SOAP客户端是一个相对简单的任务，当我们使用`SoapClient`类时。让我们创建`soap-service/client/index.php`文件，内容如下：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Executing the client code should result in the following output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 执行客户端代码应该产生以下输出：
- en: '![](assets/f2a8a419-c30a-48d6-bf7f-00e5fab1e73d.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f2a8a419-c30a-48d6-bf7f-00e5fab1e73d.png)'
- en: 'What happens under the hood when the SOAP request is issued can be observed
    with networking tools such as Wireshark:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当发出SOAP请求时，底层发生了什么可以通过Wireshark等网络工具观察到：
- en: '![](assets/35adede7-01e3-4081-8bb7-24e7b29c231a.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/35adede7-01e3-4081-8bb7-24e7b29c231a.png)'
- en: 'This shows us the exact content of an individual SOAP request, such as that
    for `$client->customerWelcome(''John'')`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了单个SOAP请求的确切内容，例如`$client->customerWelcome('John')`的请求：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Understanding the structure and content of the SOAP request makes it possible
    to even use the `cURL` functions to handle request-response communication, although
    that would be much more cumbersome and error-prone than dealing with the `SoapClient`
    and `SoapServer` classes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 了解SOAP请求的结构和内容使得甚至可以使用`cURL`函数来处理请求-响应通信，尽管这比处理`SoapClient`和`SoapServer`类要困难得多且容易出错。
- en: Throughout this section, we have touched upon some of the key points of SOAP
    services. While there is much more to be said about the SOAP specification, the examples
    presented here are a nice starting point to writing SOAP services.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经触及了一些SOAP服务的关键点。虽然关于SOAP规范还有很多要说的，但这里呈现的示例是编写SOAP服务的一个不错的起点。
- en: A somewhat simpler variant of a web service would be REST.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简单的Web服务变体将是REST。
- en: Working with REST
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REST
- en: Unlike SOAP, REST is an architectural style. It has no protocols or standards
    of its own. It relies on URLs and HTTP verbs, such as POST, GET, PUT, and DELETE,
    in order to establish a message exchange process. The lack of standard makes it somewhat
    challenging to talk about, as various REST service implementations may present
    a client with different ways to consume services. When it comes to juggling data
    back and forth, we are free to choose over JSON, XML, or any other format we prefer.
    The simplicity and lightweightness of JSON made it a popular choice among many
    users and frameworks.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与SOAP不同，REST是一种架构风格。它没有自己的协议或标准。它依赖于URL和HTTP动词，如POST、GET、PUT和DELETE，以建立消息交换过程。缺乏标准使得它在一定程度上具有挑战性，因为各种REST服务实现可能以不同的方式向客户端提供消费服务的途径。在来回搬运数据时，我们可以自由选择JSON、XML或其他任何我们喜欢的格式。JSON的简单性和轻量性使其成为许多用户和框架中的热门选择。
- en: Loosely speaking, the very act of opening a web page in the browser can be interpreted
    as a REST call, where the browser acts as a client and server acts as a REST service.
    Unlike browser pages that may involve cookies and sessions, REST relies on stateless
    operations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 宽泛地说，浏览器中打开网页的行为可以被解释为一个REST调用，其中浏览器充当客户端，服务器充当REST服务。与可能涉及cookie和会话的浏览器页面不同，REST依赖于无状态操作。
- en: Moving forward, we will assume that our web server is configured to serve content
    of the `rest-service/server` directory for [http://rest-service.server](http://rest-service.server) requests,
    and content of the `rest-service/client` directory for [http://rest-service.client](http://rest-service.client) requests.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 继续向前，我们将假设我们的Web服务器配置为为[http://rest-service.server](http://rest-service.server)请求提供`rest-service/server`目录的内容，并为[http://rest-service.client](http://rest-service.client)请求提供`rest-service/client`目录的内容。
- en: JSON extensions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON扩展
- en: Over the years, the JSON data format has become somewhat of a default data exchange format
    for REST. The simplicity of JSON made it quite popular with PHP developers. Out
    of the box, the PHP language provides the `json_encode()` and `json_decode()`
    functions. Using these functions, we can easily encode PHP arrays and objects
    as well as decode various JSON structures.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，JSON数据格式已经成为REST的默认数据交换格式。JSON的简单性使其在PHP开发人员中相当受欢迎。PHP语言提供了`json_encode()`和`json_decode()`函数。使用这些函数，我们可以轻松地对PHP数组和对象进行编码，以及解码各种JSON结构。
- en: 'The following example demonstrates the simplicity of using the `json_encode()`
    function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了使用`json_encode()`函数的简单性：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following example demonstrates the simplicity of using the `json_decode()`
    function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了使用`json_decode()`函数的简单性：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is where limitations kick in. Notice how the JSON object was converted
    to a `stdClass` type object in PHP. There is no direct way to pour this into a
    `User` type of object. We could, of course, write a custom functionality that
    tries to convert a `stdClass` object to an instance of `User` if needed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是限制开始发挥作用的地方。请注意，JSON对象在PHP中被转换为`stdClass`类型对象。没有直接的方法将其转换为`User`类型的对象。当然，如果需要，我们可以编写自定义功能，尝试将`stdClass`对象转换为`User`的实例。
- en: Creating server
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务器
- en: 'Put simply, REST servers send HTTP responses based on a given URL and HTTP
    verb. Keeping that in mind, let''s start with the following chunk of code added
    to the `rest-service/server/customer/index.php` file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，REST服务器根据给定的URL和HTTP动词发送HTTP响应。牢记这一点，让我们从添加到`rest-service/server/customer/index.php`文件的以下代码块开始：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Funny as it looks, this, here, is already a simple REST service example--one
    that handles four different operations for a single resource. Using a tool such
    as Postman, we can trigger the `DELETE` operation on the [http://rest-service.server/customer/index.php](http://rest-service.server/customer/index.php)
    resource
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来有趣的是，这里已经是一个简单的REST服务示例--一个处理单个资源的四种不同操作。使用诸如Postman之类的工具，我们可以触发对[http://rest-service.server/customer/index.php](http://rest-service.server/customer/index.php)资源的`DELETE`操作
- en: '![](assets/7536b609-156c-4f4e-8799-304d281eabe8.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7536b609-156c-4f4e-8799-304d281eabe8.png)'
- en: Obviously, this simplified implementation does not deal with any of the things
    you would normally find in REST services, such as versioning, normalization, validation,
    **Cross-Origin Resource Sharing** (**CORS**), authentication, and others. Implementing
    all of these REST features from scratch is a time-consuming task, which is why
    we might want to take a look at solutions provided by existing frameworks.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种简化的实现没有处理REST服务中通常会遇到的任何事情，比如版本控制、规范化、验证、跨域资源共享（CORS）、身份验证等。从头开始实现所有这些REST功能是一项耗时的任务，这就是为什么我们可能需要看看现有框架提供的解决方案。
- en: 'The Silex micro-frameworks is a neat solution for quickly getting started with
    REST services. We can add Silex to our project simply by running the following
    command on console, within the `rest-service/server` directory:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Silex微框架是快速开始REST服务的一个不错的解决方案。我们可以通过在`rest-service/server`目录中的控制台上运行以下命令来简单地将Silex添加到我们的项目中：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once we get it installed, we can dump the following code into the `rest-service/server/index.php`
    file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装好了，我们可以将以下代码转储到`rest-service/server/index.php`文件中：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This too is a relatively simple example of the REST service, but one that does
    much more than our initial example. The Silex framework, in this case, introduces
    several key concepts that we can use to our advantage as we build our REST server.
    The `before`, `after`, and `error` middleware enable us to hook into three distinctive
    stages of the request handling process. Using the `before` middleware, we are
    able to inject an authentication code for example, as well as various checks for
    the validity of incoming data. REST services usually build their authentication
    around tokens, which are then passed along individual requests. The general idea
    is to have an endpoint such as `POST user/login`, where the user logs in with
    their username and password, and is then given an authentication token for use
    with the rest of the REST service calls. This token then usually gets passed around
    as a part of the request header. Now, every time the user tries to access a protected
    resource, a token is extracted from the header and looked into the database (or
    any other storage where it might be stored), to find out the user behind the token.
    The system then either allows the user to continue with the original request or
    blocks it out. This is where middleware comes in handy.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个相对简单的REST服务示例，但比我们最初的示例做得更多。在这种情况下，Silex框架引入了几个关键概念，我们可以利用这些概念来构建我们的REST服务器。`before`、`after`和`error`中间件使我们能够钩入请求处理过程的三个不同阶段。使用`before`中间件，我们可以注入身份验证代码，以及对传入数据的有效性进行各种检查。REST服务通常围绕令牌构建其身份验证，然后将其传递给各个请求。一般的想法是有一个端点，比如`POST
    user/login`，用户使用用户名和密码登录，然后获得一个用于其余REST服务调用的身份验证令牌。然后，这个令牌通常作为请求头的一部分传递。现在，每当用户尝试访问受保护的资源时，都会从头部提取一个令牌，并在数据库（或任何其他可能存储它的地方）中查找令牌背后的用户。然后系统要么允许用户继续原始请求，要么将其阻止。这就是中间件派上用场的地方。
- en: The web service authentication is an enormous topic by itself--one that won't
    be covered in this book. OAuth is the industry-standard protocol for authorization
    that is quite often used with REST style services. For more information about
    OAuth, check out [https://oauth.net](https://oauth.net).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务身份验证本身就是一个庞大的话题，本书不会涉及。OAuth是授权的行业标准协议，通常与REST风格的服务一起使用。有关OAuth的更多信息，请访问[https://oauth.net](https://oauth.net)。
- en: The way we wrap our responses is entirely up to us. Unlike with the SOAP, there
    is no long-established standard that defines the data structure of the REST service
    response. However, there are several initiatives in the last few years that try
    to tackle that challenge.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包装响应的方式完全取决于我们自己。与SOAP不同，没有长期建立的标准来定义REST服务响应的数据结构。然而，在过去几年中，有几个倡议试图解决这一挑战。
- en: JSON API is an attempt to formalize client-server interfaces that use exchange
    JSON data; check out [http://jsonapi.org/format/](http://jsonapi.org/format/)
    for more information.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: JSON API试图规范使用交换JSON数据的客户端-服务器接口；请访问[http://jsonapi.org/format/](http://jsonapi.org/format/)获取更多信息。
- en: 'To get the server working properly, we also need to add the `rest-service\server\.htaccess`
    file with the following content:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使服务器正常工作，我们还需要添加`rest-service\server\.htaccess`文件，内容如下：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Silex conveniently supports several key HTTP verbs (GET, POST, PUT, DELETE,
    PATCH, and OPTIONS), for which, we can easily implement logic in a *resource path
    + callback function* syntax:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Silex方便地支持几个关键的HTTP动词（GET、POST、PUT、DELETE、PATCH和OPTIONS），我们可以很容易地以*资源路径+回调函数*的语法实现逻辑：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This makes it easy to quickly draft a REST service, with merely a few lines
    of code. Our server example does little to nothing in terms of server security.
    Its purpose is to merely emphasize the usefulness of middleware when building
    REST services. Security aspects, such as authentication, authorization, CORS,
    HTTPS, and others should be given utmost attention.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得快速起草REST服务变得容易，只需几行代码。我们的服务器示例在服务器安全方面几乎没有做任何事情。它的目的只是强调构建REST服务时中间件的有用性。安全方面，如身份验证、授权、CORS、HTTPS等都应该引起极大的重视。
- en: Frameworks such as [http://silex.sensiolabs.org](http://silex.sensiolabs.org)
    and [https://apigility.org](https://apigility.org/) provide a great solution to write
    high-quality feature-rich REST services.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 框架如[http://silex.sensiolabs.org](http://silex.sensiolabs.org)和[https://apigility.org](https://apigility.org/)提供了一个很好的解决方案，可以编写高质量、功能丰富的REST服务。
- en: Creating client
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建客户端
- en: 'Given that REST services rely on HTTP, it''s safe to assume that writing clients
    with PHP CURL should be quite a straightforward process. Let''s create a `rest-service/client/index.php`
    file with the following content:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于REST服务依赖于HTTP，可以肯定地假设使用PHP CURL编写客户端应该是一个相当简单的过程。让我们创建一个`rest-service/client/index.php`文件，内容如下：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The Wireshark network tool tells us that this code generates the following
    HTTP request to a REST service:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark网络工具告诉我们，这段代码生成了以下HTTP请求到REST服务：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: While the CURL approach works just fine, it can quickly become cumbersome and
    error-prone. This implies the challenges of having to deal with various types
    of error responses, SSL certificates, and so on. A more elegant solution would
    be to use the HTTP client library, such as Guzzle.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然CURL方法运行良好，但很快就会变得繁琐且容易出错。这意味着必须处理各种类型的错误响应、SSL证书等挑战。更优雅的解决方案是使用HTTP客户端库，比如Guzzle。
- en: Guzzle is an MIT-licensed HTTP client written in PHP. It can easily be installed
    through composer, by running the `composer require guzzlehttp/guzzle` command.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Guzzle是一个使用PHP编写的MIT许可的HTTP客户端。可以通过运行`composer require guzzlehttp/guzzle`命令轻松安装它。
- en: 'Chances are that our REST services will be contacted more often by non-PHP
    clients than by PHP clients. With that in mind, let''s see how a simple HTML/jQuery
    client can talk to our REST service. We do so by adding the following code to `rest-service/client/index.html`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的REST服务很可能会更频繁地受到非PHP客户端的联系，而不是PHP客户端。考虑到这一点，让我们看看一个简单的HTML/jQuery客户端如何与我们的REST服务进行通信。我们通过将以下代码添加到`rest-service/client/index.html`来实现：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The jQuery `ajax()` method acts as an HTTP client. Passing it the proper parameter
    values, it was able to successfully establish request-response communication with
    the REST service.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的`ajax()`方法充当HTTP客户端。通过传递正确的参数值，它能够成功地与REST服务建立请求-响应通信。
- en: Throughout this section, we have touched upon some of the key points of REST
    services. Although we have barely scratched the surface of the overall REST architecture,
    the examples presented here should be enough to get us started. The ease of implementation
    and simplicity of JSON and HTTP make REST quite an appealing choice for modern
    applications.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经涉及了一些REST服务的关键点。虽然我们只是浅尝辄止REST架构的整体，但这里呈现的示例应该足以让我们开始。JSON和HTTP的易于实现和简单性使得REST对于现代应用程序来说是一个相当吸引人的选择。
- en: Working with Apache Thrift (RPC)
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Apache Thrift（RPC）
- en: Apache Thrift is an open source framework to build scalable cross-language services.
    It was originally developed by Facebook, then entered the Apache Incubator around
    May 2008. Simplicity, transparency, consistency, and performance are the four
    key values behind the framework.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Thrift是一个构建可扩展跨语言服务的开源框架。它最初由Facebook开发，然后于2008年5月左右进入Apache孵化器。简单性、透明性、一致性和性能是该框架背后的四个关键价值观。
- en: Unlike the REST and SOAP type of services, Thrift services use a binary form
    of communication. Luckily for us, Thrift provides a code generation engine to get
    us started. The code generation engine can pick up any **interface definition
    language** (**IDL**) file and generate PHP or other language bindings from it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与REST和SOAP类型的服务不同，Thrift服务使用二进制形式的通信。幸运的是，Thrift提供了一个代码生成引擎来帮助我们入门。代码生成引擎可以从任何**接口定义语言**（IDL）文件中提取并生成PHP或其他语言的绑定。
- en: Before we start writing our first service definition, we need to install Apache
    Thrift.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写第一个服务定义之前，我们需要安装Apache Thrift。
- en: Installing Apache Thrift
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Apache Thrift
- en: 'Apache Thrift can be installed from source files. Assuming that we have a fresh
    Ubuntu 16.10 installation, we can kick off the Apache Thrift installation steps
    using the following set of commands:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Thrift可以从源文件安装。假设我们有一个全新的Ubuntu 16.10安装，我们可以使用以下一组命令启动Apache Thrift安装步骤：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These two commands should get us the necessary tooling to compile our Apache
    Thrift source files. Once this is done, we can pull the actual source files on
    our machine:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令应该为我们提供编译Apache Thrift源文件所需的工具。完成后，我们可以在我们的机器上拉取实际的源文件：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With the source files unpacked, we can trigger the `configure` and `make` commands,
    as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 解压源文件后，我们可以触发`configure`和`make`命令，如下所示：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we need to make sure we have the `/usr/local/lib/` directory on our
    `LD_LIBRARY_PATH` path:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要确保我们的`LD_LIBRARY_PATH`路径上有`/usr/local/lib/`目录：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We should now log out of the shell and then log back in. Using the following
    command, we confirm that the Apache Thrift is installed:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该退出shell，然后重新登录。使用以下命令，我们确认安装了Apache Thrift：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This should give us the following output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们以下输出：
- en: '![](assets/bae82a87-22da-447b-b7a8-d6a90ab6c31e.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bae82a87-22da-447b-b7a8-d6a90ab6c31e.png)'
- en: 'With the `thrift` tool installed and available through the console, we can
    prepare our `thrift-service` project:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了`thrift`工具并且可以通过控制台使用后，我们可以准备我们的`thrift-service`项目：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Moving forward, we will assume that the web server is configured to serve content
    of the `thrift-service/client` directory to [http://thrift-service.client](http://thrift-service.client)
    requests, and content of the `thrift-service/server` directory to [http://thrift-service.server](http://thrift-service.server) requests.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，我们将假设Web服务器配置为将`thrift-service/client`目录的内容提供给[http://thrift-service.client](http://thrift-service.client)请求，并将`thrift-service/server`目录的内容提供给[http://thrift-service.server](http://thrift-service.server)请求。
- en: Defining service
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义服务
- en: 'Working with Apache Thrift in PHP can be described through the following few
    steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中使用Apache Thrift可以通过以下几个步骤描述：
- en: Defining the services through the IDL file
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过IDL文件定义服务
- en: Autogenerating language bindings
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动生成语言绑定
- en: Providing PHP implementation of defined interfaces
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供已定义接口的PHP实现
- en: Exposing provided service implementation through the server
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过服务器公开提供的服务实现
- en: Consuming exposed services via client
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过客户端使用暴露的服务
- en: Thrift services begin their life as `.thrift` files, that is, files described
    by IDL.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Thrift服务以`.thrift`文件的形式开始它们的生命周期，也就是说，由IDL描述的文件。
- en: 'The IDL files support definition of several data types:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: IDL文件支持定义多种数据类型：
- en: '`bool`: This is a Boolean value (true or false)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`：这是一个布尔值（true或false）'
- en: '`byte`: This is an 8-bit signed integer'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`：这是一个8位有符号整数'
- en: '`i16`: This is a 16-bit signed integer'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i16`：这是一个16位有符号整数'
- en: '`i32`: This is a 32-bit signed integer'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i32`：这是一个32位有符号整数'
- en: '`i64`: This is a 64-bit signed integer'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i64`：这是一个64位有符号整数'
- en: '`double`: This is a 64-bit floating point number'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`：这是一个64位浮点数'
- en: '`string`: This is a UTF-8 encoded text string'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`：这是一个UTF-8编码的文本字符串'
- en: '`binary`: This is a sequence of unencoded bytes'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`二进制`：这是一系列未编码的字节'
- en: '`struct`: This is essentially equivalent to classes in OOP languages, but without
    inheritance'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct`：这在面向对象编程语言中基本上相当于类，但没有继承'
- en: 'Container (`list`, `set`, `map`): This maps to common container types in most
    programming languages'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器（`list`，`set`，`map`）：这映射到大多数编程语言中的常见容器类型
- en: 'To keep things simple, we will focus our use on the `string` type. Let''s create
    our first Apache Thrift service. We do so by creating a `Greeting.thrift` file
    within the `thrift-service/` directory, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将专注于`string`类型的使用。让我们创建我们的第一个Apache Thrift服务。我们通过在`thrift-service/`目录中创建一个`Greeting.thrift`文件来实现：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can see that the Thrift file is a pure interface--there is no implementation
    here. The `namespace php user` syntax translates to *when code generation engine
    runs, generate GreetingService within user namespace for PHP type of generated
    code*. If we were using another language alongside PHP, let's say Java, we could
    easily add another line saying `namespace java customer`. This would then generate
    PHP bindings in one namespace, and Java in another.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Thrift文件是一个纯接口--这里没有实现。`namespace php user`语法转换为*当代码生成引擎运行时，在用户命名空间内为生成的PHP代码生成GreetingService*。如果我们在PHP之外使用另一种语言，比如Java，我们可以轻松地添加另一行，说`namespace
    java customer`。这将在一个命名空间中生成PHP绑定，在另一个命名空间中生成Java绑定。
- en: 'We can see that the `service` keyword is being used to specify the `GreetingService`
    interface. Within the interface, we then have two method definitions. The `hello(1:
    string name)` string receives a single name parameter, whereas `goodbye()` receives
    no parameters.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以看到`service`关键字被用来指定`GreetingService`接口。在接口内，我们有两个方法定义。`hello(1: string
    name)`接收一个名字参数，而`goodbye()`不接收任何参数。'
- en: See [https://thrift.apache.org/docs/idl](https://thrift.apache.org/docs/idl) for
    more details about IDL syntax.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有关IDL语法的更多详细信息，请参见[https://thrift.apache.org/docs/idl](https://thrift.apache.org/docs/idl)。
- en: 'With the `Greeting.thrift` file in place, we can trigger code generation to
    get us the necessary PHP bindings. We can do so by executing the following code
    on the console:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`Greeting.thrift`文件，我们可以触发代码生成以获得必要的PHP绑定。我们可以通过在控制台上执行以下代码来实现：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At this point, we should have our folder structure similar to the following
    screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的文件夹结构应该类似于以下截图：
- en: '![](assets/1041c9b3-049f-4abd-aefe-340e33ca8799.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1041c9b3-049f-4abd-aefe-340e33ca8799.png)'
- en: 'We can see that the `thrift` command generated two files for us under the `gen-php/user`
    directory. The `GreetingService.php` is file quite a large one; with nearly 500
    lines of code, it defines various helper functions and structures needed to work
    with our Thrift service:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`thrift`命令在`gen-php/user`目录下为我们生成了两个文件。`GreetingService.php`是一个相当大的文件；几乎有500行代码，它定义了与我们的Thrift服务一起使用所需的各种辅助函数和结构：
- en: '![](assets/5f7da8de-b524-41ac-8719-a9f24a34aff5.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5f7da8de-b524-41ac-8719-a9f24a34aff5.png)'
- en: 'Whereas, the `Types.php` file defines several different types for use:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 而`Types.php`文件定义了几种不同的类型供使用：
- en: '![](assets/40a4fc71-9e31-4be4-b5e7-5b89fc8134ed.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/40a4fc71-9e31-4be4-b5e7-5b89fc8134ed.png)'
- en: All of these types reside in `thrift-service/vendor/thrift/lib/php/lib/Thrift`,
    which is why we did the `git clone https://github.com/apache/thrift.git` command
    earlier. Up to this point, our `thrift-service/gen-php/user/GreetingService.php`
    service still does not really do anything in terms of the `hello()` and `goodbye()`
    method logic.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类型都驻留在`thrift-service/vendor/thrift/lib/php/lib/Thrift`中，这就是我们之前执行`git clone
    https://github.com/apache/thrift.git`命令的原因。到目前为止，我们的`thrift-service/gen-php/user/GreetingService.php`服务在`hello()`和`goodbye()`方法逻辑方面还没有真正做任何事情。
- en: Creating server
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务器
- en: 'The `thrift-service/server/` directory is where we will implement our project''s
    server bits. Let''s create a single all-in-one `thrift-service/server/index.php`
    file that implements the  `hello()` and `goodbye()` methods and exposes them through
    the [http://thrift-service.server/index.php](http://thrift-service.server/index.php) for
    any thrift request that may come in:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`thrift-service/server/`目录是我们将实现项目服务器部分的地方。让我们创建一个单一的`thrift-service/server/index.php`文件，实现`hello()`和`goodbye()`方法，并通过[http://thrift-service.server/index.php](http://thrift-service.server/index.php)将它们暴露给任何可能到来的thrift请求：'
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We started off by including the `ThriftClassLoader` class. This loader class
    then enabled us to set the auto-loading for the entire `Thrift` and `user` namespaces.
    We then moved onto the `hello()` and `goodbye()` method implementations through
    the `GreetingServiceImpl` class. Finally, we instantiated the appropriate *handler*,
    *processor*, *transport*, and *protocol* in order to be able to process incoming
    requests.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先包含了`ThriftClassLoader`类。然后，这个加载器类使我们能够为整个`Thrift`和`user`命名空间设置自动加载。然后，我们通过`GreetingServiceImpl`类实现了`hello()`和`goodbye()`方法。最后，我们实例化了适当的*handler*、*processor*、*transport*和*protocol*，以便能够处理传入的请求。
- en: Creating client
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建客户端
- en: 'The `thrift-service/client/` directory is where we will implement our project''s
    client. Let''s create a single *all-in-one* `thrift-service/client/index.php`
    file that calls the `hello()` and `goodbye()` methods from the Thrift service
    exposed on [http://thrift-service.server/index.php](http://thrift-service.server/index.php):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`thrift-service/client/`目录是我们将实现项目客户端的地方。让我们创建一个单一的`thrift-service/client/index.php`文件，从Thrift服务上的[http://thrift-service.server/index.php](http://thrift-service.server/index.php)调用`hello()`和`goodbye()`方法：'
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Much like with the server example, here, we also started by including the `ThriftClassLoader`
    class, which in turn enabled us to set the auto-loading for the entire `Thrift`
    and `user` namespaces. We then instantiated the socket, transport, protocol, and
    client, thus making a connection with the Thrift service. Both client and server
    are using the same `thrift-service/gen-php/user/GreetingService.php` file. Given
    that `GreetingServiceClient` resides within the auto-generated `GreetingService.php` file,
    this makes it easy for the client to instantly be aware of any method `GreetingService` may
    expose.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 就像服务器示例一样，在这里，我们也首先包含了`ThriftClassLoader`类，这样就能够为整个`Thrift`和`user`命名空间设置自动加载。然后我们实例化了socket、传输、协议和客户端，从而与Thrift服务建立了连接。客户端和服务器都使用相同的`thrift-service/gen-php/user/GreetingService.php`文件。鉴于`GreetingServiceClient`位于自动生成的`GreetingService.php`文件中，这使得客户端可以立即了解`GreetingService`可能公开的任何方法。
- en: 'To test our client, all we need to do is open [http://thrift-service.client/index.php](http://thrift-service.client/index.php) in
    the browser. This should give us the following output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的客户端，我们只需要在浏览器中打开[http://thrift-service.client/index.php](http://thrift-service.client/index.php)。这应该给我们以下输出：
- en: '![](assets/237508b6-9a68-44b0-bcdb-259fd4979808.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/237508b6-9a68-44b0-bcdb-259fd4979808.png)'
- en: Throughout this section, we touched upon some of the key points of Apache Thrift
    services. Although there is plenty more to be said about the Thrift's IDL and
    type system, the examples presented here are a step in the right direction.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们触及了Apache Thrift服务的一些关键点。虽然关于Thrift的IDL和类型系统还有很多要说的，但这里呈现的示例是朝着正确方向迈出的一步。
- en: Understanding microservices
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解微服务
- en: The term microservices denotes an architectural style of building applications
    taking the form of loosely coupled services. These independently deployable services
    are tiny applications most often built via a web service technology. While one
    service can communicate via SOAP, the other can be do so via REST, Apache Thrift,
    or something else. There is no standard to specify the firm requirements here.
    The general idea is to take a large monolithic application and slice it down into
    several smaller applications, that is, services, but doing so in a manner that
    serves a business goal.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“微服务”表示一种以松散耦合服务形式构建应用程序的架构风格。这些独立部署的服务通常是通过Web服务技术构建的微型应用程序。一个服务可以通过SOAP进行通信，另一个可以通过REST、Apache
    Thrift或其他方式进行通信。这里没有规定明确的要求。总体思想是将一个庞大的单体应用程序切割成几个更小的应用程序，即服务，但要以符合业务目标的方式进行切割。
- en: 'The following diagram tries to visualize this concept:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表试图可视化这个概念：
- en: '![](assets/3779faf8-7bb6-459d-86f0-e4a652e50c7d.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3779faf8-7bb6-459d-86f0-e4a652e50c7d.png)'
- en: 'Popularized by the likes of Netflix and Amazon, the microservices style sets
    out to solve a few key challenges of modern application development, some of which
    include the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由Netflix和亚马逊等公司推广，微服务风格旨在解决现代应用开发的一些关键挑战，其中包括以下几点：
- en: '**Development team size**: This is a single microservice that can be developed
    by a relatively small team'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发团队规模**：这是一个可以由相对较小的团队开发的单个微服务'
- en: '**Diversity of development skills**: These are different services that can
    be written in different programming languages'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发技能的多样性**：这些是可以用不同编程语言编写的不同服务'
- en: '**Change/upgrade**: These smaller pieces of code are easier to change or update'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改/升级**：这些更小的代码片段更容易更改或更新'
- en: '**Integration and deployment**: These smaller pieces of code are easier to
    deploy'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成和部署**：这些更小的代码片段更容易部署'
- en: '**Easier for newcomers**: These smaller pieces of code are easier to catch
    up with'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对新手更容易**：这些更小的代码片段更容易跟上'
- en: '**Business capabilities focus**: This individual service code is organized
    around specific business capability'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务能力聚焦**：这个单独的服务代码是围绕特定的业务能力组织的'
- en: '**Scalability**: Not everything scales equally; smaller chunks of code can
    be scaled more easily'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：并非所有东西都能等比例扩展；更小的代码块可以更容易地扩展'
- en: '**Fault handling**: This single faulty service does not bring an entire application
    down'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障处理**：这个单个故障服务不会导致整个应用程序崩溃'
- en: '**Technology stack**: This is less dependency on fast-chaining technology stacks'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术栈**：这减少了对快速链接技术栈的依赖'
- en: 'At the same time, they induce several new challenges, some of which include
    the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，它们也带来了一些新的挑战，其中包括以下几点：
- en: '**Service communication**: This is an extra effort involved around service
    communication'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务通信**：这是围绕服务通信涉及的额外工作'
- en: '**Distributed transactions**: These are challenges caused by business requirements
    spanning across several services'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式事务**：这些是由跨越多个服务的业务需求引起的挑战'
- en: '**Testing and monitoring**: These are somewhat more challenging than with monolith
    applications'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试和监控**：这比单体应用程序更具挑战性'
- en: '**Network latency**: Every microservice introduces an extra bit of network
    latency'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络延迟**：每个微服务都会引入额外的网络延迟'
- en: '**Fault tolerance**: These are microservices that have to be designed for failure
    from the ground up'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容错性**：这些微服务必须从根本上设计为容错'
- en: That being said, building microservices is all but an easy task. Going *monolith
    first*, with a carefully decoupled and modular structure, may be a better starting
    point for most of the applications. Once a monolithic grows to the point where
    its complexities begin to affect the way we manage it, then it's time to consider
    slicing it into microservices.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，构建微服务绝非易事。首先采用*单体架构*，以精心解耦和模块化的结构作为大多数应用的更好起点。一旦单体应用增长到影响我们管理方式的复杂程度，那么就是考虑将其切分为微服务的时候了。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Throughout this chapter, we took a look at two of the most common and well-established
    web services: SOAP and REST. We also looked into a rising new star called Apache
    Thrift. Once we pass the barrier of initial Apache Thrift installation and setup,
    features such as simplicity, scalability, speed, and portability certainly come
    into focus. As we saw in our client example, the RPC calls can easily be implemented
    with a central code repository--the `thrift-service/gen-php/` directory in our
    case.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了两种最常见和成熟的网络服务：SOAP和REST。我们还研究了一个新兴的明星，叫做Apache Thrift。一旦我们通过了初始的Apache
    Thrift安装和设置障碍，诸如简单性、可扩展性、速度和可移植性等特性就会成为焦点。正如我们在客户端示例中看到的，RPC调用可以很容易地通过一个中央代码库来实现——在我们的情况下是`thrift-service/gen-php/`目录。
- en: While Apache Thrift has yet to catch up in terms of popularity, the fact that
    it is being used by the likes of Facebook, Evernote, Pinterest, Quora, Uber, and
    other well-known names, certainly speaks for itself. This is not to say that future-wise
    SOAP or REST are less important. Choosing the right type of service is a matter of
    *careful planning* and *forward thinking*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Apache Thrift在流行度方面还有待赶上，但它被Facebook、Evernote、Pinterest、Quora、Uber等知名公司使用的事实，无疑说明了它的价值。这并不是说未来方面SOAP或REST就不重要。选择正确的服务类型是一种*谨慎规划*和*前瞻思维*的问题。
- en: Finally, we glossed over some of the key points of an emerging a new architectural
    style called microservices.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要介绍了一种新兴的架构风格，称为微服务的一些关键要点。
- en: 'Moving forward, we will take a closer look at working with some of the most
    commonly used databases in PHP applications: MySQL, Mongo, Elasticsearch, and
    Redis.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 前进时，我们将更仔细地研究在PHP应用程序中使用的一些最常用的数据库：MySQL、Mongo、Elasticsearch和Redis。
