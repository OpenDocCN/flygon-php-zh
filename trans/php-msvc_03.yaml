- en: Chapter 3. Application Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。应用程序设计
- en: In the previous chapters, we looked at a brief description of the application
    we will build. It is now time to give you an in-depth look of the overall project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们看了一下我们将要构建的应用程序的简要描述。现在是时候让您深入了解整个项目了。
- en: Microservices structure
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务结构
- en: We want to build a geolocalization application and we chose to create it like
    a game so that it is more fun and easier to understand. Feel free to adapt the
    example to any other idea, for example, a tourism application with geolocalization
    embedded.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望构建一个地理定位应用程序，并选择将其创建为一个游戏，以使其更有趣且更易于理解。请随意将示例调整为任何其他想法，例如嵌入地理定位的旅游应用程序。
- en: Our game will use geolocalization to find different secrets all around the world
    (or in a specific geographic area if you want a smaller map). The backend system
    will generate new secrets and place them randomly on our map, allowing the users
    to explore their environment to find them. As a player of our game, you will collect
    the different secrets and store them in your *wallet*, which is where you will
    find more information about each of them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏将使用地理定位来发现世界各地的不同秘密（或者在特定地理区域内，如果您想要一个较小的地图）。后端系统将生成新的秘密并将它们随机放置在我们的地图上，允许用户探索他们的环境以找到它们。作为我们游戏的玩家，您将收集不同的秘密并将它们存储在您的*钱包*中，这是您将找到有关每个秘密的更多信息的地方。
- en: To make our game more fun, we will have a battle engine. While you are discovering
    our *secret world*, you can battle against other players to steal his/her *secrets*.
    The battle engine will be a simple one--just throw a dice and the highest score
    wins the battle.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的游戏更有趣，我们将拥有一个战斗引擎。当您发现我们的*秘密世界*时，您可以与其他玩家进行战斗，以窃取他/她的*秘密*。战斗引擎将是一个简单的引擎--只需掷骰子，得分最高者赢得战斗。
- en: A project of this kind cannot be completed without other services, such as a
    user/player management system among others.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的项目不能没有其他服务完成，例如用户/玩家管理系统等。
- en: 'As a developer, you start with a specification and you try to decompose it
    into smaller parts. From our little description, we can start defining our microservices
    and their responsibilities as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，您从规范开始，然后尝试将其分解为更小的部分。根据我们的简要描述，我们可以开始定义我们的微服务及其责任如下：
- en: '**User service**: The main responsibility of this service is user registration
    and management. To keep the example small, we will also add extra functionalities, such
    as user notifications and secrets wallet management.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户服务：这项服务的主要责任是用户注册和管理。为了使示例简单，我们还将添加额外的功能，例如用户通知和秘密钱包管理。
- en: '**Battle service**: This service will be responsible for the users battle,
    keeping a record of each battle and moving secrets from the loser wallet to the
    winner.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 战斗服务：这项服务将负责用户的战斗，记录每场战斗并将秘密从失败者的钱包转移到获胜者的钱包。
- en: '**Secret service**: This is one of the core services for our game because it
    will be responsible for all the secrets stuff.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密服务：这是我们游戏的核心服务之一，因为它将负责所有秘密事务。
- en: '**Location service**: To add an extra layer of complexity, we decided to create
    a service to manage any task related to locations. The main responsibility is
    to know where everything is located; for example, if the user service needs to
    know if there are other players in the area, sending a message with the geolocalization
    to this service, the response will tell the User Service who is in the area.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置服务：为了增加额外的复杂性，我们决定创建一个服务来管理与位置相关的任何任务。主要责任是知道所有东西的位置；例如，如果用户服务需要知道该区域是否有其他玩家，向该服务发送带有地理定位的消息，响应将告诉用户服务谁在该区域。
- en: Note that we are not only creating services for our game, but we will be using
    other supporting services to make everything work smoothly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不仅为我们的游戏创建服务，而且我们将使用其他支持服务使一切运行顺利。
- en: 'The following diagram describes the communication paths between our different
    services. Every service will be able to talk to other services so that we can
    compose bigger and more complex tasks. The following diagram depicts connections
    between our microservices:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了我们不同服务之间的通信路径。每个服务都能够与其他服务交流，这样我们就可以组合更大更复杂的任务。以下图表描述了我们微服务之间的连接：
- en: '![Microservices structure](graphics/B06142_03_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![微服务结构](graphics/B06142_03_01.jpg)'
- en: Microservice patterns
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务模式
- en: A design pattern is a reusable solution to a recurrent problem in a real-world
    application development. These solutions have a proven track record of success
    and they are widely used, so adding them to our project will make our software
    more stable and reliable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是在现实世界应用程序开发中解决重复问题的可重用解决方案。这些解决方案已经被证明具有成功的记录，并且被广泛使用，因此将它们添加到我们的项目中将使我们的软件更加稳定和可靠。
- en: 'We are building a microservice application and because we want it to be as
    stable and reliable as possible, we will use some microservice patterns, such
    as: API gateway, service discovery and registry, and shared database or database
    per service.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建一个微服务应用程序，因为我们希望它尽可能稳定和可靠，所以我们将使用一些微服务模式，例如：API网关、服务发现和注册表，以及共享数据库或每个服务一个数据库。
- en: API gateway
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API网关
- en: We will have a frontend for the users to register and interact with our application
    and it will be the main client of our microservices. Also, we are planning to
    have native mobile applications in the future. Having different clients using
    our application can create headaches for us because their use of our microservices
    can be very different.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为用户提供前端注册和与我们的应用程序交互，并且它将是我们微服务的主要客户端。此外，我们计划将来拥有原生移动应用程序。由于不同的客户端使用我们的应用程序可能会给我们带来麻烦，因为他们对我们的微服务的使用可能会有很大不同。
- en: 'To unify the way any client uses our microservices, we will be adding an extra
    layer--an API gateway. This API gateway becomes the single entry point for any
    client (for example, browser and native application). In this layer, our gateway
    can handle the request in two ways: some requests are simply proxied and others
    are fanned out to multiple services. We can even use this API gateway as a security
    layer, checking whether each request from the client is allowed to use our microservices
    or not:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了统一任何客户端使用我们的微服务的方式，我们将添加一个额外的层--一个API网关。这个API网关成为任何客户端（例如浏览器和原生应用程序）的单一入口点。在这一层，我们的网关可以以两种方式处理请求：一些请求只是被代理，而其他请求则被分发到多个服务。我们甚至可以将这个API网关用作安全层，检查客户端的每个请求是否被允许使用我们的微服务：
- en: '![API gateway](graphics/B06142_03_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![API网关](graphics/B06142_03_02.jpg)'
- en: Assets' requests
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 资产请求
- en: 'Having an API gateway has numerous benefits, among which we can highlight the
    following ones:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有API网关有许多好处，其中我们可以强调以下几点：
- en: Our application will have a single point of access, removing the problem of
    clients needing to know where each microservice is.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用程序将有一个单一的访问点，消除了客户端需要知道每个微服务位置的问题。
- en: We have a bigger control of how our services are used, and we can even provide
    custom endpoints for specific clients.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以更好地控制我们的服务如何被使用，甚至可以为特定客户提供自定义端点。
- en: It reduces the number of requests/roundtrips. With one single round-trip, a
    client can retrieve data from multiple services.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它减少了请求/往返的次数。通过一次往返，客户端可以从多个服务中检索数据。
- en: Service discovery and registry
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务发现和注册
- en: Our services will need to call other services. On monolithic applications, the
    solution is very simple--we can call methods or use procedure calls. We are building
    a microservices application running in containers, so there is no easy way of
    knowing where some service is located. Our containers infrastructure is very flexible
    and we need to build a service discovery system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务将需要调用其他服务。在单体应用程序中，解决方案非常简单--我们可以调用方法或使用过程调用。我们正在构建一个运行在容器中的微服务应用程序，所以没有简单的方法可以知道某个服务的位置。我们的容器基础设施非常灵活，我们需要构建一个服务发现系统。
- en: 'Each of our services will obtain the location of all the other linked services
    by querying our service registry (a place where we store information about all
    our services using Consul). Our registry will know the locations of each service
    instance. The following figure shows the autodiscovery pattern:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的每个服务将通过查询我们的服务注册表（一个使用Consul存储有关所有服务信息的地方）来获取所有其他链接服务的位置。我们的注册表将知道每个服务实例的位置。下图显示了自动发现模式：
- en: '![Service discovery and registry](graphics/B06142_03_03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![服务发现和注册](graphics/B06142_03_03.jpg)'
- en: 'To achieve this, we will use different tools:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用不同的工具：
- en: '**Consul**: This is our service registry with loads of features, such as clustering
    support, among others.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Consul**：这是我们的服务注册表，具有许多功能，如集群支持等。'
- en: '**Fabio**: This is a reverse proxy built on Go and has a deep integration with
    Consul. What we like about this proxy is the easy connection with Consul and its
    ability to do blue-green deploys. Another interesting tool you can try is Træfik.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fabio**：这是一个基于Go构建的反向代理，与Consul有深度集成。我们喜欢这个代理的原因是它与Consul的轻松连接以及其进行蓝绿部署的能力。另一个你可以尝试的有趣工具是Træfik。'
- en: '**NGINX**: A powerful HTTP server and reverse proxy, this is a very well-known
    tool for most of the web developers and was chosen due to its performance and
    low memory footprint. We will be using Fabio and NGINX as reverse proxies indistinctly.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NGINX**：这是一个强大的HTTP服务器和反向代理，对于大多数Web开发人员来说，这是一个非常知名的工具，由于其性能和低内存占用而被选择。我们将同时使用Fabio和NGINX作为反向代理。'
- en: '**ContainerPilot**: This is a small tool written in Go. We will use this software
    to register our services in Consul, send stats of our containers to a centralized
    telemetry system, send health checks to Consul, and detect changes in other services.
    We will create some kind of auto-healing system with this tool.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ContainerPilot**：这是一个用Go编写的小工具。我们将使用这个软件将我们的服务注册到Consul中，将我们容器的统计数据发送到一个集中的遥测系统，向Consul发送健康检查，并检测其他服务的变化。我们将使用这个工具创建一种自动修复系统。'
- en: Shared database or database per service
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享数据库或每个服务一个数据库
- en: In one way or another, an application generates data that we need to store.
    In a monolithic application, there is no doubt that all the data is stored at
    the same place. The problem is when you are dealing with a microservice application
    and there is no easy response. Each application domain is unique, so there is
    no rule of thumb to solve the problem; you need to analyze your data and decide
    if you want to store all the data in a shared store, if each service has its own
    data store, or a mixture.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以某种方式，应用程序会生成我们需要存储的数据。在单体应用程序中，毫无疑问，所有数据都存储在同一个地方。问题在于当你处理微服务应用程序时，没有简单的答案。每个应用程序域都是独特的，所以没有固定的规则来解决问题；你需要分析你的数据，并决定是否要将所有数据存储在共享存储中，每个服务是否有自己的数据存储，或者混合使用。
- en: In our sample application, we will cover both the approaches but let's explain
    the benefits of each option.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例应用程序中，我们将涵盖这两种方法，但让我们解释每种选项的好处。
- en: Database per service
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每个服务一个数据库
- en: 'In this approach, we keep each microservice''s persistent data private to that
    service, the data is only accesible via its API and has numerous benefits:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们将每个微服务的持久数据保持私有，数据只能通过其API访问，并具有许多好处：
- en: It makes the services loosely coupled; you can make changes to the battle service
    without impacting the user service, for example.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使服务之间的耦合度降低；你可以对战斗服务进行更改而不影响用户服务，例如。
- en: It increases the flexibility of our application due to the fact that the data
    can only be accessed by its API; we can use different storage engines. For example,
    we can use a relational database in our user service and a NoSQL in the Location
    service.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于数据只能通过其API访问，它增加了我们应用程序的灵活性；我们可以使用不同的存储引擎。例如，我们可以在用户服务中使用关系数据库，在位置服务中使用NoSQL。
- en: Of course, this solution has a few drawbacks, the difficulty of joining data
    shared between different services being the most notable problem.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种解决方案也有一些缺点，最显著的问题是共享不同服务之间的数据的困难。
- en: Shared database
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享数据库
- en: This approach works like a database in a monolithic application--all the data
    is stored in the same engine. The main benefit is the simplicity of having everything
    in one place.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法就像在单体应用程序中的数据库一样--所有数据都存储在同一个引擎中。主要好处是将所有内容放在一个地方的简单性。
- en: 'This simplicity has some drawbacks; we highlight the following ones among them:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单性也有一些缺点；我们在其中突出以下几个：
- en: Any database change can break or impact other services
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何数据库更改都可能破坏或影响其他服务
- en: Results in a less flexible application as you are using the same engine for
    all the data
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相同的引擎处理所有数据会导致应用程序不够灵活
- en: If the data store is down, all the services that use the shared database will
    note the problem
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据存储出现问题，所有使用共享数据库的服务都会注意到这个问题。
- en: As a developer, your job is to find the best solution for each problem you need
    to solve. You need to decide how you are going to store the application data,
    always keeping in mind the benefits and drawbacks of each option.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，您的工作是为您需要解决的每个问题找到最佳解决方案。您需要决定如何存储应用程序数据，始终牢记每个选项的利弊。
- en: RESTful conventions
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful惯例
- en: '**Representational State Transfer** is the name of the method used to communicate
    with the APIs. As the name suggests, it is *stateless*; in other words, the services
    do not keep the data transferred, so if you call a microservice sending data (for
    example, a username and a password), the microservice will not remember the data
    next time you call it. The state is kept by the client, so the client needs to
    send the state every time the microservice is called.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**表述状态转移**是用于与API通信的方法的名称。顾名思义，它是*无状态*的；换句话说，服务不会保留传输的数据，因此，如果您调用一个发送数据的微服务（例如，用户名和密码），微服务将不会在下次调用时记住数据。状态由客户端保留，因此客户端需要每次调用微服务时发送状态。'
- en: A good example of this is when a user is logged in and the user is able to call
    a specific method, so it is necessary to send the user credentials (username and
    password or token) every time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是当用户登录并且用户能够调用特定方法时，每次都需要发送用户凭据（用户名和密码或令牌）。
- en: The concept of a Rest API is not a service anymore; instead of that, it is like
    a resource container available to be communicated by identifiers (URIs).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Rest API的概念不再是一个服务；相反，它就像一个资源容器，可以通过标识符（URI）进行通信。
- en: In the following lines, we will define some interesting conventions about APIs.
    It is important to know these kinds of tips because you should do things as you
    would like to find them when you are working on an API. In other words, writing
    an API is like writing a book for yourself--it will be read by developers like
    you, so the perfect functionality is not the only important thing, the friendly
    way to talk is important too.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几行中，我们将定义一些有关API的有趣的惯例。了解这些提示很重要，因为在编写API时，您应该像在API上工作时一样做事情。换句话说，编写API就像为自己写书一样--它将被像您一样的开发人员阅读，因此完美的功能并不是唯一重要的事情，友好的交流方式也很重要。
- en: Creating a RESTful API will be easier for you and the consumers if you follow
    some conventions in order to make them happy. I have been using some recommendations
    on my RESTful APIs and the results were really good. They help to organize your
    application and its future maintenance needs. Also, your API consumers will thank
    you when they enjoy working with your application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遵循一些惯例，为您和消费者创建一个RESTful API将会更容易让他们满意。我一直在我的RESTful API上使用一些建议，结果非常好。它们有助于组织您的应用程序及其未来的维护需求。此外，当API消费者享受与您的应用程序一起工作时，他们会感谢您。
- en: Security
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全
- en: Security in your RESTful API is important, but it is especially important if
    your API is going to be consumed by people you do not know, in other words, if
    it is going to be available to everybody.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API中的安全性很重要，但如果您的API将被您不认识的人使用，换句话说，如果它将对所有人开放，那么它就尤为重要。
- en: Use SSL everywhere--it is important for the security of your API. There are
    many public places without an SSL connection and it is possible to sniff packages
    and get other people's credentials.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到处使用SSL--这对于您的API的安全性很重要。有许多没有SSL连接的公共场所，可以嗅探数据包并获取其他人的凭据。
- en: Use token authentication, but it is mandatory to use SSL if you want to use
    a token to authenticate the users. Using a token avoids sending entire credentials
    every time you need to identify the current user. If it is not possible, you can
    use OAuth2.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用令牌身份验证，但如果要使用令牌对用户进行身份验证，则必须使用SSL。使用令牌可以避免每次需要识别当前用户时发送完整凭据。如果不可能，您可以使用OAuth2。
- en: Provide response headers useful to limit and avoid too many requests by the
    same consumer. One of the problems with big companies is the traffic or even people
    trying to do bad things with your API. It is good to have some kind of method
    to avoid these kinds of problems.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供响应头，以限制和避免同一消费者发送过多请求。大公司的一个问题是流量，甚至有人试图对您的API做坏事。有一种方法可以避免这类问题是很好的。
- en: Standards
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准
- en: 'Bit by bit, more standards for PHP and microservices are appearing. As we saw
    in the last chapter, there are groups, such as PHP-FIG, trying to establish them.
    Here are some tips to make your API more standard:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: PHP和微服务的更多标准正在逐渐出现。正如我们在上一章中看到的，有一些团体，比如PHP-FIG，正在努力建立它们。以下是一些使您的API更加标准的提示：
- en: Use JSON everywhere. Avoid using XML; if there is a standard for RESTful APIs,
    it is JSON. It is more compact and can be easily loaded in web languages.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到处使用JSON。避免使用XML；如果有一个RESTful API的标准，那就是JSON。它更紧凑，可以在Web语言中轻松加载。
- en: Use camelCase instead of snake_case; it is easier to read.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用驼峰命名法而不是蛇形命名法；这样更容易阅读。
- en: Use HTTP status code errors. There are standard statuses for each situation,
    so use them to avoid explaining every response of your API better.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP状态码错误。每种情况都有标准状态，因此使用它们可以避免解释API的每个响应。
- en: Include the versioning in the URL, do not put it on the header. The version
    needs to be in the URL to ensure browser explorability of the resources across
    versions.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在URL中包含版本信息，不要将其放在头部。版本信息需要在URL中，以确保资源在不同版本之间的浏览器可探索性。
- en: Provide a way to override the HTTP method. Some browsers only allow `POST` and
    `GET` requests, so it will be good to allow a `X-HTTP-Method-Override` header
    to override `PUT`, `PATCH`, and `DELETE`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种覆盖HTTP方法的方式。一些浏览器只允许`POST`和`GET`请求，因此允许使用`X-HTTP-Method-Override`头来覆盖`PUT`、`PATCH`和`DELETE`将是有益的。
- en: Consumer amenities
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费者便利设施
- en: 'The consumers of your API are the most important, so you need to provide useful,
    helpful, and friendly ways to make the developer''s job easier. Develop the methods
    thinking about them:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您的API的使用者是最重要的，因此您需要提供有用、友好的方法来使开发人员的工作更轻松。开发方法时要考虑到他们：
- en: Limit the response data. The developer will not need all the available data,
    so you can limit the response using a filter for the fields to return.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制响应数据。开发人员不需要所有可用的数据，因此可以使用字段过滤器限制响应。
- en: Use query parameters to filter and sort results. It will help you simplify your
    API.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用查询参数来过滤和排序结果。这将有助于简化您的API。
- en: Remember that your API is going to be used by different developers, so look
    after your documentation--it needs to be really clear and friendly.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住您的API将被不同的开发人员使用，因此要注意您的文档——它需要非常清晰和友好。
- en: Return something useful on the `POST`, `PATCH`, and `PUT` requests. Avoid making
    the developer call to the API too many times to get the required data.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`POST`、`PATCH`和`PUT`请求上返回有用的内容。避免开发人员多次调用API以获取所需的数据。
- en: It is good to provide a way to autoload related resource representations in
    the response. It would be helpful for the developers in order to avoid requesting
    the same thing many times to get all the necessary data. It is possible to do this
    by including filters to define specific parameters in the URL.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种在响应中自动加载相关资源表示的方式。这对开发人员来说将是有帮助的，以避免多次请求相同的内容以获取所有必要的数据。可以通过在URL中包含过滤器来定义特定参数来实现这一点。
- en: Make the pagination using link headers, then the developers will not need to
    make the links on their own.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用链接头来进行分页，这样开发人员就不需要自己创建链接。
- en: Include response headers that facilitate caching. HTTP has included a framework
    to do this just by adding some headers.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括促进缓存的响应头。HTTP已经包含了一个框架，只需添加一些头部即可实现这一点。
- en: There are a lot more tips, but these ones are enough for the first approach
    to RESTful conventions. In the subsequent chapters, we will see examples of these
    RESTful conventions and explain how they should be used better.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多提示，但这些足以作为RESTful约定的第一步。在接下来的章节中，我们将看到这些RESTful约定的示例，并解释如何更好地使用它们。
- en: Caching strategy
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存策略
- en: Phil Karlton
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Phil Karlton
- en: '>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*"There are only two hard things in Computer Science: cache invalidation and
    naming things."*'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “在计算机科学中只有两件难事：缓存失效和命名事物。”
- en: A cache is a component that stores data temporarily so that future requests
    for that data can be served faster. This temporal storage is used to shorten our
    data access times, reduce latency, and improve I/O. We can improve the overall
    performance using different types of caches in our microservice architecture.
    Let's take a look at this subject.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是一个组件，用于临时存储数据，以便将来对该数据的请求可以更快地提供。这种临时存储用于缩短我们的数据访问时间，减少延迟，并改善I/O。我们可以在微服务架构中使用不同类型的缓存来提高整体性能。让我们来看看这个主题。
- en: General caching strategy
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般的缓存策略
- en: 'To maintain the cache, we have algorithms that provide instructions which tell
    us how the cache should be maintained. The most common algorithms are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了维护缓存，我们有算法提供指示，告诉我们应该如何维护缓存。最常见的算法如下：
- en: '**Least Frequently Used (LFU)**: This strategy uses a counter to keep track
    of how often an entry is accessed and the element with the lowest counter is removed
    first.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最不经常使用（LFU）**：此策略使用计数器来跟踪条目的访问频率，并首先删除计数最低的元素。'
- en: '**Least Recently Used (LRU)**: In this case, the recently-used items are always
    near the top of the cache and when we need some space, elements that have not
    been accessed recently are removed.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最近最少使用（LRU）**：在这种情况下，最近使用的项目总是靠近缓存的顶部，当我们需要一些空间时，将删除最近未被访问的元素。'
- en: '**Most Recently Used (MRU)**: The recently-used items are removed first. We
    will use this approach in situations where older items are more commonly accessed.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最近最常使用（MRU）**：首先删除最近使用的项目。我们将在较老的项目更常被访问的情况下使用这种方法。'
- en: 'The perfect time to start thinking about your cache strategy is when you are
    designing each of the microservices required by your app. Every time your service
    returns data, you need to ask to yourself some questions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序所需的每个微服务时，开始考虑缓存策略的最佳时机。每当您的服务返回数据时，您需要问自己一些问题：
- en: Are we returning sensible data we can't store at any place?
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否返回了无法在任何地方存储的合理数据？
- en: Are we returning the same result if we keep the input the same?
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入相同，我们是否返回相同的结果？
- en: How long can we store this data?
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以存储这些数据多久？
- en: How do we want to invalidate this cache?
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要如何使缓存失效？
- en: You can add a cache layer at any place you want in your application. For example,
    if you are using Percona/MySQL/MariaDB as a data storage, you can enable and set
    up the query cache correctly. This little setup will give your database a boost.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在应用程序中的任何位置添加缓存层。例如，如果您正在使用Percona/MySQL/MariaDB作为数据存储，可以正确启用和设置查询缓存。这个小设置将提升您的数据库性能。
- en: 'You need to think about cache even when you are coding. You can do lazy loading
    on objects and data or build a custom cache layer to improve the overall performance.
    Imagine that you are requesting and processing data from an external storage,
    the requested data can be repeated several times in the same execution. Doing
    something similar to the following piece of code will reduce the calls to your
    external storage:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在编码时，你也需要考虑缓存。你可以对对象和数据进行延迟加载，或者构建一个自定义的缓存层来提高整体性能。想象一下，你正在从外部存储请求和处理数据，请求的数据可能在同一次执行中重复多次。做类似下面的代码片段将减少对外部存储的调用：
- en: '[PRE0]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that our examples omit big chunks of code, such as namespaces or other
    functions. We only want to give you the overall idea so that you can create your
    own code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的示例省略了大量的代码，比如命名空间或其他函数。我们只想给你一个整体的想法，这样你就可以创建自己的代码。
- en: In this case, we will store our data in the `$myCache` variable every time we
    make a request to our external storage using an ID as the key identifier. The
    next time we request an element with the same ID as a previous one, we will get
    the element from `$myCache` instead of requesting the data from the external storage.
    Note that this strategy is only successful if you can reuse the data in the same
    PHP execution.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将我们的数据存储在`$myCache`变量中，每当我们使用ID作为键标识符向外部存储发出请求时。下一次我们请求与之前相同ID的元素时，我们将从`$myCache`中获取元素，而不是从外部存储请求数据。请注意，只有在同一次PHP执行中可以重用数据时，这种策略才会成功。
- en: In PHP, you have access to the most popular cache servers, such as **memcached**
    and **Redis**; both of them store their data in a key-value format. Having access
    to these powerful tools will allow us to increase the performance of our microservices
    application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，你可以访问最流行的缓存服务器，比如**memcached**和**Redis**；它们都以键值格式存储数据。访问这些强大的工具将允许我们提高微服务应用程序的性能。
- en: 'Let''s rebuild our preceding example using `Redis` as our cache storage. In
    the following piece of code, we will assume that you have a `Redis` library available
    in your environment (for example, phpredis) and a `Redis` server running:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`Redis`作为我们的缓存存储来重建我们之前的示例。在下面的代码片段中，我们将假设你的环境中有一个`Redis`库可用（例如phpredis），并且有一个`Redis`服务器在运行：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we connected to the Redis server first and adapted the `getMyDataById`
    function to use our new Redis instance. This example can be more complicated,
    for example, by adding the dependence injection and storing a JSON in the cache,
    among other infinite options. One of the benefits of using a cache engine instead
    of building your own is that all of them come with a lot of cool and useful features.
    Imagine that you want to keep the data in cache for only 10 seconds; this is very
    easy to do with Redis--simply change the set call with `$this->myCache->set($id,
    $externalData, 10)` and after ten seconds your record will be wiped from the cache.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先连接到Redis服务器，并调整`getMyDataById`函数以使用我们的新Redis实例。这个例子可能会更复杂，例如通过添加依赖注入和在缓存中存储JSON等无限的选项。使用缓存引擎而不是构建自己的一个好处是，它们都带有许多很酷和有用的功能。想象一下，你想将数据保留在缓存中只有10秒；这在Redis中非常容易实现--只需用`$this->myCache->set($id,
    $externalData, 10)`替换set调用，十秒后你的记录将从缓存中删除。
- en: Something even more important than adding data to the cache engine is invalidating
    or removing the data you have stored. In some cases, it is fine to use old data
    but in other cases, using old data can cause problems. If you do not add a TTL
    to make the data expire automatically, ensure that you have a way of removing
    or invalidating the data when it is required.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 比将数据添加到缓存引擎更重要的是使你存储的数据失效或删除。在某些情况下，使用旧数据是可以接受的，但在其他情况下，使用旧数据可能会导致问题。如果你没有添加TTL来使数据自动过期，请确保你有一种在需要时删除或使数据失效的方法。
- en: Keep this example and the previous one in mind, we will be using both strategies
    in our microservice application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这个例子和前面的例子，我们将在我们的微服务应用程序中使用这两种策略。
- en: As a developer, you don't need to be tied to a specific cache engine; wrap it,
    create an abstraction, and use that abstraction so that you can change the underlying
    engine at any point without changing all the code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，你不需要被绑定到特定的缓存引擎；封装它，创建一个抽象，并使用该抽象，这样你就可以在任何时候更改底层引擎而不必更改所有的代码。
- en: This general caching strategy can be used in any scope of your application--you
    can use it inside the code of your microservice or even between microservices.
    In our application example, we will deal with *secrets*; their data doesn't change
    very often, so we can store all this information on our cache layer (Redis) the
    first time they are accessed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通用的缓存策略可以在应用程序的任何范围内使用--你可以在你的微服务代码中使用它，甚至在微服务之间使用。在我们的应用程序示例中，我们将处理*秘密*；它们的数据变化不是很频繁，所以我们可以在第一次访问时将所有这些信息存储在我们的缓存层（Redis）中。
- en: Future petitions will obtain the secrets' data from our cache layer instead
    of getting it from our data storage, improving the performance of our app. Note
    that the service that retrieves and stores the *secrets* data is the one that
    is responsible for managing this cache.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将来的请求将从我们的缓存层获取秘密数据，而不是从我们的数据存储中获取，从而提高我们应用的性能。请注意，检索和存储*秘密*数据的服务是负责管理这个缓存的服务。
- en: Let's see some other caching strategies that we will be using in our microservices
    application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们将在微服务应用程序中使用的其他缓存策略。
- en: HTTP caching
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP缓存
- en: This strategy uses some HTTP headers to determine whether the browser can use
    a local copy of the response or it needs to request a fresh copy from the origin
    server. This cache strategy is managed outside your application, so you don't
    have much control over it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略使用一些HTTP头来确定浏览器是否可以使用响应的本地副本，或者需要从源服务器请求新的副本。这种缓存策略是在应用程序之外管理的，所以你对它没有太多控制。
- en: 'Some of the HTTP headers we can use are as listed:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的一些HTTP头如下：
- en: '**Expires**: This sets a time in the future when the content will expire. When
    this point in the future is reached, any similar requests will have to go back
    to the origin server.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Expires**：设置内容将过期的未来时间。当未来的这一点到达时，任何类似的请求都必须返回到原始服务器。'
- en: '**Last-modified**: This specifies the last time that the response was modified;
    it can be used as part of your custom validation strategy to ensure that your
    users always have fresh content.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Last-modified**：指定响应最后修改的时间；它可以作为您的自定义验证策略的一部分，以确保用户始终拥有新鲜内容。'
- en: '**Etag**: This header tag is one of the several mechanisms that HTTP provides
    for web cache validation, which allows a client to make conditional requests.
    An Etag is an identifier assigned by a server to a specific version of a resource.
    If the resource changes, the Etag also changes, allowing us to quickly compare
    two resource representations to determine if they are the same.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Etag**：此标头标记是HTTP提供的用于Web缓存验证的几种机制之一，它允许客户端进行条件请求。Etag是服务器分配给资源特定版本的标识符。如果资源发生更改，Etag也会更改，从而使我们能够快速比较两个资源表示以确定它们是否相同。'
- en: '**Pragma**: This is an old header, from the HTTP/1.0 implementation. HTTP/1.1
    Cache-control implements the same concept.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pragma**：这是一个旧的标头，来自HTTP/1.0实现。HTTP/1.1 Cache-control实现了相同的概念。'
- en: '**Cache-control**: This header is the replacement for the expires header; it
    is well supported and allows us to implement a more flexible cache strategy. The
    different values for this header can be combined to achieve different caching
    behaviors.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cache-control**：此标头是expires标头的替代品；它得到了很好的支持，并允许我们实现更灵活的缓存策略。此标头的不同值可以组合以实现不同的缓存行为。'
- en: 'The following are the available options:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可用的选项：
- en: '**no-cache**: This says that any cached content must be revalidated on each
    request before being sent to a client.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**no-cache**：表示必须在每个请求之前重新验证任何缓存的内容，然后才能发送给客户端。'
- en: '**no-store**: This indicates that the content cannot be cached in any way.
    This option is useful when the response contains sensitive data.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**no-store**：表示内容无法以任何方式缓存。当响应包含敏感数据时，此选项很有用。'
- en: '**public**: This marks the content as public and it can be cached by the browser
    and any intermediate caches.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public**：将内容标记为公共，可以由浏览器和任何中间缓存进行缓存。'
- en: '**private**: This marks the content as private; this content can be stored
    by the user''s browser, but not by intermediate parties.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private**：将内容标记为私有；此内容可以由用户的浏览器存储，但不能由中间方存储。'
- en: '**max-age**: This sets the maximum age that the content may be cached before
    it must be revalidated. This option value is measured in seconds, with a maximum
    of 1 year (31,536,000 seconds).'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**max-age**：设置内容在必须重新验证之前可以缓存的最长时间。此选项值以秒为单位，最长为1年（31,536,000秒）。'
- en: '**s-maxage**: This is similar to the max-age header; the only difference is
    that this option is only applied to intermediary caches.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s-maxage**：这与max-age标头类似；唯一的区别是此选项仅应用于中间缓存。'
- en: '**must-revalidate**: This tag indicates that the rules indicated by max-age,
    s-maxage, or the expires header must be obeyed strictly.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**must-revalidate**：此标记表示必须严格遵守max-age、s-maxage或expires标头指示的规则。'
- en: '**proxy-revalidate**: This is similar to s-maxage, but only applies to intermediary
    proxies.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**proxy-revalidate**：这与s-maxage类似，但仅适用于中间代理。'
- en: '**no-transform**: This header tells caches that they are not allowed to modify
    the received content under any circumstances.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**no-transform**：此标头告诉缓存它们不得在任何情况下修改接收到的内容。'
- en: In our example application, we will have a public UI that can be reached through
    any web browser. Using the right HTTP headers, we can avoid requests for the same
    assets again and again. For example, our CSS and JavaScript files won't change
    frequently, so we can set up an expiry date in the future and the browser will
    keep a copy of them; the future requests will use the local copy instead of requesting
    a new copy.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例应用程序中，我们将拥有一个可以通过任何Web浏览器访问的公共UI。使用正确的HTTP标头，我们可以避免对相同资产的重复请求。例如，我们的CSS和JavaScript文件不会经常更改，因此我们可以设置一个未来的到期日期，浏览器将保留它们的副本；未来的请求将使用本地副本而不是请求新副本。
- en: 'You can add an expires header to all `.jpg`, `.jpeg`, `.png`, `.gif`, `.ico`,
    `.css`, and `.js` files with a date of 123 days in the future from the browser
    access time in NGINX with a simple rule:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用简单的规则在NGINX中为所有`.jpg`、`.jpeg`、`.png`、`.gif`、`.ico`、`.css`和`.js`文件添加一个到浏览器访问时间未来123天的到期标头：
- en: '[PRE2]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Static files caching
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态文件缓存
- en: 'Some static elements are very cache-friendly, among them you can cache the
    following ones:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一些静态元素非常适合缓存，其中包括以下内容：
- en: Logos and non-auto generated images
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志和非自动生成的图像
- en: Style sheets
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式表
- en: JavaScript files
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript文件
- en: Downloadable content
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可下载内容
- en: Any media files
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何媒体文件
- en: These elements tend to change infrequently, so they can be cached for longer
    periods of time. To alleviate your servers' load, you can use a **Content Delivery
    Network** (**CDN**) so that these infrequently changed files can be served by
    these external servers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元素往往很少更改，因此可以缓存更长时间。为了减轻服务器的负载，您可以使用**内容交付网络**（**CDN**），以便这些很少更改的文件可以由这些外部服务器提供。
- en: 'Basically, there are two types of CDNs:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，CDN有两种类型：
- en: '**Push CDNs**: This type requires you to **push** the files you want to store.
    It is your responsibility to ensure that you are uploading the correct file to
    the CDN and the pushed resource is available. It is mostly used with uploaded
    images, for example, the avatar of your user. Note that some CDNs can return an
    OK response after a push, but your file is not really ready yet.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Push CDNs**：这种类型要求您**推送**要存储的文件。您有责任确保将正确的文件上传到CDN，并且推送的资源可用。它主要用于上传的图像，例如用户的头像。请注意，一些CDN在推送后可以返回OK响应，但您的文件实际上还没有准备好。'
- en: '**Pull CDNs**: This is the lazy version, you don''t need to send anything to
    the CDN. When a request comes through the CDN and the file is not in their storage,
    they get the resource from your server and it stores it for future petitions.
    It is mostly used with CSS, images, and JavaScript assets.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拉CDN**：这是懒惰的版本，您不需要将任何内容发送到CDN。当请求通过CDN并且文件不在它们的存储中时，它们会从您的服务器获取资源并将其存储以供将来使用。它主要用于CSS、图像和JavaScript资源。'
- en: You need to have this in mind when you are designing your microservice application
    because you may allow your users to upload some files.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计微服务应用程序时，您需要记住这一点，因为您可能允许用户上传一些文件。
- en: Where are you going to store these files? If they are to be public, why not
    use CDN to deliver these files instead of them being gutted from your servers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在哪里存储这些文件？如果它们是公开的，为什么不使用CDN来传送这些文件，而不是从您的服务器中删除它们。
- en: Some of the well-known CDNs are CloudFlare, Amazon CloudFront, and Fastly, among
    others. What they all have in common is that they have multiple data centers around
    the world, allowing them to try to give you a copy of your file from the closest
    server.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一些著名的CDN包括CloudFlare、Amazon CloudFront和Fastly等。它们的共同之处在于它们在世界各地都有多个数据中心，使它们可以尝试从最近的服务器为您提供文件的副本。
- en: By combining HTTP with static files caching strategies, you will reduce the
    asset requests on your server to a minimum. We will not explain other cache strategies, such
    as full page caching; with what we have covered, you have enough to start building
    a successful microservice application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将HTTP与静态文件缓存策略结合起来，您将最大限度地减少服务器上的资源请求。我们不会解释其他缓存策略，比如完整页面缓存；根据我们所涵盖的内容，您已经有足够的知识来开始构建成功的微服务应用程序。
- en: Domain-driven design
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计
- en: '**Domain-driven design** (**DDD** from here on) is an approach for the development
    when it has complex needs. This concept is not new; it was created by Eric Evans
    in his book with the same title in 2004, but now it is mainstream as microservices
    are popular among developers and very common in huge projects.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域驱动设计**（从这里开始称为DDD）是一种在有复杂需求时进行开发的方法。这个概念并不新鲜；它是由Eric Evans在他2004年的同名书中创建的，但现在它是主流的，因为微服务在开发人员中很受欢迎，并且在大型项目中非常常见。'
- en: This is happening as there is great compatibility between the microservices
    concepts (regarding the software architecture, dividing every functionality into
    services) and DDD concepts (about the bounded contexts).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是发生的，因为微服务概念（关于软件架构，将每个功能划分为服务）和DDD概念（关于有界上下文）之间有很好的兼容性。
- en: Before knowing where and how we can use DDD in our microservices project, it
    is necessary to understand what DDD is and how it works, so let me introduce you
    to the main concepts as a summary of this approach.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解我们如何在微服务项目中使用DDD之前，有必要了解DDD是什么以及它是如何工作的，所以让我向您介绍这种方法的主要概念作为总结。
- en: How domain-driven design works
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域驱动设计的工作原理
- en: 'Evans introduced some concepts that are necessary to understand to learn how
    domain-driven design works:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Evans引入了一些必要的概念，以了解领域驱动设计的工作原理：
- en: '**Context**:This is the setting in which a word or statement appears that determines
    its meaning.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**：这是一个词或语句出现的环境，决定了它的含义。'
- en: '**Domain**: This is a sphere of knowledge (ontology), influence, or activity.
    The subject area to which the user applies a program is the domain of the software.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域**：这是知识（本体论）、影响或活动的领域。用户应用程序的主题领域是软件的领域。'
- en: '**Model**:This is a system of abstractions that describes selected aspects
    of a domain and can be used to solve problems related to that domain.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这是描述领域的选定方面的抽象系统，可以用来解决与该领域相关的问题。'
- en: '**Ubiquitous language**:This is a language structured around the domain model
    and used by all team members to connect all the activities of the team with the
    software.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**普遍语言**：这是围绕领域模型构建的语言，由所有团队成员使用，将团队的所有活动与软件连接起来。'
- en: The **software domain** is not related to the technical terms, programming or
    computers in any way. In most projects, the most challenging part is to understand
    the business domain, so DDD suggests using a **model domain**; this is abstract,
    ordered, and selective knowledge reproduced in a diagram, code, or just words.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件领域**与技术术语、编程或计算机无关。在大多数项目中，最具挑战性的部分是理解业务领域，因此DDD建议使用**模型领域**；这是在图表、代码或文字中复制的抽象、有序和选择性知识。'
- en: 'The model domain is like the roadmap to build projects with complex functionalities,
    and it is necessary to follow five steps to achieve it. These five steps need
    to be agreed on by the development team and the domain expert:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 模型领域就像建立具有复杂功能的项目的路线图，需要遵循五个步骤才能实现。这五个步骤需要开发团队和领域专家达成一致。
- en: '**Brainstorming and refinement**: There should be a communication channel between
    the development team and the domain expert. So, all the people in the project
    should be able to talk to everyone because they all need to know how the project
    should work.'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**头脑风暴和完善**：开发团队和领域专家之间应该有一个沟通渠道。因此，项目中的所有人都应该能够与每个人交谈，因为他们都需要知道项目应该如何工作。'
- en: '**Draft domain model**: During the conversation, it is necessary to start drawing
    a draft of the domain model, so that it can be checked and corrected by the domain
    expert until they both agree.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**草稿领域模型**：在对话过程中，有必要开始绘制领域模型的草稿，以便领域专家可以检查和纠正，直到他们达成一致。'
- en: '**Early class diagram**:Using the draft, we can start building an early version
    of the class diagram.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**早期类图**：使用草稿，我们可以开始构建类图的早期版本。'
- en: '**Simple prototype**: Using the draft of the early class diagram and domain
    model, it is possible to build a very simple prototype. Evans suggests avoiding
    things that are not related to the domain to ensure that the domain business was
    modeled properly. It can be a very simple program as a trace.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**简单原型**：使用早期类图和领域模型的草稿，可以构建一个非常简单的原型。Evans建议避免与领域无关的事物，以确保领域业务得到适当建模。它可以是一个非常简单的程序作为追踪。'
- en: '**Prototype feedback**: The domain expert interacts with the prototype in order
    to check whether all the needs are met and then the entire team will improve the
    model domain and the prototype.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**原型反馈**：领域专家与原型进行交互，以检查是否满足所有需求，然后整个团队将改进领域模型和原型。'
- en: 'This process will have all the iterations needed until the domain model is
    correct:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程将进行所有必要的迭代，直到领域模型正确为止：
- en: '![How domain-driven design works](graphics/B06142_03_04.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![领域驱动设计的工作原理](graphics/B06142_03_04.jpg)'
- en: The model, code, and design must evolve and grow together.They cannot be unsynchronized
    at all. If a concept is updated on the model, it should also be updated on the
    code and on the design automatically, and the same goes for the rest.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 模型、代码和设计必须一起发展和成长。它们不能不同步。如果模型上的概念更新了，代码和设计也应该自动更新，其他方面也是如此。
- en: A model is an abstraction system that describes selective concepts of a domain
    and it can be used to resolve problems related to that domain. If there is a piece
    of the model that is not reflected in the code, it should be removed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是描述领域的选择性概念的抽象系统，它可以用来解决与该领域相关的问题。如果模型中的某个部分在代码中没有反映出来，那么它应该被移除。
- en: 'Finally, the domain model is the base of the common language in a project.
    This common language in DDD is called **ubiquitous language** and it should have
    the following things:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，领域模型是项目中通用语言的基础。DDD中的这种通用语言称为**普遍语言**，它应该具有以下特点：
- en: Class names and their functions related to the domain
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与领域相关的类名和它们的功能
- en: Terms to discuss the domain rules included on the model
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论模型中包含的领域规则的术语
- en: Names of analysis and design patterns applied to the domain model
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用于领域模型的分析和设计模式的名称
- en: The ubiquitous language should be used by all the members of the project, including
    developers and domain experts, so the developers should be able to describe all
    the tasks and functions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 项目所有成员，包括开发人员和领域专家，都应该使用普遍语言，因此开发人员应该能够描述所有的任务和功能。
- en: It is absolutely necessary to use this language in all the discussions between
    the team, such as meetings, diagrams, or documentation, but this language was
    not born in the first iteration of the process, meaning that it can take many
    iterations of refactoring having the model, language, and code synchronized. If,
    for example, the developers discover that a class from the domain should be renamed,
    they cannot refactor this without refactoring the name on the domain model and
    the ubiquitous language.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队之间的所有讨论中绝对必须使用这种语言，比如会议、图表或文档，但这种语言并不是在过程的第一次迭代中诞生的，这意味着它可能需要多次重构，使模型、语言和代码保持同步。例如，如果开发人员发现领域中的一个类应该被重命名，他们不能在没有重构领域模型和普遍语言的情况下进行重构。
- en: The ubiquitous language, domain model, and code should evolve togetheras a single
    knowledge block.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 普遍语言、领域模型和代码应该作为一个单一的知识块一起发展。
- en: There is controversial concept on DDD. Eric Evans says that it is necessary
    for the domain expert to use the same language as the team, but some people do
    not like this idea. Usually, the domain experts do not have knowledge of object-oriented
    concepts or microservices because they are too abstract for non-developers. Anyway,
    DDD says that if the domain expert does not understand the domain model, it is
    because there is something wrong with it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 关于DDD存在争议的概念。Eric Evans说，领域专家必须使用与团队相同的语言，但有些人不喜欢这个想法。通常，领域专家不了解面向对象的概念或微服务，因为这些对非开发人员来说太抽象了。无论如何，DDD认为，如果领域专家不理解领域模型，那是因为它存在问题。
- en: There are diagrams in the domain model, but Evans suggests using text as well,
    because diagrams do not explain the concepts properly. Also, the diagrams should
    be superficial; if you want to see more details you have the code for it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型中有图表，但Evans建议也使用文本，因为图表无法正确解释概念。此外，图表应该是表面的；如果你想看更多细节，可以查看代码。
- en: Some projects are affected by the connection between the domain model and the
    code. This happens because there is a division between analysis and design. The
    analysts make a model independent of the design and the developers cannot develop
    the functionalities because some information is missing. In addition, they cannot
    talk with the domain expert. The development team will not follow the model and,
    in the end, the domain model will not be updated and it will not work. Therefore,
    the project will not meet the requirements.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目受到领域模型和代码之间的连接的影响。这是因为分析和设计之间存在分歧。分析人员制定了一个独立于设计的模型，开发人员无法开发功能，因为缺少一些信息。此外，他们无法与领域专家交流。开发团队将不遵循模型，最终领域模型将不会得到更新，也不会起作用。因此，项目将无法满足要求。
- en: To sum up, DDD works to achieve the software development as an iterative process
    of refinement of the model, design, and code as a single task in a block.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，DDD旨在将软件开发作为模型、设计和代码的迭代精炼过程，作为一个单一的任务块。
- en: Using domain-driver design in microservices
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在微服务中使用领域驱动设计
- en: As we said before, DDD meets the microservice's needs perfectly. A common problem
    with microservices appears because they have decentralized data management; this
    has advantages but can be problematic sometimes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，DDD完全满足微服务的需求。微服务的一个常见问题是它们具有分散的数据管理；这有优势，但有时也会带来问题。
- en: The concept model between two services will be different, and it can cause problems
    in huge companies. For example, a user can differ depending on the service, the
    attributes for each service regarding the user can differ and, also, the attribute
    semantic can differ.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 两个服务之间的概念模型将是不同的，这可能会在大型公司中造成问题。例如，用户可能会因服务而异，每个服务关于用户的属性可能会不同，而且属性语义也可能会不同。
- en: It is even more complex when, in a big company, the application evolves a lot
    and has updates for many years. Each service can have different attributes for
    the user and, generally, they do not match. So, a great way to solve this is using
    DDD.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当在一个大公司中，应用程序经历了很多年的更新，变得更加复杂时，情况变得更加复杂。每个服务可能对用户有不同的属性，通常它们不匹配。因此，使用DDD是解决这个问题的一个很好的方法。
- en: As microservices do, DDD divides a complex domain into different contexts, making
    relationships between them and asking for the collaboration of all the members
    to get a ubiquitous language in a particular domain and bounded context, iterating
    this process until they achieve a real concept regarding the problem.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与微服务一样，DDD将复杂的领域划分为不同的上下文，建立它们之间的关系，并要求所有成员合作，以在特定领域和有界上下文中获得一种通用语言，通过迭代这个过程直到实现对问题的真正概念。
- en: Evans suggests designing each microservice as a DDD-bounded context so that
    it will provide a logical boundary for microservices inside a system. Every single
    microservice (or team working on it) will be responsible for that part of the
    system, and it will give clearer and maintainable code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Evans建议将每个微服务设计为DDD有界上下文，以便为系统内的微服务提供逻辑边界。每个微服务（或团队）将负责系统的一部分，并提供更清晰和可维护的代码。
- en: 'Michael Plöd gave more ideas about how DDD can help microservices. There are four
    significant areas regarding building microservices:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Michael Plöd提出了有关DDD如何帮助微服务的更多想法。在构建微服务方面有四个重要领域：
- en: '**Strategic design**: This is basically bounded context, but context maps and
    other patterns are important too. A context map should show all the bounded contexts
    of the project and their relationships with each other; it also describes the
    contract between them. The context map is very useful for monolithic applications
    wanting to move into microservices.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**战略设计**：这基本上是有界上下文，但上下文映射和其他模式也很重要。上下文映射应显示项目的所有有界上下文及其彼此之间的关系；它还描述它们之间的契约。上下文映射对于希望转向微服务的单片应用程序非常有用。'
- en: '**Internal building blocks**: This refers to using tactical patterns, such
    as aggregates, entities, or repositories, when designing the inside of a bounded
    context.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部构建块**：这指的是在设计有界上下文内部时使用战术模式，如聚合、实体或存储库。'
- en: '**Large-scale structures**: This is used to create a structure using evolving
    order and responsibility layers. This is a concept in microservices too. In huge
    projects, it is helpful to create large-scale structures into boundary contexts.
    They should be designed to evolve individually.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大规模结构**：用于使用不断发展的顺序和责任层创建结构。这也是微服务中的一个概念。在大型项目中，将大规模结构创建到边界上下文中是有帮助的。它们应该被设计为独立演变。'
- en: '**Distillation**: Distilling a core domain from an already grown system is
    very useful when migrating a monolithic application into microservices. The most
    important part should be identifying and extracting the core domain, along with
    the iteration process of identifying a subdomain, extracting it from the core,
    and refactoring.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蒸馏**：从已经成长的系统中提炼核心领域，在将单片应用程序迁移到微服务时非常有用。最重要的部分应该是识别和提取核心领域，以及识别子域、从核心中提取它并进行重构的迭代过程。'
- en: To sum up, microservices and DDD match perfectly, but it is necessary to have
    a larger scope and understand more than the boundary contexts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，微服务和DDD完全匹配，但需要有更大的范围并且了解超出边界上下文的内容。
- en: Event-driven architecture
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动架构
- en: '**Event-driven architecture** (**EDA**) is a pattern of architecture for applications
    following the tips of production, detection, consumption of, and reaction to events.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件驱动架构**（**EDA**）是一种遵循生产、检测、消费和对事件做出反应的应用程序架构模式。'
- en: It is possible to describe an event as a change of state. For example, if a
    door is closed and somebody opens it, the state of the door changes from closed
    to opened. The service to open the door has to make this change like an event,
    and that event can be known by the rest of the services.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将事件描述为状态的改变。例如，如果门关闭了，有人打开了它，门的状态就从关闭变为打开。打开门的服务必须将此更改作为事件进行，其他服务可以知道这个事件。
- en: An event notification is a message that was produced, published, detected, or
    consumed asynchronously and it is the status changed by the event. It is important
    to understand that an event does not move around the application, it just happens.
    The term *event* is a little controversial because it usually means the message
    event notification instead of the event, so it is important to know the difference
    between the event and the event notification.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 事件通知是异步产生、发布、检测或消费的消息，它是由事件改变的状态。重要的是要理解事件并不在应用程序中传播，它只是发生。术语“事件”有点争议，因为它通常指的是消息事件通知，而不是事件，因此了解事件和事件通知之间的区别很重要。
- en: This pattern is commonly used in applications based on components or microservices
    because they can be applied by the design and implementation of applications.
    An application driven by events has event creators and event consumers or sink
    (they have to execute the action as soon as the event is available).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式通常用于基于组件或微服务的应用程序，因为它们可以应用于应用程序的设计和实现。由事件驱动的应用程序具有事件创建者和事件消费者或接收器（它们必须在事件可用时立即执行操作）。
- en: An **event creator** is the producer of the event; it only knows that the event
    has occurred, nothing else. Then we have the event consumers, which are the entities
    responsible of knowing that the event was fired. The consumers are involved in
    processing or changing the event.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件创建者**是事件的生产者；它只知道事件已发生，没有其他信息。然后我们有事件消费者，它们负责知道事件已被触发。消费者参与处理或更改事件。'
- en: The **event consumers** are subscribed to some kind of middleware event manager which,
    as soon as it receives notification of an event from a creator event, forwards
    the event to the registered consumers to be taken by them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件消费者**订阅了某种中间件事件管理器，一旦它收到来自创建者事件的通知，就会将事件转发给已注册的消费者来接收。'
- en: Developing applications as microservices around an architecture such as EDA
    allows these applications to be constructed in a way that facilitates more responsiveness
    because the EDA applications are, by design, ready to be in unpredictable and
    asynchronous environments.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序开发为围绕诸如EDA之类的架构的微服务允许这些应用程序以一种更具响应性的方式构建，因为EDA应用程序是按设计准备好在不可预测和异步环境中运行的。
- en: 'The advantages of using EDA are as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用EDA的优势如下：
- en: '**Uncoupling systems**: The creator service does not need to know the rest
    of the services, and the rest of the services do not know the creator. So, it
    allows it to uncouple the system.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦系统**：创建者服务不需要知道其他服务，其他服务也不知道创建者。因此，它允许解耦系统。'
- en: '**Interaction publish/subscribe**: EDA allows many-to-many interactions, where
    the services publish information about some event and the services can get that
    information and do what is necessary with the event. So, it enables many creator
    events and consumer events to exchange status and respond to information in real
    time.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互发布/订阅**：EDA允许多对多的交互，其中服务发布有关某个事件的信息，服务可以获取该信息并对事件进行必要的处理。因此，它使许多创建者事件和消费者事件能够实时交换状态并响应信息。'
- en: '**Asynchronous**: EDA allows asynchronous interactions between the services,
    so they do not need to wait for an immediate response and it is not mandatory
    to have a connection working while they are waiting for the response.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步**：EDA允许服务之间的异步交互，因此它们不需要等待即时响应，而且在等待响应时不需要连接工作。'
- en: Event-driven architecture in microservices
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务中的事件驱动架构
- en: Microservices are commonly used in large projects to divide their services into
    smaller ones. So, it is really important to have good and organized communication
    between them. Event-driven architecture can be used to solve the common issues of
    communication between microservices.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型项目中，通常使用微服务将其服务划分为较小的服务。因此，它非常重要在它们之间有良好和有组织的通信。事件驱动架构可用于解决微服务之间通信的常见问题。
- en: In a project based on microservices, usually every microservice communicates
    with each other using HTTP requests. This has some problems that we will now explain.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于微服务的项目中，通常每个微服务都使用HTTP请求相互通信。这会带来一些问题，我们现在来解释。
- en: In our `Finding secrets` project, there is a function to create events for the
    users. When a new event is created, the event name and the images attached in
    the event form need to be sent to a service to create a video from the data received.
    Once the video is generated, the event will be updated and sent to the users by
    e-mail.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的“寻找秘密”项目中，有一个函数用于为用户创建事件。创建新事件时，需要将事件名称和事件表单中附加的图像发送到一个服务，以从接收到的数据创建视频。生成视频后，事件将被更新并通过电子邮件发送给用户。
- en: If we make HTTP requests for each service, the problem is that all the services
    need to know about the others. For example, the service to generate the video
    needs to know how to update the event once the video is generated; in other words,
    the service has to contain code to do this update.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为每个服务进行HTTP请求，问题在于所有服务都需要了解其他服务。例如，生成视频的服务需要知道如何在生成视频后更新事件；换句话说，服务必须包含代码来执行此更新。
- en: Also, this becomes more and more difficult once we add many services because
    it will need more communication between them. It will have more failures and the
    main problem is that if a microservice is down, the video will not be generated.
    So, using HTTP requests is not going to scale pretty well and we should use a
    different strategy to communicate microservices in projects like this one.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一旦我们添加了许多服务，这将变得越来越困难，因为它将需要更多的通信。它将有更多的故障，并且主要问题是，如果一个微服务宕机，视频将无法生成。因此，在像这样的项目中，使用HTTP请求不会很好地扩展，我们应该使用不同的策略来进行微服务通信。
- en: What if we do the things differently? In other words, the service to generate
    the video will not update the event directly and the event will not ask the video
    service to generate the video. So, how can we make the microservices communicate?
    The answer is with event-driven architecture.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以不同的方式做事会怎样？换句话说，生成视频的服务不会直接更新事件，事件也不会要求视频服务生成视频。那么，我们如何使微服务进行通信？答案是使用事件驱动架构。
- en: 'To do this, we need the following things:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要以下内容：
- en: A queue of events for each microservice
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务的事件队列
- en: All the microservices have to send the event to a centralized BUS (we can use
    AWS to do this)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有微服务都必须将事件发送到集中式总线（我们可以使用AWS来做这个）
- en: Every queue of microservices has to be subscribed to the centralized BUS
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务队列都必须订阅集中式总线
- en: Every microservice has a background worker listening to the queue of events
    and it will execute the necessary action when receiving an event
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务都有一个后台工作程序监听事件队列，并在接收到事件时执行必要的操作
- en: 'In the following figure, you can see the different services involved and the
    process flow, indicated with arrows. The following figure shows the event-driven
    workflow:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，您可以看到涉及的不同服务和流程流程，用箭头表示。下图显示了事件驱动的工作流程：
- en: '![Event-driven architecture in microservices](graphics/B06142_03_05.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: 微服务中的事件驱动架构
- en: When we create a new event on the **EVENTS SERVICE API** (**1**), the event
    goes to the centralized BUS (**2**) and the corresponding worker gets the event
    from the centralized BUS (**3**); the rest of them just ignore the event. The
    event is placed in the video generator service queue and it waits to be executed
    by the service (**4**).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在**事件服务API**（**1**）上创建一个新事件时，事件会进入集中式总线（**2**），相应的工作者会从集中式总线（**3**）获取事件；其他工作者会忽略这个事件。事件被放置在视频生成服务的队列中，并等待服务执行（**4**）。
- en: Once the video has been generated by a service worker, the service launches
    a new event to the centralized BUS (5). However, it will be taken by a different
    worker this time (6) and the res of workers will ignore this event as earlier.
    The worker to update the event and the worker to send the e-mail will put the
    event into their queues and it will be executed (**7**) doing the corresponding
    action for each service and they will send a new event into the centralized BUS
    if it is necessary.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦视频由服务工作者生成，服务就会向集中式总线（5）发出新的事件。然而，这次会由另一个工作者（6）接管，其他工作者会像之前一样忽略这个事件。更新事件的工作者和发送电子邮件的工作者会将事件放入他们的队列中，并且会执行（**7**）对每个服务执行相应的操作，如果有必要的话，他们会向集中式总线发送新的事件。
- en: 'This is a loop of events that improves the HTTP requests method for the communication
    between services. The advantages of using event-driven architecture are as mentioned:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个事件循环，它改进了服务之间的通信的HTTP请求方法。使用事件驱动架构的优势如上所述：
- en: If there are any errors or exceptions on a service, the event does not get lost,
    it stays in the queue and it will be executed later. For example, if the service
    to send e-mails is down, the event to send the e-mail will be kept in the queue
    waiting for the service to go up again.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务出现任何错误或异常，事件不会丢失，它会留在队列中，并且稍后会被执行。例如，如果发送电子邮件的服务出现问题，发送电子邮件的事件将被保留在队列中，等待服务再次启动。
- en: The services do not need to know how to update other services. It means that
    the logic of the service can be isolated in each service.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务不需要知道如何更新其他服务。这意味着服务的逻辑可以在每个服务中被隔离。
- en: It is possible to add more microservices without impact.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以添加更多的微服务而不会产生影响。
- en: It will scale better.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将更好地扩展。
- en: Continuous integration, continuous delivery, and tools
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成、持续交付和工具
- en: A software project cannot be successful without a strategy for code commit or
    a testing/deploying workflow. Having a strategy is even more important when you
    work in a team. There is nothing more annoying than working on a messy project
    where there are no rules or nobody is accountable for the work they have done.
    In this section, we will explain the most common and successful development practices.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 没有代码提交策略或测试/部署工作流程，软件项目是无法成功的。当你在团队中工作时，拥有一个策略更加重要。没有什么比在一个混乱的项目上工作更令人恼火，没有规则或没有人对他们所做的工作负责。在本节中，我们将解释最常见和成功的开发实践。
- en: Continuous integration - CI
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成 - CI
- en: Continuous integration is a software development practice where all the team
    members integrate their work frequently. Every time new code is pushed to the
    shared repository, an automated build will be fired to detect any kind of integration
    errors as fast as possible. The main goal is to avoid long and unpredictable integrations.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成是一个软件开发实践，团队成员频繁地集成他们的工作。每当新代码被推送到共享存储库时，将触发自动构建，以尽快检测任何集成错误。主要目标是避免长时间和不可预测的集成。
- en: What is continous integration?
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是持续集成？
- en: Let's explain it better with a brief example of what the CI process is like.
    Imagine that you have our game example ready and working well in production and
    you have a new idea for a small feature that the users of your application will
    love. This new feature can be done in a few hours.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简短的例子更好地解释持续集成的过程是什么样的。想象一下，你的游戏示例已经准备就绪，在生产中运行良好，你有一个新的想法，一个小功能，你的应用程序的用户会喜欢。这个新功能可以在几个小时内完成。
- en: Begin by getting a copy of the current source code on your development machine;
    you will be using a source control system, so you only need to check out a working
    copy from the mainline.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在开发机器上获取当前源代码的副本；你将使用源代码控制系统，所以你只需要从主线检出一个工作副本。
- en: Now that you have a working copy of the source, you can do whatever you need
    to complete the feature, add new code, create new tests, and so on. The CI practice
    assumes that a high part of your code will be covered by automated tests. A popular
    unit test suite available for PHP is PHPUnit, a simple and powerful tool that
    we will cover in the later chapters. Having our code tested will help us in the
    future steps of the process and will assure high quality in our code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了源代码的工作副本，你可以做任何你需要完成的功能，添加新代码，创建新测试等等。持续集成实践假设你的大部分代码将被自动化测试覆盖。对于PHP来说，一个流行的单元测试套件是PHPUnit，这是一个简单而强大的工具，我们将在后面的章节中介绍。对我们的代码进行测试将有助于我们在未来的步骤中，并确保我们的代码质量高。
- en: Now you have ended your new feature and it is time to launch an automated build
    on your development environment. This process will take the source code, check
    for errors, and run the automated tests. Only if the build and all the tests pass
    without errors, we can consider the build as good and it can be added to our repository.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了新功能，是时候在你的开发环境上启动一个自动构建了。这个过程将获取源代码，检查错误，并运行自动化测试。只有当构建和所有测试都通过没有错误时，我们才能认为构建是好的，并且可以将其添加到我们的存储库中。
- en: The result of doing this process is that we have a stable piece of software
    that works properly and contains very few bugs.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的结果是，我们有一个稳定的软件，它能正常工作并且包含非常少的bug。
- en: Benefits of CI
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持续集成的好处
- en: 'The main goal of continuous integration is to reduce risk, but this is not
    the only benefit of adopting this development practice. Among others, we can highlight
    the following benefits:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成的主要目标是降低风险，但这并不是采用这种开发实践的唯一好处。其中，我们可以强调以下好处：
- en: Reduced integration times
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少集成时间
- en: Early bug detection due to the fact that we are pushing small changes and each
    change is tested again and again
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们正在推送小的更改并且每个更改都经过了一次又一次的测试，因此可以早期发现错误
- en: Constant availability of a stable build that we can use, for example, to make
    new tests, use as a demo for our customers, or even to deploy it again
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定构建的持续可用性，我们可以使用它进行新的测试，用作我们的客户演示，甚至再次部署
- en: Continuous monitoring of the project quality metrics
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目质量指标的持续监控
- en: Tools for continuous integration
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持续集成的工具
- en: 'As a developer, you can be worried about how to automate this process. Don''t
    worry, in the market you have multiple ways to create and manage your CI pipeline.
    The best recommendation from us is, before you decide which CI software you will use
    in your projects, spend some time testing all your options. Some of the CI software
    available with an easy integration with PHP are:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，您可能会担心如何自动化这个过程。不用担心，在市场上有多种方式可以创建和管理您的CI流水线。我们的最佳建议是，在决定在项目中使用哪种CI软件之前，花一些时间测试所有的选择。一些与PHP轻松集成的CI软件包括：
- en: '**Jenkins**: This is an open source project that is very easy to install and
    manage. Its versatility makes this software perhaps one of the most widely used
    for CI.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins**：这是一个非常容易安装和管理的开源项目。它的多功能性使得这个软件可能是最广泛使用的CI软件之一。'
- en: '**Bamboo**: This is a subscription-based software. Atlassian is well known
    in the development world for its productivity and development support tools. It is
    a nice option if you need deep integration with other Atlassian tools.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bamboo**：这是一个基于订阅的软件。Atlassian在开发世界以其生产力和开发支持工具而闻名。如果您需要与其他Atlassian工具深度集成，这是一个不错的选择。'
- en: '**Travis**: This is another subscription based software with a free plan for
    open source projects.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Travis**：这是另一个基于订阅的软件，针对开源项目有免费计划。'
- en: '**PHP CI**: This new open source tool was built on PHP and is available to
    installed on your server or as a cloud-based tool.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PHP CI**：这个新的开源工具是基于PHP构建的，可以安装在您的服务器上，也可以作为基于云的工具使用。'
- en: 'In our sample project, we will use Jenkins and spin up a Docker container.
    In the meantime, you can start testing Jenkins with this simple command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例项目中，我们将使用Jenkins并启动一个Docker容器。与此同时，您可以使用以下简单命令开始测试Jenkins：
- en: '[PRE3]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command will create a container with the official Docker image for Jenkins
    and map the 8080 and 50000 from your local environment to the container. If you
    open your browser on `http://localhost:8080`, you will have access to the Jenkins
    UI.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将创建一个包含Jenkins官方Docker镜像的容器，并将本地环境的8080和50000端口映射到容器中。如果您在浏览器中打开`http://localhost:8080`，您将可以访问Jenkins
    UI。
- en: Continuous delivery
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续交付
- en: Continuous delivery is the continuation of the continuous integration and the
    main goal is to be able to deploy any version of your software at any point, without a
    point of failure. We can achieve this by ensuring that our code is always available
    to be deployed and by following a continuous integration practice, we can ensure
    the quality and level of integration of our source.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付是持续集成的延续，其主要目标是能够在任何时候部署软件的任何版本，而不会出现故障。我们可以通过确保我们的代码始终可供部署，并遵循持续集成的实践，来实现这一点，从而确保我们的源代码的质量和集成水平。
- en: With continuous delivery, every time we make a change to our code, this change
    is built, tested, and then released to a stage environment. The following diagram shows
    the basic workflow on a CD pipeline. As you can see, if any testing step fails,
    we need to start again until our code passes the tests. Working this way, we can
    always ensure that our project meets the highest quality standards.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过持续交付，每当我们对代码进行更改时，这些更改都会被构建、测试，然后发布到一个阶段环境。下图显示了CD流水线上的基本工作流程。正如您所看到的，如果任何测试步骤失败，我们需要重新开始，直到我们的代码通过测试。通过这种方式工作，我们可以始终确保我们的项目符合最高的质量标准。
- en: 'The following is the diagram for continuous delivery workflow:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是持续交付工作流程的图表：
- en: '![Continuous delivery ](graphics/B06142_03_06.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![持续交付](graphics/B06142_03_06.jpg)'
- en: Benefits of continuous delivery
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持续交付的好处
- en: 'Continuous delivery has numerous benefits; among them, we highlight the following
    ones:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付有许多好处；其中，我们强调以下几点：
- en: '**Reduced deployment risk**: We will be deploying smaller changes, so there
    is less space for something to go wrong and it will be easier to fix any problems.
    Even if we apply a deploy pattern, such as blue-green deployments, our deployment
    will be undetectable to our users.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少部署风险**：我们将部署更小的更改，因此出错的可能性更小，而且更容易修复任何问题。即使我们应用了部署模式，比如蓝绿部署，我们的部署对我们的用户来说是不可察觉的。'
- en: '**Progress tracking**: Since not all developers and managers track the work
    progress in the same way, we are now deploying small releases very quickly; there
    is no doubt when a task is done--if it is on production, the task is done.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进度跟踪**：由于并非所有开发人员和经理以相同的方式跟踪工作进展，我们现在非常快速地部署小版本；当任务完成时毫无疑问——如果它在生产环境中，那么任务就完成了。'
- en: '**Higher quality**: With continuous delivery, we work in small batches; this
    allows us to get feedback from users throughout the delivery life cycle. We can
    even use A/B testing to test ideas before building the full feature. Having automatic
    testing tools in our pipeline allows the developers to discover regressions quickly
    and avoid the release of unstable software.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更高的质量**：通过持续交付，我们以小批量工作；这使我们能够在交付生命周期中从用户那里获得反馈。我们甚至可以使用A/B测试来在构建完整功能之前测试想法。在我们的流水线中使用自动化测试工具使开发人员能够快速发现回归并避免发布不稳定的软件。'
- en: '**Faster time to market**: The integration and test phase of the traditional
    software life cycle can take weeks, but if we manage to automate the build and
    deployment, and environment provisioning and testing processes, we can reduce
    the times to the minimum and incorporate them in the developer''s daily work.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的上市时间**：传统软件生命周期的集成和测试阶段可能需要几周的时间，但如果我们设法自动化构建和部署、环境配置和测试流程，我们可以将时间缩短到最低并将其纳入开发人员的日常工作中。'
- en: '**Lower costs**: If we invest in build, test, deployment, and environment automation,
    we reduce the cost of software by eliminating many fixed associated costs.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低成本：如果我们投资于构建、测试、部署和环境自动化，就可以通过消除许多固定的相关成本来降低软件成本。
- en: Tools for a continuous delivery pipeline
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持续交付流水线的工具
- en: 'As mentioned before, continuous delivery is a continuation of continuous integration,
    so we can use most of the CI tools we mentioned earlier and expand our pipeline
    with our favorite testing framework. In PHP, we have a great number of testing
    frameworks available, but the most well known are the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，持续交付是持续集成的延续，因此我们可以使用我们之前提到的大多数CI工具，并用我们最喜欢的测试框架扩展我们的流水线。在PHP中，有许多可用的测试框架，但最知名的有以下几种：
- en: '**phpUnit**: This is the most well-known framework used to create unit tests.
    Every PHP developer needs to know this framework as it will be the foundation
    of their tests. It is a standard in the industry.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: phpUnit：这是最知名的用于创建单元测试的框架。每个PHP开发人员都需要了解这个框架，因为它将成为他们测试的基础。这是行业标准。
- en: '**Codeception**: This is one of the complete testing suites available for PHP.
    With Codeception, you can build unit, functional, and acceptance tests.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Codeception：这是为PHP提供的最完整的测试套件之一。使用Codeception，你可以构建单元测试、功能测试和验收测试。
- en: '**Behat**: This is the most popular behavior-driven PHP testing framework.
    Instead of writing code, you write stories and the framework will transform and
    test them.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Behat：这是最流行的面向行为的PHP测试框架。你不需要编写代码，而是编写故事，框架会转换并测试它们。
- en: '**PHPSec**: This is another important framework that follows the behavior-driven
    testing.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHPSec：这是另一个遵循面向行为测试的重要框架。
- en: '**Selenium**: This is one of the most sophisticated testing frameworks used
    to automate browsers. With this framework, it is possible to write user acceptance
    tests.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Selenium：这是最复杂的测试框架之一，用于自动化浏览器。有了这个框架，就可以编写用户验收测试。
- en: In the subsequent chapters, we will use some of these testing frameworks. In
    the meantime, give each of them a go and select your favorite frameworks. Remember
    that you can mix them without any problems.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用其中一些测试框架。与此同时，尝试每一个并选择你最喜欢的框架。记住，你可以毫无问题地混合它们。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we talked about the different ways of designing and developing
    an application. We covered some patterns and strategies that you can easily integrate
    in your development workflow and we even talked about the most common development
    practices. In the subsequent chapters, we will apply all these concepts in our
    development workflow.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了设计和开发应用程序的不同方式。我们涵盖了一些模式和策略，你可以轻松地整合到你的开发工作流程中，甚至谈到了最常见的开发实践。在接下来的章节中，我们将在我们的开发工作流程中应用所有这些概念。
