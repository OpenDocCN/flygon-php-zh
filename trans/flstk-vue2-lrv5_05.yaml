- en: Integrating Laravel and Vue.js with Webpack
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Laravel和Vue.js集成到Webpack中
- en: In this chapter, we'll migrate the Vuebnb frontend prototype into our main Laravel
    project, achieving the first full-stack iteration of Vuebnb. This fully-integrated
    environment will include a Webpack build step, allowing us to incorporate more
    sophisticated tools and techniques as we continue to build the frontend.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把Vuebnb前端原型迁移到我们的主要Laravel项目中，实现Vuebnb的第一个全栈迭代。这个完全集成的环境将包括一个Webpack构建步骤，允许我们在继续构建前端时整合更复杂的工具和技术。
- en: 'Topics covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题：
- en: An introduction to Laravel's out-of-the-box frontend app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Laravel开箱即用前端应用程序简介
- en: A high-level overview of Webpack
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack的高级概述
- en: How to configure Laravel Mix to compile frontend assets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何配置Laravel Mix来编译前端资产
- en: Migrating the Vuebnb prototype into the full-stack Laravel environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Vuebnb原型迁移到全栈Laravel环境中
- en: Using ES2015 with Vue.js, including syntax and polyfills for older browsers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vue.js中使用ES2015，包括为旧浏览器提供语法和polyfills
- en: Switching hard-coded data in the frontend app to backend data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将前端应用程序中的硬编码数据切换为后端数据
- en: Laravel frontend
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Laravel前端
- en: We think of Laravel as being a backend framework, but a fresh Laravel project
    includes boilerplate code and configuration for a frontend app as well.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为Laravel是一个后端框架，但是一个新的Laravel项目也包括了前端应用程序的样板代码和配置。
- en: The out-of-the-box frontend includes JavaScript and Sass asset files, as a well
    as a `package.json` file that specifies dependencies such as Vue.js, jQuery, and
    Bootstrap.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 前端开箱即用包括JavaScript和Sass资产文件，以及一个`package.json`文件，指定依赖项，如Vue.js、jQuery和Bootstrap。
- en: Let's take a look at this boilerplate code and configuration so we get an idea
    of how the Vuebnb frontend app will fit into our Laravel project when we begin
    the migration.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个样板代码和配置，以便我们了解Vuebnb前端应用程序在我们开始迁移时将如何适应我们的Laravel项目。
- en: JavaScript
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript
- en: JavaScript assets are kept in the `resources/assets/js` folder. There are several `.js` files
    in this directory, as well as a sub-directory component, with a `.vue` file. This
    latter file will be explained in another chapter so we'll ignore it for now.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript资产保存在`resources/assets/js`文件夹中。该目录中有几个`.js`文件，以及一个子目录`component`，其中有一个`.vue`文件。我们将在另一章节中解释后者，所以现在我们将忽略它。
- en: The main JavaScript file is `app.js`. You'll see the familiar Vue constructor
    in this file, but also some syntax that may not be as familiar. On the first line
    is a `require` function that is intended to import an adjacent file, `bootstrap.js`,
    which in turn loads other libraries including jQuery and Lodash.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 主JavaScript文件是`app.js`。在这个文件中，你会看到熟悉的Vue构造函数，但也会有一些不太熟悉的语法。第一行是一个`require`函数，用于导入一个相邻的文件`bootstrap.js`，它又加载其他库，包括jQuery和Lodash。
- en: '`require` is not a standard JavaScript function and must be resolved somehow
    before this code can be used in a browser.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`require`不是标准的JavaScript函数，必须在代码在浏览器中使用之前进行解析。'
- en: '`resources/assets/js/app.js`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: CSS
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS
- en: If you haven't heard of *Sass* before, it's a CSS extension that makes it easier
    to develop CSS. A default Laravel installation includes the `resources/assets/sass` directory, which
    includes two boilerplate Sass files.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前没有听说过*Sass*，它是一种CSS扩展，使开发CSS更容易。默认的Laravel安装包括`resources/assets/sass`目录，其中包括两个样板Sass文件。
- en: The main Sass file is `app.scss`. Its job is to import other Sass files including
    the Bootstrap CSS framework.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 主Sass文件是`app.scss`。它的工作是导入其他Sass文件，包括Bootstrap CSS框架。
- en: '`resources/assets/sass/app.scss`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/sass/app.scss`：'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Node modules
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点模块
- en: Another key aspect of the Laravel frontend is the `package.json` file in the
    root of the project directory. Similar to `composer.json`, this file is used for
    configuration and dependency management, only for Node modules rather than PHP.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel前端的另一个关键方面是项目目录根目录中的`package.json`文件。与`composer.json`类似，该文件用于配置和依赖管理，只不过是用于Node模块而不是PHP。
- en: One of the properties of `package.json` is `devDependencies`, which specifies
    the modules required in the development environment, including jQuery, Vue, and
    Lodash.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`的属性之一是`devDependencies`，指定了开发环境中需要的模块，包括jQuery、Vue和Lodash。'
- en: '`package.json`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Views
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: To serve the frontend app with Laravel, it needs to be included in a view. The
    only out-of-the-box view provided is the welcome view, located at `resources/views/welcome.blade.php`, which
    is used as a boilerplate home page.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Laravel中提供前端应用程序，需要将其包含在视图中。唯一提供的开箱即用视图是位于`resources/views/welcome.blade.php`的`welcome`视图，用作样板首页。
- en: The welcome view does not actually include the frontend app and it's left to
    the user to install it themselves. We'll look at how to do this later in the chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`welcome`视图实际上不包括前端应用程序，用户需要自行安装。我们将在本章后面讨论如何做到这一点。'
- en: Asset compilation
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资产编译
- en: 'The files in `resources/assets` include functions and syntax that can''t be
    used directly in a browser. For example, the `require` method used in `app.js`,
    which is designed to import a JavaScript module, is not a native JavaScript method
    and is not part of the standard Web API:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets`中的文件包括不能直接在浏览器中使用的函数和语法。例如，在`app.js`中使用的`require`方法，用于导入JavaScript模块，不是原生JavaScript方法，也不是标准Web
    API的一部分：'
- en: '![](assets/9687148e-76da-46c2-8876-0ac1a022d93b.png)Figure 5.1. require is
    not defined in the browser'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/9687148e-76da-46c2-8876-0ac1a022d93b.png)图5.1. 浏览器中未定义`require`'
- en: 'A build tool is needed to take these asset files, resolve any non-standard
    functions and syntax, and output code that the browser can use. There are a number
    of popular build tools for frontend assets including Grunt, Gulp, and Webpack:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个构建工具来获取这些资产文件，解析任何非标准函数和语法，并输出浏览器可以使用的代码。前端资产有许多流行的构建工具，包括Grunt、Gulp和Webpack：
- en: '![](assets/bf0b1519-498e-4862-89e3-418509ed2104.png)Figure 5.2\. Asset compilation
    process'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/bf0b1519-498e-4862-89e3-418509ed2104.png)图5.2. 资产编译过程'
- en: The reason we go to the effort of using this asset compilation process is so
    we can author our frontend app without the constraints of what a browser allows.
    We can introduce a variety of handy development tools and features that'll allow
    us to write our code and fix problems more easily.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以要使用这个资产编译过程，是为了能够在不受浏览器限制的情况下编写我们的前端应用。我们可以引入各种方便的开发工具和功能，这些工具和功能将使我们更容易地编写代码和解决问题。
- en: Webpack
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webpack
- en: Webpack is the default build tool supplied with Laravel 5.5 and we'll be making
    use of it in the development of Vuebnb.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack是Laravel 5.5默认提供的构建工具，我们将在Vuebnb的开发中使用它。
- en: What makes Webpack different to other popular build tools, such as Gulp and
    Grunt, is that it's first and foremost a *module bundler*. Let's begin our overview
    of Webpack by getting an understanding of how the module bundling process works.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack与其他流行的构建工具（如Gulp和Grunt）不同之处在于，它首先是一个*模块打包工具*。让我们通过了解模块打包过程的工作原理来开始我们对Webpack的概述。
- en: Dependencies
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖
- en: 'In a frontend application, we are likely to have dependencies for third-party
    JavaScript libraries or even other files in our own code base. For example, the
    Vuebnb prototype is dependent on Vue.js and the mock-listing data file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端应用中，我们可能会有第三方JavaScript库或甚至自己代码库中的其他文件的依赖关系。例如，Vuebnb原型依赖于Vue.js和模拟列表数据文件：
- en: '![](assets/5a6df745-de9c-465b-b804-0dec5598bfc7.png)Figure 5.3\. Vuebnb prototype
    dependencies'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5a6df745-de9c-465b-b804-0dec5598bfc7.png)图5.3。Vuebnb原型依赖关系'
- en: There's no real way of managing these dependencies in a browser, other than
    to ensure any shared functions and variables have global scope and that scripts
    are loaded in the right order.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了确保任何共享的函数和变量具有全局范围，并且脚本按正确的顺序加载外，在浏览器中没有真正的方法来管理这些依赖关系。
- en: 'For example, since `node_modules/vue/dist/vue.js` defines a global `Vue` object
    and is loaded first, we''re able to use the `Vue` object in our `app.js` script.
    If either of those conditions was not met, `Vue` would not be defined when `app.js`ran,
    resulting in an error:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，由于`node_modules/vue/dist/vue.js`定义了全局的`Vue`对象并且首先加载，我们可以在`app.js`脚本中使用`Vue`对象。如果不满足这两个条件中的任何一个，当`app.js`运行时，`Vue`将未被定义，导致错误：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This system has a number of downsides:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统有一些缺点：
- en: Global variables introduce possibilities of naming collisions and accidental
    mutations
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量引入了命名冲突和意外变异的可能性
- en: Script loading order is fragile and can be easily broken as the app grows
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本加载顺序是脆弱的，随着应用程序的增长很容易被破坏
- en: We can't utilize performance optimizations, such as loading scripts asynchronously
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法利用性能优化，比如异步加载脚本
- en: Modules
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: A solution to the dependency management problem is to use a module system, such
    as CommonJS or native ES modules. These systems allow JavaScript code to be modularized
    and imported into other files.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 解决依赖管理问题的一个方法是使用CommonJS或原生ES模块等模块系统。这些系统允许JavaScript代码模块化，并导入到其他文件中。
- en: 'Here is a CommonJS example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个CommonJS的例子：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And here is a Native ES modules example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个原生ES模块的例子：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The problem is that CommonJS cannot be used in a browser (it was designed for
    server-side JavaScript) and native ES modules are only now getting browser support.
    If we want to use a module system in a project, we'll need a build tool: Webpack.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于CommonJS不能在浏览器中使用（它是为服务器端JavaScript设计的），而原生ES模块现在才开始得到浏览器支持。如果我们想在项目中使用模块系统，我们需要一个构建工具：Webpack。
- en: Bundling
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包
- en: The process of resolving modules into browser-friendly code is called **bundling**.
    Webpack begins the bundling process with the **entry file**as a starting point.
    In the Laravel frontend app, `resources/assets/js/app.js` is the entry file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块解析为适合浏览器的代码的过程称为**打包**。Webpack从**入口文件**开始打包过程。在Laravel前端应用中，`resources/assets/js/app.js`是入口文件。
- en: Webpack analyzes the entry file to find any dependencies. In the case of `app.js`,
    it will find three: `bootstrap`, `vue`, and `Example.vue`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack分析入口文件以找到任何依赖关系。在`app.js`的情况下，它会找到三个：`bootstrap`、`vue`和`Example.vue`。
- en: '`resources/assets/js/app.js`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Webpack will resolve these dependencies and then analyze them to find any dependencies
    that they might have. This process continues until all dependencies of the project
    are found. The result is a graph of dependencies that, in a large project, might
    include hundreds of different modules.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack将解析这些依赖关系，然后分析它们以找到它们可能具有的任何依赖关系。这个过程会一直持续，直到找到项目的所有依赖关系。结果是一个依赖关系图，在一个大型项目中，可能包括数百个不同的模块。
- en: 'Webpack uses this graph of dependencies as a blueprint for bundling all the
    code into a single browser-friendly file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack将这些依赖关系图作为打包所有代码到单个适合浏览器的文件的蓝图：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Loaders
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载器
- en: Part of what makes Webpack so powerful is that during the bundling process it
    can *transform* a module with one or more Webpack loaders.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack之所以如此强大的部分原因是，在打包过程中，它可以使用一个或多个Webpack加载器来*转换*模块。
- en: For example, *Babel* is a compiler that transforms next-generation JavaScript
    syntax such as ES2015 into standard ES5\. The Webpack Babel loader is one of the
    most popular as it allows developers to write their code using modern features,
    but still provide support in older browsers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*Babel*是一个编译器，将下一代JavaScript语法（如ES2015）转换为标准的ES5。Webpack Babel加载器是最受欢迎的加载器之一，因为它允许开发人员使用现代特性编写他们的代码，但仍然在旧版浏览器中提供支持。
- en: For example, in the entry file, we see the ES2015 `const` declaration that isn't
    supported by IE10.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在入口文件中，我们看到了IE10不支持的ES2015 `const`声明。
- en: '`resources/assets/js/app.js`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the Babel loader is used, `const` will be transformed to `var` before it's
    added to the bundle.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了Babel加载器，`const`将在添加到包中之前被转换为`var`。
- en: '`public/js/app.js`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`public/js/app.js`：'
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Laravel Mix
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Laravel Mix
- en: One of the downsides of Webpack is that configuring it is arduous. To make thing
    easier, Laravel includes a module called *Mix* that takes the most commonly-used
    Webpack options and puts them behind a simple API.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack的一个缺点是配置它很繁琐。为了简化事情，Laravel包含一个名为*Mix*的模块，它将最常用的Webpack选项放在一个简单的API后面。
- en: The Mix configuration file can be found in the root of the project directory.
    Mix configuration involves chaining methods to the `mix` object that declare the
    basic build steps of your app. For example, the `js` method takes two arguments,
    the entry file and the output directory, and the Babel loader is applied by default.
    The `sass` method works in an equivalent way.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Mix配置文件可以在项目目录的根目录中找到。Mix配置涉及将方法链接到`mix`对象，声明应用程序的基本构建步骤。例如，`js`方法接受两个参数，入口文件和输出目录，默认情况下应用Babel加载器。`sass`方法以类似的方式工作。
- en: '`webpack.mix.js`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack.mix.js`：'
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running Webpack
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Webpack
- en: Now that we have a high-level understanding of Webpack, let's run it and see
    how it bundles the default frontend asset files.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Webpack有了一个高层次的理解，让我们运行它并看看它是如何捆绑默认的前端资产文件的。
- en: 'First, ensure you have all the development dependencies installed:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保您已安装所有开发依赖项：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: CLI
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLI
- en: 'Webpack is typically runs from the command line, for example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，Webpack是从命令行运行的，例如：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Rather than figuring out the correct CLI option ourselves, we can use one of
    the Weback scripts predefined in `package.json`. For example, the `development` script
    will run Webpack with options suitable for creating a development build.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与其自己找出正确的CLI选项，我们可以使用`package.json`中预定义的Weback脚本之一。例如，`development`脚本将使用适合创建开发构建的选项运行Webpack。
- en: '`package.json`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`：'
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First build
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首次构建
- en: 'Let''s now run the `dev` script (a shortcut for the `development` script):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行`dev`脚本（`development`脚本的快捷方式）：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After this runs, you should see an output in the Terminal similar to the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，您应该在终端中看到类似以下的输出：
- en: '![](assets/6ad468e2-6365-48eb-a310-d318e82f8f4d.png)Figure 5.4\. Webpack Terminal
    output'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6ad468e2-6365-48eb-a310-d318e82f8f4d.png)图5.4. Webpack终端输出'
- en: This output tells us a number of things, but most importantly that the build
    was successful and what files were created in the output including fonts, JavaScript,
    and CSS. Note that the output file path is relative not to the project root but
    to the `public` directory, so the `js/apps.js` file will be found at `public/js/app.js`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出告诉我们很多事情，但最重要的是构建成功了，以及输出了哪些文件，包括字体、JavaScript和CSS。请注意，输出文件路径是相对于`public`目录而不是项目根目录，所以`js/apps.js`文件将在`public/js/app.js`找到。
- en: JavaScript
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript
- en: Inspecting the output JavaScript file, `public/js/app.js`, we see a whole lot
    of code in there - around 42,000 lines! That's because jQuery, Lodash, Vue, and
    the other JavaScript dependencies have all been bundled into this one file. It's
    also because we've used a development build that does not include minification
    or uglification.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 检查输出的JavaScript文件`public/js/app.js`，我们会看到里面有大量的代码 - 大约42,000行！这是因为jQuery、Lodash、Vue和其他JavaScript依赖项都被捆绑到这个文件中。这也是因为我们使用了不包括缩小或丑化的开发构建。
- en: 'If you search through the file, you''ll see that the code from our entry file, `app.js`,
    has been transpiled to ES5 as expected:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您搜索文件，您会看到我们的入口文件`app.js`的代码已经按预期转换为ES5：
- en: '![](assets/63bd67a1-8729-460c-b088-42e7291fc09b.png)Figure 5.5\. Bundle file public/js/app.js'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/63bd67a1-8729-460c-b088-42e7291fc09b.png)图5.5. 捆绑文件public/js/app.js'
- en: CSS
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS
- en: We also have a CSS bundle file, `public/css/app.css`. If you inspect this file
    you will find the imported Bootstrap CSS framework has been included and the Sass
    syntax has been compiled to plain CSS.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个CSS捆绑文件`public/css/app.css`。如果您检查这个文件，您会发现导入的Bootstrap CSS框架已经包含在内，Sass语法已经编译成普通的CSS。
- en: Fonts
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字体
- en: You might think it's strange that there are fonts in the output, since Mix did
    not include any explicit font configuration. These fonts are dependencies of the
    Bootstrap CSS framework and Mix, by default, will output them individually rather
    than in a font bundle.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得奇怪的是输出中有字体，因为Mix没有包含任何显式的字体配置。这些字体是Bootstrap CSS框架的依赖项，Mix默认会将它们单独输出而不是打包成一个字体包。
- en: Migrating Vuebnb
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移Vuebnb
- en: Now that we're familiar with the default Laravel frontend app code and configuration,
    we're ready to migrate the Vuebnb prototype into the main project. This migration
    will allow us to have all our source code in one place, plus we can utilize this
    more sophisticated development environment for building the remainder of Vuebnb.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了默认的Laravel前端应用程序代码和配置，我们准备将Vuebnb原型迁移到主项目中。这个迁移将允许我们将所有源代码放在一个地方，而且我们可以利用这个更复杂的开发环境来构建Vuebnb的其余部分。
- en: 'The migration will involve:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移将涉及：
- en: Removing any unnecessary modules and files
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除任何不必要的模块和文件
- en: Moving the prototype files into the Laravel project structure
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原型文件移动到Laravel项目结构中
- en: Modifications to the prototype files to adapt them to the new environment
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改原型文件以适应新环境
- en: '![](assets/2938293a-97c3-4d88-bdbd-1bcc5ee042b9.png)Figure 5.6\. Vuebnb prototype
    migration'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2938293a-97c3-4d88-bdbd-1bcc5ee042b9.png)图5.6. Vuebnb原型迁移'
- en: Removing unnecessary dependencies and files
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除不必要的依赖项和文件
- en: 'Let''s begin by removing the Node dependencies we no longer need. We''ll keep `axis` as
    it''ll be used in a later chapter, and `cross-env` because it ensures our NPM
    scripts can be run in a variety of environments. We''ll get rid of the rest:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先移除我们不再需要的Node依赖项。我们将保留`axis`，因为它将在后面的章节中使用，以及`cross-env`，因为它确保我们的NPM脚本可以在各种环境中运行。我们将摆脱其余的：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command will leave your dev dependencies looking like this.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会让你的开发依赖项看起来像这样。
- en: '`package.json`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`：'
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we''ll remove the files we don''t need. This includes several of the
    JavaScript assets, all of the Sass plus the welcome view:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将移除我们不需要的文件。这包括几个JavaScript资产，所有的Sass以及`welcome`视图：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since we're removing all the Sass files, we'll also need to remove the `sass` method
    in the Mix configuration.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在移除所有Sass文件，我们还需要在Mix配置中移除`sass`方法。
- en: '`webpack.mix.js`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack.mix.js`：'
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now our frontend app is free from clutter and we can move the prototype files
    into their new home.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的前端应用程序没有杂乱的东西，我们可以将原型文件移动到它们的新家。
- en: HTML
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML
- en: 'Let''s now copy the contents of `index.html`from the prototype project we completed
    in [Chapter 2](b381aa06-e15c-4cb9-9b8b-4b9421ed73db.xhtml), *Prototyping Vuebnb,
    Your First Vue.js Project*, into a new file, `app.blade.php`. This will allow
    the template to be used as a Laravel view:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将原型项目中的`index.html`的内容复制到一个新文件`app.blade.php`中。这将允许模板作为Laravel视图使用：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We'll also update the home web route to point to this new view instead of welcome.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将更新主页web路由，指向这个新视图而不是欢迎页面。
- en: '`routes/web.php`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes/web.php`:'
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Syntax clash
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法冲突
- en: Using the prototype template file as a view will cause a small issue as Vue
    and Blade share a common syntax. For example, look at the heading section where
    Vue.js interpolates the title and address of a listing.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原型模板文件作为视图会导致一个小问题，因为Vue和Blade共享相同的语法。例如，查看Vue.js在标题部分插入标题和列表地址的地方。
- en: '`resources/views/app.blade.php`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`:'
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When Blade processes this, it will think the double curly brackets are its own
    syntax and will generate a PHP error as neither `title` nor `address` are defined
    functions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当Blade处理这个时，它会认为双大括号是它自己的语法，并且会生成一个PHP错误，因为`title`和`address`都不是定义的函数。
- en: 'There is a simple solution: escape these double curly brackets to let Blade
    know to ignore them. This can be done by placing an `@` symbol as a prefix.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个简单的解决方案：通过在双大括号前加上`@`符号来让Blade知道忽略它们。这可以通过在前面加上`@`符号来实现。
- en: '`resources/views/app.blade.php`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`:'
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once you''ve done that for each set of double curly brackets in the file, load
    the home route in the browser to test the new view. Without the JavaScript or
    CSS it doesn''t look great, but at least we can confirm it works:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中的每一组双大括号中完成这些操作后，加载浏览器中的主页路由以测试新视图。没有JavaScript或CSS，它看起来不太好，但至少我们可以确认它可以工作：
- en: '![](assets/d297a0df-877b-4072-a869-98891fd553f0.png)Figure 5.7\. Home route'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/d297a0df-877b-4072-a869-98891fd553f0.png)图5.7。主页路由'
- en: JavaScript
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript
- en: 'Let''s now move the prototype''s main script file, `app.js`, into the Laravel
    project:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将原型的主要脚本文件`app.js`移动到Laravel项目中：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Given the current Mix settings, this will now be the entry file of the JavaScript
    bundle. This means JavaScript dependencies at the bottom of the view can be replaced
    with the bundle, that is.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 根据当前的Mix设置，这将成为JavaScript捆绑包的入口文件。这意味着视图底部的JavaScript依赖项可以被捆绑包替换。
- en: '`resources/views/app.blade.php`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`:'
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Can be replaced with,
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可以被替换为，
- en: '`resources/views/app.blade.php`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`:'
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Mock data dependency
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟数据依赖项
- en: 'Let''s copy the mock data dependency into the project as well:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也将模拟数据依赖项复制到项目中：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Currently, this file declares a global variable `sample` thatis then picked
    up in the entry file. Let's make this file a module by replacing the variable
    declaration with an ES2015 `export default`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个文件声明了一个全局变量`sample`，然后在入口文件中被引用。让我们通过用ES2015的`export default`替换变量声明来将这个文件变成一个模块。
- en: '`resources/assets/js/data.js`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/data.js`:'
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can now import this module at the top of our entry file. Note that Webpack
    can guess the file extension in an import statement so you can omit the `.js` from `data.js`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在我们的入口文件顶部导入这个模块。请注意，Webpack可以在导入语句中猜测文件扩展名，因此您可以省略`data.js`中的`.js`。
- en: '`resources/assets/js/app.js`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`:'
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: While Laravel has opted to use CommonJS syntax for including modules, that is `require`,
    we will use native ES module syntax, that is `import`. This is because ES modules
    are making their way into the JavaScript standard, and it's more consistent with
    the syntax used by Vue.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Laravel选择使用CommonJS语法来包含模块，即`require`，但我们将使用原生ES模块语法，即`import`。这是因为ES模块正在成为JavaScript标准的一部分，并且它更符合Vue使用的语法。
- en: Displaying modules with Webpack
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Webpack显示模块
- en: 'Let''s run a Webpack build to make sure the JavaScript migration is working
    so far:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行Webpack构建，确保JavaScript迁移到目前为止是有效的：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If all is well, you''ll see the JavaScript bundle file being output:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您将看到JavaScript捆绑文件被输出：
- en: '![](assets/bc3060e9-abb3-4da4-b9fc-918d2bdecdaa.png)Figure 5.8\. Webpack Terminal
    output'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/bc3060e9-abb3-4da4-b9fc-918d2bdecdaa.png)图5.8。Webpack终端输出'
- en: It'd be nice to know that the mock data dependency was added without having
    to manually inspect the bundle to find the code. We can do this by telling Webpack
    to print the modules it has processed in the Terminal output.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 很好地知道模拟数据依赖项是如何添加的，而不必手动检查捆绑包以找到代码。我们可以通过告诉Webpack在终端输出中打印它处理过的模块来实现这一点。
- en: 'In the `development` script in our `package.json`, a `--hide-modules` flag has
    been set, as some developers prefer a succinct output message. Let''s remove it
    for now and instead add the `--display-modules` flag, so the script looks like
    this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`package.json`的`development`脚本中，设置了一个`--hide-modules`标志，因为一些开发人员更喜欢简洁的输出消息。让我们暂时将其移除，而是添加`--display-modules`标志，使脚本看起来像这样：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now run the build again, and we get this more verbose terminal output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行构建，我们会得到更详细的终端输出：
- en: '![](assets/6df01ea4-90bf-477f-a649-b37a04ae4c36.png)Figure 5.9\. Webpack Terminal
    output with the display-modules flag'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6df01ea4-90bf-477f-a649-b37a04ae4c36.png)图5.9。带有display-modules标志的Webpack终端输出'
- en: This assures us that both our `app.js` and `data.js` files are included in the
    bundle.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以确保我们的`app.js`和`data.js`文件都包含在捆绑包中。
- en: Vue.js dependency
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue.js依赖项
- en: Let's now import Vue.js as a dependency of our entry file.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将Vue.js作为我们入口文件的依赖项导入。
- en: '`resources/assets/js/app.js`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`:'
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Running the build again, we''ll now see Vue.js in the list of modules in the
    Terminal output, plus some dependencies that it has introduced:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行构建，我们现在会在终端输出中看到Vue.js在模块列表中，以及它引入的一些依赖项：
- en: '![](assets/8c460263-f2d3-40b6-8dd6-0ace4c0d1278.png)Figure 5.10\. Webpack Terminal
    output showing Vue.js'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/8c460263-f2d3-40b6-8dd6-0ace4c0d1278.png)图5.10。显示Vue.js的Webpack终端输出'
- en: You may be wondering how `import Vue from 'vue'` resolves, as it doesn't seem
    to be a proper file reference. Webpack will, by default, check the `node_modules` folder
    in the project for any dependencies, saving you from having to put `import Vue
    from 'node_modules/vue';`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道`import Vue from 'vue'`是如何解析的，因为它似乎不是一个正确的文件引用。Webpack默认会在项目的`node_modules`文件夹中检查任何依赖项，这样就不需要将`import
    Vue from 'node_modules/vue';`放在项目中了。
- en: But how, then, does it know the entry file of this package? Looking at the Webpack
    Terminal output in the preceding screenshot, you can see that it has included `node_modules/vue/dist/vue.common.js`.
    It knows to use this file because, when Webpack is adding node modules as dependencies,
    it checks their `package.json` file and looks for the `main` property, which in
    the case of Vue is.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，它又是如何知道这个包的入口文件呢？看一下前面截图中的Webpack终端输出，你会看到它已经包含了`node_modules/vue/dist/vue.common.js`。它知道要使用这个文件，是因为当Webpack将节点模块添加为依赖项时，它会检查它们的`package.json`文件，并查找`main`属性，而在Vue的情况下是。
- en: '`node_modules/vue/package.json`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`node_modules/vue/package.json`：'
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: However, Laravel Mix overrides this to force a different Vue build.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Laravel Mix会覆盖这一点，以强制使用不同的Vue构建。
- en: '`node_modules/laravel-mix/setup/webpack.config.js`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`node_modules/laravel-mix/setup/webpack.config.js`：'
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In short, `import Vue from 'vue'` is effectively the same as `import Vue from
    'node_modules/vue/dist/vue.common.js'`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`import Vue from 'vue'`实际上与`import Vue from 'node_modules/vue/dist/vue.common.js'`是一样的。
- en: We'll explain the different Vue builds in [Chapter 6](c3b31042-0e33-40d8-ad31-d048ccf7082d.xhtml), *Composing
    Widgets with Vue.js Components*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](c3b31042-0e33-40d8-ad31-d048ccf7082d.xhtml)中解释不同的Vue构建，*使用Vue.js组件组合小部件*。
- en: 'With that done, our JavaScript has been successfully migrated. Loading the
    home route again, we can better make out the listing page of Vuebnb with the JavaScript
    now included:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 搞定了，我们的JavaScript已成功迁移。再次加载主页路由，我们现在可以更好地看到Vuebnb的列表页面，其中包括JavaScript：
- en: '![](assets/b177096b-bc47-4952-b83d-8c01b30b73b9.png)Figure 5.11\. Home route
    with JavaScript migrated'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/b177096b-bc47-4952-b83d-8c01b30b73b9.png)图5.11.带有JavaScript迁移的主页路由'
- en: CSS
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS
- en: 'To migrate CSS, we''ll copy `style.css`from the prototype into the Laravel
    project. The default Laravel frontend app used Sass rather than CSS, so we''ll
    need to make a directory for CSS assets first:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要迁移CSS，我们将从原型中复制`style.css`到Laravel项目中。默认的Laravel前端应用程序使用Sass而不是CSS，因此我们需要先为CSS资产创建一个目录：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let's then make a new declaration in our Mix config to get a CSS bundle using
    the `styles` method.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在我们的Mix配置中进行新的声明，使用`styles`方法获取一个CSS捆绑包。
- en: '`webpack.mix.js`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack.mix.js`：'
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We'll now link to the CSS bundle in our view by updating thelink's `href`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在视图中链接到CSS捆绑包，更新链接的`href`。
- en: '`resources/views/app.blade.php`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Font styles
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字体样式
- en: 'We also have the Open Sans and Font Awesome style sheets to include. First,
    install the font packages with NPM:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有Open Sans和Font Awesome样式表要包含。首先，使用NPM安装字体包：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We'll modify our Mix configuration to bundle our app CSS, Open Sans, and Font
    Awesome CSS together. We can do this by passing an array to the first argument
    of the `styles` method.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改我们的Mix配置，将我们的应用程序CSS、Open Sans和Font Awesome CSS捆绑在一起。我们可以通过将数组传递给`styles`方法的第一个参数来实现这一点。
- en: '`webpack.mix.js`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack.mix.js`：'
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Mix will append statistics about the CSS bundle into the Terminal output:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Mix将在终端输出中附加有关CSS捆绑包的统计信息：
- en: '![](assets/c4a097b9-3772-4381-8d74-5433c0bc8d85.png)Figure 5.12\. Webpack Terminal
    output with CSS'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c4a097b9-3772-4381-8d74-5433c0bc8d85.png)图5.12.带有CSS的Webpack终端输出'
- en: Remember to remove the links to the font style sheets from the view as these
    will now be in the CSS bundle.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 记得从视图中删除对字体样式表的链接，因为现在它们将在CSS捆绑包中。
- en: Fonts
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字体
- en: Open Sans and Font Awesome need both a CSS style sheet, and the relevant font
    files. Like CSS, Webpack can bundle fonts as modules, but we currently don't need
    to take advantage of this. Instead, we'll use the `copy` method, which tells Mix
    to copy the fonts from their home directory into the `public` folder where they
    can be accessed by the frontend app.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Open Sans和Font Awesome都需要一个CSS样式表和相关的字体文件。与CSS一样，Webpack可以将字体捆绑为模块，但我们目前不需要利用这一点。相反，我们将使用`copy`方法，告诉Mix将字体从它们的主目录复制到`public`文件夹中，这样前端应用程序就可以访问它们了。
- en: '`webpack.mix.js`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack.mix.js`：'
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: After building again, you'll now see a `public/fonts` folder in the project
    structure.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建后，您现在将在项目结构中看到一个`public/fonts`文件夹。
- en: Images
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像
- en: 'We''ll now migrate the images, including the logo for the toolbar, and the
    mock data header image:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将迁移图像，包括工具栏的标志和模拟数据标题图像：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let's chain on another `copy` method to include these in the `public/images` directory.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再链上另一个`copy`方法，将它们包含在`public/images`目录中。
- en: '`webpack.mix.js`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack.mix.js`：'
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We also need to ensure the view is pointing to the correct file location for
    the images. In the toolbar.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保视图指向正确的图像文件位置。在工具栏中。
- en: '`resources/views/app.blade.php`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: And in the modal.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以及在模态框中。
- en: '`resources/views/app.blade.php`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Don't forget that the `headerImageStyle` data property in the entry file also
    needs to be updated.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记需要更新入口文件中的`headerImageStyle`数据属性。
- en: '`resources/assets/js/app.js`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'While not exactly an image, we''ll also migrate the `favicon`. This can be
    put straight into the `public` folder:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不完全是一张图片，我们也将迁移`favicon`。这可以直接放入`public`文件夹中：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After building again, we''ll now have the Vuebnb client app prototype fully
    migrated:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建后，我们现在将完全迁移Vuebnb客户端应用程序原型：
- en: '![](assets/402bf3b1-0a52-4dd7-843e-7780f2577cbe.png)Figure 5.13\. Vuebnb client
    app prototype served from Laravel'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/402bf3b1-0a52-4dd7-843e-7780f2577cbe.png)图5.13.从Laravel提供的Vuebnb客户端应用程序原型'
- en: Development tools
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发工具
- en: 'We can utilize some handy development tools to improve our frontend workflow,
    including:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用一些方便的开发工具来改进我们的前端工作流程，包括：
- en: Watch mode
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视模式
- en: BrowserSync
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BrowserSync
- en: Watch mode
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视模式
- en: So far, we've been running builds of our app manually using `npm run dev` every
    time we make a change. Webpack also has a watch mode where it automatically runs
    a build when a dependency changes. Thanks to the design of Webpack, it is able
    to efficiently complete these automatic builds by only rebuilding modules that
    have changed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在每次进行更改时手动运行应用程序的构建，使用`npm run dev`。Webpack还有一个观察模式，在这种模式下，当依赖项发生更改时，它会自动运行构建。由于Webpack的设计，它能够通过仅重新构建已更改的模块来高效地完成这些自动构建。
- en: 'To use watch mode, run the `watch` script included in `package.json`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用观察模式，请运行`package.json`中包含的`watch`脚本：
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To test that it works, add this at the bottom of `resources/assets/js/app.js`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试它是否有效，请在`resources/assets/js/app.js`的底部添加以下内容：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If watch mode is running correctly, saving this file will trigger a build, and
    you'll see updated build statistics in the Terminal. If you then refresh the page
    you'll see the Testing watch message in the console.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果观察模式正在正确运行，保存此文件将触发构建，并且您将在终端中看到更新的构建统计信息。然后刷新页面，您将在控制台中看到测试观察模式的消息。
- en: To turn off watch mode, press *Ctrl* + *C* in the Terminal. It can then be restarted
    at any time. Don't forget to remove the `console.log` once you're satisfied watch
    mode is working.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭观察模式，在终端中按*Ctrl* + *C*。然后可以随时重新启动。不要忘记在满意观察模式工作后删除`console.log`。
- en: I'll assume you're using *watch* for the rest of the book, so I won't remind
    you to build your project after changes anymore!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设您在本书的其余部分中都在使用*watch*，所以我不会再提醒您在更改后构建项目了！
- en: BrowserSync
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BrowserSync
- en: Another useful development tool is BrowserSync. Similar to watch mode, BrowserSync
    monitors your files for changes, and when one occurs inserts the change into the
    browser. This saves you from having to do a manual browser refresh after every
    build.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的开发工具是BrowserSync。与观察模式类似，BrowserSync监视文件的更改，当发生更改时，将更改插入浏览器。这样可以避免在每次构建后手动刷新浏览器。
- en: 'To use BrowserSync, you''ll need to have the Yarn package manager installed.
    If you''re running terminal commands from within the Vagrant Box, you''re all
    set, as Yarn is pre-installed with Homestead. Otherwise, follow the installation
    instructions for Yarn here: [https://yarnpkg.com/en/docs/install](https://yarnpkg.com/en/docs/install).'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用BrowserSync，您需要安装Yarn软件包管理器。如果您在Vagrant Box中运行终端命令，那么您已经准备就绪，因为Yarn已预先安装在Homestead中。否则，请按照此处的Yarn安装说明进行安装：[https://yarnpkg.com/en/docs/install](https://yarnpkg.com/en/docs/install)。
- en: 'BrowserSync has been integrated with Mix and can be used by chaining a call
    to the `browserSync` method in your Mix configuration. Pass an options object
    with the app''s URL as a `proxy` property, for example, `browserSync({ proxy:
    http://vuebnb.test })`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 'BrowserSync已与Mix集成，并且可以通过在Mix配置中调用`browserSync`方法来使用。传递一个带有应用程序URL作为`proxy`属性的选项对象，例如，`browserSync({
    proxy: http://vuebnb.test })`。'
- en: 'We have the app''s URL stored as an environment variable in the `.env` file,
    so let''s get it from there rather than hard-coding into our Mix file. First,
    install the NPM `dotenv` module, which reads a `.env` file into a Node project:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用程序的URL存储为`.env`文件中的环境变量，因此让我们从那里获取它，而不是硬编码到我们的Mix文件中。首先，安装NPM `dotenv`模块，它将`.env`文件读入Node项目中：
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Require the `dotenv` module at the top of the Mix configuration file and use
    the `config` method to load `.env`. Any environment variables will then be available
    as properties of the `process.env` object.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mix配置文件的顶部要求`dotenv`模块，并使用`config`方法加载`.env`。然后环境变量将作为`process.env`对象的属性可用。
- en: 'We can now pass an options object to the `browserSync` method with `process.env.APP_URL` assigned
    to `proxy`. I also like to use the `open: false` option as well, which prevents
    BrowserSync from automatically opening a tab.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们可以将一个带有`process.env.APP_URL`分配给`proxy`的选项对象传递给`browserSync`方法。我还喜欢使用`open:
    false`选项，这样可以防止BrowserSync自动打开一个标签页。'
- en: '`webpack.mix.js`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack.mix.js`：'
- en: '[PRE50]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: BrowserSync runs on its own port, `3000` by default. When you run `npm run watch` again,
    open a new tab at `localhost:3000`. After you make changes to your code you'll
    find they are automatically reflected in this BrowserSync tab!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: BrowserSync默认在自己的端口`3000`上运行。当您再次运行`npm run watch`时，在`localhost:3000`上打开一个新标签页。在对代码进行更改后，您会发现这些更改会自动反映在此BrowserSync标签页中！
- en: Note that if you run BrowserSync inside your Homestead box you can access it
    at `vuebnb.test:3000`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您在Homestead框中运行BrowserSync，可以在`vuebnb.test:3000`上访问它。
- en: Even though the BrowserSync server runs on a different port to the web server,
    I will continue to refer to URLs in the app without specifying the port to avoid
    any confusion, for example, `vuebnb.test` rather than `localhost:3000` or `vuebnb.test:3000`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 即使BrowserSync服务器在不同的端口上运行，我将继续在应用程序中引用URL而不指定端口，以避免任何混淆，例如，`vuebnb.test`而不是`localhost:3000`或`vuebnb.test:3000`。
- en: ES2015
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES2015
- en: The `js` Mix method applies the Babel plugin to Webpack, ensuring that any ES2015
    code is transpiled down to browser-friendly ES5 before it's added to the bundle
    file.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`js` Mix方法将Babel插件应用于Webpack，确保任何ES2015代码在添加到捆绑文件之前被转译为浏览器友好的ES5。'
- en: We wrote the Vuebnb frontend app prototype using only ES5 syntax, as we ran
    it directly in the browser without any build step. But now we can take advantage
    of ES2015 syntax, which includes a lot of handy features.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用ES5语法编写了Vuebnb前端应用程序原型，因为我们直接在浏览器中运行它，没有任何构建步骤。但现在我们可以利用ES2015语法，其中包括许多方便的功能。
- en: For example, we can use a shorthand for assigning a function to an object property.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用一种简写方式将函数分配给对象属性。
- en: '`resources/assets/js/app.js`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Can be changed to this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 可以更改为：
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There are several instances of this in `app.js` that we can change. There aren't
    any other opportunities for using ES2015 syntax in our code yet, though in the
    coming chapters we'll see more.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`中有几个这样的实例，我们可以更改。尽管在我们的代码中还没有其他使用ES2015语法的机会，但在接下来的章节中我们会看到更多。
- en: Polyfills
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Polyfills
- en: The ES2015 proposal includes new syntax, but also new APIs, such as `Promise`, and
    additions to existing APIs, such as `Array` and `Object`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015提案包括新的语法，还包括新的API，如`Promise`，以及对现有API的添加，如`Array`和`Object`。
- en: The Webpack Babel plugin can transpile ES2015 syntax, but new API methods require
    polyfilling. A **polyfill** is a script that is run in the browser to cover an
    API or API method that may be missing.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack Babel插件可以转译ES2015语法，但新的API方法需要进行polyfill。**Polyfill**是在浏览器中运行的脚本，用于覆盖可能缺失的API或API方法。
- en: 'For example, `Object.assign` is a new API method that is not supported in Internet
    Explorer 11\. If we want to use it in our frontend app, we have to check at the
    top of our script whether the API method exists, and if not, we define it manually
    with a polyfill:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Object.assign`是一个新的API方法，在Internet Explorer 11中不受支持。如果我们想在前端应用程序中使用它，我们必须在脚本的顶部检查API方法是否存在，如果不存在，则使用polyfill手动定义它：
- en: '[PRE53]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Speaking of which, `Object.assign` is a handy way of merging objects and would
    be useful in our frontend app. Let's use it in our code, then add a polyfill to
    ensure the code will run in older browsers.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，`Object.assign`是合并对象的一种方便方法，在我们的前端应用程序中会很有用。让我们在我们的代码中使用它，然后添加一个polyfill来确保代码在旧版浏览器中运行。
- en: Look at the `data` object in our entry file, `resources/assets/js/app.js`. We
    are manually assigning each property of the `sample` object to the `data` object,
    giving it the same property name. To save having to repeat ourselves, we can instead
    use `Object.assign` and simply merge the two objects. In practice, this doesn't
    do anything different, it's just more succinct code.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们入口文件`resources/assets/js/app.js`中的`data`对象。我们手动将`sample`对象的每个属性分配给`data`对象，给它相同的属性名。为了避免重复，我们可以使用`Object.assign`来简单地合并这两个对象。实际上，这并没有做任何不同的事情，只是更简洁的代码。
- en: '`resources/assets/js/app.js`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`:'
- en: '[PRE54]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To polyfill `Object.assign` we must install a new `core-js` dependency, which
    is a library of polyfills for most new JavaScript APIs. We''ll use some other
    `core-js` polyfills later in the project:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了polyfill`Object.assign`，我们必须安装一个新的`core-js`依赖项，这是一个为大多数新的JavaScript API提供polyfill的库。我们稍后将在项目中使用一些其他`core-js`的polyfill：
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'At the top of `app.js`, add this line to include the `Object.assign` polyfill:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`的顶部，添加以下行以包含`Object.assign`的polyfill：
- en: '[PRE56]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: After this builds, refresh your page to see whether it works. Most likely you
    will not notice any difference unless you can test this on an older browser, such
    as Internet Explorer, but now you have the assurance that this code will run almost
    anywhere.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，刷新页面以查看是否有效。除非您可以在旧版浏览器（如Internet Explorer）上测试，否则您很可能不会注意到任何区别，但现在您可以确保这段代码几乎可以在任何地方运行。
- en: Mock data
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟数据
- en: We've now completely migrated the Vuebnb prototype into our Laravel project,
    plus we've added a build step. Everything in the frontend app is working as it
    was in [Chapter 2](b381aa06-e15c-4cb9-9b8b-4b9421ed73db.xhtml), *Prototyping Vuebnb,
    Your First Vue.js Project*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完全将Vuebnb原型迁移到了我们的Laravel项目中，并且我们已经添加了一个构建步骤。前端应用程序中的一切都像[第2章](b381aa06-e15c-4cb9-9b8b-4b9421ed73db.xhtml)中的一样工作，*Vuebnb原型设计，您的第一个Vue.js项目*。
- en: However, we still have mock data hard-coded into the frontend app. In this last
    part of the chapter, we're going to remove that hard-coded data and replace it
    with data from the backend.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们仍然在前端应用程序中硬编码了模拟数据。在本章的最后部分，我们将删除这些硬编码的数据，并用后端数据替换它。
- en: Routes
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: Currently, the home route, that is,` */*`, loads our frontend app. But what
    we've built for our frontend app so far is not meant to be a home page! We'll
    be building that in future chapters.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，主页路由，即`*/*`，加载我们的前端应用程序。但是，我们迄今为止构建的前端应用程序并不是一个主页！我们将在以后的章节中构建它。
- en: What we've built is the *listing* page, which should be at a route like `/listing/5`,
    where `5` is the ID of the mock data listing being used.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的是*listing*页面，应该在类似`/listing/5`的路由上，其中`5`是正在使用的模拟数据列表的ID。
- en: '| Page | Route |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 页面 | 路由 |'
- en: '| --- | --- |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Home page | / |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 主页 | / |'
- en: '| Listing page | /listing/{listing} |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 列表页面 | /listing/{listing} |'
- en: Let's modify the route to reflect this.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改路由以反映这一点。
- en: '`routes/web.php`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes/web.php`:'
- en: '[PRE57]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Just like in our `api/listing/{listing}` route, the dynamic segment is meant
    to match the ID for one of our mock data listings. If you recall from the previous
    chapter, we created 30 mock data listings with an ID range of 1 to 30.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在我们的`api/listing/{listing}`路由中一样，动态段意味着要匹配我们模拟数据列表中的一个ID。如果您还记得上一章，我们创建了30个模拟数据列表，ID范围是1到30。
- en: If we now type hint the `Listing` model in the `closure` function's profile,
    Laravel's service container will pass in a model with an ID that matches that
    dynamic route segment.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在`闭包`函数的配置文件中对`Listing`模型进行类型提示，Laravel的服务容器将传递一个与动态路由段匹配的ID的模型。
- en: '`routes/web.php`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes/web.php`:'
- en: '[PRE58]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: One cool in-built feature is, if the dynamic segment does not match a model,
    for example `/listing/50` or `/listing/somestring`, Laravel will abort the route
    and return a 404.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很酷的内置功能是，如果动态段与模型不匹配，例如`/listing/50`或`/listing/somestring`，Laravel将中止路由并返回404。
- en: Architecture
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: 'Given that we can retrieve the correct listing model in the route handler,
    and that, thanks to the Blade templating system, we can dynamically insert content
    into our *app* view, an obvious architecture emerges: we can inject the model
    into the head of the page. That way, when the Vue app loads, it will have immediate
    access to the model:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们可以在路由处理程序中检索到正确的列表模型，并且由于Blade模板系统的存在，我们可以动态地将内容插入到我们的*app*视图中，一个明显的架构出现了：我们可以将模型注入到页面的头部。这样，当Vue应用程序加载时，它将立即访问模型：
- en: '![](assets/ced66f3d-6116-4340-99d0-a9785f410ac5.png)Figure 5.14\. Inline listing
    model into the head of the page'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/ced66f3d-6116-4340-99d0-a9785f410ac5.png)图5.14。将内联列表模型插入页面的头部'
- en: Injecting data
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入数据
- en: Getting the mock-listing data into the client app will take several steps. We'll
    begin by converting the model to an array. The `view` helper can then be used
    to make the model available within the template at runtime.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 将模拟列表数据传递到客户端应用程序将需要几个步骤。我们将首先将模型转换为数组。然后可以使用`view`助手在模板中运行时使模型可用。
- en: '`routes/web.php`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes/web.php`:'
- en: '[PRE59]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now, in the Blade template, we'll create a script in the head of the document.
    By using double curly brackets, we can interpolate the model directly into the
    script.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Blade模板中，我们将在文档的头部创建一个脚本。通过使用双花括号，我们可以直接将模型插入脚本中。
- en: '`resources/views/app.blade.php`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE60]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If we now go to the `/listing/5` route, we will see the following in our page
    source:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们转到`/listing/5`路由，我们将在页面源代码中看到以下内容：
- en: '[PRE61]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And you will see the following in our console:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 并且您将在控制台中看到以下内容：
- en: '![](assets/5b075b90-99d1-483b-ab29-0062fbf83768.png)Figure 5.15\. Console output
    after injecting model ID'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5b075b90-99d1-483b-ab29-0062fbf83768.png)图5.15。注入模型ID后的控制台输出'
- en: JSON
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: We'll now encode the entire model as JSON within the view. The JSON format is
    good because it can be stored as a string and can be parsed by both PHP and JavaScript.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将整个模型编码为JSON放在视图中。JSON格式很好，因为它可以存储为字符串，并且可以被PHP和JavaScript解析。
- en: In our inline script, let's format the model as a JSON string and assign to
    a `model` variable.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的内联脚本中，让我们将模型格式化为JSON字符串并分配给`model`变量。
- en: '`resources/views/app.blade.php`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE62]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Notice we also had to wrap `json_encode` in another global function, `addslashes`.
    This function will add backslashes before any character that needs to be escaped.
    It's necessary to do this because the JavaScript JSON parser doesn't know which
    quotes in the string are part of the JavaScript syntax, and which are part of
    the JSON object.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还必须在另一个全局函数`addslashes`中包装`json_encode`。这个函数将在需要转义的任何字符之前添加反斜杠。这是必要的，因为JavaScript
    JSON解析器不知道字符串中的引号是JavaScript语法的一部分，还是JSON对象的一部分。
- en: We also had to use a different kind of Blade syntax for interpolation. A feature
    of Blade is that statements within double curly brackets `{{ }}` are automatically
    sent through PHP's `htmlspecialchars` function to prevent XSS attacks. This will,
    unfortunately, invalidate our JSON object. The solution is to use the alternative `{!!
    !!}` syntax, which does not validate the contents. This is safe to do in this
    scenario because we're sure we're not using any user-supplied content.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须使用不同类型的Blade语法进行插值。Blade的一个特性是，双花括号`{{ }}`中的语句会自动通过PHP的`htmlspecialchars`函数发送，以防止XSS攻击。不幸的是，这将使我们的JSON对象无效。解决方案是使用替代的`{!!
    !!}`语法，它不会验证内容。在这种情况下这样做是安全的，因为我们确定我们没有使用任何用户提供的内容。
- en: 'Now if we refresh the page, we''ll see the JSON object as a string in the console:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们刷新页面，我们将在控制台中看到JSON对象作为字符串：
- en: '![](assets/b553cf66-4c47-41bd-aec4-bc08db5e1316.png)Figure 5.16\. Model as
    a JSON string in the console'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/b553cf66-4c47-41bd-aec4-bc08db5e1316.png)图5.16。控制台中的JSON字符串模型'
- en: 'If we change the log command to `console.log(JSON.parse(model));`, we see our
    model not as a string, but as a JavaScript object:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将日志命令更改为`console.log(JSON.parse(model));`，我们将看到我们的模型不是一个字符串，而是一个JavaScript对象：
- en: '![](assets/3eee0596-4d8d-4a4f-b1f4-38bcd82c946b.png)Figure 5.17\. Model as
    an object in the console'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/3eee0596-4d8d-4a4f-b1f4-38bcd82c946b.png)图5.17。控制台中的对象模型'
- en: We've now successfully gotten our model from the backend into the frontend app!
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功地将我们的模型从后端传递到前端应用程序！
- en: Sharing data between scripts
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在脚本之间共享数据
- en: We have another issue to overcome now. The inline script in the head of the
    document, which is where our model object is, is a different script to the one
    where we have our client application, which is where it's needed.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有另一个问题要克服。文档头部的内联脚本，其中包含我们的模型对象，与我们的客户端应用程序所在的脚本不同，这是需要的地方。
- en: 'As we''ve discussed in the previous section, multiple scripts and global variables
    are generally not preferred as they make the app fragile. But in this scenario,
    they''re a necessity. The safest way to share an object or function between two
    scripts is to make it a property of the global `window` object. That way, it''s
    very obvious from your code that you''re intentionally using a global variable:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中讨论的，通常不建议使用多个脚本和全局变量，因为它们会使应用程序变得脆弱。但在这种情况下，它们是必需的。在两个脚本之间安全共享对象或函数的最佳方法是将其作为全局`window`对象的属性。这样，从您的代码中很明显，您有意使用全局变量：
- en: '[PRE63]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If you add additional scripts to your project, particularly third-party ones,
    they might also add to the `window` object, and there's a possibility of a naming
    collision. To avoid this the best we can, we'll make sure we use a very specific
    property name.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向项目添加其他脚本，特别是第三方脚本，它们可能也会添加到`window`对象，并且可能会发生命名冲突的可能性。为了尽量避免这种情况，我们将确保使用非常特定的属性名称。
- en: '`resources/views/app.blade.php`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE64]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now, over in the entry file of the frontend app, we can work with this `window` property
    in our script.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在前端应用程序的入口文件中，我们可以在脚本中使用这个`window`属性。
- en: '`resources/assets/js/app.js`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE65]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Replacing the hard-coded model
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换硬编码的模型
- en: We now have access to our listing model in the entry file, so let's switch it
    with our hard-coded model in the `data` property assignment.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在入口文件中访问我们的列表模型，让我们将其与`data`属性分配中的硬编码模型进行交换。
- en: '`resources/assets/js/app.js`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE66]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'With that done, we can now remove the `import sample from ''./data'';`statement
    from the top of `app.js`. We can also delete the sample data files as they won''t
    be used any further in the project:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们现在可以从`app.js`的顶部删除`import sample from './data';`语句。我们还可以删除示例数据文件，因为它们在项目中将不再使用：
- en: '[PRE67]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Amenities and prices
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设施和价格
- en: If you refresh the page now, it will load, but the script will have some errors.
    The problem is that the amenities and prices data are structured differently in
    the frontend app to how they are in the backend. This is because the model initially
    came from our database, which stores scalar values. In JavaScript, we can use
    richer objects which allow us to nest data, making it much easier to work with
    and manipulate.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在刷新页面，它将加载，但脚本将出现一些错误。问题在于设施和价格数据在前端应用程序中的结构与后端中的结构不同。这是因为模型最初来自我们的数据库，它存储标量值。在JavaScript中，我们可以使用更丰富的对象，允许我们嵌套数据，使其更容易处理和操作。
- en: 'Here is how the model object currently looks. Notice that the amenities and
    prices are scalar values:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这是模型对象当前的外观。请注意，设施和价格是标量值：
- en: '![](assets/064fd314-22ec-49e0-b643-11027566d74b.png)Figure 5.18\. How the listing
    model currently looks'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/064fd314-22ec-49e0-b643-11027566d74b.png)图5.18。列表模型当前的外观'
- en: 'This is how we need it to look, with the amenities and prices as arrays:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的样子，包括设施和价格作为数组：
- en: '![](assets/dc6c4b95-eaec-4ade-a5d3-b139eb7c53a8.png)Figure 5.19\. How the listing
    model should look'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/dc6c4b95-eaec-4ade-a5d3-b139eb7c53a8.png)图5.19。列表模型应该的外观'
- en: To fix this problem, we'll need to transform the model before we pass it to
    Vue. To save you having to think too much about this, I've put the transformation
    function into a file, `resources/assets/js/helpers.js`. This file is a JavaScript
    module that we can import into our entry file and use by simply passing the model
    object into the function.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要在将模型传递给Vue之前对其进行转换。为了让您不必过多考虑这个问题，我已经将转换函数放入了一个文件`resources/assets/js/helpers.js`中。这个文件是一个JavaScript模块，我们可以将其导入到我们的入口文件中，并通过简单地将模型对象传递给函数来使用它。
- en: '`resources/assets/js/app.js`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE68]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Once we''ve added this and refreshed the page, we should see the new model
    data in the text parts of the page (although still with the hard-coded images):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤并刷新页面后，我们应该在页面的文本部分看到新的模型数据（尽管图像仍然是硬编码的）：
- en: '![](assets/32f99369-737e-4291-9e7e-f446a63555f3.png)Figure 5.20\. New model
    data in page with hard-coded images'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/32f99369-737e-4291-9e7e-f446a63555f3.png)图5.20。页面中的新模型数据与硬编码的图像'
- en: Image URLs
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像URL
- en: The last thing to do is replace the hard-coded images' URLs in the frontend
    app. These URLs are not currently a part of the model, so need to be manually
    added to the model before we inject it into the template.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是替换前端应用程序中的硬编码图像URL。这些URL目前不是模型的一部分，因此需要在将其注入模板之前手动添加到模型中。
- en: We've already done a very similar job back in [Chapter 4](86698fb7-c4c0-4a6e-831d-4b8cdde3a4b8.xhtml), *Building
    a Web Service With Laravel*, for the API listing route.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第4章](86698fb7-c4c0-4a6e-831d-4b8cdde3a4b8.xhtml)中做了一个非常类似的工作，*使用Laravel构建Web服务*，用于API列表路由。
- en: '`app/Http/Controllers/ListingController.php`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/Http/Controllers/ListingController.php`：'
- en: '[PRE69]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In fact, our web route will end up with identical code to this API route, only
    instead of returning JSON, it will return a view.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们的web路由最终将与这个API路由的代码相同，只是不返回JSON，而是返回一个视图。
- en: Let's share the common logic. Begin by moving the route closure function into
    a new `get_listing_web` method in the listing controller.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分享共同的逻辑。首先将路由闭包函数移动到列表控制器中的一个新的`get_listing_web`方法。
- en: '`app/Http/Controllers/ListingController.php`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/Http/Controllers/ListingController.php`：'
- en: '[PRE70]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Then adjust the route to call this new controller method.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调整路由以调用这个新的控制器方法。
- en: '`routes/web.php`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes/web.php`：'
- en: '[PRE71]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Let's now update the controller so *both* the web and API routes get the images'
    URLs added to their model. We'll first create a new `add_image_urls` method, which
    abstracts the logic that was used in `get_listing_api`. Now both of the route-handling
    methods will call this new method.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新控制器，使得*web*和API路由都将图像的URL添加到它们的模型中。我们首先创建一个新的`add_image_urls`方法，它抽象了在`get_listing_api`中使用的逻辑。现在路由处理方法都将调用这个新方法。
- en: '`app/Http/Controllers/ListingController.php`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/Http/Controllers/ListingController.php`：'
- en: '[PRE72]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'With that done, if we refresh the app and open Vue Devtools, we should see
    that we have the image URLs as an `images` data property:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，如果我们刷新应用并打开Vue Devtools，我们应该看到我们有图像URL作为`images`数据属性：
- en: '![](assets/2a17020d-30e8-4f25-ad17-192ecc32b947.png)Figure 5.21\. Images are
    now a data property as shown in Vue Devtools'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2a17020d-30e8-4f25-ad17-192ecc32b947.png)图5.21。如Vue Devtools中所示，图像现在是一个数据属性'
- en: Replacing the hard-coded image URLs
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换硬编码的图像URL
- en: The final step is to use these image URLs from the backend instead of the hard-coded
    URL. Remembering that `images` is an array of URLs, we'll use the first image
    as a default, that is, `images[0]`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是使用后端的图像URL，而不是硬编码的URL。记住`images`是一个URL数组，我们将使用第一个图像作为默认值，即`images[0]`。
- en: First, we'll update the entry file,
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将更新入口文件，
- en: '`resources/assets/js/app.js`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE74]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Then the view for the modal image.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是模态图像的视图。
- en: '`resources/views/app.blade.php`:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE75]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'With that done, after a rebuild and page refresh, you''ll see the content of
    mock data listing `#5` in the page:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 完成重建和页面刷新后，您将在页面中看到模拟数据列表`#5`的内容：
- en: '![](assets/a3cc885a-d893-44b4-94a6-e7af8955cf40.png)Figure 5.22\. Listing page
    with mock data'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a3cc885a-d893-44b4-94a6-e7af8955cf40.png)图5.22。带有模拟数据的列表页面'
- en: 'To verify, and to admire our work, let''s try another route, for example, `/listing/10`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证并欣赏我们的工作，让我们尝试另一个路由，例如`/listing/10`：
- en: '![](assets/24a89bd1-3055-499b-8510-b415b00df4cd.png)Figure 5.23\. Listing page
    with mock data'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/24a89bd1-3055-499b-8510-b415b00df4cd.png)图5.23。带有模拟数据的列表页面'
- en: Summary
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we got familiar with the files and configuration of Laravel's
    default frontend app. We then migrated the Vuebnb client app prototype into our
    Laravel project, achieving the first full-stack iteration of Vuebnb.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们熟悉了Laravel默认前端应用程序的文件和配置。然后我们将Vuebnb客户端应用程序原型迁移到我们的Laravel项目中，实现了Vuebnb的第一个全栈迭代。
- en: We also learned about Webpack, seeing how it addresses the JavaScript dependency
    management problem by bundling modules into a browser-friendly build file. We
    set up Webpack in our project via Laravel Mix, which offers a simple API for common
    build scenarios.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了Webpack，看到它是如何通过将模块捆绑到浏览器友好的构建文件中来解决JavaScript依赖管理问题的。我们通过Laravel Mix在项目中设置了Webpack，它提供了一个简单的API来处理常见的构建场景。
- en: We then investigated tools for making our frontend development process easier,
    including Webpack watch mode and BrowserSync.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调查了一些工具，使得我们的前端开发过程更容易，包括Webpack的监视模式和BrowserSync。
- en: Finally, we saw how to get data from the backend into the frontend app by injecting
    it into the document head.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到如何通过将数据注入到文档头部，将数据从后端传递到前端应用程序。
- en: 'In [Chapter 6](c3b31042-0e33-40d8-ad31-d048ccf7082d.xhtml), *Composing Widgets
    with Vue.js Components*, we will be introduced to one of the most important and
    powerful tools for building user interfaces with Vue.js: components. We will build
    an image carousel for Vuebnb, and use knowledge of components to refactor the
    Vuebnb client app into a flexible component-based architecture.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](c3b31042-0e33-40d8-ad31-d048ccf7082d.xhtml)中，*使用Vue.js组件组合小部件*，我们将介绍构建Vue.js用户界面的最重要和强大的工具之一：组件。我们将为Vuebnb构建一个图像轮播，并利用组件的知识将Vuebnb客户端应用程序重构为灵活的基于组件的架构。
