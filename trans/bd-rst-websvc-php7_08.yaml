- en: API Testing – Guards on the Gates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API测试-守卫在大门上
- en: In the last chapter, we fixed the issues that we had identified and completed
    the remaining things in our RESTful web service. However, to ensure quality we
    need to test our endpoints, and manual testing is not enough. In real-world projects,
    we can't test each endpoint repeatedly because in the real world there are a lot
    more endpoints. So, we move towards automated testing. We write test cases and
    execute them in an automated way. In fact, it makes more sense to write test cases
    first, run them, and then write code to fulfill the requirements of that test.
    This method of development is called **TDD** (**Test-driven Development**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们解决了我们识别出的问题，并完成了RESTful web服务中剩下的事情。然而，为了确保质量，我们需要测试我们的端点，手动测试是不够的。在现实世界的项目中，我们无法重复测试每个端点，因为在现实世界中有更多的端点。因此，我们转向自动化测试。我们编写测试用例并以自动化的方式执行它们。事实上，首先编写测试用例，运行它们，然后编写代码来满足该测试的要求更有意义。这种开发方法称为TDD（测试驱动开发）。
- en: 'TDD is good and ensures that we are working exactly according to our test cases.
    However, in this book, we didn''t use TDD because there were a lot of things to
    understand and we didn''t want to include one more thing at the same time. So
    now, when we are done with the concepts, understanding, and writing the RESTful
    web service in Lumen (which was also new for many of us), now we can do this missing
    thing, that is, testing. TDD is not essential, but testing is. If we haven''t
    written tests till now in favor of understanding other stuff, then we should do
    it now. The following are the topics that we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是好的，并确保我们按照我们的测试用例进行工作。然而，在这本书中，我们没有使用TDD，因为有很多东西要理解，我们不想同时包括一件事。所以现在，当我们完成了概念、理解和在Lumen中编写RESTful
    web服务（对我们许多人来说也是新的）时，现在我们可以做这个缺失的事情，也就是测试。TDD并非必不可少，但测试是。如果我们迄今为止没有为了理解其他东西而编写测试，那么现在我们应该这样做。以下是本章将涵盖的主题：
- en: The need for automated API tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化API测试的需求
- en: 'Types of tests:'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试类型：
- en: Unit testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Functional testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试
- en: Acceptance testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验收测试
- en: What type of tests will we write?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将编写什么类型的测试？
- en: 'Testing frameworks:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试框架：
- en: Introduction to CodeCeption
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍CodeCeption
- en: Setup and configurations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和配置
- en: Writing API tests
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写API测试
- en: Summary and more resources
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结和更多资源
- en: The need for automated tests
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试的需求
- en: As we discussed earlier, in the real world, we can't test every endpoint repeatedly
    after every major feature or change. We can try but we are human and we can miss
    out on that. The bigger problem is that we may sometimes think that we tested
    it but miss it and because there is no record of what we tested, we can't know.
    If we have a separate quality assurance team or person, they will most probably
    test and keep a record of that. However, in case of a RESTful web service, it
    will take more of their time or the possibility is that the QA person will test
    the end product as a whole and not RESTful web service.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论过的，在现实世界中，我们无法在每个主要功能或更改后重复测试每个端点。我们可以尝试，但我们是人类，我们可能会错过。更大的问题是，我们有时可能会认为我们已经测试过了，但却错过了，因为没有记录我们测试过什么，我们无法知道。如果我们有一个单独的质量保证团队或人员，他们很可能会测试并记录下来。然而，在RESTful
    web服务的情况下，这将占用更多的时间，或者可能的情况是QA人员将作为一个整体测试最终产品，而不是RESTful web服务。
- en: Just like the RESTful web service works as one component or one side of a product,
    there are more low-level components of the RESTful web service as well. Not just
    endpoints but those endpoints depends on more low-level code. So in order to make
    our debugging easier, we write tests for these low-level components as well. Also,
    this way we can ensure that these low-level components are working fine and doing
    what they intend to. In case of any issues, we can run tests and know exactly
    what is not working properly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就像RESTful web服务作为产品的一个组件或一个方面一样，RESTful web服务还有更多低级组件。不仅仅是端点，而是这些端点依赖于更低级的代码。因此，为了使我们的调试更容易，我们也为这些低级组件编写测试。此外，这样我们可以确保这些低级组件运行良好，并且按照其意图进行操作。在出现任何问题的情况下，我们可以运行测试，并确切地知道哪些地方出了问题。
- en: Although, writing tests takes time at first but it is good in the long run.
    First of all, it saves the time of testing the same endpoints repeatedly after
    every change. Then, it helps a lot in case of refactoring something. It lets us
    know where the ripple effect is and what is affected because of our refactoring.
    Although, it takes time initially to write tests but it's worth it if we intend
    to make something that will remain there. In fact, the software development cost
    is less than the maintenance cost. This is because it will be developed once but
    to maintain and do the changes, it will consume more time. So, if we have written
    automated tests, it will ensure that everything is working exactly as required
    because the person who is maintaining the code is probably not the one who wrote
    it the first time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一开始编写测试需要时间，但从长远来看是有好处的。首先，它节省了在每次更改后重复测试相同端点的时间。然后，在重构某些东西时，它在很大程度上有所帮助。它让我们知道涟漪效应在哪里，以及由于我们的重构受到了什么影响。尽管一开始编写测试需要时间，但如果我们打算做一些长期存在的东西，那么它是值得的。事实上，软件开发成本比维护成本要低。这是因为它只会开发一次，但要维护和做更改，将会消耗更多的时间。因此，如果我们编写了自动化测试，它将确保一切都按照要求正常工作，因为维护代码的人很可能不是第一次编写代码的人。
- en: There is no one type of testing that provides all these benefits but there are
    different types of testing, with each having their own benefits. Now that we know
    the importance of automated testing and writing test cases, let's learn about
    the different types of testing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种测试可以提供所有这些好处，但有不同类型的测试，每种测试都有其自己的好处。既然我们知道了自动化测试和编写测试用例的重要性，让我们了解一下不同类型的测试。
- en: Types of testing
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'There are different types of testing in different contexts. In our case, we
    will discuss four major types of automated testing. These are the different types,
    based on how and what we test:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的上下文中有不同类型的测试。在我们的情况下，我们将讨论四种主要类型的自动化测试。这些是不同类型的测试，基于我们测试的方式和内容：
- en: Unit testing
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration testing
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Functional testing
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试
- en: Acceptance testing
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验收测试
- en: Unit testing
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: In unit testing, we test different units separately. By unit, we mean very small
    independent components. Obviously, components depend on each other but we consider
    a very small unit. In our case that small unit is class. The class is a unit that
    should have a single responsibility and it should be abstract from others and
    depend on the minimum number of other classes or components. Anyway, we can say
    in unit testing, we test class by creating an object of that class irrespective
    of whether it fulfills the required behavior.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，我们分别测试不同的单元。所谓的单元，指的是非常小的独立组件。显然，组件彼此依赖，但我们考虑的是一个非常小的单元。在我们的情况下，这个小单元是类。这个类是一个应该具有单一职责的单元，它应该与其他类或组件抽象，并且依赖于最少数量的其他类或组件。无论如何，我们可以说在单元测试中，我们通过创建该类的对象来测试类，而不管它是否满足所需的行为。
- en: One important thing to understand is that during unit tests, our test shouldn't
    touch code other than class/code under testing. If this code is interacting with
    some other object or external stuff during unit testing, we should mock these
    objects instead of interacting with actual objects so that the result of other
    object's methods should not affect the result of the unit/class we are testing.
    You are probably wondering what do we mean by mocking? **Mocking** means providing
    a fake object and setting it as per the desired behavior.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的事情要理解的是，在单元测试期间，我们的测试不应该触及除了测试类/代码之外的代码。如果在单元测试期间，这段代码与其他对象或外部内容进行交互，我们应该模拟这些对象，而不是与实际对象进行交互，以便其他对象的方法的结果不会影响我们正在测试的单元/类的结果。你可能想知道我们所说的模拟是什么意思？**模拟**意味着提供一个虚假对象，并根据所需的行为设置它。
- en: For example, if we are testing using the `User` class and it depends on the
    `Role` class, then a problem in the `Role` class shouldn't let the `User` class
    test fail. To achieve that, we will mock the `Role` object and inject in the `User`
    class object and then set the fixed return value for the method of the `Role`
    class that the `User` class is using. So next, it will actually invoke the `Role`
    class and will not depend on it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们正在使用`User`类进行测试，并且它依赖于`Role`类，那么`Role`类中的问题不应该导致`User`类的测试失败。为了实现这一点，我们将模拟`Role`对象并将其注入`User`类对象中，然后为`User`类使用的`Role`类的方法设置固定的返回值。因此，接下来，它将实际调用`Role`类，并且不会依赖于它。
- en: 'The benefits of unit testing:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的好处：
- en: It will let us know if a class is not doing what it intends to do. After some
    time, when the project is in maintenance, another developer will be able to understand
    what this class intends to do. What its methods are intended to do. So it will
    be like a manual of class written by a developer who knew why they wrote that
    class.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将让我们知道一个类是否没有达到其意图。一段时间后，当项目处于维护阶段时，另一个开发人员将能够理解这个类的意图。它的方法的意图是什么。因此，它将像是由知道为什么编写了该类的开发人员编写的类的手册。
- en: Also, as we just discussed we should mock objects, on which class under testing
    depends, we should be able to inject the mocked object inside the object of the
    class under testing. If we will be able to do that and are able to manage without
    invoking an outside object, only then we can call our code, a testable code. If
    our code is not testable, then we cannot write a unit test for it. So, unit testing
    helps us make our code testable which actually is more loosely coupled code. So
    having the testable code is an advantage (as it is loosely coupled and more maintainable),
    even if we are not writing tests.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另外，正如我们刚刚讨论的，我们应该模拟对象，测试类依赖的对象，我们应该能够将模拟对象注入到测试类的对象中。如果我们能够做到这一点，并且能够在不调用外部对象的情况下进行管理，那么我们才能称我们的代码为可测试代码。如果我们的代码不可测试，那么我们就无法为其编写单元测试。因此，单元测试帮助我们使我们的代码可测试，这实际上是更松散耦合的代码。因此，具有可测试代码是一种优势（因为它是松散耦合的，更易于维护），即使我们不编写测试。
- en: It will let us debug where exactly the problem is if we are having any problems.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们遇到任何问题，它将让我们调试出问题所在。
- en: As unit tests don't interact with outside objects, they are faster than some
    other types of testing.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于单元测试不与外部对象交互，因此它们比其他一些测试类型更快。
- en: Developers who write unit tests are considered to be better developers, as code
    with tests is consider cleaner code because the developer has ensured that unit
    level components are not tightly coupled. And units tests can be used as a manual
    to what a class provides and how to use it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试的开发人员被认为是更好的开发人员，因为带有测试的代码被认为是更干净的代码，因为开发人员已经确保了单元级组件不是紧密耦合的。单元测试可以作为类提供的手册以及如何使用它。
- en: Acceptance testing
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验收测试
- en: Acceptance testing is the complete opposite of unit testing. Unit testing is
    done at the lowest level while acceptance testing is done at the highest level.
    Acceptance testing is how an end-user will see the product and how an end-user
    will interact with it. In case of a website, in acceptance testing, we write the
    test that hits the URL from outside. Testing tools simulate a browser or external
    client to hit the URL. In fact, some testing tools also provide an option to use
    a web browser, such as Chrome or Firefox.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试是单元测试的完全相反。单元测试是在最低级别进行的，而验收测试是在最高级别进行的。验收测试是最终用户将如何看待产品以及最终用户将如何与产品进行交互的方式。在网站的情况下，在验收测试中，我们编写测试以从外部访问URL。测试工具模拟浏览器或外部客户端来访问URL。事实上，一些测试工具还提供使用Web浏览器（如Chrome或Firefox）的选项。
- en: Most of the time, these tests are written by a QA team. It is because they are
    the people who are there to ensure that system is working for the end user, exactly
    how it is intended to. Also, these tests execution is slow. And for user interfaces,
    sometimes there is a lot of detail to test so a separate QA team does this type
    of testing. However, it is just a common practice, so there can be an exception
    to that depending on the situation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这些测试是由QA团队编写的。这是因为他们是确保系统对最终用户正常工作的人，正如预期的那样。此外，这些测试的执行速度很慢。对于用户界面，有时需要测试很多细节，因此需要一个单独的QA团队来进行此类测试。但这只是一个常见的做法，因此根据情况可能会有例外。
- en: 'The benefits of acceptance testing:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试的好处：
- en: Acceptance testing lets you see how an end user will see and interact with your
    software from outside
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验收测试让您看到最终用户如何从外部看到和与您的软件交互
- en: It also lets you catch the problem, that will occur in any specific web browser
    because it uses a real web browser to execute tests
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还可以让您捕捉将在任何特定的Web浏览器中发生的问题，因为它使用真实的Web浏览器来执行测试
- en: As acceptance tests are written to be performed from outside, it doesn't matter
    which system you are testing and what technology or framework is used to write
    the system
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于验收测试是为了从外部执行而编写的，所以无论您要测试哪个系统以及用于编写系统的技术或框架是什么都无关紧要
- en: For example, if you are writing test cases using a tool written in PHP, then
    you can use it for systems written in other languages as well. So it doesn't matter
    if development language is PHP, Python, Golang, or .Net. It is because acceptance
    tests hit the system from outside without any internal knowledge of the system.
    And it is the only one of these four types of tests which test the system without
    considering any inner detail.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您正在使用PHP编写测试用例的工具，那么您也可以将其用于其他语言编写的系统。因此，开发语言是PHP、Python、Golang还是.Net都无关紧要。这是因为验收测试从外部击中系统，而不需要了解系统的任何内部知识。它是这四种测试中唯一一个在不考虑任何内部细节的情况下测试系统的测试类型。
- en: Acceptance tests are very useful as they interact with your system with a real
    browser. So if some thing will not work in the specific browser, then these things
    can be identified. But keep in mind that with a real browser, these tests take
    time to execute. It is also slow if the browser simulation is used but still the
    browser simulation will take less time than the real browser. Note that acceptance
    testing is considered the slowest and most time consuming among these four types
    of tests.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试非常有用，因为它们与您的系统使用真实浏览器进行交互。因此，如果某些内容在特定浏览器中无法正常工作，那么这些问题可以被识别出来。但请记住，使用真实浏览器，这些测试需要时间来执行。如果使用浏览器模拟，速度也会很慢，但仍然比真实浏览器快。请注意，验收测试被认为是这四种测试中最慢和最耗时的。
- en: Functional testing
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能测试
- en: Functional testing is similar to acceptance testing; however, it is from a different
    aspect. Functional testing is about testing functional requirements. It tests
    functional requirements and tests from outside the system. However, it has visibility
    inside and it can execute some code of the system in the test case.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试与验收测试类似；但是，它是从不同的角度。功能测试是关于测试功能需求。它测试功能需求并从系统外部进行测试。但是，它具有内部可见性，并且可以在测试用例中执行系统的一些代码。
- en: Similar to acceptance testing it hits the URL; however, even to hit the URL,
    it executes code the browser or external client will execute on that specific
    the URL. However, it doesn't actually hit the URL from outside. Tests don't hit
    URL in reality, they just simulate it. It is because unlike acceptance testing,
    we are not interested in how exactly an end user will interact with it, instead
    if code is executed from that URL then we want to know the response.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与验收测试类似，它击中URL；然而，即使要击中URL，它也会执行浏览器或外部客户端将在特定URL上执行的代码。但实际上并不是从外部击中URL。测试实际上并没有击中URL，它只是模拟了它。这是因为与验收测试不同，我们对最终用户如何与之交互并不感兴趣，而是如果代码从该URL执行，我们想要知道响应。
- en: We are more interested in if our functional requirements are met, and if not
    met then where is the problem?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更感兴趣的是我们的功能需求是否得到满足，如果没有得到满足，问题出在哪里？
- en: 'The benefits of functional testing:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试的好处：
- en: With functional testing, the testing tool has access to the system, so it shows
    better error detail than acceptance testing.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过功能测试，测试工具可以访问系统，因此显示的错误细节比验收测试更好。
- en: Functional tests don't actually open the browser or external client, so they
    are faster.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试实际上不会打开浏览器或外部客户端，因此速度更快。
- en: In functional tests, we can also execute system code directly through the testing
    tool, so in some cases, we can do so to either save test case writing time, or
    to make test case execution faster. There are many testing tools available for
    that. We will use one of them named CodeCeption shortly.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在功能测试中，我们还可以通过测试工具直接执行系统代码，因此在某些情况下，我们可以这样做来节省测试用例编写时间，或者使测试用例执行更快。有许多可用的测试工具。我们将很快使用其中一个名为CodeCeption。
- en: Integration testing
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration testing is very similar to unit testing in a way that in both types
    of testing we test classes by making their objects invoke their methods. But they
    are different in how we test classes. In case of unit testing, we don't touch
    other objects with which our class under test is interacting with. But in integration
    testing, we want to see how it all works together. We let them interact with each
    other.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试在某种程度上与单元测试非常相似，因为在这两种测试中，我们通过使它们的对象调用它们的方法来测试类。但它们在测试类的方式上有所不同。在单元测试的情况下，我们不会触及我们要测试的类与之交互的其他对象。但在集成测试中，我们想要看到它们如何一起工作。我们让它们相互交互。
- en: Sometimes, everything is working fine as per the unit test but not at higher-level
    tests (functional test or acceptance test) where we test it on the basis of requirements
    by hitting the URL. So, in some cases, higher-level tests are failing and unit
    tests are passing so to narrow down where the problem is, integration tests are
    very useful. So, you can consider that the integration test stands somewhere between
    functional tests and unit tests. Functional testing is about testing the functional
    requirement while unit testing is about testing a single unit. So, an integration
    test is in the middle of both, it tests how these single units work together;
    however, it tests by testing small components from code but lets them interact
    with each other as well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一切都按照单元测试的要求正常运行，但在更高级别的测试（功能测试或验收测试）中却不正常，我们会根据需求通过访问URL进行测试。因此，在某些情况下，高级别测试失败，而单元测试通过，为了缩小问题的范围，集成测试非常有用。因此，可以认为集成测试处于功能测试和单元测试之间。功能测试是关于测试功能需求，而单元测试是关于测试单个单元。因此，集成测试处于两者之间，它测试这些单个单元如何一起工作；然而，它通过测试代码中的小组件进行测试，同时也让它们相互交互。
- en: Some developers write integration tests and call it a unit test. Actually, integration
    tests just let code under the test to interact with other objects, so it can test
    how those classes work when they interact with system components. So, some people
    write integration tests if the code under test is very simple that needs to be
    tested while interacting with the system. However, it is not necessary to only
    write one unit test or integration test, you can write both if you have time.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员编写集成测试并将其称为单元测试。实际上，集成测试只是让测试中的代码与其他对象进行交互，因此它可以测试这些类在与系统组件交互时的工作方式。因此，如果测试中的代码非常简单且需要与系统交互进行测试，有些人会编写集成测试。然而，并不一定只编写一个单元测试或集成测试，如果有时间，可以同时编写两者。
- en: 'The benefits of integration testing:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的好处：
- en: Integration testing is useful when unit tests are not enough to catch bugs and
    high-level tests keep telling you that there is something wrong. So, integration
    tests helps in debugging the problem.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当单元测试不足以捕捉错误，高级别测试不断告诉您有问题时，集成测试非常有用，可以帮助调试问题。
- en: Because of the nature of integration testing, it helps a lot in case of refactoring
    while telling you exactly what is affected by the new change.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于集成测试的性质，在重构时非常有帮助，可以告诉您新更改受到了什么影响。
- en: What type of testing will we do?
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们将进行哪种类型的测试？
- en: Every type of testing has its own importance, especially unit testing. However,
    we will mainly do API testing that will be testing our RESTful web service endpoints.
    It never means that unit testing is less important, it is just that we are mainly
    focusing on API testing in this chapter because the book is focused on RESTful
    web services. In fact, testing is a big topic and you will be able to see complete
    books written on testing and TDD.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的测试都有其重要性，尤其是单元测试。然而，我们主要进行API测试，将测试我们的RESTful Web服务端点。这并不意味着单元测试不重要，只是我们在本章主要关注API测试，因为本书侧重于RESTful
    Web服务。实际上，测试是一个大课题，你将能够看到关于测试和TDD的完整书籍。
- en: Nowadays, **BDD** (**Behavior-driven Development**) is a more popular term.
    It is not completely different than TDD. It is just a different way of stating
    test cases. In fact, in BDD, there are no test cases instead there are specs.
    They serve the same purpose but BDD has a more friendly way to address the problem
    that is by stating specs and implementing them and that's how TDD works. So TDD
    and BDD are not different, just a different way to address the same problem.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，“BDD”（行为驱动开发）是一个更流行的术语。它与TDD并没有完全不同。它只是陈述测试用例的一种不同方式。实际上，在BDD中，没有测试用例，而是规范。它们具有相同的目的，但BDD以更友好的方式解决问题，即通过陈述规范并实现它们，这就是TDD的工作方式。因此，TDD和BDD并没有不同，只是解决同一个问题的不同方式。
- en: We can perform API testing in both functional and acceptance testing ways. However,
    it makes more sense to write API tests as functional tests. Because functional
    tests will be fast as well as having an insight to our code base. It also makes
    more sense because acceptance tests are for end users and end users don't use
    API. The end user uses a user interface.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以功能测试和验收测试的方式进行API测试。然而，将API测试编写为功能测试更有意义。因为功能测试将更快，并且对我们的代码库有洞察力。这也更有意义，因为验收测试是为最终用户而设计的，而最终用户不使用API。最终用户使用用户界面。
- en: Testing frameworks
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试框架
- en: Just like we have frameworks for writing software, we have frameworks for writing
    test cases as well. As we are PHP developers, we will use a testing framework
    that is written in PHP or in which we can write test cases in PHP so that we can
    use it easily.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们有用于编写软件的框架一样，我们也有用于编写测试用例的框架。由于我们是PHP开发人员，我们将使用一个用PHP编写的测试框架，或者我们可以在其中用PHP编写测试用例，以便我们可以轻松使用它。
- en: First of all, there are different testing frameworks that we can use in PHP,
    no matter which development framework we are using for application development.
    However, there are also testing tools that come with Laravel and Lumen. We can
    also use them for writing test cases. In fact, it will be easier to write test
    cases for Lumen but it will be Lumen and Laravel specific. Here, we will use a
    framework that you will be able to use outside the Lumen and Laravel ecosystems
    as well as for any PHP project, no matter which development framework you are
    using to write the code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，无论我们用于应用开发的开发框架是什么，我们都可以在PHP中使用不同的测试框架。然而，Laravel和Lumen也带有测试工具。我们也可以使用它们来编写测试用例。实际上，为Lumen编写测试用例会更容易，但它将是特定于Lumen和Laravel的。在这里，我们将使用一个框架，您将能够在Lumen和Laravel生态系统之外以及任何PHP项目中使用它，无论您使用哪个开发框架来编写代码。
- en: 'There are many different testing frameworks in PHP so how will we decide which
    one we want to use? We are going to use a framework that will not be so low level
    that we need to write everything by ourselves because we are not going to write
    unit tests but functional tests so we are picking up a bit of a high-level framework.
    A famous framework for unit testing is PHPUnit: [https://phpunit.de/](https://phpunit.de/).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中有许多不同的测试框架，那么我们如何决定使用哪一个？我们将使用一个不太低级的框架，因为我们不打算编写单元测试，而是功能测试，所以我们选择了一个稍微高级的框架。一个著名的单元测试框架是PHPUnit：[https://phpunit.de/](https://phpunit.de/)。
- en: 'There is another unit testing framework in **BDD** (**Behavior-driven Development**)
    style named as PHPSpec: [http://www.phpspec.net](http://www.phpspec.net) and PHPSpec
    is awesome if you are trying to learn or write unit tests. However, here we will
    be using a framework that is good for both functional and unit tests. Although,
    we are not writing unit tests but we want to consider a framework that you can
    later use for unit testing as well. The framework I have picked is CodeCeption:
    [http://codeception.com/](http://codeception.com/) because it seems very good
    at API testing. Another BDD-style alternative could be Behat: [http://behat.org/en/latest/](http://behat.org/en/latest/).
    It is a high-level testing framework but it is better if we are doing acceptance
    testing or even better if we have a separate QA team who will be writing many
    test cases in the Gherkin syntax ([https://github.com/cucumber/cucumber/wiki/Gherkin](https://github.com/cucumber/cucumber/wiki/Gherkin))
    that is very close to the natural language. However, Behat and Gherkin may have
    a bit more of a learning curve for PHP developers while CodeCeption is simply
    PHP (although it can use Gherkin if required), so as many readers will be new
    to writing test cases I will keep things simple and close to PHP. However, here
    is a detailed comparison I wrote 2 years ago on which framework to use for API
    testing, it is old but still valid for most of the stuff. If you are interested
    then you can have a look at [http://haafiz.me/programming/api-testing-selecting-testing-framework](http://haafiz.me/programming/api-testing-selecting-testing-framework).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个以**BDD**（行为驱动开发）风格命名的单元测试框架，名为PHPSpec：[http://www.phpspec.net](http://www.phpspec.net)，如果您想学习或编写单元测试，PHPSpec也很棒。然而，在这里，我们将使用一个既适用于功能测试又适用于单元测试的框架。尽管我们不写单元测试，但我们希望考虑一个稍后也可以用于单元测试的框架。我选择的框架是CodeCeption：[http://codeception.com/](http://codeception.com/)，因为它在API测试方面似乎非常出色。另一个BDD风格的选择可能是Behat：[http://behat.org/en/latest/](http://behat.org/en/latest/)。这是一个高级测试框架，但如果我们进行验收测试，甚至更好的是如果我们有一个专门的QA团队，他们将用Gherkin语法（[https://github.com/cucumber/cucumber/wiki/Gherkin](https://github.com/cucumber/cucumber/wiki/Gherkin)）编写许多测试用例，这非常接近自然语言。然而，对于PHP开发人员来说，Behat和Gherkin可能有更多的学习曲线，而CodeCeption只是简单的PHP（尽管如果需要，它也可以使用Gherkin），因此许多读者将是新手编写测试用例，我将保持简单并贴近PHP。然而，这是我两年前写的关于选择API测试框架的详细比较，虽然有些过时，但对于大部分内容仍然有效。如果您感兴趣，可以看一下[http://haafiz.me/programming/api-testing-selecting-testing-framework](http://haafiz.me/programming/api-testing-selecting-testing-framework)。
- en: CodeCeption introduction
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CodeCeption简介
- en: CodeCeption is written in PHP and it is powered by PHPUnit. CodeCeption claims
    that *CodeCeption uses PHPUnit as a backend for running its tests. Thus, any PHPUnit
    test can be added to a CodeCeption test suite and then executed*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: CodeCeption是用PHP编写的，并由PHPUnit支持。CodeCeption声称*CodeCeption使用PHPUnit作为运行其测试的后端。因此，任何PHPUnit测试都可以添加到CodeCeption测试套件中，然后执行*。
- en: Tests other than acceptance tests require a testing framework that has some
    insight or connection with code under the test. If we are using a development
    framework than a testing framework should has some sort of module or plugin for
    that framework. CodeCeption is good at this. It provides modules for different
    frameworks and CMS, such as Symfony, Joomla, Laravel, Lumen, Yii2, WordPress,
    and Zend frameworks. Just to let you know, these are just a few frameworks. CodeCeption
    has support for many other modules that can be helpful in different cases.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了验收测试之外的其他测试需要一个具有对测试代码的洞察或连接的测试框架。如果我们使用的是开发框架，那么测试框架应该具有某种针对该框架的模块或插件。CodeCeption在这方面做得很好。它为不同的框架和CMS提供了模块，例如Symfony、Joomla、Laravel、Lumen、Yii2、WordPress和Zend框架。只是让您知道，这些只是一些框架。CodeCeption还支持许多其他模块，可以在不同情况下提供帮助。
- en: Setup and understanding the structure
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和理解结构
- en: 'There are different ways to install CodeCeption but I prefer composer and it
    is a standard way to install different PHP tools as PHP packages. So let''s install
    that:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 安装CodeCeption有不同的方法，但我更喜欢composer，这是安装不同PHP工具的标准方式。所以让我们安装它：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we are using the `--dev` flag so that it will add CodeCeption
    in the `require-dev` block in the `composer.json` file. So, in production it will
    not be installed when you run `composer install --no-dev`, it will not install
    dependencies in the `require-dev` block. In case of confusion, check the composer-related
    chapter that is [Chapter 5](2221827f-3115-4141-a9c1-f4a30cf0f2a9.xhtml), *Load
    and resolve with Composer, an Evolutionary*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们正在使用`--dev`标志，这样它就会将CodeCeption添加到`composer.json`文件中的`require-dev`块中。因此，在生产环境中，当您运行`composer
    install --no-dev`时，它将不会安装在`require-dev`块中的依赖项。如果有疑惑，请查看与composer相关的章节，即[第5章](2221827f-3115-4141-a9c1-f4a30cf0f2a9.xhtml)，*使用Composer加载和解决问题，一个进化*。
- en: After installing it, we need to set it up for writing test cases and to make
    it a part of our project. Installation just means that it is now in the `vendors`
    directory and now we can execute CodeCeption commands through composer.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们需要设置它以编写测试用例，并使其成为我们项目的一部分。安装只意味着它现在在`vendors`目录中，现在我们可以通过composer执行CodeCeption命令。
- en: 'To set up, we need to run the CodeCeption bootstrap command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置，我们需要运行CodeCeption引导命令：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`codecept` is CodeCeption''s executable in the `vendor/bin` directory, so we
    executed it through composer and gave it an argument to run the `bootstrap` command.
    So after executing this command, some files and directories will be added in your
    project.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`codecept`是CodeCeption在`vendor/bin`目录中的可执行文件，所以我们通过composer执行它，并给它一个参数来运行`bootstrap`命令。因此，在执行这个命令之后，一些文件和目录将被添加到你的项目中。'
- en: 'Here is a list of them:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是它们的列表：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you look at the mentioned list of files, then you will notice that we have
    one file at root, that is, `codeception.yml`, which contains the basic configurations
    of CodeCeption tests. It tells us about paths and basic settings. If you read
    this file, you will be able to easily understand it. If you don't understand something,
    ignore it for now. Other than this file, everything is in the `tests/` directory.
    This stuff is more important to us.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下提到的文件列表，那么你会注意到我们在根目录下有一个文件，即`codeception.yml`，其中包含了CodeCeption测试的基本配置。它告诉我们关于路径和基本设置。如果你阅读这个文件，你将能够很容易地理解它。如果你不理解某些东西，现在先忽略它。除了这个文件，其他的都在`tests/`目录下。这些对我们来说更重要。
- en: First of all, there are two empty directories in the `tests/` directory. `_output`
    contains output of test cases in case of failure and `_data` contains database
    queries in case we want to set up a default database for testing before and after
    running tests.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`tests/`目录下有两个空目录。`_output`包含测试用例的输出，如果失败的话，`_data`包含数据库查询，如果我们想在运行测试之前和之后设置一个默认的数据库。
- en: Other than that, you can see there are three groups of files having similar
    files with the difference of testing type. In CodeCeption, we know these groups
    as test suites. So, by default CodeCeption comes with three test suites. The acceptance,
    functional, and unit suites. All these three suites contain four files and one
    empty directory. So, let's look into the purpose of each of these files and directory.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，你可以看到有三组文件，这些文件具有相似的文件，只是测试类型不同。在CodeCeption中，我们知道这些组是测试套件。所以，默认情况下，CodeCeption带有三个测试套件。接受、功能和单元套件。所有这三个套件都包含四个文件和一个空目录。所以，让我们来看看每个文件和目录的目的。
- en: tests/{suite-name}/
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: tests/{suite-name}/
- en: Here, `{suite-name}` will be replaced by the suite's actual name; like in case
    of unit suite, it will be `tests/unit/`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`{suite-name}`将被套件的实际名称替换；比如说单元套件，它将是`tests/unit/`。
- en: Anyway, this directory will be used to save test cases that we will write.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这个目录将用于保存我们将要编写的测试用例。
- en: tests/{suite-name}.suite.yml
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: tests/{suite-name}.suite.yml
- en: This file is a configuration file specific to that suite. It contains `ActorName`
    for this particular suite. Actor is nothing else than one with specific settings
    and capabilities. Based on actor settings, it runs tests differently. Settings
    include the module's configurations and enabling modules.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件是特定套件的配置文件。它包含了这个特定套件的`ActorName`。Actor实际上就是具有特定设置和能力的人。根据actor的设置，它以不同的方式运行测试。设置包括模块的配置和启用模块。
- en: tests/_support/_generated/{suite-name}TesterActions.php
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: tests/_support/_generated/{suite-name}TesterActions.php
- en: This file is an auto generated file based on settings in `tests/{suite-name}.suite.yml`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件是基于`tests/{suite-name}.suite.yml`中的设置自动生成的文件。
- en: tests/_support/{suite-name}Tester.php
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: tests/_support/{suite-name}Tester.php
- en: This file uses the generated file in the `_generated` directory and the developer
    can customize it more, if required. However, normally it isn't required.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件使用了`_generated`目录中生成的文件，开发人员可以根据需要进行更多的自定义。然而，通常情况下是不需要的。
- en: tests/_support/Helper/{suite-name}.php
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: tests/_support/Helper/{suite-name}.php
- en: This file in the suite is the helper file. Here, you can add more methods in
    class and use that in your test cases. Just like other code has libraries and
    helpers, your test-cases code can also have helper methods in the helper class
    for that suite.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 套件中的这个文件是辅助文件。在这里，你可以在类中添加更多的方法，并在你的测试用例中使用它。就像其他代码有库和辅助程序一样，你的测试用例代码也可以在套件的辅助类中有辅助方法。
- en: Note that you can add more files, if you need different helper classes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你需要不同的辅助类，你可以添加更多的文件。
- en: Creating the API suite
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建API套件
- en: 'In our case, we need unit tests and API tests. Although, we can use the functional
    tests suite for API tests because these are at the functional testing level but
    for the sake of clarity and understanding, we can create a separate API suite
    through this command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们需要单元测试和API测试。虽然我们可以使用功能测试套件进行API测试，因为这些测试处于功能测试级别，但为了清晰和理解起见，我们可以通过这个命令创建一个单独的API套件：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, in this command, `g` is short for generate and it will generate an API
    suite. `api` is just the name of another suite, and this command has created these
    files and directories:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，`g`是`generate`的缩写，它将生成一个API套件。`api`只是另一个套件的名称，这个命令已经创建了这些文件和目录：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `api.suite.yml` file will have basic settings without much detail. It is
    because the `api.suite.yml` file will have basic settings without much detail.
    It is because `api` here is just a name. You could even say:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`api.suite.yml`文件将具有基本设置，但没有太多细节。这是因为`api.suite.yml`文件将具有基本设置，但没有太多细节。这是因为这里的`api`只是一个名称。你甚至可以说：'
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It should have created `abc` suite with the same file structure and settings.
    So, our API Suite is just another test suite that we created separately for the
    sake of clarity and understanding.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该已经创建了`abc`套件，具有相同的文件结构和设置。所以，我们的API套件只是另一个我们为了清晰和理解而单独创建的测试套件。
- en: Configuring the API suite
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置API套件
- en: 'API needs REST client to fetch RESTful web service endpoints. Other than that
    it depends on Lumen. We said Lumen because it will be integrated with our code
    as we are writing functional level tests not acceptance tests. So, our testing
    framework should have insight and interaction with Lumen. What else will we need
    in our configuration? We need to set the testing `.env` file. So, with that here
    is what our configuration file looks like:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: API需要REST客户端来获取RESTful网络服务端点。除此之外，它还依赖于Lumen。我们说Lumen，因为它将与我们的代码集成，我们正在编写功能级别的测试而不是接受测试。因此，我们的测试框架应该对Lumen有洞察力和交互。我们的配置还需要什么？我们需要设置测试的`.env`文件。因此，这就是我们的配置文件的样子：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before proceeding further, note that we have specified a different environment
    file option here under the `config/Lumen`, that is, `environment_file: .env.testing`.
    So, if we are specifying `.env.testing` here, then we should have a `.env.testing`.
    Nothing big, just copy and paste your `.env` file. From the command line, execute
    this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '在继续之前，请注意，我们在`config/Lumen`下指定了一个不同的环境文件选项，即`environment_file: .env.testing`。因此，如果我们在这里指定了`.env.testing`，那么我们应该有一个`.env.testing`。没什么大不了的，只需复制并粘贴您的`.env`文件。从命令行执行以下操作：'
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Change the database credentials so that it points to the different database,
    having a copy of your current database schema and data, based on which you want
    to write test cases. Although, database-related stuff we will do during testing
    in Laravel/Lumen will be rollback, and will not affect our actual database, so
    the same database will be fine in the development. However, it is not recommended,
    in fact, prohibited on staging to have the same database for testing; so, better
    to keep different databases and configurations from the start.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数据库凭据，使其指向不同的数据库，该数据库具有您当前数据库架构和数据的副本，基于这些数据，您想编写测试用例。尽管在Laravel/Lumen中进行测试时与数据库相关的内容将会回滚，并且不会影响我们的实际数据库，因此在开发中使用相同的数据库也是可以的。但是，在暂存环境中不建议，事实上是禁止使用相同的数据库进行测试；因此，最好从一开始就保持不同的数据库和配置。
- en: We don't run tests in production. We don't even install tests related tool in
    production, as you can see we installed CodeCeption with the `--dev` flag. So,
    when our code is in production and we want to deploy a new feature, our test cases
    are run on a different server and then the code is deployed on the production
    server. There are several **CI** (**Continuous Integration**) tools available
    for that.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在生产环境中运行测试。我们甚至不会在生产环境中安装与测试相关的工具，正如您所看到的，我们使用`--dev`标志安装了CodeCeption。因此，当我们的代码在生产环境中，并且我们想要部署一个新功能时，我们的测试用例会在不同的服务器上运行，然后将代码部署到生产服务器上。有几种**CI**（**持续集成**）工具可用于此。
- en: Writing test cases
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: Now, it's time to write test cases. The first thing is how we decide what we
    should test. Should we start testing every endpoint and then every class?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候编写测试用例了。首先要了解的是，我们如何决定应该测试什么。我们应该先测试每个端点，然后再测试每个类吗？
- en: The first thing to understand is that we should only test the code that is written
    by us. By us, I mean someone from our team. We don't intend to test the code that
    is third-party, framework code, or a package. Also, we don't want to test each
    and every class and every method. In an ideal case, we can test each and every
    minor function's details but it has its drawbacks. First of all in the real world,
    we don't have time for that. We intend to test most parts but not all parts. Another
    reason is that all the tests that we are writing are a liability as well. We also
    need to maintain these tests over time. So, we do unit test for the parts where
    it makes sense to do so; where it is actually doing something which have some
    complexity. If you have a function that is as simple as that it calls another
    function and returns the result then I don't think that such piece of code should
    have its own test.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要理解的是，我们应该只测试我们自己编写的代码。我所说的我们，是指我们团队的某个人。我们不打算测试第三方代码、框架代码或包代码。此外，我们也不想测试每个类和每个方法。在理想情况下，我们可以测试每个细微功能的细节，但这也有其缺点。首先，在现实世界中，我们没有时间这样做。我们打算测试大部分但不是全部部分。另一个原因是，我们编写的所有测试也是一种负担。随着时间的推移，我们还需要维护这些测试。因此，我们只对有意义的部分进行单元测试；只有在实际上执行一些复杂操作的地方才进行测试。如果您有一个函数，它的功能就是调用另一个函数并返回结果，那么我认为这样的代码片段不应该有自己的测试。
- en: Another thing is, if we are doing unit testing as well as API testing then from
    where should we start writing tests? Should we write tests for all endpoints and
    then all classes or we will do the opposite so we will first test all classes
    and then all endpoints? How will we do that? We obviously intend to test our endpoints.
    And we also intend to test code under those endpoints. This is something that
    different people can do differently but I and many other people, I have seen,
    start writing both API tests and unit tests side by side. I prefer to write API
    tests and keep writing them for one resource. After that, we will go towards unit
    testing of controller. In our case, we don't have much stuff in the model other
    than what is being inherited from Eloquent or relations. During API testing of
    a resource, if we need more detail to fix a bug, then we can start writing unit
    tests for that class. But there is no hard and fast rule. It is just a matter
    of preference.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件事是，如果我们既要进行单元测试又要进行API测试，那么我们应该从哪里开始编写测试呢？我们应该先为所有端点编写测试，然后再为所有类编写测试，还是相反，先测试所有类，然后再测试所有端点？我们该如何做呢？我们显然打算测试我们的端点。我们也打算测试这些端点下的代码。这是不同的人可以以不同方式做的事情，但我和许多其他人，我见过的人，都是同时编写API测试和单元测试。我更喜欢编写API测试并继续为一个资源编写测试。之后，我们将转向控制器的单元测试。在我们的情况下，模型中除了从Eloquent或关系继承的内容之外，没有太多东西。在对资源进行API测试时，如果我们需要更多细节来修复错误，那么我们可以开始为该类编写单元测试。但这并没有硬性规定。这只是一种偏好问题。
- en: API tests for post resource
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 针对post资源的API测试
- en: 'We can either write test cases in a structural approach or we can write it
    in class. Both ways are fine, I recommend class, so you can take advantage of
    your OOP concepts, if you want at some point. So let''s create a file for that:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以结构化方法编写测试用例，也可以以类的方式编写。两种方式都可以，我建议使用类，这样您可以在某个时候利用面向对象的概念。因此，让我们为此创建一个文件：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will create a class in `tests/api/CreatePostCest.php` with content similar
    to:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`tests/api/CreatePostCest.php`中创建一个类，内容类似于：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `_before()` method is here so that you can write any code, which you want
    to execute before your test cases and the `_after()` method is there to execute
    after your test cases. The next method there is just for an example that we are
    going to modify.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`_before()`方法是为了让您可以在测试用例之前编写任何代码，而`_after()`方法是为了在测试用例之后执行。接下来的方法只是一个示例，我们将对其进行修改。'
- en: Here, we are going to write two types of tests. One while trying to create a
    post without login that should returns unauthorized error and the other to create
    a post after login which should be successful.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将编写两种类型的测试。一种是在尝试未登录时创建一个帖子，这应该返回未经授权的错误，另一种是在登录后创建一个帖子，这应该是成功的。
- en: 'Before writing that, let''s set up our database factory to get random content
    for post, so we can use it during testing. Let''s modify `app/database/factories/ModelFactory.php`,
    so it looks like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在写之前，让我们设置我们的数据库工厂，以便为帖子获取随机内容，这样我们在测试期间可以使用它。让我们修改`app/database/factories/ModelFactory.php`，使其看起来像这样：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The highlighted code is that I just added. So, we are telling it to return an
    array of parameters, title, content, and status generated through `Faker\Generator`
    class' object. So, based on how we have defined different fields here, we can
    generate random content for Post user through `ModelFactory`, so that data will
    be random and dynamic instead of static content. During testing, it is better
    to have random data in test cases to test it properly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚刚添加了粗体标记的代码。所以，我们告诉它返回一个基于`Faker\Generator`类对象生成的参数数组，标题、内容和状态。所以，根据我们在这里定义的不同字段，我们可以通过`ModelFactory`为帖子用户生成随机内容，这样数据将是随机和动态的，而不是静态内容。在测试期间，最好在测试用例中使用随机数据来进行测试。
- en: 'Okay, now let''s write our test case in the `CreatePostCest.php` file, here
    is the function that we will write:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们在`CreatePostCest.php`文件中编写我们的测试用例，这是我们将要编写的函数：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, comments are explaining everything there, so there is no need
    to tell anything explicitly except that we have used the `sendPost()` method to
    send a Post request, we could also say `sendGet()` or `sendPut()` for different
    HTTP methods, and so on. So, now we need to run this test.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，注释已经解释了一切，所以除了我们使用`sendPost()`方法发送一个Post请求之外，没有必要明确说明任何事情，我们也可以说`sendGet()`或`sendPut()`来使用不同的HTTP方法，等等。所以，现在我们需要运行这个测试。
- en: 'We can run it through:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式运行它：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It will not give us that clear output on the console. We can add `-v`, `-vv`,
    or `-vvv` to make the output more and more verbose, but in this command, it will
    make composer exec-related information more and more verbose. So let''s execute
    it as:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会在控制台上给我们清晰的输出。我们可以添加`-v`，`-vv`或`-vvv`来使输出更加详细，但在这个命令中，它会使composer exec相关的信息变得越来越详细。所以让我们这样执行：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Feel free to add `-v` up to three times to get more and more verbose output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 随意添加`-v`，最多三次，以获得更加详细的输出：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can make an alias of path `vendor/bin/codecept` and during that session
    in console, we can use shorthand like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为路径`vendor/bin/codecept`创建一个别名，在控制台的会话中，我们可以使用这样的简写：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So, execute it and you will see a lot of detail in the console. Use `-v`, `-vv`,
    or `-vvv` based on how you want it. For now let''s execute it as:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，执行它，你会在控制台中看到很多细节。根据你的需要使用`-v`，`-vv`或`-vvv`。现在让我们这样执行它：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In our case, our first test should have passed. Now, we should write our second
    test case, that is, to create a post after login. It involves more things that
    we need to understand. So let''s first see the code for this test case and then
    we will review it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们的第一个测试应该已经通过了。现在，我们应该编写我们的第二个测试用例，也就是在登录后创建一个帖子。这涉及到更多我们需要理解的东西。所以让我们先看一下这个测试用例的代码，然后再进行审查：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you look at this test case, you will find it very similar to the previous
    test case code except for a few statements. So, I have highlighted these statements
    in bold. The first thing is that as the test case is different, so is our `wantTo()`
    argument.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看这个测试用例，你会发现它和之前的测试用例代码非常相似，除了一些语句。所以，我已经用粗体标出了这些语句。第一件事是，由于测试用例不同，所以我们的`wantTo()`参数也不同。
- en: Then, we are getting the first user from DB and generating a token based on
    the user object. Here, we are calling our application code because we are using
    the Lumen module as configured in the `api.suite.yml` file. Then, we are using
    CodeCeption's `$I->amBearerAuthenticated($token)` method with `$token` that we
    generated. This means we are sending a valid token so the server will consider
    it as a logged-in user. This time response code will be 200, so by saying `$I->seeResponseCodeIs(200)`,
    we are telling it that it should have 200 response code or else the test should
    fail. That's all this code does.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从数据库中获取第一个用户，并基于用户对象生成一个令牌。在这里，我们调用我们的应用程序代码，因为我们使用了在`api.suite.yml`文件中配置的Lumen模块。然后，我们使用CodeCeption的`$I->amBearerAuthenticated($token)`方法与我们生成的`$token`一起。这意味着我们发送了一个有效的令牌，所以服务器将把它视为已登录用户。这次响应代码将是200，所以通过`$I->seeResponseCodeIs(200)`，我们告诉它应该有200的响应代码，否则测试应该失败。这段代码就是这样做的。
- en: Actually, there can be a lot more test cases similar to this, like test if it
    returns `400 Bad Request` response in case of an incomplete request.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，还可以有很多类似的测试用例，比如测试如果在请求不完整的情况下返回`400 Bad Request`响应。
- en: 'After running tests, you will see this at the end of the console:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试后，你会在控制台的最后看到这个：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This shows that we are asserting two things. <q>Assertion means stating an
    expectation or fact that we want to be true.</q> In simple words, it is something
    that we are checking on response. Like, right now we are testing response code
    only. But in the real world, we test the whole response with a lot more test cases.
    CodeCeption also offers us to test those things. So, let''s modify our current
    two test cases with more assertions. Here are two more things that we are going
    to test:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们断言了两件事。<q>断言意味着陈述我们希望为真的期望或事实。</q>简单来说，这是我们在响应中检查的内容。就像现在我们只测试响应代码一样。但在现实世界中，我们会用更多的测试用例来测试整个响应。CodeCeption也为我们提供了测试这些内容的方法。所以，让我们用更多的断言修改我们当前的两个测试用例。以下是我们将要测试的两个内容：
- en: Will assert that we get JSON in response.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将断言我们得到了响应中的JSON。
- en: Will assert that we get the right data in response based on our input.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将断言我们根据我们的输入得到了正确的响应数据。
- en: 'So here is our code to do so:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是我们的代码：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see the highlighted text in the preceding code snippet, we have
    added three more assertions and you can see how simple it is. Actually, checking
    something in response can be tricky when we don''t know what values an object
    can have. For example, what if we want to request and see posts list. So, how
    we will assert when we don''t know the values? In such cases, you can use JSON
    path-based assertion, documented here: [http://codeception.com/docs/modules/REST#seeResponseJsonMatchesJsonPath](http://codeception.com/docs/modules/REST#seeResponseJsonMatchesJsonPath).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上述代码片段中看到的，我们添加了三个额外的断言，你可以看到它是多么简单。实际上，在我们不知道对象可能具有的值时，检查响应中的内容可能会有些棘手。例如，如果我们想要请求并查看帖子列表，那么当我们不知道值时，我们该如何断言呢？在这种情况下，你可以使用基于JSON路径的断言，文档在这里：[http://codeception.com/docs/modules/REST#seeResponseJsonMatchesJsonPath](http://codeception.com/docs/modules/REST#seeResponseJsonMatchesJsonPath)。
- en: 'You will use it something like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你会像这样使用它：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is also what you see in Response but there is even a method which tests
    if that record exists now in DB as well. You should try it on your own. Here you
    can find its documentation: [http://codeception.com/docs/modules/Db#seeInDatabase](http://codeception.com/docs/modules/Db#seeInDatabase).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是你在响应中看到的，但甚至有一个方法可以测试该记录是否现在也存在于数据库中。你应该自己尝试一下。你可以在这里找到它的文档：[http://codeception.com/docs/modules/Db#seeInDatabase](http://codeception.com/docs/modules/Db#seeInDatabase)。
- en: Other test cases
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他测试用例
- en: 'There are a lot more test cases related to other Post operations (endpoints).
    However, the way to write test cases will remain same. So, I am skipping the so
    that you can write those test cases by yourself. However, just as a hint, here
    are some test cases you should write for practice:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多与其他帖子操作（端点）相关的测试用例。然而，编写测试用例的方式将保持不变。所以，我会跳过这部分，这样你就可以自己编写这些测试用例。不过，作为提示，以下是一些你应该练习编写的测试用例：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then related to update Post:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后关于更新帖子：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then related to post listing:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后关于帖子列表：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then related to getting a single post:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后关于获取单个帖子：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'So, I would highly recommend that you write these test cases. In case you need
    more examples or if you want to see examples of testing authentication-related
    endpoints, then here you can find some examples that you can read to understand
    it better: [https://github.com/Haafiz/REST-API-for-basic-RPG/tree/master/tests/api](https://github.com/Haafiz/REST-API-for-basic-RPG/tree/master/tests/api).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我强烈建议你编写这些测试用例。如果你需要更多示例，或者想要查看与身份验证相关的端点测试示例，那么你可以在这里找到一些示例，以便更好地理解：[https://github.com/Haafiz/REST-API-for-basic-RPG/tree/master/tests/api](https://github.com/Haafiz/REST-API-for-basic-RPG/tree/master/tests/api)。
- en: For more information related to CodeCeption, refer to the CodeCeption documentation
    at [http://codeception.com/](http://codeception.com/).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有关CodeCeption的更多信息，请参阅CodeCeption文档：[http://codeception.com/](http://codeception.com/)。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned testing types, the importance of automated testing,
    and wrote API tests for our RESTful web service endpoints. One thing I again want
    to say here is that we wrote only API tests to keep our focus on our topic but
    unit testing is of no less importance. However, testing is a huge topic and unit
    testing has its own complexity, so couldn't be discussed in this one chapter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了测试类型，自动化测试的重要性，并为我们的RESTful Web服务端点编写了API测试。我再次想说的一件事是，我们只编写了API测试，以保持专注在我们的主题上，但单元测试同样重要。然而，测试是一个庞大的主题，单元测试有其自身的复杂性，所以无法在这一章中讨论。
- en: More resources
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多资源
- en: 'If you want to know more about automated testing in PHP, then here are some
    important resources:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于PHP自动化测试的信息，那么这里有一些重要的资源。
- en: Test Driven Laravel (Video course by Adam Wathan) [https://adamwathan.me/test-driven-Laravel/](https://adamwathan.me/test-driven-laravel/),
    however this is mainly focused on Laravel. But still, this will teach you important
    things.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 《Test Driven Laravel》（Adam Wathan的视频课程）[https://adamwathan.me/test-driven-Laravel/](https://adamwathan.me/test-driven-laravel/)，然而这主要是关注于Laravel的。但是，这也会教给你一些重要的东西。
- en: Similarly, there is Laravel Testing Decoded (an old book by Jeffrey Way) at
    [https://leanpub.com/Laravel-testing-decoded](https://leanpub.com/laravel-testing-decoded)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，Jeffrey Way的旧书《Laravel Testing Decoded》可以在[https://leanpub.com/Laravel-testing-decoded](https://leanpub.com/laravel-testing-decoded)找到。
- en: 'Again, this is a Laravel-specific book but teaches you a lot in general. There
    is Jeffrey Way''s new upcoming book that is in general on PHP testing named Testing
    PHP: [https://leanpub.com/testingphp](https://leanpub.com/testingphp)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是一本专门针对Laravel的书，但在一般情况下也会教给你很多东西。Jeffrey Way即将推出的新书是关于PHP测试的，名为《Testing
    PHP》：[https://leanpub.com/testingphp](https://leanpub.com/testingphp)
- en: 'The preceding mentioned book that is on PHP is still not completed so you can
    learn from Jeffrey Way''s awesome screencasts testing videos: [https://laracasts.com/skills/testing](https://laracasts.com/skills/testing)
    In fact, Laracasts is not only good for testing but for learning overall PHP and
    Laravel.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的关于PHP的书还没有完成，所以你可以从Jeffrey Way的精彩的视频测试中学习：[https://laracasts.com/skills/testing](https://laracasts.com/skills/testing)。事实上，Laracasts不仅适用于测试，还适用于全面学习PHP和Laravel。
- en: No matter which source you pick, the important thing is that you do practice.
    The same is true for both development and testing. In fact, if you haven't done
    testing before then practicing testing is even more important. To start, you will
    find it a bit overwhelming but it is worth it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪个来源，重要的是你要练习。这对于开发和测试都是如此。事实上，如果你以前没有进行过测试，那么练习测试就更加重要。起初，你可能会感到有些不知所措，但这是值得的。
