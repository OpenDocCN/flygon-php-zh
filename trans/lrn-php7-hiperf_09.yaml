- en: Appendix B. MVC and Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B. MVC和框架
- en: We covered the names of some of the frameworks in different chapters, but we
    did not discuss them. In today's world, we don't invent the wheel again; we build
    upon the tools that are already built, tested, and widely used. So, as best practice,
    if there is nothing available to fulfill the requirements, we can build it using
    a framework that suits the requirements best.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在不同章节中提到了一些框架的名称，但没有讨论它们。在今天的世界中，我们不会重新发明轮子；我们会在已经构建、测试和广泛使用的工具基础上进行构建。因此，作为最佳实践，如果没有可用的工具来满足需求，我们可以使用最适合需求的框架来构建它。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: The MVC design pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVC设计模式
- en: Laravel
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Laravel
- en: Lumen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lumen
- en: Apigility
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apigility
- en: The MVC design pattern
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC设计模式
- en: '**Model View Controller** (**MVC**) is a design pattern widely used in different
    programming languages. Most PHP frameworks use this design pattern. This pattern
    divides the application into three layers: Model, View, and Controller. Each one
    of these has separate tasks, and they are all interconnected. There are different
    visual representations for MVC, but an overall and simple representation can be
    seen in the following diagram:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型视图控制器**（**MVC**）是一种广泛应用于不同编程语言中的设计模式。大多数PHP框架使用这种设计模式。这种模式将应用程序分为三层：模型、视图和控制器。每个层都有不同的任务，并且它们都相互连接。MVC有不同的视觉表示，但是可以在以下图表中看到一个整体和简单的表示：'
- en: '![The MVC design pattern](graphics/B05225_AppendixB_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![MVC设计模式](graphics/B05225_AppendixB_01.jpg)'
- en: Now, let's discuss each part of the MVC design pattern.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论MVC设计模式的每个部分。
- en: Model
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: The model layer is the backbone of the application and handles the data logic.
    Mostly, it is considered that model is responsible for CRUD operations on a database,
    which may or may not be true. As we mentioned previously, model is responsible
    for the data logic, which means that data validation operations can also be performed
    here. In simple words, models provide an abstraction for the data. The remaining
    application layers don't know or care how and from where the data comes or how
    an operation is performed on data. It is the model's responsibility to take care
    of all data logic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模型层是应用程序的支柱，处理数据逻辑。大多数情况下，认为模型负责对数据库进行CRUD操作，这可能是真实的，也可能不是。正如我们之前提到的，模型负责数据逻辑，这意味着数据验证操作也可以在这里执行。简单地说，模型为数据提供了一个抽象。其余的应用层不知道或不关心数据来自何处，或者如何对数据执行操作。这是模型的责任，负责处理所有数据逻辑。
- en: In today's complex framework structures, the overall MVC structure is changed,
    and not only do models handle data operations, but also, every other application
    logic is handled by models. The method followed is fat models and slim controllers,
    which means keep all the application logic in models and the controllers as clean
    as possible.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今复杂的框架结构中，整体MVC结构已经改变，不仅模型处理数据操作，而且每个其他应用逻辑也由模型处理。遵循的方法是“胖模型，瘦控制器”，这意味着将所有应用逻辑放在模型中，使控制器尽可能清晰。
- en: Views
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: Views are what is visible to end users. All data related to this user and public
    is displayed in the views, so views can be called the visual representation of
    the models. Views need data to display. It asks for some specific data or action
    from the controller. Views do not know or want to know from where the controller
    gets this data; it just asks the controller to get it. Controller knows who to
    ask for this specific data and communicates with the specific model. It means
    that views do not have any direct link to models. However, in the earlier diagram,
    we linked model to view directly. This is because in the advanced systems nowadays,
    views can directly take data from models. For example, Magento controllers can't
    send data back to views. For the data (that is, to get data directly from the
    database) and/or to communicate with models, views communicate with blocks and
    helper classes. In modern practices, views can be connected to models directly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是最终用户可见的内容。与此用户和公众相关的所有数据都显示在视图中，因此视图可以被称为模型的视觉表示。视图需要数据来显示。它向控制器请求一些特定的数据或操作。视图不知道或不想知道控制器从何处获取这些数据；它只是要求控制器获取它。控制器知道要向谁请求这些特定的数据，并与特定的模型进行通信。这意味着视图没有直接连接到模型。然而，在早期的图表中，我们直接将模型与视图连接起来。这是因为在现今的先进系统中，视图可以直接从模型获取数据。例如，Magento控制器无法将数据发送回视图。对于数据（即直接从数据库获取数据）和/或与模型通信，视图与块和辅助类进行通信。在现代实践中，视图可以直接连接到模型。
- en: Controllers
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: Controllers respond to actions performed by a user in the views and respond
    to the view. For example, a user fills a form and submits it. Here, the controller
    comes in the middle and starts taking action on the submission of the form. Now,
    the controller will first check whether the user is allowed to make this request
    or not. Then, the controller will take the appropriate action, such as communicating
    with the model or any other operation. In a simple analogy, the controller is
    the middle man between views and models. As we mentioned before in the models
    section, controllers should be slim. So, mostly, controllers are only used to
    handle the requests and communicate with models and views. All kinds of data operations
    are performed in models.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器响应用户在视图中执行的操作，并响应视图。例如，用户填写表单并提交。在这里，控制器介入并开始对表单的提交采取行动。现在，控制器将首先检查用户是否被允许发出此请求。然后，控制器将采取适当的行动，例如与模型或任何其他操作进行通信。简单地说，控制器是视图和模型之间的中间人。正如我们之前在模型部分提到的，控制器应该是精简的。因此，大多数情况下，控制器仅用于处理请求并与模型和视图进行通信。所有类型的数据操作都在模型中执行。
- en: The MVC design pattern's sole job is to separate the responsibilities of different
    parts in an application. So, models are used to manage the application data. Controllers
    are used to take actions on user inputs, and views are responsible for the visual
    representation of data. As we mentioned before, MVC separates the responsibilities
    of each part, so it does not matter whether it accesses the model from controllers
    or views; the only thing that matters is that views and controllers should not
    be used to perform operations on data, as it is the model's responsibility, and
    controllers should not be used to view any kind of data by the end user as this
    is the view's responsibility.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: MVC设计模式的唯一工作是分离应用程序中不同部分的责任。因此，模型用于管理应用程序数据。控制器用于对用户输入进行操作，视图负责数据的视觉表示。正如我们之前提到的，MVC分离了每个部分的责任，因此无论是从控制器还是视图访问模型都无关紧要；唯一重要的是视图和控制器不应该用于对数据执行操作，因为这是模型的责任，控制器也不应该用于查看任何类型的数据，因为这是视图的责任。
- en: Laravel
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Laravel
- en: Laravel is one of the most popular PHP frameworks, and according to the Laravel
    official website, it is a framework for Web Artisans. Laravel is beautiful, powerful,
    and has tons of features that can enable developers to write efficient and quality
    code. The Laravel official documentation is well written and very easy to understand.
    So, let's play a little with Laravel.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel是最流行的PHP框架之一，根据Laravel官方网站的说法，它是一个面向Web工匠的框架。Laravel美观、强大，并且拥有大量功能，可以让开发人员编写高效和高质量的代码。Laravel官方文档写得很好，非常容易理解。所以，让我们来玩一下Laravel吧。
- en: Installation
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'Installation is very easy and simple. Let''s use Composer to install Laravel.
    We discussed Composer in Appendix A. Issue the following command in the terminal
    to install and create a project in Laravel:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 安装非常简单。让我们使用Composer来安装Laravel。我们在附录A中讨论了Composer。在终端中输入以下命令来安装并创建一个Laravel项目：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If Composer is not installed globally on the system, place `composer.phar`
    in a directory where Laravel should be installed and issue the following command
    in the terminal at the root of this directory:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统上没有全局安装Composer，将`composer.phar`放在应该安装Laravel的目录中，并在该目录的根目录下在终端中输入以下命令：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, Laravel will be downloaded, and a new project with the name `packt` will
    be created. Also, Composer will download and install all the dependencies for
    the project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Laravel将被下载，并将创建一个名为`packt`的新项目。此外，Composer将下载并安装项目的所有依赖项。
- en: Open the browser and head to the project's URL, and we will be welcomed with
    a nice simple page saying **Laravel 5**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器，转到项目的URL，我们将受到一个简单的页面，上面写着**Laravel 5**。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As of the writing of this book, Laravel 5.2.29 is the latest version available.
    However, if Composer is used, then every time the `composer update` command is
    used, Laravel and all other components will be automatically updated.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 截至撰写本书时，Laravel 5.2.29是最新版本。但是，如果使用Composer，则每次使用`composer update`命令时，Laravel和所有其他组件都将自动更新。
- en: Features
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能
- en: Laravel provides tons of features, and we will only discuss a few here.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel提供了大量的功能，我们在这里只讨论一些。
- en: Routing
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由
- en: 'Laravel provides powerful routing. Routes can be grouped, and prefixes, namespaces,
    and middleware can be defined for route groups. Also, Laravel supports all HTTP
    methods, including `POST`, `GET`, `DELETE`, `PUT`, `OPTIONS`, and `PATCH`. All
    the routes are defined in the `routes.php` file in the application''s `app` folder.
    Take a look at the following example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel提供了强大的路由。路由可以分组，并且可以为路由组定义前缀、命名空间和中间件。此外，Laravel支持所有HTTP方法，包括`POST`、`GET`、`DELETE`、`PUT`、`OPTIONS`和`PATCH`。所有路由都在应用程序的`app`文件夹中的`routes.php`文件中定义。看一下以下示例：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding snippet, we created a new routes group. This will be only
    used when the URL has a prefixed customer. For example, if a URL is similar to
    `domain.com/customer`, this group will be used. We also used a customer namespace.
    Namespacing allows us to use standard PHP namespaces and divide our files in subfolders.
    In the preceding example, all customer controllers can be placed in the Customer
    subfolder in the `Controllers` directory, and the controller will be created as
    follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们创建了一个新的路由组。只有当URL有一个前缀为customer时才会使用这个组。例如，如果URL类似于`domain.com/customer`，则将使用此组。我们还使用了一个customer命名空间。命名空间允许我们使用标准的PHP命名空间并将文件分割成子文件夹。在上面的示例中，所有customer控制器可以放在`Controllers`目录中的Customer子文件夹中，并且控制器将如下创建：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, namespacing a route group enables us to place our controller files in subfolders,
    which are easy to manage. Also, we used the web middleware. Middleware provides
    a way to filter the request before entering the application, which enables us
    to use it to check whether a user is logged in or not, the CSRF protection, or
    whether there are any other actions that can be performed in a middleware and
    need to be performed before the request is sent to application. Laravel comes
    with a few middleware, including `web`, `api`, `auth`, and so on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对路由组进行命名空间使我们能够将控制器文件放在易于管理的子文件夹中。此外，我们使用了web中间件。中间件提供了一种在进入应用程序之前过滤请求的方法，这使我们可以使用它来检查用户是否已登录，CSRF保护，或者是否有任何其他需要在请求发送到应用程序之前执行的中间件操作。Laravel带有一些中间件，包括`web`、`api`、`auth`等。
- en: 'If a route is defined as `GET`, no `POST` request can be sent to this route.
    It is very convenient, which enables us to not worry about the request method
    filtering. However, HTML forms do not support the HTTP methods like `DELETE`,
    `PATCH`, and `PUT`. For this, Laravel provides method spoofing, in which a hidden
    form field with `name _method` and the value of the HTTP method is used to make
    this request possible. For example, in our routes group, to make the request possible
    to delete a route, we need a form similar to the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路由定义为`GET`，则不能向该路由发送`POST`请求。这非常方便，使我们不必担心请求方法过滤。但是，HTML表单不支持`DELETE`、`PATCH`和`PUT`等HTTP方法。为此，Laravel提供了方法欺骗，其中使用带有`name
    _method`和HTTP方法值的隐藏表单字段，以使此请求成为可能。例如，在我们的路由组中，为了使删除路由的请求成为可能，我们需要一个类似于以下的表单：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When the preceding form is submitted, it will work, and the delete route will
    be used. Also, we created a CSRF hidden field, which is used for CSRF protection.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当提交上述表单时，它将起作用，并且将使用删除路由。此外，我们创建了一个CSRF隐藏字段，用于CSRF保护。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Laravel routing is very interesting, and it is a big topic. More in-depth detail
    can be found at [https://laravel.com/docs/5.2/routing](https://laravel.com/docs/5.2/routing).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel路由非常有趣，是一个大的话题。更深入的细节可以在[https://laravel.com/docs/5.2/routing](https://laravel.com/docs/5.2/routing)找到。
- en: Eloquent ORM
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eloquent ORM
- en: 'Eloquent ORM provides active records to interact with the database. To use
    Eloquent ORM, we have to just extend our models from the Eloquent model. Let''s
    have a look at a simple user model, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent ORM提供了与数据库交互的活动记录。要使用Eloquent ORM，我们只需从Eloquent模型扩展我们的模型。让我们看一个简单的用户模型，如下所示：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That''s it; we have a model that can handle all the CRUD operations now. Note
    that we commented the `$table property` and did the same for `$primaryKey`. This
    is because Laravel uses a plural name of the class to look for the table unless
    the table is defined with the protected `$table property`. In our case, Laravel
    will look for table name users and use it. However, if we want to use a table
    named `customers`, we can just uncomment the line, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；我们现在有一个可以处理所有CRUD操作的模型。请注意，我们已经注释了`$table属性`，并对`$primaryKey`做了相同的操作。这是因为Laravel使用类的复数名称来查找表，除非表是使用受保护的`$table属性`定义的。在我们的情况下，Laravel将查找表名users并使用它。但是，如果我们想使用名为`customers`的表，我们只需取消注释该行，如下所示：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Similarly, Laravel thinks that a table will have a primary key with the column
    name `id`. However, if another column is needed, we can override the default primary
    key, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Laravel认为表将具有列名`id`的主键。但是，如果需要另一列，我们可以覆盖默认的主键，如下所示：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Eloquent models also make it easy for timestamps. By default, if the table
    has the `created_at` and `updated_at` fields, then these two dates will be generated
    automatically and saved. If no timestamps are required, these can be disabled,
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 优雅的模型也使时间戳变得容易。默认情况下，如果表具有`created_at`和`updated_at`字段，则这两个日期将自动生成并保存。如果不需要时间戳，可以禁用如下：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Saving data to the table is easy. The table columns are used as properties
    of the models, so if our `customer` table has columns such as `name`, `email`,
    `phone`, and so on, we can set them as follows in our `customer` controller, mentioned
    in the routing section:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据保存到表中很容易。表列被用作模型的属性，因此，如果我们的`customer`表具有诸如`name`、`email`、`phone`等列，我们可以在路由部分提到的`customer`控制器中设置它们，如下所示：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, we added the `save` action to our controller. Now,
    if a `POST` or `GET` request is made along the form data, Laravel assigns all
    the form-submitted data to a Request object as properties with the same names
    as that of the form fields. Then, using this request object, we can access all
    the data submitted by the form either using `POST` or `GET`. After assigning all
    the data to model properties (the same names as those of table columns), we can
    just call the save method. Now, our model does not have any save method, but its
    parent class, which is the Eloquent model, has this method defined. However, we
    can override this `save` method in our `model` class in case we need some other
    features in this method.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们向我们的控制器添加了`save`操作。现在，如果提交了`POST`或`GET`请求以及表单数据，Laravel将所有表单提交的数据分配给一个Request对象，作为与表单字段相同名称的属性。然后，使用此请求对象，我们可以访问通过`POST`或`GET`提交的所有数据。在将所有数据分配给模型属性（与表列的名称相同）之后，我们只需调用save方法。现在，我们的模型没有任何保存方法，但是其父类，即Eloquent模型，已经定义了此方法。但是，如果需要此方法中的其他功能，我们可以在我们的`model`类中覆盖此`save`方法。
- en: 'Fetching data from the Eloquent model is also easy. Let''s try an example.
    Add a new action to the `customer` controller, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从Eloquent模型中获取数据也很容易。让我们尝试一个例子。向`customer`控制器添加一个新操作，如下所示：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We used the `all()` static method in the model, which is basically defined
    in the Eloquent model, which, in turn, fetches all the data in our `customers`
    table. Now, if we want to get a single customer by the primary key, we can use
    the `find($id)` method, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模型中使用了`all()`静态方法，它基本上是在Eloquent模型中定义的，反过来获取了我们的`customers`表中的所有数据。现在，如果我们想要通过主键获取单个客户，我们可以使用`find($id)`方法，如下所示：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will fetch the customer with the ID `3`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取ID为`3`的客户。
- en: 'Updating is simple, and the same `save()` method is used, as shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 更新很简单，使用相同的`save()`方法，如下所示：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will update the customer with the ID `3`. First, we loaded the `customer`,
    then we assigned new data to its properties, and then we called the same `save()`
    method. Deleting the model is simple and easy and can be done as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更新ID为`3`的客户。首先，我们加载了`customer`，然后我们为其属性分配了新数据，然后调用了相同的`save()`方法。删除模型简单易行，可以按如下方式完成：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We first loaded the customer with the ID `3`, and then we called the `delete`
    method, which will delete the customer with the ID `3`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先加载了ID为`3`的客户，然后调用了`delete`方法，这将删除ID为`3`的客户。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Laravel's Eloquent models are very powerful and provide lots of features. These
    are well explained in the documentation at [https://laravel.com/docs/5.2/eloquent](https://laravel.com/docs/5.2/eloquent).
    The Laravel database section is also worth reading and can be found at [https://laravel.com/docs/5.2/database](https://laravel.com/docs/5.2/database).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel的Eloquent模型非常强大，并提供了许多功能。这些在文档中有很好的解释，网址为[https://laravel.com/docs/5.2/eloquent](https://laravel.com/docs/5.2/eloquent)。Laravel数据库部分也值得阅读，网址为[https://laravel.com/docs/5.2/database](https://laravel.com/docs/5.2/database)。
- en: Artisan CLI
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Artisan CLI
- en: 'Artisan is the command-line interface provided with Laravel, and it has some
    nice commands that can be used for quicker operations. It has lots of commands,
    and a full list can be seen using the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Artisan是Laravel提供的命令行界面，它有一些很好的命令可以用于更快的操作。它有很多命令，可以使用以下命令查看完整列表：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will list all the options and commands available.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出所有可用的选项和命令。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `php artisan` command should be run in the same directory in which the `artisan`
    file is located. It is placed at the root of the project.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`php artisan`命令应该在`artisan`文件所在的同一目录中运行。它被放置在项目的根目录下。'
- en: 'Some of the basic commands are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一些基本命令如下：
- en: '`make:controller`: This command creates a new controller in the `Controllers`
    folder. The command can be used as follows:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make:controller`: 这个命令在`Controllers`文件夹中创建一个新的控制器。可以如下使用：'
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If a namespaced controller is required, as it happened before with the `Customer`
    namespace, it can be done as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要一个有命名空间的控制器，就像之前的`Customer`命名空间一样，可以如下操作：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This command will create `CustomerController` in the `Customer` folder. If the
    `Customer` folder is not available, it will create the folder as well.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将在`Customer`文件夹中创建`CustomerController`。如果`Customer`文件夹不存在，它也将创建该文件夹。
- en: '`make:model`: This creates a new model in the `app` folder. The syntax is the
    same as the `make:controller` command, as follows:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make:model`: 这在`app`文件夹中创建一个新的模型。语法与`make:controller`命令相同，如下：'
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For the namespaced models, it can be used as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有命名空间的模型，可以如下使用：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will create the `Customer` model in the `Customer` folder and use the `Customer`
    namespace for it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`Customer`文件夹中创建`Customer`模型，并为其使用`Customer`命名空间。
- en: '`make:event`: This creates a new `event` class in the `Events` folder. It can
    be used as follows:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make:event`: 这在`Events`文件夹中创建一个新的`event`类。可以如下使用：'
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`make:listener`: This command creates a new listener for an event. This can
    be used as follows:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make:listener`: 这个命令为事件创建一个新的监听器。可以如下使用：'
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding command will create a new listener for our `MyEvent` event. We
    have to always mention the event for which we need to create a listener using
    the `--event` option.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将为我们的`MyEvent`事件创建一个新的监听器。我们必须始终使用`--event`选项提及我们需要创建监听器的事件。
- en: '`make:migration`: This command creates a new migration in the database/migrations
    folder.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make:migration`: 这个命令在database/migrations文件夹中创建一个新的迁移。'
- en: '`php artisan migrate`: This runs all the available migrations that are not
    executed.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`php artisan migrate`: 这将运行所有尚未执行的可用迁移。'
- en: '`php artisan optimize`: This command optimizes the framework for better performance.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`php artisan optimize`: 这个命令优化框架以获得更好的性能。'
- en: '`php artisan down`: This puts the application in maintenance mode.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`php artisan down`: 这将把应用程序置于维护模式。'
- en: '`php artisan up`: This command brings the application back live from the maintenance
    mode.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`php artisan up`: 这个命令将应用程序从维护模式中恢复。'
- en: '`php artisan cache:clear`: This command clears the application cache.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`php artisan cache:clear`: 这个命令清除应用程序缓存。'
- en: '`php artisan db:seed`: This command seeds the database with records.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`php artisan db:seed`: 这个命令用记录填充数据库。'
- en: '`php artisan view:clear`: This clears all the compiled view files.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`php artisan view:clear`: 这将清除所有已编译的视图文件。'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More detail about the Artisan console or Artisan CLI can be found in the documentation
    at [https://laravel.com/docs/5.2/homestead](https://laravel.com/docs/5.2/homestead).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Artisan控制台或Artisan CLI的更多详细信息可以在文档中找到，网址为[https://laravel.com/docs/5.2/homestead](https://laravel.com/docs/5.2/homestead)。
- en: Migrations
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移
- en: 'Migrations is another powerful feature in Laravel. In migrations, we define
    the database schemas—whether it creates tables, removes tables, or adds/updates
    columns in the tables. Migrations are very convenient in deployment and act as
    version control for the database. Let''s create a migration for our customer table
    that is not available in the database yet. To create a migration, issue the following
    command in the terminal:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移是Laravel中的另一个强大功能。在迁移中，我们定义数据库模式——它是创建表、删除表或在表中添加/更新列。迁移在部署中非常方便，并且作为数据库的版本控制。让我们为我们的数据库中尚不存在的customer表创建一个迁移。要创建一个迁移，在终端中发出以下命令：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A new file in the `database/migrations` folder will be created with the filename
    `create_customer_table` prefixed with the current date and a unique ID. The class
    is created as `CreateCustomerTable`. This is a class as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`database/migrations`文件夹中将创建一个新文件，文件名为当前日期和唯一ID前缀的`create_customer_table`。类被创建为`CreateCustomerTable`。这是一个如下的类：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The class will have two public methods: `up()` and `down()`. The `up()` method
    should have all the new schemas for the table(s). The `down()` method is responsible
    for reversing the executed migration. Now, lets add the `customers` table schema
    to the `up()` method, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类将有两个公共方法：`up()`和`down()`。`up()`方法应该包含表的所有新模式。`down()`方法负责撤销已执行的迁移。现在，让我们将`customers`表模式添加到`up()`方法中，如下：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the `up()` method, we defined the schema and table name. Columns for the
    table are individually defined, including the column size. The `increments()`
    method defines the autoincrement column, which, in our case, is the `id` column.
    Next, we created three string columns for `name`, `email`, and `phone`. Then,
    we used the `timestamps()` method, which creates the `created_at` and `updated_at`
    timestamp columns. In the `down()` method, we just used the `drop()` method of
    the `Schema` class to drop out the `customers` table. Now, we need to run our
    migrations using the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`up()`方法中，我们定义了模式和表名。表的列是单独定义的，包括列大小。`increments()`方法定义了自动增量列，在我们的例子中是`id`列。接下来，我们为`name`、`email`和`phone`创建了三个字符串列。然后，我们使用了`timestamps()`方法，它创建了`created_at`和`updated_at`时间戳列。在`down()`方法中，我们只是使用了`Schema`类的`drop()`方法来删除`customers`表。现在，我们需要使用以下命令运行我们的迁移：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding command will not only run our migration but will also run all
    those migrations that are not executed yet. When a migration is executed, Laravel
    stores the migration name in a table called `migrations`, from where Laravel decides
    which migrations it has to execute and which to skip.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令不仅会运行我们的迁移，还会运行尚未执行的所有迁移。当执行迁移时，Laravel会将迁移名称存储在一个名为`migrations`的表中，从中决定要执行哪些迁移以及要跳过哪些迁移。
- en: 'Now, if we need to roll back the latest executed migration, we can use the
    following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们需要回滚最近执行的迁移，我们可以使用以下命令：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will roll back to the last batch of migrations. To roll back all the migrations
    of the application, we can use the reset command, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将回滚到最后一批迁移。要回滚应用程序的所有迁移，我们可以使用reset命令，如下所示：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will roll back the complete application migrations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将回滚完整的应用程序迁移。
- en: Migrations make it easy for deployment because we won't need to upload the database
    schemas every time we create some new changes in the tables or database. We will
    just create the migrations and upload all the files, and after this, we will just
    execute the migration command, and all the schemas will be updated.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移使部署变得容易，因为我们不需要每次在表或数据库中创建一些新的更改时上传数据库模式。我们只需创建迁移并上传所有文件，之后我们只需执行迁移命令，所有模式将被更新。
- en: Blade templates
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blade模板
- en: 'Laravel comes with its own template language called Blade. Also, Blade template
    files support plain PHP code. Blade template files are compiled to plain PHP files
    and are cached until they are changed. Blade also supports layouts. For example,
    the following is our master page layout in Blade, placed in the `resources/views/layout`
    folder with the name `master.blade.php`. Take a look at the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel自带了自己的模板语言Blade。此外，Blade模板文件支持普通的PHP代码。Blade模板文件被编译为普通的PHP文件，并在更改之前被缓存。Blade还支持布局。例如，以下是我们在Blade中的主页面布局，放在`resources/views/layout`文件夹中，名为`master.blade.php`。看一下以下代码：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding example, we had a section for the sidebar that defines a `content`
    section. Also, we had `@yield`, which displays the contents of a section. Now,
    if we want to use this layout, we will need to extend it in the child template
    files. Let''s create the `customers.blade.php` file in the `resources/views/`
    folder and place the following code in it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们有一个定义`content`部分的侧边栏。此外，我们有`@yield`，它显示部分的内容。现在，如果我们想要使用这个布局，我们需要在子模板文件中扩展它。让我们在`resources/views/`文件夹中创建`customers.blade.php`文件，并将以下代码放入其中：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As can be seen in the preceding code, we extended the `master` layout and then
    placed contents in every section of the `master` layout. Also, it is possible
    to include different templates in another template. For example, let''s have two
    files, `sidebar.blade.php` and `menu.blade.php`, in the `resources/views/includes`
    folder. Then, we can include these files in any template, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们扩展了`master`布局，然后在`master`布局的每个部分放置了内容。此外，还可以在另一个模板中包含不同的模板。例如，让我们在`resources/views/includes`文件夹中有两个文件，`sidebar.blade.php`和`menu.blade.php`。然后，我们可以在任何模板中包含这些文件，如下所示：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We used `@include` to include a template. The dot (`.`) indicates a folder
    separation. We can easily send data to Blade templates or views from our controllers
    or routers. We have to just pass the data as an array to a view, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@include`来包含一个模板。点(`.`)表示文件夹分隔。我们可以轻松地从我们的控制器或路由器向Blade模板或视图发送数据。我们只需将数据作为数组传递给视图，如下所示：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, `count` is available in our `customers` view file and can be accessed
    as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的`customers`视图文件中可以访问`count`，如下所示：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Yes, Blade uses double curly braces to echo a variable. For control structures
    and loops, let''s have another example. Let''s send data to the `customers` view,
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，Blade使用双花括号来输出变量。对于控制结构和循环，让我们举一个例子。让我们向`customers`视图发送数据，如下所示：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, our `customers` view file will be similar to the following if we want
    to display all the `customers` data:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要显示所有`customers`数据，我们的`customers`视图文件将类似于以下内容：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: All the preceding syntax looks familiar as it is almost the same as plain PHP.
    However, to display a variable, we have to use double curly braces `{{}}`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述语法看起来很熟悉，因为它几乎与普通的PHP相同。但是，要显示一个变量，我们必须使用双花括号`{{}}`。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A nice and easy-to-read documentation for Blade templates can be found at [https://laravel.com/docs/5.2/blade](https://laravel.com/docs/5.2/blade).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://laravel.com/docs/5.2/blade](https://laravel.com/docs/5.2/blade)找到一个易于阅读的Blade模板文档。
- en: Other features
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他特性
- en: We only discussed a few basic features in the previous section. Laravel has
    tons of other features, such as Authentication and Authorization, which provide
    an easy way to authenticate and authorize users. Also, Laravel provides a powerful
    caching system, which supports file-based cache, the Memcached, and Redis cache.
    Laravel also provides events and listeners for these events, which is very convenient
    when we want to perform a specific action and when a specific event occurs. Laravel
    supports localization, which enables us to use localized contents and multiple
    languages. Laravel also supports task scheduling and queues, in which we schedule
    some tasks to run at a specific time and queue some tasks to be run when their
    turn arrives.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们只讨论了一些基本功能。Laravel还有许多其他功能，例如身份验证和授权，提供了一种简单的方式来对用户进行身份验证和授权。此外，Laravel提供了强大的缓存系统，支持基于文件的缓存、Memcached和Redis缓存。Laravel还为这些事件提供了事件和监听器，当我们想执行特定操作时以及特定事件发生时，这是非常方便的。Laravel支持本地化，可以使用本地化内容和多种语言。Laravel还支持任务调度和队列，我们可以在特定时间安排一些任务运行，并在轮到它们时排队运行一些任务。
- en: Lumen
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lumen
- en: 'Lumen is a micro-framework provided by Laravel. Lumen is mainly intended to
    create stateless APIs and has a minimal set of features of Laravel. Also, Lumen
    is compatible with Laravel, which means that if we just copy our Lumen application
    to Laravel, it will work fine. The installation is simple. Just use the following
    Composer command to create a Lumen project, and it will download all the dependencies,
    including Lumen:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen是由Laravel提供的微框架。Lumen主要用于创建无状态API，并具有Laravel的最小功能集。此外，Lumen与Laravel兼容，这意味着如果我们只是将我们的Lumen应用程序复制到Laravel中，它将正常工作。安装很简单。只需使用以下Composer命令创建一个Lumen项目，它将下载包括Lumen在内的所有依赖项：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding command will download Lumen and then create our API application.
    After this, rename `.env.example` as `.env`. Also, create a 32-characters-long
    app key and place it in the `.env` file. Now, the basic application is ready to
    use and create APIs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将下载Lumen，然后创建我们的API应用程序。完成后，将`.env.example`重命名为`.env`。还要创建一个32个字符长的应用程序密钥，并将其放入`.env`文件中。现在，基本应用程序已准备好使用和创建API。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Lumen is almost the same as Laravel, but some Laravel features are not included
    by default. More details can be found at [https://lumen.laravel.com/docs/5.2](https://lumen.laravel.com/docs/5.2).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen与Laravel几乎相同，但默认情况下不包括一些Laravel功能。更多细节可以在[https://lumen.laravel.com/docs/5.2](https://lumen.laravel.com/docs/5.2)找到。
- en: Apigility
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apigility
- en: 'Apigility is built and developed by Zend in Zend Framework 2\. Apigility provides
    an easy to use GUI to create and manage APIs. It is very easy to use and is capable
    of creating complex APIs. Let''s start by installing Apigility using Composer.
    Issue the following command in the terminal:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Apigility是由Zend在Zend Framework 2中构建和开发的。Apigility提供了一个易于使用的GUI来创建和管理API。它非常易于使用，并能够创建复杂的API。让我们从使用Composer安装Apigility开始。在终端中输入以下命令：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding command will download Apigility and its dependencies, including
    Zend Framework 2, and will set up our project named `packt`. Now, issue the following
    command to enable the development mode so that we can have access to the GUI:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将下载Apigility及其依赖项，包括Zend Framework 2，并将设置我们的名为`packt`的项目。现在，发出以下命令以启用开发模式，以便我们可以访问GUI：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, open the URL as [yourdomain.com/packt/public](http://yourdomain.com/packt/public),
    and we will see a beautiful GUI, as shown in the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开URL [yourdomain.com/packt/public](http://yourdomain.com/packt/public)，我们将看到一个漂亮的GUI，如下面的屏幕截图所示：
- en: '![Apigility](graphics/B05225_AppendixB_02.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Apigility](graphics/B05225_AppendixB_02.jpg)'
- en: 'Now, let''s create our first API. We will call this API "`books`", which will
    return a list of books. Click on the **New API** button, as shown in the preceding
    picture, and a popup will be displayed. In the text box, enter `books` as the
    API name and click on `Create` button; the new API will be created. When the API
    is created, we will be presented with the following screen:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的第一个API。我们将称此API为“`books`”，它将返回一本书的列表。单击前面图片中显示的**New API**按钮，将显示一个弹出窗口。在文本框中输入`books`作为API名称，然后单击`Create`按钮；新API将被创建。创建API后，我们将看到以下屏幕：
- en: '![Apigility](graphics/B05225_AppendixB_03.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Apigility](graphics/B05225_AppendixB_03.jpg)'
- en: 'Apigility provides easy ways to set other properties for the API, such as versioning
    and authentication. Now, let''s create an RPC service by clicking on the **New
    Service** button in the left sidebar. Also, we can click on the **Create a new
    one** link in the **RPC** section in the preceding screenshot. We will be presented
    with the following screen:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Apigility提供了设置API的其他属性的简单方法，例如版本控制和身份验证。现在，通过单击左侧边栏中的**New Service**按钮来创建一个RPC服务。此外，我们可以在前面的屏幕截图中的**RPC**部分单击**Create
    a new one**链接。我们将看到以下屏幕：
- en: '![Apigility](graphics/B05225_AppendixB_04.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![Apigility](graphics/B05225_AppendixB_04.jpg)'
- en: 'As shown in the preceding screenshot, we created an RPC service named `get`
    in the `books` API. The route URI entered is `/books/get`, which will be used
    to call this RPC service. When we click on the `Create service` button, the API
    creation successful message will be displayed, and also, the following screen
    will be displayed:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们在`books`API中创建了一个名为`get`的RPC服务。输入的路由URI是`/books/get`，将用于调用此RPC服务。当我们单击`Create
    service`按钮时，将显示API创建成功的消息，并且还将显示以下屏幕：
- en: '![Apigility](graphics/B05225_AppendixB_05.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![Apigility](graphics/B05225_AppendixB_05.jpg)'
- en: As can be seen in the preceding screenshot, the allowed HTTP method for this
    service is only **GET**. Let's keep this as it is, but we can select all or any
    of them. Also, we want to keep **Content Negotiation Selector** as `Json`, and
    our service will accept/receive all the content in the JSON format. Also, we can
    select different media types and content types.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，此服务的允许HTTP方法仅为**GET**。让我们保持原样，但我们可以选择全部或任何一个。此外，我们希望将**内容协商选择器**保持为`Json`，并且我们的服务将以JSON格式接受/接收所有内容。此外，我们可以选择不同的媒体类型和内容类型。
- en: 'Next, we should add some fields to our service that will be used. Click on
    the **Fields** tab, and we will see the **Fields** screen. Click on the **New
    Field** button, and we will be presented with the following popup:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该为我们的服务添加一些将要使用的字段。点击**字段**选项卡，我们将看到**字段**屏幕。点击**新建字段**按钮，我们将看到以下弹出窗口：
- en: '![Apigility](graphics/B05225_AppendixB_06.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![Apigility](graphics/B05225_AppendixB_06.jpg)'
- en: 'As can be seen in the preceding screenshot, we can set all the properties for
    a field, such as the **Name**, **Description**, whether it is required or not,
    and some other settings, including an error message if the validation fails. After
    we created two fields, **title** and **author**, we will have a screen similar
    to the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们可以为字段设置所有属性，如**名称**、**描述**、是否必填等，以及一些其他设置，包括验证失败时的错误消息。在创建了两个字段**title**和**author**之后，我们将看到类似以下的屏幕：
- en: '![Apigility](graphics/B05225_AppendixB_07.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![Apigility](graphics/B05225_AppendixB_07.jpg)'
- en: As can be seen in the preceding screen, we can add validators and filters to
    each individual field too.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕所示，我们也可以为每个单独的字段添加验证器和过滤器。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As this is just an introductory topic for Apigility, we will not cover validators
    and filters and some other topics in this book.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这只是Apigility的入门主题，我们将不会在本书中涵盖验证器、过滤器和其他一些主题。
- en: 'The next topic is documentation. When we click on the **Documentation** tab,
    we will see the following screen:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题是文档。当我们点击**文档**选项卡时，我们将看到以下屏幕：
- en: '![Apigility](graphics/B05225_AppendixB_08.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![Apigility](graphics/B05225_AppendixB_08.jpg)'
- en: Here, we will document our service, add some description, and also can generate
    the response body for documentation purposes. This is very important as it will
    enable others to better understand our APIs and services.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将记录我们的服务，添加一些描述，还可以为文档目的生成响应主体。这非常重要，因为它将使其他人更好地理解我们的API和服务。
- en: 'Now, we need to get the all the books from somewhere. It can be either from
    the database or from another service or any other source. However, for now, we
    will just use an array of books for test purposes. If we click on the **Source**
    tab, we will find that our code for the service is placed at `module/books/src/books/V1/Rpc/Get/GetController.php`.
    Apigility created a module for our API `books` and then placed all the source
    code in this module in different folders according to the version of our API,
    which is V1 by default. We can add more versions, such as V2 and V3, to our APIs.
    Now, if we open the `GetController` file, we will find some code and an action
    called `getAction` according to our route URI. The code is as follows, and the
    highlighted code is the one we added:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要从某个地方获取所有的书。可以是从数据库中获取，也可以是从另一个服务或其他来源获取。然而，现在，我们只是为了测试目的，将使用一组书的数组。如果我们点击**来源**选项卡，我们会发现我们服务的代码放在`module/books/src/books/V1/Rpc/Get/GetController.php`中。Apigility为我们的API`books`创建了一个模块，然后根据API的版本（默认为V1），将所有源代码放在这个模块的不同文件夹中。我们可以为我们的API添加更多版本，如V2和V3。现在，如果我们打开`GetController`文件，我们会发现一些代码和一个根据我们的路由URI命名为`getAction`的操作。代码如下，高亮显示的是我们添加的代码：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code, we used `ContentNegotiation\ViewModel`, which is responsible
    for responding with the data in the format that we selected in the service setup,
    which is JSON in our case. Then, we created a simple `$books` array with the fieldnames
    we created for the service and assigned our values to them. Then, we returned
    them using the `ViewModel` object, which handles the response data conversion
    to JSON.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们使用了`ContentNegotiation\ViewModel`，它负责以我们在服务设置中选择的格式（在我们的情况下是JSON）响应数据。然后，我们创建了一个简单的`$books`数组，其中包含我们为服务创建的字段名，并为它们分配了值。然后，我们使用`ViewModel`对象返回它们，该对象处理响应数据转换为JSON。
- en: 'Now, let''s test our API. As our service can accept `GET` requests, we will
    just type our URL in the browser with the `books/get` URI, and we will see the
    JSON response. It is best to check the API with tools such as RestClient or Postman
    for Google Chrome, which provides an easy-to-use interface to make different types
    of requests to APIs. We tested it with Postman and got the response shown in the
    following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试我们的API。由于我们的服务可以接受`GET`请求，我们只需在浏览器中输入带有`books/get` URI的URL，就会看到JSON响应。最好使用RestClient或Google
    Chrome的Postman等工具来检查API，这些工具提供了一个易于使用的界面，可以向API发出不同类型的请求。我们使用Postman进行了测试，并得到了以下截图中显示的响应：
- en: '![Apigility](graphics/B05225_AppendixB_09.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![Apigility](graphics/B05225_AppendixB_09.jpg)'
- en: Also note that we set our service to accept only `GET` requests. So, if we send
    a request other than `GET`, we will get an `HTTP Status code 405 methods not allowed`
    error.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们将我们的服务设置为仅接受`GET`请求。因此，如果我们发送的请求不是`GET`，我们将收到`HTTP状态码405方法不允许`的错误。
- en: Apigility is very powerful and provides tons of features, such as RESTFul APIs,
    HTTP authentication, database connected services with easy-to-create DB connectors,
    and a selection of tables for a service. While using Apigility, we need not worry
    about the API, service structure security, and other things, as Apigility does
    this for us. We need to only concentrate on the business logic of the APIs and
    services.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Apigility非常强大，提供了许多功能，如RESTFul API、HTTP身份验证、与易于创建的数据库连接器连接的数据库服务，以及服务的表格选择。在使用Apigility时，我们不需要担心API、服务结构安全性和其他事情，因为Apigility会为我们处理这些。我们只需要专注于API和服务的业务逻辑。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Apigility can't be covered completely in this Appendix. Apigility has lots of
    features that can be covered in a complete book. Apigility's official documentation
    at [https://apigility.org/documentation](https://apigility.org/documentation)
    is a good place to get started and read more about this.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Apigility无法在本附录中完全涵盖。Apigility有很多功能，可以在一本完整的书中进行介绍。Apigility的官方文档网址[https://apigility.org/documentation](https://apigility.org/documentation)是一个很好的起点，可以了解更多信息。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this Appendix, we discussed the basics of the MVC design pattern. We also
    discussed the Laravel framework and some of its good features. We introduced you
    to the Laravel-based micro-framework, Lumen. At the end, we had a small introduction
    to Apigility and created a test API and web service.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们讨论了MVC设计模式的基础知识。我们还讨论了Laravel框架及其一些优秀特性。我们向你介绍了基于Laravel的微框架Lumen。最后，我们对Apigility进行了简要介绍，并创建了一个测试API和Web服务。
- en: In IT, things get obsolete in a very short time span. It is always required
    to study upgraded tools and find new ways and techniques for the best approaches
    in programming. Therefore, one should not stop after completing this book and
    start studying new topics and also the topics that are not covered completely
    in this book. Until this point, you will have the knowledge that you can use to
    set up high-performance environments for high-performance applications. We wish
    you good luck and success in PHP-ing!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在IT领域，事物很快就会过时。总是需要学习升级的工具，寻找编程中最佳方法的新途径和技术。因此，完成本书后不应该停止学习，而是开始研究新的主题，以及本书中未完全涵盖的主题。到这一点，你将拥有知识，可以用来建立高性能应用程序的高性能环境。祝你在PHP编程中好运和成功！
