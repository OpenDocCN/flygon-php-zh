["```php\n$graph = []; \n\n$visited = []; \n\n$vertexCount = 6; \n\nfor($i = 1;$i<=$vertexCount;$i++) { \n\n    $graph[$i] = array_fill(1, $vertexCount, 0); \n\n    $visited[$i] = 0; \n\n} \n\n```", "```php\n$graph[1][2] = $graph[2][1] = 1; \n\n$graph[1][5] = $graph[5][1] = 1; \n\n$graph[5][2] = $graph[2][5] = 1; \n\n$graph[5][4] = $graph[4][5] = 1; \n\n$graph[4][3] = $graph[3][4] = 1; \n\n$graph[3][2] = $graph[2][3] = 1; \n\n$graph[6][4] = $graph[4][6] = 1; \n\n```", "```php\nfunction BFS(array &$graph, int $start, array $visited): SplQueue { \n\n    $queue = new SplQueue;\n\n    $path = new SplQueue;\n\n    $queue->enqueue($start);\n\n    $visited[$start] = 1;\n\n    while (!$queue->isEmpty()) { \n\n      $node = $queue->dequeue();\n\n      $path->enqueue($node);\n\n      foreach ($graph[$node] as $key => $vertex) { \n\n          if (!$visited[$key] && $vertex == 1) { \n\n          $visited[$key] = 1;\n\n          $queue->enqueue($key);\n\n          }\n\n      }\n\n    }\n\n    return $path;\n\n}\n\n```", "```php\n$path = BFS($graph, 1, $visited); \n\nwhile (!$path->isEmpty()) { \n\n    echo $path->dequeue().\"\\t\"; \n\n} \n\n```", "```php\n    1       2       5       3       4       6\n\n```", "```php\n    5       1       2       4       3       6\n\n```", "```php\nfunction DFS(array &$graph, int $start, array $visited): SplQueue { \n\n    $stack = new SplStack; \n\n    $path = new SplQueue; \n\n    $stack->push($start); \n\n    $visited[$start] = 1; \n\n    while (!$stack->isEmpty()) { \n\n      $node = $stack->pop(); \n\n      $path->enqueue($node); \n\n      foreach ($graph[$node] as $key => $vertex) { \n\n          if (!$visited[$key] && $vertex == 1) { \n\n          $visited[$key] = 1; \n\n          $stack->push($key); \n\n          } \n\n      } \n\n    } \n\n    return $path; \n\n} \n\n```", "```php\n$path = DFS($graph, 1, $visited); \n\nwhile (!$path->isEmpty()) { \n\n    echo $path->dequeue().\"\\t\"; \n\n} \n\n```", "```php\n    1       5       4       6       3       2\n\n```", "```php\n$graph = [ \n\n    [0, 0, 0, 0, 1], \n\n    [1, 0, 0, 1, 0], \n\n    [0, 1, 0, 1, 0], \n\n    [0, 0, 0, 0, 0], \n\n    [0, 0, 0, 0, 0], \n\n];\n\n```", "```php\nfunction topologicalSort(array $matrix): SplQueue { \n\n    $order = new SplQueue; \n\n    $queue = new SplQueue; \n\n    $size = count($matrix); \n\n    $incoming = array_fill(0, $size, 0); \n\n    for ($i = 0; $i < $size; $i++) { \n\n      for ($j = 0; $j < $size; $j++) { \n\n          if ($matrix[$j][$i]) { \n\n          $incoming[$i] ++; \n\n          } \n\n      } \n\n      if ($incoming[$i] == 0) { \n\n          $queue->enqueue($i); \n\n      } \n\n    } \n\n    while (!$queue->isEmpty()) { \n\n      $node = $queue->dequeue(); \n\n      for ($i = 0; $i < $size; $i++) { \n\n          if ($matrix[$node][$i] == 1) { \n\n            $matrix[$node][$i] = 0; \n\n            $incoming[$i] --; \n\n            if ($incoming[$i] == 0) { \n\n                $queue->enqueue($i); \n\n            } \n\n          } \n\n      } \n\n      $order->enqueue($node); \n\n    } \n\n    if ($order->count() != $size) // cycle detected \n\n      return new SplQueue; \n\n    return $order; \n\n} \n\n```", "```php\n$sorted = topologicalSort($graph);\n\nwhile (!$sorted->isEmpty()) {\n\n    echo $sorted->dequeue() . \"\\t\";\n\n} \n\n```", "```php\n    2       1       0 \n\n      3       4\n\n```", "```php\nfor i:= 1 to n do \n\n  for j:= 1 to n do \n\n     dis[i][j] = w[i][j] \n\nfor k:= 1 to n do \n\n   for i:= 1 to n do \n\n      for j:= 1 to n do \n\n         sum := dis[i][k] + dis[k][j] \n\n         if (sum < dis[i][j]) \n\n              dis[i][j] := sum \n\n```", "```php\n$totalVertices = 5; \n\n$graph = []; \n\nfor ($i = 0; $i < $totalVertices; $i++) { \n\n    for ($j = 0; $j < $totalVertices; $j++) { \n\n      $graph[$i][$j] = $i == $j ? 0 : PHP_INT_MAX; \n\n    }\n\n}\n\n```", "```php\n$graph[0][1] = $graph[1][0] = 10;\n\n$graph[2][1] = $graph[1][2] = 5;\n\n$graph[0][3] = $graph[3][0] = 5;\n\n$graph[3][1] = $graph[1][3] = 5;\n\n$graph[4][1] = $graph[1][4] = 10;\n\n$graph[3][4] = $graph[4][3] = 20;\n\n```", "```php\nfunction floydWarshall(array $graph): array {\n\n    $dist = [];\n\n    $dist = $graph;\n\n    $size = count($dist);\n\n    for ($k = 0; $k < $size; $k++)\n\n      for ($i = 0; $i < $size; $i++)\n\n          for ($j = 0; $j < $size; $j++)\n\n        $dist[$i][$j] = min($dist[$i][$j],\n\n    $dist[$i][$k] + $dist[$k][$j]);\n\n    return $dist;\n\n} \n\n```", "```php\n$distance = floydWarshall($graph); \n\necho \"Shortest distance between A to E is:\" . $distance[0][4] . \"\\n\"; \n\necho \"Shortest distance between D to C is:\" . $distance[3][2] . \"\\n\"; \n\n```", "```php\nShortest distance between A to E is:20\n\nShortest distance between D to C is:10\n\n```", "```php\n   function Dijkstra(Graph, source):\n\n      create vertex set Q\n\n      for each vertex v in Graph:   \n\n          dist[v] := INFINITY\n\n          prev[v] := UNDEFINED          \n\n          add v to Q         \n\n      dist[source] := 0           \n\n      while Q is not empty:\n\n          u := vertex in Q with min dist[u]\n\n          remove u from Q\n\n          for each neighbor v of u:\n\n              alt := dist[u] + length(u, v)\n\n              if alt < dist[v]:   \n\n                  dist[v] := alt\n\n                  prev[v] := u\n\n      return dist[], prev[]\n\n```", "```php\n$graph = [\n\n    'A' => ['B' => 3, 'C' => 5, 'D' => 9],\n\n    'B' => ['A' => 3, 'C' => 3, 'D' => 4, 'E' => 7],\n\n    'C' => ['A' => 5, 'B' => 3, 'D' => 2, 'E' => 6, 'F' => 3],\n\n    'D' => ['A' => 9, 'B' => 4, 'C' => 2, 'E' => 2, 'F' => 2],\n\n    'E' => ['B' => 7, 'C' => 6, 'D' => 2, 'F' => 5],\n\n    'F' => ['C' => 3, 'D' => 2, 'E' => 5],\n\n];\n\n```", "```php\nfunction Dijkstra(array $graph, string $source,string $target):array{ \n\n    $dist = []; \n\n    $pred = []; \n\n    $Queue = new SplPriorityQueue(); \n\n    foreach ($graph as $v => $adj) { \n\n      $dist[$v] = PHP_INT_MAX; \n\n      $pred[$v] = null; \n\n      $Queue->insert($v, min($adj)); \n\n    } \n\n    $dist[$source] = 0; \n\n    while (!$Queue->isEmpty()) { \n\n      $u = $Queue->extract(); \n\n      if (!empty($graph[$u])) { \n\n          foreach ($graph[$u] as $v => $cost) { \n\n           if ($dist[$u] + $cost < $dist[$v]) { \n\n            $dist[$v] = $dist[$u] + $cost; \n\n            $pred[$v] = $u; \n\n        } \n\n          } \n\n      } \n\n    } \n\n    $S = new SplStack();\n\n    $u = $target; \n\n    $distance = 0;\n\n    while (isset($pred[$u]) && $pred[$u]) {\n\n      $S->push($u);\n\n      $distance += $graph[$u][$pred[$u]];\n\n      $u = $pred[$u]; \n\n    } \n\n    if ($S->isEmpty()) { \n\n      return [\"distance\" => 0, \"path\" => $S]; \n\n    } else {\n\n      $S->push($source);\n\n      return [\"distance\" => $distance, \"path\" => $S]; \n\n    }\n\n}\n\n```", "```php\n$source = \"A\"; \n\n$target = \"F\"; \n\n$result = Dijkstra($graph, $source, $target); \n\nextract($result); \n\necho \"Distance from $source to $target is $distance \\n\"; \n\necho \"Path to follow : \"; \n\nwhile (!$path->isEmpty()) { \n\n    echo $path->pop() . \"\\t\"; \n\n} \n\n```", "```php\nDistance from A to F is 8\n\nPath to follow : A      C       F\n\n```", "```php\nfunction BellmanFord(list vertices, list edges, vertex source) \n\n  // This implementation takes a vertex source \n\n  // and fills distance array with shortest-path information \n\n  // Step 1: initialize graph \n\n  for each vertex v in vertices: \n\n    if v is source \n\n      distance[v] := 0 \n\n    else \n\n      distance[v] := infinity \n\n  // Step 2: relax edges repeatedly \n\n  for i from 1 to size(vertices)-1: \n\n    for each edge (u, v) with weight w in edges: \n\n      if distance[u] + w < distance[v]: \n\n        distance[v] := distance[u] + w \n\n  // Step 3: check for negative-weight cycles \n\n    for each edge (u, v) with weight w in edges: \n\n        if distance[u] + w < distance[v]: \n\n      error \"Graph contains a negative-weight cycle\" \n\n```", "```php\n$graph = [ \n\n    0 => [0, 3, 5, 9, 0, 0], \n\n    1 => [3, 0, 3, 4, 7, 0], \n\n    2 => [5, 3, 0, 2, 6, 3], \n\n    3 => [9, 4, 2, 0, 2, 2], \n\n    4 => [0, 7, 6, 2, 0, 5], \n\n    5 => [0, 0, 3, 2, 5, 0] \n\n]; \n\n```", "```php\ndefine(\"I\", PHP_INT_MAX); \n\n$graph = [ \n\n    0 => [I, 3, 5, 9, I, I], \n\n    1 => [3, I, 3, 4, 7, I], \n\n    2 => [5, 3, I, 2, 6, 3], \n\n    3 => [9, 4, 2, I, 2, 2], \n\n    4 => [I, 7, 6, 2, I, 5], \n\n    5 => [I, I, 3, 2, 5, I] \n\n]; \n\n```", "```php\nfunction bellmanFord(array $graph, int $source): array { \n\n    $dist = []; \n\n    $len = count($graph); \n\n    foreach ($graph as $v => $adj) { \n\n      $dist[$v] = PHP_INT_MAX; \n\n    } \n\n    $dist[$source] = 0; \n\n    for ($k = 0; $k < $len - 1; $k++) { \n\n      for ($i = 0; $i < $len; $i++) { \n\n          for ($j = 0; $j < $len; $j++) { \n\n            if ($dist[$i] > $dist[$j] + $graph[$j][$i]) { \n\n            $dist[$i] = $dist[$j] + $graph[$j][$i]; \n\n        } \n\n          } \n\n      } \n\n    } \n\n    for ($i = 0; $i < $len; $i++) { \n\n      for ($j = 0; $j < $len; $j++) { \n\n          if ($dist[$i] > $dist[$j] + $graph[$j][$i]) { \n\n           echo 'The graph contains a negative-weight cycle!'; \n\n           return []; \n\n          } \n\n      } \n\n        } \n\n    return $dist; \n\n} \n\n```", "```php\n$source = 0; \n\n$distances = bellmanFord($graph, $source); \n\nforeach($distances as $target => $distance) { \n\n    echo \"distance from $source to $target is $distance \\n\"; \n\n} \n\n```", "```php\ndistance from 0 to 0 is 0\n\ndistance from 0 to 1 is 3\n\ndistance from 0 to 2 is 5\n\ndistance from 0 to 3 is 7\n\ndistance from 0 to 4 is 9\n\ndistance from 0 to 5 is 8\n\n```", "```php\n$G = [ \n\n    [0, 3, 1, 6, 0, 0], \n\n    [3, 0, 5, 0, 3, 0], \n\n    [1, 5, 0, 5, 6, 4], \n\n    [6, 0, 5, 0, 0, 2], \n\n    [0, 3, 6, 0, 0, 6], \n\n    [0, 0, 4, 2, 6, 0] \n\n]; \n\n```", "```php\nfunction primMST(array $graph) { \n\n    $parent = [];   // Array to store the MST \n\n    $key = [];     // used to pick minimum weight edge         \n\n    $visited = [];   // set of vertices not yet included in MST \n\n    $len = count($graph); \n\n    // Initialize all keys as MAX \n\n    for ($i = 0; $i < $len; $i++) { \n\n      $key[$i] = PHP_INT_MAX; \n\n      $visited[$i] = false; \n\n    } \n\n    $key[0] = 0; \n\n    $parent[0] = -1; \n\n    // The MST will have V vertices \n\n    for ($count = 0; $count < $len - 1; $count++) { \n\n  // Pick the minimum key vertex \n\n  $minValue = PHP_INT_MAX; \n\n  $minIndex = -1; \n\n  foreach (array_keys($graph) as $v) { \n\n      if ($visited[$v] == false && $key[$v] < $minValue) { \n\n        $minValue = $key[$v]; \n\n        $minIndex = $v; \n\n      } \n\n  } \n\n  $u = $minIndex; \n\n  // Add the picked vertex to the MST Set \n\n  $visited[$u] = true; \n\n  for ($v = 0; $v < $len; $v++) { \n\n      if ($graph[$u][$v] != 0 && $visited[$v] == false && \n\n        $graph[$u][$v] < $key[$v]) { \n\n          $parent[$v] = $u; \n\n          $key[$v] = $graph[$u][$v]; \n\n      } \n\n  } \n\n    } \n\n    // Print MST \n\n    echo \"Edge\\tWeight\\n\"; \n\n    $minimumCost = 0; \n\n    for ($i = 1; $i < $len; $i++) { \n\n      echo $parent[$i] . \" - \" . $i . \"\\t\" . $graph[$i][$parent[$i]] \n\n         \"\\n\"; \n\n      $minimumCost += $graph[$i][$parent[$i]]; \n\n    } \n\n    echo \"Minimum cost: $minimumCost \\n\"; \n\n} \n\n```", "```php\nEdge    Weight\n\n0 - 1   3\n\n0 - 2   1\n\n5 - 3   2\n\n1 - 4   3\n\n2 - 5   4\n\nMinimum cost: 13\n\n```", "```php\nfunction Kruskal(array $graph): array { \n\n    $len = count($graph); \n\n    $tree = []; \n\n    $set = []; \n\n    foreach ($graph as $k => $adj) { \n\n    $set[$k] = [$k]; \n\n    } \n\n    $edges = []; \n\n    for ($i = 0; $i < $len; $i++) { \n\n      for ($j = 0; $j < $i; $j++) { \n\n        if ($graph[$i][$j]) { \n\n          $edges[$i . ',' . $j] = $graph[$i][$j]; \n\n        } \n\n    } \n\n    } \n\n    asort($edges); \n\n    foreach ($edges as $k => $w) { \n\n    list($i, $j) = explode(',', $k); \n\n    $iSet = findSet($set, $i); \n\n    $jSet = findSet($set, $j); \n\n    if ($iSet != $jSet) { \n\n        $tree[] = [\"from\" => $i, \"to\" => $j, \n\n    \"cost\" => $graph[$i][$j]]; \n\n        unionSet($set, $iSet, $jSet); \n\n    } \n\n    } \n\n    return $tree; \n\n} \n\nfunction findSet(array &$set, int $index) { \n\n    foreach ($set as $k => $v) { \n\n      if (in_array($index, $v)) { \n\n        return $k; \n\n      } \n\n    } \n\n    return false; \n\n} \n\nfunction unionSet(array &$set, int $i, int $j) { \n\n    $a = $set[$i]; \n\n    $b = $set[$j]; \n\n    unset($set[$i], $set[$j]); \n\n    $set[] = array_merge($a, $b); \n\n} \n\n```", "```php\n$graph = [ \n\n    [0, 3, 1, 6, 0, 0], \n\n    [3, 0, 5, 0, 3, 0], \n\n    [1, 5, 0, 5, 6, 4], \n\n    [6, 0, 5, 0, 0, 2], \n\n    [0, 3, 6, 0, 0, 6], \n\n    [0, 0, 4, 2, 6, 0] \n\n]; \n\n$mst = Kruskal($graph); \n\n$minimumCost = 0; \n\nforeach($mst as $v) { \n\n    echo \"From {$v['from']} to {$v['to']} cost is {$v['cost']} \\n\"; \n\n    $minimumCost += $v['cost']; \n\n} \n\necho \"Minimum cost: $minimumCost \\n\"; \n\n```", "```php\nFrom 2 to 0 cost is 1\n\nFrom 5 to 3 cost is 2\n\nFrom 1 to 0 cost is 3\n\nFrom 4 to 1 cost is 3\n\nFrom 5 to 2 cost is 4\n\nMinimum cost: 13\n\n```"]