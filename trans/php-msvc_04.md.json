["```php\n    Feature: Search secrets \n     In order to find secrets \n     Users should be able to search for near secrets \n\n     Scenario: Search secrets by distance \n       Given there are 996 secrets in the game which are no closer than 100 \n       meters from me \n       And there are 4 secrets SEC001, SEC005, SEC054, SEC121 that are \n       within 100 \n       meters from me \n       When I search for closer secrets \n       Then I should see the following secrets: \n         | Secret code | \n         | SEC001      | \n         | SEC005      | \n         | SEC054      | \n         | SEC121      | \n\n```", "```php\n    RUN curl -sS https://getcomposer.org/installer \n    | php -- --install-dir=/usr/bin/ --filename=composer \n\n```", "```php\n    RUN curl -sSL https://phar.phpunit.de/phpunit.phar -o \n    /usr/bin/phpunit && chmod +x /usr/bin/phpunit \n\n```", "```php\n    \"phpunit/phpunit\": \"4.0.*\",\n```", "```php\n    source_battle: \n       image: nginx:stable \n       volumes: \n           - ../source/battle:/var/www/html \n       command: \"true\" \n\n```", "```php\n    volumes_from: \n               - source_battle \n\n```", "```php\n**$ docker-compose up**\n\n```", "```php\n**$ docker exec -it docker_microservice_battle_fpm_1 /bin/bash**\n\n```", "```php\n**# cd /var/www/html && composer create-project --prefer-dist laravel/lumen .**\n\n```", "```php\n<?php \nnamespace App;\n\nclass Dummy \n{ \n} \n\n```", "```php\n**$ docker exec -it docker_microservice_battle_fpm_1 /bin/bash**\n\n```", "```php\n**# cd /var/www/html**\n**# ./vendor/bin/phpunit**\n\n```", "```php\n    public static function getConfigArray() \n    { \n      return [ \n           'debug'   => true, \n           'storage' => [ \n               'host' => 'localhost', \n               'port' => 5432, \n               'user' => 'my-user', \n               'pass' => 'my-secret-password' \n           ] \n       ]; \n    } \n\n```", "```php\n    public function testFailAssertArrayHasKey() \n    { \n       $dummy = new App\\Dummy(); \n\n       $this->assertArrayHasKey('foo', $dummy::getConfigArray()); \n    } \n\n```", "```php\n    public function testPassAssertArrayHasKey() \n    { \n       $dummy = new App\\Dummy(); \n\n       $this->assertArrayHasKey('storage', $dummy::getConfigArray()); \n    } \n\n```", "```php\n    public $foo; \n\n```", "```php\n    public function testAssertClassHasAttribute() \n    { \n      $this->assertClassHasAttribute('foo', App\\Dummy::class); \n      $this->assertClassHasAttribute('bar', App\\Dummy::class); \n    } \n\n```", "```php\n    public function testAssertArraySubset() \n    { \n       $dummy = new App\\Dummy(); \n\n       $this->assertArraySubset(['storage' => 'failed-test'], \n       $dummy::getConfigArray()]); \n    } \n\n```", "```php\n    public static $availableLocales = [ \n           'en_GB', \n           'en_US', \n           'es_ES', \n           'gl_ES' \n    ]; \n\n```", "```php\n    public function testAssertClassHasStaticAttribute() \n    { \n      $this->assertClassHasStaticAttribute('availableLocales', \n      App\\Dummy::class); \n    } \n\n```", "```php\n    public static function getRandomCode() \n    { \n      return 'CODE-123A'; \n    } \n\n```", "```php\n    public function testAssertRegExp() \n    { \n       $this->assertRegExp('/^CODE\\-\\d{2,7}[A-Z]$/', \n       App\\Dummy::getRandomCode()); \n    } \n\n```", "```php\n    <?php \n\n    namespace App\\Http\\Controllers; \n\n    use Illuminate\\Http\\Request; \n\n    class LocationController extends Controller \n    { \n\n    } \n\n```", "```php\n    <?php \n\n    use Laravel\\Lumen\\Testing\\DatabaseTransactions; \n\n    class LocationControllerTest extends TestCase \n    { \n      public function testDistance() \n      { \n      } \n\n      public function testClosestSecrets() \n      { \n      } \n    } \n\n```", "```php\n    public function testDistance() \n    { \n      $realDistanceLondonAmsterdam = 358.06; \n\n      $london = [ \n           'latitude'  => 51.50, \n           'longitude' => -0.13 \n      ]; \n\n      $amsterdam = [ \n           'latitude'  => 52.37, \n           'longitude' => 4.90 \n      ]; \n\n      $location = new App\\Http\\Controllers\\LocationController(); \n\n      $calculatedDistance = $location->getDistance($london, $amsterdam); \n\n      $this->assertClassHasStaticAttribute('conversionRates', \n      App\\Http\\Controllers\\LocationController::class); \n      $this->assertEquals($realDistanceLondonAmsterdam, \n                          $calculatedDistance); \n    } \n\n```", "```php\n    const ROUND_DECIMALS = 2; \n\n    public static $conversionRates = [ \n       'km'    => 1.853159616, \n       'mile'  => 1.1515 \n    ]; \n\n    protected function convertDistance($distance, $unit = 'km') \n    { \n      switch (strtolower($unit)) { \n        case 'mile': \n          $distance = $distance * self::$conversionRates['mile']; \n          break; \n        default : \n          $distance = $distance * self::$conversionRates['km']; \n          break; \n      } \n\n      return round($distance, self::ROUND_DECIMALS); \n    } \n\n```", "```php\npublic function getEuclideanDistance($pointA, $pointB, $unit = 'km') \n    { \n       $distance = sqrt( \n           pow(abs($pointA['latitude'] - $pointB['latitude']), 2) + pow(abs($pointA['longitude'] - $pointB['longitude']), 2) \n       ); \n\n       return $this->convertDistance($distance, $unit); \n    } \n\n```", "```php\n    public function getDistance($pointA, $pointB, $unit = 'km') \n    { \n      return $this->getEuclideanDistance($pointA, $pointB, $unit); \n    } \n\n```", "```php\n    public function getHaversineDistance($pointA, $pointB, $unit = 'km') \n    { \n      $distance = rad2deg( \n           acos( \n               (sin(deg2rad($pointA['latitude'])) * \n               sin(deg2rad($pointB['latitude']))) + \n               (cos(deg2rad($pointA['latitude'])) * \n               cos(deg2rad($pointB['latitude'])) * \n               cos(deg2rad($pointA['longitude'] - \n               $pointB['longitude']))) \n           ) \n       ) * 60; \n\n      return $this->convertDistance($distance, $unit); \n    } \n\n```", "```php\n    return $this->getHaversineDistance($pointA, $pointB, $unit); \n\n```", "```php\n    public function testClosestSecrets() \n    { \n      $currentLocation = [ \n           'latitude'  => 40.730610, \n           'longitude' => -73.935242 \n      ]; \n\n      $location = new App\\Http\\Controllers\\LocationController(); \n\n      $closestSecrets = $location->getClosestSecrets($currentLocation); \n      $this->assertClassHasStaticAttribute('conversionRates', \n      App\\Http\\Controllers\\LocationController::class); \n      $this->assertContainsOnly('array', $closestSecrets); \n      $this->assertCount(3, $closestSecrets); \n\n       // Checking the first element \n       $currentElement = array_shift($closestSecrets); \n       $this->assertArraySubset(['name' => 'amber'], $currentElement); \n\n       // Second \n       $currentElement = array_shift($closestSecrets); \n       $this->assertArraySubset(['name' => 'ruby'], $currentElement); \n\n       // Third \n       $currentElement = array_shift($closestSecrets); \n       $this->assertArraySubset(['name' => 'diamond'], $currentElement); \n    } \n\n```", "```php\n    public static $cacheSecrets = [ \n       [ \n           'id' => 100, \n           'name' => 'amber', \n           'location' => ['latitude'  => 42.8805, 'longitude' => -8.54569, \n           'name'      => 'Santiago de Compostela'] \n       ], \n       [ \n           'id' => 100, \n           'name' => 'diamond', \n           'location' => ['latitude'  => 38.2622, 'longitude' => -0.70107,\n           'name'      => 'Elche'] \n       ], \n       [ \n           'id' => 100, \n           'name' => 'pearl', \n           'location' => ['latitude'  => 41.8919, 'longitude' => 12.5113, \n           'name'      => 'Rome'] \n       ], \n       [ \n           'id' => 100, \n           'name' => 'ruby', \n           'location' => ['latitude'  => 53.4106, 'longitude' => -2.9779, \n           'name'      => 'Liverpool'] \n       ], \n       [ \n           'id' => 100, \n           'name' => 'sapphire', \n           'location' => ['latitude'  => 50.08804, 'longitude' => 14.42076, \n           'name'      => 'Prague'] \n       ], \n    ]; \n\n```", "```php\n    public function getClosestSecrets($originPoint) \n    { \n      $closestSecrets    = [];\n      $preprocessClosure = function($item) use($originPoint) { \n        return $this->getDistance($item['location'], $originPoint); \n      };  \n\n       $distances = array_map($preprocessClosure, self::$cacheSecrets); \n\n       asort($distances); \n\n       $distances = array_slice($distances, 0, \n         self::MAX_CLOSEST_SECRETS, true); \n\n       foreach ($distances as $key => $distance) { \n         $closestSecrets[] = self::$cacheSecrets[$key]; \n       } \n\n       return $closestSecrets; \n    } \n\n```", "```php\n    \"require-dev\": { \n      \"fzaninotto/faker\": \"~1.4\", \n      \"phpunit/phpunit\": \"~4.0\", \n      \"behat/behat\": \"3.*\" \n    }, \n\n```", "```php\n**# cd /var/www/html && composer update**\n\n```", "```php\n**# vendor/bin/behat**\n\n```", "```php\nFeature: Secrets wallet \n In order to play the game \n As a user \n I need to be able to put found secrets into a wallet \n\n Scenario: Finding a single secret \n    Given there is an \"amber\" \n    When I add the \"amber\" to the wallet \n    Then I should have 1 secret in the wallet \n\n Scenario: Finding two secrets \n    Given there is an \"amber\" \n    And there is a \"diamond\" \n    When I add the \"amber\" to the wallet \n    And I add the \"diamond\" to the wallet \n    Then I should have 2 secrets in the wallet \n\n```", "```php\nScenario: Some description of the scenario \n Given some context \n When some event \n Then the outcome \n\n```", "```php\n**# vendor/bin/behat --init**\n\n```", "```php\n    /** \n    * @Given there is a(n) :arg1 \n    */ \n    public function thereIsA($arg1) \n    { \n       throw new PendingException(); \n    } \n\n```", "```php\n    <?php \n\n     use Behat\\Behat\\Context\\Context; \n     use Behat\\Behat\\Tester\\Exception\\PendingException; \n     use Behat\\Gherkin\\Node\\PyStringNode; \n     use Behat\\Gherkin\\Node\\TableNode; \n\n    /** \n    * Defines application features from the specific context. \n    */ \n    class FeatureContext implements Context \n    { \n      private $secretsCache; \n      private $wallet; \n\n      public function __construct() \n      { \n        $this->secretsCache = new SecretsCache(); \n        $this->wallet = new Wallet($this->secretsCache); \n      } \n\n      /** \n      * @Given there is a(n) :secret \n      */ \n      public function thereIsA($secret) \n      { \n        $this->secretsCache->setSecret($secret); \n      } \n\n      /** \n      * @When I add the :secret to the wallet \n      */ \n      public function iAddTheToTheWallet($secret) \n      { \n        $this->wallet->addSecret($secret); \n      } \n\n      /** \n      * @Then I should have :count secret(s) in the wallet \n      */ \n      public function iShouldHaveSecretInTheWallet($count) \n      { \n         PHPUnit_Framework_Assert::assertCount( \n           intval($count), \n           $this->wallet \n         ); \n      } \n    } \n\n```", "```php\n    <?php \n    final class SecretsCache \n    { \n      private $secretsMap = []; \n\n      public function setSecret($secret) \n      { \n         $this->secretsMap[$secret] = $secret; \n      } \n\n      public function getSecret($secret) \n      { \n        return $this->secretsMap[$secret]; \n      } \n    } \n\n```", "```php\n    <?php \n    final class Wallet implements \\Countable \n    { \n      private $secretsCache; \n      private $secrets; \n\n      public function __construct(SecretsCache $secretsCache) \n      { \n        $this->secretsCache = $secretsCache; \n      } \n\n      public function addSecret($secret) \n      { \n        $this->secrets[] = $secret; \n      } \n\n      public function count() \n      { \n        return count($this->secrets); \n      } \n    } \n\n```"]