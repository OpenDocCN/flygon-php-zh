- en: Chapter 8.  Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 测试
- en: We already asserted multiple times throughout the book that pure functions are
    easier to test; it is time we prove it. In this chapter, we will first present
    a small glossary about the topic in order to ensure we speak a common language.
    We will then continue with how a functional approach helps with traditional testing.
    Finally, we will learn about a different way to test code, called **property-based
    testing**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整本书中已经多次断言纯函数更容易测试；现在是时候证明它了。在本章中，我们将首先介绍有关这个主题的小词汇表，以确保我们使用共同的语言。然后，我们将继续讨论功能性方法如何帮助传统测试。最后，我们将了解一种称为**基于属性的测试**的代码测试方法。
- en: None of the subjects of this chapter are strictly confined to functional programming;
    you will be able to use anything in any legacy codebase. Also, this is not a book
    about testing, so we will not go into every detail. It is also assumed that you
    have some prior knowledge about testing code in PHP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题并不严格限于函数式编程；您可以在任何传统代码库中使用任何内容。此外，这不是一本关于测试的书，所以我们不会详细介绍每个细节。还假定您对在PHP中测试代码有一些先验知识。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Small testing glossary
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型测试词汇表
- en: Testing pure functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试纯函数
- en: Test parallelization as a speed-up technique
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试并行化作为一种加速技术
- en: Property-based testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于属性的测试
- en: Testing vocabulary
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试词汇表
- en: I won't claim to give you a complete glossary of all testing-related terms and
    also I won't explain the subtle differences and interpretations that could be
    made for each of them. The idea of this section is simply to lay some common ground.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会声称给你一个完整的所有与测试相关术语的词汇表，也不会解释每个术语的微妙差异和解释。这一部分的目的只是为了奠定一些共同的基础。
- en: 'The glossary won''t be in alphabetical order, but rather terms will be grouped
    by categories. Also, it must by no means be considered a complete glossary. There
    are a lot more terms and techniques that pertain to testing than what will be
    presented here, especially if you include all testing methods related to performance,
    security, and usability:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 词汇表不会按字母顺序排列，而是根据类别分组。此外，绝对不能认为它是一个完整的词汇表。与测试相关的术语和技术远不止这里所呈现的内容，特别是如果包括所有与性能、安全性和可用性相关的测试方法：
- en: '**Unit testing**: Tests conducted against each individual component separately.
    What is considered a *unit* varies-a function/method, a whole class, a whole module.
    Usually, dependency to other units is mocked to cleanly isolate each part.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：针对每个单独的组件进行的测试。被视为*单元*的内容各不相同-可以是一个函数/方法、一个整个类、一个整个模块。通常会模拟对其他单元的依赖，以清晰地隔离每个部分。'
- en: '**Functional testing**: Tests the software as a black box to ensure that it
    meets the specifications. External dependency is usually mocked.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：以黑盒方式测试软件，以确保其符合规格。通常会模拟外部依赖。'
- en: '**Integration testing**: Tests conducted against the whole application and
    its dependencies, including external ones, to ensure that everything integrates
    correctly.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：针对整个应用程序及其依赖项（包括外部依赖项）进行的测试，以确保一切正确集成。'
- en: '**Acceptance testing**: Tests conducted by the final customer / end user against
    a set of agreed-upon criteria.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验收测试**：由最终客户/最终用户根据一组约定的标准进行的测试。'
- en: '**Regression testing**: Repeats a test after some change is made to ensure
    no issues were introduced in the process.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归测试**：在进行某些更改后重复测试，以确保没有引入问题。'
- en: '**Fuzz testing / Fuzzing**: Tests conducted by inputting massive amounts of
    (semi) random data in order to make it crash. This helps discover coding errors
    or security issues.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模糊测试/ Fuzzing**：通过输入大量（半）随机数据进行的测试，以使其崩溃。这有助于发现编码错误或安全问题。'
- en: '**Ad-hoc testing**: Tests performed with no formal framework or plan.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**临时测试**：在没有正式框架或计划的情况下进行的测试。'
- en: '**Component testing**: See *unit testing*.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件测试**：见*单元测试*。'
- en: '**Blackbox testing**: See *functional testing*.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黑盒测试**：见*功能测试*。'
- en: '**Behavioral testing**: See *functional testing*.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为测试**：见*功能测试*。'
- en: '**User Acceptance testing** (**UAT)**: See *acceptance testing*.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户验收测试**（**UAT**）：见*验收测试*。'
- en: '**Alpha version**: Usually, the first version that is tested as a black box.
    It can be unstable and cause data loss.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Alpha版本**：通常是作为黑盒测试的第一个版本。它可能不稳定并导致数据丢失。'
- en: '**Beta version**: Usually, the first version that is feature-complete and in
    a state good enough to be released to external people. It can still have serious
    issues and should not be used in a production environment.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Beta版本**：通常是功能完整且足够好以发布给外部人员的第一个版本。它仍然可能存在严重问题，不应在生产环境中使用。'
- en: '**Release Candidate **(**RC)**: A version that is deemed stable enough to be
    released to the public for a final test. Usually the last RC is "promoted" as
    the released version.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布候选版**（**RC**）：被认为足够稳定以发布给公众进行最终测试的版本。通常最后一个RC会被“提升”为发布版本。'
- en: '**Mocking (mock)**: Creating components that imitate other parts of the software
    or an external service to test only the matter at hand.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟**（mock）：创建模拟软件或外部服务的组件，以仅测试手头的问题。'
- en: '**Stubbing** (**stub)**: See *mocking*.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根**（**stub**）：见*模拟*。'
- en: '**Code coverage**: The percentage of the application code or features that
    is covered by the tests. It can have different granularity: by lines, by functions,
    by components, and so on.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码覆盖率**：测试覆盖的应用程序代码或功能的百分比。可以有不同的粒度：按行、按函数、按组件等。'
- en: '**Instrumentation**: The process of adding code to the application in order
    to test and monitor behavior or coverage. It can be done manually or by a tool
    either in the source, in a compiled form, or in-memory.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪器化**：向应用程序添加代码以测试和监视行为或覆盖范围的过程。可以手动完成，也可以通过工具在源代码、编译形式或内存中完成。'
- en: '**Peer review**: A process where one or multiple colleagues examine the produced
    work such as code, documentation, or anything pertaining to the release.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同行评审**：一种同事检查所产出工作（如代码、文档或与发布相关的任何内容）的过程。'
- en: '**Static analysis**: Analysis the application without running it, usually done
    by a tool. It can provide information about coverage, complexity, coding style,
    or even found issues.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态分析：分析应用程序而无需运行它，通常由工具完成。它可以提供有关覆盖范围、复杂性、编码风格甚至发现问题的信息。
- en: '**Static testing**: All of the testing and reviews performed without executing
    the application. See *peer review* and *static analysis*.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态测试：在不执行应用程序的情况下进行的所有测试和审查。参见*同行审查*和*静态分析*。
- en: '**Smoke tests**: Superficially testing the main parts of an application to
    ensure the core features work.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒烟测试：对应用程序的主要部分进行表面测试，以确保核心功能正常工作。
- en: '**Technical review**: See *peer review*.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术审查：参见*同行审查*。
- en: '**Decision point**: A statement in the code where a change in the control flow
    can happen, typically an `if` condition.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决策点：代码中的一个语句，控制流可以发生变化，通常是一个“if”条件。
- en: '**Path**: The sequence of statements executed from the beginning of the function
    to the end. A function can have multiple paths depending on its decision point.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径：从函数开始到结束执行的语句序列。根据其决策点，函数可以有多个路径。
- en: '**Cyclomatic complexity**: A measure of the complexity of a piece of code.
    There are various algorithms to compute it; one is "number of decision points
    + 1".'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圈复杂度：代码复杂性的度量。有各种算法来计算它；其中一个是“决策点的数量+1”。
- en: '**Defect**, **failure**, **issue,** or **bug**: Anything that does not work
    as expected in the application.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺陷、失败、问题或错误：在应用程序中未按预期工作的任何内容。
- en: '**False-positive**: A test result seen as a defect when in fact everything
    works fine.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假阳性：测试结果被视为缺陷，而实际上一切都正常。
- en: '**False-negative**: A test result seen as a success when in fact there is a
    defect.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假阴性：测试结果被视为成功，而实际上存在缺陷。
- en: '**Test-driven Development** (**TDD)**: A development methodology where you
    start by writing a test and then the minimum amount of code to make it pass before
    repeating the process.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发（TDD）：一种开发方法，您首先编写测试，然后编写最少量的代码使其通过，然后重复该过程。
- en: '**Behavior-driven Development** (**BDD)**: A development methodology based
    on TDD where you describe behavior using a domain-specific language instead of
    writing traditional tests.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为驱动开发（BDD）：一种基于TDD的开发方法，其中您使用特定于领域的语言描述行为，而不是编写传统测试。
- en: '**Type-driven Development**: A running joke in the functional world where you
    replace tests with a strong type system. Depending on whom you ask, the idea might
    be taken more or less seriously.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型驱动开发：在功能世界中的一个笑话，您可以使用强类型系统替换测试。取决于您问的人，这个想法可能会更或更不严肃。
- en: '**X-driven Development**: There is a new best development methodology created
    every week; the website [http://devdriven.by/](http://devdriven.by/) tries to
    reference them all.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于X的开发：每周都会出现一种新的最佳开发方法；网站[http://devdriven.by/](http://devdriven.by/)试图引用它们。
- en: Testing pure functions
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试纯函数
- en: As we just saw in the glossary, there are a lot of potential ways to test an
    application. In this section, we will, however, limit ourselves to tests at the
    function level; or in other words, we will do unit testing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在术语表中看到的那样，有很多潜在的测试应用程序的方法。在本节中，我们将限制自己只进行函数级别的测试；换句话说，我们将进行单元测试。
- en: 'So, what makes pure functions so much easier to test? There are multiple reasons;
    let''s start by enumerating them and we will then see why with real test cases:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，纯函数为什么要容易得多呢？有多种原因；让我们从列举它们开始，然后我们将通过真实的测试用例来看为什么：
- en: Mocking is simplified as you only need to provide input arguments. No external
    state to create, no singletons to stub.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟变得简单，因为您只需要提供输入参数。无需创建外部状态，也无需存根单例。
- en: Repeated calls will yield exactly the same result for a given arguments list,
    whatever the time of day or previously run tests. There is no need to put the
    application in a certain state.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定的参数列表，重复调用将产生完全相同的结果，无论是白天还是之前运行的测试。无需将应用程序置于特定状态。
- en: Functional programming encourages smaller functions doing exactly one thing.
    This usually entails test cases that are easier to write and understand.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程鼓励编写更小的函数，每个函数只做一件事。这通常意味着更容易编写和理解的测试用例。
- en: Referential transparency usually means you need fewer tests to gain the same
    level of trust in your code.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用透明度通常意味着您需要更少的测试来获得对代码的相同信任水平。
- en: The absence of side-effects guarantees that your test will have no consequences
    on any other subsequent tests. This means you can run them in any order you want
    without worrying about resetting the state between each test or running them in
    isolation.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无副作用保证了您的测试不会对任何其他后续测试产生影响。这意味着您可以以任何您想要的顺序运行它们，而不必担心在每个测试之间重置状态或者独立运行它们。
- en: Some of these claims may seem a bit bold to you, or maybe you are unsure why
    I made them. Let's take some time to verify why they are true with examples. We
    will separate our examples into four different parts to makes things easier to
    follow.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些声明中的一些可能对您来说似乎有点大胆，或者您可能不确定我为什么要这样做。让我们花点时间用例子来验证它们为什么是真的。我们将把我们的例子分成四个不同的部分，以便更容易跟踪。
- en: All inputs are explicit
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有输入都是显式的。
- en: As we discovered earlier, a pure function needs to have all of its inputs as
    arguments. You cannot rely on some static method from a singleton, generate random
    numbers, or get any kind of data that can change from an external source.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前发现的，纯函数需要将其所有输入作为参数。您不能依赖于单例的某些静态方法，生成随机数，或者从外部来源获取任何可能发生变化的数据。
- en: The corollary is that you can run your test at any time during the day, on any
    environment, and for any given list of arguments, and the output will stay the
    same. This simple fact makes both writing and reading tests a lot easier.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 其推论是，您可以在一天中的任何时间，在任何环境中，对于任何给定的参数列表运行测试，输出将保持不变。这个简单的事实使得编写和阅读测试变得更容易。
- en: 'Imagine you have to test the following function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您需要测试以下函数：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The problem is that, when you call the function, you need to know what time
    it is so you can check whether the return value is correct. This fact leads to
    some issues:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，当你调用函数时，你需要知道现在是什么时间，这样你才能检查返回值是否正确。这一事实导致了一些问题：
- en: You basically have to re-implement the function logic inside the test, thus
    possibly having the same bug in both the test and the function.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本上，你必须在测试中重新实现函数逻辑，因此可能在测试和函数中都存在相同的错误。
- en: There is a slight chance that, between the time you computed the expected value
    and the function gets the time again to return a result, a minute elapsed, changing
    the current hour and thus the function result. Those kinds of false positive are
    a real headache to debug.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你计算期望值并且函数再次返回结果之间，可能会有一分钟的时间流逝，改变当前的小时，从而改变函数的结果。这种假阳性的情况真的很头疼。
- en: You cannot test all possible outputs without somehow manipulating the system
    clock.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不以某种方式操纵系统时钟的情况下，你无法测试所有可能的输出。
- en: The dependency to the current time being hidden, the person reading the test
    can only infer what the function is doing.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前时间的依赖性被隐藏，阅读测试的人只能推断函数在做什么。
- en: By simply moving the `$hour` variable as a parameter, we solve all the previously
    mentioned issues.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地将`$hour`变量作为参数传递，我们解决了之前提到的所有问题。
- en: Also, if you use a test runner that allows you to create a data provider for
    your tests, such as **PHPUnit** or **atoum**, testing the function becomes as
    simple as creating a provider that creates a list of hours associated with the
    expected return and simply feeds the time to the function and checks the result.
    This test is a lot simpler to write, understand, and expand than anything else
    you would have needed to write earlier.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你使用一个允许你为测试创建数据提供程序的测试运行器，比如**PHPUnit**或**atoum**，测试函数就变得非常简单，只需要创建一个提供程序，生成与预期返回相关联的小时列表，然后将时间提供给函数并检查结果。这种测试比之前需要编写的任何其他内容都更简单、更易于理解和扩展。
- en: Referential transparency and no side-effects
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用透明性和无副作用
- en: Referential transparency ensures that you can replace a function call (with
    certain arguments) with the result of the computation anywhere in your code. This
    is also an interesting property for testing as it mostly means you will need to
    test less to gain the same amount of trust. Let me explain.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 引用透明性确保你可以在代码的任何地方用计算结果替换函数调用（带有特定参数）。这对于测试也是一个有趣的特性，因为这基本上意味着你需要测试的内容更少，就能获得相同的信任。让我解释一下。
- en: Usually, when you do unit testing, you try to choose the smallest unit possible
    that satisfies the trust you want to place in your code. Usually, you will test
    either at the module, class, or method level. Obviously, when doing functional
    programming, you will test at the function level.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在进行单元测试时，你会尽量选择最小的单元，以满足你对代码的信任。通常情况下，你会在模块、类或方法级别进行测试。显然，在进行函数式编程时，你会在函数级别进行测试。
- en: Your functions will obviously call other functions. In a traditional testing
    setup, you would try to mock as many as those as possible in order to ensure that
    you test only the functionality of the current unit and you are not impacted by possible
    bugs in other functions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你的函数显然会调用其他函数。在传统的测试设置中，你会尽量模拟尽可能多的函数，以确保你只测试当前单元的功能，而不会受到其他函数可能存在的错误的影响。
- en: Although not impossible, it's cumbersome to mock functions in PHP, so this becomes
    a bit difficult in our case. This is especially true for composed functions such
    as `$title = compose('strip_tags', 'trim', 'capitalize');` due to the way composition
    is implemented in PHP using closures.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在PHP中模拟函数并非不可能，但在我们的情况下有些麻烦。特别是对于像`$title = compose('strip_tags', 'trim',
    'capitalize');`这样的组合函数，由于PHP中使用闭包实现组合的方式，这变得有些困难。
- en: 'So what do we do? Pretty much nothing. The goal of unit testing is to gain
    confidence in the fact that your code works in the expected way. In a traditional
    imperative approach, you mock as many dependencies as possible for the following
    reasons:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们该怎么办呢？基本上什么都不做。单元测试的目标是对代码按预期方式的工作获得信心。在传统的命令式方法中，你会尽量模拟尽可能多的依赖项，原因如下：
- en: Each dependency can depend on some state you need to provide, making your job
    tougher. Even worse, dependencies can have dependencies of their own that also
    require some state, and so on.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个依赖项都可能依赖于你需要提供的某些状态，使你的工作更加困难。更糟糕的是，依赖项可能有自己的依赖项，也需要一些状态，依此类推。
- en: Imperative code can have side effects, which could lead to your function or
    some dependencies having issues. This means that without mocks, you are not only
    testing your function, but all other dependencies and the interaction between
    them; in other words, you are doing integration testing.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令式代码可能会产生副作用，这可能导致你的函数或某些依赖项出现问题。这意味着，如果没有模拟，你不仅在测试你的函数，还在测试所有其他依赖项和它们之间的交互；换句话说，你在进行集成测试。
- en: Control structures introduce decision points, which can make reasoning about
    a function complex; this means that, if you reduce the number of moving pieces
    to the strict minimum, your function is easier to test. Mocking other function
    calls reduces this complexity.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制结构引入决策点，这可能使对函数的推理变得复杂；这意味着，如果你将移动部件的数量减少到最低限度，你的函数就更容易测试。模拟其他函数调用可以减少这种复杂性。
- en: When doing functional programming, the first issue is moot as there is no global
    state. Everything your dependencies will ever need is either already in the arguments
    to your tested function or will be computed along the way. So mocking dependencies
    will make you do more work instead of less.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行函数式编程时，第一个问题是无关紧要的，因为没有全局状态。你的依赖项所需的一切要么已经在被测试函数的参数中，要么将在途中计算。因此，模拟依赖项将使你做更多的工作，而不是更少。
- en: Since our functions are pure and referentially transparent, there is no risk
    of side effects having any consequences on the computation result, meaning even
    if we have dependency, we are not doing integration testing. Sure, a bug in one
    of the functions that is called will result in an error, but hopefully it will also
    have been caught earlier by another test, making it clear what is happening.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的函数是纯函数且引用透明的，因此副作用不会对计算结果产生任何影响，这意味着即使我们有依赖关系，我们也不进行集成测试。当然，如果调用的函数中有错误，那么会导致错误，但希望它也会在另一个测试中被捕获，从而清楚地说明发生了什么。
- en: 'Concerning the complexity, if we go back to our composed function, `$title
    = compose(''strip_tags'', ''trim'', ''capitalize'');`, I posit it is really easy
    for anyone to understand what is happening. If all three functions are already
    tested, there is nothing much that can go wrong, even if we were to rewrite this
    without the `compose` command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于复杂性，如果我们回到我们的组合函数，`$title = compose('strip_tags', 'trim', 'capitalize');`，我认为任何人都很容易理解发生了什么。如果所有三个函数都已经经过测试，那么即使我们在没有`compose`命令的情况下重新编写它，也不会出现太多问题。
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is not much to test here. Obviously, we would have to write some tests
    to ensure that we pass the right temporary value to each function and that the
    plumbing works as expected, but if we have confidence in all three called functions,
    we can have a lot of confidence that this function will work also.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多需要测试的地方。显然，我们需要编写一些测试来确保我们将正确的临时值传递给每个函数，并且管道的工作符合预期，但是如果我们对所有三个被调用的函数都有信心，那么我们就可以非常有信心地认为这个函数也会工作。
- en: This line of reasoning is only possible because we know due to the properties
    of referential transparency that none of the three functions will have any impact
    on any of the others in some subtle way, meaning that their own unit tests give
    us trust enough in the fact that they will not break.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种推理是可能的，因为我们知道由于引用透明的属性，这三个函数中的任何一个都不会以一些微妙的方式影响其他任何一个，这意味着它们自己的单元测试给了我们足够的信任，即它们不会出错。
- en: The result of all this is that usually you will write fewer tests for functional
    code because you will gain trust quicker. However, it does not mean that the `title`
    function does not need to be tested, because you could have made a small mistake
    somewhere. Each component should still be tested, but probably with a bit less
    care in correctly isolating everything.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的结果通常是，您会为函数式代码编写更少的测试，因为您会更快地获得信任。但这并不意味着`title`函数不需要测试，因为您可能在某个地方犯了一个小错误。每个组件仍然应该被测试，但可能在正确隔离一切方面要小心一些。
- en: Obviously, we are not talking about database access, or third-party APIs, or
    services here; those should always be mocked for the same reasons as in any test
    suite.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不是在谈论数据库访问，第三方API或服务；出于与任何测试套件相同的原因，这些都应该被模拟。
- en: Simplified mocking
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化模拟
- en: This might already be clear, but I really want to stress the point that any
    mocking you will have to do will be greatly simplified.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能已经很清楚了，但我真的想强调一点，您需要做的任何模拟都会大大简化。
- en: First of all, you will only need to create the input arguments of the function
    under test. In some cases, this represents creating some pretty big data structures
    or instantiating complex classes, but at least you don't have to mock external
    states or a whole lot of services that are injected in your dependencies.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您只需要创建要测试的函数的输入参数。在某些情况下，这意味着创建一些相当大的数据结构或实例化复杂的类，但至少您不必模拟外部状态或注入到依赖项中的大量服务。
- en: Also, this might not be true in all cases, but usually your functions operate
    on a smaller scale because they are a small part of something bigger, meaning
    that any one function will only take some really precise and concise parameters.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能在所有情况下都不是真的，但通常您的函数在较小的规模上运行，因为它们是更大东西的一小部分，这意味着任何一个函数只会接受一些非常精确和简洁的参数。
- en: Obviously, there will be exceptions, but not that many, and as we discussed
    earlier, since all of the parts making the big picture will already be tested.
    Your degree of confidence should then already be higher than is usually the case
    in a more imperative application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，会有例外，但不是很多，正如我们之前讨论的那样，由于构成整体的所有部分已经被测试。因此，您的信心程度应该比通常情况下更高。
- en: Building blocks
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建模块
- en: Functional programming encourages the creation of small building blocks that
    get reused as part of bigger functions. Those small functions do usually only
    one thing. This makes them easier to understand, but also easier to test.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程鼓励创建小的构建模块，这些模块作为更大函数的一部分被重复使用。这些小函数通常只做一件事。这使它们更容易理解，也更容易测试。
- en: The more decision points a function has, the more difficult it is to come up
    with a way to test each possible execution path. A small specialized function
    has usually at most two of those decision points, making it fairly easy to test.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的决策点越多，测试每个可能的执行路径就越困难。一个小的专门函数通常最多有两个这样的决策点，这使得它相当容易测试。
- en: Bigger function usually don't perform any kind of control flow, they are just
    composed of our smaller blocks in a straightforward way. Since this means there
    is only one possible execution path, it also means that they are easy to test.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通常较大的函数不会执行任何控制流，它们只是以直接的方式由我们的较小模块组成。由于这意味着只有一条可能的执行路径，这也意味着它们很容易测试。
- en: Closing words
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束语
- en: Of course, I am not saying that you won't encounter some pure functions that
    are difficult to test. It's just than in general you will have less trouble writing
    your tests and you will also gain trust in your code quicker.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我并不是说您不会遇到一些难以测试的纯函数。通常情况下，您编写测试时会遇到更少的麻烦，并且您也会更快地对代码产生信任。
- en: With the industry moving ever closer to methodologies such as TDD, this means
    that functional programming is really a good fit for a modern application. This
    is especially true once you realize that most advice you'll find in order to write
    "testable code" is already enforced by using only functional programming techniques.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 随着行业越来越接近TDD等方法论，这意味着函数式编程确实非常适合现代应用。一旦你意识到，通过只使用函数式编程技术就已经强制执行了大部分关于编写“可测试代码”的建议，这一点尤其正确。
- en: Speeding up using parallelization
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并行化加速
- en: If you have ever searched for a solution to speed up your test suites, chances
    are that you found something about test parallelization. Usually, users of PHPUnit
    will find the **ParaTest** utility, for example.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经寻找加速测试套件的解决方案，很可能会找到关于测试并行化的内容。通常，PHPUnit的用户会找到**ParaTest**实用工具，例如。
- en: 'The main idea is to run multiple PHP processes simultaneously in order to leverage
    all the processing power of the computer. This approach works for mostly two reasons:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 主要思想是同时运行多个PHP进程，以利用计算机的所有处理能力。这种方法主要有两个原因：
- en: A single test run has bottlenecks such as disk speed for source file parsing
    or database access.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单次测试运行存在瓶颈，比如源文件解析的磁盘速度或数据库访问。
- en: PHP being single-threaded, a multi-core CPU, like nearly all computers have
    nowadays, is not used to its full potential by a single test run.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于PHP是单线程的，像几乎所有现在的计算机一样，多核CPU在单次测试运行中没有得到充分利用。
- en: By running multiples tests in parallel, both those issues can be solved. The
    ability to do this is, however, limited by the fact that each test suite is independent
    from the others, a property that is already enforced by referential transparency
    in a functional codebase.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过并行运行多个测试，这两个问题都可以解决。然而，能够这样做的能力受到了一个限制，即每个测试套件都是独立的，这一特性在函数式代码库中已经通过引用透明性得到了强制执行。
- en: This means that, if the functions under test follow the functional principles,
    you can run all your tests in parallel without having to make any adaptation.
    In some cases, this could divide by ten the time taken for your whole test suite,
    greatly improving the feedback loop when you develop in the process.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果被测试的函数遵循函数式原则，你可以在不做任何调整的情况下并行运行所有的测试。在某些情况下，这可能会将整个测试套件所需的时间缩短十分之一，大大改善了你在开发过程中的反馈循环。
- en: If you are using PHPUnit utility, the aforementioned ParaTest utility is one
    of the easiest ways to get started. You can find it on GitHub at [https://github.com/brianium/paratest](https://github.com/brianium/paratest).
    I advise you to use the **`-functional`** command-line parameter so that each
    function can be tested simultaneously instead of just the test cases.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用PHPUnit实用工具，前面提到的ParaTest实用工具是最简单的入门方式之一。你可以在GitHub上找到它：[https://github.com/brianium/paratest](https://github.com/brianium/paratest)。我建议你使用**`-functional`**命令行参数，这样每个函数都可以同时进行测试，而不仅仅是测试用例。
- en: There is also a brand-new utility for PHPUnit users called **PHPChunkIt**. I
    haven't had the opportunity to test it, but I hear it is interesting. You can
    find it on GitHub at [https://github.com/jwage/phpchunkit](https://github.com/jwage/phpchunkit).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit用户还有一个全新的实用工具叫做**PHPChunkIt**。我还没有机会测试它，但我听说它很有意思。你可以在GitHub上找到它：[https://github.com/jwage/phpchunkit](https://github.com/jwage/phpchunkit)。
- en: Another more flexible option is using Fastest, available at [https://github.com/liuggio/fastest](https://github.com/liuggio/fastest).
    The examples shown in the tool documentation are for PHPUnit, but in theory it
    is able to run anything in parallel.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更灵活的选择是使用Fastest，可以在[https://github.com/liuggio/fastest](https://github.com/liuggio/fastest)找到。工具文档中显示的示例是针对PHPUnit的，但理论上它能够并行运行任何东西。
- en: If you are using the atoum utility instead, by default your tests are already
    in what they call *concurrent* mode, which means they run in parallel. You can
    modify this behavior for each test using annotations as stated in the execution
    engine documentation at [https://atoum-en.rtfd.org/en/latest/engine.html](https://atoum-en.rtfd.org/en/latest/engine.html).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是atoum实用工具，那么默认情况下你的测试已经处于他们所谓的*并发*模式，这意味着它们是并行运行的。你可以根据执行引擎文档中的注释修改每个测试的行为：[https://atoum-en.rtfd.org/en/latest/engine.html](https://atoum-en.rtfd.org/en/latest/engine.html)。
- en: The **behat** framework users can use the **Parallel Runner** extension, also
    available on GitHub at [https://github.com/shvetsgroup/ParallelRunner](https://github.com/shvetsgroup/ParallelRunner).
    If you are using **CodeCeption** framework, it is sadly a bit difficult to achieve;
    the documentation ([http://codeception.com/docs/12-ParallelExecution](http://codeception.com/docs/12-ParallelExecution))
    has, however, multiple possible solutions for you.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**behat**框架的用户可以使用**Parallel Runner**扩展，也可以在GitHub上找到：[https://github.com/shvetsgroup/ParallelRunner](https://github.com/shvetsgroup/ParallelRunner)。如果你使用**CodeCeption**框架，要实现并行化可能有点困难；然而，文档（[http://codeception.com/docs/12-ParallelExecution](http://codeception.com/docs/12-ParallelExecution)）中有多种可能的解决方案。'
- en: I strongly suggest you look into parallelizing your tests as it will be time
    well spent. Even if you are only able to save a few seconds on each run, this
    gain quickly accumulates. Faster tests means you will run them more often and
    this is usually a good way to improve code quality.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你研究一下并行化你的测试，因为这将是花费时间的好方法。即使你每次运行只能节省几秒钟，这种收益很快就会累积起来。更快的测试意味着你会更频繁地运行它们，这通常是改进代码质量的好方法。
- en: Property-based testing
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于属性的测试
- en: Tired of spending time tediously writing test cases, John Hughes and Koen Claessen
    decided it was time for a change. A little more than 15 years ago, they wrote
    and published a paper about a new tool they called *QuickCheck*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰·休斯和科恩·克拉森厌倦了费时费力地编写测试用例，他们决定是时候改变一下了。15年多前，他们写了一篇关于他们称之为*QuickCheck*的新工具的论文并发表了出来。
- en: The main idea is that, instead of defining a list of possible input values and
    then asserting that the result is what we expect, you define a list of properties
    that characterize your function. The tool then generates as many test cases as
    wanted automatically and verifies that the property holds.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 主要思想是，不是定义可能的输入值列表，然后断言结果是我们期望的，而是定义表征函数的属性列表。然后工具会自动生成所需的测试用例，并验证属性是否成立。
- en: The default operating mode is for *QuickCheck* to generate random values and
    feed them to your functions. The result is then checked against the properties.
    If a failure is detected, the tool will then try to reduce the inputs to the minimal
    set of inputs generating the issue.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的操作模式是*QuickCheck*生成随机值并将其提供给您的函数。然后检查结果是否符合属性。如果检测到失败，工具将尝试将输入减少到生成问题的最小输入集。
- en: Having a tool generating as many testing values as you want is invaluable to
    find edge cases it would have taken you hours to think about. The fact that the
    test case is then reduced to its minimal form is also great to easily determine
    what is going wrong and how to fix it. It so happens that random values are not
    always the best way to test something. This is why you can also provide generators
    that will be used instead.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个工具可以生成尽可能多的测试值是无价的，可以找到需要花费数小时才能想到的边缘情况。测试用例被减少到最小形式也很容易确定出了什么问题以及如何解决。偶然情况下，随机值并不总是测试某些东西的最佳方式。这就是为什么您还可以提供要使用的生成器。
- en: Also, thinking of your tests as a set of properties that need to hold true is
    a great way to focus more clearly on what the system is supposed to do instead
    of focusing on finding test values. This is especially helpful when doing TDD
    as your tests will be more akin to a specification.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将测试视为一组需要保持真实的属性是一种更清晰地关注系统应该做什么而不是专注于查找测试值的好方法。这在进行TDD时尤其有帮助，因为您的测试将更像是规范。
- en: If you want to learn more about this approach, the original paper is available
    online at [http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf](http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf).
    The author uses Haskell in his paper but the content is however fairly easy to
    read and understand.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于这种方法的信息，原始论文可以在[http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf](http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf)上找到。作者在论文中使用Haskell，但内容相当容易阅读和理解。
- en: What exactly is a property?
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性到底是什么？
- en: A property is a rule that your function must respect in order to be determined
    correct. It can be something really simple, such as the result of a function adding
    to integers requiring also to be an integer, or anything more complex, such as
    verifying the monad laws.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是您的函数必须遵守的规则，以确定其正确性。它可以是非常简单的东西，比如函数添加两个整数的结果也需要是整数，也可以是更复杂的东西，比如验证单子定律。
- en: You usually want to create properties that are not already enforced otherwise,
    be it by another property or the language. For example, if we use the scalar type
    systems introduced by PHP 7, our preceding integer example is not needed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您希望创建的属性不是已经由其他属性或语言强制执行的。例如，如果我们使用PHP 7引入的标量类型系统，我们之前的整数示例就不需要了。
- en: 'As an example, we will take something from the paper. Say we just wrote a function
    that reverses the order of elements in an array. The authors propose that this
    function should have the following properties:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们将从论文中选取一些内容。假设我们刚刚编写了一个函数，用于反转数组中元素的顺序。作者建议这个函数应该具有以下属性：
- en: The `reverse([x]) == [x]` property reverses an array with a single element and
    should yield the exact same array
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse([x]) == [x]` 属性，反转一个只有一个元素的数组应该产生完全相同的数组'
- en: The `reverse(reverse(x)) == x` property reverses an array twice and should yield
    the exact same array
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse(reverse(x)) == x` 属性，两次反转数组应该产生完全相同的数组'
- en: The `reverse(array_merge(x, y)) == array_merge(reverse(y), reverse(x))` property,
    reversing two merged arrays should yield the same result as merging the second
    array reversed to the first one reversed
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse(array_merge(x, y)) == array_merge(reverse(y), reverse(x))` 属性，反转两个合并的数组应该产生与将第二个数组反转后合并到第一个数组反转的结果相同'
- en: The first two properties will guarantee that our function does not mess with
    the values. If we were to have only those two properties, a function doing absolutely
    nothing besides returning its parameter will pass the test with flying colors.
    This is where the third property comes into play. The way it is written ensures
    that our function does what we expect of it because there is no other way the
    property will hold.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个属性将确保我们的函数不会干扰值。如果我们只有这两个属性，一个除了返回参数之外什么都不做的函数将会轻松通过测试。这就是第三个属性发挥作用的地方。它的写法确保我们的函数按我们期望的方式工作，因为没有其他方式属性会成立。
- en: What is interesting about those properties is that at no time do they perform
    any kind of computation. They are simple to implement and understand, meaning
    it is nearly impossible to introduce bugs in them. If you were to test your functions
    by somehow re-implementing the computation they are doing, it would kind of defeat
    the whole point.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是这些属性在任何时候都不执行任何计算。它们很容易实现和理解，这意味着几乎不可能在其中引入错误。如果您通过某种方式重新实现它们正在进行的计算来测试您的函数，这将有点违背初衷。
- en: Although pretty simple, this example shows perfectly that it is not easy to
    find valuable properties that are both meaningful and simple enough to ensure
    they will have no bugs. If you have trouble finding good properties, I encourage
    you to take an overview and think of your function in terms of the business logic
    you are trying to implement. Do not think in terms of inputs and outputs but try
    to see the broader picture.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管非常简单，这个例子完美地展示了找到有价值的属性既有意义又足够简单以确保它们不会有错误并不容易。如果您在找到好的属性方面有困难，我鼓励您以业务逻辑的角度来审视您的函数。不要以输入和输出为出发点，而是尝试看到更广阔的画面。
- en: Implementing the add function
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现add函数
- en: A great explanation on why property based testing is a valuable tool can be
    found in a slide deck available online at [http://www.slideshare.net/ScottWlaschin/an-introduction-to-property-based-testing](http://www.slideshare.net/ScottWlaschin/an-introduction-to-property-based-testing).
    There is also a companion blog post with some more information at [http://fsharpforfunandprofit.com/posts/property-based-testing-2/](http://fsharpforfunandprofit.com/posts/property-based-testing-2/).
    I will try to summarize them quickly here.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 关于为什么基于属性的测试是一种有价值的工具的很好的解释可以在网上的幻灯片中找到[http://www.slideshare.net/ScottWlaschin/an-introduction-to-property-based-testing](http://www.slideshare.net/ScottWlaschin/an-introduction-to-property-based-testing)。还有一个伴随的博客帖子，提供了更多信息[http://fsharpforfunandprofit.com/posts/property-based-testing-2/](http://fsharpforfunandprofit.com/posts/property-based-testing-2/)。我将在这里快速总结它们。
- en: A developer is asked to write a function adding two values with some tests.
    He writes two tests where the expected result is 4; everything is fine. The person
    asking for the function asks for more tests; they fail for the reason that the
    function was always returning the value 4 instead of doing anything meaningful.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要求开发人员编写一个添加两个值的函数，并进行一些测试。他编写了两个预期结果为4的测试；一切正常。要求函数的人要求进行更多的测试；它们失败的原因是函数总是返回值4，而没有做任何有意义的事情。
- en: The developer rewrites the function so that the tests pass again, but a new
    round of tests continues to fail. What was really done was to incorporate the
    results to the new tests as special cases in the original function. The excuse
    advanced by the developer is that they were following the TDD best practices saying
    that you need to *write the minimal code that will make the test pass*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员重写函数，使测试再次通过，但新一轮的测试继续失败。实际上所做的是将结果合并到原始函数中的新测试中作为特殊情况。开发人员提出的借口是，他们遵循了TDD的最佳实践，即需要*编写最小的代码来使测试通过*。
- en: What is happening might seem stupid for such a simple function, but if you replace
    it with some kind of complicated business logic that needs to be implemented,
    such a story is probably more common that you would think and is also one of the
    pitfalls of TDD as stated by its opponent. If you follow TDD to the letter, your
    code will never be better than your tests.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情可能对于这样一个简单的功能来说似乎很愚蠢，但是如果你用一些需要实现的复杂业务逻辑来替换它，这样的故事可能比你想象的更常见，也是TDD的一个缺点，正如其反对者所说的。如果你严格遵循TDD，你的代码永远不会比你的测试更好。
- en: The slide deck continues by introducing tests where each value is a random integer
    and the function is tested by comparing the result to `x + y`. In this case, there
    is no way the developer could cheat using special cases in its function. There
    is obviously another issue, however, you re-implemented the function inside the
    test to verify the result.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 幻灯片继续介绍了一些值为随机整数的测试，并通过将结果与`x + y`进行比较来测试函数。在这种情况下，开发人员无法使用函数中的特殊情况进行欺骗。然而，显然还有另一个问题，即在测试中重新实现了函数以验证结果。
- en: Enter property based testing. The first property implemented is `add(x, y) ==
    add(y, x)`. The developer implements the `add` property as being `x * y`, which
    correctly passes the test.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 进入基于属性的测试。首先实现的属性是`add(x, y) == add(y, x)`。开发人员将`add`属性实现为`x * y`，这样就能正确通过测试。
- en: This means we need a second property, for example, the `add(add(x, 1), 1) ==
    add(x, 2)` property. This can also be beaten with the implementation of `x - y`,
    but in this case the first test will fail. This is why the developer's newest
    implementation is simply to return `0`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要第二个属性，例如`add(add(x, 1), 1) == add(x, 2)`属性。这也可以通过实现`x - y`来实现，但在这种情况下，第一个测试将失败。这就是为什么开发人员的最新实现只是返回`0`。
- en: At this point, a final property, `add(x, 0) == x` is added. The developer is
    finally forced to write a correct implementation for our function as he isn't
    able to find a way to cheat it this time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，最后一个属性`add(x, 0) == x`被添加。开发人员最终被迫为我们的函数编写正确的实现，因为这一次他无法找到欺骗的方法。
- en: 'If we go back to our final three properties and compare them to what we know
    about the addition properties in mathematics, we can draw the following comparison:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到我们的最后三个属性，并将它们与我们对数学中加法属性的了解进行比较，我们可以得出以下比较：
- en: In the `add(x, 0) == x` property, 0 is the *identity* of the addition
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`add(x, 0) == x`属性中，0是加法的*单位元*
- en: In the `add(x, y) == add(y, x)` property, the addition is *commutative*
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`add(x, y) == add(y, x)`属性中，加法是*交换的*
- en: In the `add(add(x, 1), 1) == add(x, 2)` property, the addition is *associative*
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`add(add(x, 1), 1) == add(x, 2)`属性中，加法是*结合的*
- en: All three properties are in fact well-known properties of the operation we were
    trying to implement. As we said earlier, taking a step back and reflecting about
    the what instead of the who is a great help when coming up with properties.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个属性实际上都是我们试图实现的操作的众所周知的属性。正如我们之前所说的，退一步反思“是什么”而不是“谁”，对于提出属性时是一个很好的帮助。
- en: 'The remainder of the slides are a great and interesting read, but as I don''t
    want to plagiarize the entire content, I''d rather encourage you to go read it
    online. I will just take three more pieces of advice from them as I find them
    really great and easy to remember:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 幻灯片的其余部分是一次很好且有趣的阅读，但是我不想剽窃整个内容，我更愿意鼓励你去网上阅读。我只会从中选取三条建议，因为我觉得它们真的很好，也很容易记住：
- en: '**Different paths, same destination**: Come up with two different ways to get
    the same results using the function under tests, like we did for the third property
    of `reverse`.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同的路径，同一个目的地**：想出两种不同的方法来使用被测试的函数得到相同的结果，就像我们为`reverse`的第三个属性所做的那样。'
- en: '**There and back again**: If your function has an inverse, try applying both
    to see if you get the initial value back, like we did for the second property
    of `reverse`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来回一趟**：如果你的函数有一个反函数，尝试同时应用两者，看看是否能得到初始值，就像我们为`reverse`的第二个属性所做的那样。'
- en: '**Some things never change**: If some properties of your input are not changed
    by the function, test for them, for example, array length or type of the data.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有些事情永远不会改变**：如果您的输入的某些属性不会被函数改变，那么对它们进行测试，例如数组长度或数据类型。'
- en: With all this, you should now have a good idea about how to find good properties
    for your functions. It is still a difficult task, but in the end you'll probably
    save a lot of time as you won't have to add edge cases as you find them.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一切，现在您应该对如何为您的函数找到好的属性有了一个很好的想法。这仍然是一项困难的任务，但最终您可能会节省很多时间，因为您不必在找到它们时添加边缘情况。
- en: If you'd like to have a good example of a real-life bug that was discovered
    thanks to property-based testing, John Hughes himself gave a great talk with some
    nice examples at [https://vimeo.com/68383317](https://vimeo.com/68383317).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要一个真实生活中由于基于属性的测试而被发现的错误的很好例子，约翰·休斯本人在[https://vimeo.com/68383317](https://vimeo.com/68383317)上做了一个很棒的演讲，并举了一些很好的例子。
- en: The PhpQuickCheck testing library
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PhpQuickCheck测试库
- en: 'Having seen the theoretical aspects of property-based testing in general, we
    can now shift our attention to a PHP-specific implementation-the `PhpQuickCheck`
    library. The source code is available on GitHub at [https://github.com/steos/php-quickcheck](https://github.com/steos/php-quickcheck)
    and the library can be installed using **`composer`** command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们已经看到了属性测试的理论方面之后，现在我们可以将注意力转向PHP特定的实现-`PhpQuickCheck`库。源代码可以在GitHub上找到[https://github.com/steos/php-quickcheck](https://github.com/steos/php-quickcheck)，并且可以使用**`composer`**命令进行安装：
- en: '[PRE2]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You might need to change your `minimum-stability` setting to dev in your `composer.json`
    file, or add the dependency manually as explained on the GitHub page, because
    there is currently no stable release of the library.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要在您的`composer.json`文件中将`minimum-stability`设置为`dev`，或者根据GitHub页面上的说明手动添加依赖项，因为目前该库还没有稳定版本。
- en: The project was started in September 2014 and most of its development took place
    until November of the same year. Since then, not many new features have been added,
    mostly improvement of the coding styles and some minor improvements.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目始于2014年9月，大部分开发工作都在同年11月之前进行。自那时以来，没有添加太多新功能，主要是改进编码风格和一些小的改进。
- en: Although we can't say the project is really alive today, it is one of the first
    serious attempts to have a `QuickCheck` library in PHP and it has some functionalities
    that are not yet available in its main contender and will be discussed later.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不能说该项目今天真的还很活跃，但它是PHP中第一个严肃尝试拥有`QuickCheck`库的项目之一，并且它具有一些功能，这些功能在其主要竞争对手中尚不可用，稍后将进行讨论。
- en: 'But let''s not get ahead of ourselves; let''s get back to our first example,
    the reverse function. Imagine we wrote the `array_reverse` function available
    in PHP and we needed to test it. This is how it would look with the `PhpQuickCheck`
    library:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，让我们不要急于行事；让我们回到我们的第一个例子，即反转函数。想象一下，我们编写了PHP中可用的`array_reverse`函数，并且我们需要对其进行测试。使用`PhpQuickCheck`库，它将如下所示：
- en: '[PRE3]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `check` static method accepts the amount of test data it needs to generate
    as the first argument. The second argument is an instance of `Generator` function;
    usually, you will use `Generator::forAll` to create it in the example. The last
    part is an array of options you can pass in the random generator `seed` variable,
    the `max_size` function for the generated data (the meaning of this value depends
    on the generator used), or finally the `echo` options which will display a dot
    (`.`) for each passed test.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`check`静态方法接受需要生成的测试数据量作为第一个参数。第二个参数是`Generator`函数的实例；通常，您将使用`Generator::forAll`在示例中创建它。最后一部分是您可以传递的选项数组，包括随机生成器`seed`变量，生成的数据的`max_size`函数（此值的含义取决于所使用的生成器），或者最后的`echo`选项，它将显示一个点（`.`）表示每个通过的测试。'
- en: The `forAll` instance accepts an array representing the arguments to your test
    and the test itself. In our case, for the first test, we generate random integers
    and for the other two, random integer arrays. The test must return a Boolean value: `true`
    for passed, `false` otherwise.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`forAll`实例接受一个表示测试参数和测试本身的数组。在我们的例子中，对于第一个测试，我们生成随机整数，对于另外两个测试，我们生成随机整数数组。测试必须返回一个布尔值：`true`表示通过，否则为`false`。'
- en: 'If you were to run our little example, it would display a dot for each random
    data generated, because we passed the `echo` option. The resulting variable contains
    information about the test results themselves. In our case, if you displayed `$merge`,
    it would show:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行我们的小例子，它会显示每个生成的随机数据的一个点，因为我们传递了`echo`选项。结果变量包含有关测试结果本身的信息。在我们的情况下，如果您显示`$merge`，它将显示：
- en: '[PRE4]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `seed` instance will be different on each run except if you pass one as
    parameter. Reusing the `seed` instance allows you to create the exact same test
    data. This can be useful to check whether a particular edge case is correctly
    fixed after being discovered.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`seed`实例在每次运行时都会不同，除非您将其作为参数传递。重用`seed`实例允许您创建完全相同的测试数据。这对于检查特定边缘情况是否在被发现后被正确修复非常有用。'
- en: 'An interesting feature is automatically determining which generator to use
    based on type annotations. You can do so using methods on the `Annotation` class:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的功能是根据类型注释自动确定要使用哪个生成器。您可以使用`Annotation`类上的方法来实现：
- en: '[PRE5]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This feature can, however, only work with annotation right now and type hints
    will be ignored.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个功能目前只能与注释一起使用，类型提示将被忽略。
- en: As you can see with those small examples, the `PhpQuickCheck` library relies
    heavily on static functions. The codebase in itself is also sometimes a bit hard
    to understand and the library lacks good documentation and an active community.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这些小例子中所看到的，`PhpQuickCheck`库在很大程度上依赖于静态函数。代码库本身有时也有点难以理解，而且该库缺乏良好的文档和活跃的社区。
- en: All in all, I don't think I would recommend using this over the option we'll
    see next. I just wanted to present the library to you as a possible alternative
    and, who knows, its status might change in the future.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我认为我不会推荐使用这个选项，我们将在下面看到的选项可能更好。我只是想向您介绍这个库作为一个可能的替代方案，谁知道，它的状态可能会在未来发生变化。
- en: Eris
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eris
- en: '**Eris** development started out in November 2014, roughly at the time the
    `PhpQuickCheck` library got its last big feature introduced. As we will see, the
    coding style is definitively more modern. Everything is cleanly organized in namespace
    and helpers take the form of functions instead of static methods.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**Eris**的开发始于2014年11月，大约是`PhpQuickCheck`库引入最后一个重大功能的时间。正如我们将看到的，编码风格明显更现代。一切都清晰地组织在命名空间中，辅助函数采用函数的形式而不是静态方法。'
- en: 'As usual, you can get Eris using the **`composer`** command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，您可以使用**`composer`**命令获取Eris：
- en: '[PRE6]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The documentation is available online at [http://eris.rtfd.org/](http://eris.rtfd.org/)
    and it is quite complete. The only gripe I have with it is that the sole examples
    are for people using PHPUnit to run their test suites. It should be doable to
    use it with other tests runners, but this is something that isn't documented for
    now.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可在线获取，网址为[http://eris.rtfd.org/](http://eris.rtfd.org/)，并且非常完整。我对它唯一的抱怨是，唯一的示例是为使用PHPUnit运行其测试套件的人准备的。应该可以使用其他测试运行器，但目前尚未有文档记录。
- en: 'If we wanted to use Eris to test the properties we defined for `array_reduce`,
    our test case would look something like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用Eris来测试我们为`array_reduce`定义的属性，我们的测试用例将如下所示：
- en: '[PRE7]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code is somewhat similar to what we wrote for the `PhpQuickCheck` library
    but leverages methods that are added by the provided trait to our test case and
    generator functions instead of static methods. The `forAll` method accepts a list
    of generators representing the arguments to our test function. You can subsequently
    use the `then` keyword to define the function. You have access to all asserters
    provided by PHPUnit.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码与我们为`PhpQuickCheck`库编写的代码有些相似，但利用了由提供的trait添加到我们的测试用例和生成器函数中的方法，而不是静态方法。`forAll`方法接受表示测试函数参数的生成器列表。随后，您可以使用`then`关键字来定义函数。您可以访问PHPUnit提供的所有断言。
- en: The documentation explains in detail how you can configure various aspects of
    the library, such as the amount of generated test data, limiting the execution
    time, and so on. Each generator is also detailed at length with various examples
    and use cases.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 文档详细解释了您如何配置库的各个方面，例如生成的测试数据量，限制执行时间等。每个生成器也都有详细的说明，包括各种示例和用例。
- en: 'Let''s see what happens when we have a failing test case. Imagine we want to
    prove that no strings are also a numerical value; we could write the following
    test:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们有一个失败的测试用例时会发生什么。想象一下，我们想证明没有字符串也是一个数值；我们可以编写以下测试：
- en: '[PRE8]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see how we raised the number of iterations using the `limitTo` function
    to 1,000 from the default of 100\. This is because a lot of strings are in fact
    not numerical values and without this raise, I was only able to get a failure
    one test out of three. Even with this higher limit, it is still possible that
    sometimes all test data will pass the test without failures.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们使用`limitTo`函数将迭代次数从默认的100提高到1,000。这是因为实际上有很多字符串并不是数值，如果不提高迭代次数，我只能得到三次测试中的一次失败。即使有了更高的限制，有时所有的测试数据仍可能通过测试而没有失败。
- en: 'This is the kind of output you would get:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你会得到的输出类型：
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The test failed after 160 iterations with the string `"9"`. Eris also gives
    you the command to run if you want to reproduce exactly this failing test by seeding
    the random generator manually:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 测试在160次迭代后失败，字符串为`"9"`。Eris还会给出命令，如果您想通过手动设置随机生成器来精确重现此失败的测试：
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the library is fairly easy to use when your tests are written
    for PHPUnit. Otherwise, you might need to do some adaptation but I think it is
    worth your time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，当您的测试是为PHPUnit编写时，该库非常易于使用。否则，您可能需要做一些调整，但我认为这值得您的时间。
- en: Closing words
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束语
- en: The `QuickCheck` library is easier to use in strictly typed functional programming
    language because it is sufficient to declare generators for certain types and
    some properties for your functions, and nearly everything else can be done automatically.
    The `PhpQuickCheck` library tries to emulate this behavior but the result is a
    bit tedious to use.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuickCheck`库在严格类型的函数式编程语言中更容易使用，因为只需为某些类型声明生成器和一些函数的属性，几乎其他所有事情都可以自动完成。`PhpQuickCheck`库试图模拟这种行为，但结果有点麻烦。'
- en: However, this doesn't mean you can't use property-based testing effectively
    in PHP! Once you have created your generators, the framework will use it to generate
    as much test data as you let it, possibly uncovering edge cases you would never
    have thought of. For example, there is a bug in the `DateTime` method's implementation
    in PHP that arises on leap years and could easily be overlooked when creating
    test data manually. See the *Testing the language* part at [http://www.giorgiosironi.com/2015/06/property-based-testing-primer.html](http://www.giorgiosironi.com/2015/06/property-based-testing-primer.html) (by
    the creator of Eris) for more details on the issue.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着您不能有效地在PHP中使用基于属性的测试！一旦您创建了生成器，框架将使用它生成尽可能多的测试数据，可能会发现您从未想到的边缘情况。例如，在PHP中，`DateTime`方法的实现存在一个在闰年时出现的bug，手动创建测试数据时很容易忽略。有关此问题的更多详细信息，请参阅Eris的创建者在[http://www.giorgiosironi.com/2015/06/property-based-testing-primer.html](http://www.giorgiosironi.com/2015/06/property-based-testing-primer.html)中的*测试语言*部分。
- en: Writing properties can be challenging, especially in the beginning. But more
    often than not, it helps you reason about the feature you are implementing and
    will probably lead to better code because you took the time to think about it
    from a different angle.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 编写属性可能具有挑战性，特别是在开始阶段。但往往它有助于您思考您正在实现的功能，并且可能会导致更好的代码，因为您花时间从不同的角度考虑它。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we had a quick look at what can be done on the testing front
    when you use a more functional approach to programming. As we saw, functional
    code is often easier to test because it enforces what is considered best practice
    for testing when doing imperative coding.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速了解了在使用更功能化的编程方法时可以在测试方面做些什么。正如我们所看到的，功能化代码通常更容易测试，因为它强制执行了在进行命令式编码时被认为是最佳实践的测试。
- en: By having no side-effects and explicit dependencies, you can avoid most of the
    issues you usually encounter when writing tests. This results in less time spent
    testing and more time to concentrate on your application.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过没有副作用和明确的依赖关系，您可以避免在编写测试时通常遇到的大部分问题。这将导致测试时间减少，更多时间集中在应用程序上。
- en: We also discovered property-based testing, which is a great way to discover
    issues related to edge cases. It also allows us you to take a step back and think
    about the properties you want to enforce for your functions, which is akin to
    creating a specification for them. This approach is particularly effective when
    doing TDD as it forces you to think about what you want instead of how to do it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现了基于属性的测试，这是发现与边缘情况相关问题的好方法。它还允许我们退一步，思考您想要强制执行的函数属性，这类似于为它们创建规范。这种方法在进行TDD时特别有效，因为它迫使您思考您想要什么，而不是如何做。
- en: Now that we have discussed testing to ensure our functions do what they should,
    we will learn about code optimization in order to allow for application performance
    in the next chapter. A well-tested codebase will help you do the necessary refactoring
    to achieve better speed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了测试以确保我们的函数执行应该做的事情，接下来我们将学习关于代码优化，以便在应用程序性能方面进行。经过充分测试的代码库将帮助您进行必要的重构，以实现更好的速度。
