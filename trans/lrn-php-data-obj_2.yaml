- en: 'Chapter 2. Using PHP Data Objects: First Steps'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。使用PHP数据对象：第一步
- en: In the previous chapter, we had a brief overview of what PDO is, how to connect
    to your favourite database using PDO, how to issue simple queries and how to handle
    errors. Now that you are convinced that PDO is a good thing and are thinking of
    using it actively, we will be delving into all the features it has to offer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要概述了PDO是什么，如何使用PDO连接到您喜欢的数据库，如何发出简单的查询以及如何处理错误。现在您已经确信PDO是一个好东西，并且正在考虑积极使用它，我们将深入了解它所提供的所有功能。
- en: In this chapter, we will look more closely at creating connections to a database
    using PDO and connection strings (data source names), the `PDOStatement` class,
    and how to traverse result sets. We will also create a small library management
    application, which will allow us to manage a collection of books of your home
    library. The application will be able to list books and authors as well as add
    and edit them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更仔细地研究使用PDO和连接字符串（数据源名称）创建数据库连接，`PDOStatement`类以及如何遍历结果集。我们还将创建一个小型的图书管理应用程序，它将允许我们管理您家中图书的收藏。该应用程序将能够列出书籍和作者，并添加和编辑它们。
- en: We will start by having a look at connection strings, since without them, we
    will not be able to connect to any database. We will then create a sample database,
    on which all the examples in this book will be based.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看一下连接字符串，因为没有它们，我们将无法连接到任何数据库。然后我们将创建一个示例数据库，本书中的所有示例都将基于此数据库。
- en: We will depart from the simplistic, imaginary cars' database and create a real
    working database with several tables. However, now we will be dealing with the
    classical example of books and authors. We chose this example because such entities
    are more common. The relational model will be relatively simple, so that you will
    be able to follow the examples easily, if you have already come across such a
    database elsewhere.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将离开简单的、想象中的汽车数据库，并创建一个真正的工作数据库，其中包含几个表。但是，现在我们将处理书籍和作者的经典示例。我们选择这个例子是因为这样的实体更常见。关系模型将相对简单，这样您就可以轻松地跟随示例，如果您已经在其他地方遇到过这样的数据库。
- en: Connection Strings
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接字符串
- en: Connection strings, or data source names (abbreviated DSN) as they are called
    in the PDO documentation, are PHP strings that carry such information as the name
    of the database management system and of the database itself, as well as other
    connection parameters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串或数据源名称（在PDO文档中称为DSN）是PHP字符串，其中包含数据库管理系统的名称和数据库本身的名称，以及其他连接参数。
- en: Their advantage over using traditional methods of creating database connection
    is that you don't have to modify your code if you change the database management
    system. A connection string can be defined in a configuration file and that file
    gets processed by your application. Should your database (data source) change,
    you just edit that configuration file and the rest of your code is kept intact.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 它们相对于使用传统的方法创建数据库连接的优势在于，如果更改数据库管理系统，您无需修改代码。连接字符串可以在配置文件中定义，并且该文件由您的应用程序处理。如果您的数据库（数据源）更改，您只需编辑该配置文件，其余代码将保持完整。
- en: 'The connection strings used in PDO differ due to the existence of different
    database management systems. However, they always have a common prefix, which
    denotes the underlying database driver. Remember the MySQL, SQLite, and PostgreSQL
    examples in the [Chapter 1](ch01.html "Chapter 1. Introduction"). The three connection
    strings looked like the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不同的数据库管理系统的存在，PDO中使用的连接字符串不同。但是，它们始终具有一个共同的前缀，表示底层数据库驱动程序。请记住[第1章](ch01.html
    "第1章。介绍")中的MySQL、SQLite和PostgreSQL示例。三个连接字符串看起来像下面这样：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we can see, the prefix (the substring before the first semicolon) always
    keeps the name of the PDO driver. Since we don't have to use different functions
    to create a connection with PDO, this prefix tells us which internal driver should
    be used. The rest of the string is parsed by that driver to further initiate the
    connection. In these cases we supplied the database name; for MySQL and PostgreSQL;
    we also supplied the host name on which the server runs. (As SQLite is a local
    database engine, such a parameter would not make sense.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前缀（第一个分号之前的子字符串）始终保留PDO驱动程序的名称。由于我们不必使用不同的函数来创建与PDO的连接，这个前缀告诉我们应该使用哪个内部驱动程序。字符串的其余部分由该驱动程序解析以进一步初始化连接。在这些情况下，我们提供了数据库名称；对于MySQL和PostgreSQL；我们还提供了服务器运行的主机名。（由于SQLite是一个本地数据库引擎，这样的参数是没有意义的。）
- en: 'If you want to specify additional parameters, you should consult your database
    manual ([www.php.net/pdo](http://www.php.net/pdo) is always a good place to start).
    For example, the MySQL PDO driver understands the following parameters:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想指定其他参数，您应该查阅您的数据库手册（[www.php.net/pdo](http://www.php.net/pdo)始终是一个很好的起点）。例如，MySQL
    PDO驱动程序理解以下参数：
- en: '**host** - the hostname on which the server runs (*localhost* in our example)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**host** - 服务器运行的主机名（在我们的示例中为*localhost*）'
- en: '**port** - the port number where the database server is listening (defaults
    to *3306)*'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**port** - 数据库服务器正在侦听的端口号（默认为*3306*）'
- en: '**dbname** - the name of the database (*cars* in our example)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dbname** - 数据库的名称（在我们的示例中为*cars*）'
- en: '**unix_socket** - the MySQL UNIX socket (instead of host and/or port).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**unix_socket** - MySQL的UNIX套接字（而不是主机和/或端口）。'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `SQLite:` prefix denotes a connection to a SQLite 3 database. To connect
    to SQLite 2 database, you have to use `SQLite2:` prefix. Please see [http://www.php.net/manual/en/ref.pdo-sqlite.connection.php](http://www.php.net/manual/en/ref.pdo-sqlite.connection.php)
    for details.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`SQLite:`前缀表示连接到SQLite 3数据库。要连接到SQLite 2数据库，您必须使用`SQLite2:`前缀。有关详细信息，请参阅[http://www.php.net/manual/en/ref.pdo-sqlite.connection.php](http://www.php.net/manual/en/ref.pdo-sqlite.connection.php)。'
- en: As you might have noticed, different drivers use different character to delimit
    the parameters—such as a semicolon in MySQL and space in PostgreSQL.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，不同的驱动程序使用不同的字符来分隔参数——例如MySQL中的分号和PostgreSQL中的空格。
- en: Creating the Sample Database
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建示例数据库
- en: Suppose that you have a good library at home and you want your computer to help
    you manage it. You decide to create a web-based database using PHP and, of course,
    PDO. From now on, the examples will be for MySQL and SQLite databases.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在家里有一个很好的图书馆，您希望计算机帮助您管理它。您决定使用PHP和当然PDO创建一个基于Web的数据库。从现在开始，示例将是针对MySQL和SQLite数据库的。
- en: The Data Model
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据模型
- en: 'As our database is really simple, we will just have two entities in it: authors
    and books. Hence, we will be creating two tables with the same names. Now, let''s
    think what properties each of these entities will have.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的数据库非常简单，因此我们只会在其中有两个实体：作者和书籍。因此，我们将创建两个同名的表。现在，让我们考虑每个实体将具有哪些属性。
- en: Authors will have their first name, their last name, and a short biography.
    The table will need to have a primary key which we will call *id*. We will use
    it to refer to an author from the `books` table.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作者将有他们的名字、姓氏和简短的传记。表格将需要一个我们称之为*id*的主键。我们将使用它来从`books`表中引用作者。
- en: Books are written by authors. (Sometimes they are written by more than one author,
    but we will consider books written by only one author here.) So we will need a
    field for the author’s ID, as well as the book’s title, ISBN number, publisher
    name, and year of publication. Also, we will include a short summary of what the
    book is about.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 书是由作者写的。（有时它们是由多位作者写的，但我们将在这里只考虑由一位作者写的书。）因此，我们将需要一个字段来存储作者的ID，以及书的标题、ISBN号、出版商名称和出版年份。此外，我们将包括书的简短摘要。
- en: We need for a separate table for authors, because an author might have written
    more than one book. Also, our example would be really simple otherwise! Thus,
    we opted for a two-table database structure. If we were to consider books written
    by more than one author, we would need three tables, which would make the example
    very complicated.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个单独的作者表，因为一个作者可能写了多本书。否则，我们的示例将非常简单！因此，我们选择了一个两表数据库结构。如果我们考虑由多位作者编写的书籍，我们将需要三个表，这将使示例变得非常复杂。
- en: Creating the MySQL Database
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建MySQL数据库
- en: 'After you have launched your MySQL command line client, you will see the `mysql>`
    prompt, where you will be able to issue commands to create the database and the
    tables in it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动了MySQL命令行客户端后，您将看到`mysql>`提示符，您可以在其中发出命令来创建数据库和其中的表：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, we have created a database and called it `pdo`. We also created
    two tables: books and authors, just as we had planned. Now let''s see how we do
    that in SQLite. As we cannot create the database inside the SQLite command line
    client, we launch it like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经创建了一个名为`pdo`的数据库。我们还创建了两个表：books和authors，就像我们计划的那样。现在让我们看看如何在SQLite中做到这一点。由于我们无法在SQLite命令行客户端内创建数据库，我们会这样启动它：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, the SQL is slightly different for SQLite—the primary keys are
    declared without the `NOT NULL` and `auto_increment` options. In SQLite, a column
    declared as `INTEGER PRIMARY KEY` is automatically incremented. Now let''s insert
    some values into our database. The syntax will be the same for MySQL and SQLite
    so here we will just present the MySQL command line client example. We will start
    with authors, because we will need their primary key values for inserting into
    the books table:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，SQLite的SQL略有不同——主键声明时没有`NOT NULL`和`auto_increment`选项。在SQLite中，声明为`INTEGER
    PRIMARY KEY`的列会自动递增。现在让我们向数据库插入一些值。MySQL和SQLite的语法将是相同的，所以这里我们只呈现MySQL命令行客户端的示例。我们将从作者开始，因为我们需要他们的主键值来插入到书籍表中：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have inserted three authors, let''s add some books. But before
    we do, we should know which *author* has which *id*. A simple `SELECT` query will
    help us:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经插入了三位作者，让我们添加一些书籍。但在这样做之前，我们应该知道哪个*作者*有哪个*id*。一个简单的`SELECT`查询将帮助我们：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can finally use this information to add three books, each written by
    one of these authors:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于可以使用这些信息添加三本书，每本书都是由这些作者中的一位写的：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have filled the `authors` and `books` tables, we may begin to create
    the first page of our small library management web application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经填充了`authors`和`books`表，我们可以开始创建我们小型图书馆管理网络应用的第一个页面。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The data used is based on real books published by Packt Publishing Ltd (the
    publisher that brought to you this book you are reading now). To find out more,
    visit their site at [http://www.packtpub.com](http://www.packtpub.com)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所使用的数据基于由Packt Publishing Ltd出版的真实书籍（这是为您带来正在阅读的这本书的出版商）。要了解更多信息，请访问他们的网站[http://www.packtpub.com](http://www.packtpub.com)
- en: Designing Our Code
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的代码
- en: Good application architecture is another key factor of an application, besides
    the correct data model. As the application that we are going to develop in this
    chapter, is relatively small, this task is not very complicated. First, we will
    create two pages that will list books and authors. To begin with, we should think
    about how these pages would look. To make our simple example small and compact,
    we will present a header on all pages that will contain links to the books list
    and the authors list. Later we will add two more pages that will allow us to add
    an author and a book.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的应用架构是应用的另一个关键因素，除了正确的数据模型。由于我们将在本章开发的应用程序相对较小，因此这项任务并不是很复杂。首先，我们将创建两个页面，分别列出书籍和作者。首先，我们应该考虑这些页面的外观。为了使我们的简单示例小巧紧凑，我们将在所有页面上呈现一个标题，其中包含指向书籍列表和作者列表的链接。稍后，我们将添加另外两个页面，允许我们添加作者和书籍。
- en: 'Of course, we should create a common include file that will define the common
    functions such as the header and footer display and the connection to the database.
    Our example is really small, so we will not be using any template system or even
    object-oriented syntax. (Indeed, these topics are beyond the scope of this book.)
    So, to summarize:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们应该创建一个通用的包含文件，用于定义共同的函数，如标题和页脚显示以及与数据库的连接。我们的示例非常小，因此我们将不使用任何模板系统甚至面向对象的语法。（事实上，这些主题超出了本书的范围。）因此，总结一下：
- en: All common functions (including code to create the PDO connection object) will
    be kept in an include file (called `common.inc.php)`.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有通用函数（包括创建PDO连接对象的代码）将保存在一个包含文件中（称为`common.inc.php`）。
- en: Every page will be held in a separate file, which includes the `common.inc.php`
    file.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个页面将保存在一个单独的文件中，其中包括`common.inc.php`文件。
- en: Every page will process data and display it (so that we have no separation of
    data processing and data presentation, as one would expect from an application
    designed with the model-view-controller pattern in mind).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个页面将处理数据并显示数据（因此我们没有数据处理和数据呈现的分离，这是人们从设计为模型-视图-控制器模式的应用程序所期望的）。
- en: 'Now that we have this small plan, we can begin with our `common.inc.php` file.
    As we have just discussed, for now, it will contain the functions to display the
    header and the footer, as well as the code to create the connection object. Let''s
    keep the PDO object in a global variable called `$conn` and call our header function
    `showHeader()`, and the footer function `showFooter()`. Also, we will keep the
    database connection string, user name, and password in this include file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个小计划，我们可以开始编写我们的`common.inc.php`文件。正如我们刚刚讨论的，目前，它将包含显示页眉和页脚的函数，以及创建连接对象的代码。让我们将PDO对象保存在一个名为`$conn`的全局变量中，并调用我们的页眉函数`showHeader()`，页脚函数`showFooter()`。此外，我们将在这个包含文件中保留数据库连接字符串、用户名和密码：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, the file is really simple, and you will just have to change
    the values of the `$user` and `$pass` variables (on lines 9 and 10) to match your
    setup. For a SQLite database, you would also have to change line 8 so that it
    contains an appropriate connection string, for example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个文件非常简单，你只需要更改`$user`和`$pass`变量的值（第9行和第10行）以匹配你的设置。对于SQLite数据库，你还需要更改第8行，使其包含一个适当的连接字符串，例如：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Of course, you should change this to reflect the path to where you created the
    SQLite database. Also, the `showHeader()` function simply renders HTML code and
    passes the value of the `$title` variable via the `htmlspecialchars()` function
    so that any illegal characters (such as a less-than sign) are properly escaped.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你应该根据你创建SQLite数据库的路径进行更改。此外，`showHeader()`函数只是呈现HTML代码，并通过`htmlspecialchars()`函数传递`$title`变量的值，以便任何非法字符（如小于号）都能得到适当的转义。
- en: Save the file to your web root directory. This again depends on your web server
    setup. For example, it could be `C:\Apache\htdocs or /var/www/html`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存到您的Web根目录。这取决于您的Web服务器设置。例如，它可以是`C:\Apache\htdocs`或`/var/www/html`。
- en: Now, let's create a page that lists the books. We will have to issue the query
    and then iterate over the results to present each book in its own row. Later,
    we will create a page that will list all the authors from the database that we
    created earlier. After we finish this task, we will look at result set traversal.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个列出书籍的页面。我们将发出查询，然后遍历结果，以呈现每本书的单独行。稍后，我们将创建一个页面，列出我们之前创建的数据库中的所有作者。完成这项任务后，我们将查看结果集遍历。
- en: 'Let''s call our file `books.php` and create the code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称我们的文件为`books.php`并创建代码：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This file should be saved to the directory where the `common.inc.php` file
    is located. As you can see, there are more comments and HTML in the code, but
    there is nothing very complicated here. As we decided earlier, the code includes
    the `common.inc.php` file, then renders the page header, issues a query on the
    line #10, renders the table header, and finally iterates over every row in the
    result set to output every book''s details.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件应该保存在`common.inc.php`文件所在的目录中。正如你所看到的，代码中有更多的注释和HTML，但这里没有什么非常复杂的东西。正如我们之前决定的，代码包括`common.inc.php`文件，然后呈现页面页眉，在第10行发出查询，呈现表头，最后遍历结果集中的每一行，输出每本书的详细信息。
- en: Just as in the first chapter, we traverse the result set in a `while` row, using
    the `fetch()` method of the `PDOStatement` object (held in the `$q` variable).
    We instruct this method to return the rows as arrays indexed by table column names
    (by specifying the `PDO::FETCH_ASSOC` parameter).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在第一章中一样，我们使用`PDOStatement`对象的`fetch()`方法（保存在`$q`变量中）在`while`行中遍历结果集。我们指示该方法返回由表列名称索引的数组行（通过指定`PDO::FETCH_ASSOC`参数）。
- en: Inside the loop, we render the HTML of every row, inserting there the columns
    from our table. After the loop quits, we close the table and display the footer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内，我们呈现每一行的HTML，插入表中的列。循环结束后，我们关闭表并显示页脚。
- en: 'Now it''s time to test our first PDO-powered application. Fire up your browser
    and navigate to `http://localhost/books.php`. If you did everything correctly
    (so that your web server and database are properly setup), you should see a table
    similar to the following screenshot (although your page might look much wider,
    we resized the window before taking a screenshot so that it fits on a printed
    page):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是测试我们第一个PDO驱动的应用程序的时候了。打开你的浏览器，转到`http://localhost/books.php`。如果你做得正确（这样你的Web服务器和数据库都正确设置），你应该看到一个类似下面截图的表格（尽管你的页面可能看起来更宽，我们在截图之前调整了窗口大小，以便它适合打印页面）：
- en: '![Designing Our Code](graphics/2660-02-01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![设计我们的代码](graphics/2660-02-01.jpg)'
- en: 'Once we have ensured that our application works with MySQL, let''s see how
    it will work with SQLite. To do this, we have to edit line 8 in the `common.inc.php`
    file so that it contains the SQLite DSN:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确保我们的应用程序可以与MySQL一起工作，让我们看看它如何与SQLite一起工作。为此，我们必须编辑`common.inc.php`文件中的第8行，使其包含SQLite
    DSN：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you did everything correctly, then after refreshing your browser, you should
    see the same screen. As we discussed earlier—only one configuration option has
    to be changed when you start using another database system.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做得正确，那么刷新你的浏览器后，你应该看到相同的屏幕。正如我们之前讨论过的——当你开始使用另一个数据库系统时，只需要更改一个配置选项。
- en: 'Now, let''s create the code for the page that will list the authors. Create
    a file named `authors.php` and place it in the directory where you saved the previous
    two files. The code is practically identical to the books listing page:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为列出作者的页面创建代码。创建一个名为`authors.php`的文件，并将其放在您保存前两个文件的目录中。代码几乎与书籍列表页面相同：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This file follows the same logic: include the `common.inc.php` file, and then
    issue the query and traverse the result set. If you have done everything correctly,
    then you simply click on the **Authors** link located on the books listing page
    in your browser to get the following page:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件遵循相同的逻辑：包含`common.inc.php`文件，然后发出查询并遍历结果集。如果你做的一切都正确，那么你只需在浏览器中点击位于书籍列表页面上的**作者**链接，就可以得到以下页面：
- en: '![Designing Our Code](graphics/2660-02-02.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![设计我们的代码](graphics/2660-02-02.jpg)'
- en: 'As you can see, the page correctly presents the three authors that we added
    at the beginning of this chapter. If you want to test this with SQLite, change
    the line #10 to contain the SQLite connection string. On refreshing your browser,
    you should see the same page, but now based on the SQLite database contents.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，页面正确地呈现了我们在本章开头添加的三位作者。如果您想要使用SQLite进行测试，请将第10行更改为包含SQLite连接字符串。刷新浏览器后，您应该看到相同的页面，但现在基于SQLite数据库内容。
- en: Now that we have created these two pages and seen that using PDO is not complicated,
    let's look at some theory before we extend the application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了这两个页面，并且看到使用PDO并不复杂，让我们在扩展应用程序之前先看一些理论。
- en: PDO Statements and Result Sets
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PDO语句和结果集
- en: 'Our examples made use of two of the main classes in PHP Data Objects: the `PDO`
    class, which is used to create a connection and issue queries, and the `PDOStatement`
    class, which we use to loop through the result set. We will look at the first
    of these classes in later chapters. Here, we will examine the `PDOStatement` class
    to see what other ways of traversing the result set that it has to offer.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例使用了PHP数据对象中的两个主要类：`PDO`类，用于创建连接和发出查询，以及`PDOStatement`类，我们用它来循环遍历结果集。我们将在后面的章节中查看这两个类中的第一个。在这里，我们将检查`PDOStatement`类，看看它提供了哪些其他遍历结果集的方式。
- en: As we already know, instances of the `PDOStatement` class are returned from
    the call to `PDO::query()` method. The main purpose of this class is to provide
    an interface to the result set. In fact, we have already used its most important
    method to iterate over the result set. We only looked at one fetch style (or mode
    of the returned row), but PDO offers several styles. This class can also provide
    additional information about a result set, such as the number of rows and columns,
    and fetch the whole result set into a two-dimensional array.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的那样，从对`PDO::query()`方法的调用中返回`PDOStatement`类的实例。这个类的主要目的是提供一个接口来访问结果集。事实上，我们已经使用了它最重要的方法来遍历结果集。我们只看了一个获取样式（或返回行的模式），但PDO提供了几种样式。这个类还可以提供有关结果集的其他信息，比如行数和列数，并将整个结果集获取到一个二维数组中。
- en: 'Let''s begin by looking at some different fetch styles. We already know the
    `PDO::FETCH_ASSOC` mode that returns an array indexed by column name. The default
    operation of the `PDOStatement` object is to return an array indexed by both an
    integer index and a column name, that is the `PDO::FETCH_BOTH` fetch mode. We
    can also request only an integer-indexed array by using the `PDO::FETCH_NUM` fetch
    style. PDO also supports fetching rows as objects with the `PDO::FETCH_OBJ` mode.
    In this case the call to `PDO::fetch()method` will return an instance of the `stdClass`
    internal class with its properties populated with the row''s values. This happens
    in the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一些不同的获取样式。我们已经知道`PDO::FETCH_ASSOC`模式，它返回一个由列名索引的数组。`PDOStatement`对象的默认操作是返回一个由整数索引和列名索引的数组，即`PDO::FETCH_BOTH`获取模式。我们还可以使用`PDO::FETCH_NUM`获取样式来请求只有整数索引的数组。PDO还支持使用`PDO::FETCH_OBJ`模式将行作为对象获取。在这种情况下，对`PDO::fetch()method`的调用将返回一个`stdClass`内部类的实例，其属性填充了行的值。这在以下代码中发生：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `PDOStatement` class also allows you to set the fetch mode once for all
    subsequent calls to its `fetch()` method. This is done via the `PDOStatement::setFetchMode()`
    method, which accepts any of the `PDO::FETCH_ASSOC, PDO::FETCH_BOTH, PDO::FETCH_NUM`,
    and `PDO::FETCH_OBJ` constants. With this in mind, we can rewrite lines 23 and
    24 of the `authors.php` file to look like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`PDOStatement`类还允许您为所有后续对其`fetch()`方法的调用设置获取模式。这是通过`PDOStatement::setFetchMode()`方法完成的，该方法接受`PDO::FETCH_ASSOC,
    PDO::FETCH_BOTH, PDO::FETCH_NUM`和`PDO::FETCH_OBJ`常量中的任何一个。有了这个想法，我们可以将`authors.php`文件的第23和24行重写为以下形式：'
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can try it on your copy of the `authors.php` file and refresh the browser
    to see that this works.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`authors.php`文件的副本上尝试并刷新浏览器，看看它是否有效。
- en: 'You may have noticed that the SQLite, MySQL, and pgSQL PHP extensions all offer
    similar functionality. Indeed, we can use any of the `mysql_fetch_row(), mysql_fetch_assoc(),
    mysql_fetch_array()`, or `mysql_fetch_object()` functions to achieve the same
    effect. That''s why PDO goes further and enables us to use three additional fetch
    modes. These three modes can be only set via `PDOStatement::setFetchMode()` call,
    and here they are:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，SQLite、MySQL和pgSQL PHP扩展都提供了类似的功能。事实上，我们可以使用`mysql_fetch_row()、mysql_fetch_assoc()、mysql_fetch_array()`或`mysql_fetch_object()`函数来实现相同的效果。这就是为什么PDO更进一步，使我们能够使用三种额外的获取模式。这三种模式只能通过`PDOStatement::setFetchMode()`调用来设置，它们分别是：
- en: '`PDO::FETCH_COLUMN` allows you to instruct the `PDOStatement` object to return
    the specified column of every row. In this case, `PDO::fetch()` will return a
    scalar value. The columns are numbered starting with 0\. This happens in the following
    code snippet:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_COLUMN`允许您指示`PDOStatement`对象返回每行的指定列。在这种情况下，`PDO::fetch()`将返回一个标量值。列从0开始编号。这在以下代码片段中发生：'
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This reveals that the call to `$q->fetch()` does indeed returns scalar values
    (not arrays). Note that the column with the index 1 should be the author's last
    name, not their first name, if you are simply looking at the page with authors
    list. However, our query looks like `SELECT * FROM authors`, so it also retrieves
    the author ids, which are stored into the 0th column. You should be aware of this,
    as you may spend hours looking for the source of such a logical error.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这揭示了对`$q->fetch()`的调用确实返回标量值（而不是数组）。请注意，索引为1的列应该是作者的姓，而不是他们的名，如果您只是查看作者列表页面。然而，我们的查询看起来像是`SELECT
    * FROM authors`，所以它也检索了作者的ID，这些ID存储在第0列中。您应该意识到这一点，因为您可能会花费数小时来寻找这样一个逻辑错误的源头。
- en: '`PDO::FETCH_INTO` can be used to modify an instance of an object. Let''s rewrite
    our above example as follows:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_INTO`可以用来修改对象的实例。让我们将上面的示例重写如下：'
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Inside the `while` loop we didn't assign the `$r` variable, which is the return
    value of `$q->fetch(). $r` has been bound to this method via the call to `$q->setFetchMode()`
    before the loop.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环中，我们没有分配`$r`变量，这是`$q->fetch()`的返回值。在循环之前，通过调用`$q->setFetchMode()`将`$r`绑定到这个方法。
- en: '`PDO::FETCH_CLASS` can be used to return objects of a specified class. For
    every row, an instance of this class will be created with the properties named
    and assigned the values of the result set columns. Note that the class does not
    necessarily have these properties declared since PHP allows runtime creation of
    object properties. For example:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_CLASS`可以用来返回指定类的对象。对于每一行，将创建这个类的一个实例，并将结果集列的值命名和赋值给这些属性。请注意，该类不一定要声明这些属性，因为PHP允许在运行时创建对象属性。例如：'
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will print output similar to that for the previous example. Also, this
    fetch mode allows you to create instances by passing an array of parameters to
    their constructors:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印类似于上一个示例的输出。此外，这种获取模式允许您通过将参数数组传递给它们的构造函数来创建实例：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: (This will work only if the `SomeClass` class has been defined.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: （这只有在`SomeClass`类已经被定义的情况下才会起作用。）
- en: We would recommend using `PDOStatement::setFetchMode()` as it is more convenient
    and easier to maintain (and, of course, has more features).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用`PDOStatement::setFetchMode()`，因为它更方便，更容易维护（当然，功能也更多）。
- en: 'Describing all of these fetch modes may seem excessive, but each of them is
    useful in certain situations. Indeed, you may have noticed that the list of books
    is somewhat incomplete. It does not contain the author''s name. We will add this
    missing column, and to make our example trickier, we will make the author''s name
    clickable and link it to the author''s profile page (which we will create). This
    profile page needs the author''s ID so that we can pass it in the URL. It will
    display all the information that we have about the author, as well as the list
    of all of their books. Let''s begin with this author''s profile page:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 描述所有这些获取模式可能看起来有些多余，但在某些情况下，它们每一个都是有用的。实际上，您可能已经注意到书籍列表有些不完整。它不包含作者的名字。我们将添加这个缺失的列，并且为了使我们的示例更加棘手，我们将使作者的名字可点击，并将其链接到作者的个人资料页面（我们将创建）。这个个人资料页面需要作者的ID，以便我们可以在URL中传递它。它将显示我们关于作者的所有信息，以及他们所有书籍的列表。让我们从这个作者的个人资料页面开始：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Name this file `author.php` and save it to the directory where rest of the files
    are located.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件命名为`author.php`并将其保存到其他文件所在的目录中。
- en: 'Here are a few comments about the code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是有关代码的一些评论：
- en: 'We handle the author''s ID (line #13) by explicitly casting it to an integer
    so as to prevent a possible security hole. We later pass the `$id` variable to
    the text of the query without quoting as it''s OK to do so with numeric values.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过将作者的ID（第13行）显式转换为整数来处理它，以防止可能的安全漏洞。我们稍后将`$id`变量传递给查询文本，而不用引号引用，因为对于数字值来说这样做是可以的。
- en: 'We will discuss the call to `$q->closeCursor(); $q = null` on line #13 in the
    following chapters. Here we will just note that it''s a good idea to call this
    method between queries executed on the same connection object and then set it
    to null. Our example would not work without it. Also note that we don''t need
    this after the last query.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中讨论第13行中对`$q->closeCursor(); $q = null`的调用。在这里我们只想指出，调用这个方法是一个好主意，可以在同一个连接对象上执行查询之间调用它，然后将其设置为null。我们的示例如果没有它将无法工作。还要注意的是，在最后一个查询之后我们不需要这样做。
- en: 'We also do simple error handling here: we check whether the author ID is invalid.
    If it is invalid, we display an error message and then exit. (See lines 22 to
    27.)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在这里也进行了简单的错误处理：我们检查作者ID是否无效。如果无效，我们会显示错误消息，然后退出。（见第22至27行。）
- en: 'On lines 25 and 27, we use the author''s ID to create the query and set the
    fetch mode to be `PDO::FETCH_ASSOC`. Then we proceed to the display of data: first
    we render the author''s details and then all his books.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第25和27行，我们使用作者的ID创建查询，并将获取模式设置为`PDO::FETCH_ASSOC`。然后我们继续显示数据：首先我们呈现作者的详细信息，然后是他的所有书籍。
- en: 'Now you can return to your browser and point it to the URL: `http://localhost/author.php?id=1`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以返回浏览器，将其指向URL：`http://localhost/author.php?id=1`。
- en: 'The following screen should appear:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕应该出现：
- en: '![PDO Statements and Result Sets](graphics/2660-02-03.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![PDO语句和结果集](graphics/2660-02-03.jpg)'
- en: 'As you can see, everything is correct on the page: The author''s details, which
    we filed first (`id=1`), and the only book by this author. Now let''s see how
    our application reacts to an invalid ID submitted. We know that we have only three
    authors, so any number other than 1, 2, or 3 is invalid. Also, a non-number parameter
    will evaluate to 0, which is invalid. If we change the URL in the address bar
    to `http://localhost/author.php?id=zzz`. We will end up with the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，页面上的一切都是正确的：我们首先填写的作者详细信息（`id=1`），以及这位作者的唯一一本书。现在让我们看看我们的应用程序如何对提交的无效ID做出反应。我们知道我们只有三位作者，所以除了1、2或3之外的任何数字都是无效的。此外，非数字参数将计算为0，这是无效的。如果我们将地址栏中的URL更改为`http://localhost/author.php?id=zzz`。我们将得到以下结果：
- en: '![PDO Statements and Result Sets](graphics/2660-02-04.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![PDO语句和结果集](graphics/2660-02-04.jpg)'
- en: You should also switch to SQLite in `common.inc.php` and see that this page
    also works with this database.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该在`common.inc.php`中切换到SQLite，并查看此页面是否也适用于此数据库。
- en: 'Now, let''s modify our existing `books.php` file to add an author column with
    a link to the author''s profile page. We will have to join the two tables where
    the book''s `author` field equals the author''s ID field, and select the author''s
    ID, first name, and last name. So our query will look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改现有的`books.php`文件，以添加一个带有指向作者个人资料页面的链接的作者列。我们将不得不连接两个表，其中书的`作者`字段等于作者的ID字段，并选择作者的ID、名和姓。因此，我们的查询将如下所示：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Before we proceed with the changes, let''s run this query in the command line
    client. We will also modify this query for the client as its window will not fit
    the whole row:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续更改之前，让我们在命令行客户端中运行此查询。我们还将修改此查询以适应客户端，因为其窗口无法容纳整行：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, the query is returning two columns called `id`. This means
    that we will not be able to use the `PDO::FETCH_ASSOC` mode, since there can be
    only `id` array index. Here we have two options: Either use the `PDO::FETCH_NUM`
    mode or retrieve the ID fields using aliases.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，查询返回了两列名为`id`。这意味着我们将无法使用`PDO::FETCH_ASSOC`模式，因为只能有一个`id`数组索引。我们有两个选择：要么使用`PDO::FETCH_NUM`模式，要么使用别名检索ID字段。
- en: Let's see how we would code the page using `PDO::FETCH_NUM:`
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`PDO::FETCH_NUM`编写页面：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note the highlighted lines—they contain the changes; the rest of file is the
    same. As you can see, we added the call to `$q->setFetchMode()` and changed the
    loop to use numeric column indexes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意高亮显示的行-它们包含更改；文件的其余部分相同。正如您所看到的，我们添加了对`$q->setFetchMode()`的调用，并更改了循环以使用数字列索引。
- en: 'If we navigate back to `http://localhost/books.php`, we will see a list similar
    to the one in this screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们导航回`http://localhost/books.php`，我们将看到与此截图中类似的列表：
- en: '![PDO Statements and Result Sets](graphics/2660-02-05.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![PDO语句和结果集](graphics/2660-02-05.jpg)'
- en: We can click on every author to get to their profile page. Of course, changing
    back to SQLite in `common.inc.php` should also work.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以点击每个作者以进入其个人资料页面。当然，在`common.inc.php`中切换回SQLite也应该起作用。
- en: 'Another (and much better) option is to use aliases for column names in the
    SQL code. If we do this, we will not have to take care of the numeric indexes
    and change the code every time we add or remove columns from our tables. We just
    change the SQL to the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个（更好的）选择是在SQL代码中为列名使用别名。如果我们这样做，我们就不必关心数字索引，并且每次从我们的表中添加或删除列时都要更改代码。我们只需将SQL更改为以下内容：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The final version of `books.php` will look like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`books.php`的最终版本将如下所示：'
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that we changed the fetch mode back to `PDO::FETCH_ASSOC`. Also, we access
    the author's ID on line 34 with `$r['authorId']`, since we aliased that column
    with `authorId` in the query.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将提取模式更改回`PDO::FETCH_ASSOC`。此外，我们在第34行使用`$r['authorId']`访问作者的ID，因为我们在查询中使用`authorId`对该列进行了别名。
- en: PDO also allows us to fetch all the results into an array. We may need this
    for further processing or for passing to some function. However, this should be
    done only for small result sets. This is highly discouraged for applications like
    ours, because we simply display the list of books or authors. Fetching a big result
    set into an array will require memory allocated for the whole result, while in
    our case we display results row by row, so this requires memory for just one row.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: PDO还允许我们将所有结果提取到数组中。我们可能需要这个用于进一步处理或传递给某个函数。但是，这应该仅用于小型结果集。这在我们这样的应用程序中是非常不鼓励的，因为我们只是显示书籍或作者的列表。将大型结果集提取到数组中将需要为整个结果分配内存，而在我们的情况下，我们逐行显示结果，因此只需要一行的内存。
- en: 'This method is called `PDOStatement::fetchAll()`. The resulting array is either
    a two-dimensional array or a list of objects—this depends on the fetch mode. This
    method accepts all the `PDO::FETCH_xxxx` constants, just like `PDOStatement::fetch()`.
    For example, we could rewrite our `books.php` file in the following manner to
    achieve the same result. Here is the relevant part of `books.php` lines 9 to 46:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法被称为`PDOStatement::fetchAll()`。结果数组可以是一个二维数组，也可以是对象列表-这取决于提取模式。这个方法接受所有`PDO::FETCH_xxxx`常量，就像`PDOStatement::fetch()`一样。例如，我们可以以以下方式重写我们的`books.php`文件以达到相同的结果。以下是`books.php`第9到46行的相关部分：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note the highlighted lines here—we fetch the whole result into the `$books`
    array on line 5 and then iterate over it with a `foreach` loop on line 21\. If
    you run the modified page, you will see that we receive the same result. This
    will also work if we change to SQLite database in the `common.inc.php` file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这里的高亮显示的行-我们在第5行将整个结果提取到`$books`数组中，然后在第21行使用`foreach`循环对其进行迭代。如果运行修改后的页面，您将看到我们收到相同的结果。如果在`common.inc.php`文件中切换到SQLite数据库，这也将起作用。
- en: 'The `PDOStatement::fetchAll()` method also allows us to select the values of
    a single column with the `PDO::FETCH_COLUMN` mode. If we want to fetch the entire
    book titles using the query from the last example, we can do the following (note
    the number and ordering of columns):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`PDOStatement::fetchAll()`方法还允许我们使用`PDO::FETCH_COLUMN`模式选择单个列的值。如果我们想使用上一个示例中的查询提取整个书名，我们可以这样做（注意列的数量和顺序）：'
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This would give the following output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, when a single column is requested, this method returns one-dimensional
    array.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，当请求单个列时，此方法返回一维数组。
- en: Retrieving Result Set Metadata
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索结果集元数据
- en: As we have seen in the previous section, the `PDOStatement` class allows us
    to retrieve some information about the data contained in the result set. This
    information is called **metadata**, and you probably have already used some of
    it one way or another.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中所看到的，`PDOStatement`类允许我们检索有关结果集中包含的数据的一些信息。这些信息称为**元数据**，您可能已经以某种方式使用过其中的一些。
- en: The most important metadata about a result set is, of course, the number of
    rows it contains. We can use the row count to enhance user experience by, for
    example, paginating long result sets. Our example library application is still
    quite small, with only three books so far, but as our database grows, we surely
    will need some tools to get the total row count for every table displayed and
    paginate it for easy browsing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 结果集最重要的元数据当然是它包含的行数。我们可以使用行数来增强用户体验，例如对长结果集进行分页。我们的示例库应用目前还很小，只有三本书，但随着数据库的增长，我们肯定需要一些工具来获取每个表的总行数，并对其进行分页以便浏览。
- en: 'Traditionally, you would use the `mysql_num_rows(), sqlite_num_rows()` function
    or the `pg_num_rows()` function (depending on your database) to get the total
    number of rows returned by the query. In PDO, the method responsible for retrieving
    the number of rows is called `PDOStatement::rowCount()`. However, if you want
    to test it with the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，您会使用`mysql_num_rows(), sqlite_num_rows()`函数或`pg_num_rows()`函数（取决于您的数据库）来获取查询返回的总行数。在PDO中，负责检索行数的方法称为`PDOStatement::rowCount()`。但是，如果你想用以下代码测试它：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: you will see that PDO returns 0 both for MySQL and SQLite. This is because PDO
    operates differently from the traditional database extensions. The documentation
    says, "If the last SQL statement executed by the associated `PDOStatement` class
    was a `SELECT` statement, some databases may return the number of rows returned
    by that statement. However, this behavior is not guaranteed for all databases
    and should not
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现PDO对MySQL和SQLite都返回0。这是因为PDO的操作方式与传统的数据库扩展不同。文档中说：“如果与关联的`PDOStatement`类执行的最后一个SQL语句是`SELECT`语句，则某些数据库可能返回该语句返回的行数。但是，并不是所有数据库都保证这种行为。”
- en: be relied on for portable applications." Neither MySQL nor SQLite drivers support
    this functionality, and that's why the return value of this method is 0\. We will
    see how to count the number of rows returned with PDO (so that this is a really
    portable method) in [Chapter 5](ch05.html "Chapter 5. Handling Rowsets").
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植应用程序不应依赖于这种方法。" MySQL和SQLite驱动程序都不支持此功能，这就是为什么该方法的返回值为0。我们将在[第5章](ch05.html
    "第5章。处理行集")中看到如何使用PDO计算返回的行数（因此这是一个真正可移植的方法）。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A *RDBMS* does not know how many rows a query will return till the last row
    has been retrieved. This is done because of performance considerations. In most
    cases, queries with a `WHERE` clause, return only part of the rows stored in a
    table, and database servers do their best to ensure that such queries execute
    as fast as possible. This means that they start returning rows as soon as they
    discover those that match the `WHERE` clause—this happens much earlier than when
    the last row is reached. That is why they really don't know how many rows will
    be returned beforehand. The `mysql_num_rows(), sqlite_num_rows()` function or
    the `pg_num_rows()` function operates on result sets that have been prefetched
    into memory (buffered queries). PDO's default behavior is to use unbuffered queries.
    We will speak about MySQL buffered queries later in [Chapter 6](ch06.html "Chapter 6. Advanced
    PDO Usage").
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*RDBMS*不知道查询将返回多少行，直到检索到最后一行。这是出于性能考虑。在大多数情况下，带有`WHERE`子句的查询只返回表中存储的部分行，数据库服务器会尽力确保这样的查询尽快执行。这意味着他们在发现与`WHERE`子句匹配的行时就开始返回行——这比到达最后一行要早得多。这就是为什么他们真的不知道事先将返回多少行。`mysql_num_rows(),
    sqlite_num_rows()`函数或`pg_num_rows()`函数操作的是已经预取到内存中的结果集（缓冲查询）。PDO的默认行为是使用非缓冲查询。我们将在[第6章](ch06.html
    "第6章。高级PDO用法")中讨论MySQL缓冲查询。'
- en: 'Another method that can be of interest is the `PDOStatement::columnCount()`
    method, which returns the number of columns in the result set. It is handy when
    we execute arbitrary queries. (For example, a database management application
    like `phpMyAdmin` could make great use of this method, as it allows a user to
    type arbitrary SQL queries.) We can use it in the following way:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能感兴趣的方法是`PDOStatement::columnCount()`方法，它返回结果集中的列数。当我们执行任意查询时，这很方便。（例如，像`phpMyAdmin`这样的数据库管理应用程序可以充分利用这种方法，因为它允许用户输入任意SQL查询。）我们可以这样使用它：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will reveal that our query returns a result set containing 10 columns (seven
    columns from the **books** table and three columns from **authors** table).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将揭示我们的查询返回了一个包含10列的结果集（**books**表的七列和**authors**表的三列）。
- en: Unfortunately, PDO currently does not allow you to retrieve the name of the
    table or of a particular column from a result set to which it belongs. This functionality
    is useful if your application utilizes queries that join two or more tables. In
    such case, it is possible to fetch the table name for every column given its numeric
    index, starting with 0\. However, proper use of column aliases eliminates the
    need to use such functionality. For example, when we modified the books listing
    page to display the author's name, we aliased the author's ID column to avoid
    name conflict. That alias clearly identifies the column as belonging to the `authors`
    table.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，PDO目前不允许您从结果集中检索表的名称或特定列的名称。如果您的应用程序使用了连接两个或多个表的查询，这个功能就很有用。在这种情况下，可以根据其数字索引（从0开始）获取每列的表名。但是，正确使用列别名可以消除使用这种功能的需要。例如，当我们修改书籍列表页面以显示作者的姓名时，我们为作者的ID列设置了别名以避免名称冲突。该别名清楚地标识了该列属于`authors`表。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took our first steps with PDO and even created a small working
    database-driven, dynamic application that runs on two different databases. Now
    you should be able to connect to any supporting database, using the rules for
    constructing a connection string. You should then be able to run queries against
    it, and to traverse and display the result set.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们初步使用了PDO，甚至创建了一个可以在两个不同数据库上运行的小型数据库驱动动态应用程序。现在你应该能够连接到任何支持的数据库，使用构建连接字符串的规则。然后你应该能够对其运行查询，并遍历和显示结果集。
- en: In the next chapter, we will deal with a very important aspect of any database-driven
    application—error handling. We will also extend our example application by giving
    it the ability to add and edit books and authors, thus making it more realistic
    and useful.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理任何数据库驱动应用程序的一个非常重要的方面——错误处理。我们还将通过为其添加和编辑书籍和作者的功能来扩展我们的示例应用程序，从而使其更加真实和有用。
