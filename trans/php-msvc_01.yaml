- en: Chapter 1. What are Microservices?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 什么是微服务？
- en: Good projects need good solutions; this is why developers are always looking
    for better ways to do their jobs. There is no best solution for all projects because
    every single project has different needs and the architect (or the developer)
    has to find the best solution for that specific project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的项目需要好的解决方案；这就是为什么开发人员总是在寻找更好的工作方式。没有适用于所有项目的最佳解决方案，因为每个项目都有不同的需求，架构师（或开发人员）必须为该特定项目找到最佳解决方案。
- en: Microservices are maybe a good approach to solve problems; in the last few years,
    companies such as Netflix, PayPal, eBay, Amazon, and Spotify have chosen to use
    microservices in their own development teams because they believed them to be
    the best solution for their projects. To understand why they chose microservices
    and understand the kinds of projects you should use them in, it is necessary to
    know what a microservice is.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可能是解决问题的一个好方法；在过去几年中，像Netflix、PayPal、eBay、亚马逊和Spotify这样的公司选择在他们自己的开发团队中使用微服务，因为他们认为这是他们项目的最佳解决方案。要理解他们为什么选择微服务，并了解应该在哪种项目中使用它们，有必要了解什么是微服务。
- en: Firstly, it is essential to understand what a monolithic application is, but
    basically, we can define a microservice as an extended Service Oriented Architecture.
    In other words, it is a way to develop an application by following the required steps
    to turn it into various little services. Each service will execute itself and
    communicate with others through requests, usually using APIs on HTTP.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，了解什么是单片应用是至关重要的，但基本上，我们可以将微服务定义为扩展的面向服务的架构。换句话说，这是一种通过遵循将应用程序转变为各种小服务所需的步骤来开发应用程序的方式。每个服务将自行执行并通过请求与其他服务通信，通常使用HTTP上的API。
- en: To further understand what microservices are, we first need to understand what
    a monolithic application is. It is the typical application that we have been developing
    for the last few years, for example in PHP, using a framework like Symfony; in
    other words, all the applications we have been developing are divided into different
    parts, such as frontend, backend, and database, and also use the **Model-View-Controller** (**MVC**)
    pattern. It is important to differentiate between MVC and microservices. MVC is
    a design pattern and microservices are a way to develop an application; therefore,
    applications developed using MVC could still be monolithic applications. People
    may think that if we split our application into different machines and divide
    the business logic from the model and the view, the application is then based
    on microservices, but this is not correct.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步了解什么是微服务，我们首先需要了解什么是单片应用。这是我们过去几年一直在开发的典型应用，例如在PHP中使用像Symfony这样的框架；换句话说，我们一直在开发的所有应用都被划分为不同的部分，如前端、后端和数据库，并且还使用MVC模式。重要的是要区分MVC和微服务。MVC是一种设计模式，而微服务是一种开发应用的方式；因此，使用MVC开发的应用仍然可能是单片应用。人们可能会认为，如果我们将应用程序分割到不同的机器上，并将业务逻辑与模型和视图分开，那么应用程序就是基于微服务的，但这是不正确的。
- en: However, using a monolithic architecture still has its advantages. There are
    also various huge web applications, such as Facebook, that use it; we just need
    to know when we need to use a monolithic architecture and when we need to use
    microservices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用单片架构仍然有其优势。还有一些巨大的网络应用，比如Facebook，使用它；我们只需要知道何时需要使用单片架构，何时需要使用微服务。
- en: Monolithic versus microservices
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单片与微服务
- en: Now, we will discuss the advantages and disadvantages of using monolithic applications
    and how microservices improve a specific project by giving a basic example.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论使用单片应用的优缺点以及微服务如何通过提供一个基本示例来改进特定项目。
- en: 'Imagine a taxi platform like Uber; the platform in this example will be a small
    one with only the basic things in order to understand the definitions. There are
    customers, drivers, cities, and a system to track the location of the taxi in
    real time:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下像Uber这样的出租车平台；在这个例子中，平台将是一个小型平台，只有基本的东西，以便理解定义。有顾客、司机、城市，以及一个实时跟踪出租车位置的系统：
- en: '![Monolithic versus microservices](graphics/image_00_001.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![单片与微服务](graphics/image_00_001.jpg)'
- en: In a monolithic system, we have all this together---we have a common database
    with the customers and drivers linked to cities and all these are linked to the
    system to track taxis using foreign keys.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在单片系统中，所有这些都在一起---我们有一个与顾客和司机相关联的公共数据库，这些都与城市相关联，并且所有这些都与使用外键跟踪出租车的系统相关联。
- en: All this can also be hosted on different machines using master-slave databases;
    the backend can be in different instances using a load balancer or a reverse proxy
    and the frontend can use a different technology using Node.js or even plain HTML.
    Even so, the platform will be a monolithic application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些也可以托管在不同的机器上，使用主从数据库；后端可以在不同的实例中使用负载均衡器或反向代理，前端可以使用不同的技术，如Node.js甚至纯HTML。即便如此，平台仍然是一个单片应用。
- en: 'Lets see an example of possible problems faced in a monolithic application:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在单片应用中可能面临的问题的例子：
- en: Two developers, Joe and John, are working on the basic taxi example project;
    Joe needs to change some code on drivers and John has to change some code on customers.
    The first problem is that both the developers are working on the same base code;
    this is not an exclusive monolithic problem but if Joe needs to add a new field
    on drivers, he may need to change the customer's model too, so Joe's work does
    not finish on the driver's side; in other words, his work is not delimited. This
    is what happens when we use monolithic applications.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两位开发人员Joe和John正在基本的出租车示例项目上工作；Joe需要更改一些关于司机的代码，而John需要更改一些关于顾客的代码。第一个问题是，这两位开发人员都在同一个基本代码上工作；这不是一个独占的单片问题，但如果Joe需要在司机模型上添加一个新字段，他可能也需要更改顾客的模型，因此Joe的工作不仅仅局限在司机方面；换句话说，他的工作没有被界定。这就是当我们使用单片应用时会发生的情况。
- en: 'Joe and John have realized that the system to track taxis has to communicate
    with third parties calling external APIs. The application does not have a very
    big load but the system to track taxis has a lot of requests from customers and
    drivers, so there is a bottleneck on that side. Joe and John have to scale it
    to solve the problem on the tracking system: they can get faster machines, more
    memory, and a load balancer, but the problem is that they have to scale the entire
    application.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乔和约翰意识到，跟踪出租车的系统必须与调用外部API的第三方进行通信。应用程序的负载并不是很大，但跟踪出租车的系统却有很多来自顾客和司机的请求，因此在那一方面存在瓶颈。乔和约翰必须对其进行扩展以解决跟踪系统上的问题：他们可以获得更快的机器、更多的内存和负载均衡器，但问题是他们必须对整个应用程序进行扩展。
- en: Joe and John are happy; they just finished fixing the problem on the system
    to track taxis. Now they will put the changes on the production server. They will
    have to work tonight when the traffic on the web application is lower; the risk
    is high because they have to deploy the entire application and not just the system
    to track taxis that they fixed.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乔和约翰很高兴；他们刚刚解决了跟踪出租车系统的问题。现在他们将把更改放到生产服务器上。他们将不得不在网站应用程序的流量较低时工作；风险很高，因为他们必须部署整个应用程序，而不仅仅是他们修复的跟踪出租车系统。
- en: In a couple of hours, an error 500 appears within the application. Joe and John
    know that the problem is related to the tracking system, but the entire application
    will be down only because there is a problem with a part of the application.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在几个小时内，应用程序出现了500错误。乔和约翰知道问题与跟踪系统有关，但整个应用程序将会崩溃，只是因为应用程序的一部分出了问题。
- en: 'A microservice is a simple, isolated entity with a concrete proposal. It is
    independent and works with the rest of the microservices by communicating through
    an agreed channel as you can see in the next picture:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一个简单的、独立的实体，具有明确的目标。它是独立的，并通过约定的通道与其他微服务进行通信，如下图所示：
- en: '![Monolithic versus microservices](graphics/image_00_004.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![单体架构与微服务](graphics/image_00_004.jpg)'
- en: For developers who are used to working on object-oriented programming, the idea
    of a microservice would be something like an encapsulated object working on a
    different machine and isolated from the other ones working on different machines
    too.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于习惯于面向对象编程的开发人员来说，微服务的概念就像是一个封装的对象在不同的机器上运行，并且与其他在不同机器上运行的对象隔离。
- en: Following the same example as before, if we have a problem on the system to
    track taxis, it would be necessary to isolate all the code related to this part
    of the application. This is a little complex and will be explained in detail in
    [Chapter 9](ch09.html "Chapter 9. From Monolithic to Microservices"), *From Monolithic
    to Microservices*, but in general terms, it is a database used exclusively by
    the system to track taxis, so we need to extract the part for this purpose and
    the code needs to be modified to work with the extracted database. Once the goal
    is achieved, we will have a microservice with an API (or any other channel) that
    can be called by the rest of the monolithic application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前的例子，如果我们在跟踪出租车的系统上出现问题，就需要隔离与该部分应用程序相关的所有代码。这有点复杂，将在第9章“从单体架构到微服务”中详细解释，但总的来说，这是一个专门用于跟踪出租车的系统的数据库，因此我们需要提取出这部分，并修改代码以使其与提取出的数据库一起工作。一旦目标实现，我们将拥有一个可以被单体应用程序的其余部分调用的微服务API（或任何其他渠道）。
- en: This will avoid the problems mentioned before---Joe and John can work on their
    own issue because once the application is divided into microservices, they will
    work on the customer or driver microservice. If Joe has to change code or include
    a new field, he will only need to change it in his own entity and John will consume
    the drivers API to communicate with it from the customer's part.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将避免之前提到的问题——乔和约翰可以独立处理他们自己的问题，因为一旦应用程序被划分为微服务，他们将处理顾客或司机微服务。如果乔需要更改代码或包含新字段，他只需要在自己的实体中进行更改，约翰将使用司机API从顾客部分进行通信。
- en: The scalability can be done just for this microservice, so it is not necessary
    to scale the entire application by spending money and resources and if the system
    to track taxis is down, the rest of the application will work without any problems.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性只需针对这个微服务进行，因此不需要花费金钱和资源来扩展整个应用程序，如果跟踪出租车的系统出现问题，其余应用程序将可以正常工作。
- en: Another advantage of using microservices is that they are agnostic to the language;
    in other words, it is possible to use different languages for each microservice.
    A microservice written in PHP can talk to others written in Python or Ruby because
    they only give the API to the rest of the microservices, so they just have to
    share the same interface to communicate with each other.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务的另一个优势是它们对语言是不可知的；换句话说，每个微服务可以使用不同的语言。一个用PHP编写的微服务可以与用Python或Ruby编写的其他微服务进行通信，因为它们只向其他微服务提供API，因此它们只需共享相同的接口来相互通信。
- en: Service Oriented Architectures versus microservices
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向服务的架构与微服务
- en: When a developer encounters microservices and they know the **Service Oriented
    Architecture** (**SOA**) style of software design, the first question they ask
    themselves is whether SOA and microservices are the same thing or whether they
    are related, and the answer is a little bit controversial; depending on who you
    ask, the answer will be different.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员遇到微服务并了解面向服务的架构（SOA）软件设计风格时，他们首先要问自己的问题是SOA和微服务是否是同一回事，或者它们是否相关，答案有点具有争议性；取决于你问的人，答案会有所不同。
- en: According to Martin Fowler, SOA focuses on integrating monolithic applications
    between themselves, and it uses an **Enterprise Service Bus** (**ESB**) to achieve
    this.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 根据马丁·福勒（Martin Fowler）的说法，SOA专注于将单体应用程序相互集成，并使用企业服务总线（ESB）来实现这一目标。
- en: When the SOA architectures began to appear, these ones tried to connect different
    components between themselves, and this is one of the characteristics of microservices,
    but the problem with SOA was that it needed many things surrounding the architecture
    to work properly, such as ESB, **Business process management** (**BPM**), service
    repositories, register, and more things, so it made it more difficult to develop.
    Also, in order to change some parts of a code, it was necessary to agree with
    the other development teams before doing it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当SOA架构开始出现时，它们试图将不同的组件连接在一起，这是微服务的特点之一，但SOA的问题在于它需要许多围绕架构工作的东西，如ESB、**业务流程管理**（**BPM**）、服务存储库、注册表等等，因此这使得开发变得更加困难。此外，为了更改代码的某些部分，需要先与其他开发团队达成一致。
- en: All these things made the maintenance and code evolution difficult, and the
    time to market long; in other words, this architecture was not the best for applications
    that often needed to make changes live.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些因素使得维护和代码演进变得困难，上市时间变长；换句话说，这种架构并不适合经常需要实时更改的应用程序。
- en: 'There are other opinions regarding SOA. Some say that SOA and microservices
    are the same, but SOA is the theory and microservices is a good implementation.
    The need to use an ESB or communicate using WSDL or WADL was not a must, but it
    was defined as the SOA  standard. As you can see on the next picture, your architecture
    using SOA and ESB will look like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 关于SOA还有其他观点。有人说SOA和微服务是一样的，但SOA是理论，微服务是一个很好的实现。使用ESB或使用WSDL或WADL进行通信并不是必须的，但它被定义为SOA的标准。如下图所示，使用SOA和ESB的架构如下所示：
- en: '![Service Oriented Architectures versus microservices](graphics/image_00_006.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![面向服务的架构与微服务](graphics/image_00_006.jpg)'
- en: The requests arrive via different ways; this is the same way microservices work,
    but all the requests reach the ESB and it knows where it should call to get the
    data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请求通过不同的方式到达；这与微服务的工作方式相同，但所有请求都到达ESB，它知道应该调用哪里来获取数据。
- en: Microservices characteristics
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务特点
- en: 'Next, we will look at the key elements of a microservice architecture:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下微服务架构的关键要素：
- en: '**Ready to fail**: Microservices are designed to fail. In a web application,
    microservices communicate with each other and if one of them fails, the rest should
    work to avoid a cascading failure. Basically, microservices attempt to avoid communicating
    synchronously using async calls, queues, systems based on actors, and streams
    instead. This topic will be discussed in the subsequent chapters.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备失败**：微服务被设计为失败。在Web应用程序中，微服务相互通信，如果其中一个失败，其余部分应该继续工作以避免级联故障。基本上，微服务试图避免使用同步通信，而是使用异步调用、队列、基于actor的系统和流。这个话题将在接下来的章节中讨论。'
- en: '**Unix philosophy**: Microservices should follow the Unix philosophy. Each
    microservice must be designed to do one thing only, and should only be small and
    independent. This allows us as developers to adjust and deploy each microservice
    independently. The Unix philosophy emphasizes building simple, short, clear, modular,
    and extensible code that can be easily maintained and repurposed by developers
    as well, in addition to its creators.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unix哲学**：微服务应该遵循Unix哲学。每个微服务必须设计为只做一件事，并且应该小而独立。这使我们作为开发人员能够独立调整和部署每个微服务。Unix哲学强调构建简单、简短、清晰、模块化和可扩展的代码，这样可以方便开发人员进行维护和重用，而不仅仅是其创建者。'
- en: '**Communication layer**: Each microservice communicates with the others through
    HTTP requests and messages, executing the business logic, querying the database,
    exchanging messages with the required systems and, at the end, returning a JSON
    (or HTML/XML) response.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通信层**：每个微服务通过HTTP请求和消息与其他微服务通信，执行业务逻辑，查询数据库，与所需系统交换消息，最终返回JSON（或HTML/XML）响应。'
- en: '**Scalability**: The main reason to choose a microservice architecture is that
    it is possible to scale the application easily. The bigger an application is and
    the more traffic the application has, the more sense the proper selection of choosing
    microservices makes. A microservice can scale the required part without any impact
    on the rest of the application.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：选择微服务架构的主要原因是可以轻松扩展应用程序。应用程序越大，流量越大，选择微服务的合理性就越大。微服务可以在不影响应用程序的其他部分的情况下扩展所需的部分。'
- en: Successful cases
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成功案例
- en: 'The best way to understand how important microservices are in real life is
    knowing some platforms that decided to evolve and use microservices thinking about
    the future and making the maintenance and scalability easier, faster, and more
    effective:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 了解微服务在现实生活中有多重要的最好方法是了解一些决定发展并使用微服务的平台，考虑未来并使维护和扩展更容易、更快速、更有效：
- en: '**Netflix**: The number one application for online video streaming turned its
    architecture into microservices a few years ago. There is a story about the reason
    they decided to use microservices. Making changes on a review module, a developer
    forgot to put the `;` at the end of the line and Netflix was down for many hours.
    The platform gets around 30% of the total traffic from the USA every day, so Netflix
    has to offer a stable service to its customers who pay every month. To get this,
    Netflix makes five requests to its different servers for each request that we
    make and it can get requests from 800 different devices using its streaming video
    API.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Netflix**：在线视频流媒体的头号应用在几年前将其架构转变为微服务。有一个关于他们决定使用微服务的原因的故事。在对评论模块进行更改时，一名开发人员忘记在行尾加上`;`，导致Netflix宕机了很多小时。该平台每天约30%的总流量来自美国，因此Netflix必须向每月付费的客户提供稳定的服务。为了实现这一点，Netflix对每个我们发出的请求进行五次请求，并且可以使用其流媒体视频API从800个不同的设备获取请求。'
- en: '**eBay**: In 2007, eBay decided to change its architecture to microservices;
    it used a monolithic application on C++ and Perl, later they moved to services
    built on Java, and finally they implemented their architecture using microservices.
    Its main application has many services and each one executes its own logic to
    be used by the customers in each area.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**eBay**：在2007年，eBay决定将其架构改为微服务；他们曾在C++和Perl上使用单片应用程序，后来他们转向了基于Java构建的服务，最终实施了微服务架构。它的主要应用程序有许多服务，每个服务都执行自己的逻辑，以供每个领域的客户使用。'
- en: '**Uber**: Microservices allowed this company to grow quickly because it allowed
    it to use different languages (Node.js, Go, Scala, Java, or Python) for each microservice
    and the process of hiring engineers was easier because they were not limited by
    the language code.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Uber**：微服务使得这家公司能够快速增长，因为它允许使用不同的语言（Node.js、Go、Scala、Java或Python）用于每个微服务，而且招聘工程师的过程更容易，因为他们不受语言代码的限制。'
- en: '**Amazon**: Maybe Amazon is not the king of Internet traffic, but it moved
    to microservices a few years ago, being one of the first ones to use live microservices.
    The engineers said that it was not possible to provide all the services they offer,
    such as the web service, using the old monolithic application.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**亚马逊**：也许亚马逊不是互联网流量之王，但它几年前就转向了微服务，成为最早使用实时微服务的公司之一。工程师们表示，使用旧的单片应用程序无法提供他们提供的所有服务，比如网络服务。'
- en: '**Spotify**: The need to be faster than its opponent was a must for Spotify.
    The main engineer, Niklas Gustavsson, said that being fast, automating everything,
    and having smaller teams of development is really important for the application.
    This is the reason Spotify uses microservices.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spotify**：对于Spotify来说，比对手更快是必须的。主要工程师尼古拉斯·古斯塔夫森表示，快速、自动化一切以及拥有更小的开发团队对应用程序非常重要。这就是为什么Spotify使用微服务的原因。'
- en: Disadvantages of microservices
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务的缺点
- en: Next, we will look at the disadvantages of the microservices architecture. When
    asking developers about this, they agree that the major problem with microservices
    is the debugging on the production server.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看微服务架构的缺点。当询问开发人员时，他们认为微服务的主要问题是在生产服务器上进行调试。
- en: Debugging an application based on microservices can be a little tedious when
    you have hundreds of microservices in your application and you have to find where
    a problem is; you need to spend time looking for the microservice that is giving
    you the error. Each microservice works like an individual machine, so to look
    at a specific log you have to go to the specific microservice. Fortunately, there
    are some tools to help us out with this subject by getting the logs from all the
    different microservices in your application and putting them together into a single
    location. In the subsequent chapters, we will look at these kinds of tools.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基于微服务的应用程序调试可能会有点繁琐，特别是当你的应用程序中有数百个微服务时，你需要找到问题出在哪里；你需要花时间寻找给你报错的微服务。每个微服务都像一个独立的机器，所以要查看特定的日志，你必须去特定的微服务。幸运的是，有一些工具可以帮助我们解决这个问题，可以从应用程序中的所有不同微服务中获取日志，并将它们汇总到一个位置。在接下来的章节中，我们将看看这些工具。
- en: Another disadvantage is that it is necessary to maintain every single microservice
    as an entire server; in other words, every single microservice can have one or
    more databases, logs, different services, or library versions, and even the code
    can be in a different language, so if it is difficult to maintain a single server
    and doing it with hundreds will waste money and time.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是需要将每个微服务都作为一个完整的服务器进行维护；换句话说，每个微服务都可以有一个或多个数据库、日志、不同的服务或库版本，甚至代码可以使用不同的语言，因此如果维护单个服务器困难，那么维护数百个服务器将浪费金钱和时间。
- en: Also, the communication between microservices is very important---they have
    to work like clocks, so communication is essential for the application. To do
    this, the communication between the development teams will be necessary to tell
    each other what they need and also to write good documentation for each microservice.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，微服务之间的通信非常重要---它们必须像时钟一样工作，因此通信对于应用程序至关重要。为了做到这一点，开发团队之间的沟通将是必要的，彼此告知他们需要什么，同时为每个微服务编写良好的文档也是必要的。
- en: A good practice to work with microservices is having everything automatized
    or at least everything possible. Maybe the most important part is the deployment.
    If it is necessary to deploy hundreds of microservices, it can be difficult. So,
    the best way is to automatize these kinds of tasks. We will look at how to do
    this in the subsequent chapters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与微服务一起工作的一个好的做法是自动化一切，或者至少尽可能自动化一切。也许最重要的部分是部署。如果需要部署数百个微服务，这可能会很困难。因此，最好的方法是自动化这些任务。我们将在接下来的章节中看看如何做到这一点。
- en: How to focus your development on microservices
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何将开发重点放在微服务上
- en: Developing microservices is a new way of thinking. Therefore, it can be difficult
    when you encounter how the application will be designed and built for the first
    time. However, if you always remember that the most important idea behind microservices
    is the need to decompose your application into smaller logical pieces, you are
    already halfway there.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 开发微服务是一种新的思维方式。因此，当您第一次遇到应用程序的设计和构建时，可能会感到困难。然而，如果您始终记住微服务背后最重要的思想是将应用程序分解为更小的逻辑部分的需求，那么您已经完成了一半。
- en: Once you understand this, the following core ideas will help you with the design
    and build process of your application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦理解了这一点，以下核心思想将有助于您的应用程序的设计和构建过程。
- en: Always create small logical black boxes
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 始终创建小的逻辑黑匣子
- en: As a developer, you always start with the big picture of what you will build.
    Try to decompose the big picture into small logical blocks that only do one thing.
    Once the multiple small pieces are ready, you can start building complex systems,
    ensuring that the foundations of your application are solid.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，你总是从你将要构建的大局开始。尝试将大局分解为只做一件事情的小逻辑块。一旦多个小块准备就绪，你可以开始构建复杂的系统，确保你的应用程序的基础是坚实的。
- en: Each of your microservices is like a black box with a public interface, which
    is the only way to interact with your software. The main recommendation you need
    to have always in mind is to build a very stable API. You can change the implementation
    of an API call without many problems, but if you change the way of calling or
    even the response of this call, you will be in big trouble. In the case of deep
    changes to your API, ensure that you use some kind of versioning so that you can
    support the old and new versions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你的每个微服务都像一个黑匣子，有一个公共接口，这是与你的软件交互的唯一方式。你需要牢记的主要建议是构建一个非常稳定的API。你可以在不引起太多问题的情况下更改API调用的实现，但是如果你改变调用的方式甚至是这个调用的响应，你将陷入麻烦。在对API进行重大更改的情况下，确保使用某种版本控制，以便你可以支持旧版本和新版本。
- en: Network latency is your hidden enemy
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络延迟是你隐藏的敌人
- en: The communication between services is made through API calls using the network
    as a connection pipe. This message exchange takes some time and it will not always
    be the same due to multiple factors. Imagine that you have *service_a* on one
    machine and a *service_b* on a different machine. Do you think that the network
    latency will always be the same? What happens if, for example, one of the servers
    is under a high load and takes some time to process requests? To reduce time,
    always keep an eye on your infrastructure, monitor everything, and use compression
    if it is available.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 服务之间的通信是通过使用网络作为连接管道的API调用进行的。这种消息交换需要一些时间，由于多种因素，它的时间不会总是相同。想象一下，你在一台机器上有*service_a*，在另一台机器上有*service_b*。你认为网络延迟会一直是一样的吗？如果，例如，其中一台服务器负载很高，需要一些时间来处理请求，会发生什么？为了减少时间，始终关注你的基础设施，监控一切，并在可用时使用压缩。
- en: Always think about scalability
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 始终考虑可扩展性
- en: One of the main advantages of a microservice application is that each service
    can be scaled up or down. This flexibility can be achieved by reducing the number
    of stateful services to the minimum. A stateful service relies on data persistence,
    making it difficult to move or share the data without having data consistency
    problems.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应用的主要优势之一是每个服务都可以进行扩展。通过将有状态服务的数量减少到最低，可以实现这种灵活性。有状态服务依赖于数据持久性，这使得在没有数据一致性问题的情况下移动或共享数据变得困难。
- en: Using autodiscovery and autoregistry techniques, you can build a system that
    knows which one will deal with each request at all times.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动发现和自动注册技术，你可以构建一个系统，它始终知道谁将处理每个请求。
- en: Use a lightweight communication protocol
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用轻量级通信协议
- en: Nobody likes to wait, not even your microservices. Don't try to reinvent the
    wheel or use an obscure but cool communication protocol, use HTTP and REST. They
    are known by all web developers, they are fast, reliable, easy to implement, and
    very easy to debug. If you need to increase the security, implement SSL/TSL.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人喜欢等待，即使是你的微服务也是如此。不要试图重新发明轮子或使用一个晦涩但很酷的通信协议，使用HTTP和REST。它们为所有的Web开发人员所熟知，它们快速、可靠、易于实现，非常容易调试。如果需要增加安全性，实现SSL/TSL。
- en: Use queues to reduce a service load or make async executions
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用队列来减少服务负载或进行异步执行。
- en: As a developer, you want to make your system as fast as possible. Therefore,
    it makes no sense to increase the execution time of an API call just because it
    is waiting for some action that can be done in the background. In these cases,
    the best approach is the use of queues and job runners in charge of this background
    processing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，你希望使你的系统尽可能快。因此，增加API调用的执行时间只因为它在等待可以在后台完成的某些操作是没有意义的。在这些情况下，最好的方法是使用队列和作业运行程序来处理后台处理。
- en: Imagine that you have a notification system that sends an e-mail to a customer
    when placing an order on your microservice e-commerce. Do you think that the customer
    wants to wait to see the payment successful page only because the system is trying
    to send an e-mail? In this case, a better approach is to enqueue the message so
    that the customer will have a pretty instant thank you page. Later, a job runner
    will pick up the queued notification and the e-mail will be sent to the customer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个通知系统，在微服务电子商务上下订单时向客户发送电子邮件。你认为客户想要等待看到支付成功页面，只是因为系统正在尝试发送电子邮件吗？在这种情况下，更好的方法是将消息加入队列，这样客户将会有一个非常快速的感谢页面。稍后，作业运行程序将提取排队的通知，并将电子邮件发送给客户。
- en: Be ready for the worst case scenario
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为最坏的情况做好准备
- en: You have a nice, new, good-looking site built on top of microservices. Are you
    ready for the moment when everything goes wrong? If you are suffering a network
    partition, do you know if your application will recover from that situation? Now,
    imagine that you have a recommendation system and it is down, are you going to
    give the customers a *default* recommendation while you try to recover the dead
    service? Welcome to the world of distributed systems where when something goes
    wrong, it can get worse. Always keep this in mind and try to be ready for any
    scenario.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个建立在微服务之上的漂亮、新颖、好看的网站。当一切都出错的时候，你准备好了吗？如果你遇到了网络分区，你知道你的应用程序是否能从这种情况中恢复吗？现在，想象一下你有一个推荐系统，它出现了问题，你会在尝试恢复死掉的服务时给客户一个默认的推荐吗？欢迎来到分布式系统的世界，在这里，一旦出现问题，情况可能会变得更糟。始终牢记这一点，并尝试为任何情况做好准备。
- en: Each service is different, so keep different repositories and build environments
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个服务都是不同的，因此保持不同的存储库和构建环境
- en: We are decomposing an application into small parts which we want to scale and
    deploy independently, so it makes sense to keep the source in different repositories.
    Having different build environments and repositories means that each microservice
    has its own lifecycle and can be deployed without affecting the rest of your application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将一个应用程序分解成小部分，我们希望对其进行扩展和独立部署，因此将源代码保留在不同的存储库中是有意义的。拥有不同的构建环境和存储库意味着每个微服务都有自己的生命周期，并且可以在不影响应用程序的其他部分的情况下进行部署。
- en: In the subsequent chapters, we will take a deeper look at all these ideas and
    how to implement them using different driven developments.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更深入地研究所有这些想法，以及如何使用不同的驱动开发来实现它们。
- en: Advantages of using PHP on microservices
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP构建微服务的优势
- en: To understand why PHP is a suitable programming language for building microservices,
    we need to take a small peek into its history, where it comes from, which problems
    it was trying to solve, and the evolution of the language.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么PHP是构建微服务的合适编程语言，我们需要稍微了解一下它的历史，它的起源，它试图解决的问题以及语言的演变。
- en: A short history of PHP
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP的简短历史
- en: In 1994, Rasmus Lerdorf created what we can say was the first version of PHP.
    He built a small suite of **Common Gateway Interfaces** (**CGIs**) in the C programming
    language to maintain his personal web page. This suite of scripts was called *Personal
    Home Page Tools*, but it was more commonly referenced as *PHP Tools*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 1994年，Rasmus Lerdorf创建了我们可以说是PHP的第一个版本。他用C语言构建了一套小型的**公共网关接口**（**CGI**）来维护他的个人网页。这套脚本被称为*个人主页工具*，但更常被称为*PHP工具*。
- en: Time passed and Rasmus rewrote and extended the suite so that it could work
    with web forms and have the ability to communicate with databases. This new implementation
    was called *Personal Home Page/Forms Interpreter* or *PHP/FI* and served as a
    framework upon which other developers could build dynamic web applications. In
    June 1995, the source code was opened to the public under the name of *Personal
    Home Page Tools* (*PHP Tools*) *version 1.0*, allowing developers from all over
    the world to use it, fix bugs and improve the suite.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 时间过去了，Rasmus重写并扩展了这套脚本，使其能够与Web表单一起工作，并具有与数据库通信的能力。这个新的实现被称为*个人主页/表单解释器*或*PHP/FI*，并作为其他开发人员可以构建动态Web应用程序的框架。1995年6月，源代码以*个人主页工具*（*PHP工具*）*版本1.0*的名义向公众开放，允许世界各地的开发人员使用它，修复错误并改进这套脚本。
- en: The first idea around PHP/FI was not to create a new programming language, and
    Lerdorf let it grow organically, leading to some problems like the inconsistency
    of function names or their parameters. Sometimes the function names were the same
    as the low-level libraries that PHP was using.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: PHP/FI的最初想法并不是创建一种新的编程语言，Lerdorf让它自然生长，导致了一些问题，比如函数名称或参数的不一致性。有时函数名称与PHP正在使用的低级库相同。
- en: In October 1995, Rasmus released a new rewrite of the code; this was the first
    release that was considered as an advanced scripting interface and PHP started
    to become the programming language that it is today.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 1995年10月，Rasmus发布了代码的新重写；这是第一个被认为是高级脚本接口的发布，PHP开始成为今天的编程语言。
- en: As a language, PHP was designed to be very similar to C in structure so that
    it would be easier to be adopted by developers who were familiar with C, Perl,
    or similar languages. Along with the growth of the features of the language, the
    number of early adopters also began to grow. A Netcraft survey of May, 1998 indicated
    that nearly 60,000 domains had headers containing PHP (around 1% of the domains
    on the Internet at the time), which indicated that the hosting server had it installed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种语言，PHP的设计与C语言的结构非常相似，因此对于熟悉C、Perl或类似语言的开发人员来说更容易被接受。随着语言功能的增长，早期采用者的数量也开始增长。1998年5月的Netcraft调查显示，几乎有6万个域名包含了PHP的头部信息（占当时互联网域名的1%左右），这表明主机服务器已经安装了PHP。
- en: One important point in PHP history was when Andi Gutmans and Zeev Suraski of
    Tel Aviv, Israel, joined the project in 1997\. At this time, they did another
    complete rewrite of the parser and started the development of a new and independent
    programming language. This new language was named PHP, with the meaning becoming
    a recursive acronym---**PHP **(**Hypertext Preprocessor**).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: PHP历史上的一个重要时刻是1997年以色列特拉维夫的Andi Gutmans和Zeev Suraski加入了这个项目。在这个时候，他们对解析器进行了另一次完全重写，并开始开发一种新的独立编程语言。这种新语言被命名为PHP，意思是递归缩写---**PHP**（**超文本预处理器**）。
- en: The official release of PHP 3 was in June 1998, including a great number of
    features that made the language suitable for all kinds of projects. Some of the
    features included were a mature interface for multiple databases, support for
    multiple protocols and APIs, and the ease of extending the language itself. Among
    all the features, the most important ones were the inclusion of object-oriented
    programming and a more powerful and consistent language syntax.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 3的官方发布是在1998年6月，包括了许多功能，使该语言适用于各种项目。其中一些功能包括成熟的多数据库接口，支持多种协议和API，以及扩展语言本身的便利性。在所有功能中，最重要的是包括了面向对象编程和更强大、一致的语言语法。
- en: Andi Gutmans and Zeev Suraski founded Zend Technologies and started the rewrite
    of PHP's core, creating the Zend Engine in 1999\. Zend Technologies became the
    most important PHP company and the main contributor to the source code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Andi Gutmans和Zeev Suraski成立了Zend Technologies，并于1999年开始重写PHP的核心，创建了Zend引擎。Zend
    Technologies成为了最重要的PHP公司，也是源代码的主要贡献者。
- en: This was only the beginning and as years passed, PHP grew in features, language
    stability, maturity, and developer adoption.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个开始，随着时间的推移，PHP在功能、语言稳定性、成熟度和开发者采用方面不断增长。
- en: PHP milestones
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP的里程碑
- en: Now that we have some historical background, we can focus on the main milestones
    achieved by PHP throughout the years. Each release increased the language stability
    and added more and more features.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一些历史背景，我们可以专注于PHP在这些年里取得的主要里程碑。每个版本都增加了语言的稳定性，并添加了越来越多的功能。
- en: Version 4.x
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.x版本
- en: PHP 4 was the first release, which included the Zend Engine. This engine increased
    the average performance of PHP. Along with the Zend Engine, PHP 4 included support
    for more web servers, HTTP sessions, output buffering, and increased security.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 4是第一个包含Zend引擎的版本。这个引擎提高了PHP的平均性能。除了Zend引擎，PHP 4还包括对更多Web服务器、HTTP会话、输出缓冲和增强安全性的支持。
- en: Version 5.x
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.x版本
- en: PHP 5 was released on July 13, 2004 using the Zend Engine II, which increased
    the language performance once again. This release included important improvements
    for **object-oriented** (**OO**) programming, making the language more flexible
    and robust. Now, users were able to choose between developing applications in
    a procedural or a stable OO way; they could have the best of both worlds. In this
    release, one of the most important extensions used to connect to data stores was
    also included---the **PHP Data Objects** (**PDO**) extension.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 5于2004年7月13日发布，使用了Zend Engine II，再次提高了语言的性能。这个版本包括了对**面向对象**（**OO**）编程的重要改进，使语言更加灵活和健壮。现在，用户可以选择以过程化或稳定的面向对象方式开发应用程序；他们可以兼得两者的优点。在这个版本中，还包括了连接到数据存储的最重要的扩展之一---**PHP数据对象**（**PDO**）扩展。
- en: With PHP 5 becoming the most stable version in 2008, many open source projects
    started ending their support for PHP 4 in their new code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 随着PHP 5在2008年成为最稳定的版本，许多开源项目开始在他们的新代码中终止对PHP 4的支持。
- en: Version 6.x
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.x版本
- en: 'This release was one of the most famous failures for PHP. The development of
    this major release started in 2005 but, in 2010, it was abandoned due to difficulties
    with the Unicode implementation. Not all the work was thrown away and most of
    the features, one of them being namespaces, were added to the previous releases.
    As a side note, version 6 is generally associated with a failure in the tech world:
    PHP 6, Perl 6, and even MySQL 6 were never released.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本是PHP最著名的失败之一。这个主要版本的开发始于2005年，但在2010年因Unicode实现的困难而被放弃。并非所有的工作都被抛弃，大部分功能，其中包括命名空间，都被添加到了之前的版本中。顺便说一句，版本6通常与技术世界中的失败联系在一起：PHP
    6、Perl 6，甚至MySQL 6都从未发布。
- en: Version 7.x
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.x版本
- en: This was a long awaited release---one release to rule them all and a release
    with performance levels seen never before.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个期待已久的发布---一个统治所有的发布，一个具有前所未有的性能水平的发布。
- en: On December 3, 2015, version 7.0.0 was released with the last Zend Engine available.
    The performance increase obtained only by changing the running version on your
    machine reached up to 70%, with a very small memory footprint.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年12月3日，发布了最后一个Zend引擎的7.0.0版本。仅通过在您的机器上更改运行版本，性能提高了70%，内存占用非常小。
- en: The language also evolved, and PHP now had a better 64-bit support and a secure
    random number generator. Now you could create anonymous classes or define return
    types among other major changes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 语言也在不断发展，PHP现在具有更好的64位支持和安全的随机数生成器。现在你可以创建匿名类或定义返回类型等其他重大改变。
- en: This release became serious competition to the other so-called *enterprise languages*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本成为了其他所谓的*企业语言*的严肃竞争对手。
- en: Advantages
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优势
- en: 'PHP is one of the most used programming languages you can use to build your
    web projects. In case you are not yet sure if PHP is the appropriate language
    for your next application, let us now to tell you the main advantages of using
    PHP:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: PHP是你可以用来构建你的Web项目的最常用的编程语言之一。如果你还不确定PHP是否适合你的下一个应用程序，让我们告诉你使用PHP的主要优势：
- en: '**Big community**: It''s very easy to engage in conferences, events, and meetups
    all over the world with ZendCon, PHP[world], or International PHP Conference.
    Not only can you talk to other PHP developers at events and conferences, but you
    can join IRC/Slack channels or mailing lists to ask questions and keep yourself
    updated. One of the many locations where you can find events near your area is
    on the official site at [http://php.net/cal.php](http://php.net/cal.php).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**庞大的社区**：很容易参加全球各地的ZendCon、PHP[world]或国际PHP大会等会议、活动和聚会。你不仅可以在活动和会议上与其他PHP开发者交流，还可以加入IRC/Slack频道或邮件列表提问和保持更新。你可以在官方网站上的[http://php.net/cal.php](http://php.net/cal.php)找到附近地区的活动地点之一。'
- en: '**Great documentation**: The main point of information about the language is
    available on the PHP website ([http://php.net/docs.php](http://php.net/docs.php)).
    This reference guide covers every aspect of PHP, from basic control flows to advanced
    topics. Do you want to read a book? No problem, it will be easy to find a suitable
    book among more than 15,000 Amazon references. Even if you need more information,
    a quick search on Google will give you more than 9,300,000,000 results.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档齐全**：关于这种语言的主要信息可以在PHP网站上找到（[http://php.net/docs.php](http://php.net/docs.php)）。这个参考指南涵盖了PHP的每个方面，从基本的控制流到高级主题。你想读一本书吗？没问题，你很容易在15000多本亚马逊参考书中找到合适的书。即使你需要更多信息，快速在谷歌上搜索就会给你超过93亿的结果。'
- en: '**Stable**: The PHP project makes frequent releases and maintains several major
    releases at the same time until their scheduled **End Of Life** (**EOL**). Usually,
    the time between a release and its EOL is enough to move to the next mainstream
    version.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳定**：PHP项目经常发布版本，并同时维护几个主要版本，直到它们计划的**生命周期结束**（**EOL**）。通常，发布和EOL之间的时间足以转移到下一个主流版本。'
- en: '**Easy to deploy**: PHP is the most popular server-side programming language
    with an 81.8% usage in August 2016, so the market moves in the same direction.
    It is very easy to find a hosting provider with PHP preinstalled and ready to
    use, so you only need to deal with the deploy.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于部署**：PHP是最受欢迎的服务器端编程语言，在2016年8月的使用率达到81.8%，所以市场也朝着同一个方向发展。很容易找到一个预安装了PHP并且可以直接使用的托管提供商，所以你只需要处理部署的问题。'
- en: There are a number of ways of deploying your code into production. For instance,
    you can track your code in a Git repository and do a Git pull on your server later.
    You could also push your files through FTP to the public location.You can even
    build a **Continuous Integration**/**Continuous Delivery** (**CI**/**CD**) system
    with Jenkins, Docker, Terraform, Packer, Ansible, or other tools. The complexity
    of the deploy will always match the project complexity.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多部署代码到生产环境的方法。例如，你可以在Git存储库中跟踪你的代码，然后稍后在服务器上进行Git拉取。你也可以通过FTP将文件推送到公共位置。你甚至可以使用Jenkins、Docker、Terraform、Packer、Ansible或其他工具构建一个**持续集成**/**持续交付**（**CI**/**CD**）系统。部署的复杂性将始终与项目的复杂性相匹配。
- en: '**Easy to install**: PHP has prebuilt packages for the major operating systems:
    it can be installed on Linux, Mac, Windows, or Unix. Sometimes the packages are
    available inside the package system (for instance, apt). In other cases, you need
    external tools to install it, such as Homebrew. In the worst case scenario, you
    can download the source code and compile it on your machine.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于安装**：PHP在主要操作系统上都有预构建的软件包：它可以安装在Linux、Mac、Windows或Unix上。有时软件包可以在软件包系统内获得（例如apt）。在其他情况下，你需要外部工具来安装它，比如Homebrew。在最坏的情况下，你可以下载源代码并在你的机器上编译它。'
- en: '**Open Source**: All the PHP source code is available at GitHub, so it is really
    simple for any developer to take a deep look at how everything works. This openness
    allows a programmer to participate in the project, extending the language or fixing
    the bugs. The license used in PHP is a **Berkeley Software Distribution** (**BSD**)
    style license without the *copyleft* restrictions associated with GPL.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开源**：所有PHP源代码都可以在GitHub上找到，因此任何开发人员都可以轻松地深入了解一切是如何工作的。这种开放性允许程序员参与项目，扩展语言或修复错误。PHP使用的许可证是**伯克利软件发行**（**BSD**）风格的许可证，没有与GPL相关的*版权*限制。'
- en: '**High running speed (PHP 7)**: In the past, PHP was not fast enough, but this
    situation changed completely with PHP 7\. This major release is based on the **PHP
    Next-Gen** (**PHPNG**) project with Zend Technologies as the leader. The idea
    behind PHPNG was to speed up PHP applications and they did this very well. The
    performance gains can vary between 25% and 70% only by changing the PHP version.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高运行速度（PHP 7）**：过去，PHP的速度不够快，但这种情况在PHP 7中完全改变了。这个主要版本是基于**PHP Next-Gen**（**PHPNG**）项目，由Zend
    Technologies领导。PHPNG的理念是加速PHP应用程序，他们做得非常好。仅通过更改PHP版本，性能提升可以在25%到70%之间变化。'
- en: '**High number of frameworks and libraries available**: The PHP ecosystem is
    very rich in libraries and frameworks. The common way to find a suitable library
    for your project is using PEAR and PECL.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大量可用的框架和库**：PHP生态系统在库和框架方面非常丰富。找到适合你的项目的库的常见方法是使用PEAR和PECL。'
- en: Regarding the available frameworks, you can use one of the best, for example
    Zend Framework, Symfony, Laravel, Phalcon, CodeIgniter, or you can build one from
    scratch if you can't find one that meets your requirements. The best part about
    this is that all of these are open source, so you can always extend them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可用的框架，你可以使用最好的之一，例如Zend Framework、Symfony、Laravel、Phalcon、CodeIgniter，或者如果找不到符合你要求的框架，你可以从头开始构建一个。最好的部分是所有这些都是开源的，所以你可以随时扩展它们。
- en: '**High development speed**: PHP has a relatively small learning curve, which
    can help you start coding from the beginning. Also, the similarities in syntax
    with C, Perl, and other languages can make you understand how everything works
    in no time. PHP avoids wasting time waiting for the compiler to generate our build.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高开发速度**：PHP具有相对较小的学习曲线，这可以帮助你从头开始编码。此外，与C、Perl和其他语言的语法相似性可以让你很快理解一切是如何工作的。PHP避免了等待编译器生成我们的构建所浪费的时间。'
- en: '**Easy to debug**: As you probably know, PHP is an interpreted language. Therefore,
    when trying to solve an issue, you have multiple options to succeed. The easy
    way is dropping a few `var_dump` or `print_r` calls to view what the code is doing.
    For a deeper view of the execution, you can link your IDE to Xdebug or Zend Debug
    and start tracing your application.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于调试**：你可能知道，PHP是一种解释性语言。因此，在解决问题时，你有多种选择。简单的方法是放置一些`var_dump`或`print_r`调用来查看代码的执行情况。为了更深入地查看执行情况，你可以将你的IDE链接到Xdebug或Zend
    Debug，并开始跟踪你的应用程序。'
- en: '**Easy to test**: No modern programming language will survive in the wild without
    an appropriate test suite, so you have to ensure that your application will continue
    running as expected. Don''t worry, the PHP community has your back as you have
    available multiple tools to do any kind of tests. For instance, you can use PHPUnit
    for your **Test Driven Development** (**TDD**), or Behat if you are following
    a **Behavior Driven Development** (**BDD**).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于测试**：没有现代编程语言能在野外生存而没有适当的测试套件，所以你必须确保你的应用程序将继续按预期运行。不用担心，PHP社区支持你，因为你有多种工具可进行任何类型的测试。例如，你可以使用PHPUnit进行你的**测试驱动开发**（**TDD**），或者如果你遵循**行为驱动开发**（**BDD**），可以使用Behat。'
- en: '**You can do anything**: PHP is a modern programming language with multiple
    applications in the real world. Therefore, only sky is the limit! You can build
    a GUI application using the GTK extension, or you can create a terminal command
    with all the required files in a phar archive. The language has no limitations,
    so anything can be built.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你可以做任何事情**：PHP是一种现代编程语言，在现实世界中有多种应用。因此，只有天空是极限！你可以使用GTK扩展构建GUI应用程序，或者你可以在phar存档中创建一个包含所有所需文件的终端命令。这种语言没有限制，所以任何东西都可以构建。'
- en: Disadvantages
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺点
- en: 'Like any programming language, PHP also has some disadvantages. Some of the
    most common mentioned disadvantages flagged are: security issues, unsuitable for
    large applications, and weak types. PHP started as a collection of CGIs and has
    become more modern and robust throughout the years, so it is pretty robust and
    flexible for a young programming language (in comparison with other languages).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何编程语言一样，PHP也有一些缺点。一些最常见的缺点包括：安全问题，不适合大型应用程序和弱类型。PHP最初是一组CGI的集合，并且随着多年的发展变得更加现代和健壮，因此与其他语言相比，它非常健壮和灵活。
- en: In any case, an experienced developer will have no problem overcoming these
    disadvantages when building their application if they use the best practices.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，有经验的开发人员在构建应用程序时，如果使用最佳实践，就不会遇到这些缺点。
- en: As you can already see, the evolution of PHP was enormous. It has one of the
    most vibrant communities, was made for the web, and has all the power you need
    to create any kind of project. Without a doubt, PHP will be the right language
    for you to express your best ideas.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经看到的，PHP的发展是巨大的。它拥有最活跃的社区之一，是为网络而生，并且具有创建任何类型项目所需的所有功能。毫无疑问，PHP将是您表达最佳创意的正确语言。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how microservices stand against monolithic architecture
    and SOA. We learned about the essential components of microservices architecture
    along with its advantages and disadvantages. Further along the chapter, we looked
    at how to implement the microservices architecture and the prerequisites to take
    into consideration before switching to microservices. Later, we covered the history
    of PHP versions along with their advantages and disadvantages.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了微服务与单体架构和SOA的对比。我们了解了微服务架构的基本组件及其优缺点。在本章的后半部分，我们讨论了如何实施微服务架构以及在转向微服务之前需要考虑的先决条件。随后，我们介绍了PHP版本的历史以及它们的优缺点。
