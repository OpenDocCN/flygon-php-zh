- en: Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程
- en: Every so often, there is a shift in the software industry. A shift that enriches
    the ecosystem with ideas promising easier systems and application development.
    The driving force behind which is mostly the Internet nowadays, as it is a medium
    for all connected applications, not just those running in our browser. Majority
    of mobile users consume a large number of cloud services, without even realizing
    it. Ensuring consistent user experience in such a connected world is a challenge addressed
    in multiple ways. One such viewpoint is the reactivity, where programming language
    itself plays an important role.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件行业时不时会发生变革。这种变革丰富了思想，承诺更容易的系统和应用程序开发。如今，驱动这一切的主要是互联网，因为它是所有连接应用程序的媒介，不仅仅是在我们的浏览器中运行的应用程序。大多数移动用户消费大量的云服务，甚至没有意识到。在这样一个互联的世界中确保一致的用户体验是一个以多种方式解决的挑战。响应性就是其中一种观点，其中编程语言本身起着重要作用。
- en: Traditionally, PHP follows the synchronous programming model and is not really
    fit for asynchronous programming. Although the standard library already has everything
    needed to write asynchronous I/O applications, the reality could not be far from
    different. Both MySQLi and MySQL (PDO), for example, remain blocking, making asynchronous
    programming with PHP useless. Luckily, the tides are shifting, and awareness about asynchronous
    is coming about with PHP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，PHP遵循同步编程模型，不太适合异步编程。尽管标准库已经包含了编写异步I/O应用程序所需的一切，但现实可能大相径庭。例如，MySQLi和MySQL（PDO）仍然是阻塞的，使得使用PHP进行异步编程毫无意义。幸运的是，形势正在改变，人们对PHP的异步性有了更多的认识。
- en: Reactive programming is an emerging topic of the software industry that builds
    on top of observables as its primitive. We associate asynchronous behavior with
    it, as observables provide an ideal way to access asynchronous sequences of multiple
    items. On a higher level, it's just another programming paradigm, just as procedural,
    object-oriented, declarative, and functional programming are. While it requires
    a certain mind shift to adopt observables, operators, observers, and other building
    blocks, in return, it allows greater expressiveness and unidirectional data flow,
    leading to cleaner and simpler code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是软件行业的新兴话题，它建立在可观察对象的基础上。我们将其与异步行为联系在一起，因为可观察对象提供了访问多个项目的异步序列的理想方式。在更高的层面上，它只是另一种编程范式，就像过程式、面向对象、声明式和函数式编程一样。虽然采用可观察对象、操作符、观察者和其他构建块需要一定的思维转变，但作为回报，它允许更大的表现力和单向数据流，从而导致更清洁和简单的代码。
- en: 'In this chapter,  we will take a closer look at the following sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更详细地研究以下几个部分：
- en: Similarities with event-driven programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与事件驱动编程的相似之处
- en: 'Using RxPHP:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxPHP：
- en: Installing RxPHP
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装RxPHP
- en: Observable and observer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象和观察者
- en: Subject
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题
- en: Operator
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符
- en: Writing custom operator
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义操作符
- en: Non-blocking I/O
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非阻塞I/O
- en: 'Using React:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React：
- en: Installing React
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装React
- en: React event loop
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React事件循环
- en: Observable and event loop
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象和事件循环
- en: Similarities with event-driven programming
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与事件驱动编程的相似之处
- en: 'Wikipedia defines reactive programming as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科对响应式编程的定义如下：
- en: '"A programming paradigm oriented around data flows and the propagation of change."'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: “以数据流和变化传播为导向的编程范式。”
- en: 'The very first thought of this may imply some similarities to a well-known
    event-driven programming. The data flows and the propagation of change sound a
    bit like something we may implement via the `\SplSubject`, `\SplObjectStorage`,
    and `\SplObserver` interfaces in PHP, as per the following trivial example. The
    `\SplObjectStorage` interface further encapsulates the `\Countable`, `\Iterator`,
    `\Traversable`, `\Serializable`, and `\ArrayAccess` interfaces:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法的第一印象可能暗示与众所周知的事件驱动编程有些相似。数据流和变化的传播听起来有点像我们可以通过PHP中的`\SplSubject`、`\SplObjectStorage`和`\SplObserver`接口来实现的东西，如下面的琐碎例子所示。`\SplObjectStorage`接口进一步封装了`\Countable`、`\Iterator`、`\Traversable`、`\Serializable`和`\ArrayAccess`接口：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We may say that data flows translate to a sequence of updates coming from the `$userRegister`
    instance's `notify()` method, the propagation of change translates to triggering
    the `update()` method of the mailer and logger instances, and the `\SplObjectStorage` method
    plays an important role This is just a trivial and superficial interpretation
    of the reactive programming paradigm in the context of the PHP code. Furthermore,
    there is no asynchronicity here at the moment. The PHP runtime and standard library
    effectively offer all that is needed to write asynchronous code. Throwing in a
    *reactivity* in the mix, is merely a matter of choosing the right library.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，数据流转化为从`$userRegister`实例的`notify()`方法传来的更新序列，变化的传播转化为触发`mailer`和`logger`实例的`update()`方法，而`\SplObjectStorage`方法则起着重要作用。这只是在PHP代码的上下文中对响应式编程范式的一个琐碎和肤浅的解释。此外，目前这里没有异步性。PHP运行时和标准库有效地提供了编写异步代码所需的一切。在其中加入*响应性*，只是选择合适的库的问题。
- en: While the choice of PHP libraries for reactive programming isn't nearly as rich
    as those of the JavaScript ecosystem, there are a few noteworthy ones, such as **RxPHP** and **React**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管PHP反应式编程的库选择远不及JavaScript生态系统丰富，但有一些值得注意的库，如RxPHP和React。
- en: Using RxPHP
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RxPHP
- en: 'Originally developed by Microsoft for the .NET platform, a set of libraries
    named **ReactiveX** (**reactive extensions**) is available at [http://reactivex.io](http://reactivex.io). ReactiveX
    allows us to write asynchronous and event-based programs using observable sequences.
    They do so by abstracting away low-level concerns such as non-blocking I/O, which
    we will talk about later. Over time, several programming languages made their own
    implementations of ReactiveX, following a nearly identical design pattern. The
    PHP implementation, named RxPHP, can be downloaded from [https://github.com/ReactiveX/RxPHP](https://github.com/ReactiveX/RxPHP):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最初由微软为.NET平台开发，名为**ReactiveX**（响应式扩展）的一组库可在[http://reactivex.io](http://reactivex.io)上找到。
    ReactiveX允许我们使用可观察序列编写异步和基于事件的程序。 他们通过抽象化低级关注点（例如非阻塞I/O）来实现这一点，我们稍后会谈论。 随着时间的推移，几种编程语言制作了自己的ReactiveX实现，遵循几乎相同的设计模式。
    名为RxPHP的PHP实现可以从[https://github.com/ReactiveX/RxPHP](https://github.com/ReactiveX/RxPHP)下载：
- en: '![](assets/2e6cd07e-5278-44a0-bf41-28da819dc572.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2e6cd07e-5278-44a0-bf41-28da819dc572.png)'
- en: Installing RxPHP
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装RxPHP
- en: 'The RxPHP library is available as a Composer `reactivex/rxphp` package. Assuming
    we already installed PHP and Composer, we can simply execute the following command
    in an empty directory:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: RxPHP库可作为Composer`reactivex/rxphp`包使用。 假设我们已经安装了PHP和Composer，我们可以在空目录中简单地执行以下命令：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This should give us an output similar to the following one:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们一个类似以下的输出：
- en: '![](assets/fd7135e9-4256-4fe9-9950-72f5b86a3c0e.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fd7135e9-4256-4fe9-9950-72f5b86a3c0e.png)'
- en: 'The output suggests installing `react/event-loop`; we need to be sure to follow
    up on that by executing the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 输出建议安装`react/event-loop`；我们需要确保执行以下命令进行跟进：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This should give us an output much like the following one:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们一个类似以下的输出：
- en: '![](assets/8627f3dc-2c79-4815-babe-131e0476128d.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8627f3dc-2c79-4815-babe-131e0476128d.png)'
- en: All that remains now is to create an `index.php` file, which includes `autoload.php` file
    generated by Composer, and we are ready to start playing with
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是创建一个`index.php`文件，其中包括由Composer生成的`autoload.php`文件，然后我们就可以开始玩了
- en: '![](assets/ccd5737a-95a9-4f41-be15-b8026849479e.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ccd5737a-95a9-4f41-be15-b8026849479e.png)'
- en: 'The RxPHP library is comprised of several key components, the most basic ones
    being the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: RxPHP库由几个关键组件组成，其中最基本的是以下内容：
- en: Observable
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察
- en: Observer
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: Subject
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题
- en: Operator
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作员
- en: Moving forward, let's take a closer look at each of these components.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，让我们更仔细地看看每个组件。
- en: Observable and observer
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察和观察者
- en: 'In our introduction example, we touched upon the observer pattern using `\SplSubject`
    and `\SplObserver`. Now, we are introducing an RxPHP observable and observer component.
    We might say that `\SplSubject` is analogous to `Rx\Observable`, whereas `\SplObserver`
    is analogous to `Rx\Observer\CallbackObserver`. The whole SPL and Rx, however,
    are only superficially analogous. `Rx\Observable` is more powerful than `\SplObserver`.
    We can think of `Rx\Observable` as a lazy source of event, a thing that produces
    value over time. Observables emit the following three types of events to their
    observers:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的介绍示例中，我们提到了使用`\SplSubject`和`\SplObserver`的观察者模式。 现在，我们正在介绍RxPHP可观察和观察者组件。
    我们可能会说`\SplSubject`类似于`Rx\Observable`，而`\SplObserver`类似于`Rx\Observer\CallbackObserver`。
    然而，整个SPL和Rx只是表面上类似。 `Rx\Observable`比`\SplObserver`更强大。 我们可以将`Rx\Observable`视为事件的惰性源，一种随时间产生值的东西。
    可观察对象向其观察者发出以下三种类型的事件：
- en: The current item in the stream
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流中的当前项目
- en: The error, if one occurred
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误，如果发生了错误
- en: The complete state
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的状态
- en: In a nutshell, it is a reactive data source that knows how to signal internal
    data changes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，它是一个知道如何发出内部数据更改信号的响应式数据源。
- en: 'Let''s take a look at the following simple example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的简单例子：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of which is as :'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 其输出如下：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We see that the `subscribe()` method of the `Observable` instance accepts an
    instance of `CallbackObserver`. Each of the three parameters of an observer is
    a callback function. The first callback handles the stream item, the second returns
    potential error, and the third indicates a completed stream.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`Observable`实例的`subscribe()`方法接受`CallbackObserver`的实例。 观察者的三个参数中的每一个都是回调函数。
    第一个回调处理流项目，第二个返回潜在错误，第三个指示已完成的流。
- en: 'RxPHP provides few a type of observables:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: RxPHP提供了几种类型的可观察对象：
- en: '`AnonymousObservable`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnonymousObservable`'
- en: '`ArrayObservable`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayObservable`'
- en: '`ConnectableObservable`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConnectableObservable`'
- en: '`EmptyObservable`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmptyObservable`'
- en: '`ErrorObservable`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ErrorObservable`'
- en: '`ForkJoinObservable`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForkJoinObservable`'
- en: '`GroupedObservable`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GroupedObservable`'
- en: '`IntervalObservable`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntervalObservable`'
- en: '`IteratorObservable`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IteratorObservable`'
- en: '`MulticastObservable`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MulticastObservable`'
- en: '`NeverObservable`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NeverObservable`'
- en: '`RangeObservable`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RangeObservable`'
- en: '`RefCountObservable`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RefCountObservable`'
- en: '`ReturnObservable`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReturnObservable`'
- en: '`TimerObservable`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimerObservable`'
- en: 'Let''s take a look at a more elaborate example of observable and observer:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个更详细的例子：可观察和观察者
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We started off by creating a simple generator function called `users()`. The
    great thing about generators is that they act as iterator, which makes it easy
    to create RxPHP observables from them using the `fromIterator()` method. Once
    we have the observable, we can chain few of its methods, such as `map()` and `filter()`,
    together. This way, we control the data stream hitting our subscribed observer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个名为`users()`的简单生成器函数。 生成器的好处是它充当迭代器，这使得使用`fromIterator()`方法从中创建RxPHP可观察对象变得容易。
    一旦我们有了可观察对象，我们可以将其方法链接在一起，例如`map()`和`filter()`。 通过这种方式，我们控制了流向我们订阅的观察者的数据流。
- en: 'Assume the `users.csv` file with following content:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`users.csv`文件包含以下内容：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the preceding code should be something like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出应该是这样的：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s assume that we want to attach multiple observers to our `$users`
    stream:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要将多个观察者附加到我们的`$users`流：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This won''t work. The code won''t throw any error, but the result might not
    be what we would expect it to be:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会起作用。 代码不会抛出任何错误，但结果可能不是我们期望的：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We cannot really attach multiple subscribers this way. The first attached observer
    consumes the stream, which is why the second observer sees it empty. This is where
    the `Rx\Subject\Subject` component may come in handy.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能通过这种方式真正附加多个订阅者。第一个附加的观察者消耗了流，这就是为什么第二个观察者看到它是空的。这就是`Rx\Subject\Subject`组件可能会派上用场的地方。
- en: Subject
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题
- en: '`Rx\Subject\Subject` is an interesting component--it''s a class that acts both
    as observable and observer. The benefit of this is seen in the following example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rx\Subject\Subject`是一个有趣的组件--它既充当可观察对象又充当观察者。这种好处在以下示例中得以体现：'
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using the anonymous classes, we were able to extend the `Rx\Subject\Subject` class
    on-the-fly. The underlying `onCompleted()`, `onError(Exception $error)`, and `onNext($value)`
    methods are where we *tap into* our observer-related logic. Once executed, the
    code results in the following output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用匿名类，我们能够即时扩展`Rx\Subject\Subject`类。底层的`onCompleted()`，`onError(Exception $error)`和`onNext($value)`方法是我们连接到观察者相关逻辑的地方。一旦执行，代码的输出如下：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What is happening here is that the mailer first taps into the stream, and then
    streams back into the logger stream. This is possible because of the dual nature
    of `Rx\Subject\Subject`. It is important to note that the logger does not observe
    the original stream. We can test this easily by adding the filter to `$mailer`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的是邮件程序首先进入流，然后流回到记录器流。这是因为`Rx\Subject\Subject`的双重性质才可能。重要的是要注意记录器不观察原始流。我们可以通过将过滤器添加到`$mailer`来轻松测试这一点：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The resulting output will now omit the user named on the logger observer:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的输出将不包括记录器观察者上的用户名：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Operator
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符
- en: The observable model of RxPHP allows us to treat streams with simple and composable
    operations. Each of these operations is done by an individual operator. The composition
    of operators is possible because operators themselves mostly return observable
    as a result of their operation. A quick peek into the `vendor\reactivex\rxphp\lib\Rx\Operator`
    directory reveals 48 different operator implementations, classified in several
    different categories
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: RxPHP的可观察模型允许我们使用简单和可组合的操作来处理流。每个操作都是由一个单独的操作符完成的。操作符的组合是可能的，因为操作符本身在其操作的结果中大多返回可观察对象。快速查看`vendor\reactivex\rxphp\lib\Rx\Operator`目录，会发现48个不同的操作符实现，分为几个不同的类别
- en: Creating o
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建o
- en: Transforming observables
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换可观察对象
- en: Filtering observables
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤可观察对象
- en: Combining observables
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合可观察对象
- en: Error-handling operators
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理操作符
- en: Observable utility operators
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象实用程序操作符
- en: Conditional and Boolean operators
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件和布尔操作符
- en: Mathematical and aggregate operators
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学和聚合操作符
- en: Connectable observable operators
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可连接的可观察对象操作符
- en: 'The `map`, `filter`, and `reduce` methods are likely the most known and popular operators,
    so let''s start our example with them:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`，`filter`和`reduce`方法可能是最为人熟知和流行的操作符，所以让我们从它们开始我们的示例：'
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We started off by writing a simple generator function called `xrange()`. The
    beauty of the generator here is that the `xrange()` function will always take
    the same amount of memory, regardless of the range we choose. This gives us a
    great foundation to play with the ReactiveX operators. We then created a simple `$observer`,
    utilizing only its `$onNext` callable whilst ignoring the `$onError` and `$onCompleted` callables
    for the purpose of this section. We then created an observable stream from our `xrange()`
    function, passing it a range of 1 to 20. Finally, we got to the point where we
    hooked the `map()`, `filter()`, `reduce()`, and `subscribe()` method calls to
    our observable instance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写了一个名为`xrange()`的简单生成器函数。生成器的美妙之处在于，无论我们选择的范围如何，`xrange()`函数始终占用相同的内存量。这为我们提供了一个很好的基础来使用ReactiveX操作符。然后，我们创建了一个简单的`$observer`，仅利用其`$onNext`可调用，而忽略了`$onError`和`$onCompleted`可调用，以便本节的目的。然后，我们从我们的`xrange()`函数创建了一个可观察流，传递了一个范围从1到20。最后，我们到了将`map()`，`filter()`，`reduce()`和`subscribe()`方法调用连接到我们的可观察实例的地步。
- en: 'If we were to execute this code now, the resulting output would be number `36`.
    To understand where this is coming from, let''s take a step back and comment out
    the `filter()` and `reduce()` methods:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在执行这段代码，结果输出将是数字`36`。要理解这是从哪里来的，让我们退一步并注释掉`filter()`和`reduce()`方法：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output now is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的输出如下：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `map()` function transforms the emitted items by applying a function to
    each item. In this case, that function is `$item * 2`. Now, let''s go ahead and
    restore the `filter()` function, but leave the `reduce()` function commented out:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数通过将函数应用于每个项目来转换发出的项目。在这种情况下，该函数是`$item * 2`。现在，让我们继续恢复`filter()`函数，但将`reduce()`函数注释掉：'
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Knowing now that the `filter()` function will receive the `map()` function
    output stream (`2`, `4`, `6`, ... `20`), we observe the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在知道`filter()`函数将接收`map()`函数输出流（`2`，`4`，`6`，... `20`），我们观察到以下输出：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `filter()` function transforms the emitted items by emitting back only those
    items that pass a predicate test. In this case, the predicate test is `$item %
    3 == 0`, which means, it returns items evenly divisible by `3`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`函数通过仅发出通过谓词测试的项目来转换发出的项目。在这种情况下，谓词测试是`$item % 3 == 0`，这意味着它返回能被`3`整除的项目。'
- en: Finally, if we restore the `reduce()` function, the result comes back as `36`.
    Unlike `map()` and `filter()`, which accept a single emitted item value, the `reduce()` function
    callback accepts two values.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们恢复`reduce()`函数，结果将返回为`36`。与`map()`和`filter()`只接受单个发出的项目值不同，`reduce()`函数回调接受两个值。
- en: 'A quick change to the body of the `reduce()` callback clarifies what''s going
    on:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对`reduce()`回调的快速更改澄清了发生了什么：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This gives output as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can see that `$x` comes in as a value of the first emitted item, whereas
    `$y` comes in as a value of the second emitted item. The function then applies
    sum computation on them, making the return result now a first emitted item in
    the second iteration, basically, giving `(6 + 12) => 18 => (18 + 18) => 36`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`$x`作为第一个发出的项目的值，而`$y`作为第二个发出的项目的值。然后函数对它们进行求和计算，使得返回结果现在是第二次迭代中的第一个发出的项目，基本上是给出了`(6
    + 12) => 18 => (18 + 18) => 36`。
- en: 'Given the sheer number of operators supported by RxPHP, we can imagine the
    real-life complexities we get to solve in an elegant way by simply composing a
    number of operators into a chain, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到RxPHP支持的大量操作符，我们可以想象通过简单地将多个操作符组合成链来解决现实生活中的复杂问题的优雅方式：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If existing operators are not enough, we can easily write our own by extending `Rx\Operator\OperatorInterface`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现有的操作符不够用，我们可以通过扩展`Rx\Operator\OperatorInterface`来轻松编写自己的操作符。
- en: Writing custom operators
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义操作符
- en: 'Though RxPHP provides over 40 operators for us to use, sometimes, there may
    be a need to use an operator that does not exist. Consider the following case:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然RxPHP为我们提供了40多个操作符供我们使用，但有时可能需要使用不存在的操作符。考虑以下情况：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Executing this code with the *correct* `$users` variable gives us the following
    expected output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*正确的*`$users`变量执行此代码会得到以下预期输出：
- en: '![](assets/adcac991-4be4-46cb-a8f4-d86272baeac5.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/adcac991-4be4-46cb-a8f4-d86272baeac5.png)'
- en: 'However, if we were to remove the comment in front of the *faulty* `$user`
    variable, the output comes out slightly unexpected, or at least not how we would
    like to handle it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们去掉*有问题的*`$user`变量前面的注释，输出结果会稍微出乎意料，或者至少不是我们希望处理的方式：
- en: '![](assets/de247ab0-2353-4b00-bf0e-705febf72d38.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/de247ab0-2353-4b00-bf0e-705febf72d38.png)'
- en: 'What we really want is to shift the unserialize logic into the RxPHP operator,
    and have it gracefully handle the unsuccessful `unserialize()` attempts. Luckily,
    writing a custom operator is an easy task. A quick look into the `vendor/reactivex/rxphp/src/Operator/OperatorInterface.php` file
    reveals the following interface:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想要的是将反序列化逻辑转移到RxPHP操作符中，并优雅地处理失败的`unserialize()`尝试。幸运的是，编写自定义操作符是一项简单的任务。快速查看`vendor/reactivex/rxphp/src/Operator/OperatorInterface.php`文件，可以看到以下接口：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Easy enough, the interface only requires a single `__invoke()` method implementation.
    We wrote about the `__invoke()` method extensively in [Chapter 4](d96bd098-e569-4ac7-ba7e-47ad24e3bbfb.xhtml),
    *Magic Behind Magic Methods*. This method gets called when we try to call an object
    as a function. `OperatorInterface`, in this case, lists three arguments to the `__invoke()`
    method, two of which are mandatory:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接口非常简单，只需要实现一个`__invoke()`方法。我们在[第4章](d96bd098-e569-4ac7-ba7e-47ad24e3bbfb.xhtml)中详细介绍了`__invoke()`方法，*魔术方法背后的魔术*。当我们尝试将对象作为函数调用时，将调用此方法。在这种情况下，`OperatorInterface`列出了`__invoke()`方法的三个参数，其中两个是必需的。
- en: '`$observable`: This will be our input observable to which we subscribe'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$observable`：这将是我们的输入可观察对象，我们将订阅它'
- en: '`$observer`: This is where we will emit our output value'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$observer`：这是我们将发出输出值的地方'
- en: 'With that in mind, the following is an implementation of our custom `UnserializeOperator`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，以下是我们自定义`UnserializeOperator`的实现：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Unfortunately, we cannot chain our operator directly as we chain the RxPHP
    operators. We need to help ourselves with the `lift()` operator:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法像链式调用RxPHP操作符那样直接链式调用我们的操作符。我们需要使用`lift()`操作符来帮助自己：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With `UnserializeOperator` in place, the faulty serialized `$users` string
    now gives the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`UnserializeOperator`，有问题的序列化`$users`字符串现在会得到以下输出：
- en: '![](assets/540a7acd-603e-456b-bd8b-8d5eb4af2f0c.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/540a7acd-603e-456b-bd8b-8d5eb4af2f0c.png)'
- en: Our operator is now successfully handling errors, in that, it is delegating
    them onto the observer `onError` callback.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的操作符现在成功地处理错误，即将它们委托给观察者的`onError`回调。
- en: Making the best out of RxPHP is mostly about knowing the ins and outs of its
    operators. The `vendor/reactivex/rxphp/demo/` directory provides quite a few operator
    usage examples. It is worth spending some time going through each.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 充分利用RxPHP主要是了解其操作符的各个方面。`vendor/reactivex/rxphp/demo/`目录提供了许多操作符使用示例。值得花一些时间逐个查看。
- en: Non-blocking IO
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非阻塞IO
- en: Using the RxPHP extensions opens up quite a few possibilities. Its observables,
    operators, and subscribers/observers implementations are certainly powerful. What
    they don't provide, however, is asynchronicity. This is where the React library
    comes into play, by providing an event-driven, non-blocking I/O abstraction layer.
    Before we touch upon React, let's first lay out a trivial example of blocking
    versus non-blocking I/O in PHP.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RxPHP扩展开启了许多可能性。它的可观察对象、操作符和订阅者/观察者实现确实很强大。然而，它们没有提供异步性。这就是React库发挥作用的地方，它提供了一个基于事件驱动的、非阻塞的I/O抽象层。在我们讨论React之前，让我们先举一个PHP中阻塞与非阻塞I/O的简单例子。
- en: We create a small *beacon* script that will merely generate some **standard
    output** (**stdout**) over time. Then, we will create a script that reads from
    the **standard input** (**stdin**) and see how it behaves when reading is done
    in the stream blocking and stream non-blocking mode.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个小的*信标*脚本，它只会随着时间生成一些**标准输出**（**stdout**）。然后，我们将创建一个从**标准输入**（**stdin**）读取的脚本，并查看在读取时以流阻塞和流非阻塞模式下的行为。
- en: 'We start by creating the `beacon.php` file with the following content:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建`beacon.php`文件，内容如下：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The use of `$argv[1]` hints that the file is intended to be run from console.
    Using `$argv[1]`, we provide a number of seconds we wish the script to run. Within
    the loop, we have a signal... output, followed by a short `0.2` seconds of script
    sleep.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`$argv[1]`表明该文件是用于从控制台运行。使用`$argv[1]`，我们提供希望脚本运行的秒数。在循环内，我们有一个信号...输出，然后是短暂的`0.2`秒脚本休眠。
- en: 'With our beacon script in place, let''s go ahead and create `index.php` file
    with the following content:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的信标脚本已经就位，让我们继续创建`index.php`文件，内容如下：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Aside from two obvious start/end outputs, we utilize the `fgets()` function
    to read from the standard input.  `stream_set_blocking()` method is deliberately
    left commented out for the moment. Notice that the two scripts are completely
    unrelated to each other. At no point is `index.php` referencing the `beacon.php`
    file. This is because we will use the console and its pipe (`|`) to bridge the
    stdout of the `beacon.php` script to a stdin consumed by the `index.php` :'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了两个明显的开始/结束输出外，我们利用`fgets()`函数从标准输入中读取。`stream_set_blocking()`方法故意被暂时注释掉。请注意，这两个脚本完全不相关。`index.php`从未引用`beacon.php`文件。这是因为我们将使用控制台及其管道（`|`）来将`beacon.php`脚本的stdout桥接到`index.php`消耗的stdin。
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The resulting output is shown here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出如下：
- en: '![](assets/24b412d5-df8a-41c2-ae3f-f34d9cb535ad.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/24b412d5-df8a-41c2-ae3f-f34d9cb535ad.png)'
- en: There is nothing wrong with this output; this is what we expected. We first
    see the start string showing up, then several occurrences of signal..., and finally,
    the end string. However, there lies the catch, all of the signal... bits that
    are pulled by the `fgets()` function from stdout are an example of blocking IO.
    While we might not perceive it as such in this small example, we could easily
    imagine a beacon script sending output from a very large file, or a slow database
    connection. Our `index.php` script would simply hang its execution blocked during
    that time, or, better to say, it would wait for the `while (($line = fgets(STDIN)...`
    line to resolve.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出没有问题；这是我们预期的。我们首先看到开始字符串出现，然后出现几次signal...，最后是结束字符串。然而，问题在于，`fgets()`函数从stdout中拉取的所有signal...位都是阻塞I/O的一个例子。虽然在这个小例子中我们可能不会察觉到，但我们很容易想象一个beacon脚本从一个非常大的文件或一个慢的数据库连接中发送输出。我们的`index.php`脚本将在那段时间内被简单地挂起执行，或者更好地说，它将等待`while
    (($line = fgets(STDIN)...`行解决。
- en: 'How can we resolve the problem? First, we need to understand that this is not
    really a technical problem as such. There is nothing wrong with waiting to receive
    data. No matter how much we abstract things, there will always be that someone or
    something who needs to wait for data somewhere. The trick is positioning the somewhere bit
    at the right place, so it does not stand in the way of user experience. The JavaScript
    promises and callbacks are one example of where we may want to place that somewhere.
    Let''s take a look at the simple AJAX call made by the JavaScript jQuery library:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？首先，我们需要明白这实际上并不是一个技术问题。等待接收数据并没有什么问题。无论我们如何抽象事物，总会有某个人或某些东西需要在某个地方等待数据。诀窍在于将这个地方放在正确的位置，这样它就不会妨碍用户体验。JavaScript的promise和回调就是我们可能想要放置这个地方的一个例子。让我们来看一下JavaScript
    jQuery库所做的简单AJAX调用：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following screenshot shows the resulting output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了结果输出：
- en: '![](assets/dec130cd-c357-416b-a618-5395b5c1c72d.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dec130cd-c357-416b-a618-5395b5c1c72d.png)'
- en: Notice how `start-time` and `end-time` have been outputted before the `result-time`.
    The JavaScript did not block the execution at the `$.ajax({...` line, like PHP
    did on its `while (($line = fgets(STDIN)...` line in the preceding example. This
    is because JavaScript runtime is fundamentally different than PHP. The asynchronous
    nature of JavaScript relies on the chunks of code to split off and execute separately,
    then update what's needed via the callback mechanism, a functionality made possible
    by JavaScript event loop based concurrency model and message queue mechanism.
    The callback in this case was the anonymous function assigned to the success property
    of the `ajax()` method call. Once the AJAX call executed successfully, it called
    the assigned `success` function, which in turn resulted last on the output as
    the AJAX call takes time to execute.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`start-time`和`end-time`在`result-time`之前被输出。JavaScript没有像PHP在前面的例子中的`while
    (($line = fgets(STDIN)...`行那样在`$.ajax({...`行阻塞执行。这是因为JavaScript运行时与PHP根本不同。JavaScript的异步性质依赖于代码块的分离和单独执行，然后通过回调机制更新所需的内容，这是由JavaScript事件循环并发模型和消息队列机制实现的功能。这种情况下的回调是分配给`ajax()`方法调用的`success`属性的匿名函数。一旦AJAX调用成功执行，它调用了分配的`success`函数，这反过来导致了AJAX调用需要时间来执行的输出。
- en: 'Now, let''s go back to our little PHP example and modify the `index.php` file by
    removing the comment we placed in front of the `stream_set_blocking(STDIN, 0);`
    expression. Running the command again, with the pipe (`|`) this time, now results
    in the output much like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的小PHP例子，通过删除我们放在`stream_set_blocking(STDIN, 0);`表达式前面的注释来修改`index.php`文件。再次运行命令，这次使用管道（`|`），结果输出如下：
- en: '![](assets/4c4e8bb4-7afb-408d-b467-b8ea55b2acc4.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4c4e8bb4-7afb-408d-b467-b8ea55b2acc4.png)'
- en: 'This time, the `while (($line = fgets(STDIN)...` line did not block the execution
    by waiting for `beacon.php` to finish. The trick lies in the `stream_set_blocking()`
    function, as it enables us to control the stream blocking mode, which by default
    is set to block I/O. Let''s go ahead and make a more PHP-like example, this time
    without using the console pipe. We will leave the `beacon.php` file as it is,
    but modify the `index.php` file as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，`while (($line = fgets(STDIN)...`行没有通过等待`beacon.php`完成来阻塞执行。诀窍在于`stream_set_blocking()`函数，因为它使我们能够控制流的阻塞模式，默认情况下设置为阻塞I/O。让我们继续制作一个更像PHP的例子，这次不使用控制台管道。我们将保留`beacon.php`文件不变，但修改`index.php`文件如下：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We started off with a `proc_open()` function, which allows us to execute a
    command and open file pointers for standard input, output, and error. The `''php
    beacon.php 2''` argument does pretty much what our console command did, in regards
    to the part of command left of the pipe character. The way we catch an output
    of beacon script is using the `fgets()` function. However, we are not doing it
    directly, we are doing it through the while loop here, whereas the condition is
    the process `running` state. In other words, as long as the process is running,
    check whether there is any new output from the newly created process or not. If
    there is an output, show it; if not, show the --- beacon lost --- message. The
    following screenshot shows the resulting output with default (blocking) I/O:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`proc_open()`函数开始，它允许我们执行一个命令并为标准输入、输出和错误打开文件指针。`'php beacon.php 2'`参数基本上做了我们控制台命令的事情，关于管道字符左边的部分。我们捕获信标脚本的输出方式是使用`fgets()`函数。然而，我们不是直接这样做的，我们是通过这里的while循环来做的，条件是进程`running`状态。换句话说，只要进程在运行，就检查是否有新的输出来自新创建的进程。如果有输出，显示它；如果没有，显示`---信标丢失---`消息。以下截图显示了默认（阻塞）I/O的结果：
- en: '![](assets/4a9d00b2-7ccb-4731-b79f-7ed3a6eb0252.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4a9d00b2-7ccb-4731-b79f-7ed3a6eb0252.png)'
- en: 'If we now remove the comment in front of `stream_set_blocking($pipes[1], 0);`,
    the resulting output changes into this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在取消注释`stream_set_blocking($pipes[1], 0);`前面的注释，生成的输出将变成这样：
- en: '![](assets/502a795f-e386-41f8-b9d8-4862cd4f2a27.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/502a795f-e386-41f8-b9d8-4862cd4f2a27.png)'
- en: The output here shows the non-blocking relationship between the beacon and our
    running script. Unblocking the stream, we were able to utilize the `fgets()` function,
    which would normally block the script to periodically check on the standard input for
    as long as the process is running. In a nutshell, we are now able to read the
    output from a sub-process, while being able to initialize a few more of the sub-processes
    along the way. Although the example itself is a long-long way from the convenience
    of the jQuery promise/callback example, it is a first step towards the complexities
    behind blocking and non-blocking I/O, as it affects the way we write our code.
    This is where we will come to appreciate the role of the RxPHP observables and
    React event loops.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的输出显示了信标和我们运行的脚本之间的非阻塞关系。解除流的阻塞，我们能够利用`fgets()`函数，这通常会阻塞脚本以定期检查标准输入，只要进程正在运行。简而言之，我们现在能够从子进程读取输出，同时能够初始化更多的子进程。尽管这个例子本身离jQuery
    promise/callback例子的便利还有很长的路要走，但这是我们写代码时阻塞和非阻塞I/O背后复杂性的第一步。这就是我们将会欣赏RxPHP可观察对象和React事件循环的作用的地方。
- en: Using React
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React
- en: React is a library that makes it possible to event-driven programming in PHP,
    much like JavaScript does. Based on the reactor pattern, it essentially acts as
    an event loop, allowing various other third-party libraries using its components
    to write asynchronous code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: React是一个库，它使得在PHP中进行事件驱动编程成为可能，就像JavaScript一样。基于反应器模式，它本质上充当一个事件循环，允许使用其组件的各种第三方库编写异步代码。
- en: The page at [https://en.wikipedia.org/wiki/Reactor_pattern](https://en.wikipedia.org/wiki/Reactor_pattern)
    states, *The reactor design pattern is an event handling pattern for handling
    service requests delivered concurrently to a service handler by one or more inputs*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Reactor_pattern](https://en.wikipedia.org/wiki/Reactor_pattern)页面上说，*反应器设计模式是一种处理服务请求的事件处理模式，由一个或多个输入并发地传递给服务处理程序*。'
- en: The library is available at [https://github.com/reactphp/react](https://github.com/reactphp/react)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 该库可在[https://github.com/reactphp/react](https://github.com/reactphp/react)找到
- en: '![](assets/f69decec-31c7-445e-920e-3c45c3e22e7f.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f69decec-31c7-445e-920e-3c45c3e22e7f.png)'
- en: Installing React
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装React
- en: 'The React library is available as a Composer `react/react` package. Assuming
    we are still in our project directory where we installed RxPHP, we can simply
    execute the following command in order to add React to our project:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: React库可作为Composer `react/react`包获得。假设我们仍然在我们安装RxPHP的项目目录中，我们可以简单地执行以下命令来将React添加到我们的项目中：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This should give us an output similar to the following one:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们一个类似以下的输出：
- en: '![](assets/58f88a2d-ef96-4ca2-b052-662c17135a41.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/58f88a2d-ef96-4ca2-b052-662c17135a41.png)'
- en: We can see quite a few interesting `react/*` packages being pulled in, `react/event-loop` being
    one of them. The messages suggesting we should install one of the more performant
    loop implementations are definitely worthy of interest, though out of the scope
    of this book.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一些有趣的`react/*`包被引入，`react/event-loop`是其中之一。建议我们安装更高性能的循环实现的消息绝对值得关注，尽管超出了本书的范围。
- en: React event loop
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React事件循环
- en: Without any of the suggested event loop extensions, React event loop defaults
    to the `React\EventLoop\StreamSelectLoop` class, which is a `stream_select()`
    function-based event loop.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 没有建议的任何事件循环扩展，React事件循环默认为`React\EventLoop\StreamSelectLoop`类，这是基于`stream_select()`函数的事件循环。
- en: The page at [http://php.net/manual/en/function.stream-select.php](http://php.net/manual/en/function.stream-select.php)
    states, *The stream_select() function accepts arrays of streams and waits for
    them to change status*
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://php.net/manual/en/function.stream-select.php](http://php.net/manual/en/function.stream-select.php)页面上说，*stream_select()函数接受流数组并等待它们改变状态*'
- en: As we already saw in our previous examples, making an event loop in React is
    simple
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的例子中看到的，使用React创建事件循环是简单的
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We are using the `Factory::create()` static function, which is implemented
    as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`Factory::create()`静态函数，实现如下：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we can see that unless we have `ext-libevent`, `ext-event`, or `ext-libev` installed,
    then the `StreamSelectLoop` implementation is used.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，除非我们安装了`ext-libevent`、`ext-event`或`ext-libev`，否则将使用`StreamSelectLoop`实现。
- en: Each iteration of the loop is a tick. The event loop tracks timers and streams.
    Without either of these two, there are no ticks, and the loop simply
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的每次迭代都是一个滴答。事件循环跟踪计时器和流。如果没有这两者中的任何一个，就没有滴答声，循环就简单地
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code gives us the following output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码给我们以下输出：
- en: '![](assets/0c81eb9e-fdaf-4494-98d2-08934a6ff4a9.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0c81eb9e-fdaf-4494-98d2-08934a6ff4a9.png)'
- en: As soon as we add some timers, the situation ch
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了一些计时器，情况就会发生变化
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code gives us the following output:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码给我们以下输出：
- en: '![](assets/48487a6d-646b-4b0a-ac55-4e0520019a7c.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/48487a6d-646b-4b0a-ac55-4e0520019a7c.png)'
- en: Notice the order of the timer output, and the time next to each. Our loop still
    managed to end, as our timers expired. To keep the loop running constantly, we
    can add a *periodic timer*
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意计时器输出的顺序和每个计时器旁边的时间。我们的循环仍然成功结束了，因为我们的计时器到期了。为了使循环持续运行，我们可以添加一个*周期计时器*。
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding code gives us the following output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码给我们以下输出：
- en: '![](assets/bee357c9-0bb1-42c3-b5bd-146eb5cb191b.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bee357c9-0bb1-42c3-b5bd-146eb5cb191b.png)'
- en: This loop will now continue to produce the same timer... output until we hit *Ctrl*
    + *C* on the console. We might be wondering, how does this differ from a PHP `while`
    loop? Generally, the `while` loop is of polling type, as it continuously checks
    things, leaving little to no room for the processor to switch tasks. The event
    loop uses more efficient interrupt-driven I/O instead of polling. However, the
    default `StreamSelectLoop` uses the `while` loop for its event-loop implementation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环现在将继续产生相同的计时器...输出，直到我们在控制台上按下*Ctrl* + *C*。我们可能会想，这与PHP的`while`循环有什么不同？一般来说，`while`循环是轮询类型的，因为它不断地检查事物，几乎没有机会让处理器切换任务。事件循环使用更有效的中断驱动I/O，而不是轮询。然而，默认的`StreamSelectLoop`使用`while`循环来实现其事件循环。
- en: The addition of timers and streams is what makes it useful, as it abstracts
    the hard bits from us.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器和流的添加使其变得有用，因为它将难点抽象化了。
- en: Observables and event loop
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察对象和事件循环
- en: 'Let''s go ahead and see how we can make our observables work with an event
    loop:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看如何使我们的可观察对象与事件循环一起工作：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There is quite a lot going on here. We started off by creating a standard input
    and then flagging it as non-blocking. We then created the observer of the `Subject`
    type. This is because, as we will see later, we want our observer to behave like
    observer and observable. We then instantiated the loop, and passed onto `EventLoopScheduler`.
    In order for observables to work with the loop, we need to wrap them with a scheduler.
    We then used the instance of `IntervalObservable`, making its `map()` operator
    read the standard input, whereas the `filter()` operator was set to filter out
    any empty inputs (pressing Enter key on console with no text). We stored this
    observable into a `$disposable` variable. Finally, given that our `$observer`
    was an instance of `Subject`, we were able to attach the `filter()` operator to
    it as well as `subscribeCallback()`. We instructed the `filter()` operator here
    to only filter out the input with the quit string. Once `quit` was typed onto
    the console, followed by the *Enter* key,  `subscribeCallback()` was executed.
    Within `subscribeCallback()`, we have a `$disposable->dispose()` expression. Calling
    the disposable's dispose method automatically unsubscribed  `$observer` from  `$observable`.
    Given that there were no other timers or streams within the loop, this automatically
    terminated the loop.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情要做。我们首先创建了一个标准输入，然后将其标记为非阻塞。然后我们创建了`Subject`类型的观察者。这是因为，正如我们将在后面看到的，我们希望我们的观察者表现得像观察者和可观察者。然后我们实例化了循环，并传递给`EventLoopScheduler`。为了使可观察对象与循环一起工作，我们需要用调度程序包装它们。然后我们使用`IntervalObservable`的实例，使其`map()`操作符读取标准输入，而`filter()`操作符被设置为过滤掉任何空输入（在控制台上按Enter键而没有文本）。我们将这个可观察对象存储到`$disposable`变量中。最后，由于我们的`$observer`是`Subject`的一个实例，我们能够将`filter()`操作符附加到它以及`subscribeCallback()`。我们在这里指示`filter()`操作符只过滤出带有退出字符串的输入。一旦在控制台上输入`quit`，然后按*Enter*键，`subscribeCallback()`就会被执行。在`subscribeCallback()`中，我们有一个`$disposable->dispose()`表达式。调用可处置的dispose方法会自动取消`$observer`对`$observable`的订阅。鉴于循环中没有其他计时器或流，这会自动终止循环。
- en: 'The following screenshot shows the console output of the preceding code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面代码的控制台输出：
- en: '![](assets/39aa8f7d-4f9a-4c4c-920f-9f8a202dc1c9.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/39aa8f7d-4f9a-4c4c-920f-9f8a202dc1c9.png)'
- en: When the code was run, we first saw the `start` string, then we typed in `John` and
    press , then we say $observer.onNext..., which repeated all the way until we typed `quit`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码运行时，我们首先看到`start`字符串，然后我们输入`John`并按下，然后我们说$observer.onNext...，一直重复，直到我们输入`quit`。
- en: The React event loop opens an interesting possibility for us, much like we are
    used to seeing in JavaScript and browser. While there is much more to be said
    about React, this should be enough to get us started with RxPHP and React combination.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: React事件循环为我们打开了一个有趣的可能性，就像我们在JavaScript和浏览器中习惯看到的那样。虽然关于React还有很多要说的，但这应该足以让我们开始使用RxPHP和React的组合。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we touched upon RxPHP and React, the two libraries that promise
    to bring reactive programming to PHP. While RxPHP brings the powerful  observables
    packaged in composable-looking syntax, React enriches our experience with event-loop
    implementation. To carefully, we should emphasize that this is still a relatively
    experimental area for PHP, and far from ready for mainstream production use. It
    does, however, demonstrate that PHP is not limited with its runtime capabilities
    and shows promise in the reactive area.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涉及了RxPHP和React，这两个库承诺将响应式编程带到PHP中。虽然RxPHP提供了强大的可组合语法包装的可观察对象，React则通过事件循环实现丰富了我们的体验。需要谨慎的是，这对于PHP来说仍然是一个相对实验性的领域，远未准备好用于主流生产。然而，它确实表明了PHP在运行时能力上并不受限，并在响应式领域显示出了潜力。
- en: Moving forward, we will shift our focus on common design patterns found in modern
    PHP applications.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把重点转移到现代PHP应用程序中常见的设计模式。
