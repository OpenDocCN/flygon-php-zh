- en: Chapter 2. GoF Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。GoF设计模式
- en: There are a handful of things that make a great software developer. Knowledge
    and usage of design patterns is one of them. Design patterns empower developers
    to communicate using well-known names for various software interactions. Whether
    someone is a PHP, Python, C#, Ruby, or any other language developer, design patterns
    provide language agnostic solutions for frequently occurring software problems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些因素使得一个优秀的软件开发者。设计模式的知识和使用就是其中之一。设计模式使开发者能够使用众所周知的名称来进行各种软件交互。无论是PHP、Python、C#、Ruby还是其他任何语言的开发者，设计模式都为经常发生的软件问题提供了与语言无关的解决方案。
- en: The concept of design patterns emerged in 1994 as part of the *Elements of Reusable
    Object-Oriented Software* book. Detailing 23 different design patterns, the book
    was written by four authors Erich Gamma, Richard Helm, Ralph Johnson, and John
    Vlissides. The authors are often referred to as the **Gang of Four** (**GoF**),
    and the presented design patterns are sometimes referred to as GoF design patterns.
    In Today, more than two decades later, designing software that is extensible,
    reusable, maintainable, and adaptable is near to impossible without embracing
    design patterns as part of implementation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式的概念于1994年出现，作为《可重用面向对象软件的元素》一书的一部分。该书详细介绍了23种不同的设计模式，由Erich Gamma、Richard
    Helm、Ralph Johnson和John Vlissides四位作者撰写。这些作者通常被称为**四人帮**（**GoF**），所提出的设计模式有时被称为GoF设计模式。如今，两十多年后，设计可扩展、可重用、可维护和可适应的软件几乎不可能不将设计模式作为实现的一部分。
- en: 'There are three types of design patterns which we will cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍三种设计模式：
- en: Creational
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创造性
- en: Structural
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构性
- en: Behavioral
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为
- en: Throughout this chapter we will not go deep into the theory of each of them,
    as that alone is an entire book's worth of material. Moving forward, we will focus
    more on simple PHP implementation examples for each of the patterns, just so we
    get a more visual sense of things.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会深入研究每一个模式的理论，因为单独讨论这些内容就是一本完整的书。接下来，我们将更多地关注每种模式的简单PHP实现示例，以便更直观地了解事物。
- en: Creational patterns
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建型模式
- en: 'Creational patterns, as the name suggests, create *objects* for us, so we do
    not have to instantiate them directly. Implementing creation patterns gives our
    application a level of flexibility, where the application itself can decide what
    objects to instantiate at a given time. The following is a list of patterns we
    categorize as creational patterns:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型模式，顾名思义，为我们创建*对象*，因此我们不必直接实例化它们。实现创建模式为我们的应用程序提供了一定程度的灵活性，应用程序本身可以决定在特定时间实例化哪些对象。以下是我们归类为创建型模式的模式列表：
- en: Abstract factory pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: Builder pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建造者模式
- en: Factory method pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法模式
- en: Prototype pattern
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型模式
- en: Singleton pattern
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: See [https://en.wikipedia.org/wiki/Creational_pattern](https://en.wikipedia.org/wiki/Creational_pattern)
    for more information about creational design patterns.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有关创建型设计模式的更多信息，请参见[https://en.wikipedia.org/wiki/Creational_pattern](https://en.wikipedia.org/wiki/Creational_pattern)。
- en: Abstract factory pattern
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: Building portable applications requires a great level of dependencies encapsulation.
    The abstract factory facilitates this by *abstracting the creation of families
    of related or dependent objects*. Clients never create these platform objects
    directly, the factory does it for them, making it possible to interchange concrete
    implementations without changing the code that uses them, even at runtime.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 构建可移植应用程序需要很高的依赖封装级别。抽象工厂通过*抽象化相关或依赖对象的创建*来实现这一点。客户端永远不会直接创建这些平台对象，工厂会为他们创建，使得可以在不改变使用它们的代码的情况下交换具体实现，甚至在运行时。
- en: 'The following is an example of possible abstract factory pattern implementation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可能的抽象工厂模式实现示例：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We started off by creating an interface `Button`, which is later implemented
    by our `SubmitButton` and `ResetButton` concrete classes. `GUIFactory` and `ResetFactory`
    implement the `GUIFactory` interface, which specifies the `createButton` method.
    The client then simply instantiates factories and calls for `createButton`, which
    returns a proper button instance that we call the `render` method.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个接口`Button`，然后由我们的`SubmitButton`和`ResetButton`具体类来实现。`GUIFactory`和`ResetFactory`实现了`GUIFactory`接口，该接口指定了`createButton`方法。然后客户端简单地实例化工厂并调用`createButton`，返回一个适当的按钮实例，我们称之为`render`方法。
- en: Builder pattern
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建造者模式
- en: The builder pattern separates the construction of a complex object from its
    representation, making it possible for the same construction process to create
    different representations. While some creational patterns construct a product
    in one call, builder pattern does it step by step under the control of the director.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式将复杂对象的构建与其表示分离，使得相同的构建过程可以创建不同的表示。虽然一些创造模式在一次调用中构造产品，但建造者模式在主管的控制下逐步进行。
- en: 'The following is an example of builder pattern implementation:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是建造者模式实现的示例：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We started off by creating a concrete `Car` class with several methods defining
    some base characteristics of a car. We then created a `CarBuilderInterface` that
    will control some of those characteristics and get the final result (`car`). The
    concrete class `CarBuilder` then implemented the `CarBuilderInterface`, followed
    by the concrete `CarBuildDirector` class, which defined build and the `getCar`
    method. The client then simply instantiated a new instance of `CarBuilder`, passing
    it as a constructor parameter to a new instance of `CarBuildDirector`. Finally,
    we called the `build` and `getCar` methods of `CarBuildDirector` to get the actual
    car `Car` instance.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个具体的`Car`类，其中包含定义汽车一些基本特征的几种方法。然后我们创建了一个`CarBuilderInterface`，它将控制其中一些特征并获得最终结果（`car`）。具体类`CarBuilder`然后实现了`CarBuilderInterface`，接着是具体的`CarBuildDirector`类，它定义了构建和`getCar`方法。客户端只需实例化一个新的`CarBuilder`实例，并将其作为构造函数参数传递给一个新的`CarBuildDirector`实例。最后，我们调用`CarBuildDirector`的`build`和`getCar`方法来获得实际的汽车`Car`实例。
- en: Factory method pattern
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂方法模式
- en: The `factory` method pattern deals with the problem of creating objects without
    having to specify the exact class of the object that will be created.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`工厂`方法模式处理创建对象的问题，而无需指定将要创建的对象的确切类。'
- en: 'The following is an example of factory method pattern implementation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是工厂方法模式实现的示例：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We started off by creating a `ProductFactory` and `Product` interfaces. The
    `SimpleProductFactory` implements the `ProductFactory` and returns the new `product`
    instance via its `makeProduct` method. The `SimpleProduct` class implements `Product`,
    and returns the product type. Finally, the client creates the instance of `SimpleProductFactory`,
    calling the `makeProduct` method on it. The `makeProduct` returns the instance
    of the `Product`, whose `getType` method returns the `SimpleProduct` string.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个`ProductFactory`和`Product`接口。`SimpleProductFactory`实现了`ProductFactory`并通过其`makeProduct`方法返回新的`product`实例。`SimpleProduct`类实现了`Product`，并返回产品类型。最后，客户端创建了`SimpleProductFactory`的实例，并在其上调用`makeProduct`方法。`makeProduct`返回`Product`的实例，其`getType`方法返回`SimpleProduct`字符串。
- en: Prototype pattern
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型模式
- en: The prototype pattern replicates other objects by use of cloning. What this
    means is that we are not using the `new` keyword to instantiate new objects. PHP
    provides a `clone` keyword which makes a shallow copy of an object, thus providing
    pretty much straight forward prototype pattern implementation. Shallow copy does
    not copy references, only values to the new object. We can further utilize the
    magic `__clone` method on our class in order to implement more robust clone behavior.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式通过克隆来复制其他对象。这意味着我们不是使用`new`关键字来实例化新对象。PHP提供了一个`clone`关键字，它可以对对象进行浅复制，从而提供了非常直接的原型模式实现。浅复制不会复制引用，只会将值复制到新对象。我们还可以利用我们的类上的魔术`__clone`方法来实现更健壮的克隆行为。
- en: 'The following is an example of prototype pattern implementation:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是原型模式实现的示例：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We started off by creating a simple `User` class. The `Employee` then extends
    the `User`, while setting `name` and `email` in its constructor. The client then
    instantiates the `Employee` via the `new` keyword, and clones it into the `director`
    variable. The `$director` variable is now a new instance, one made not by the
    `new` keyword, but with cloning, using the `clone` keyword. Changing `name` and
    `email` on `$director`, does not affect `$employee`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个简单的`User`类。然后`Employee`类扩展了`User`类，并在其构造函数中设置了`name`和`email`。客户端通过`new`关键字实例化了`Employee`，并将其克隆到`director`变量中。`$director`变量现在是一个新实例，不是通过`new`关键字创建的，而是通过克隆使用`clone`关键字创建的。在`$director`上更改`name`和`email`不会影响`$employee`。
- en: Singleton pattern
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例模式
- en: The purpose of singleton pattern is to restrict instantiation of class to a
    *single* object. It is implemented by creating a method within the class that
    creates a new instance of that class if one does not exist. If an object instance
    already exists, the method simply returns a reference to an existing object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式的目的是限制类的实例化为*单个*对象。它通过在类中创建一个方法来实现，如果不存在对象实例，则创建该类的新实例。如果对象实例已经存在，则该方法简单地返回对现有对象的引用。
- en: 'The following is an example of singleton pattern implementation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是单例模式实现的示例：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We started off by creating a `Logger` class with a static `$instance` member,
    and the `getInstance` method that always returns a single instance of the class.
    Then we added a few sample methods to demonstrate the client executing various
    methods on a single instance.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个带有静态`$instance`成员和`getInstance`方法的`Logger`类，该方法始终返回类的单个实例。然后我们添加了一些示例方法，以演示客户端在单个实例上执行各种方法。
- en: Structural patterns
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构模式
- en: 'Structural patterns deal with class and object composition. Using interfaces
    or abstract classes and methods, they define ways to compose objects, which in
    turn obtain new functionality. The following is a list of patterns we categorize
    as structural patterns:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 结构模式处理类和对象的组合。使用接口或抽象类和方法，它们定义了组合对象的方式，从而获得新功能。以下是我们将作为结构模式进行分类的模式列表：
- en: Adapter
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式
- en: Bridge
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接模式
- en: Composite
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合模式
- en: Decorator
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: Facade
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观模式
- en: Flyweight
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 享元模式
- en: Proxy
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: See [https://en.wikipedia.org/wiki/Structural_pattern](https://en.wikipedia.org/wiki/Structural_pattern)
    for more information about structural design patterns.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有关结构设计模式的更多信息，请参阅[https://en.wikipedia.org/wiki/Structural_pattern](https://en.wikipedia.org/wiki/Structural_pattern)。
- en: Adapter pattern
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器模式
- en: The adapter pattern allows the interface of an existing class to be used from
    another interface, basically, helping two incompatible interfaces to work together
    by converting the interface of one class into an interface expected by another
    class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式允许使用现有类的接口来自另一个接口，基本上通过将一个类的接口转换为另一个类期望的接口，帮助两个不兼容的接口一起工作。
- en: 'The following is an example of adapter pattern implementation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是适配器模式实现的示例：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We started off by creating a concrete `Stripe` class. We then defined the `PaymentService`
    interface with some basic payment handling methods. The `StripePaymentServiceAdapter`
    implements the `PaymentService` interface, providing concrete implementation of
    payment handling methods. Finally, the client instantiates the `StripePaymentServiceAdapter`
    and executes the payment handling methods.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个具体的`Stripe`类。然后定义了`PaymentService`接口，其中包含一些基本的支付处理方法。`StripePaymentServiceAdapter`实现了`PaymentService`接口，提供了支付处理方法的具体实现。最后，客户端实例化了`StripePaymentServiceAdapter`并执行了支付处理方法。
- en: Bridge pattern
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桥接模式
- en: The bridge pattern is used when we want to decouple a class or abstraction from
    its implementation, allowing them both to change independently. This is useful
    when the class and its implementation vary often.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式用于当我们想要将类或抽象与其实现解耦时，允许它们独立变化。当类和其实现经常变化时，这是很有用的。
- en: 'The following is an example of bridge pattern implementation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是桥接模式实现的示例：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We started off by creating a `MailerInterface`. The concrete `Mailer` class
    then implements the `MailerInterface`, providing a base class for `PHPMailer`
    and `SwiftMailer`. We then define the `MessagingInterface`, which gets implemented
    by the `TextMessage` and `HtmlMessage` classes. Finally, the client instantiates
    `PHPMailer` and `SwiftMailer`, passing on instances of `TextMessage` and `HtmlMessage`
    prior to calling the `send` method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个`MailerInterface`。具体的`Mailer`类然后实现了`MailerInterface`，为`PHPMailer`和`SwiftMailer`提供了一个基类。然后我们定义了`MessagingInterface`，它由`TextMessage`和`HtmlMessage`类实现。最后，客户端实例化`PHPMailer`和`SwiftMailer`，在调用`send`方法之前传递`TextMessage`和`HtmlMessage`的实例。
- en: Composite pattern
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合模式
- en: The composite pattern is about treating the hierarchy of objects as a single
    object, through a common interface. Where the objects are composed into three
    structures and the client is oblivious to changes in the underlying structure
    because it only consumes the common interface.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式是关于将对象的层次结构视为单个对象，通过一个公共接口。对象被组合成三个结构，客户端对底层结构的更改毫不知情，因为它只消耗公共接口。
- en: 'The following is an example of composite pattern implementation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是组合模式实现的示例：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We started off by creating a `Graphic` interface. We then created the `CompositeGraphic`,
    `Circle`, `Square`, and `Triangle`, all of which implement the `Graphic` interface.
    Aside from just implementing the `draw` method from the `Graphic` interface, the
    `CompositeGraphic` adds two more methods, used to track internal collection of
    graphics added to it. The client then instantiates all of these `Graphic` classes,
    adding them all to the `CompositeGraphic`, which then calls the `draw` method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个`Graphic`接口。然后创建了`CompositeGraphic`、`Circle`、`Square`和`Triangle`，它们都实现了`Graphic`接口。除了实现`Graphic`接口的`draw`方法之外，`CompositeGraphic`还添加了另外两个方法，用于跟踪添加到其中的图形的内部集合。然后客户端实例化所有这些`Graphic`类，将它们全部添加到`CompositeGraphic`中，然后调用`draw`方法。
- en: Decorator pattern
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: The decorator pattern allows behavior to be added to an individual object instance,
    without affecting the behavior of other instances of the same class. We can define
    multiple decorators, where each adds new functionality.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式允许向单个对象实例添加行为，而不影响同一类的其他实例的行为。我们可以定义多个装饰器，每个装饰器都添加新功能。
- en: 'The following is an example of decorator pattern implementation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是装饰器模式实现的示例：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We started off by creating a `LoggerInterface`, with a simple `log` method.
    We then defined `Logger` and `LoggerDecorator`, both of which implement the `LoggerInterface`.
    Followed by `ErrorLoggerDecorator`, `WarningLoggerDecorator`, and `NoticeLoggerDecorator`
    which implement the `LoggerDecorator`. Finally, the client part instantiates the
    `logger` three times, passing it different decorators.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个`LoggerInterface`，其中包含一个简单的`log`方法。然后定义了`Logger`和`LoggerDecorator`，它们都实现了`LoggerInterface`。然后是`ErrorLoggerDecorator`、`WarningLoggerDecorator`和`NoticeLoggerDecorator`，它们实现了`LoggerDecorator`。最后，客户端部分实例化了`logger`三次，并传递了不同的装饰器。
- en: Facade pattern
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外观模式
- en: The facade pattern is used when we want to simplify the complexities of large
    systems through a simpler interface. It does so by providing convenient methods
    for most common tasks, through a single wrapper class used by a client.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式用于通过一个更简单的接口简化大型系统的复杂性。它通过为客户端提供方便的方法来执行大多数常见任务，通过一个单一的包装类来实现。
- en: 'The following is an example of facade pattern implementation:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是外观模式实现的示例：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We started off by creating a `Product` class, with a single `getQty` method.
    We then created a `QuickOrderFacade` class that accepts `product` instance and
    quantity via a `constructor` and further provides the `generateOrder` method that
    aggregates all of the order generating actions. Finally, the client instantiates
    the `product`, which it passes onto the instance of `QuickOrderFacade`, calling
    the `generateOrder` on it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个`Product`类，其中包含一个`getQty`方法。然后创建了一个`QuickOrderFacade`类，它通过`constructor`接受`product`实例和数量，并进一步提供了`generateOrder`方法，该方法汇总了所有生成订单的操作。最后，客户端实例化了`product`，将其传递给`QuickOrderFacade`的实例，并调用了其上的`generateOrder`。
- en: Flyweight pattern
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 享元模式
- en: The flyweight pattern is about performance and resource reduction, sharing as
    much data as possible between similar objects. What this means is that instances
    of a class which are identical are shared in an implementation. This works best
    when a large number of same class instances are expected to be created.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 享元模式关乎性能和资源的减少，在相似对象之间尽可能共享数据。这意味着相同的类实例在实现中是共享的。当预计会创建大量相同类的实例时，这种方法效果最佳。
- en: 'The following is an example of flyweight pattern implementation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是享元模式实现的示例：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We started off by creating a `Shape` interface, with a single `draw` method.
    We then defined the `Circle` class implementing the `Shape` interface, followed
    by the `ShapeFactory` class. Within the `ShapeFactory`, the `getCircle` method
    returns an instance of a new `Circle`, based on the `color` option. Finally, the
    client instantiates several `ShapeFactory` objects, passing in different colors
    to the `getCircle` method call.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个`Shape`接口，其中包含一个`draw`方法。然后我们定义了实现`Shape`接口的`Circle`类，接着是`ShapeFactory`类。在`ShapeFactory`中，`getCircle`方法根据`color`选项返回一个新的`Circle`实例。最后，客户端实例化了几个`ShapeFactory`对象，并传入不同的颜色到`getCircle`方法中。
- en: Proxy pattern
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理模式
- en: The proxy design pattern functions as an interface to an original object behind
    the scenes. It can act as a simple forwarding wrapper or even provide additional
    functionality around the object it wraps. Examples of extra added functionality
    might be lazy loading or caching that might compensate for resource intense operations
    of an original object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代理设计模式作为原始对象的接口在后台运行。它可以充当简单的转发包装器，甚至在包装的对象周围提供额外的功能。额外添加的功能示例可能是懒加载或缓存，可以弥补原始对象的资源密集操作。
- en: 'The following is an example of proxy pattern implementation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代理模式实现的示例：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We started off by creating an `ImageInterface`, with a single `draw` method.
    We then defined the `Image` and `ProxyImage` classes, both of which extend the
    `ImageInterface`. Within the `__construct` of the `Image` class, we simulated
    the **resource intense** operation with the `sleep` method call. Finally, the
    client instantiates both `Image` and `ProxyImage`, showing the execution time
    difference between the two.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个`ImageInterface`，其中包含一个`draw`方法。然后我们定义了`Image`和`ProxyImage`类，它们都扩展了`ImageInterface`。在`Image`类的`__construct`中，我们使用`sleep`方法模拟了**资源密集**的操作。最后，客户端实例化了`Image`和`ProxyImage`，展示了两者之间的执行时间差异。
- en: Behavioral patterns
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为模式
- en: 'Behavioral patterns tackle the challenge of communication between various objects.
    They describe how different objects and classes send messages to each other to
    make things happen. The following is a list of patterns we categorize as behavioral
    patterns:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 行为模式解决了各种对象之间通信的挑战。它们描述了不同对象和类如何相互发送消息以实现事情发生。以下是我们归类为行为模式的模式列表：
- en: Chain of responsibility
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链
- en: Command
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Interpreter
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器
- en: Iterator
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: Mediator
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中介者
- en: Memento
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录
- en: Observer
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: State
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: Strategy
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略
- en: Template method
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法
- en: Visitor
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者
- en: Chain of responsibility pattern
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 责任链模式
- en: The chain of responsibility pattern decouples the sender of a request from its
    receiver, by enabling more than one object to handle requests, in a chain manner.
    Various types of handling objects can be added dynamically to the chain. Using
    a recursive composition chain allows for an unlimited number of handling objects.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链模式通过以链式方式启用多个对象处理请求，将请求的发送者与接收者解耦。各种类型的处理对象可以动态添加到链中。使用递归组合链允许无限数量的处理对象。
- en: 'The following is an example of chain of responsibility pattern implementation:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是责任链模式实现的示例：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We started off by creating an abstract `SocialNotifier` class with the abstract
    method `publish`, `notifyNext`, and `push` method implementations. We then defined
    `TwitterSocialNotifier`, `FacebookSocialNotifier`, and `PinterestSocialNotifier`,
    all of which extend the abstract `SocialNotifier`. The client starts by instantiating
    the `TwitterSocialNotifier`, followed by two `notifyNext` calls, passing it instances
    of two other `notifier` types before it calls the final `push` method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个抽象的`SocialNotifier`类，其中包含抽象方法`publish`，`notifyNext`和`push`方法的实现。然后我们定义了`TwitterSocialNotifier`，`FacebookSocialNotifier`和`PinterestSocialNotifier`，它们都扩展了抽象的`SocialNotifier`。客户端首先实例化了`TwitterSocialNotifier`，然后进行了两次`notifyNext`调用，传递了两种其他`notifier`类型的实例，然后调用了最终的`push`方法。
- en: Command pattern
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令模式
- en: The command pattern decouples the object that executes certain operations from
    objects that know how to use it. It does so by encapsulating all of the relevant
    information needed for later execution of a certain action. This implies information
    about object, method name, and method parameters.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式将执行特定操作的对象与知道如何使用它的对象解耦。它通过封装后续执行某个动作所需的所有相关信息来实现。这意味着关于对象、方法名称和方法参数的信息。
- en: 'The following is an example of command pattern implementation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是命令模式的实现示例：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We started off by creating a `LightBulbCommand` interface. We then defined the
    `LightBulbControl` class that provides two simple `turnOn` / `turnOff` methods.
    Then we defined the `TurnOnLightBulb` and `TurnOffLightBulb` classes which implement
    the `LightBulbCommand` interface. Finally, the client is instantiating the `TurnOffLightBulb`
    object with an instance of `LightBulbControl`, and calling the `execute` method
    on it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个`LightBulbCommand`接口。然后我们定义了`LightBulbControl`类，提供了两个简单的`turnOn` /
    `turnOff`方法。然后我们定义了实现`LightBulbCommand`接口的`TurnOnLightBulb`和`TurnOffLightBulb`类。最后，客户端实例化了`TurnOffLightBulb`对象，并在其上调用了`execute`方法。
- en: Interpreter pattern
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释器模式
- en: The interpreter pattern specifies how to evaluate language grammar or expressions.
    We define a representation for language grammar along with an interpreter. Representation
    of language grammar uses composite class hierarchy, where rules are mapped to
    classes. The interpreter then uses the representation to interpret expressions
    in the language.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器模式指定了如何评估语言语法或表达式。我们定义了语言语法的表示以及解释器。语言语法的表示使用复合类层次结构，其中规则映射到类。然后解释器使用表示来解释语言中的表达式。
- en: 'The following is an example of interpreter pattern implementation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是解释器模式实现的示例：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We started off by creating a `MathExpression` interface, with a single `interpret`
    method. We then add `Variable`, `Literal`, `Sum`, and `Product` classes, all of
    which implement the `MathExpression` interface. The client then instantiates from
    the `Product` class, passing it instances of `Literal` and `Sum`, finishing with
    an `interpret` method call.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个`MathExpression`接口，具有一个`interpret`方法。然后添加了`Variable`、`Literal`、`Sum`和`Product`类，它们都实现了`MathExpression`接口。然后客户端从`Product`类实例化，将`Literal`和`Sum`的实例传递给它，并最后调用`interpret`方法。
- en: Iterator pattern
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器模式
- en: The iterator pattern is used to traverse a container and access its elements.
    In other words, one class becomes able to traverse the elements of another class.
    The PHP has a native support for the iterator as part of built in `\Iterator`
    and `\IteratorAggregate` interfaces.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器模式用于遍历容器并访问其元素。换句话说，一个类变得能够遍历另一个类的元素。PHP原生支持迭代器，作为内置的`\Iterator`和`\IteratorAggregate`接口的一部分。
- en: 'The following is an example of iterator pattern implementation:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是迭代器模式实现的示例：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We started off by creating a `ProductIterator` which implements the standard
    PHP `\Iterator` interface. We then added the `ProductCollection` which implements
    the standard PHP `\IteratorAggregate` interface. The client creates an instance
    of `ProductCollection`, stacking values into it via the `addProduct` method call
    and loops through the entire collection.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个实现标准PHP`\Iterator`接口的`ProductIterator`。然后添加了实现标准PHP`\IteratorAggregate`接口的`ProductCollection`。客户端创建了一个`ProductCollection`的实例，通过`addProduct`方法调用将值堆叠到其中，并循环遍历整个集合。
- en: Mediator pattern
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中介者模式
- en: The more classes we have in our software, the more complex their communication
    becomes. The mediator pattern addresses this complexity by encapsulating it into
    a mediator object. Objects no longer communicate directly, but rather through
    a mediator object, therefore lowering the overall coupling.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的软件中有更多的类，它们的通信变得更加复杂。中介者模式通过将复杂性封装到中介者对象中来解决这个问题。对象不再直接通信，而是通过中介者对象，从而降低了整体耦合度。
- en: 'The following is an example of mediator pattern implementation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是中介者模式实现的示例：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We started off by creating a `MediatorInterface` with several methods, implemented
    by the `ConcreteMediator` class. We then defined the abstract class `Colleague`
    to force the `doSomething` method implementation on the following `ColleagueA`
    and `ColleagueB` classes. The client instantiates the `ConcreteMediator` first,
    and passes its instance to the instances of `ColleagueA` and `ColleagueB`, upon
    which it calls the `doSomething` method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个具有多个方法的`MediatorInterface`，由`ConcreteMediator`类实现。然后我们定义了抽象类`Colleague`，强制在以下`ColleagueA`和`ColleagueB`类上实现`doSomething`方法。客户端首先实例化`ConcreteMediator`，然后将其实例传递给`ColleagueA`和`ColleagueB`的实例，然后调用`doSomething`方法。
- en: Memento pattern
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备忘录模式
- en: The memento pattern provides the object restore functionality. Implementation
    is done through three different objects; originator, caretaker, and a memento,
    where the originator is the one preserving the internal state required for a later
    restore.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录模式提供了对象恢复功能。实现是通过三个不同的对象完成的；原始者、caretaker和memento，其中原始者是保留内部状态以便以后恢复的对象。
- en: 'The following is an example of memento pattern implementation:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是备忘录模式实现的示例：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We started off by creating a `Memento` class, which will provide the a current
    state of the object through the `getState` method. We then defined the `Originator`
    class that pushed the state to `Memento`. Finally, the client takes the role of
    `caretaker` by instantiating `Originator`, juggling among its few states, saving
    and restoring them from `memento`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个`Memento`类，它通过`getState`方法提供对象的当前状态。然后我们定义了`Originator`类，将状态推送到`Memento`。最后，客户端通过实例化`Originator`来扮演`caretaker`的角色，在其少数状态之间进行切换，保存并从`memento`中恢复它们。
- en: Observer pattern
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The observer pattern implements a one-too-many dependency between objects. The
    object that holds the list of dependencies is called **subject**, while the dependents
    are called **observers**. When the subject object changes state, all of the dependents
    are notified and updated automatically.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式实现了对象之间的一对多依赖关系。持有依赖项列表的对象称为**subject**，而依赖项称为**observers**。当主题对象改变状态时，所有依赖项都会被通知并自动更新。
- en: 'The following is an example of observer pattern implementation:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是观察者模式实现的示例：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We started off by creating a `Customer` class which implements the standard
    PHP `\SplSubject` interface. We then defined the `CustomerObserver` class which
    implements the standard PHP `\SplObserver` interface. Finally, the client instantiates
    the `Customer` and `CustomerObserver` objects and attaches the `CustomerObserver`
    objects to `Customer`. Any changes to `name` and `email` properties are then caught
    by the `observer`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个实现标准PHP`\SplSubject`接口的`Customer`类。然后定义了一个实现标准PHP`\SplObserver`接口的`CustomerObserver`类。最后，客户端实例化了`Customer`和`CustomerObserver`对象，并将`CustomerObserver`对象附加到`Customer`上。然后`observer`捕捉到`name`和`email`属性的任何更改。
- en: State pattern
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态模式
- en: The state pattern encapsulates the varying behavior for the same object based
    on its internal state, making an object appear as if it has changed its class.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式封装了基于其内部状态的相同对象的不同行为，使对象看起来好像已经改变了它的类。
- en: 'The following is an example of state pattern implementation:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是状态模式实现的示例：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We started off by creating a `Statelike` interface, followed by `StateLowerCase`
    and `StateMultipleUpperCase` which implement that interface. The `StateMultipleUpperCase`
    has a bit of counting logic added to its `writeName`, so it kicks off the new
    state after two invocations. We then defined the `StateContext` class, which we
    will use to switch contexts. Finally, the client instantiates the `StateContext`,
    and passes an instance of `StateLowerCase` to it through the `setState` method,
    followed by several `writeName` methods.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个`Statelike`接口，然后是实现该接口的`StateLowerCase`和`StateMultipleUpperCase`。`StateMultipleUpperCase`在其`writeName`中添加了一些计数逻辑，因此在两次调用后会启动新状态。然后我们定义了`StateContext`类，我们将使用它来切换上下文。最后，客户端实例化了`StateContext`，并通过`setState`方法将`StateLowerCase`的实例传递给它，然后调用了几次`writeName`方法。
- en: Strategy pattern
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略模式
- en: The strategy pattern defines a family of algorithms, each of which is encapsulated
    and made interchangeable with other members within that family.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式定义了一组算法，每个算法都被封装并与该组内的其他成员交换使用。
- en: 'The following is an example of strategy pattern implementation:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是策略模式实现的示例：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We started off by creating a `PaymentStrategy` interface followed with concrete
    classes `StripePayment` and `PayPalPayment` which implement it. We then defined
    the `Checkout` class with a bit of decision making logic within the `capturePayment`
    method. Finally, the client instantiates the `Checkout`, passing a certain amount
    through its constructor. Based on the amount, the `Checkout` internally triggers
    one or another `payment` when `capturePayment` is called.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个`PaymentStrategy`接口，然后是实现它的具体类`StripePayment`和`PayPalPayment`。然后我们定义了`Checkout`类，在`capturePayment`方法中加入了一些决策逻辑。最后，客户端通过构造函数传递一定金额来实例化`Checkout`。根据金额，`Checkout`在调用`capturePayment`时内部触发一个或另一个`payment`。
- en: Template pattern
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板模式
- en: The template design pattern defines the program skeleton of an algorithm in
    a method. It lets us, via use of class overriding, redefine certain steps of an
    algorithm without really changing the algorithm's structure.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 模板设计模式定义了算法在方法中的程序骨架。它让我们通过类覆盖的方式重新定义算法的某些步骤，而不真正改变算法的结构。
- en: 'The following is an example of template pattern implementation:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是模板模式实现的示例：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We started off by creating an abstract `Game` class that provides all of the
    actual abstract methods encapsulating the game-play. We then defined the `Monopoly`
    and `Chess` classes, both of which extend from the `Game` class, implementing
    game specific method game-play for each. The client simply instantiates the `Monopoly`
    and `Chess` objects, calling the `playOneGame` method on each.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个提供了封装游戏玩法的所有抽象方法的抽象`Game`类。然后我们定义了`Monopoly`和`Chess`类，它们都是从`Game`类继承的，为每个游戏实现了特定的游戏玩法方法。客户端只需实例化`Monopoly`和`Chess`对象，然后在每个对象上调用`playOneGame`方法。
- en: Visitor pattern
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问者模式
- en: The visitor design pattern is a way of separating an algorithm from an object
    structure on which it operates. As a result, we are able to add new operations
    to existing object structures without actually modifying those structures.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者设计模式是一种将算法与其操作的对象结构分离的方法。因此，我们能够向现有的对象结构添加新的操作，而不实际修改这些结构。
- en: 'The following is an example of visitor pattern implementation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是访问者模式实现的示例：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We started off by creating a `RoleVisitorInterface`, followed by `RolePrintVisitor`
    which implements the `RoleVisitorInterface` itself. We then defined the abstract
    class `Role`, with an accept method taking in the `RoleVisitorInterface` parameter
    type. We further defined the concrete `User` and `Group` classes, both of which
    extend from `Role`. The client instantiates `User`, `Group`, and the `RolePrintVisitor`;
    passing in the `visitor` to the accept method call of `User` and `Group` instances.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个`RoleVisitorInterface`，然后是实现`RoleVisitorInterface`的`RolePrintVisitor`。然后我们定义了抽象类`Role`，其中包含一个接受`RoleVisitorInterface`参数类型的方法。我们进一步定义了具体的`User`和`Group`类，它们都是从`Role`继承的。客户端实例化了`User`、`Group`和`RolePrintVisitor`，并将`visitor`传递给`User`和`Group`实例的`accept`方法调用。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Design patterns are a common, high-level language for developers. They enable
    a short-hand way of communicating application design among team members. Understanding
    how to recognize and implement design patterns shifts our focus to business requirement
    solving, rather than tinkering with how to glue our solution together on a code
    level.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是开发人员的一种常见的高级语言。它们使团队成员之间能够以简化的方式交流应用程序设计。了解如何识别和实现设计模式将我们的重点转移到解决业务需求，而不是在代码层面上如何将解决方案粘合在一起。
- en: Coding, like most hand-crafted disciplines, is one of those where you get what
    you pay for. While implementing a number of design patterns takes a certain amount
    of time, lack of doing so on a larger project will likely catch up with us in
    the future, one way or another. Similar to the "use a framework or not" debate,
    implementing the right design patterns affects *extensibility*, *re-usability*,
    *adaptability*, and *maintainability* of our code. Therefore, making it more future
    proof.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 编码，就像大多数手工制作的学科一样，是你得到你所付出的。虽然实现一些设计模式需要一定的时间，但在较大的项目中不这样做可能会在未来以某种方式追上我们。与“使用框架还是不使用框架”辩论类似，实现正确的设计模式会影响我们代码的*可扩展性*、*可重用性*、*适应性*和*可维护性*。因此，使其更具未来性。
- en: Moving forward, in the next chapter, we will look into the SOLID design principles
    and the role they play in software development processes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入研究SOLID设计原则及其在软件开发过程中的作用。
