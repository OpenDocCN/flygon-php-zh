- en: Building a Multi-Page App with Vue Router
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vue Router构建多页面应用程序
- en: In the last chapter, we learned about Vue.js components and converted Vuebnb
    to a component-based architecture. Now that we've done this, we can easily add
    new pages to our app using Vue Router.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了Vue.js组件，并将Vuebnb转换为基于组件的架构。现在我们已经做到了这一点，我们可以使用Vue Router轻松地向我们的应用程序添加新页面。
- en: In this chapter, we'll create a home page for Vuebnb, including a gallery of
    clickable thumbnails that showcase the full set of mock listings.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为Vuebnb创建一个主页，其中包括一个可点击的缩略图库，展示完整的模拟列表。
- en: 'Topics covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及的主题：
- en: An explanation of what router libraries are and why they are a critical part
    of single-page applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释了路由器库是什么，以及为什么它们是单页面应用的关键部分
- en: An overview of Vue Router and its main features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue Router及其主要功能概述
- en: Installation and basic configuration of Vue Router
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue Router的安装和基本配置
- en: Using the `RouterLink` and `RouterView` special components to manage page navigation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RouterLink`和`RouterView`特殊组件来管理页面导航
- en: Setting up AJAX with Vue to retrieve data from the web service without a page
    refresh
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Vue的AJAX以从Web服务检索数据而无需刷新页面
- en: Using route navigation guards to retrieve data before a new page is loaded
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路由导航守卫在加载新页面之前检索数据
- en: Single-page applications
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单页面应用程序
- en: Most websites are broken up into pages in order to make the information they
    contain easier to consume. Traditionally this is done with a server/client model,
    where each page must be loaded from the server with a different URL. To navigate
    to a new page, the browser must send a request to the URL of that page. The server
    will send the data back and the browser can unload the existing page and load
    the new one. For the average internet connection, this process will likely take
    a few seconds, during which the user must wait for the new page to load.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网站都被分成页面，以使它们包含的信息更容易消化。传统上，这是通过服务器/客户端模型完成的，其中每个页面必须使用不同的URL从服务器加载。要导航到新页面，浏览器必须发送到该页面的URL的请求。服务器将发送数据回来，浏览器可以卸载现有页面并加载新页面。对于普通的互联网连接，这个过程可能需要几秒钟，用户必须等待新页面加载。
- en: 'By using a powerful frontend framework and an AJAX utility, a different model
    is possible: the browser can load an initial web page, but navigating to new pages
    will not require the browser to unload the page and load a new one. Instead, any
    data required for new pages can be loaded asynchronously with AJAX. From a user''s
    perspective, such a website would appear to have pages just like any other, but
    from a technical perspective, this site really only has one page. Hence the name,
    **Single-Page Application** (**SPA**).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用强大的前端框架和AJAX实用程序，可以实现不同的模型：浏览器可以加载初始网页，但导航到新页面不需要浏览器卸载页面并加载新页面。相反，新页面所需的任何数据都可以通过AJAX异步加载。从用户的角度来看，这样的网站看起来就像任何其他网站一样有页面，但从技术角度来看，这个网站实际上只有一个页面。因此得名，**单页面应用**（**SPA**）。
- en: The advantage of the Single-Page Application architecture is that it can create
    a more seamless experience for the user. Data for new pages must still be retrieved,
    and will therefore create some small disruption to the user's flow, but this disruption
    is minimized since the data retrieval can be done asynchronously and JavaScript
    can continue to run. Also, since SPA pages usually require less data due to the
    reuse of some page elements, page loading is quicker.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 单页面应用程序架构的优势在于它可以为用户创建更无缝的体验。新页面的数据仍然必须被检索，因此会对用户的流程造成一些小的中断，但由于数据检索可以异步进行并且JavaScript可以继续运行，因此这种中断被最小化。此外，由于SPA页面通常需要较少的数据，因为一些页面元素可以重复使用，所以页面加载速度更快。
- en: The disadvantage of the SPA architecture is that it makes the client app bulkier
    due to the added functionality, so gains from speeding up page changes may be
    negated by the fact that the user must download a large app on the first page
    load. Also, handling routes adds complexity to the app as multiple states must
    be managed, URLs must be handled, and a lot of default browser functionality must
    be recreated in the app.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SPA架构的缺点是，由于增加的功能，客户端应用程序变得更加臃肿，因此通过加快页面切换所获得的收益可能会被用户必须在第一次页面加载时下载一个大型应用程序所抵消。此外，处理路由会给应用程序增加复杂性，因为必须管理多个状态，处理URL，并且必须在应用程序中重新创建许多默认的浏览器功能。
- en: Routers
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器
- en: 'If you are going with an SPA architecture and your app design includes multiple
    pages, you''ll want to use a *router*. A router, in this context, is a library
    that will mimic browser navigation through JavaScript and various native APIs
    so that the user gets an experience similar to that of a traditional multi-page
    app. Routers will typically include functionality to:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择SPA架构，并且您的应用设计包括多个页面，您将需要使用*路由器*。在这种情况下，路由器是一个库，它将通过JavaScript和各种本机API模拟浏览器导航，以便用户获得类似于传统多页面应用的体验。路由器通常包括以下功能：
- en: Handle navigation actions from within the page
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从页面内部处理导航操作
- en: Match parts of the application to routes
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序的部分与路由匹配
- en: Manage the address bar
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理地址栏
- en: Manage the browser history
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理浏览器历史记录
- en: Manage scroll bar behavior
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理滚动条行为
- en: Vue Router
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue路由器
- en: Some frontend frameworks, such as Angular or Ember, include a router library
    out-of-the-box. The philosophy guiding these frameworks is that the developer
    is better served with a complete, integrated solution for their SPA.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一些前端框架，如Angular或Ember，包含一个即插即用的路由器库。这些框架的理念是，开发人员更适合使用完整的、集成的解决方案来构建他们的SPA。
- en: Others frameworks/libraries, such as React and Vue.js, do not include a router.
    Instead, you must install a separate library.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 其他框架/库，如React和Vue.js，不包括路由器。相反，您必须安装一个单独的库。
- en: In the case of Vue.js, an official router library is available called *Vue Router*.
    This library has been developed by the Vue.js core team, so it is optimized for
    usage with Vue.js and makes full use of fundamental Vue features such as components
    and reactivity.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue.js的情况下，有一个名为*Vue Router*的官方路由器库可用。这个库是由Vue.js核心团队开发的，因此它针对与Vue.js一起使用进行了优化，并充分利用了基本的Vue功能，如组件和响应性。
- en: 'With Vue Router, different *pages* of the application are represented by different
    components. When you set up Vue Router, you will pass in configuration to tell
    it which URLs map to which component. Then, when a link is clicked in the app,
    Vue Router will swap the active component so as to match the new URL, for example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vue Router，应用程序的不同*页面*由不同的组件表示。当您设置Vue Router时，您将传递配置，告诉它哪个URL映射到哪个组件。然后，在应用程序中点击链接时，Vue
    Router将交换活动组件，以匹配新的URL，例如：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since rendering a component is an almost instantaneous process in normal circumstances,
    the transition between pages with Vue Router is as well. However, there are asynchronous
    hooks that can be invoked to give you the opportunity to load new data from the
    server, if your different pages require it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在正常情况下渲染组件是一个几乎瞬间的过程，使用Vue Router在页面之间的转换也是如此。但是，有一些异步钩子可以被调用，以便让您有机会从服务器加载新数据，如果您的不同页面需要它。
- en: Special components
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊组件
- en: When you install Vue Router, two components are registered globally for use
    throughout your app: `RouterLink` and `RouterView`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当您安装Vue Router时，两个组件将全局注册，供整个应用程序使用：`RouterLink`和`RouterView`。
- en: '`RouterLink` is generally used in place of `a` tags and gives your links access
    to the special features of Vue Router.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterLink`通常用于替代`a`标签，并使您的链接可以访问Vue Router的特殊功能。'
- en: 'As explained, Vue Router will swap designated page components as a way of mimicking
    browser navigation. `RouterView` is the outlet in which this component swap takes
    place. Like a slot, you put it somewhere in your main page template. For example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所解释的，Vue Router将交换指定的页面组件，以模拟浏览器导航。`RouterView`是此组件交换发生的出口。就像插槽一样，您可以将其放在主页面模板的某个位置。例如：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Vuebnb routing
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vuebnb路由
- en: It was never a stated goal for Vuebnb to be a single-page application. Indeed,
    Vuebnb will deviate from pure SPA architecture as we'll see later in the book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Vuebnb从未被规定为单页面应用程序的目标。事实上，Vuebnb将偏离纯SPA架构，我们将在本书的后面看到。
- en: That said, incorporating Vue Router will be very beneficial to the user's experience
    of navigation in the app, so we'll add it to Vuebnb in this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，将Vue Router纳入Vuebnb将对用户在应用程序中的导航体验非常有益，因此我们将在本章中将其添加到Vuebnb中。
- en: 'Of course, if we''re going to add a router, we''ll need some extra pages! So
    far in the project, we''ve been working on the *listing* page of Vuebnb, but are
    yet to start work on the front page of the app. So in addition to installing Vue
    Router, we will start work on the Vuebnb home page, which displays thumbnails
    and links to all our mock listings:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们要添加一个路由，我们需要一些额外的页面！到目前为止，在项目中，我们一直在Vuebnb的*listing*页面上工作，但尚未开始在应用程序的首页上工作。因此，除了安装Vue
    Router之外，我们还将开始在Vuebnb主页上工作，该主页显示缩略图和链接到我们所有模拟列表的页面：
- en: '![](assets/ecdce2d9-a3cb-45ea-81f0-2f653471205e.png)Figure 7.1\. Front page
    of Vuebnb'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/ecdce2d9-a3cb-45ea-81f0-2f653471205e.png)图7.1。Vuebnb的首页'
- en: Installing Vue Router
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Vue Router
- en: 'Vue Router is an NPM package and can be installed on the command line:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Vue Router是一个NPM包，可以在命令行上安装：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s put our router configuration into a new file, `router.js`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的路由器配置放入一个新文件`router.js`中：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To add Vue Router to our project, we must import the library and then use the `Vue.use` API
    method to make Vue compatible with Vue Router. This will give Vue a new configuration
    property, `router`, that we can use to connect a new router.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Vue Router添加到我们的项目中，我们必须导入该库，然后使用`Vue.use`API方法使Vue与Vue Router兼容。这将为Vue提供一个新的配置属性`router`，我们可以使用它来连接一个新的路由器。
- en: We then create an instance of Vue Router with new `VueRouter()`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`new VueRouter()`创建Vue Router的实例。
- en: '`resources/assets/js/router.js`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/router.js`：'
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By exporting our router instance from this new file, we've made it into a module
    that can be imported in `app.js`. If we name the imported module `router`, object
    destructuring can be used to succinctly connect it to our main configuration object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从这个新文件中导出我们的路由器实例，我们已经将其转换为一个可以在`app.js`中导入的模块。如果我们将导入的模块命名为`router`，则可以使用对象解构来简洁地将其连接到我们的主配置对象。
- en: '`resources/assets/js/app.js`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating routes
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建路由
- en: The most basic configuration for Vue Router is to provide a `routes` array, which
    maps URLs to the corresponding page components. This array will contain objects
    with at least two properties: `path` and `component`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Vue Router的最基本配置是提供一个`routes`数组，它将URL映射到相应的页面组件。此数组将包含至少两个属性的对象：`path`和`component`。
- en: Note that by *page components* I'm simply referring to any components that we've
    designated to represent a page in our app. They are regular components in every
    other way.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过*页面组件*，我只是指任何我们指定为在我们的应用程序中表示页面的组件。它们在其他方面都是常规组件。
- en: For now, we're only going to have two routes in our app, one for our home page
    and one for our listing page. The `HomePage` component doesn't exist yet, so we'll
    keep its route commented out until we create it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序中只会有两个路由，一个用于我们的主页，一个用于我们的列表页面。`HomePage`组件尚不存在，因此在创建它之前，我们将保持其路由被注释掉。
- en: '`resources/assets/js/router.js`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/router.js`：'
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You'll notice that the path for our `ListingPage` component contains a dynamic
    segment `:listing` so that this route will match paths including `/listing/1, listing/2 ... listing/whatever`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们的`ListingPage`组件的路径包含一个动态段`:listing`，因此此路由将匹配包括`/listing/1、listing/2...listing/whatever`在内的路径。
- en: There are two modes for Vue Router: *hash* mode and *history* mode. Hash mode
    uses the URL hash to simulate a full URL so that the page won't be reloaded when
    the hash changes. History mode has *real* URLs and leverages the `history.pushState` API
    to change the URL without causing a page reload. The only downside to history
    mode is that URLs outside of the app, such as `/some/weird/path`, can't be handled
    by Vue and must be handled by the server. That's no problem for us, so we'll use
    history mode for Vuebnb.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Vue Router有两种模式：*hash*模式和*history*模式。哈希模式使用URL哈希来模拟完整的URL，因此当哈希更改时页面不会重新加载。历史模式有*真实*的URL，并利用`history.pushState`API来更改URL而不引起页面重新加载。历史模式的唯一缺点是Vue无法处理应用程序之外的URL，例如`/some/weird/path`，必须由服务器处理。这对我们来说不是问题，所以我们将使用Vuebnb的历史模式。
- en: App component
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序组件
- en: For our router to work, we need to declare a `RouterView`component somewhere
    in our page template. Otherwise, there's nowhere for the page components to render.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的路由器工作，我们需要在页面模板的某个地方声明一个`RouterView`组件。否则，页面组件将无处可渲染。
- en: We'll slightly restructure our app to do this. As it is, the `ListingPage` component
    is the `root` component of the app, as it is at the top of the component hierarchy
    and loads all other components that we use.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍微重构我们的应用程序来做到这一点。目前，`ListingPage`组件是应用程序的`root`组件，因为它位于组件层次结构的顶部，并加载我们使用的所有其他组件。
- en: 'Since we want the router to switch between `ListingPage` and `HomePage` based
    on the URL, we need another component to be above `ListingPage`in the hierarchy
    and handle this work. We''ll call this new root component `App`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望路由器根据URL在`ListingPage`和`HomePage`之间切换，我们需要另一个组件在组件层次结构中位于`ListingPage`之上并处理这项工作。我们将称这个新的根组件为`App`：
- en: '![](assets/2a411013-4710-4909-ad18-255dd9144d45.png)Figure 7.2\. The relationship
    between App, ListingPage, and HomePage'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2a411013-4710-4909-ad18-255dd9144d45.png)图7.2。App、ListingPage和HomePage之间的关系'
- en: 'Let''s create the `App` component file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`App`组件文件：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The root instance of Vue should render this to the page when it loads, instead
    of `ListingPage`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Vue的根实例在加载时应该将这个渲染到页面上，而不是`ListingPage`。
- en: '`resources/assets/js/app.js`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The following is the content of the `App` component. I've added the special `RouterView` component
    into the template, which is the outlet where either the `HomePage` or `ListingPage` component
    will render.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`App`组件的内容。我在模板中添加了特殊的`RouterView`组件，这是`HomePage`或`ListingPage`组件将渲染的出口。
- en: You'll also notice I've moved the toolbar from `app.blade.php` into the template
    of `App`. This is so the toolbar is in the domain of Vue; before it was outside
    of the mount point and therefore untouchable by Vue. I've done this so that later
    we can make the main logo a link to the home page using `RouterLink`, as this
    is a convention for most websites. I've moved any toolbar related CSS into the `style` element
    as well.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到我已经将工具栏从`app.blade.php`移动到了`App`的模板中。这样工具栏就在Vue的领域内；之前它在安装点之外，因此无法被Vue触及。我这样做是为了以后我们可以使用`RouterLink`将主标志变成一个指向主页的链接，因为这是大多数网站的惯例。我也将任何与工具栏相关的CSS移入了`style`元素中。
- en: '`resources/assets/components/App.vue`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/App.vue`：'
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With that done, if you now navigate the browser to a URL like `/listing/1`,
    you'll see everything looks the same as it did before. However, if you look at
    Vue Devtools, you'll see the component hierarchy has changed, reflecting the addition
    of the `App` component.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，如果您现在将浏览器导航到类似`/listing/1`的URL，您会发现一切看起来与以前一样。但是，如果您查看Vue Devtools，您会发现组件层次结构已经改变，反映了`App`组件的添加。
- en: 'There''s also an indicator, which tells us that the `ListingPage` component
    is the active page component for Vue Router:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个指示器，告诉我们`ListingPage`组件是Vue Router的活动页面组件：
- en: '![](assets/41b25c67-0eeb-449c-8448-c7703091d149.png)Figure 7.3. /listing/1 with
    Vue Devtools open, showing the component hierarchy'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/41b25c67-0eeb-449c-8448-c7703091d149.png)图7.3。在Vue Devtools打开的情况下，显示组件层次结构的/listing/1'
- en: Home page
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主页
- en: 'Let''s start work on our home page now. We''ll first create a new component, `HomePage`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始在我们的主页上工作。我们首先创建一个新组件`HomePage`：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For now, let's add placeholder markup to the component before we set it up properly.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在设置之前向组件添加占位符标记。
- en: '`resources/assets/components/HomePage.vue`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/HomePage.vue`：'
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Be sure to import this component in the `router` file, and uncomment the route
    where it's used.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在`router`文件中导入此组件，并取消使用它的路由。
- en: '`resources/assets/js/router.js`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/router.js`：'
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You might be tempted to test this new route out by putting the URL `http://vuebnb.test/`into
    your browser address bar. You'll find, though, that it results in a 404 error.
    Remember, we still haven't created a route for this on our server. Although Vue
    is managing routes from *within* the app, any address bar navigation requests
    must be served from Laravel.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会尝试通过将URL`http://vuebnb.test/`放入浏览器地址栏来测试这个新路由。但是，您会发现这导致404错误。请记住，我们仍然没有在服务器上为此创建路由。尽管Vue从*内部*管理路由，但任何地址栏导航请求必须由Laravel提供。
- en: Let's now create a link to our home page in the toolbar by using the `RouterLink`component.
    This component is like an enhanced `a`tag. For example, if you give your routes
    a `name` property, you can simply use the `to` prop rather than having to supply
    an `href`. Vue will resolve this to the correct URL on render.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用`RouterLink`组件在工具栏中创建一个指向我们主页的链接。这个组件就像一个增强版的`a`标签。例如，如果给你的路由一个`name`属性，你可以简单地使用`to`属性，而不必提供一个`href`。Vue会在渲染时解析这个到正确的URL。
- en: '`resources/assets/components/App.vue`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/App.vue`：'
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let's also add name properties to our routes for this to work.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也为我们的路由添加`name`属性，以使其工作。
- en: '`resources/assets/js/app.js`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We'll also have to modify our CSS now since we now have another tag wrapped
    around our logo. Modify the toolbar CSS rules to match those that follow.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须修改我们的CSS，因为我们现在的标志周围有另一个标签。修改工具栏CSS规则以匹配后面的规则。
- en: '`resources/assets/components/App.vue`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/App.vue`：'
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s now open a listing page, such as `/listing/1`. If you inspect the DOM,
    you''ll see that our toolbar now has a new `a` tag inside it with a correctly
    resolved link back to the home page:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们打开一个列表页面，比如`/listing/1`。如果你检查DOM，你会看到我们的工具栏现在里面有一个新的`a`标签，其中包含一个正确解析的链接返回到主页：
- en: '![](assets/f53a1ca6-f0d5-4c08-b75c-c6f794e81b96.png)Figure 7.4\. The toolbar
    is a link back to the home page via the RouterLink element'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/f53a1ca6-f0d5-4c08-b75c-c6f794e81b96.png)图7.4 工具栏是通过`RouterLink`元素返回到主页的链接'
- en: 'If you click that link, you''ll be taken to the home page! Remember, the *page*
    hasn''t actually changed; Vue router simply swapped `ListingPage` for `HomePage` within `RouterView`,
    and also updated the browser URL via the `history.pushState` API:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击那个链接，你会被带到主页！记住，*页面*实际上并没有改变；Vue路由器只是在`RouterView`内将`ListingPage`替换为`HomePage`，并且通过`history.pushState`API更新了浏览器URL：
- en: '![](assets/4a5c5d24-13bb-45ea-8dac-a2272c4f7a4b.png)Figure 7.5\. Home page
    with Vue Devtools showing component hierarchy'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/4a5c5d24-13bb-45ea-8dac-a2272c4f7a4b.png)图7.5 主页与Vue Devtools显示的组件层次结构'
- en: Home route
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主页路由
- en: Let's now add a server-side route for the home page so that we can load our
    app from the root path. This new route will point to a `get_home_web` method in
    our `ListingController` class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为主页添加一个服务器端路由，这样我们就可以从根路径加载我们的应用程序。这个新路由将指向`ListingController`类中的`get_home_web`方法。
- en: '`routes/web.php`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes/web.php`：'
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Going to the controller now, we'll make it so the `get_home_web` method returns
    the `app` view, just as it does for the listing web route. The `app` view includes
    a template variable model which we use to pass through the initial application
    state, as set up in [Chapter 5](f7d2046c-81c6-416b-977e-2f166a911244.xhtml), *Integrating
    Laravel and Vue.js with Webpack*. For now, just assign an empty array as a placeholder.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在去控制器，我们将使`get_home_web`方法返回`app`视图，就像它为列表web路由所做的那样。`app`视图包括一个模板变量`model`，我们使用它来传递初始应用程序状态，就像在[第5章](f7d2046c-81c6-416b-977e-2f166a911244.xhtml)中设置的那样，*使用Webpack集成Laravel和Vue.js*。现在，只需将一个空数组分配为占位符。
- en: '`app/Http/Controllers/ListingController.php`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/Http/Controllers/ListingController.php`：'
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With that done, we can now navigate to `http://vuebnb.test/` and it will work!
    When the Vue app is bootstrapped, Vue Router will check the URL value and, seeing
    that the path is `*/*`, will load the `HomePage` component inside the `RouterView` outlet
    for the first rendering of the app.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们现在可以导航到`http://vuebnb.test/`，它会工作！当Vue应用程序启动时，Vue Router将检查URL值，并且看到路径是`*/*`，将在应用程序的第一次渲染中在`RouterView`出口内加载`HomePage`组件。
- en: 'Viewing the source of this page, it''s exactly the same page as we get when
    we load the listing route since it''s the same view, that is, `app.blade.php`.
    The only difference is that the initial state is an empty array:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这个页面的源代码，它与我们加载列表路由时得到的页面完全相同，因为它是相同的视图，即`app.blade.php`。唯一的区别是初始状态是一个空数组：
- en: '![](assets/c29df2f7-0487-481e-8df9-ffaac0b12063.png)Figure 7.6\. Page source
    of vuebnb.test with empty initial state'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c29df2f7-0487-481e-8df9-ffaac0b12063.png)图7.6 vuebnb.test的页面源代码，初始状态为空'
- en: Initial state
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始状态
- en: 'Just like our listing page, our home page will need initial state. Looking
    at the finished product, we can see that the home page displays a summary of all
    our mock listings with a thumbnail image, a title, and short description:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的列表页面一样，我们的主页也需要初始状态。从最终产品来看，我们可以看到主页显示了我们所有模拟列表的摘要，包括缩略图、标题和简短描述：
- en: '![](assets/bdfc15b5-27a5-4468-a68d-bd19e7a2ac25.png)Figure 7.7\. Completed
    home page, focusing on listings'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/bdfc15b5-27a5-4468-a68d-bd19e7a2ac25.png)图7.7 完成的主页，关注列表'
- en: Refactoring
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: Before we inject the initial state into the home page, let's do a small refactoring
    of the code including renaming some variables and restructuring some methods.
    This will ensure that the code semantics reflect the changing requirements and
    keep our code readable and easy to understand.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将初始状态注入到主页之前，让我们对代码进行一些小的重构，包括重命名一些变量和重构一些方法。这将确保代码语义反映出不断变化的需求，并保持我们的代码可读性和易理解性。
- en: Firstly, let's rename our template variable from `$model` to the more general `$data`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将我们的模板变量从`$model`重命名为更一般的`$data`。
- en: '`resources/views/app.blade.php`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In our listing controller, we're now going to abstract any common logic from
    our listing route methods into a new helper method called `get_listing`. In this
    helper method, we will nest the `Listing` model inside a Laravel `Collection` under
    the `listing` key. `Collection` is an array-like wrapper for Eloquent models that
    offers a bunch of handy methods that we'll be putting to use shortly. `get_listing` will
    include logic from the `add_image_urls` helper method, which can now safely be
    deleted.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的列表控制器中，我们现在要将任何通用逻辑从我们的列表路由方法中抽象出来，放到一个名为`get_listing`的新辅助方法中。在这个辅助方法中，我们将`Listing`模型嵌套在Laravel的`Collection`中，`Collection`是Eloquent模型的类似数组的包装器，提供了一堆方便的方法，我们很快就会用到。`get_listing`将包括来自`add_image_urls`辅助方法的逻辑，现在可以安全地删除它。
- en: We'll also need to reflect the change to our template variable when we call
    the `view` method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`view`方法时，我们还需要反映对我们的模板变量的更改。
- en: '`app/Http/Controllers/ListingController.php`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/Http/Controllers/ListingController.php`：'
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, we'll need to update our `ListingPage` component to reflect the new
    name and structure of the server data we're injecting.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新我们的`ListingPage`组件，以反映我们正在注入的服务器数据的新名称和结构。
- en: '`resources/assets/components/ListingPage.vue`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingPage.vue`：'
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Home page initial state
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主页初始状态
- en: Using Eloquent ORM, it's trivial to retrieve all our listing entries using the
    method `Listing::all`. Multiple `Model` instances are returned by this method
    within a `Collection` object.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Eloquent ORM，使用`Listing::all`方法检索所有我们的列表条目是微不足道的。这个方法在一个`Collection`对象中返回多个`Model`实例。
- en: Note that we don't need all the fields on the model, for example, `amenities`,
    `about`, and  so on are not used in the listing summaries that populate the home
    page. To ensure our data is as lean as possible, we can pass an array of fields
    to the `Listing::all` method that will tell the database to only include those
    fields explicitly mentioned.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要模型上的所有字段，例如`amenities`，`about`等在填充主页的列表摘要时没有用到。为了确保我们的数据尽可能精简，我们可以将一个字段数组传递给`Listing::all`方法，告诉数据库只包括那些明确提到的字段。
- en: '`app/Http/Controllers/ListingController.php`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/Http/Controllers/ListingController.php`：'
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Adding the thumbnail
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加缩略图
- en: Each mock listing has a thumbnail version of the first image, which can be used
    for the listing summary. The thumbnail is much smaller than the image we use for
    the header of the listing page and is ideal for the listing summaries on the home
    page. The URL for the thumbnail is `public/images/{x}/Image_1_thumb.jpg` where `{x}` is
    the ID of the listing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模拟列表都有第一张图片的缩略版本，可以用于列表摘要。缩略图比我们用于列表页面标题的图片要小得多，非常适合在主页上显示列表摘要。缩略图的URL是`public/images/{x}/Image_1_thumb.jpg`，其中`{x}`是列表的ID。
- en: '`Collection` objects have a helper method, `transform`, that we can use to
    add the thumbnail image URL to each listing. `transform` accepts a callback closure
    function that is called once per item, allowing you to modify that item and return
    it to the collection without fuss.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection`对象有一个辅助方法`transform`，我们可以使用它来为每个列表添加缩略图图片URL。`transform`接受一个回调闭包函数，每个项目调用一次，允许您修改该项目并将其返回到集合中，而不费吹灰之力。'
- en: '`app/Http/Controllers/ListingController.php`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/Http/Controllers/ListingController.php`：'
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Receiving in the client
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在客户端接收
- en: 'With the initial state now ready, let''s add it to our `HomePage` component.
    Before we can use it though there''s an additional aspect we need to consider:
    the listing summaries are grouped by *country*. Look again at *Figure 7.7* to
    see how these groups are displayed.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在初始状态已经准备好了，让我们将其添加到我们的`HomePage`组件中。但在我们使用它之前，还有一个额外的方面需要考虑：列表摘要是按*国家*分组的。再次看一下*图7.7*，看看这些组是如何显示的。
- en: After we've parsed our injected data, let's modify the object so the listings
    are grouped by country. We can easily create a function to do this, as every listing
    object has an `address` property in which the country is always explicitly named,
    for example, *No. 51, Hanzhong Street, Wanhua District, Taipei City, Taiwan 108*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解析了注入的数据之后，让我们修改对象，使得列表按国家分组。我们可以很容易地创建一个函数来做到这一点，因为每个列表对象都有一个`address`属性，其中国家总是明确命名的，例如，*台湾台北市万华区汉中街51号108*。
- en: To save you having to write this function, I have supplied one in the `helpers` module
    called `groupByCountry` which can be imported at the top of the component configuration.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省您编写这个函数的时间，我在`helpers`模块中提供了一个名为`groupByCountry`的函数，可以在组件配置的顶部导入。
- en: '`resources/assets/components/HomePage.vue`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/HomePage.vue`：'
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''ll now see through Vue Devtools that `HomePage` has successfully loaded
    the listing summaries, grouped by country and ready for display:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过Vue Devtools看到`HomePage`已经成功加载了按国家分组的列表摘要，准备显示：
- en: '![](assets/3936ccf7-bf87-4f1f-81b6-ba32cefb8c2c.png)Figure 7.8\. Vue Devtools
    showing the state of the HomePage component'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/3936ccf7-bf87-4f1f-81b6-ba32cefb8c2c.png)图7.8. Vue Devtools显示了HomePage组件的状态'
- en: ListingSummary component
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ListingSummary组件
- en: Now that the `HomePage` component has data available, we can work on displaying
    it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`HomePage`组件有了可用的数据，我们可以开始显示它。
- en: To begin with, clear out the existing content of the component and replace it
    with a `div`. This `div` will feature a `v-for` directive to iterate through each
    of our listing groups. Since `listing_groups` is an object with key/value pairs,
    we'll give our `v-for` two aliases: `group` and `country`, which are the value
    and key of each object item respectively.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，清空组件的现有内容，并将其替换为一个`div`。这个`div`将使用`v-for`指令来遍历我们的每一个列表组。由于`listing_groups`是一个具有键/值对的对象，我们将给我们的`v-for`两个别名：`group`和`country`，分别是每个对象项的值和键。
- en: We will interpolate `country` inside a heading. `group` will be used in the
    next section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个标题中插入`country`。`group`将在下一节中使用。
- en: '`resources/assets/components/HomePage.vue`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/HomePage.vue`：'
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is what the home page will now look like:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在主页将会是这个样子：
- en: '![](assets/858d9f59-82a4-4b37-9f17-d66fb6b3d5ee.png)Figure 7.9\. Iterating
    the listing summary groups in the HomePage component'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/858d9f59-82a4-4b37-9f17-d66fb6b3d5ee.png)图7.9. 在HomePage组件中迭代列表摘要组'
- en: 'Since each listing summary will be of some complexity, we''ll create a separate
    component, `ListingSummary`, for displaying them:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个列表摘要都会有一定的复杂性，我们将创建一个单独的组件`ListingSummary`来显示它们：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's declare `ListingSummary` within our `HomePage` template. We'll again use
    a `v-for` directive to iterate `group`, an array, creating a new instance of `ListingSummary` for
    each member. The data for each member will be bound to a single prop, `listing`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`HomePage`模板中声明`ListingSummary`。我们将再次使用`v-for`指令来遍历`group`，一个数组，为每个成员创建一个`ListingSummary`的新实例。每个成员的数据将绑定到一个单独的prop`listing`。
- en: '`resources/assets/components/HomePage.vue`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/HomePage.vue`：'
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let's create some simple content for the `ListingSummary` component, just to
    test our approach.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`ListingSummary`组件创建一些简单的内容，只是为了测试我们的方法。
- en: '`resources/assets/components/ListingSummary.vue`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSummary.vue`：'
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Refreshing our page, we''ll now see this prototype of our listing summaries:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新我们的页面，现在我们将看到我们的列表摘要的原型：
- en: '![](assets/914379fb-83ff-4ee2-9f2f-bf458f5c6cce.png)Figure 7.10\. Prototype
    of ListingSummary component'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/914379fb-83ff-4ee2-9f2f-bf458f5c6cce.png)图7.10. ListingSummary组件的原型'
- en: Since this approach is working, let's now complete the structure of the `ListingSummary` component.
    To display the thumbnail, we bind it as a background image for a fixed width/height `div`.
    We'll also need some CSS rules to get this displaying nicely.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种方法有效，现在让我们完成`ListingSummary`组件的结构。为了显示缩略图，我们将其绑定为固定宽度/高度的背景图片`div`。我们还需要一些CSS规则来使其显示得很好。
- en: '`resources/assets/components/ListingSummary.vue`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSummary.vue`：'
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After you add that code, your listing summaries will look like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了该代码后，您的列表摘要将如下所示：
- en: '![](assets/1d03bd54-26e4-4b89-96ba-488b7749ccc8.png)Figure 7.11\. Complete
    listing summaries being displayed'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11。显示完整的列表摘要
- en: We gave each listing summary a fixed width/height so that we could display them
    in a neat grid. Currently, they're displaying in one tall column, so let's add
    some CSS flex rules to the `HomePage` component to get the summaries into rows.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给每个列表摘要一个固定的宽度/高度，以便我们可以以整齐的网格显示它们。目前，它们显示在一个高列中，所以让我们向`HomePage`组件添加一些CSS
    flex规则，将摘要放入行中。
- en: We'll add a class `listing-summary-group` to the element that wraps the summaries.
    We'll also add a class `home-container` to the root `div` to constrain the width
    of the page and center the content.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在包装摘要的元素中添加一个名为`listing-summary-group`的类。我们还将在根`div`中添加一个名为`home-container`的类，以限制页面的宽度并使内容居中。
- en: '`resources/assets/components/HomePage.vue`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/HomePage.vue`：'
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finally, we'll need to add a rule to prevent the listings from forcing the edge
    of the document to exceed the viewport. Add this to the main CSS file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加一个规则，防止列表强制文档边缘超出视口。将这个规则添加到主CSS文件中。
- en: '`resources/assets/css/style.css`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/css/style.css`：'
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With that, we get a nice looking home page:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们得到了一个漂亮的主页：
- en: '![](assets/2af19583-0877-4a44-b9c5-44c1be1d91d5.png)Figure 7.12\. Listing summaries
    in rows'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12。列表摘要按行显示
- en: 'You''ll notice that at full page width, we can only see three listings from
    each country group. The other seven are hidden by the CSS `overflow: hidden` rule.
    Soon, we''ll be adding image slider functionality to each group to allow the user
    to browse through all the listings.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '您会注意到在整个页面宽度上，我们只能看到每个国家组的三个列表。其他七个被CSS的`overflow: hidden`规则隐藏了。很快，我们将为每个组添加图像滑块功能，以允许用户浏览所有列表。'
- en: In-app navigation
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用内导航
- en: 'If we use the address bar of the browser to navigate to the home page, `http://vuebnb.test/`,
    it works because Laravel is now serving a page at this route. But, if we navigate
    to the home page *from the listing page*, there''s no longer any page content:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用浏览器的地址栏导航到主页，`http://vuebnb.test/`，它可以工作，因为Laravel现在在这个路由上提供页面。但是，如果我们从列表页导航到主页，就不再有页面内容了：
- en: '![](assets/4c4b9d22-86d4-4846-8b3d-3b5bb6f6ff55.png)Figure 7.13\. Empty home
    page after navigating from listing page'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13。从列表页导航到空的主页
- en: We currently don't have any links to the listing page from the home page, but
    if we did, we'd experience a similar issue.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前没有从主页到列表页的任何链接，但如果有的话，我们会遇到类似的问题。
- en: The reason is that our page components currently get their initial state from
    the data we've injected into the head of the document. If we navigate to a different
    page using Vue Router, which doesn't invoke a page refresh, the next page component
    will have the wrong initial state merged in.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是我们的页面组件目前从我们注入到文档头部的数据中获取它们的初始状态。如果我们使用Vue Router导航到不会引发页面刷新的不同页面，下一个页面组件将合并错误的初始状态。
- en: 'We need to improve our architecture so that when a page is navigated to we
    check if the model injected into the head matches the current page. To facilitate
    this, we''ll add a `path`property to the model and check that it matches the active
    URL. If not, we''ll use AJAX to get the right data from the web service:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要改进我们的架构，以便在导航到页面时检查注入到头部的模型是否与当前页面匹配。为了实现这一点，我们将在模型中添加一个`path`属性，并检查它是否与活动URL匹配。如果不匹配，我们将使用AJAX从网络服务获取正确的数据：
- en: '![](assets/a22ae360-9d35-4247-b66a-1ae858d2130f.png)Figure 7.14\. How a page
    decides what data it needsIf you''re interested in reading more about this design
    pattern, check out the article *Avoid This Common Anti-Pattern In Full-Stack Vue/Laravel
    Apps* at [https://vuejsdevelopers.com/2017/08/06/vue-js-laravel-full-stack-ajax/](https://vuejsdevelopers.com/2017/08/06/vue-js-laravel-full-stack-ajax/).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14。页面如何决定需要什么数据如果您对阅读更多关于这种设计模式感兴趣，请查看文章*Avoid This Common Anti-Pattern In
    Full-Stack Vue/Laravel Apps*，网址为[https://vuejsdevelopers.com/2017/08/06/vue-js-laravel-full-stack-ajax/](https://vuejsdevelopers.com/2017/08/06/vue-js-laravel-full-stack-ajax/)。
- en: Adding a path to the model
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向模型添加路径
- en: Let's go to the listing controller and add a `path` property to the data injected
    into the head of our view. To do this, we'll add a helper function called `add_meta_data` which
    will add the path, as well as some other meta properties in later chapters.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到列表控制器，并向注入到我们视图头部的数据添加一个`path`属性。为此，我们将添加一个名为`add_meta_data`的辅助函数，它将在后面的章节中添加路径，以及一些其他元属性。
- en: Note that the path of the current route can be determined by the `Request` object.
    This object can be declared as the last argument of any `route-handling` functions
    and is provided in each request by the service container.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当前路由的路径可以通过`Request`对象确定。这个对象可以被声明为任何`route-handling`函数的最后一个参数，并且由服务容器在每个请求中提供。
- en: '`app/Http/Controllers/ListingController.php`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/Http/Controllers/ListingController.php`：'
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Route navigation guards
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由导航守卫
- en: Similar to lifecycle hooks, *navigation guards* allow you to intercept Vue Router
    navigations at a particular point in their life cycle. These guards can be applied
    to a specific component, a specific route, or to all routes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于生命周期钩子，*导航守卫*允许您在其生命周期的特定时刻拦截Vue Router导航。这些守卫可以应用于特定组件、特定路由或所有路由。
- en: 'For example, `afterEach` is the navigation guard called after any route is
    navigated away from. You might use this hook to store analytics information, for
    example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`afterEach`是在任何路由被导航离开后调用的导航守卫。您可以使用此钩子来存储分析信息，例如：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can use the `beforeRouteEnter`navigation guard to fetch data from our web
    service if the data in the head is unsuitable. Consider the following pseudo-code
    for how we might implement this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`beforeRouteEnter`导航守卫从我们的网络服务中获取数据，如果头部的数据不合适。考虑以下伪代码，说明我们可能如何实现这一点：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: next
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一个
- en: 'An important feature of navigation guards is that they will halt navigation
    until the `next` function is called. This allows asynchronous code to be executed
    before the navigation is resolved:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 导航守卫的一个重要特性是它们会阻止导航，直到调用`next`函数。这允许在解析导航之前执行异步代码。
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can pass `false` to the `next` function to prevent a navigation, or you
    can pass a different route to redirect it. If you don't pass anything, the navigation
    is considered confirmed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向`next`函数传递`false`来阻止导航，或者你可以传递一个不同的路由来重定向它。如果你什么都不传，导航被认为是确认的。
- en: 'The `beforeRouteEnter` guard is a special case. Firstly, `this` is undefined
    within it since it is called before the next page component has been created:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeRouteEnter`守卫是一个特殊情况。首先，在它内部，`this`是未定义的，因为它是在下一个页面组件被创建之前调用的。'
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: However, the `next` function in `beforeRouteEnter` can accept a callback function
    as an argument, for example, `next(component => { ... });` where `component` is
    the page component instance.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`beforeRouteEnter`中的`next`函数可以接受一个回调函数作为参数，例如，`next(component => { ... });`其中`component`是页面组件实例。
- en: 'This callback is not triggered until the route is confirmed and the component
    instance has been created. Due to how JavaScript closures work, the callback will
    have access to the scope of the surrounding code where it was called:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个回调函数直到路由确认并且组件实例被创建后才会被触发。由于JavaScript闭包的工作原理，回调函数将可以访问它被调用的周围代码的作用域。
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: HomePage component
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HomePage组件
- en: Let's add `beforeRouteEnter` to the `HomePage`component. Firstly, move any logic
    for retrieving data from the document head into the hook. We then check the `path`property
    of the data to see if it matches the current route. If so, we call `next`and pass
    a callback function that applies the data to the component's instance. If not,
    we'll need to use AJAX to get the right data.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把`beforeRouteEnter`添加到`HomePage`组件中。首先，将从文档头部检索数据的任何逻辑移到这个钩子中。然后我们检查数据的`path`属性，看它是否与当前路由匹配。如果是，我们调用`next`并传递一个将数据应用到组件实例的回调函数。如果不是，我们需要使用AJAX来获取正确的数据。
- en: '`resources/assets/components/HomePage.vue`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/HomePage.vue`：'
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: I've added `listing_groups` as a data property. Before, we were applying our
    data to the component instance as it was created. Now, we're applying the data
    after the component is created. To set up reactive data, Vue must know the names
    of the data properties, so we initialize with an empty value and update it when
    the data needed is available.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经添加了`listing_groups`作为数据属性。之前，我们在组件实例创建时应用我们的数据。现在，我们在组件创建后应用数据。为了设置响应式数据，Vue必须知道数据属性的名称，所以我们用空值初始化，当需要的数据可用时再更新它。
- en: Home API endpoint
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主页API端点
- en: We'll now implement the AJAX functionality. Before we do, though, we need to
    add a home page endpoint to our web service.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现AJAX功能。不过，在我们这样做之前，我们需要在我们的Web服务中添加一个主页端点。
- en: Let's first add the home API route.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先添加主页API路由。
- en: '`routes/api.php`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes/api.php`：'
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Looking now at the `ListingController` class, we'll abstract the bulk of the
    logic from `get_home_web` into a new function, `get_listing_summaries`. We'll
    then use this function in the `get_home_api` method and return a JSON response.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看`ListingController`类，我们将把`get_home_web`中的大部分逻辑抽象成一个新函数`get_listing_summaries`。然后我们将在`get_home_api`方法中使用这个函数并返回一个JSON响应。
- en: '`app/Http/Controllers/ListingController.php`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/Http/Controllers/ListingController.php`：'
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Axios
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Axios
- en: 'To perform AJAX requests to the web service, we''ll use the Axios HTTP client,
    which is included with Laravel''s default frontend code. Axios has a very simple
    API allowing us to make requests to a GET URL like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行对Web服务的AJAX请求，我们将使用包含在Laravel默认前端代码中的Axios HTTP客户端。Axios有一个非常简单的API，允许我们向GET
    URL发出请求，如下所示：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Axios is a Promise-based library, so in order to retrieve the response, you
    can simply chain a `then` callback:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Axios是一个基于Promise的库，所以为了获取响应，你可以简单地链接一个`then`回调：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As the Axios NPM package is already installed, we can go ahead and import the `HomePage`component.
    We can then use it to perform the request to the home API endpoint, `/api/`. In
    the `then` callback, we apply the returned data to the component instance exactly
    as we did with the inlined model.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Axios NPM包已经安装，我们可以导入`HomePage`组件。然后我们可以使用它来执行对主页API端点`/api/`的请求。在`then`回调中，我们将返回的数据应用到组件实例，就像我们在内联模型中所做的那样。
- en: '`resources/assets/components/HomePage.vue`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/HomePage.vue`：'
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: And with that, we can now navigate to the home page in two ways, either via
    the address bar, or by going from a link from the listing page. Either way, we
    get the right data!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以以两种方式导航到主页，一种是通过地址栏，另一种是从列表页面的链接导航。无论哪种方式，我们都能得到正确的数据！
- en: Mixins
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合
- en: If you have any functionality that is common between components, you can put
    it in a `mixin` to avoid rewriting the same functionality.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有任何在组件之间共同的功能，你可以把它放在一个`mixin`中，以避免重写相同的功能。
- en: 'A Vue `mixin` is an object in the same form as a component configuration object.
    To use it in a component, declare within an array and assign it to the configuration
    property `mixin`. When this component is instantiated, any configuration options
    of the `mixin` will be merged with what you''ve declared on the component:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Vue `mixin`是一个与组件配置对象形式相同的对象。要在组件中使用它，声明为一个数组，并将其分配给配置属性`mixin`。当这个组件被实例化时，`mixin`的任何配置选项将与你在组件上声明的选项合并：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You might be wondering what happens if the component configuration has a method
    or other property that conflicts with the `mixin`. The answer is that `mixins`
    have a *merging strategy* that determines the priority of any conflicts. Generally,
    the component's specified configuration will take precedence. The details of the
    merging strategy are explained in the Vue.js documentation at [http://vuejs.org](http://vuejs.org).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，如果组件配置中有一个与“mixin”冲突的方法或其他属性会发生什么。答案是“mixins”有一个*合并策略*来确定任何冲突的优先级。通常，组件指定的配置将优先。合并策略的详细信息在Vue.js文档中解释[http://vuejs.org](http://vuejs.org)。
- en: Moving the solution to a mixin
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将解决方案移动到mixin
- en: 'Let''s generalize the solution for getting the right data to the home page
    so that we can use it on the listing page as well. To do this, we''ll move Axios
    and the `beforeRouteEnter` hook from the `HomePage` component into a mixin that
    can then be added to both page components:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将解决方案概括为获取首页正确数据的解决方案，以便我们也可以在列表页面上使用它。为此，我们将Axios和`beforeRouteEnter`钩子从`HomePage`组件移动到一个mixin中，然后可以将其添加到两个页面组件中：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: At the same time, let's improve the code by removing the repetition of the `next` function
    call. To do this, we'll create a new method, `getData`, which will be responsible
    for figuring out where to get the right data for the page and also for getting
    it. Note that this method will be asynchronous since it may need to wait for AJAX
    to resolve, so it will return a Promise rather than an actual value. This Promise
    is then resolved within the navigation guard.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，让我们通过删除`next`函数调用的重复来改进代码。为此，我们将创建一个新方法`getData`，它将负责找出页面的正确数据来源，并获取它。请注意，这个方法将是异步的，因为它可能需要等待AJAX解析，所以它将返回一个Promise而不是实际值。这个Promise然后在导航守卫中解析。
- en: '`resources/assets/js/route-mixin.js`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/route-mixin.js`：'
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We don't need a polyfill for Promise as that is already supplied in the `Axios`
    library.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要为Promise添加polyfill，因为`Axios`库中已经提供了。
- en: assignData
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: assignData
- en: You'll notice that within the `next` callback we call a method on the subject
    component called `assignData`, passing the data object as an argument. We'll need
    to implement the `assignData` method in any component that uses this `mixin`.
    We do it this way so that the component can process the data, if necessary, before
    it is applied to the component instance. For example, the `ListingPage` component
    must process the data via the `populateAmenitiesAndPrices` helper function.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到在`next`回调中，我们调用了主题组件上的一个方法`assignData`，并将数据对象作为参数传递。我们需要在使用这个`mixin`的任何组件中实现`assignData`方法。我们这样做是为了让组件在应用到组件实例之前，如果需要的话，可以处理数据。例如，`ListingPage`组件必须通过`populateAmenitiesAndPrices`辅助函数处理数据。
- en: '`resources/assets/components/ListingPage.vue`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingPage.vue`：'
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We'll also need to add `assignData` to the `HomePage` component.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将`assignData`添加到`HomePage`组件中。
- en: '`resources/assets/components/HomePage.vue`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/HomePage.vue`：'
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Linking to the listing page
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接到列表页面
- en: The above should work but we can't test it since there are not yet any in-app
    links to the listing page!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的方法应该有效，但我们无法测试，因为尚未有任何应用内链接到列表页面！
- en: Each of our `ListingSummary` instances represents a single listing, and should
    therefore be a clickable link to the page for that listing. Let's use the `RouterLink` component
    to achieve this. Note that the object we bind to the `to` prop includes the name
    of the route as well as a `params` object which includes a value for the dynamic
    segment of the route, the listing ID.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的每个`ListingSummary`实例代表一个单独的列表，并且应该是指向该列表页面的可点击链接。让我们使用`RouterLink`组件来实现这一点。请注意，我们绑定到`to`属性的对象包括路由的名称以及一个`params`对象，其中包括路由的动态段的值，即列表ID。
- en: '`resources/assets/components/ListingSummary.vue`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSummary.vue`：'
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With that done, the listing summaries will now be links. Clicking from one
    to the listing page, we see this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，列表摘要现在将是链接。从一个链接到列表页面，我们看到这个：
- en: '![](assets/47a777b4-a997-42b3-bf6b-5e8d34379b22.png)Figure 7.15\. Successful
    AJAX call after navigating to listing page'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/47a777b4-a997-42b3-bf6b-5e8d34379b22.png)图7.15\. 导航到列表页面后成功的AJAX调用'
- en: 'We can see in *Figure 7.15* that the AJAX call to the listing API was successful
    and returned the data we wanted. If we also look at the Vue Devtools tab, as well
    as the Dev Tools console, we can see the correct data in our component instance.
    The problem is that we now have an unhandled 404 error for the header image:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图7.15*中看到，对列表API的AJAX调用成功返回了我们想要的数据。如果我们还查看Vue Devtools选项卡，以及Dev Tools控制台，我们可以看到组件实例中的正确数据。问题是，现在我们对头部图片有一个未处理的404错误：
- en: '![](assets/99a48262-9bff-432f-8679-3a846aca5295.png)Figure 7.16\. Dev Tools
    console showing error'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/99a48262-9bff-432f-8679-3a846aca5295.png)图7.16\. Dev Tools控制台显示错误'
- en: The reason for this is that the component's first render occurs *before* the
    callback in the `next` hook is called. This means that the initialization values
    for the component data are used in the first render.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是组件的第一次渲染发生在`next`钩子中的回调之前。这意味着组件数据的初始化值在第一次渲染中被使用。
- en: '`resources/assets/components/ListingPage.vue`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingPage.vue`：'
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the `HeaderImage` declaration, we bind the first image like this: `:image-url="images[0]"`.
    Since the array is initially empty, this will be an undefined value and results
    in the unhandled error.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HeaderImage`声明中，我们像这样绑定第一个图像：`:image-url="images[0]"`。由于数组最初是空的，这将是一个未定义的值，并导致未处理的错误。
- en: 'The explanation is complex, but the fix is easy: just add a `v-if` to `header-image`,
    ensuring it won''t render until valid data is available.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 解释很复杂，但修复很简单：只需在`header-image`中添加`v-if`，确保在有效数据可用之前不会渲染。
- en: '`resources/assets/components/ListingPage.vue`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingPage.vue`：'
- en: '[PRE52]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Scroll behavior
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滚动行为
- en: Another aspect of website navigation that the browser automatically manages
    is *scroll behavior*. For example, if you scroll to the bottom of a page, then
    navigate to a new page, the scroll position is reset. But if you return to the
    previous page, the scroll position is remembered by the browser, and you're taken
    back to the bottom.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 网站导航的另一个方面是浏览器自动管理的*滚动行为*。例如，如果您滚动到页面底部，然后导航到新页面，滚动位置将被重置。但是，如果您返回到上一个页面，浏览器会记住滚动位置，并将您带回底部。
- en: 'The browser can''t do this when we''ve hijacked navigation with Vue Router.
    So, when you scroll to the bottom of the Vuebnb home page and click a listing
    in Cuba, let''s say, the scroll position is unchanged when the listing page component
    is loaded. This feels really unnatural to the user, who would expect to be taken
    to the top of the new page:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Vue Router劫持导航时，浏览器无法做到这一点。因此，当您滚动到Vuebnb主页的底部并点击古巴的某个列表时，当加载列表页面组件时，滚动位置不会改变。这对用户来说感觉非常不自然，用户期望被带到新页面的顶部：
- en: '![](assets/19966550-9244-468a-b9fa-2115b5b294bf.png)Figure 7.17\. Scroll position
    issue after navigating with Vue Router'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17。使用Vue Router导航后的滚动位置问题
- en: Vue Router has a `scrollbehavior` method that allows you to adjust where the
    page is scrolled when you change routes by simply defining the `x` and `y` positions
    of the horizontal and vertical scroll bars. To keep it simple, and yet to still
    keep the UX natural, let's make it so we are always at the top of the page when
    a new page is loaded.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Vue Router有一个`scrollbehavior`方法，允许您通过简单地定义水平和垂直滚动条的`x`和`y`位置来调整页面在更改路由时滚动到的位置。为了保持简单，但仍然保持用户体验自然，让我们使得在加载新页面时总是在页面顶部。
- en: '`resources/assets/js/router.js`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/router.js`：'
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Adding a footer
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加页脚
- en: 'To improve the design of Vuebnb, let''s add a footer to the bottom of each
    page. We''ll make it a reusable component, so let''s begin by creating that:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进Vuebnb的设计，让我们在每个页面的底部添加一个页脚。我们将把它做成一个可重用的组件，所以让我们从创建它开始：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here is the markup. For now, it's just a stateless component.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是标记。目前，它只是一个无状态的组件。
- en: '`resources/assets/js/CustomFooter.vue`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/CustomFooter.vue`：'
- en: '[PRE55]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Let's add the footer to the `App` component, just below the `RouterView` where
    the pages are output.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将页脚添加到`App`组件中，在输出页面的`RouterView`下方。
- en: '`resources/assets/js/App.vue`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/App.vue`：'
- en: '[PRE56]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here''s how it looks on the listing page:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它在列表页面上的样子：
- en: '![](assets/468a31ff-2de5-4199-8290-f4dc7e2085a3.png)Figure 7.18\. Custom footer
    on listing page'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18。列表页面上的自定义页脚
- en: 'Now here''s how it looks on the home page. It doesn''t look as good because
    the text is not aligned left as you''d expect. This is because the container constraints
    used on this page are different to the `.container` class we''ve added to the
    footer:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它在主页上的样子。它看起来不太好，因为文本没有左对齐，这不是您期望的。这是因为在这个页面上使用的容器约束与我们添加到页脚的`.container`类不同：
- en: '![](assets/83c646d8-8f4f-493b-a19c-7376abe3cb57.png)Figure 7.19\. Custom footer
    on home page'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19。主页上的自定义页脚
- en: In fact, `.container` was specifically designed for the listing page, while `.home-container` was
    designed for the home page. To fix this, and to make things less confusing, let's
    firstly rename the `.container` class to `.listing-container`. You'll also need
    to update the `ListingPage` component to ensure it's using this new class name.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`.container`是专门为列表页面设计的，而`.home-container`是为主页设计的。为了解决这个问题，让事情变得不那么混乱，让我们首先将`.container`类重命名为`.listing-container`。您还需要更新`ListingPage`组件，以确保它使用这个新的类名。
- en: Secondly, let's move `.home-container` to the main CSS file as well, since we'll
    start to use it globally as well.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，让我们也将`.home-container`移到主CSS文件中，因为我们将全局使用它。
- en: '`resources/assets/css/style.css`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/css/style.css`：'
- en: '[PRE57]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now we have `.home-container` and `.listing-container` as two possible containers
    for our `custom-footer` component. Let's dynamically select the class depending
    on the route, so the footer is always correctly aligned.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有`.home-container`和`.listing-container`作为我们`custom-footer`组件的两个可能的容器。让我们根据路由动态选择类，以便页脚始终正确对齐。
- en: The route object
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由对象
- en: 'The *route object* represents the state of the currently active route and can
    be accessed inside the root instance, or a component instance, as `this.$route`.
    This object contains parsed information of the current URL and the route records
    matched by the URL:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*路由对象*代表当前活动路由的状态，并可以在根实例或组件实例中访问，如`this.$route`。该对象包含当前URL的解析信息以及URL匹配的路由记录：'
- en: '[PRE58]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Dynamically selecting the container class
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态选择容器类
- en: In order to select the correct container class in `custom-footer`, we can get
    the name of the current route from the route object, and use that in a template
    literal.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`custom-footer`中选择正确的容器类，我们可以从路由对象中获取当前路由的名称，并在模板文字中使用它。
- en: '`resources/assets/components/CustomFooter.vue`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/CustomFooter.vue`：'
- en: '[PRE59]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now the footer will use `.home-container` when displayed on the home page:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当在主页上显示时，页脚将使用`.home-container`：
- en: '![](assets/efd60af9-5efc-4b8d-9c39-dd6e099f6ea5.png)Figure 7.20\. Custom footer
    on home page with the correct container class'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20。主页上的自定义页脚与正确的容器类
- en: Listing summary image slider
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表摘要图像滑块
- en: On our home page, we need to make it so that a user can see more than just three
    of the possible 10 listings for each country. To do this, we will turn each listing
    summary group into an image slider.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主页上，我们需要让用户能够看到每个国家的可能10个列表中不止三个。为此，我们将每个列表摘要组转换为图像滑块。
- en: 'Let''s create a new component to house each listing summary group. We''ll then
    add arrowheads to the sides of this component, allowing the user to easily step
    through its listings:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的组件来容纳每个列表摘要组。然后我们将箭头添加到该组件的两侧，让用户可以轻松地浏览其列表：
- en: '[PRE60]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We'll now abstract the markup and logic for displaying listing summaries from `HomePage` into
    this new component. Each group will need to know the name of the country and the
    included listings, so we'll add this data as props.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从`HomePage`中将显示列表摘要的标记和逻辑抽象到这个新组件中。每个组需要知道国家的名称和包含的列表，因此我们将这些数据添加为props。
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSummaryGroup.vue`：'
- en: '[PRE61]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Back in the `HomePage`, we will declare the `ListingSummaryGroup` with a `v-for`,
    iterating over each country group.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`HomePage`，我们将使用`v-for`声明`ListingSummaryGroup`，对每个国家组进行迭代。
- en: '`resources/assets/components/HomePage.vue`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/HomePage.vue`:'
- en: '[PRE62]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Most developers will use the terms *image carousel*and *image slider*interchangeably.
    In this book, I make a slight distinction, a *carousel* contains a single image
    that gets completely switched out with another, while a *slider* shifts the position
    of images, with several visible at once.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发人员会将术语*图像轮播*和*图像滑块*互换使用。在本书中，我做了一个细微的区分，*轮播*包含一个完全被另一个替换的单个图像，而*滑块*则是移动图像的位置，同时可见几个图像。
- en: Adding the slider
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加滑块
- en: We'll now add the slider functionality to `ListingSummaryGroup`. To do this,
    we'll reuse the `CarouselControl` component we made back in [Chapter 6](c3b31042-0e33-40d8-ad31-d048ccf7082d.xhtml), *Composing
    Widgets with Vue.js Components*. We'll want to display one on either side of the
    group, so let's put them into the template, remembering to declare the `dir`attribute.
    We'll also add some structural markup and CSS for displaying the controls.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为`ListingSummaryGroup`添加滑块功能。为此，我们将重用我们在[第6章](c3b31042-0e33-40d8-ad31-d048ccf7082d.xhtml)中制作的`CarouselControl`组件，*使用Vue.js组件组合小部件*。我们希望在组的两侧显示一个，所以让我们将它们放入模板中，记得声明`dir`属性。我们还将添加一些结构标记和CSS来显示控件。
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSummaryGroup.vue`:'
- en: '[PRE63]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'After adding this code, your home page will look like this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了这段代码后，您的主页将如下所示：
- en: '![](assets/0c9de4a0-ed44-4cdf-882d-947ab738a935.png)Figure 7.21\. Carousel
    controls on listing summary groups'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21\. 列表摘要组的轮播控件
- en: Translate
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平移
- en: In order to *shift* our listing summaries in response to the carousel controls
    being clicked, we will use a CSS transform called `translate`. This moves an affected
    element from its current position by an amount specified in pixels.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在点击轮播控件时*移动*我们的列表摘要，我们将使用一个名为`translate`的CSS变换。这将使受影响的元素从当前位置移动指定像素的距离。
- en: 'The total width of each listing summary is 365px (350px fixed width plus 15px
    margin). This means if we move our group to the left by 365px, it will give the
    effect of shifting the position of all images by one. You can see here I''ve added
    the translate as inline styling to test if it works. Note that we `translate`
    in a *negative* direction to get the group to move to the left:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 每个列表摘要的总宽度为365px（350px固定宽度加上15px边距）。这意味着如果我们将我们的组向左移动365px，它将产生将所有图像位置向左移动一个的效果。您可以在这里看到我已经添加了平移作为内联样式以测试它是否有效。请注意，我们以*负*方向进行平移以使组向左移动：
- en: '![](assets/a7557439-4548-4a23-b2ff-86f078053d9a.png)Figure 7.22\. Listing group
    shifted to the left by using translate'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22\. 使用平移向左移动的列表组
- en: By binding inline style to the element with the `listing-summary` class, we
    can control the translate from JavaScript. Let's do this via a computed property
    so we can calculate the translate amount dynamically.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将内联样式绑定到具有`listing-summary`类的元素，我们可以通过JavaScript控制平移。让我们通过一个计算属性来做到这一点，这样我们就可以动态计算平移量。
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSummaryGroup.vue`:'
- en: '[PRE64]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now all of our summary groups will be shifted:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的摘要组都将被移动：
- en: '![](assets/07cfeef2-c95f-4f4b-9939-85058fb8b98f.png)Figure 7.23\. Shifted listing
    groups with translate controlled by JavaScript'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.23\. 通过JavaScript控制的平移后的列表组
- en: The problem evident in *Figure 7.23* is that we can only see three images at
    once and that they're overflowing out of the container into the other parts of
    the page.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.23*中显而易见的问题是，我们一次只能看到三张图像，并且它们溢出到容器的其他部分。'
- en: 'To fix this, we''ll move the CSS rule `overflow: hidden` from `listing-summaries` to `listing-summaries-wrapper`.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '为了解决这个问题，我们将把CSS规则`overflow: hidden`从`listing-summaries`移到`listing-summaries-wrapper`。'
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSummaryGroup.vue`:'
- en: '[PRE65]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Carousel controls
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮播控件
- en: We now need the carousel controls to change the value of the translate. To do
    so, let's add a data property, `offset`, to `ListingSummaryGroup`. This will track
    how many images we've shifted along, that is, it will start at zero, and go up
    to a maximum of seven (not 10 because we don't want to shift so far along that
    all of the images are off-screen).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要轮播控件来改变平移的值。为此，让我们在`ListingSummaryGroup`中添加一个数据属性`offset`。这将跟踪我们移动了多少图像，即它将从零开始，最多到七（不是10，因为我们不希望移动得太远，以至于所有图像都超出屏幕）。
- en: We'll also add a method `change`, which will serve as an event handling function
    for the custom event that the carousel control components emit. This method accepts
    one argument, `val`, which will either be `-1` or `1`, depending on whether the
    left or right carousel control was triggered.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个名为`change`的方法，它将作为自定义事件的事件处理函数，该事件由轮播控件组件发出。该方法接受一个参数`val`，根据触发了左侧还是右侧轮播控件，它将是`-1`或`1`。
- en: '`change` will step the value of `offset`, which is then multiplied by the width
    of each listing (365px) to calculate the translate.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`change`将步进`offset`的值，然后乘以每个列表的宽度（365px）来计算平移。'
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSummaryGroup.vue`:'
- en: '[PRE66]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Lastly, we must use a `v-on` directive in the template to register a listener
    for the `change-image` event of the `CarouselControl` components.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须在模板中使用`v-on`指令来注册对`CarouselControl`组件的`change-image`事件的监听器。
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSummaryGroup.vue`:'
- en: '[PRE67]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: With that done, we have a working image slider for each listing group!
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，每个列表组都有一个工作中的图像滑块！
- en: Finishing touches
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的修饰
- en: There are two more small features to add to these image sliders to give Vuebnb
    users the best possible experience. Firstly, let's add a CSS transition to animate
    the translate change over a period of half a second and give a nice *sliding*
    effect.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个小功能要添加到这些图像滑块中，以给Vuebnb用户最佳体验。首先，让我们添加CSS过渡，以在半秒钟的时间内动画平移变化，并产生一个漂亮的*滑动*效果。
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSummaryGroup.vue`:'
- en: '[PRE69]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Sadly you can't see the effects of this in a book, so you'll have to try it
    for yourself!
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是你无法在书中看到这些效果，所以你得自己尝试一下！
- en: Finally, unlike our image carousel, these sliders are not continuous; they have
    a minimum and maximum value. Let's hide the appropriate arrow if that minimum
    or maximum is reached. For example, when the sliders load, the left arrow should
    be hidden because the user cannot decrement the offset further below zero.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与我们的图像轮播不同，这些滑块不是连续的；它们有一个最小值和最大值。如果达到了最小值或最大值，让我们隐藏相应的箭头。例如，当滑块加载时，左箭头应该被隐藏，因为用户不能再减小偏移量到零以下。
- en: 'To do this, we''ll use style bindings to dynamically add a `visibility: hidden` CSS
    rule.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '为了做到这一点，我们将使用样式绑定动态添加`visibility: hidden`的CSS规则。'
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSummaryGroup.vue`：'
- en: '[PRE70]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: And the computed properties.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 以及计算属性。
- en: '`resources/assets/components/ListingSummaryGroup.vue`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSummaryGroup.vue`：'
- en: '[PRE71]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'With that done, we can see the left arrow is hidden when the page loads, as
    expected:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以看到左箭头在页面加载时隐藏，正如预期的那样：
- en: '![](assets/6797f901-bc01-4b74-bf89-cc6e085eaa9a.png)Figure 7.24\. Hidden left
    arrow on page load'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6797f901-bc01-4b74-bf89-cc6e085eaa9a.png)图7.24。页面加载时隐藏的左箭头'
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how router libraries work and why they are a crucial
    addition to SPAs. We then got familiar with the key features of Vue Router including
    the route object, navigation guards, and the `RouterLink` and `RouterView` special
    components.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了路由库的工作原理以及它们为单页应用程序的重要性。然后我们熟悉了Vue Router的关键特性，包括路由对象、导航守卫以及`RouterLink`和`RouterView`特殊组件。
- en: Putting this knowledge into practice, we installed Vue Router and configured
    it for use in our app. We then built a home page for Vuebnb, including a gallery
    of listing summaries organized within image sliders.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些知识付诸实践，我们安装了Vue Router并配置了它以在我们的应用程序中使用。然后我们为Vuebnb建立了一个主页，其中包括一个在图像滑块内组织的列表摘要画廊。
- en: Finally, we implemented an architecture for correctly matching pages with either
    available local data or new data retrieved from the web service via AJAX.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了一个架构，正确匹配页面与可用的本地数据或通过AJAX从Web服务检索到的新数据。
- en: 'Now that we have a substantial number of components in our app, many of which
    communicate data between one another, it''s time to investigate another key Vue.js
    tool: Vuex. Vuex is a Flux-based library that offers a superior way of managing
    application state.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序中有大量的组件，其中许多组件之间进行数据通信，是时候调查另一个关键的Vue.js工具了：Vuex。Vuex是一个基于Flux的库，提供了一种更优越的管理应用程序状态的方式。
