# 第九章。将域逻辑提取到事务中

在上一章中，我们将所有 SQL 语句提取到了*网关*对象的一层。这样封装了应用程序与数据库之间的交互。

然而，我们通常需要对从数据库获取的数据应用一定数量的业务或域逻辑，以及返回数据库。逻辑可以包括数据验证，添加或修改值以用于演示或计算目的，将更简单的记录收集到更复杂的记录中，使用数据执行相关操作等。这种域逻辑通常嵌入到页面脚本中，使得该逻辑难以重用和测试。

本章描述了将域行为提取到单独层的一种方法。在许多方面，本章构成了本书的核心：到目前为止，一切都导致了我们对遗留应用程序的这一核心关注点，而之后的一切将引导我们进入这个核心功能周围和上面的层。

### 注意

**域还是模型？**

遗留应用程序中的域逻辑是模型-视图-控制器中的模型部分。然而，遗留代码库不太可能有提供业务域的完整模型的单独实体对象。因此，在本章中，我们将讨论域逻辑而不是模型逻辑。如果我们足够幸运已经有了单独的模型对象，那就更好了。

# 嵌入式域逻辑

尽管我们已经提取了 SQL 语句，页面脚本和类可能正在操作结果并执行与检索数据相关的其他操作。这些操作和动作是域逻辑的核心，目前它们与其他非域关注点一起嵌入。

我们可以通过查看附录 B 中的代码，*网关之前的代码*和附录 C 中的代码，*网关之后的代码*，来看到从嵌入式 SQL 到使用*网关*类的进展。这里的代码太长，无法在此处呈现。我们要注意的是，即使在提取嵌入式 SQL 语句之后，代码仍然在将结果呈现给用户之前对传入和传出的数据进行了大量处理。

将域逻辑嵌入页面脚本中使得难以独立测试该逻辑。我们也无法轻松地重用它。如果我们想要搜索在如何处理域实体（在本例中是一系列文章）方面的重复和重复，我们需要审查整个应用程序中的每个页面脚本。

这里的解决方案是将域逻辑提取到一个或多个类中，以便我们可以独立于任何特定页面脚本对它们进行测试。然后我们可以实例化域逻辑类并在任何我们喜欢的页面脚本中使用它们。

在应用该解决方案之前，我们需要确定如何为我们的域逻辑结构目标类。 

## 域逻辑模式

Martin Fowler 的**企业应用架构模式**（**PoEAA**）目录了四种域逻辑模式：

+   **事务脚本**：它主要将[域]逻辑组织为单个过程，直接调用数据库或通过一个薄的数据库包装器。每个事务都将有自己的事务脚本，尽管常见的子任务可以分解为子过程。

+   **域模型**：它创建了一组相互连接的对象，其中每个对象代表一些有意义的个体，无论是像公司那样大，还是像订单表上的一行那样小。

+   **表模块**：它使用数据库中每个表一个类的方式组织域逻辑，并且一个类的单个实例包含将对数据进行操作的各种过程，如果你有很多订单，域模型将每个订单一个订单对象，而表模块将有一个对象来处理所有订单。

+   **服务层**：它从客户端层的接口角度定义了应用程序的边界和可用操作集。它封装了应用程序的业务逻辑，在实现其操作时控制事务并协调响应。

### 注意

我强烈建议购买 PoEAA 的纸质版，并完整阅读模式描述和示例。这本书对专业程序员来说是一个绝对必备的参考书。我发现自己每周都要查阅它（有时更频繁），它总是能提供清晰和洞察力。

现在我们面临的选择是：鉴于我们遗留应用程序的现有结构，哪种模式最适合当前的架构？

在这一点上，我们将放弃服务层，因为它暗示着一个在我们遗留应用程序中可能不存在的复杂程度。同样，我们也将放弃领域模型，因为它暗示着一个封装行为的良好设计的业务实体对象集。如果遗留应用程序已经实现了这些模式中的一个，那就更好了。否则，这就只剩下表模块和交易脚本模式了。

在上一章中，当我们将 SQL 语句提取到`Gateway`类中时，这些`Gateway`类很可能遵循了表数据网关模式，特别是如果它们足够简单，只与每个`Gateway`类交互一个表。这使得表模块模式似乎是我们领域逻辑的一个很好的选择。

然而，剩下的每个页面脚本或嵌入领域逻辑的类可能不太可能一次只与一个表交互。更频繁地，遗留应用程序在一个类或脚本中跨多个表有许多交互。因此，当我们提取领域逻辑时，我们将首先使用交易脚本模式。

交易脚本无可否认是一种简单的模式。通过它，我们将领域逻辑从页面脚本中提取出来，基本完整地转移到一个类方法中。我们只对逻辑进行修改，以便将数据正确地输入和输出到类方法中，以便原始代码仍然能够正常运行。

尽管我们可能希望有比交易脚本更复杂的东西，但我们必须记住，我们在这里的目标之一是尽量避免对现有逻辑进行太大的改变。我们是重构，而不是重写。我们现在想要的是将代码移动到适当的位置，以便进行适当的测试和重用。因此，交易脚本可能是包装我们遗留的领域逻辑的最佳方式，就像它存在的那样，而不是我们希望它成为的样子。

一旦我们将领域逻辑提取到自己的层中，我们就能更清晰地看到这个逻辑，减少干扰。在那时，如果真的需要的话，我们可以开始计划将领域层重构为更复杂的东西。例如，我们可以构建一个使用表模块或领域模型来协调各种领域交互的服务层。服务层向页面脚本呈现的接口可能与交易脚本接口完全保持不变，尽管底层架构可能已经完全改变。但这是另一天的任务。

### 注意

**活动记录呢？**

Ruby on Rails 以使用活动记录模式而闻名，许多 PHP 开发人员喜欢这种数据库交互方式。它确实有其优势。然而，Fowler 将活动记录分类为数据源架构模式，而不是领域逻辑模式，因此我们不会在这里讨论它。

# 提取过程

在本书中描述的重构过程中，提取领域逻辑将是最困难、耗时和细节导向的。这是一件非常艰难的事情，需要非常小心和注意。领域逻辑是我们遗留应用程序的核心，我们需要确保只提取出正确的部分。这意味着成功完全取决于我们对现有遗留应用程序的熟悉程度和能力。

幸运的是，我们之前对现代化遗留代码库的练习已经让我们对整个应用程序有了广泛的了解，以及对我们必须提取和重构的特定部分有了深入的了解。这应该让我们有信心成功完成这项任务。这是一项要求很高，但最终令人满意的活动。

一般来说，我们按照以下步骤进行：

1.  搜索整个代码库，查找存在于“交易”类之外的“网关”类的使用情况。

1.  在发现“网关”使用的地方，检查围绕“网关”操作的逻辑，以发现该逻辑的哪些部分与应用程序的领域行为相关。

1.  提取相关的领域逻辑到一个或多个与领域元素相关的“交易”类中，并修改原始代码以使用“交易”类而不是嵌入的领域逻辑。

1.  抽查以确保原始代码仍然正常工作，并根据需要修改提取的逻辑以确保正确运行。

1.  为提取的“交易”逻辑编写测试，并随着测试代码的完善而完善测试，直到测试通过。

1.  当所有原始测试和新测试都通过时，提交代码和测试，推送到公共存储库，并通知质量保证部门。

1.  再次搜索“网关”类的使用情况，并继续提取领域逻辑，直到“网关”的使用仅存在于“交易”中。

## 搜索“网关”的使用情况

与早期章节一样，我们使用项目范围的搜索功能来查找我们创建“网关”类实例的位置：

搜索：

```php
**new .*Gateway**

```

新的“网关”实例可能直接在页面脚本中使用，这种情况下我们已经找到了一些候选代码来提取领域逻辑。如果“网关”实例被注入到一个类中，我们现在需要深入到该类中找到“网关”的使用位置。围绕该使用的代码将成为我们提取领域逻辑的候选代码。

### 发现和提取相关的领域逻辑

### 提示

在将逻辑提取到类方法时，我们应该小心遵循我们在之前章节中学到的关于依赖注入的所有经验教训。除其他事项外，这意味着：不使用全局变量，用“请求”对象替换超全局变量，不在“工厂”类之外使用`new`关键字，以及（当然）根据需要通过构造函数注入对象。

在使用“网关”找到一些候选代码之后，我们需要检查围绕“网关”使用的代码，以进行这些和其他操作：

+   数据的规范化、过滤、清理和验证

+   数据的计算、修改、创建和操作

+   使用数据进行顺序或并发操作和动作

+   保留来自这些操作和动作的成功/失败/警告/通知消息

+   保留值和变量以供以后的输入和输出

这些和其他逻辑片段很可能与领域相关。

要成功地将领域逻辑提取到一个或多个“交易”类和方法中，我们将不得不执行这些和其他活动：

+   分解或重新组织提取的领域逻辑以支持方法

+   分解或重新组织原始代码以包装新的“交易”调用

+   保留、返回或报告原始代码所需的数据

+   添加、更改或删除与提取的领域逻辑相关的原始代码中的变量

+   为“交易”类和方法创建和注入依赖项

### 注意

发现和提取最好被视为学习的过程。像这样拆解遗留应用程序是一种了解应用程序构造的方式。因此，我们不应害怕多次尝试提取。如果我们的第一次尝试失败，变得丑陋，或者结果不佳，我们应该毫不内疚地放弃工作，重新开始，学到更多关于什么有效和什么无效的知识。就我个人而言，我经常在完成对领域逻辑的提取之前进行两到三次尝试。这就是修订控制系统让我们的生活变得更加轻松的地方；我们可以分阶段工作，只有在满意结果时才提交，如果需要从干净的状态重新开始，可以回滚到较早的阶段。

### 提取示例

举例来说，回想一下我们在附录 B 中开始的代码，*网关之前的代码*。在本章的前面，我们提到我们已经将嵌入的 SQL 语句提取到*ArticlesGateway*类中，最终得到了附录 C 中的代码，*网关之后的代码*。现在我们从那里转到附录 D，*事务脚本之后的代码*，在那里我们已经将领域逻辑提取到一个`ArticleTransactions`类中。

提取的领域逻辑在其完成形式中似乎并不特别复杂，但实际工作起来却非常详细。请查看附录 C 和附录 D 进行比较。我们应该找到以下内容：

+   我们发现页面脚本中执行了两个单独的事务：一个用于提交新文章，一个用于更新现有文章。依次，这些都需要在数据库中操作用户的信用计数，以及各种数据规范化和支持操作。

+   我们将相关的领域逻辑提取到了一个`ArticleTransactions`类和两个单独的方法中，一个用于创建，一个用于更新。我们为`ArticleTransactions`方法命名，以执行领域逻辑，而不是为底层技术操作的实现命名。

+   输入过滤已封装为`ArticleTransactions`类中的支持方法，以便在两个事务方法中重复使用。

+   新的`ArticleTransactions`类接收`ArticlesGateway`和`UsersGateway`依赖项来管理数据库交互，而不是直接进行 SQL 调用。

+   一些仅与领域逻辑相关的变量已从页面脚本中删除，并作为属性放入`Transactions`类中。

+   原始页面脚本中的代码已大大减少。现在它基本上是一个对象创建和注入机制，将用户输入传递到领域层，并在稍后获取数据进行输出。

+   由于领域逻辑现在被封装起来，原始代码现在无法看到`$failure`变量，因为它在整个事务过程中被修改。该代码现在必须从`ArticleTransactions`类中获取失败信息，以供稍后呈现。

提取后，我们有一个`classes/`目录结构，看起来类似以下内容。这是在我们将 SQL 提取到`Gateway`类时使用领域导向的类结构的结果：

```php
**/path/to/app/classes/**
1 Domain/
2 Articles/
3 ArticlesGateway.php
4 ArticleTransactions.php
5 Users/
6 UsersGateway.php
```

### 注意

这不一定是我们最终的重构。`ArticleTransactions`的进一步修改仍然是可能的。例如，与其注入`UsersGateway`，也许将与用户相关的各种领域逻辑提取到`UserTransactions`类中并注入可能更有意义。`Transactions`方法之间仍然存在很多重复。我们还需要更好的错误检查和条件报告在`Transactions`方法中。这些和其他重构是次要的，只有在主要提取领域逻辑之后才会更加明显和更容易处理。

### 抽查剩余的原始代码

一旦我们从原始代码中提取了一个或多个*Transactions*，我们需要确保在使用*Transactions*而不是嵌入式领域逻辑时，原始代码能够正常工作。与以前一样，我们通过运行我们预先存在的特性测试来做到这一点。如果我们没有特性测试，我们必须浏览或以其他方式调用已更改的代码。如果这些测试失败，我们会感到高兴！我们发现了提取的错误，并有机会在部署到生产之前修复它。如果“测试”通过，我们同样会感到高兴，并继续前进。

### 为提取的事务编写测试

我们现在知道原始代码可以使用新提取的*Transactions*逻辑。然而，新的类和方法需要它们自己的一套测试。与提取领域逻辑相关的一切都一样，编写这些测试可能会很详细和苛刻。逻辑可能很复杂，有很多分支和循环。我们不应该因此而放弃测试。至少，我们需要编写覆盖领域逻辑的主要情况的测试。

如果必要，我们可以重构提取的逻辑，将它们分开成更容易测试的方法。分解提取的逻辑将使我们更容易看到流程并找到重复的逻辑元素。但是，我们必须记住，我们的目标是维护现有的行为，而不是改变遗留应用程序呈现的行为。

### 提示

有关如何使提取的逻辑更具可测试性的见解和技术，请参阅 Martin Fowler 等人的*重构*（[`refactoring.com/`](http://refactoring.com/)）以及 Michael Feathers 的*与遗留代码有效地工作*（[`www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/01311`](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/01311)）。

### 再次抽查，提交，推送，通知 QA

最后，由于我们对提取的*Transactions*逻辑的测试和相关重构可能引入了一些意外的变化，我们再次使用我们的特性测试或以其他方式调用相关代码来抽查原始代码。如果这些失败，我们会感到高兴！我们发现了我们的更改并不像我们想象的那么好，我们有机会在代码和测试离我们太远之前纠正它们。

当原始代码测试和提取的*Transactions*测试都通过时，我们再次感到高兴！现在我们可以提交我们所有的新工作，将其推送到中央仓库，并通知 QA 我们的现代化代码已经准备好供他们审查。

### Do ... While

我们通过寻找在*Transactions*类之外使用的另一个*Gateway*来重新开始提取过程。我们继续提取和测试，直到所有*Gateway*调用发生在*Transactions*类内部。

## 常见问题

### 我们是在谈论 SQL 事务吗？

事务脚本一词指的是一种架构模式，并不意味着领域逻辑必须包装在 SQL 事务中。很容易混淆这两个概念。

话虽如此，牢记 SQL 事务可能有助于我们提取领域逻辑。一个有用的经验法则是，领域逻辑的各个部分应该根据它们在单个 SQL 事务中的适应程度进行拆分。假设的事务将作为一个整体提交或回滚。

这种目的的独特性将帮助我们确定领域逻辑的边界在哪里。我们实际上并没有添加 SQL 事务，只是以这种方式思考可以让我们对领域逻辑的边界有一些洞察。

### 重复的领域逻辑怎么办？

当我们将 SQL 语句提取到`Gateway`类时，有时会发现查询是相似但并非完全相同的。我们必须确定是否有办法将它们合并成一个方法。

同样，我们可能会发现我们的传统领域逻辑的某些部分已经被复制并粘贴到两个或更多的位置。当我们发现这些情况时，我们与`Gateway`类有相同的问题。这些逻辑片段是否足够相似，可以合并成一个方法，还是必须是不同的方法（甚至完全不同的`Transactions`）？

答案取决于具体情况。在某些情况下，重复的代码将是明显的逻辑复制，这意味着我们可以重用现有的`Transactions`方法。如果不是，我们需要提取到一个新的`Transactions`类或方法中。

还有一种中间路径，领域逻辑作为一个整体是不同的，但是在不同的“交易”中有相同的逻辑支持元素。在这些情况下，我们可以将支持逻辑重构为抽象基类`Transactions`类的方法，然后从中扩展新的`Transactions`。或者，我们可以将逻辑提取到一个支持类中，并将其注入到我们的`Transactions`中。

### 打印和回显是否属于领域逻辑的一部分？

我们的`Transactions`类不应该使用`print`或`echo`。领域逻辑应该只返回或保留数据。

当我们发现领域逻辑中间存在输出生成时，我们应该提取该部分，使其位于领域逻辑之外。一般来说，这意味着在`Transactions`类中收集输出，然后通过一个单独的方法返回它或使其可用。将输出生成留给表示层。

### 交易可以是一个类而不是一个方法吗？

在示例中，我们展示了*Transactions*作为与特定领域实体相关的一组方法，例如*ArticleTransactions*。与该实体相关的领域逻辑的每个部分都包装在一个类方法中。

然而，将领域逻辑分解为每个交易一个类的结构也是合理的。事实上，一些交易可能足够复杂，以至于它们确实需要它们自己的单独类。使用单个类来表示单个领域逻辑交易没有任何问题。

例如，之前的*ArticleTransactions*类可能被拆分为一个带有支持方法的抽象基类，以及为每个提取出的领域逻辑部分创建的两个具体类。每个具体类都扩展了*AbstractArticleTransaction*，如下所示：

```php
**classes/**
1 Domain/
2 Articles/
3 ArticlesGateway.php
4 Transaction/
5 AbstractArticleTransaction.php
6 SubmitNewArticleTransaction.php
7 UpdateExistingArticleTransaction.php
8 Users/
9 UsersGateway.php
```

如果我们采用每个交易一个类的方法，我们应该如何命名单个交易类上的主要方法，实际执行交易的方法？如果我们的传统代码库中已经存在主要方法的常见约定，我们应该遵守该约定。否则，我们需要选择一个一致的方法名称。个人而言，我喜欢利用`__invoke()`魔术方法来实现这个目的，但您可能希望使用`exec()`或其他适当的术语来指示我们正在执行或以其他方式执行交易。

### “Gateway”类中的领域逻辑怎么办？

当我们将 SQL 语句提取到`Gateway`类时，有可能将一些领域逻辑移入其中，而不是保留在原始位置。在我们重构工作的早期阶段，很容易混淆领域级输入过滤（确保数据符合特定领域状态）与数据库级过滤（确保数据可以安全地与数据库一起使用）。

现在我们可以更容易地区分这两者。如果我们发现我们的“网关”类中存在领域级别的逻辑，我们可能应该将其提取到我们的“交易”类中。我们需要确保相应的测试也要更新。

### 非领域类中嵌入的领域逻辑怎么办？

本章的示例显示了嵌入在页面脚本中的领域逻辑。同样可能的是，我们的类中也嵌入了领域逻辑。如果该类可以合理地被视为领域的一部分，并且仅包含与领域相关的逻辑，但未命名为领域，将该类移动到领域命名空间可能是明智的。

否则，如果该类除了领域逻辑之外还有其他责任，我们可以继续以与从页面脚本中提取逻辑相同的方式从中提取领域逻辑。提取后，原始类将需要将相关的“交易”类注入为依赖项。然后原始类应适当地调用“交易”。

# 回顾和下一步

在这一点上，我们已经将我们遗留代码库的核心，即位于我们应用程序中心的领域逻辑，提取到了自己独立且可测试的层中。这是我们现代化过程中最具挑战性的步骤，但这绝对是值得我们花费时间的。我们并没有对领域逻辑本身进行太多修改或改进。我们所做的任何更改都只是足够将数据输入到我们的新“交易”类中，然后再次用于后续使用。

在很多方面，我们所做的只是重新安排逻辑，使其能够独立地被访问。虽然领域逻辑本身可能仍然存在许多问题，但这些问题现在是*可测试*的问题。我们可以根据需要继续添加测试，以探索领域逻辑中的边缘情况。如果我们需要添加新的领域逻辑，我们可以创建或修改我们的“交易”类和方法来封装和测试该逻辑。

将领域逻辑提取到自己的层中的过程为我们进一步迭代地重构领域模型奠定了良好的基础。如果我们选择追求这一点，这种重构将引导我们走向更适合应用领域逻辑的架构。然而，该架构将取决于应用程序。有关为我们的应用程序开发良好领域模型的更多信息，请阅读 Eric Evans 的《领域驱动设计》（[`www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215`](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)）。

通过将领域逻辑提取到自己的层中，我们可以继续进行现代化过程的下一阶段。在这一点上，我们原始代码中只剩下了一些关注点。在这些关注点中，我们将下一个关注点放在呈现层上。
