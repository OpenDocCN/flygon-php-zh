- en: Chapter 3. ORM and Data Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。ORM和数据集合
- en: Collections and models are the bread and butter of everyday Magento development.
    In this chapter, we will introduce the reader to the Magento ORM system, and we
    will learn how to properly work with data collections and the EAV system. As with
    most modern systems, Magento implements an **Object Relational Mapping** (**ORM**)
    system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 集合和模型是日常Magento开发的基础。在本章中，我们将向读者介绍Magento ORM系统，并学习如何正确地处理数据集合和EAV系统。与大多数现代系统一样，Magento实现了一个**对象关系映射**（**ORM**）系统。
- en: '*Object-relational mapping (ORM, O/RM, and O/R mapping) in computer software
    is a programming technique for converting data between incompatible type systems
    in object-oriented programming languages. This creates, in effect, a "virtual
    object database" that can be used from within the programming language.*'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*对象关系映射（ORM，O/RM和O/R映射）是计算机软件中的一种编程技术，用于在面向对象的编程语言中在不兼容的类型系统之间转换数据。这实际上创建了一个可以从编程语言内部使用的“虚拟对象数据库”。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Magento Models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Magento模型
- en: Anatomy of a Magento Data Model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Magento数据模型的解剖学
- en: EAV and EAV models
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EAV和EAV模型
- en: Working with Direct SQL queries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用直接SQL查询
- en: We will also be working with several snippets of code to provide an easy framework
    to experiment and play around with Magento.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用几个代码片段来提供一个方便的框架，以便在Magento中进行实验和玩耍。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the interactive examples in this chapter assume you are working with
    either the default Magento installation inside the VagrantBox or a Magento installation
    with sample data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本章中的交互式示例假定您正在使用VagrantBox内的默认Magento安装或带有示例数据的Magento安装。
- en: 'For this purpose, I have created the **Interactive Magento Console** (**IMC**),
    which is a shell script specially created for this book and inspired by Ruby''s
    own **Interactive Ruby Console** (**IRB**). Follow these steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我创建了**交互式Magento控制台**（**IMC**），这是一个专门为本书创建的shell脚本，受Ruby自己的**交互式Ruby控制台**（**IRB**）启发。请按照以下步骤：
- en: The first thing we will need to do is to install the IMC. To do so, download
    the source files from [https://github.com/amacgregor/mdg_imc](https://github.com/amacgregor/mdg_imc)
    and extract them under your Magento test installation. The IMC is a simple Magento
    shell script that will allow us to test our code in real time.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是安装IMC。为此，请从[https://github.com/amacgregor/mdg_imc](https://github.com/amacgregor/mdg_imc)下载源文件，并将其提取到Magento测试安装下。IMC是一个简单的Magento
    shell脚本，可以让我们实时测试我们的代码。
- en: Once you extracted the script, log in to the shell of your virtualbox.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取脚本后，登录到您的虚拟机的shell。
- en: 'Next, we will need to navigate to our Magento root folder. If you are using
    the default vagrant box, the installation is already provided; the root folder
    is located under `/srv/www/ce1720/public_html/`, and we navigate to it by running
    the following command line:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要导航到我们的Magento根文件夹。如果您正在使用默认的vagrant box，安装已经提供；根文件夹位于`/srv/www/ce1720/public_html/`下，我们可以通过运行以下命令行来导航到它：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Finally, we can start the IMC by running the following command line:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过运行以下命令行来启动IMC：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If everything is installed successfully, we should see a new line starting with
    `magento >`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切安装成功，我们应该看到一行新的以`magento >`开头的内容。
- en: Magento Model Anatomy
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Magento模型解剖学
- en: 'As we learned in the previous chapter, Magento Data Models are used to manipulate
    and access the data. The model layer is divided into two fundamental types, simple
    models and EAV, where:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中学到的，Magento数据模型用于操作和访问数据。模型层分为两种基本类型，简单模型和EAV，其中：
- en: '**Simple Models**: These model implementations are simple mappings of one object
    to one table, meaning that our object attributes match each field and our table
    structure'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单模型**：这些模型实现是一个对象到一个表的简单映射，这意味着我们的对象属性与每个字段匹配，我们的表结构'
- en: '**Entity Attribute Value Models (EAV)**: These type of models are used to describe
    entities with a dynamic number of attributes'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体属性值模型（EAV）**：这种类型的模型用于描述具有动态属性数量的实体'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that it is important to clarify that not all Magento Models extend or Mage
    use the ORM. Observers are a clear example of simpler Model classes that are not
    mapped to a specific database table or entity.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，重要的是要澄清并非所有Magento模型都扩展或使用ORM。观察者是一个明显的例子，它们是不与特定数据库表或实体映射的简单模型类。
- en: 'In addition to that, each Model type is formed by the following layers:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，每种模型类型由以下层组成：
- en: '**Model class**: Here is where most of our business logic resides. Models are
    used to manipulate the data, but they don''t access it directly.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型类**：这是大部分业务逻辑所在的地方。模型用于操作数据，但不直接访问数据。'
- en: '**Resource Model class**: Resource Models are used to interact with the database
    on behalf of our models. They are in charge of the actual CRUD operations.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源模型类**：资源模型用于代表我们的模型与数据库交互。它们负责实际的CRUD操作。'
- en: '**Model Collection class**: Each Data Model has a collection class; collections
    are objects that hold a number of individual Magento Model instances.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型集合类**：每个数据模型都有一个集合类；集合是保存多个单独的Magento模型实例的对象。'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'CRUD stands for the four basic types of database operations: create, read,
    update, and delete.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD代表数据库的四种基本操作：创建、读取、更新和删除。
- en: Magento Models don't contain any logic for communicating with the database;
    they are database agnostic. Instead, this code resides in the Resource Model layer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Magento模型不包含与数据库通信的任何逻辑；它们是与数据库无关的。相反，这些代码存在于资源模型层。
- en: This gives Magento the capacity to support different types of databases and
    platforms. Although currently only MySQL is officially supported, it is entirely
    possible to write a new resource class for a new database without touching any
    of the Model logic ones.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这使Magento有能力支持不同类型的数据库和平台。尽管目前只有MySQL得到官方支持，但完全可以编写一个新的资源类来支持新的数据库，而不用触及任何模型逻辑。
- en: '![Magento Model Anatomy](graphics/3060OS_03_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Magento模型解剖](graphics/3060OS_03_01.jpg)'
- en: 'Let''s experiment now by instantiating a product object and setting some of
    its properties by following these steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过实例化一个产品对象并按照以下步骤设置一些属性来进行实验：
- en: 'Start the Magento interactive console running under your Magento staging installation
    root:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Magento交互式控制台，运行在Magento分期安装根目录下：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our first step is going to create a new product object instance by typing:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一步是通过输入来创建一个新的产品对象实例：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can confirm whether this is a blank instance of the product class by running:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令来确认这是否是产品类的空实例：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We should see the following as a successful output:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该看到以下成功的输出：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we want to know more about the class methods, we can run the following command
    line:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想了解更多关于类方法的信息，可以运行以下命令行：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will return an array with all the available methods inside the class.
    Let''s try to run the following snippet of code and modify a product price and
    name:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个包含类内所有可用方法的数组。让我们尝试运行以下代码片段并修改产品的价格和名称：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On the first line of code, we are instantiating a specific object, then we are
    proceeding to retrieve the name attribute from the object. Next, we are setting
    the price and name, and finally are saving the object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行代码中，我们实例化了一个特定的对象，然后我们继续从对象中检索名称属性。接下来，我们设置价格和名称，最后保存对象。
- en: If we open our Magento Product class `Mage_Catalog_Model_Product`, the first
    thing that we will notice is that while both `getName()` and `getPrice()` are
    defined inside our class, the `setPrice()` and `setName()` functions are not defined
    anywhere.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开我们的Magento产品类`Mage_Catalog_Model_Product`，我们会注意到虽然`getName()`和`getPrice()`都在我们的类中定义了，但是`setPrice()`和`setName()`函数却没有在任何地方定义。
- en: But why and more importantly, how is Magento magically defining each of the
    product object setter and getter methods? While `getPrice()` and `getName()` are
    indeed defined, there is no definition for any of the getter and setter methods
    for product attributes, such as color or manufacturer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为什么，更重要的是，Magento是如何神奇地定义每个产品对象的setter和getter方法的呢？虽然`getPrice()`和`getName()`确实被定义了，但是对于产品属性的任何getter和setter方法，比如颜色或制造商，都没有定义。
- en: It's magic – methods
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这是魔法-方法
- en: Well, it happens that the Magento ORM system is indeed using magic; or to be
    precise, one of the PHP's more powerful features for implementing its getters
    and setters, the `magic __call()` method. Magento methods that are used inside
    Magento are used to set, unset, check, or retrieve data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Magento ORM系统确实使用了魔术；或者更准确地说，使用了PHP更强大的特性来实现其getter和setter，即`magic __call()`方法。Magento中使用的方法用于设置、取消设置、检查或检索数据。
- en: When we try to call a method, which does not actually exist in our corresponding
    class, PHP will look into each of the parent classes for a declaration of that
    method. If we can't find the function on any of the parent classes, it will use
    its last resort and try to use a `__call()` method, and if found, Magento (or
    PHP for that matter) will call the magic method, thus passing the requested method
    name and its arguments.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试调用一个实际上在相应类中不存在的方法时，PHP将查找每个父类中是否有该方法的声明。如果我们在任何父类中找不到该函数，它将使用最后的手段并尝试使用`__call()`方法，如果找到，Magento（或者PHP）将调用魔术方法，从而传递请求的方法名和其参数。
- en: 'Now, the Product model doesn''t have a `__call()` method defined, but it gets
    one from the `Varien_Object` class from which all Magento models inherit from.
    The inheritance tree for the `Mage_Catalog_Model_Product` class is given in the
    following flowchart:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，产品模型没有定义`__call()`方法，但是它从所有Magento模型继承的`Varien_Object`类中获得了一个。`Mage_Catalog_Model_Product`类的继承树如下流程图所示：
- en: '![It''s magic – methods](graphics/3060OS_03_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![这是魔法-方法](graphics/3060OS_03_02.jpg)'
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Every Magento Model inherits from the `Varien_Object` class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Magento模型都继承自`Varien_Object`类。
- en: 'Let''s take a closer look at the `Varien_Object` class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下`Varien_Object`类：
- en: Open the file located in `magento_root/lib/Varien/Object.php`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`magento_root/lib/Varien/Object.php`中的文件。
- en: The `Varien_Object` class not only has a `__call()` method but also two deprecated
    methods, `__set()` and `__get()`; these two are replaced by the `__call()` method
    and thus are no longer used.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Varien_Object`类不仅有一个`__call()`方法，还有两个已弃用的方法，`__set()`和`__get()`；这两个方法被`__call()`方法替代，因此不再使用。'
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Inside the `__call()` method, we have a switch that will handle not only getters
    and setters but also the `unset` and `has` functions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__call()`方法内部，我们有一个switch语句，不仅处理getter和setter，还处理`unset`和`has`函数。
- en: 'If we start a debugger and follow the calls of our snippet code to the `__call()`
    method, we can see that it receives two arguments: the method name for example
    `setName()` and the arguments from the original call.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动调试器并跟踪我们的代码片段调用`__call()`方法，我们可以看到它接收两个参数：方法名，例如`setName()`，以及原始调用的参数。
- en: 'Interestingly, Magento tries to match the corresponding method type based on
    the first three letters of the method being called; this is done when the switch
    case argument calls the substring function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Magento尝试根据被调用方法的前三个字母来匹配相应的方法类型；这是在switch case参数调用substring函数时完成的：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first thing that is called inside each case is the `_underscore()` function,
    which takes as parameter anything after the first three characters in the method
    name; following our example, the argument passed would be `Name`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下调用的第一件事是`_underscore()`函数，它以方法名的前三个字符之后的任何内容作为参数；按照我们的例子，传递的参数将是`Name`。
- en: 'The `__underscore()` function returns a data key. This key is then used by
    each of the cases to manipulate the data. There are four basic data operations,
    each used on the corresponding switch case:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`__underscore()`函数返回一个数据键。然后每种情况下都使用这个键来操作数据。有四种基本的数据操作，每种操作对应一个switch case：'
- en: '`setData($parameters)`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setData($parameters)`'
- en: '`getData($parameters)`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getData($parameters)`'
- en: '`unsetData($parameters)`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsetData($parameters)`'
- en: '`isset($parameters)`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isset($parameters)`'
- en: Each of these functions will interact with the `Varien_Object` data array and
    will manipulate it accordingly. In most cases, a magic set/get method will be
    used to interact with our object attributes; only in a few exceptions where additional
    business logic is required, getters and setters will be defined. In our example,
    they are `getName()` and `getPrice()`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数中的每一个都将与`Varien_Object`数据数组交互，并相应地对其进行操作。在大多数情况下，将使用魔术set/get方法与我们的对象属性交互；只有在需要额外的业务逻辑时，才会定义getter和setter。在我们的示例中，它们是`getName()`和`getPrice()`。
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will not enter details of what the price function is actually doing, but
    it clearly illustrates that additional logic might be required for certain parts
    of the models.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍价格函数实际在做什么，但它清楚地说明了对模型的某些部分可能需要额外的逻辑。
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: On the other hand, the `getName()` getter wasn't declared because of the need
    of implementing special logic but by the need of optimizing a crucial part of
    Magento. The `Mage_Catalog_Model_Product getName()` function can be potentially
    called hundreds of times per page load and is one of the most commonly used functions
    across Magento; after all, what kind of e-commerce platform would it be if it
    was not centered around products?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`getName()`getter并不是因为需要实现特殊逻辑而声明的，而是因为需要优化Magento的一个关键部分。`Mage_Catalog_Model_Product
    getName()`函数可能在每次页面加载时被调用数百次，是Magento中最常用的函数之一；毕竟，如果它不是围绕产品中心的电子商务平台，那它会是什么样子呢？
- en: Frontend and backend alike will call the `getName()` function at one point or
    another. For example, if we load a category page with 24 products, that is, 24
    separate calls to the `getName()` function, each of these calls will look for
    a `getName()` method on each of the parent classes, and then, when we try to use
    `magic __call()` method, it will result in losing precious milliseconds.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前端和后端都会在某个时候调用`getName()`函数。例如，如果我们加载一个包含24个产品的类别页面，也就是说，`getName()`函数会被调用24次，每次调用都会在父类中寻找`getName()`方法，然后当我们尝试使用`magic
    __call()`方法时，会导致丢失宝贵的毫秒。
- en: Resource Models contain all the database-specific logic, and they instantiate
    the specific read and write adapters for their corresponding data source. Let's
    go back to our example working with products and take a look at the product Resource
    Model located at `Mage_Catalog_Model_Resource_Product`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 资源模型包含所有特定于数据库的逻辑，并为其相应的数据源实例化特定的读取和写入适配器。让我们回到我们的产品示例，并查看位于`Mage_Catalog_Model_Resource_Product`的产品资源模型。
- en: '![It''s magic – methods](graphics/3060OS_03_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![这是魔术-方法](graphics/3060OS_03_03.jpg)'
- en: 'Resource models come in two different types: Entity and MySQL4\. The latter
    being a pretty standard one-table/one-model association, while the former is far
    more complicated.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 资源模型有两种不同类型：实体和MySQL4。后者是一个相当标准的单表/单模型关联，而前者则复杂得多。
- en: EAV Model
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EAV模型
- en: EAV stands for entity, attribute, and value, it is probably the most difficult
    concept for new Magento developers to grasp. While the EAV concept is not unique
    to Magento, it is rarely implemented on modern systems, on top of that, Magento
    implementation is not a simple one.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: EAV代表实体、属性和值，这可能是新Magento开发人员难以理解的概念。虽然EAV概念并不是Magento独有的，但它在现代系统中很少实现，而且Magento的实现也并不简单。
- en: '![EAV Model](graphics/3060OS_03_04.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![EAV模型](graphics/3060OS_03_04.jpg)'
- en: What is EAV?
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是EAV？
- en: In order to understand what EAV is and what its role within Magento is, we need
    to break down it into the parts of the EAV model.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解EAV是什么以及它在Magento中的作用，我们需要将其分解为EAV模型的各个部分。
- en: '**Entity**: The entity represents the data items (objects) inside Magento products,
    customers, categories, and orders. Each entity is stored in the database with
    a unique ID.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体**：实体代表Magento产品、客户、类别和订单中的数据项（对象）。每个实体都以唯一ID存储在数据库中。'
- en: '**Attribute**: These are our object properties. Instead of having one column
    per attribute on the product table, attributes are stored on separates sets of
    tables.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：这些是我们的对象属性。与产品表上每个属性都有一列不同，属性存储在单独的表集上。'
- en: '**Value**: As the name implies, it is simply the value link to a particular
    attribute.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**：顾名思义，它只是与特定属性相关联的值链接。'
- en: This design pattern is the secret behind Magento's flexibility and power, allowing
    entities to add and remove new properties without having to do any changes to
    the code or templates.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式是Magento灵活性和强大性的秘密，允许实体添加和删除新属性，而无需对代码或模板进行任何更改。
- en: Whereas model can be seen as a vertical way of growing our database (new attributes
    add more rows), the traditional model would involve a horizontal grow pattern
    (new attributes add more columns) that would result in a schema redesign every
    time new attributes are added.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模型可以被视为增加数据库的垂直方式（新属性增加更多行），传统模型将涉及水平增长模式（新属性增加更多列），这将导致每次添加新属性时都需要对模式进行重新设计。
- en: The EAV model not only allows the fast evolution of our database, but also,
    it is more efficient, because it only works with non-empty attributes, avoiding
    the need to reserve additional space in the database for null values.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: EAV模型不仅允许我们的数据库快速发展，而且更有效，因为它只处理非空属性，避免了为null值在数据库中保留额外空间的需要。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are interested in exploring and learning more about the Magento database
    structure, I highly recommend you to visit [www.magereverse.com](http://www.magereverse.com).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣探索和了解Magento数据库结构，我强烈建议您访问[www.magereverse.com](http://www.magereverse.com)。
- en: Adding a new product attribute is as simple as going to the Magento backend
    and specifying the new attribute type, be it color, size, brand, and so on. The
    opposite is also true, because we can get rid of unused attributes on our products
    or customer models.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新产品属性就像进入Magento后端并指定新属性类型一样简单，比如颜色、尺寸、品牌等。相反的也是真的，因为我们可以在我们的产品或客户模型上摆脱未使用的属性。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on managing attributes, visit [http://www.magentocommerce.com/knowledge-base/entry/how-do-attributes-work-in-magento](http://www.magentocommerce.com/knowledge-base/entry/how-do-attributes-work-in-magento).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有关管理属性的更多信息，请访问[http://www.magentocommerce.com/knowledge-base/entry/how-do-attributes-work-in-magento](http://www.magentocommerce.com/knowledge-base/entry/how-do-attributes-work-in-magento)。
- en: 'Magento Community Edition currently has eight different types of EAV objects:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Magento社区版目前有八种不同类型的EAV对象：
- en: Customer
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户
- en: Customer address
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户地址
- en: Products
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品
- en: Product categories
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品类别
- en: Orders
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单
- en: Invoices
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发票
- en: Credit memos
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信贷备忘录
- en: Shipments
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发货
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Magento Enterprise Edition has one additional type called RMA item, which is
    part of the **Return Merchandise Authorization** (**RMA**) system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Magento企业版有一个额外的类型称为RMA项目，它是**退货授权**（RMA）系统的一部分。
- en: All this flexibility and power is not free, and there is a price to pay; implementing
    the EAV model results in having our entity data distributed on a large number
    of tables, for example, just the Product Model is distributed on around 40 different
    tables.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些灵活性和功能都是有代价的；实施EAV模型会导致我们的实体数据分布在大量的表中，例如，仅产品模型就分布在大约40个不同的表中。
- en: 'The following diagram only shows a few of the tables involved in saving the
    information of Magento products:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表仅显示了保存Magento产品信息所涉及的一些表：
- en: '![What is EAV?](graphics/3060OS_03_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![什么是EAV？](graphics/3060OS_03_05.jpg)'
- en: Another major downside of EAV is the loss of performance when retrieving large
    collections of EAV objects and an increase on the database query complexity. Since
    the data is more fragmented (stored in more tables), selecting a single record
    involves several joins.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: EAV的另一个主要缺点是在检索大量EAV对象时性能下降，数据库查询复杂性增加。由于数据更分散（存储在更多的表中），选择单个记录涉及多个连接。
- en: Let's continue using Magento products as our example and manually build the
    query for retrieving a single product.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续以Magento产品作为示例，并手动构建检索单个产品的查询。
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you have PHPMyAdmin or MySQL Workbench installed on your development environment,
    you can experiment with the following queries. Each can be downloaded from PHPMyAdmin
    ([http://www.phpmyadmin.net/](http://www.phpmyadmin.net/)) and MySQL Workbench
    ([http://www.mysql.com/products/workbench/](http://www.mysql.com/products/workbench/)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在开发环境中安装了PHPMyAdmin或MySQL Workbench，可以尝试以下查询。可以从PHPMyAdmin（[http://www.phpmyadmin.net/](http://www.phpmyadmin.net/)）和MySQL
    Workbench（[http://www.mysql.com/products/workbench/](http://www.mysql.com/products/workbench/)）下载每个查询。
- en: 'The first table that we will need to use is the `catalog_product_entity`. We
    can consider this as our main product EAV table since it contains the main entity
    records for our products:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用的第一个表是`catalog_product_entity`。我们可以将其视为我们的主要产品EAV表，因为它包含了我们产品的主要实体记录：
- en: '![What is EAV?](graphics/3060OS_03_06_revised.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![什么是EAV？](graphics/3060OS_03_06_revised.jpg)'
- en: 'Let''s query the table by running the following SQL query:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下SQL查询来查询表：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The table contains the following fields:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该表包含以下字段：
- en: '`entity_id`: This is our product unique identifier and is used internally by
    Magento.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entity_id`：这是我们产品的唯一标识符，由Magento在内部使用。'
- en: '`entity_type_id`: Magento has several different types of EAV models, products,
    customers, and orders, and these are just some of them. Identifying each by type
    allows Magento to retrieve the attributes and values from the appropriate tables.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entity_type_id`：Magento有几种不同类型的EAV模型，产品、客户和订单，这些只是其中一些。通过类型标识，Magento可以从适当的表中检索属性和值。'
- en: '`attribute_set_id`: Products attributes can be grouped locally into attribute
    sets. Attribute sets allow even further flexibility on the product structure since
    products are not forced to use all available attributes.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attribute_set_id`：产品属性可以在本地分组到属性集中。属性集允许对产品结构进行更灵活的设置，因为产品不需要使用所有可用的属性。'
- en: '`type_id`: There are several different types of products in Magento: simple,
    configurable, bundled, downloadable, and grouped products, each with unique settings
    and functionality.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type_id`：Magento中有几种不同类型的产品：简单、可配置、捆绑、可下载和分组产品，每种产品都具有独特的设置和功能。'
- en: '`sku`: **Stock Keeping Unit** (**SKU**) is a number or code used to identify
    each unique product or item for sale in a store. This is a user-defined value.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sku`：**库存保留单位**（SKU）是用于标识商店中每个唯一产品或商品的编号或代码。这是用户定义的值。'
- en: '`has_options`: This is used to identify if a product has custom options.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`has_options`：这用于标识产品是否具有自定义选项。'
- en: '`required_options`: This is used to identify if any of the custom options are
    required.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required_options`：这用于标识是否需要任何自定义选项。'
- en: '`created_at`: This is a row creation date.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created_at`：这是行创建日期。'
- en: '`updated_at`: This shows the last time the row was modified.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updated_at`：显示行上次修改的时间。'
- en: Now we have a basic understanding of the product entity table, and we also know
    that each record represents a single product in our Magento store, but we don't
    have much information about that product beyond the SKU and the product type.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对产品实体表有了基本的了解，我们也知道每条记录代表着我们Magento商店中的一个产品，但是我们对该产品的信息并不多，除了SKU和产品类型之外。
- en: So, where are the attributes stored? And how does Magento know the difference
    between a product attribute and a customer attribute?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，属性存储在哪里？Magento如何区分产品属性和客户属性？
- en: 'For that, we need to take a look at the `eav_attribute` table by running the
    following SQL query:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要通过运行以下SQL查询来查看`eav_attribute`表：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As a result, we will not only see the product attributes but also attributes
    corresponding to the customer model, order model, and so on. Fortunately, we already
    have a key for filtering the attributes from this table. Let''s run the following
    query:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不仅会看到产品属性，还会看到与客户模型、订单模型等对应的属性。幸运的是，我们已经有一个用于从该表中过滤属性的关键。让我们运行以下查询：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This query is telling the database to only retrieve the attributes where the
    `entity_type_id` columns are equal to the product `entity_type_id(4)`. Before
    moving on, let''s analyze the most important fields inside the `eav_attribute`
    table:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询告诉数据库只检索`entity_type_id`列等于产品`entity_type_id(4)`的属性。在继续之前，让我们分析`eav_attribute`表中最重要的字段：
- en: '`attribute_id`: This is the unique identifier for each attribute and primary
    key of the table.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attribute_id`: 这是每个属性的唯一标识符和表的主键。'
- en: '`entity_type_id`: This field relates each attribute to a specific EAV model
    type.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entity_type_id`: 这个字段将每个属性关联到特定的EAV模型类型。'
- en: '`attribute_code`: This field is the name or key of our attribute and is used
    to generate the getters and setters for our magic methods.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attribute_code`: 这个字段是我们属性的名称或键，用于生成我们的魔术方法的getter和setter。'
- en: '`backend_model`: The backend model manages loading and storing data into the
    database.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backend_model`: 后端模型负责加载和存储数据到数据库中。'
- en: '`backend_type`: This field specifies the type of value stored into the backend
    (database).'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backend_type`: 这个字段指定存储在后端（数据库）的值的类型。'
- en: '`backend_table`: This field is used to specify if the attribute should be stored
    on a special table instead of the default EAV tables.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backend_table`: 这个字段用于指定属性是否应该存储在特殊表中，而不是默认的EAV表中。'
- en: '`frontend_model`: The frontend model handles the rendering of the attribute
    element into a web browser.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frontend_model`: 前端模型处理属性元素在web浏览器中的呈现。'
- en: '`frontend_input`: Similar to the frontend model, the frontend input specifies
    the type of input field the web browser should render.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frontend_input`: 类似于前端模型，前端输入指定web浏览器应该呈现的输入字段类型。'
- en: '`frontend_label`: This field is the label/name of the attribute as it should
    be rendered by the browser.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frontend_label`: 这个字段是属性的标签/名称，应该由浏览器呈现。'
- en: '`source_model`: The source models are used to populate an attribute with possible
    values. Magento comes with several predefined source models for countries, yes
    or no values, regions, and so on.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source_model`: 源模型用于为属性填充可能的值。Magento带有几个预定义的源模型，用于国家、是或否值、地区等。'
- en: Retrieving the data
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索数据
- en: At this point, we have successfully retrieved a product entity and the specific
    attributes that apply to that entity, and now it is time to start retrieving the
    actual values. In order to simply execute the example (and the query), we will
    only try to retrieve the name attribute of our products.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经成功检索了一个产品实体和适用于该实体的特定属性，现在是时候开始检索实际的值了。为了简单执行示例（和查询），我们将尝试只检索我们产品的名称属性。
- en: 'But how do we know on which table our attribute values are stored? Well, thankfully,
    Magento is following a naming convention for naming the tables. If we inspect
    our database structure, we will notice that there are several tables using the
    `catalog_product_entity` prefix:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们如何知道我们的属性值存储在哪个表中？幸运的是，Magento遵循了一种命名约定来命名表。如果我们检查我们的数据库结构，我们会注意到有几个表使用`catalog_product_entity`前缀：
- en: '`catalog_product_entity`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity`'
- en: '`catalog_product_entity_datetime`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_datetime`'
- en: '`catalog_product_entity_decimal`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_decimal`'
- en: '`catalog_product_entity_int`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_int`'
- en: '`catalog_product_entity_text`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_text`'
- en: '`catalog_product_entity_varchar`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_varchar`'
- en: '`catalog_product_entity_gallery`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_gallery`'
- en: '`catalog_product_entity_media_gallery`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_media_gallery`'
- en: '`catalog_product_entity_tier_price`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_tier_price`'
- en: But, wait, how do we know which is the right table to query for our name attribute
    values? If you were paying attention, we've already seen the answer. Do you remember
    that the `eav_attribute` table had a column called `backend_type`?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，等等，我们如何知道查询我们名称属性值的正确表？如果你在关注，我们已经看到了答案。你还记得`eav_attribute`表有一个叫做`backend_type`的列吗？
- en: 'Magento EAV stores each attribute on a different table based on the backend
    type of that attribute. If we want to confirm the backend type of our name, we
    can do so by running the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Magento EAV根据属性的后端类型将每个属性存储在不同的表中。如果我们想确认我们的名称的后端类型，可以通过运行以下代码来实现：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And we should see, as a result, that the backend type is `varchar` and that
    the values for this attribute are stored in the `catalog_product_entity_varchar`
    table. Let''s inspect this table:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 并且我们应该看到，后端类型是`varchar`，这个属性的值存储在`catalog_product_entity_varchar`表中。让我们检查这个表：
- en: '![Retrieving the data](graphics/3060OS_03_07.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![检索数据](graphics/3060OS_03_07.jpg)'
- en: 'The `catalog_product_entity_varchar` table is formed by only six columns:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_varchar`表只由六列组成：'
- en: '`value_id`: The attribute value is the unique identifier and a primary key'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value_id`: 属性值是唯一标识符和主键'
- en: '`entity_type_id`: This value belongs to the entity type ID'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entity_type_id`: 这个值属于实体类型ID'
- en: '`attribute_id`: This is a foreign key that relates the value with our `eav_entity`
    table'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attribute_id`: 这是一个外键，将值与我们的`eav_entity`表关联起来'
- en: '`store_id`: This is a foreign key matching an attribute value with a storeview'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store_id`: 这是一个外键，将属性值与storeview进行匹配'
- en: '`entity_id`: This is a foreign key to the corresponding entity table; in this
    case, it is `catalog_product_entity`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entity_id`: 这是对应实体表的外键；在这种情况下，它是`catalog_product_entity`'
- en: '`value`: This is the actual value that we want to retrieve'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`: 这是我们要检索的实际值'
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Depending on the attribute configuration, we can have it as a global value,
    meaning it applies across all store views or a value per storeview.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 根据属性配置，我们可以将其作为全局值，表示它适用于所有storeview，或者作为每个storeview的值。
- en: 'Now that we finally have all the tables that we need to retrieve the product
    information, we can build our query:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于有了检索产品信息所需的所有表，我们可以构建我们的查询：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Retrieving the data](graphics/3060OS_03_08.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![检索数据](graphics/3060OS_03_08.jpg)'
- en: 'As result of our query, we should see a result set with three columns: `product_id`,
    `product_name`, and `product_sku`. So, let''s step back for a second in order
    to get product names with SKUs. With raw SQL, we would have to write a five-line
    SQL query, and we would only be retrieving two values from our products: from
    one single EAV value table if we wanted to retrieve a numeric field, such as price,
    or from a text value, such as product.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 作为查询结果，我们应该看到一个包含三列的结果集：`product_id`，`product_name`和`product_sku`。因此，让我们退后一步，以便获取产品名称和SKU。使用原始SQL，我们将不得不编写一个五行的SQL查询，我们只能从我们的产品中检索两个值：如果我们想要检索数字字段，比如价格，或者从文本值，比如产品，我们只能从一个单一的EAV值表中检索。
- en: If we didn't have an ORM in place, maintaining Magento would be almost impossible.
    Fortunately, we do have an ORM in place, and most likely, you will never need
    to deal with raw SQL for working with Magento.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有ORM，维护Magento几乎是不可能的。幸运的是，我们有一个ORM，并且很可能你永远不需要处理Magento的原始SQL。
- en: 'That said, let''s see how can we retrieve the same product information by using
    the Magento ORM:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，让我们看看如何使用Magento ORM来检索相同的产品信息：
- en: 'Our first step is going to instantiate a product collection:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一步是实例化一个产品集合：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we will specifically tell Magento to select the name attribute:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将明确告诉Magento选择名称属性：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now sort the collection by name:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在按名称对集合进行排序：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And, finally, we will tell Magento to load the collection:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将告诉Magento加载集合：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The end result is a collection of all products in the store sorted by name;
    we can inspect the actual SQL query by running:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终结果是商店中所有产品的集合按名称排序；我们可以通过运行以下命令来检查实际的SQL查询：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With the help of only three lines of code, we are able to tell Magento to grab
    all the products in the store to specifically select the name, and finally, order
    the products by the name.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅通过三行代码的帮助，我们就能告诉Magento抓取商店中的所有产品，具体选择名称，并最终按名称排序产品。
- en: Tip
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The last line, `$collection->getSelect()->__toString()`, allows us to see the
    actual query that Magento is executing on our behalf.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行`$collection->getSelect()->__toString()`，允许我们查看Magento代表我们执行的实际查询。
- en: 'The actual query being generated by Magento is:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Magento生成的实际查询是：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we can see, the ORM and the EAV models are wonderful tools that not only
    put a lot of power and flexibility on hands of the developers, but they also do
    it in a way that is comprehensive and easy to use.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，ORM和EAV模型是非常棒的工具，不仅为开发人员提供了很多功能和灵活性，而且还以一种全面易用的方式实现了这一点。
- en: Working with Magento collections
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Magento集合
- en: If you look back to the previous code example, you might notice that we've not
    only instantiated a Product model, but also we've called the `getCollection()`
    method. The `getCollection()` method is part of the `Mage_Core_Model_Abstract`
    class, meaning that every single model inside Magento can call this method.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回顾前面的代码示例，您可能会注意到我们不仅实例化了一个产品模型，还调用了`getCollection()`方法。`getCollection()`方法是`Mage_Core_Model_Abstract`类的一部分，这意味着Magento中的每个单个模型都可以调用此方法。
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: All collections inherit from `Varien_Data_Collection`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集合都继承自`Varien_Data_Collection`。
- en: A Magento collection is basically a model that contains other models. So, instead
    of using an array for holding a collection of products, we could use a Product
    collection instead. Collections not only provide a convenient data structure for
    grouping models but also provide special methods that we can use to manipulate
    and work with collection of entities.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Magento集合基本上是包含其他模型的模型。因此，我们可以使用产品集合而不是使用数组来保存产品集合。集合不仅提供了一个方便的数据结构来对模型进行分组，还提供了特殊的方法，我们可以用来操作和处理实体的集合。
- en: 'Some of the most useful collection methods are:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最有用的集合方法是：
- en: '`addAttributeToSelect`: To add an attribute to entities in a collection, `*`
    can be used as a wildcard to add all available attributes'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addAttributeToSelect`：要向集合中的实体添加属性，可以使用`*`作为通配符来添加所有可用的属性'
- en: '`addFieldToFilter`: To add an attribute filter to a collection, this function
    is used on regular, non-EAV models'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addFieldToFilter`：要向集合添加属性过滤器，需要在常规的非EAV模型上使用此函数'
- en: '`addAttributeToFilter`: This method is used to filter a collection of EAV entities'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addAttributeToFilter`：此方法用于过滤EAV实体的集合'
- en: '`addAttributeToSort`: This method is used to add an attribute to sort order'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addAttributeToSort`：此方法用于添加属性以排序顺序'
- en: '`addStoreFilter`: This method is used to store an availability filter; it includes
    the availability product'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addStoreFilter`：此方法用于存储可用性过滤器；它包括可用性产品'
- en: '`addWebsiteFilter`: This method is used to add a website filter to a collection'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addWebsiteFilter`：此方法用于向集合添加网站过滤器'
- en: '`addCategoryFilter`: This method is used to specify a category filter for a
    product collection'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addCategoryFilter`：此方法用于为产品集合指定类别过滤器'
- en: '`addUrlRewrite`: This method is used to add URL rewrites data to a product'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addUrlRewrite`：此方法用于向产品添加URL重写数据'
- en: '`setOrder`: This method is used to set the sorting order of a collection'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setOrder`：此方法用于设置集合的排序顺序'
- en: Those are just a few of the collection methods available; each collection implements
    different unique methods depending on the entity type they correspond to. For
    example, the customer collection `Mage_Customer_Model_Resource_Customer_Collection`
    has a unique method called `groupByEmail()` , which has the name that correctly
    implies and groups the entities inside of a collection by e-mail.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是一些可用的集合方法；每个集合实现了不同的独特方法，具体取决于它们对应的实体类型。例如，客户集合`Mage_Customer_Model_Resource_Customer_Collection`有一个称为`groupByEmail()`的唯一方法，它的名称正确地暗示了通过电子邮件对集合中的实体进行分组。
- en: As with previous examples, we will continue working with the product models,
    and in this case, the product collection.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，我们将继续使用产品模型，并在这种情况下是产品集合。
- en: '![Working with Magento collections](graphics/3060OS_03_09.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![使用Magento集合](graphics/3060OS_03_09.jpg)'
- en: 'In order to illustrate better how we can use collection, we will be working
    on the following common product scenarios:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明我们如何使用集合，我们将处理以下常见的产品场景：
- en: Get product collection only from a specific category.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅从特定类别获取产品集合。
- en: Get new products since X date.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取自X日期以来的新产品。
- en: Get Bestseller products.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取畅销产品。
- en: Filter product collection by visibility.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按可见性过滤产品集合。
- en: Filter products without image.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤没有图片的产品。
- en: Add multiple sort orders.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加多个排序顺序。
- en: Get product collection only from a specific category
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅从特定类别获取产品集合
- en: The first thing most developers try to do when starting with Magento is to load
    a product collection with products from only a specific category, and while I
    have seen many approaches by using `addCategoryFilter()` or `addAttributeToFilter()`
    , the reality is that, for most cases, the approach is much simpler and a bit
    counter-intuitive to what we have learned so far.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发人员在开始使用Magento时尝试做的第一件事是从特定类别加载产品集合，虽然我看到过许多使用`addCategoryFilter()`或`addAttributeToFilter()`的方法，但实际上，对于大多数情况来说，这种方法要简单得多，而且有点违反我们迄今为止学到的直觉。
- en: 'The easiest way of doing it is not by getting a product collection first and
    then filtering by a category but actually instantiating our target category and
    getting the product collection from there. Let''s run the following snippet of
    code on IMC:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法不是首先获取产品集合，然后按类别进行过滤，而是实际上实例化我们的目标类别，并从那里获取产品集合。让我们在IMC上运行以下代码片段：
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can find the `getProductCollection()` method declaration inside the `Mage_Catalog_Model_Category`
    class. Let''s take a better look at this method:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Mage_Catalog_Model_Category`类中找到`getProductCollection()`方法的声明。让我们更仔细地看看这个方法：
- en: '[PRE24]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see, the function does nothing more than instantiating a Resource
    Model for the product collection, that is, setting the store to the current store
    ID and passing the current category to the `addCategoryFilter()` method.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，该函数实际上只是实例化产品集合的资源模型，即将存储设置为当前存储ID，并将当前类别传递给`addCategoryFilter()`方法。
- en: This is one of those decisions that was taken to optimize Magento performance,
    and frankly to simplify the life of the developers working with it, since in most
    cases a category is going to be available one way or the other.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了优化Magento性能而做出的决定之一，而且坦率地说，也是为了简化与之合作的开发人员的生活，因为在大多数情况下，某种方式都会提供类别。
- en: Get new products added since X date
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取自X日期以来添加的新产品
- en: 'So, now that we know how to get a product collection from a specific category,
    let''s see whether we are able to apply filters to the resulting products and
    only to the retrieved ones matching our conditions; in this particular case, we
    will request all the products that were added after December 2012\. Following
    our previous example code, we can filter our collection by product creation date
    by running the following code on IMC:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道如何从特定类别获取产品集合，让我们看看是否能够对结果产品应用过滤器，并且只对符合我们条件的检索产品进行过滤；在这种特殊情况下，我们将请求所有在2012年12月之后添加的产品。根据我们之前的示例代码，我们可以通过在IMC上运行以下代码来按产品创建日期过滤我们的集合：
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It is simple, isn''t it? We could even add an additional condition and get
    the products added between two dates. Let''s say we only want to retrieve the
    products that were created in the month of December:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，不是吗？我们甚至可以添加一个额外的条件，并获取在两个日期之间添加的产品。假设我们只想检索在12月份创建的产品：
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Magento''s `addFieldToFilter` supports the following conditions:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Magento的`addFieldToFilter`支持以下条件：
- en: '| Attribute code | SQL condition |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 属性代码 | SQL条件 |'
- en: '| --- | --- |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `eq` | `=` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `eq` | `=` |'
- en: '| `neq` | `!=` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `neq` | `!=` |'
- en: '| `like` | `LIKE` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `like` | `LIKE` |'
- en: '| `nlike` | `NOT LIKE` |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `nlike` | `NOT LIKE` |'
- en: '| `in` | `IN ()` |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `in` | `IN ()` |'
- en: '| `nin` | `NOT IN ()` |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `nin` | `NOT IN ()` |'
- en: '| `is` | `IS` |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `is` | `IS` |'
- en: '| `notnull` | `NOT NULL` |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `notnull` | `NOT NULL` |'
- en: '| `null` | `NULL` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `NULL` |'
- en: '| `moreq` | `>=` |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `moreq` | `>=` |'
- en: '| `gt` | `>` |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `gt` | `>` |'
- en: '| `lt` | `<` |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `lt` | `<` |'
- en: '| `gteq` | `>=` |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `gteq` | `>=` |'
- en: '| `lteq` | `<=` |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `lteq` | `<=` |'
- en: 'We can try other types of filters, for example, let''s use the following code
    on IMC after adding our creating date filter, so we can retrieve only visible
    products:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试其他类型的过滤器，例如，在添加了我们的创建日期过滤器后，在IMC上使用以下代码，这样我们就可以只检索可见产品：
- en: '[PRE27]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The visibility attribute is a special attribute used by products to control
    where products are shown; it has the following values:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性属性是产品用来控制产品显示位置的特殊属性；它具有以下值：
- en: '**Not visible individually**: It has a value 1'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不单独可见**：它的值为1'
- en: '**Catalog**: It has a value 2'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录**：它的值为2'
- en: '**Search**: It has a value 3'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：它的值为3'
- en: '**Catalog and Search**: It has a value 4'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录和搜索**：它的值为4'
- en: Get Bestseller products
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取畅销产品
- en: 'To try to get the Bestseller products for a specific category, we would need
    to step up our game and do a join with the `sales_order` table. Retrieving Bestseller
    products will come in handy later on for creating a special category or custom
    reporting; we can run the following code on IMC:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试获取特定类别的畅销产品，我们需要提升自己的水平，并与`sales_order`表进行连接。以后为了创建特殊类别或自定义报告，检索畅销产品将非常方便；我们可以在IMC上运行以下代码：
- en: '[PRE28]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let's analyze what's happening on the third line of our snippet. `getSelect()`
    is a method inherited directly from `Varien_Data_Collection_Db`, which returns
    the variable where the `Select` statement is stored in addition to the collections
    that provide methods for specifying a join and a group without having to write
    any SQL.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下我们片段的第三行发生了什么。`getSelect()`是直接从`Varien_Data_Collection_Db`继承的方法，它返回存储`Select`语句的变量，除了提供指定连接和分组的方法之外，还无需编写任何SQL。
- en: 'This is not the only way of adding a join to a collection. There is, in fact,
    a cleaner way of doing it by using the `joinField()` function. Let''s rewrite
    our previous code to make use of this function:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是向集合添加连接的唯一方法。实际上，有一种更干净的方法可以使用`joinField()`函数来实现。让我们重写我们之前的代码以使用这个函数：
- en: '[PRE29]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Filter product collection by visibility
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按可见性过滤产品集合
- en: 'This is extremely easy to do with the help of the `addAttributeToFilter` .
    Magento products have a system attribute called visibility, which has four possible
    number values ranging from 1 to 4\. We are interested only in showing products
    whose visibility is 4; meaning, it can be seen both in the search results and
    the catalog. Let''s run the following code in IMC:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这在使用`addAttributeToFilter`的帮助下非常容易实现。Magento产品有一个名为visibility的系统属性，它有四个可能的数字值，范围从1到4。我们只对可见性为4的产品感兴趣；也就是说，它可以在搜索结果和目录中都能看到。让我们在IMC中运行以下代码：
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If we change the visibility code, we can compare the different collections results.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更改可见性代码，我们可以比较不同的集合结果。
- en: Filter products without images
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤没有图像的产品
- en: Filtering products without images comes in handy when you are dealing with a
    third-party import system, which can sometimes be unreliable. As with everything
    we have done so far, product images are the attributes of our product.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理第三方导入系统时，过滤没有图像的产品非常方便，因为这种系统有时可能不可靠。与我们迄今为止所做的一切一样，产品图像是我们产品的属性。
- en: '[PRE31]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'By adding that extra filter, we require products to have a small image specified;
    by default, Magento has three products: image types, thumbnail, and `small_image`
    and image. These three types are used on different parts of the application. We
    could even set up a stricter rule for products if we wanted to.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加额外的过滤器，我们要求产品必须指定一个小图像；默认情况下，Magento有三种产品：图像类型，缩略图和`small_image`和图像。这三种类型在应用程序的不同部分使用。如果我们愿意，甚至可以为产品设置更严格的规则。
- en: '[PRE32]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Only products that have all the three types of images will be included in our
    collection. Try experimenting by filtering with the different image types.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 只有具有三种类型图像的产品才会包含在我们的集合中。尝试通过不同的图像类型进行过滤。
- en: Add multiple sort orders
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加多个排序顺序
- en: 'Finally, let''s take our collection and sort it first by stock status and then
    by price, from highest to lowest. In order to retrieve the stock status information,
    we will use a method unique to the stock status resource model called `addStockStatusToSelect()`,
    which will take care of generating the corresponding SQL for our collection query:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们先按库存状态排序，然后按价格从高到低排序我们的集合。为了检索库存状态信息，我们将使用一个特定于库存状态资源模型的方法`addStockStatusToSelect()`，它将负责为我们的集合查询生成相应的SQL。
- en: '[PRE33]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Inside this query, Magento will sort products by the salable status that is
    either true or false, and by price; the end result is that all the available products
    will show the first ordered ones from the most expensive to the cheapest ones,
    and then, the out-of-stock products will be shown from the most expensive to the
    cheapest.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个查询中，Magento将根据可销售状态（true或false）和价格对产品进行排序；最终结果是所有可用产品将显示从最昂贵到最便宜的产品，然后，缺货产品将显示从最昂贵到最便宜的产品。
- en: Experiment with different sort order combinations to see how Magento organizes
    and orders the product collections.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试不同的排序顺序组合，看看Magento如何组织和排序产品集合。
- en: Using Direct SQL
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用直接SQL
- en: So far, we have learned how Magento data models and the ORM system provide a
    clean and simple way to access, store, and manipulate our data. Before we jump
    right into this section, learn about the Magento database adapters, and how to
    run raw SQL queries, I feel it is important that we understand why you should
    avoid as much as possible to use what you are about to learn in this section.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了Magento数据模型和ORM系统提供了一种清晰简单的方式来访问、存储和操作我们的数据。在我们直接进入本节之前，了解Magento数据库适配器以及如何运行原始SQL查询，我觉得重要的是我们要理解为什么尽可能避免使用你即将在本节中学到的内容。
- en: Magento is an extremely complex system, and as we've also learned in the previous
    chapter, a framework is driven in part by events; just saving a product will trigger
    different events, each doing a different task. This will not happen if you decide
    to just create a query and update a product directly. So, as developers, we have
    to be extremely careful and sure whether there is a justifiable reason for going
    outside the ORM.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Magento是一个非常复杂的系统，正如我们在上一章中学到的，框架部分由事件驱动；仅仅保存一个产品就会触发不同的事件，每个事件执行不同的任务。如果你决定只创建一个查询并直接更新产品，这种情况就不会发生。因此，作为开发人员，我们必须非常小心，确保是否有正当理由去绕过ORM。
- en: That said, there are, of course, scenarios when being able to work with the
    database directly comes in extremely handy and is actually simpler than working
    with the Magento models. For example, when updating a product attribute globally
    or changing a product collection status, we could load a product collection and
    loop through each of the individual products updating and saving them. While this
    would work fine on a smaller collection, as soon we start growing and working
    with a larger dataset, our performance would start to drop and the script would
    take several seconds to execute.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，当然也有一些情况下，能够直接与数据库一起工作非常方便，实际上比使用Magento模型更简单。例如，当全局更新产品属性或更改产品集合状态时，我们可以加载产品集合并循环遍历每个单独的产品进行更新和保存。虽然这在较小的集合上可以正常工作，但一旦我们开始扩大规模并处理更大的数据集，性能就会开始下降，脚本执行需要几秒钟。
- en: On the other hand, a direct SQL query will execute much faster, usually under
    1 second, depending on the dataset size and the query being executed.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，直接的SQL查询将执行得更快，通常在1秒内，这取决于数据集的大小和正在执行的查询。
- en: Out of the box, Magento will take care of all the heavy lifting of having to
    establish a connection to the database by using the `Mage_Core_Model_Resource`
    model; Magento makes two types of connections available to us, `core_read` and
    `core_write`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Magento将负责处理与数据库建立连接的所有繁重工作，使用`Mage_Core_Model_Resource`模型；Magento为我们提供了两种类型的连接，`core_read`和`core_write`。
- en: 'Let''s start by instantiating a resource model and two connections, one for
    reading and the other for writing:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先实例化一个资源模型和两个连接，一个用于读取，另一个用于写入：
- en: '[PRE34]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Even if we are working with direct SQL queries, thanks to Magento, we don't
    have to worry about setting up the connection to the DB beyond instantiating a
    resource model and the proper type of connection.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们使用直接的SQL查询，由于Magento的存在，我们不必担心设置到数据库的连接，只需实例化一个资源模型和正确类型的连接。
- en: Reading
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读
- en: 'Let''s test our read connection by executing the following code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过执行以下代码来测试我们的读取连接：
- en: '[PRE35]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Although this query works, it will return all the products in the `catalog_product_entity`
    table. But what will happen if we try to run this same code on a Magento installation
    that uses table prefixes? Or what if Magento suddenly changes the table name in
    the next upgrade? This code is not portable or easily maintainable. Fortunately,
    the resource model provides another handy method called `getTableName()`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此查询有效，但它将返回`catalog_product_entity`表中的所有产品。但是，如果我们尝试在使用表前缀的Magento安装上运行相同的代码会发生什么？或者如果Magento在下一个升级中突然更改了表名会发生什么？这段代码不具备可移植性或易维护性。幸运的是，资源模型提供了另一个方便的方法，称为`getTableName()`。
- en: '`getTableName()` method will take a factory name as a parameter, and based
    on the configuration established by the `config.xml`, it will not only find out
    the right table but will also verify that table exists in the DB. Let''s update
    our code to use `getTableName()`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`getTableName()`方法将以工厂名称作为参数，并根据`config.xml`建立的配置，不仅会找到正确的表，还会验证该表是否存在于数据库中。让我们更新我们的代码以使用`getTableName()`：'
- en: '[PRE36]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We are also using the `fetchAll()` method. This will return all the rows of
    our query as an array, but this is not the only option available; we also have
    `fetchCol()` and `fetchOne()` at our disposal. Let''s have a look at the following
    functions:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在使用`fetchAll()`方法。这将以数组形式返回查询的所有行，但这并不是唯一的选项；我们还可以使用`fetchCol()`和`fetchOne()`。让我们看看以下函数：
- en: '`fetchAll`: This function retrieves all the rows returned by the original query'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchAll`：此函数检索原始查询返回的所有行'
- en: '`fetchOne`: This function will return only the values from the first database
    row returned by the query'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchOne`：此函数将仅返回查询返回的第一行数据库的值'
- en: '`fetchCol`: This function will return all the rows returned by the query but
    only the first rows; this is useful if you only want to retrieve a single column
    with unique identifiers such as products IDs or SKUs'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchCol`：此函数将返回查询返回的所有行，但只返回第一行；如果您只想检索具有唯一标识符的单个列，例如产品ID或SKU，这将非常有用'
- en: Writing
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写作
- en: As we've mentioned before, saving a model, be it a product, category, customer,
    and so on, in Magento can be relatively slow due to the amount of observers and
    events triggered in the backend.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，由于后端触发的观察者和事件数量，保存Magento中的模型（无论是产品、类别、客户等）可能相对较慢。
- en: 'But if we are only looking to update simple static values, updating large collections
    can be a painfully slow process if done through the Magento ORM. Let''s say, for
    example, we want to make all the products on the site out of stock. Instead of
    doing it through the Magento backend or creating a custom script that iterates
    through a collection of all the products, we can simply perform the following
    code snippet:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们只想更新简单的静态值，通过Magento ORM进行大型集合的更新可能是一个非常缓慢的过程。例如，假设我们想要使网站上的所有产品都缺货。我们可以简单地执行以下代码片段，而不是通过Magento后端进行操作或创建一个迭代所有产品集合的自定义脚本：
- en: '[PRE37]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have learned about:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了：
- en: Magento Models, their inheritance, and purpose
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Magento模型、它们的继承和目的
- en: How Magento uses resource and collection models
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Magento如何使用资源和集合模型
- en: The EAV model and its importance within Magento
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EAV模型及其在Magento中的重要性
- en: How the EAV works and the structure that is used inside the database
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EAV的工作原理和数据库内部使用的结构
- en: What the Magento ORM model is and how it is implemented
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Magento ORM模型是什么以及它是如何实现的
- en: How to work with Direct SQL and the Magento resource adapter
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用直接SQL和Magento资源适配器
- en: The chapters so far have been more theoretic than practical; this has been done
    with the intention of guiding you through the complexity of Magento and providing
    you with the tools and knowledge that you will require for the rest of the book.
    For the rest of the book, we will take a more hands-on approach and start building
    extensions incrementally, applying all the concepts we have learned so far.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，章节更多地是理论性的而不是实践性的；这是为了引导您了解Magento的复杂性，并为您提供本书其余部分所需的工具和知识。在本书的其余部分，我们将采取更加实践性的方法，逐步构建扩展，应用我们到目前为止学到的所有概念。
- en: In the next chapter, we will start getting our feet wet and develop our first
    Magento extension.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始涉足并开发我们的第一个Magento扩展。
