- en: Using Sorting Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用排序算法
- en: Sorting is one of the most used algorithms in computer programming. Even in
    our everyday life, if things are not sorted, we can have a hard time with them.
    Sorting can pave the way for faster searching or ordering of items in a collection.
    Sorting can be done in many different ways, such as in ascending order or descending
    order. Sorting can also be based on the type of data. For example, sorting a collection
    of names will require lexicographical sorting rather than numerical sorting. As
    sorting can play an important role for other data structures and their efficiencies,
    there are many different sorting algorithms available. We will explore a few of
    the most popular sorting algorithms in this chapter, along with their complexity
    and usages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 排序是计算机编程中最常用的算法之一。即使在日常生活中，如果事物没有排序，我们也会遇到困难。排序可以为集合中的项目提供更快的搜索或排序方式。排序可以以许多不同的方式进行，例如按升序或降序进行。排序也可以基于数据类型进行。例如，对名称集合进行排序将需要按字典顺序排序而不是按数字排序。由于排序对其他数据结构及其效率起着重要作用，因此有许多不同的排序算法可供选择。在本章中，我们将探讨一些最流行的排序算法，以及它们的复杂性和用途。
- en: Understanding sorting and their types
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解排序及其类型
- en: Sorting means a sorted order of the data. Often, our data is unsorted, which
    means we need a way to sort it. Usually, sorting is done by comparing different
    elements with each other and coming up with the ranking. In most cases, without
    the comparison, we cannot decide on the sorting part. After the comparison, we
    also need to swap the elements so that we can reorder them. A good sorting algorithm
    has the characteristics of making a minimum number of comparisons and swapping.
    There is also non-comparison based sorting, where no comparison is required to
    sort a list of items. We will also explore those algorithms in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 排序意味着数据的排序顺序。通常，我们的数据是未排序的，这意味着我们需要一种排序方式。通常，排序是通过将不同的元素进行比较并得出排名来完成的。在大多数情况下，如果没有比较，我们无法决定排序部分。比较之后，我们还需要交换元素，以便重新排序它们。一个好的排序算法具有最小数量的比较和交换的特点。还有一种非比较排序，它不需要比较就可以对项目列表进行排序。我们也将在本章中探讨这些算法。
- en: 'Sorting can be classified into different types based on the type of data set,
    direction, computational complexities, memory usage, space usage, and so on. Here
    are few of the sorting algorithms we will explore in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据集的类型、方向、计算复杂性、内存使用、空间使用等不同标准，排序可以分为不同类型。以下是本章中我们将探讨的一些排序算法：
- en: Bubble sort
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: Insertion sort
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入排序
- en: Selection sort
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择排序
- en: Quick sort
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速排序
- en: Merge sort
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归并排序
- en: Bucket sort
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桶排序
- en: We will keep our discussion limited to the preceding list, as they are the most
    commonly used sorting algorithms and can be grouped and classified under different
    criteria such as simple sorting, efficient sorting, distribution sorting, and
    so on. We will now explore each of the sorting functionalities, their implementations,
    and complexity analysis, along with their pros and cons. Let's get started with
    the most commonly used sorting algorithm - bubble sort.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把讨论限制在上面的列表中，因为它们是最常用的排序算法，可以根据不同的标准进行分组和分类，比如简单排序、高效排序、分布排序等等。我们现在将探讨每种排序功能、它们的实现以及复杂性分析，以及它们的优缺点。让我们从最常用的排序算法——冒泡排序开始。
- en: Understanding bubble sort
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解冒泡排序
- en: Bubble sort is the most commonly used sorting algorithm in the programming world.
    Most of the programmers start learning about sorting with this algorithm. It is
    a comparison-based sorting algorithm, which is always referred to as one of the
    most inefficient sorting algorithms. It requires maximum number of comparisons,
    and the average, and worst case complexity are the same.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序是编程世界中最常用的排序算法。大多数程序员都是从这个算法开始学习排序的。它是一种基于比较的排序算法，通常被认为是最低效的排序算法之一。它需要最大数量的比较，平均情况和最坏情况的复杂性是相同的。
- en: 'In bubble sort, each item of the list is compared with the rest of the items
    and swapped if required. This continues for each item in the list. We can sort
    either in ascending or descending order. Here is the pseudo algorithm for bubble
    sort:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在冒泡排序中，列表的每个项目都与其余项目进行比较，并在需要时进行交换。这对列表中的每个项目都会继续进行。我们可以按升序或降序进行排序。以下是冒泡排序的伪算法：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see from the preceding pseudocode, we are running one loop to ensure
    that we iterate each item of the list. The inner loop ensures that, once we point
    to an item, we are comparing the item with other items in the list. Based on our
    preference, we can swap the two items. The following image shows a single iteration
    to sort one item of the list. Let''s assume our list has the following items:
    **20** , **45** , **93** , **67** , **10** , **97** , **52** , **88** , **33**
    , **92** . For the first pass (iteration) to sort out the first item, the following
    steps will be taken:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的伪代码中可以看出，我们运行一个循环来确保迭代列表的每个项目。内部循环确保一旦我们指向一个项目，我们就会将该项目与列表中的其他项目进行比较。根据我们的偏好，我们可以交换这两个项目。以下图片显示了对列表中的一个项目进行排序的单次迭代。假设我们的列表包含以下项目：20，45，93，67，10，97，52，88，33，92。对于第一次通过（迭代）来排序第一个项目，将采取以下步骤：
- en: '![](Image00057.gif)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: （图片）
- en: If we check the preceding image, we can see that we are comparing two numbers
    and then deciding whether we are going to swap/exchange the item. The items with
    background color shows the two items we are comparing. As we can see, the first
    iteration of the outer loop causes the topmost items to be stored in the topmost
    places in the list. This will continue until we iterate through each of the items
    in the list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查上面的图片，我们可以看到我们正在比较两个数字，然后决定是否要交换/交换项目。背景颜色的项目显示了我们正在比较的两个项目。正如我们所看到的，外部循环的第一次迭代导致将最顶部的项目存储在列表中的最顶部位置。这将持续进行，直到我们迭代列表中的每个项目。
- en: Let's now implement the bubble sort algorithm using PHP.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用PHP来实现冒泡排序算法。
- en: Implementing bubble sort using PHP
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP实现冒泡排序
- en: 'Since we are assuming the unsorted number will be in a list, we can use a PHP
    array to represent the list of unsorted numbers. Since the array has both index
    and values, we can utilize the array to easily iterate through each item, based
    on position, and swap them where it is applicable. The code will look like this,
    based on our pseudocodes:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们假设未排序的数字将在一个列表中，我们可以使用PHP数组来表示未排序数字的列表。由于数组既有索引又有值，我们可以利用数组来轻松地根据位置迭代每个项目，并在适用的情况下进行交换。根据我们的伪代码，代码将如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we can see, we are using two `for` loops to iterate each item and comparing
    with the rest of the items. The swapping is done in the lines:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们使用两个`for`循环来迭代每个项目并与其余项目进行比较。交换是在以下行中完成的：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, we assigned the second value to a temporary variable named `$tmp` . Then,
    we assigned the first value to the second value and reassigned the temporary value
    to the first value. This is known as swapping two variables using a third or temporary
    variable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将第二个值分配给名为`$tmp`的临时变量。然后，我们将第一个值分配给第二个值，并重新分配临时值给第一个值。这被称为使用第三个或临时变量交换两个变量。
- en: 'We are only swapping if the first value is greater than the second value. Else,
    we are just ignoring. The comment on the right-hand side of the image shows whether
    an exchange occurred or not. If we want to sort it in a descending order (bigger
    number first), then we can just modify the `if` condition as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在第一个值大于第二个值时才进行交换。否则，我们就忽略。图像右侧的注释显示了是否发生了交换。如果我们想按降序（较大的数字优先）对其进行排序，那么我们只需修改`if`条件如下：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s run the code as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下方式运行代码：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will produce the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, we can see that the array is sorted using the bubble sort algorithm. Now,
    let's discuss the complexity of the algorithm.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到数组使用冒泡排序算法进行了排序。现在，让我们讨论算法的复杂性。
- en: Complexity of bubble sort
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冒泡排序的复杂性
- en: 'For the first pass, in the worst case, we have to do *n-1* comparison and swapping.
    For the *n-1th* pass, in the worst case, we have to do only one comparison and
    swapping. So, if we write it step by step then we will see:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次通过，在最坏的情况下，我们必须进行*n-1*次比较和交换。对于第*n-1*次通过，在最坏的情况下，我们只需要进行一次比较和交换。因此，如果我们一步一步地写出来，我们会看到：
- en: '*Complexity = n - 1 + n - 2 + .......... + 2 + 1 = n * ( n - 1)/2 = O(n² )*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*复杂度= n - 1 + n - 2 + .......... + 2 + 1 = n * ( n - 1)/2 = O(n² )*'
- en: Thus, the complexity of bubble sort is `O(n² )` . However, there is some constant
    time required to assign a temporary variable, swapping, go through inner loops,
    and so on. We can ignore them since they are constant.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，冒泡排序的复杂度是`O(n² )`。然而，分配临时变量、交换、遍历内部循环等都需要一些常数时间。我们可以忽略它们，因为它们是常数。
- en: 'Here is the time complexity table for bubble sort, for best, average, and worst
    case scenarios:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是冒泡排序的时间复杂度表，包括最佳情况、平均情况和最坏情况：
- en: '| Best time complexity | `Ω(n)` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 最佳时间复杂度 | `Ω(n)` |'
- en: '| Worst time complexity | `O(n² )` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: 最坏时间复杂度为`O(n² )`
- en: '| Average time complexity | `Θ(n² )` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 平均时间复杂度 | `Θ(n² )` |'
- en: '| Space complexity (worst case) | `O(1)` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 空间复杂度（最坏情况） | `O(1)` |'
- en: Though the time complexity is `O(n² )` for bubble sort, we can still apply some
    improvements to reduce the number of comparison and swaps. Let's now explore those
    options. The best time is `Ω(n)` since we need at least one inner loop to run
    to find out that the array is already sorted.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管冒泡排序的时间复杂度为`O(n² )`，我们仍然可以应用一些改进来减少比较和交换的次数。现在让我们探讨这些选项。最佳时间为`Ω(n)`，因为我们至少需要一个内部循环来运行以找出数组已经排序。
- en: Improving bubble sort algorithm
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进冒泡排序算法
- en: 'One of the most important aspects of bubble sort is that, for each iteration
    in the outer loop, there will be at least one swapping. If there is no swapping,
    then the list is already sorted. We can utilize this improvement in our pseudocode
    and redefine it like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序最重要的一个方面是，对于外部循环中的每次迭代，至少会有一次交换。如果没有交换，那么列表已经排序。我们可以利用这一改进在我们的伪代码中重新定义它：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see that we now have a flag set for each iteration to be `false`
    , and we are expecting that, inside the inner iteration, the flag will be set
    to `true` . If the flag is still false after the inner loop is done, then we can
    break the loop so that we can mark the list as sorted. Here is the implementation
    of the improved version of the algorithm:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在所看到的，我们现在为每次迭代设置了一个`false`标志，并且我们期望，在内部迭代中，标志将被设置为`true`。如果在内部循环完成后标志仍然为false，则我们可以中断循环，以便标记列表为已排序。这是改进算法的实现：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another observation is that, in the first iteration, the top item is placed
    to the right of the array. In the second loop, the second top item will be in
    the second to the right of the array. If we can visualize that after each iteration,
    the *i^(th)* cell has already stored the sorted items, there is no need to visit
    that index and do a comparison. As a result, we can reduce the outer iteration
    number from the inner iteration and reduce the comparisons by a good margin. Here
    is the pseudocode for the second improvement we are proposing:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个观察是，在第一次迭代中，顶部项目被放置在数组的右侧。在第二次循环中，第二个顶部项目将位于数组的右侧第二个位置。如果我们可以想象每次迭代后，第i个单元格已经存储了已排序的项目，那么就没有必要访问该索引并进行比较。因此，我们可以减少外部迭代次数和内部迭代次数，并大幅减少比较。这是我们提出的第二个改进的伪代码：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s implement the final improved version with PHP:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用PHP实现最终改进的版本：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we look at the inner loop in the preceding code, the only difference is
    `$j < $len - $i - 1` ; other parts are the same as the first improvement. So,
    basically, for our **20** , **45** , **93** , **67** , **10** , **97** , **52**
    , **88** , **33** , **92** list, we can easily say that after the first iteration,
    the top number **97** will not be considered for second iteration comparison.
    The same goes for **93** , which will not be considered for the third iteration,
    just like the following image:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下前面代码中的内部循环，唯一的区别是 `$j < $len - $i - 1` ；其他部分与第一次改进相同。所以，基本上，对于我们的 **20**
    , **45** , **93** , **67** , **10** , **97** , **52** , **88** , **33** , **92**
    列表，我们可以很容易地说，在第一次迭代之后，顶部的数字 **97** 将不会被考虑进行第二次迭代比较。同样， **93** 也将不会被考虑进行第三次迭代，就像下面的图片一样：
- en: '![](Image00058.gif)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00058.gif)'
- en: 'If we look at the preceding image, the immediate question that strikes our
    mind is "Isn''t **92** already sorted? Do we need to again compare all numbers
    and mark that **92** is already sorted in its place?" Yes, we are right. It is
    a valid question. This means that we can know, in which position we did the last
    swap in the inner loop; after that, the array is already sorted. So, we can set
    a bound for the next loop to go, until then, and only compare until the boundary
    we set. Here is the pseudocode for this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看前面的图片，立即冒出的问题是“**92** 已经排序了吗？我们需要再次比较所有数字并标记 **92** 已经在其位置上排序了吗？”是的，我们是对的。这是一个有效的问题。这意味着我们可以知道，在内部循环中我们上次交换的位置；之后，数组已经排序。因此，我们可以为下一个循环设置一个边界，直到那时，只比较我们设置的边界之前的部分。以下是此操作的伪代码：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we are setting the bound after completion of each inner loop and making
    sure we are not iterating unnecessarily. Here is the actual PHP code using the
    preceding pseudocode:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在每次内部循环完成后设置边界，并确保我们不会进行不必要的迭代。以下是使用前面伪代码的实际PHP代码：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have seen different variations of bubble sort implementations, but the output
    will always be the same: **10** , **20** , **33** , **45** , **52** , **67** ,
    **88** , **92** , **93** , **97** . If this is the case, then how can we be sure
    that our improvements have actually had some impact on the algorithm? Here are
    some statistics on the number of comparisons for all four implementations for
    our initial list 20, 45, 93, 67, 10, 97, 52, 88, 33, 92:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了冒泡排序实现的不同变体，但输出始终相同：**10** , **20** , **33** , **45** , **52** , **67**
    , **88** , **92** , **93** , **97** 。如果是这种情况，那么我们如何确定我们的改进实际上对算法产生了一些影响呢？以下是我们的初始列表
    20, 45, 93, 67, 10, 97, 52, 88, 33, 92 的所有四种实现的比较次数的一些统计数据：
- en: '| **Solution** | **Comparison count** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **解决方案** | **比较次数** |'
- en: '| Regular bubble sort | 90 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 常规冒泡排序 | 90 |'
- en: '| After first improvement | 63 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 第一次改进后 | 63 |'
- en: '| After second improvement | 42 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 第二次改进后 | 42 |'
- en: '| After third improvement | 38 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 第三次改进后 | 38 |'
- en: As we can see, we have reduced the number of comparisons from **90** to **38**
    with our improvement. So, we can certainly boost up the algorithm with some improvements
    to reduce the number of comparisons required.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们通过改进将比较次数从 **90** 减少到 **38** 。因此，我们可以肯定地通过一些改进来提高算法，以减少所需的比较次数。
- en: Understanding selection sort
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解选择排序
- en: 'Selection sort is another comparison-based sorting algorithm, which looks similar
    to bubble sort. The biggest difference is that it takes fewer swapping than bubble
    sort. In selection sort, we first find the minimum/maximum item of the array and
    place it in the first place. If we are sorting in descending order, then we will
    take the maximum value from the array. For ascending order, we will take the minimum
    value. In the second iteration, we will find the second-most maximum or minimum
    value of the array and place it in second place. This goes on until we place each
    number into a correctly sorted position. This is known as selection sort. The
    pseudocode for selection sort looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 选择排序是另一种基于比较的排序算法，看起来类似于冒泡排序。最大的区别在于它进行的交换次数比冒泡排序少。在选择排序中，我们首先找到数组的最小/最大项，并将其放在第一个位置。如果我们按降序排序，那么我们将从数组中取得最大值。对于升序排序，我们将取得最小值。在第二次迭代中，我们将找到数组的第二大或第二小值，并将其放在第二个位置。这样一直进行，直到我们将每个数字放在正确排序的位置上。这就是选择排序。选择排序的伪代码如下所示：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we look at the preceding algorithm, we can see that, after iteration one
    in the outer loop, the first minimum item is stored in position one. During the
    first iteration, we selected the first item and then found the minimum value from
    the remaining items (from 2 to *n* ). We assumed that the first item is the minimum
    value. If we find another minimum value , we would mark its position until we
    have scanned the remaining list and found a new minimum value . If no minimum
    value is found, then our assumption is correct, and that is indeed the minimum
    value. Here is a picture illustrating our **20** , **45** , **93** , **67** ,
    **10** , **97** , **52** , **88** , **33** , **92** arrays during the first two
    steps in selection sort:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看前面的算法，我们可以看到，在外部循环的第一次迭代之后，第一个最小项被存储在位置一。在第一次迭代中，我们选择了第一项，然后从剩余项（从2到 *n*
    ）中找到最小值。我们假设第一项是最小值。如果我们找到另一个最小值，我们会标记它的位置，直到我们扫描了剩余列表并找到了一个新的最小值。如果没有找到最小值，那么我们的假设是正确的，那确实是最小值。这里是一个图示，说明了我们的
    **20** , **45** , **93** , **67** , **10** , **97** , **52** , **88** , **33**
    , **92** 数组在选择排序的前两个步骤中的情况：
- en: '![](Image00059.gif)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00059.gif)'
- en: As we can see in the preceding image, we started with the first item in the
    list, which is **20** . Then, we found the minimum value from the rest of the
    array, which is **10** . At the end of the first iteration, we just swapped the
    values from two places (marked by arrows). As a result, at the end of the first
    iteration, we have the minimum value from the array stored in the first place.
    Then, we pointed to the next item, which is **45** , and started finding the next
    smallest items compared to **45** from the right side of its position. We found
    **20** from the remaining items (as shown by two arrows). At the end of the second
    iteration, we are just swapping the second position number to the newly found
    smallest one from the remainder of the list. This continues until the last element,
    and, at the end of the process, we have a sorted list of arrays. Let's now convert
    the pseudocode into a PHP code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的图像所示，我们从列表中的第一个项目**20**开始。然后，我们从数组的其余部分找到最小值**10**。在第一次迭代结束时，我们只交换了两个位置的值（由箭头标记）。因此，在第一次迭代结束时，我们将数组的最小值存储在第一个位置。然后，我们指向下一个项目**45**，并开始从其位置右侧找到与**45**相比的下一个最小项目。我们从剩余项目中找到**20**（如两个箭头所示）。在第二次迭代结束时，我们只是将第二个位置的数字与列表剩余部分中新找到的最小数字进行交换。这将持续到最后一个元素，并且在过程结束时，我们将得到一个排序好的数组列表。现在让我们将伪代码转换为PHP代码。
- en: Implementing selection sort
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现选择排序
- en: 'We will take the same approach as the bubble sort where our implementation
    will take an array as an argument and return a sorted array. Here is the implementation
    in PHP:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用与冒泡排序相同的方法，其中我们的实现将以数组作为参数并返回一个排序好的数组。以下是PHP中的实现：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As can be seen, this is the simplest way to sort an array in ascending order.
    If you want to do it in descending order, we just need to change the comparison
    `$arr[$j] <` `$arr[$min]` to `$arr[$j] > $arr[$min]` and replace `$min` with `$max`
    .
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这是按升序对数组进行排序的最简单方法。如果要按降序排序，我们只需要将比较`$arr[$j] < $arr[$min]`更改为`$arr[$j]
    > $arr[$min]`，并将`$min`替换为`$max`。
- en: Complexity of selection sort
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择排序的复杂度
- en: 'Selection sort also looks similar to bubble sort and has two `for` loops with
    0 to *n* . The basic difference between bubble sort and selection sort is that,
    selection sort makes maximum *n-1* number of swapping, whereas bubble sort can
    have *n*n* number of swapping, in the worst case scenario. However, in the selection
    sort, the best case, worst case, and average case have similar complexity. Here
    is the complexity chart for selection sort:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 选择排序看起来也与冒泡排序相似，并且有两个0到*n*的`for`循环。冒泡排序和选择排序的基本区别在于，选择排序最多进行*n-1*次交换，而冒泡排序在最坏的情况下可能进行*n*n*次交换。然而，在选择排序中，最佳情况、最坏情况和平均情况的复杂度相似。以下是选择排序的复杂度图表：
- en: '| Best time complexity | `Ω(n² )` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 最佳时间复杂度 | `Ω(n²)` |'
- en: '| Worst time complexity | `O(n² )` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 最坏时间复杂度 | `O(n²)` |'
- en: '| Average time complexity | `Θ(n² )` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 平均时间复杂度 | `Θ(n²)` |'
- en: '| Space complexity (worst case) | `O(1)` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 空间复杂度（最坏情况） | `O(1)` |'
- en: Understanding insertion Sort
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解插入排序
- en: So far, we have seen two comparison-based sorting algorithms. Now, we will explore
    another sorting algorithm that is somewhat efficient compared to the previous
    two. We are talking about the insertion sort. It has the simplest implementation
    compared to the other two sorting algorithms we have just seen. If the number
    of items is smaller, insertion sort works better than bubble sort and selection
    sort. If the data set is large, then it becomes inefficient, like bubble sort.
    Since the swapping is almost linear for insertion sort, it is recommended that
    you use insertion sort instead of bubble sort and selection sort.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了两种基于比较的排序算法。现在，我们将探讨另一种排序算法，与前两种相比效率要高一些。我们说的是插入排序。与我们刚刚看到的另外两种排序算法相比，它的实现最简单。如果项目数量较小，插入排序比冒泡排序和选择排序效果更好。如果数据集很大，那么它就会变得效率低下，就像冒泡排序一样。由于插入排序的交换几乎是线性的，建议您使用插入排序而不是冒泡排序和选择排序。
- en: 'As the name suggests, insertion sort works on the principle of inserting the
    number to its correct place on the left-hand side. It starts from the second item
    of the array and checks whether the items that are left to it are smaller than
    the current value or not. If so, it shifts the item and stores the smaller item
    in its correct position. Then, it moves to the next item, and the same principle
    continues until the full array is sorted. The pseudocode for insertion sort looks
    like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，插入排序是根据将数字插入到左侧正确位置的原则工作的。它从数组的第二个项目开始，并检查左侧的项目是否小于当前值。如果是，它会移动项目并将较小的项目存储在其正确的位置。然后，它移动到下一个项目，并且相同的原则一直持续到整个数组排序完成。插入排序的伪代码如下：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we consider our previous list of numbers used for bubble sort and selection
    sort, then we will have the following scenario for which we must do insertion
    sort.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑我们之前用于冒泡排序和选择排序的数字列表，那么我们必须进行插入排序。
- en: 'The elements of our array were: **20** , **45** , **93** , **67** , **10**
    , **97** , **52** , **88** , **33** , **92** .'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数组的元素是：**20**，**45**，**93**，**67**，**10**，**97**，**52**，**88**，**33**，**92**。
- en: 'Let''s start with the second item, which is **45** . Now, we will start from
    the first item to the left of **45** and go to the beginning of the array to see
    whether there is a value greater than **45** on the left. As there is only **20**
    , no insertion is required as the item so far is sorted until the second element
    (**20** ,**45** ). Now, we will move our pointer to **93,** and it starts again,
    comparing left of the array starting from **45** and search if the value is bigger.
    Since **45** is not bigger than **93** , it stops there, as previously, we concluded
    that the first two items are already sorted. Now, we have the first three items
    (**20** , **45** , **93** ) sorted. Next, we have **67** , and we start again
    by comparing from the left of the numbers. The first number to the left is **93**
    , which is bigger, so it has to move one place. We move **93** to the position
    that was held by **67** . Then, we move to the next item to the left of it, which
    is **45** . **45** is smaller than **67** , and no further comparison is required.
    Now, we will insert **67** at the position that was held by **93** and **93**
    will have to be moved to **67** ''s position. This continues until the full array
    is sorted. This image illustrates the full sorting process using insertion sort
    at each step:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第二个项目开始，即**45**。现在，我们将从**45**左边的第一个项目开始，并转到数组的开头，看看左边是否有大于**45**的值。由于只有**20**，因此不需要插入，因为到目前为止的项目已经排序好了（**20**，**45**）。现在，我们将指针移动到**93**，并且再次开始，从数组的左边开始比较并搜索是否有更大的值。由于**45**不大于**93**，因此停在那里，就像之前一样，我们得出前两个项目已经排序好了的结论。现在，我们有前三个项目（**20**，**45**，**93**）排序好了。接下来是**67**，我们再次从左边的数字开始比较。左边的第一个数字是**93**，比较大，因此必须移动一个位置。我们将**93**移动到**67**的位置。然后，我们移动到左边的下一个项目，即**45**。**45**小于**67**，不需要进一步比较。现在，我们将**67**插入到**93**的位置，**93**将移动到**67**的位置。这将一直持续到整个数组排序好。这张图片说明了使用插入排序的完整排序过程的每一步：
- en: '![](Image00060.gif)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00060.gif)'
- en: Implementing insertion sort
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现插入排序
- en: 'We will implement the insertion sort in a similar way to the other two sorts
    but with a subtle difference. This time, we will pass the array as a reference.
    By doing so, we will not require any return value from the function. We can also
    pass the argument by value and return the array at the end of the function if
    we want. Here is the code for this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与其他两种排序类似的方式实现插入排序，但有细微差别。这次，我们将数组作为引用传递。通过这样做，我们将不需要从函数中返回任何值。如果需要的话，我们也可以按值传递参数并在函数结束时返回数组。以下是此代码：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The parameter array is passed to the function by reference (`&$arr` ). Thus,
    the original array, not a copy of it, will be modified directly. Now, we want
    to run the code and check the output. For this, we have to run the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 参数数组通过引用（`&$arr`）传递给函数。因此，原始数组而不是副本将直接被修改。现在，我们想要运行代码并检查输出。为此，我们必须运行以下代码：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will produce the same output we had in the previous two cases. The only
    difference is that we are not expecting any return array from the function and
    not storing it into any new variable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生与前两种情况相同的输出。唯一的区别是我们不期望从函数中返回任何数组，并且不将其存储到任何新变量中。
- en: If we pass the array by reference, then we do not have to return the array.
    The passed array will be modified inside the function. It is down to choice how
    we want to achieve the sorting.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过引用传递数组，那么我们就不需要返回数组。传递的数组将在函数内部被修改。我们可以选择如何实现排序。
- en: Complexity of insertion sort
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入排序的复杂性
- en: 'Insertion sort has a complexity similar to bubble sort. The basic difference
    with bubble sort is that the number of swapping is much lower than bubble sort.
    Here is the complexity for insertion sort:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序的复杂性类似于冒泡排序。与冒泡排序的基本区别在于交换的次数比冒泡排序要少得多。这是插入排序的复杂性：
- en: '| Best time complexity | `Ω(n)` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 最佳时间复杂度 | `Ω(n)` |'
- en: '| Worst time complexity | `O(n² )` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 最坏时间复杂度 | `O(n²)` |'
- en: '| Average time complexity | `Θ(n² )` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 平均时间复杂度 | `Θ(n²)` |'
- en: '| Space complexity (worst case) | `O(1)` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 空间复杂度（最坏情况） | `O(1)` |'
- en: Understanding divide-and-conquer technique for sorting
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解用于排序的分治技术
- en: So far, we have explored the sorting option with a full list of numbers. As
    a result, we had a big list of numbers to compare every time. This can be solved
    if we can somehow make the list smaller. The divide-and-conquer method can be
    very helpful for us. With this method, we will divide a problem into two or more
    subproblems or sets, and then solve the smaller problems before combining all
    those results from the subproblems to get the final result. This is what is known
    as divide-and-conquer.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了使用完整数字列表的排序选项。结果，我们每次都有一个大的数字列表进行比较。如果我们可以以某种方式使列表变小，这个问题就可以解决。分治法对我们非常有帮助。通过这种方法，我们将问题分解为两个或更多的子问题或集合，然后解决较小的问题，然后将所有这些子问题的结果组合起来得到最终结果。这就是所谓的分治法。
- en: The divide-and-conquer method can allow us to solve our sorting problems efficiently
    and reduce the complexity of our algorithm. Two of the most popular sorting algorithms
    are merge sort and quick sort, which apply the divide-and-conquer algorithm to
    sort a list of items, and hence, they are considered to be the best sorting algorithms.
    Now, we will explore these two algorithms in the next section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 分治法可以让我们有效地解决排序问题，并减少算法的复杂性。最流行的两种排序算法是归并排序和快速排序，它们应用分治算法来对项目列表进行排序，因此被认为是最好的排序算法。现在，我们将在下一节中探讨这两种算法。
- en: Understanding merge sort
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解归并排序
- en: 'As we already know that merge sort applies the divide-and-conquer approach
    to solve the sorting problem, we need to find out two processes to address the
    issue. The first one is to divide the problem set into smaller enough problems
    to solve easily, and then combine those results. We will apply a recursive approach
    here for the divide-and-conquer part. The following image shows how to take the
    approach for divide-and-conquer. We will now consider a smaller list of numbers
    **20** , **45** , **93** , **67** , **97** , **52** , **88** , **33** to explain
    the divide-and-conquer part:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，归并排序应用分而治之的方法来解决排序问题，我们需要找出两个过程来解决这个问题。第一个是将问题集分解成足够小的问题，然后合并这些结果。我们将在这里应用递归方法来进行分而治之。以下图像显示了如何采取分而治之的方法。我们现在将考虑一个较小的数字列表**20**，**45**，**93**，**67**，**97**，**52**，**88**，**33**来解释分而治之的部分：
- en: '![](Image00061.gif)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00061.gif)'
- en: Based on the preceding image, we can now start preparing our pseudocode, which
    will have two parts - divide and conquer. Here is the pseudocode to achieve that
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的图像，我们现在可以开始准备我们的伪代码，它将有两部分 - 分割和征服。以下是实现这一点的伪代码
- en: '`func` mergesort ( A : array of sortable items):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`func` mergesort ( A : sortable items的数组):'
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our first part of the pseudocode shows the divide process. We divided the array
    of items until it reaches the size of 1\. Then, we started to merge the results
    using the merge function. In the merge function, we had an array to store the
    merged results. Because of this, merge sort actually has more space complexity
    than the other algorithms we have seen so far. Now, let's get into coding and
    implement this pseudocode using PHP.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们伪代码的第一部分显示了分割过程。我们将数组分割直到达到大小为1的程度。然后，我们开始使用合并函数合并结果。在合并函数中，我们有一个数组来存储合并的结果。因此，归并排序实际上比我们迄今为止看到的其他算法具有更多的空间复杂度。现在，让我们开始编码并使用PHP实现这个伪代码。
- en: Implementing merge sort
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现归并排序
- en: 'We will first write the divide part followed by the merge or conquer part.
    PHP has some built-in functions to split an array. We will use the `array_slice`
    function to do the splitting. Here is the code to do this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先写出分割部分，然后是合并或征服部分。PHP有一些内置函数可以拆分数组。我们将使用`array_slice`函数来进行拆分。以下是执行此操作的代码：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As we can see from the code, we split the array in a recursive way until the
    array size becomes 1\. When array size is 1, we start to merge backward, just
    like the last image. Here is the code for the merge function, which will take
    two arrays, and merge them into one as per our pseudocode:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中可以看出，我们以递归的方式分割数组，直到数组大小变为1。当数组大小为1时，我们开始向后合并，就像最后一个图像一样。以下是合并函数的代码，它将接受两个数组，并根据我们的伪代码将它们合并成一个：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The code is now complete as we have merged the two supplied arrays and returned
    the combined results to the `mergeSort` function. We have just solved the problem
    recursively. If you run the following code, you will have a list of items in ascending
    order:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码已经完成，因为我们已经合并了两个提供的数组，并将合并的结果返回给`mergeSort`函数。我们刚刚以递归的方式解决了问题。如果你运行以下代码，你将得到一个按升序排列的项目列表：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, let's explore the complexity for merge sort.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探讨归并排序的复杂度。
- en: Complexity of merge sort
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 归并排序的复杂度
- en: 'Since merge sort follows the divide-and-conquer method, we have to address
    both complexities here. For an n-sized array, we first need to divide the array
    into two halves and then merge them to get an n-sized array. This can be written
    in terms of `T(n)` as:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于归并排序遵循分而治之的方法，我们必须在这里解决两种复杂性。对于一个大小为n的数组，我们首先需要将数组分成两半，然后合并它们以获得一个大小为n的数组。这可以用`T(n)`来表示：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So, the complexity for merge sort is `O(n log(n))` . Here is the complexity
    chart for merge sort:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，归并排序的复杂度是`O(n log(n))`。以下是归并排序的复杂度图表：
- en: '| Best time complexity | `Ω(nlog(n))` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 最佳时间复杂度 | `Ω(nlog(n))` |'
- en: '| Worst time complexity | `O(nlog(n))` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 最坏时间复杂度 | `O(nlog(n))` |'
- en: '| Average time complexity | `Θ(nlog(n))` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 平均时间复杂度 | `Θ(nlog(n))` |'
- en: '| Space complexity (worst case) | `O(n)` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 空间复杂度（最坏情况） | `O(n)` |'
- en: Understanding quick sort
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解快速排序
- en: 'Quick sort is another efficient sorting algorithm that applies the divide-and-conquer
    method. Although it does not divide into equal halves like merge sort, it creates
    dynamic partitions to sort the data. This is how quick sort works:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序是另一种应用分而治之方法的高效排序算法。虽然它不像归并排序那样均等地分割，但它创建动态分区来对数据进行排序。这就是快速排序的工作原理：
- en: Pick a random value from the array, which we will call pivot.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数组中选择一个随机值，我们称之为枢轴。
- en: Reorder the array so that the item that is smaller than the pivot goes to the
    left of it, and the items that are greater than, or equal to, the pivot go to
    the right of it. This is known as partitioning.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新排列数组，使小于枢轴的项目移到它的左边，大于或等于枢轴的项目移到它的右边。这就是分区。
- en: Recursively call *steps 1* and *2* to solve the two subarrays (left and right
    of pivot) until all items are sorted.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归调用*步骤1*和*步骤2*来解决两个子数组（枢轴的左边和右边）的问题，直到所有项目都排序完成。
- en: 'There are many ways to picking a pivot from the array. We can either choose
    the left-most item of the array or the right-most item of the array. In both cases,
    if the array is already sorted, it will take worst case complexity. Choosing a
    good pivot can improve the efficiency of the algorithm. There are some different
    ways of doing a partition. We will explain the *Hoare Partition* , which makes
    comparatively fewer swaps than other partition methods. Here is our pseudo algorithm
    for the quick sort. We will do in-place sorting so that no extra space is required:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从数组中选择一个枢轴的方法有很多种。我们可以选择数组的最左边的项目或最右边的项目。在这两种情况下，如果数组已经排序，它将达到最坏情况的复杂度。选择一个好的枢轴可以提高算法的效率。有一些不同的分区方法。我们将解释*Hoare
    Partition*，它比其他分区方法进行了更少的交换。以下是我们的快速排序的伪算法。我们将进行原地排序，因此不需要额外的空间：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We used the first item as the pivot element. We can also choose the last item
    or take a median for choosing the pivot element. Let's now implement the algorithm
    using PHP.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用第一个项目作为枢轴元素。我们也可以选择最后一个项目或取中值来选择枢轴元素。现在让我们使用PHP来实现算法。
- en: Implementing quick sort
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现快速排序
- en: 'As shown in the pseudocode, we will have two functions to implement a quick
    sort: one function to do the quick sort itself, and the other for the partitioning.
    Here is the implementation to do the quick sort:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如伪代码所示，我们将有两个函数来实现快速排序：一个函数用于执行快速排序本身，另一个用于分区。以下是执行快速排序的实现：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is the implementation to do the partitioning:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行分区的实现：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we visually illustrate the pivot and the sorting in the partitions, we can
    see the following image. For simplicity, we are only showing the steps where swapping
    took place:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在分区中直观地说明枢轴和排序，我们可以看到以下图像。为简单起见，我们只显示了发生交换的步骤：
- en: '![](Image00062.gif)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00062.gif)'
- en: Complexity of quick sort
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速排序的复杂性
- en: 'The worst case complexity of quick sort can be similar to bubble sort''s complexity.
    The selection of the pivot actually causes this. Here is the complexity chart
    for a quick sort:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序的最坏情况复杂度可能与冒泡排序的复杂度相似。实际上是由于枢轴的选择导致的。以下是快速排序的复杂性图表：
- en: '| Best time complexity | `Ω(nlog(n))` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 最佳时间复杂度 | `Ω(nlog(n))` |'
- en: '| Worst time complexity | `O(n² )` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 最坏时间复杂度 | `O(n²)` |'
- en: '| Average time complexity | `Θ(nlog(n))` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 平均时间复杂度 | `Θ(nlog(n))` |'
- en: '| Space complexity (worst case) | `O(log(n))` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 空间复杂度（最坏情况） | `O(log(n))` |'
- en: Understanding bucket sort
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解桶排序
- en: 'The bucket sort is also known as bin sort. Bucket sort is a distribution sorting
    system where array elements are placed in different buckets. Each bucket is then
    sorted individually by either another sorting algorithm, or by applying recursive
    bucket sorting. An implementation of bucket sort using PHP can look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 桶排序也被称为箱排序。桶排序是一种分布排序系统，其中数组元素被放置在不同的桶中。然后每个桶都单独排序，可以使用另一个排序算法，或者应用递归桶排序。使用PHP实现桶排序可能如下所示：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The time complexity of bucket sort is comparatively better than other comparison-based
    sorting algorithms. Here are the complexities for bucket sort:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 桶排序的时间复杂度比其他基于比较的排序算法要好。以下是桶排序的复杂性：
- en: '| Best time complexity | `Ω(n+k)` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 最佳时间复杂度 | `Ω(n+k)` |'
- en: '| Worst time complexity | `O(n² )` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 最坏时间复杂度 | `O(n²)` |'
- en: '| Average time complexity | `Θ(n+k)` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 平均时间复杂度 | `Θ(n+k)` |'
- en: '| Space complexity (worst case) | `O(n)` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 空间复杂度（最坏情况） | `O(n)` |'
- en: Using PHP's built-in sorting function
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP的内置排序函数
- en: 'PHP has a rich library of predefined functions, and that also includes different
    sorting functions. It has different functions to sort a list of items in an array
    either by value or by key/index. We can also keep the association of the array''s
    values with their respective keys while doing the sorting. Another important function
    of PHP is the built-in function for sorting a multi-dimensional array. Here is
    a summary of these functions:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: PHP具有丰富的预定义函数库，其中还包括不同的排序函数。它有不同的函数来按值或按键/索引对数组中的项目进行排序。在进行排序时，我们还可以保持数组值与其相应键的关联。PHP的另一个重要函数是用于对多维数组进行排序的内置函数。以下是这些函数的摘要：
- en: '| **Function name** | **Purpose** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **函数名称** | **目的** |'
- en: '| `sort()` | This sorts an array in ascending order. Value/key association
    is not preserved. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `sort()` | 这将按升序对数组进行排序。不保留值/键关联。 |'
- en: '| `rsort()` | Sort an array in reverse/descending order. Index/key association
    is not preserved. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `rsort()` | 按照逆序/降序对数组进行排序。不保留索引/键关联。 |'
- en: '| `asort()` | Sort an array while maintaining index association. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `asort()` | 在保持索引关联的同时对数组进行排序。 |'
- en: '| `arsort()` | Sort an array in reverse order and maintain index association.
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `arsort()` | 以逆序排序数组并保持索引关联。 |'
- en: '| `ksort()` | Sort an array by key. It maintains key to data correlations.
    This is useful mainly for associative arrays. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `ksort()` | 按键对数组进行排序。它保持键与数据的关联。这主要适用于关联数组。 |'
- en: '| `krsort()` | Sort an array by key in reverse order. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `krsort()` | 按键以逆序排序数组。 |'
- en: '| `natsort()` | Sort an array using a natural order algorithm, and Value/key
    association is maintained. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `natsort()` | 使用自然顺序算法对数组进行排序，并保持值/键关联。 |'
- en: '| `natcasesort()` | Sort an array using a case insensitive "natural order"
    algorithm, and Value/key association is maintained. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `natcasesort()` | 使用不区分大小写的“自然顺序”算法对数组进行排序，并保持值/键关联。 |'
- en: '| `usort()` | Sort an array by values using a user-defined comparison function,
    and Value/Key association is not maintained.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '| `usort()` | 使用用户定义的比较函数按值对数组进行排序，并且不保持值/键关联。'
- en: The second parameter is a callable function for comparison. |
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个可调用的比较函数。 |
- en: '| `uksort()` | Sort an array by keys using a user-defined comparison function,
    and Value/key association is maintained.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '| `uksort()` | 使用用户定义的比较函数按键对数组进行排序，并保持值/键关联。'
- en: The second parameter is a callable function for comparison. |
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个可调用的比较函数。 |
- en: '| `uasort()` | Sort an array by values using a user-defined comparison function,
    and Value/key association is maintained.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '| `uasort()` | 使用用户定义的比较函数按值对数组进行排序，并保持值/键关联。'
- en: The second parameter is a callable function for comparison. |
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个可调用的比较函数。 |
- en: 'For `sort` , `rsort` , `ksort` , `krsort` , `asort` , and `arsort` , the following
    sorting flags are available:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`sort`，`rsort`，`ksort`，`krsort`，`asort`和`arsort`，可以使用以下排序标志：
- en: '**SORT_REGULAR** : compare items as they are (don''t change types)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SORT_REGULAR**：按原样比较项目（不更改类型）'
- en: '**SORT_NUMERIC** : compare items numerically'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SORT_NUMERIC**：按数字比较项目'
- en: '**SORT_STRING** : compare items as strings'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SORT_STRING**：将项目作为字符串进行比较'
- en: '**SORT_LOCALE_STRING** : compare items as strings, based on the current locale'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SORT_LOCALE_STRING**：根据当前区域设置将项目作为字符串进行比较'
- en: '**SORT_NATURAL** : compare items as strings using "natural ordering"'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SORT_NATURAL**：使用“自然顺序”将项目比较为字符串'
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about different sorting algorithms. Sorting is
    an integral part of our development process, and knowledge of different sorting
    algorithms and their complexity will help us decide the best choice for sorting
    algorithms based on our problem set. There are other algorithms for sorting, which
    can be found online for further study. We intentionally did not cover the heapsort
    in this chapter as we will discuss that in *Chapter 10* . In the next chapter,
    we will discuss another important topic concerning algorithms - searching.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了不同的排序算法。排序是我们开发过程中的一个重要部分，了解不同的排序算法及其复杂性将帮助我们根据问题集选择最佳的排序算法。还有其他排序算法，可以在网上找到进行进一步研究。我们故意没有在本章中涵盖堆排序，因为我们将在*第10章*中讨论。在下一章中，我们将讨论另一个关于算法的重要主题
    - 搜索。
