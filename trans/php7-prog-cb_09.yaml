- en: Chapter 9. Developing Middleware
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章. 开发中间件
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Authenticating with middleware
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中间件进行身份验证
- en: Using middleware to implement access control
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中间件实现访问控制
- en: Improving performance using the cache
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓存来提高性能
- en: Implementing routing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现路由
- en: Making inter-framework system calls
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行跨框架系统调用
- en: Using middleware to cross languages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中间件跨语言
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: As often happens in the IT industry, terms get invented, and then used and abused.
    The term **middleware** is no exception. Arguably the first use of the term came
    out of the **Internet Engineering Task Force** (**IETF**) in the year 2000\. Originally,
    the term was applied to any software which operates between the transport (that
    is, TCP/IP) and the application layer. More recently, especially with the acceptance
    of **PHP Standard Recommendation number 7** (**PSR-7**), middleware, specifically
    in the PHP world, has been applied to the web client-server environment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IT 行业中经常发生的情况是，术语被创造出来，然后被使用和滥用。术语**中间件**也不例外。可以说，这个术语最早是在 2000 年由**互联网工程任务组**（**IETF**）提出的。最初，这个术语是用于指代在传输层（即
    TCP/IP）和应用层之间运行的任何软件。最近，特别是随着**PHP 标准推荐编号 7**（**PSR-7**）的接受，中间件，特别是在 PHP 世界中，已经被应用到了
    Web 客户端-服务器环境中。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The recipes in this section will make use of the concrete classes defined in
    [Appendix](apa.html "Appendix A. Defining PSR-7 Classes"), *Defining PSR-7 Classes*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的配方将使用[附录](apa.html "附录 A. 定义 PSR-7 类")中定义的具体类，*定义 PSR-7 类*。
- en: Authenticating with middleware
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用中间件进行身份验证
- en: One very important usage of middleware is to provide authentication. Most web-based
    applications need the ability to verify a visitor via username and password. By
    incorporating PSR-7 standards into an authentication class, you will make it generically
    useful across the board, so to speak, being secure enough that it can be used
    in any framework that provides PSR-7-compliant request and response objects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件的一个非常重要的用途是提供身份验证。大多数基于 Web 的应用程序都需要通过用户名和密码验证访问者的能力。通过将 PSR-7 标准纳入身份验证类，您将使其在各个方面都具有通用性，可以说是足够安全，可以在提供
    PSR-7 兼容请求和响应对象的任何框架中使用。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'We begin by defining an `Application\Acl\AuthenticateInterface` class. We use
    this interface to support the Adapter software design pattern, making our `Authenticate`
    class more generically useful by allowing a variety of adapters, each of which
    can draw authentication from a different source (for example, from a file, using
    OAuth2, and so on). Note the use of the PHP 7 ability to define the return value
    data type:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个 `Application\Acl\AuthenticateInterface` 类。我们使用这个接口来支持适配器软件设计模式，通过允许各种适配器，使我们的
    `Authenticate` 类更具通用性，每个适配器都可以从不同的来源（例如，从文件中，使用 OAuth2 等）获取身份验证。请注意使用 PHP 7 定义返回值数据类型的能力：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that by defining a method that requires a PSR-7-compliant request, and
    produces a PSR-7-compliant response, we have made this interface universally applicable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过定义一个需要符合 PSR-7 的请求并生成符合 PSR-7 的响应的方法，我们使得此接口具有普遍适用性。
- en: 'Next, we define the adapter that implements the `login()` method required by
    the interface. We make sure to use the appropriate classes, and define fitting
    constants and properties. The constructor makes use of `Application\Database\Connection`,
    defined in [Chapter 5](ch05.html "Chapter 5. Interacting with a Database"), *Interacting
    with a Database*:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义实现接口所需的 `login()` 方法的适配器。我们确保使用适当的类，并定义适合的常量和属性。构造函数使用在[第 5 章](ch05.html
    "第 5 章. 与数据库交互")中定义的 `Application\Database\Connection`：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The core `login()` method extracts the username and password from the request
    object. We then do a straightforward database lookup. If there is a match, we
    store user information in the response body, JSON-encoded:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 核心 `login()` 方法从请求对象中提取用户名和密码。然后我们进行直接的数据库查找。如果匹配成功，我们将用户信息存储在响应主体中，以 JSON 编码：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Never store passwords in clear text. When you need to do a password match, use
    `password_verify()`, which negates the need to reproduce the password hash.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要以明文形式存储密码。当您需要进行密码匹配时，请使用 `password_verify()`，这样就不需要再生成密码哈希。
- en: 'The `Authenticate` class is a wrapper for an adapter class that implements
    `AuthenticationInterface`. Accordingly, the constructor takes an adapter class
    as an argument, as well as a string that serves as the key, in which authentication
    information is stored in `$_SESSION`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Authenticate` 类是一个实现 `AuthenticationInterface` 的适配器类的包装器。因此，构造函数接受一个适配器类作为参数，以及一个字符串作为密钥，在其中身份验证信息存储在
    `$_SESSION` 中：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In addition, we provide a login form with a security token, which helps prevent
    **Cross Site Request Forgery** (**CSRF**) attacks:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们提供了一个带有安全令牌的登录表单，可以帮助防止**跨站点请求伪造**（**CSRF**）攻击：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, the `login()` method in this class checks whether the token is valid.
    If not, a 400 response is returned. Otherwise, the `login()` method of the adapter
    is called:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，此类中的 `login()` 方法将检查令牌是否有效。如果无效，则返回 400 响应。否则，调用适配器的 `login()` 方法：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'First of all, be sure to follow the recipes defined in [Appendix](apa.html
    "Appendix A. Defining PSR-7 Classes"), *Defining PSR-7 Classes*. Next, go ahead
    and define the classes presented in this recipe, summarized in the following table:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请确保遵循[附录](apa.html "附录 A. 定义 PSR-7 类")中定义的配方。接下来，继续定义本配方中介绍的类，总结如下表所示：
- en: '| Class | Discussed in these steps |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 在这些步骤中讨论 |'
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Application\Acl\AuthenticateInterface` | 1 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Acl\AuthenticateInterface` | 1 |'
- en: '| `Application\Acl\DbTable` | 2 - 3 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Acl\DbTable` | 2 - 3 |'
- en: '| `Application\Acl\Authenticate` | 4 - 6 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Acl\Authenticate` | 4 - 6 |'
- en: 'You can then define a `chap_09_middleware_authenticate.php` calling program
    that sets up autoloading and uses the appropriate classes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以定义一个 `chap_09_middleware_authenticate.php` 调用程序，设置自动加载并使用适当的类：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You are now in a position to set up the authentication adapter and core class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以设置身份验证适配器和核心类了：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Be sure to initialize the incoming request, and set up the request to be made
    to the authentication class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 确保初始化传入请求，并设置要发送到身份验证类的请求：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Check the incoming class method to see if it is `POST`. If so, pass a request
    to the authentication class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 检查传入的类方法是否为`POST`。如果是，将请求传递给身份验证类：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The display logic looks like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 显示逻辑如下：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is the output from an invalid authentication attempt. Notice the `401`
    status code on the right. In this illustration, you could add a `var_dump()` of
    the response object:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个无效身份验证尝试的输出。请注意右侧的`401`状态代码。在这个示例中，您可以添加对响应对象的`var_dump()`：
- en: '![How it works...](graphics/B05314_09_05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_09_05.jpg)'
- en: 'Here is a successful authentication:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个成功的身份验证：
- en: '![How it works...](graphics/B05314_09_06.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_09_06.jpg)'
- en: See also
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For guidance on how to avoid CSRF and other attacks, please see [Chapter 12](ch12.html
    "Chapter 12. Improving Web Security"), *Improving Web Security*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何避免CSRF和其他攻击的指导，请参阅[第12章](ch12.html "第12章。提高Web安全性") *提高Web安全性*。
- en: Using middleware to implement access control
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用中间件实现访问控制
- en: As the name implies, middleware sits in the middle of a sequence of function
    or method calls. Accordingly, middleware is well suited for the task of "gate
    keeper". You can easily implement an **Access Control List** (**ACL**) mechanism
    with a middleware class that reads the ACL, and allows or denies access to the
    next function or method call in the sequence.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，中间件位于一系列函数或方法调用的中间。因此，中间件非常适合“门卫”的任务。您可以使用一个中间件类轻松实现**访问控制列表**（**ACL**）机制，该类读取ACL并允许或拒绝对序列中下一个函数或方法调用的访问。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Probably the most difficult part of the process is determining which factors
    to include in the ACL. For the purposes of illustration, let''s say that our users
    are all assigned a `level` and a `status`. In this illustration, the level is
    defined as follows:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个过程中可能最困难的部分是确定ACL中要包括哪些因素。为了说明，假设我们的用户都被分配了一个`level`和一个`status`。在这个示例中，level的定义如下：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The status could indicate how far they are in the membership signup process.
    For example, a status of `0` could indicate they've initiated the membership signup
    process, but have not yet been confirmed. A status of `1` could indicate their
    e-mail address is confirmed, but they have not paid the monthly fee, and so on.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态可能表示他们在会员注册过程中的进展。例如，状态为`0`可能表示他们已启动会员注册过程，但尚未确认。状态为`1`可能表示他们的电子邮件地址已确认，但他们尚未支付月费，依此类推。
- en: 'Next, we need to define the resources we plan to control. In this case, we
    will assume there is a need to control access to a series of web pages on the
    site. Accordingly, we need to define an array of such resources. In the ACL, we
    can then refer to the key:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义我们计划控制的资源。在这种情况下，我们将假设有必要控制对站点上一系列网页的访问。因此，我们需要定义一个这样的资源数组。在ACL中，我们可以引用键：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, the most important piece of configuration is to make assignments to
    pages according to `level` and `status`. The generic template used in the configuration
    array might look like this:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，最重要的配置部分是根据`level`和`status`对页面进行分配。配置数组中使用的通用模板可能如下所示：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we are in a position to define the `Acl` class. As before, we use a few
    classes, and define constants and properties appropriate for access control:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以定义`Acl`类了。与以前一样，我们使用了一些类，并定义了适用于访问控制的常量和属性：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `__construct()` method, we break up the assignments array into `$pages`,
    the resources to be controlled, `$levels`, and `$allowed`, which are the actual
    assignments. If the array does not include one of these three sub-components,
    an exception is thrown:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__construct()`方法中，我们将分配数组分解为`$pages`（要控制的资源）、`$levels`和`$allowed`（实际分配）。如果数组不包括这三个子组件中的一个，就会抛出异常：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You may have noticed that we allow inheritance. In `$allowed`, the `inherits`
    key can be set to another key within the array. If so, we need to merge its values
    with the values currently under examination. We iterate through `$allowed` in
    reverse, merging any inherited values each time through the loop. This method,
    incidentally, also only isolates rules that apply to a certain `status` and `level`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们允许继承。在`$allowed`中，`inherits`键可以设置为数组中的另一个键。如果是这样，我们需要将其值与当前正在检查的值合并。我们通过反向迭代`$allowed`，每次循环都合并任何继承的值。顺便说一句，这种方法也只隔离适用于特定`status`和`level`的规则：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When processing authorization, we initialize a few variables, and then extract
    the page requested from the original request URI. If the page parameter doesn''t
    exist, we set a `400` code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理授权时，我们初始化了一些变量，然后从原始请求URI中提取了请求的页面。如果页面参数不存在，我们设置了`400`代码：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Otherwise, we decode the request body contents, and acquire the `status` and
    `level`. We are then in a position to call `mergeInherited()`, which returns an
    array of pages accessible to this `status` and `level`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们解码请求体内容，并获取`status`和`level`。然后我们可以调用`mergeInherited()`，它返回一个对此`status`和`level`可访问的页面数组：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the requested page is in the `$allowed` array, we set the status code to
    a happy `200`, and return an authorized setting along with the web page that corresponds
    to the page code requested:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果请求的页面在`$allowed`数组中，我们将状态代码设置为`200`，并返回一个授权设置，以及与请求的页面代码对应的网页：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then return the response, JSON-encoded, and we are done:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们返回响应，以JSON编码，完成：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'After that, you will need to define `Application\Acl\Acl`, which is discussed
    in this recipe. Now move to the `/path/to/source/for/this/chapter` folder and
    create two directories: `public` and `pages`. In `pages`, create a series of PHP
    files, such as `page1.php`, `page2.php`, and so on. Here is an example of how
    one of these pages might look:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您需要定义`Application\Acl\Acl`，这在本示例中进行了讨论。现在转到`/path/to/source/for/this/chapter`文件夹并创建两个目录：`public`和`pages`。在`pages`中，创建一系列PHP文件，例如`page1.php`，`page2.php`等。以下是其中一个页面的示例：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can also define a `menu.php` page, which could be included in the output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以定义一个`menu.php`页面，该页面可以包含在输出中：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `logout.php` page should destroy the session:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`logout.php`页面应销毁会话：'
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `auth.php` page will display a login screen (as described in the previous
    recipe):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth.php`页面将显示登录屏幕（如前一示例中所述）：'
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can then create a configuration file that allows access to web pages depending
    on level and status. For the sake of illustration, call it `chap_09_middleware_acl_config.php`
    and return an array that might look like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以创建一个配置文件，根据级别和状态允许访问网页。为了举例说明，将其命名为`chap_09_middleware_acl_config.php`并返回一个类似于以下内容的数组：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, in the `public` folder, define `index.php`, which sets up autoloading,
    and ultimately calls up both the `Authenticate` and `Acl` classes. As with other
    recipes, define configuration files, set up autoloading, and use certain classes.
    Also, don''t forget to start the session:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`public`文件夹中，定义`index.php`，该文件设置自动加载，并最终调用`Authenticate`和`Acl`类。与其他示例一样，定义配置文件，设置自动加载，并使用某些类。还要记得启动会话：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: It is a best practice to protect your sessions. An easy way to help protect
    a session is to use `session_regenerate_id()`, which invalidates the existing
    PHP session identifier and generates a new one. Thus, if an attacker were to obtain
    the session identifier through illegal means, the window of time in which any
    given session identifier is valid is kept to a minimum.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 保护会话是最佳实践。帮助保护会话的一种简单方法是使用`session_regenerate_id()`，它使现有的PHP会话标识无效并生成一个新的标识。因此，如果攻击者通过非法手段获得会话标识符，任何给定会话标识符有效的时间窗口将被最小化。
- en: 'You can now pull in the ACL configuration, and create instances for `Authenticate`
    as well as `Acl`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以拉取ACL配置，并为`Authenticate`和`Acl`创建实例：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, define incoming and outbound request instances:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义传入和传出请求实例：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the incoming request method was `post`, process the authentication calling
    the `login()` method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传入的请求方法是`post`，则调用`login()`方法处理身份验证：
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the session key defined for authentication is populated, that means the
    user has been successfully authenticated. If not, we program an anonymous function,
    called **later**, which includes the authentication login page:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为身份验证定义的会话密钥已填充，则表示用户已成功验证。如果没有，我们将编写一个名为**later**的匿名函数，其中包含身份验证登录页面：
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Otherwise, you can proceed with the ACL check. You first need to find, from
    the original query, which web page the user wants to visit, however:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您可以继续进行ACL检查。您首先需要从原始查询中找到用户想要访问的网页，但是：
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can then reprogram the `$outbound` request to include this information:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以重新编程`$outbound`请求以包含此信息：
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, you''ll be in a position to check authorization, supplying the outbound
    request as an argument:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将能够检查授权，提供传出请求作为参数：
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can then examine the return response for the `authorized` parameter, and
    program an anonymous function to include the return `page` parameter if OK, and
    the `sorry` page otherwise:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以检查`authorized`参数的返回响应，并编写匿名函数以包含返回的`page`参数（如果OK），以及否则包含`sorry`页面：
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now all you need to do is to set the form action and wrap the anonymous function
    in HTML:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您只需要设置表单操作并在HTML中包装匿名函数：
- en: '[PRE35]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To test it, you can use the built-in PHP web server, but you will need to use
    the `-t` flag to indicate that the document root is `public`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试它，您可以使用内置的PHP Web服务器，但是您需要使用`-t`标志指示文档根目录为`public`：
- en: '[PRE36]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: From a browser, you can access the `http://localhost:8080/` URL.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从浏览器中，您可以访问`http://localhost:8080/` URL。
- en: 'If you try to access any page, you will simply be redirected back to the login
    page. As per the configuration, a user with status = `1`, and level = `BEG` can
    only access page `1` and log out. If, when logged in as this user, you try to
    access page 2, here is the output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试访问任何页面，您将被重定向回登录页面。根据配置，具有状态=`1`和级别=`BEG`的用户只能访问页面`1`并注销。如果以此用户身份登录，尝试访问页面2，则输出如下：
- en: '![How it works...](graphics/B05314_09_07.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_09_07.jpg)'
- en: See also
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: This example relies on `$_SESSION` as the sole means of user authentication
    once they have logged in. For good examples of how you can protect PHP sessions,
    please see [Chapter 12](ch12.html "Chapter 12. Improving Web Security"), *Improving
    Web Security*, specifically the recipe entitled *Safeguarding the PHP session*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户登录，此示例依赖于`$_SESSION`作为用户身份验证的唯一手段。有关如何保护PHP会话的良好示例，请参见[第12章](ch12.html "第12章。提高Web安全性")*提高Web安全性*，特别是名为*保护PHP会话*的示例。
- en: Improving performance using the cache
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓存提高性能
- en: The cache software design pattern is where you store a result that takes a long
    time to generate. This could take the form of a lengthy view script or a complex
    database query. The storage destination needs to be highly performant, of course,
    if you wish to improve the user experience of website visitors. As different installations
    will have different potential storage targets, the cache mechanism lends itself
    to the adapter pattern as well. Examples of potential storage destinations include
    memory, a database, and the filesystem.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存软件设计模式是存储需要很长时间才能生成的结果的地方。这可以采用漫长的视图脚本或复杂的数据库查询的形式。当然，存储目的地需要具有高性能，如果您希望提高网站访问者的用户体验。由于不同的安装将具有不同的潜在存储目标，因此缓存机制也适用于适配器模式。潜在存储目标的示例包括内存、数据库和文件系统。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'As with a couple of other recipes in this chapter, as there are shared constants,
    we define a discreet `Application\Cache\Constants` class:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与本章中的其他一些配方一样，由于有共享的常量，我们定义了一个独立的`Application\Cache\Constants`类：
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Seeing as we are following the adapter design pattern, we define an interface
    next:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们遵循适配器设计模式，接下来我们定义一个接口：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we are ready to define our first cache adapter, in this illustration, by
    using a MySQL database. We need to define properties that will hold column names
    as well as prepared statements:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备定义我们的第一个缓存适配器，在这个示例中，我们使用MySQL数据库。我们需要定义将保存列名和准备语句的属性：
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The constructor allows us to provide key column names as well as an `Application\Database\Connection`
    instance and the name of the table used for the cache:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数允许我们提供键列名以及`Application\Database\Connection`实例和用于缓存的表的名称：
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The next few methods prepare statements, and are called when we access the
    database. We do not show all the methods, but present enough to give you the idea:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的几个方法准备语句，并在访问数据库时调用。我们没有展示所有的方法，但呈现足够的内容来给你一个想法：
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we define a method that determines whether data for a given key exists:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们定义一个确定给定键的数据是否存在的方法：
- en: '[PRE42]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The core methods are ones that read from and write to the cache. Here is the
    method that retrieves from the cache. All we need to do is to execute the prepared
    statement, which performs a `SELECT`, with a `WHERE` clause, which incorporates
    the key and group:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 核心方法是从缓存中读取和写入的方法。这是从缓存中检索的方法。我们只需要执行准备好的语句，执行`SELECT`，带有`WHERE`子句，其中包括键和组：
- en: '[PRE43]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When writing to the cache, we first determine whether an entry for this cache
    key exists. If so, we perform an `UPDATE`; otherwise, we perform an `INSERT`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入缓存时，我们首先确定是否存在该缓存键的条目。如果是，我们执行“UPDATE”；否则，我们执行“INSERT”：
- en: '[PRE44]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We then define two methods that remove the cache either by key or by group.
    Removal by group provides a convenient mechanism if there are a large number of
    items that need to be deleted:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义了两种方法，通过键或组来删除缓存。通过组删除提供了一个方便的机制，如果有大量需要删除的项目：
- en: '[PRE45]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Lastly, we define getters and setters for each of the properties. Not all are
    shown here to conserve space:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为每个属性定义获取器和设置器。这里没有展示所有的内容以节省空间：
- en: '[PRE46]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The filesystem cache adapter defines the same methods as defined earlier. Note
    the use of `md5(),` not for security, but as a way of quickly generating a text
    string from the key:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件系统缓存适配器定义了与之前定义的相同的方法。请注意使用`md5()`，不是为了安全，而是作为一种快速从键生成文本字符串的方法：
- en: '[PRE47]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now we are ready to present the core cache mechanism. In the constructor, we
    accept a class that implements `CacheAdapterInterface` as an argument:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备介绍核心缓存机制。在构造函数中，我们接受一个实现了`CacheAdapterInterface`的类作为参数：
- en: '[PRE48]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next are a series of wrapper methods that call methods of the same name from
    the adapter, but accept a `Psr\Http\Message\RequestInterface` class an an argument,
    and return a `Psr\Http\Message\ResponseInterface` as a response. We start with
    a simple one: `hasKey()`. Note how we extract the `key` from the request parameters:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是一系列的包装方法，调用适配器中同名的方法，但接受`Psr\Http\Message\RequestInterface`类作为参数，并返回`Psr\Http\Message\ResponseInterface`作为响应。我们从一个简单的开始：`hasKey()`。注意我们如何从请求参数中提取`key`：
- en: '[PRE49]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To retrieve information from the cache, we need to pull the key and group parameters
    from the request object, and then call the same method from the adapter. If no
    results are obtained, we set a `204` code, which indicates the request was a success,
    but no content was produced. Otherwise, we set a `200` (success) code, and iterate
    through the results. Everything is then stuffed into a response object, which
    is returned:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从缓存中检索信息，我们需要从请求对象中提取键和组参数，然后调用适配器中的相同方法。如果没有获得结果，我们设置一个`204`代码，表示请求成功，但没有生成内容。否则，我们设置一个`200`（成功）代码，并遍历结果。然后将所有内容放入响应对象中，并返回：
- en: '[PRE50]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Strangely, writing to the cache is almost identical, except that the results
    are expected to be either a number (that is, the number of rows affected), or
    a Boolean result:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 奇怪的是，写入缓存几乎与之前定义的方法相同，只是结果预期要么是一个数字（即受影响的行数），要么是一个布尔结果：
- en: '[PRE51]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The remove methods are, as expected, quite similar to each other:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除方法与预期相似：
- en: '[PRE52]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In order to demonstrate the use of the `Acl` class, you will need to define
    the classes described in this recipe, summarized here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`Acl`类的使用，您需要定义本篇文章中描述的类，总结如下：
- en: '| Class | Discussed in these steps |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 在这些步骤中讨论 |'
- en: '| --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Application\Cache\Constants` | 1 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Cache\Constants` | 1 |'
- en: '| `Application\Cache\CacheAdapterInterface` | 2 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Cache\CacheAdapterInterface` | 2 |'
- en: '| `Application\Cache\Database` | 3 - 10 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Cache\Database` | 3 - 10 |'
- en: '| `Application\Cache\File` | 11 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Cache\File` | 11 |'
- en: '| `Application\Cache\Core` | 12 - 16 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Cache\Core` | 12 - 16 |'
- en: 'Next, define a test program, which you could call `chap_09_middleware_cache_db.php`.
    In this program, as usual, define constants for necessary files, set up autoloading,
    use the appropriate classes, oh... and write a function that produces prime numbers
    (you''re probably re-reading that last little bit at this point. Not to worry,
    we can help you with that!):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个测试程序，你可以称之为`chap_09_middleware_cache_db.php`。在这个程序中，像往常一样，定义必要文件的常量，设置自动加载，使用适当的类，哦...并编写一个生成质数的函数（你可能在这一点上重新阅读最后一点。不用担心，我们可以帮你解决这个问题！）：
- en: '[PRE53]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Well, a function that takes a long time to run is needed, so prime number generator,
    here we go! The numbers 1, 2, and 3 are given as primes. We use the PHP 7 `yield
    from` syntax to produce these first three. then, we skip right to 5, and proceed
    up to the maximum value requested:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，需要一个运行时间很长的函数，所以质数生成器，我们来吧！数字1、2和3被给定为质数。我们使用PHP 7的`yield from`语法来生成这前三个。然后，我们直接跳到5，并继续到请求的最大值：
- en: '[PRE54]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can then set up a database cache adapter instance, which serves as an argument
    for the core:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以设置一个数据库缓存适配器实例，作为核心的参数：
- en: '[PRE55]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Alternatively, if you wish to use the file cache adapter instead, here is the
    appropriate code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您希望使用文件缓存适配器，这是适当的代码：
- en: '[PRE56]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you wanted to clear the cache, here is how it might be done:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要清除缓存，可以这样做：
- en: '[PRE57]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can use `time()` and `microtime()` to see how long this script runs with
    and without the cache:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`time()`和`microtime()`来查看此脚本在有缓存和无缓存的情况下运行的时间：
- en: '[PRE58]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, generate a cache request. A status code of `200` indicates you were able
    to obtain a list of primes from the cache:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，生成一个缓存请求。状态码`200`表示您能够从缓存中获取素数列表：
- en: '[PRE59]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Otherwise, you can assume nothing was obtained from the cache, which means
    you need to generate prime numbers, and save the results to the cache:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您可以假设未从缓存中获取任何内容，这意味着您需要生成素数，并将结果保存到缓存中：
- en: '[PRE60]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can then check the stop time, calculate the difference, and have a look
    at your new list of primes:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以检查停止时间，计算差异，并查看您的新素数列表：
- en: '[PRE61]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here is the expected output before values were stored in the cache:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在值存储在缓存之前的预期输出：
- en: '![How it works...](graphics/B05314_09_08.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_09_08.jpg)'
- en: 'You can now run the same program again, this time retrieving from the cache:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以再次运行相同的程序，这次是从缓存中检索：
- en: '![How it works...](graphics/B05314_09_09.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_09_09.jpg)'
- en: Allowing for the fact that our little prime number generator is not the world's
    most efficient, and also that the demonstration was run on a laptop, the time
    went from over 30 seconds down to milliseconds.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的小素数生成器不是世界上效率最高的，而且演示是在笔记本电脑上运行的，时间从30多秒降到了毫秒。
- en: There's more...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Another possible cache adapter could be built around commands that are part
    of the **Alternate PHP Cache** (**APC**) extension. This extension includes such
    functions as `apc_exists()`, `apc_store()`, `apc_fetch()`, and `apc_clear_cache()`.
    These functions are perfect for our `hasKey()`, `saveToCache()`, `getFromCache()`,
    and `removeBy*()` functions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的缓存适配器可以围绕**Alternate PHP Cache** (**APC**)扩展的命令构建。该扩展包括诸如`apc_exists()`、`apc_store()`、`apc_fetch()`和`apc_clear_cache()`之类的函数。这些函数非常适合我们的`hasKey()`、`saveToCache()`、`getFromCache()`和`removeBy*()`函数。
- en: See also
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You might consider making slight changes to the cache adapter classes described
    previously following PSR-6, which is a standards recommendation directed towards
    the cache. There is not the same level of acceptance of this standard as with
    PSR-7, however, so we decided to not follow this standard exactly in the recipe
    presented here. For more information on PSR-6, please refer to [http://www.php-fig.org/psr/psr-6/](http://www.php-fig.org/psr/psr-6/).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能考虑对先前描述的缓存适配器类进行轻微更改，遵循PSR-6，这是一个针对缓存的标准建议。然而，对于这个标准的接受程度并不像PSR-7那样高，因此我们决定在这里提出的配方中不完全遵循这个标准。有关PSR-6的更多信息，请参阅[http://www.php-fig.org/psr/psr-6/](http://www.php-fig.org/psr/psr-6/)。
- en: Implementing routing
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施路由
- en: Routing refers to the process of accepting user-friendly URLs, dissecting the
    URL into its component parts, and then making a determination as to which class
    and method should be dispatched. The advantage of such an implementation is that
    not only can you make your URLs **Search Engine Optimization** (**SEO**)-friendly,
    but you can also create rules, incorporating regular expression patterns, which
    can extract values of parameters.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是指接受用户友好的URL、解析URL为其组成部分，然后确定应该调度哪个类和方法的过程。这种实现的优势在于，不仅可以使您的URL**搜索引擎优化**（**SEO**）友好，还可以创建规则，包括正则表达式模式，可以提取参数的值。
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Probably the most popular approach is to take advantage of a web server that
    supports **URL rewriting**. An example of this is an Apache web server configured
    to use `mod_rewrite`. You then define rewriting rules that allow graphic file
    requests and requests for CSS and JavaScript to pass untouched. Otherwise, the
    request would be funneled through a routing method.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能最受欢迎的方法是利用支持**URL重写**的Web服务器。这样的一个例子是配置为使用`mod_rewrite`的Apache Web服务器。然后，您定义重写规则，允许图形文件请求以及对CSS和JavaScript的请求保持不变。否则，请求将通过路由方法进行处理。
- en: Another potential approach is to simply have your web server virtual host definition
    point to a specific routing script, which then invokes the routing class, make
    routing decisions, and redirect appropriately.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种潜在的方法是简单地让您的Web服务器虚拟主机定义指向特定的路由脚本，然后调用路由类，做出路由决策，并适当地重定向。
- en: 'The first code to consider is how to define routing configuration. The obvious
    answer is to construct an array, where each key would point to a regular expression
    against which the URI path would match, and some form of action. An example of
    such configuration is shown in the following code snippet. In this example, we
    have three routes defined: `home`, `page`, and the default. The default should
    be last as it will match anything not matched previously. The action is in the
    form of an anonymous function that will be executed if a route match occurs:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要考虑的第一段代码是如何定义路由配置。显而易见的答案是构造一个数组，其中每个键都指向一个正则表达式，该正则表达式与URI路径匹配，并且有某种形式的操作。以下代码片段显示了这种配置的示例。在这个例子中，我们定义了三个路由：`home`、`page`和默认路由。默认路由应该放在最后，因为它将匹配之前未匹配的任何内容。操作以匿名函数的形式呈现，如果路由匹配发生，则将执行该函数：
- en: '[PRE62]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, we define our `Router` class. We first define constants and properties
    that will be of use during the process of examining and matching a route:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的`Router`类。我们首先定义在检查和匹配路由过程中将有用的常量和属性：
- en: '[PRE63]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The constructor accepts a `ServerRequestInterface` compliant class, the path
    to the document root, and the configuration file mentioned earlier. Note that
    we throw an exception if the default configuration is not supplied:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数接受一个符合`ServerRequestInterface`的类、文档根目录的路径以及前面提到的配置文件。请注意，如果未提供默认配置，则会抛出异常：
- en: '[PRE64]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we have a series of getters that allow us to retrieve the original request,
    document root, and final route match:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有一系列的getter，允许我们检索原始请求、文档根目录和最终路由匹配：
- en: '[PRE65]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `isFileOrDir()` method is used to determine whether we are trying to match
    against a CSS, JavaScript, or graphic request (among other possibilities):'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isFileOrDir()`方法用于确定我们是否试图匹配CSS、JavaScript或图形请求（以及其他可能性）：'
- en: '[PRE66]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally we define `match()`, which iterates through the configuration array
    and runs the `uri` parameter through `preg_match()`. If positive, the configuration
    key and `$matches` array populated by `preg_match()` are stored in `$routeMatch`,
    and the callback is returned. If there is no match, the default callback is returned:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义了`match()`，它遍历配置数组，并通过`preg_match()`运行`uri`参数。如果匹配成功，则将配置键和`preg_match()`填充的`$matches`数组存储在`$routeMatch`中，并返回回调。如果没有匹配，则返回默认回调：
- en: '[PRE67]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: How it works...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'First, change to `/path/to/source/for/this/chapter` and create a directory
    called `routing`. Next, define a file, `index.php`, which sets up autoloading
    and uses the right classes. You can define a constant `PAGE_DIR` that points to
    the `pages` directory created in the previous recipe:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，切换到`/path/to/source/for/this/chapter`并创建一个名为`routing`的目录。接下来，定义一个文件`index.php`，设置自动加载并使用正确的类。您可以定义一个常量`PAGE_DIR`，指向上一篇文章中创建的`pages`目录：
- en: '[PRE68]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, add the configuration array discussed in step 3 of this recipe. Note
    that you could add `(/)?` at the end of the pattern to account for an optional
    trailing slash. Also, for the `home` route, you could offer two options: either
    `/` or `/home`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加在本教程第3步中讨论的配置数组。请注意，您可以在模式的末尾添加`(/)?`以考虑可选的尾随斜杠。另外，对于`home`路由，您可以提供两个选项：`/`或`/home`：
- en: '[PRE69]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You can then define a router instance, supplying an initialized `ServerRequest`
    instance as the first argument:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以定义一个路由器实例，将初始化的`ServerRequest`实例作为第一个参数提供：
- en: '[PRE70]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You then need to check to see whether the request is a file or directory, and
    also whether the route match is `/`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要检查请求是文件还是目录，以及路由匹配是否为`/`：
- en: '[PRE71]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, define `main.php`, something like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义`main.php`，类似于这样：
- en: '[PRE72]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'And finally, a revised menu that uses user-friendly routing is required:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要一个使用用户友好路由的修订菜单：
- en: '[PRE73]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To test the configuration using Apache, define a virtual host definition that
    points to `/path/to/source/for/this/chapter/routing`. In addition, define a `.htaccess`
    file that directs any request that is not a file, directory, or link to `index.php`.
    Alternatively, you could just use the built-in PHP webserver. In a terminal window
    or command prompt, type this command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Apache测试配置，请定义一个虚拟主机定义，指向`/path/to/source/for/this/chapter/routing`。此外，定义一个`.htaccess`文件，将任何不是文件、目录或链接的请求重定向到`index.php`。或者，您可以直接使用内置的PHP
    Web服务器。在终端窗口或命令提示符中，键入此命令：
- en: '[PRE74]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In a browser, the output when requesting `http://localhost:8080/home` is something
    like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，请求`http://localhost:8080/home`时的输出如下：
- en: '![How it works...](graphics/B05314_09_10.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_09_10.jpg)'
- en: See also
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For information on rewriting using the **NGINX** web server, have a look at
    this article: [http://nginx.org/en/docs/http/ngx_http_rewrite_module.html](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html).
    There are plenty of sophisticated PHP routing libraries available that introduce
    far greater functionality than the simple router presented here. These include
    Altorouter ([http://altorouter.com/](http://altorouter.com/)), TreeRoute ([https://github.com/baryshev/TreeRoute](https://github.com/baryshev/TreeRoute)),
    FastRoute ([https://github.com/nikic/FastRoute](https://github.com/nikic/FastRoute)),
    and Aura.Router. ([https://github.com/auraphp/Aura.Router](https://github.com/auraphp/Aura.Router)).
    In addition, most frameworks (for example, Zend Framework 2 or CodeIgniter) have
    their own routing capabilities.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用**NGINX** Web服务器进行重写的信息，请参阅本文：[http://nginx.org/en/docs/http/ngx_http_rewrite_module.html](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html)。有许多复杂的PHP路由库可用，介绍的功能远远超过了这里介绍的简单路由器。这些包括Altorouter
    ([http://altorouter.com/](http://altorouter.com/))，TreeRoute ([https://github.com/baryshev/TreeRoute](https://github.com/baryshev/TreeRoute))，FastRoute
    ([https://github.com/nikic/FastRoute](https://github.com/nikic/FastRoute))和Aura.Router.
    ([https://github.com/auraphp/Aura.Router](https://github.com/auraphp/Aura.Router))。此外，大多数框架（例如Zend
    Framework 2或CodeIgniter）都具有自己的路由功能。
- en: Making inter-framework system calls
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行跨框架系统调用
- en: One of the primary reasons for the development of PSR-7 (and middleware) was
    a growing need to make calls between frameworks. It is of interest to note that
    the main documentation for PSR-7 is hosted by **PHP Framework Interop** **Group**
    (**PHP-FIG**).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-7（和中间件）开发的主要原因之一是日益增长的需要在框架之间进行调用。值得注意的是，PSR-7的主要文档由**PHP Framework Interop**
    **Group** (**PHP-FIG**)托管。
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: The primary mechanism used in middleware inter-framework calls is to create
    a driver program that executes framework calls in succession, maintaining a common
    request and response object. The request and response objects are expected to
    represent `Psr\Http\Message\ServerRequestInterface` and `Psr\Http\Message\ResponseInterface`,
    respectively.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中间件跨框架调用中使用的主要机制是创建一个驱动程序，依次执行框架调用，维护一个公共的请求和响应对象。预期请求和响应对象分别代表`Psr\Http\Message\ServerRequestInterface`和`Psr\Http\Message\ResponseInterface`。
- en: 'For the purposes of this illustration, we define a middleware session validator.
    The constants and properties reflect the session `thumbprint`, which is a term
    we use to incorporate factors such as the website visitor''s IP address, browser,
    and language settings:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们定义了一个中间件会话验证器。常量和属性反映了会话`thumbprint`，这是一个我们用来包含网站访问者IP地址、浏览器和语言设置等因素的术语：
- en: '[PRE75]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The constructor takes a `ServerRequestInterface` instance and the session as
    arguments. If the session is an array (such as `$_SESSION`), we wrap it in a class.
    The reason why we do this is in case we are passed a session object, such as `JSession`
    used in Joomla. We then create the thumbprint using the previously mentioned factors.
    If the stored thumbprint is not available, we assume this is the first time, and
    store the current print as well as stop time, if this parameter is set. We used
    `md5()` because it''s a fast hash, is not exposed externally, and is therefore
    useful to this application:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数接受`ServerRequestInterface`实例和会话作为参数。如果会话是一个数组（比如`$_SESSION`），我们将其包装在一个类中。我们这样做的原因是，以防我们传递了一个会话对象，比如Joomla中使用的`JSession`。然后，我们使用先前提到的因素创建指纹。如果存储的指纹不可用，我们假设这是第一次，并存储当前的指纹以及停止时间（如果设置了此参数）。我们使用`md5()`是因为它是一个快速的哈希，不会外部暴露，因此对这个应用程序很有用：
- en: '[PRE76]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'It''s not required to define `__invoke()`, but this magic method is quite convenient
    for standalone middleware classes. As is the convention, we accept `ServerRequestInterface`
    and `ResponseInterface` instances as arguments. In this method, we simply check
    to see whether the current thumbprint matches the one stored. The first time,
    of course, they will match. But on subsequent requests, the chances are an attacker
    intent on session hijacking will be caught out. In addition, if the session time
    exceeds the stop time (if set), likewise, a `401` code will be sent:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并不需要定义`__invoke()`，但这个魔术方法对于独立的中间件类非常方便。按照惯例，我们接受`ServerRequestInterface`和`ResponseInterface`实例作为参数。在这个方法中，我们只是检查当前的指纹是否与存储的指纹匹配。第一次，当然，它们会匹配。但在后续请求中，有可能会捕获到试图劫持会话的攻击者。此外，如果会话时间超过了停止时间（如果设置了），同样会发送`401`代码：
- en: '[PRE77]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can now put our new middleware class to use. The main problems with inter-framework
    calls, at least at this point, are summarized here. Accordingly, how we implement
    middleware depends heavily on the last point:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们的新中间件类。至少在这一点上，不同框架之间的调用存在的主要问题在这里总结。因此，我们如何实现中间件在很大程度上取决于最后一点：
- en: Not all PHP frameworks are PSR-7-compliant
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有的PHP框架都符合PSR-7
- en: Existing PSR-7 implementations are not complete
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的PSR-7实现并不完整
- en: All frameworks want to be the "boss"
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有框架都想成为“老大”
- en: 'As an example, have a look at the configuration files for **Zend Expressive**,
    which is a self-proclaimed *PSR7 Middleware Microframework*. Here is the file,
    `middleware-pipeline.global.php`, which is located in the `config/autoload` folder
    in a standard Expressive application. The dependencies key is used to identify
    the middleware wrapper classes that will be activated in the pipeline:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为一个例子，让我们来看看**Zend Expressive**的配置文件，它是一个自称为*PSR7中间件微框架*。这里有一个名为`middleware-pipeline.global.php`的文件，它位于标准Expressive应用程序中的`config/autoload`文件夹中。依赖项键用于标识将在管道中激活的中间件包装类：
- en: '[PRE78]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Under the `middleware_pipline` key, you can identify classes that will be executed
    before or after the routing process occurs. Optional parameters include `path`,
    `error`, and `priority`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`middleware_pipline`键下，您可以标识在路由过程发生之前或之后将被执行的类。可选参数包括`path`、`error`和`priority`：
- en: '[PRE79]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Another technique is to modify the source code of an existing framework module,
    and make a request to a PSR-7-compliant middleware application. Here is an example
    modifying a **Joomla!** installation to include a middleware session validator.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种技术是修改现有框架模块的源代码，并向符合PSR-7的中间件应用程序发出请求。以下是修改**Joomla!**安装以包含中间件会话验证器的示例。
- en: 'Next, add this code the end of the `index.php` file in the `/path/to/joomla`
    folder. Since Joomla! uses Composer, we can leverage the Composer autoloader:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将此代码添加到`/path/to/joomla`文件夹中的`index.php`文件的末尾。由于Joomla!使用Composer，我们可以利用Composer自动加载程序：
- en: '[PRE80]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can then create an instance of our middleware session validator, and make
    a validation request just before `$app = JFactory::getApplication(''site'');`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建我们的中间件会话验证器的实例，并在`$app = JFactory::getApplication('site');`之前进行验证请求：
- en: '[PRE81]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: How it works...
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, create the `Application\MiddleWare\Session\Validator` test middleware
    class described in steps 2-5\. Then you will need to go to [https://getcomposer.org/](https://getcomposer.org/)
    and follow the directions to obtain Composer. Download it to the `/path/to/source/for/this/chapter`
    folder. Next, build a basic Zend Expressive application, as shown next. Be sure
    to select `No` when prompted for minimal skeleton:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建描述步骤2-5的`Application\MiddleWare\Session\Validator`测试中间件类。然后，您需要转到[https://getcomposer.org/](https://getcomposer.org/)并按照说明获取Composer。将其下载到`/path/to/source/for/this/chapter`文件夹中。接下来，构建一个基本的Zend
    Expressive应用程序，如下所示。在提示是否选择最小骨架时，请务必选择`No`：
- en: '[PRE82]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This will create a `folder /path/to/source/for/this/chapter/expressive`. Change
    to this directory. Modify `public/index.php` as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个`/path/to/source/for/this/chapter/expressive`文件夹。切换到这个目录。修改`public/index.php`如下：
- en: '[PRE83]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'You will then need to create a wrapper class that invokes our session validator
    middleware. Create a `SessionValidateAction.php` file that needs to go in the
    `/path/to/source/for/this/chapter/expressive/src/App/Action` folder. For the purposes
    of this illustration, set the stop time parameter to a short duration. In this
    case, `time() + 10` gives you 10 seconds:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要创建一个调用我们会话验证中间件的包装类。创建一个`SessionValidateAction.php`文件，需要放在`/path/to/source/for/this/chapter/expressive/src/App/Action`文件夹中。为了说明这一点，将停止时间参数设置为一个较短的持续时间。在这种情况下，`time()
    + 10`给您10秒：
- en: '[PRE84]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'You will now need to add the new class to the middleware pipeline. Modify `config/autoload/middleware-pipeline.global.php`
    as follows. Modifications are shown in **bold**:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要将新类添加到中间件管道中。修改`config/autoload/middleware-pipeline.global.php`如下。修改部分用**粗体**显示：
- en: '[PRE85]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You might also consider modifying the home page template to show the status
    of `$_SESSION`. The file in question is `/path/to/source/for/this/chapter/expressive/templates/app/home-page.phtml`.
    Simply adding `var_dump($_SESSION)` should suffice.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还考虑修改主页模板以显示`$_SESSION`的状态。相关文件是`/path/to/source/for/this/chapter/expressive/templates/app/home-page.phtml`。只需添加`var_dump($_SESSION)`即可。
- en: 'Initially, you should see something like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，您应该看到类似以下的东西：
- en: '![How it works...](graphics/B05314_09_11.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_09_11.jpg)'
- en: 'After 10 seconds, refresh the browser. You should now see this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 10秒后，刷新浏览器。现在您应该看到这个：
- en: '![How it works...](graphics/B05314_09_12.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_09_12.jpg)'
- en: Using middleware to cross languages
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用中间件跨语言
- en: 'Except in cases where you are trying to communicate between different versions
    of PHP, PSR-7 middleware will be of minimal use. Recall what the acronym stands
    for: **PHP Standards Recommendations**. Accordingly, if you need to make a request
    to an application written in another language, treat it as you would any other
    web service HTTP request.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您尝试在不同版本的PHP之间进行通信，否则PSR-7中间件将几乎没有用处。回想一下这个首字母缩略词的含义：**PHP标准建议**。因此，如果您需要向另一种语言编写的应用程序发出请求，请将其视为任何其他Web服务HTTP请求。
- en: How to do it...
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the case of PHP 4, you actually have a chance in that there is limited support
    for object-oriented programming. Accordingly, the best approach would be to downgrade
    the basic PSR-7 classes described in the first three recipes. There is not enough
    space to cover all the changes, but we present a potential PHP 4 version of `Application\MiddleWare\ServerRequest`.
    The first thing to note is that there are no namespaces! Accordingly, we use a
    classname with underscores, _, in place of namespace separators:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PHP 4的情况下，实际上有机会进行面向对象编程的有限支持。因此，最好的方法是降级前三个食谱中描述的基本PSR-7类。没有足够的空间来涵盖所有的变化，但我们提供了`Application\MiddleWare\ServerRequest`的潜在PHP
    4版本。首先要注意的是没有命名空间！因此，我们使用下划线_来代替命名空间分隔符的类名：
- en: '[PRE86]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'All properties are identified in PHP 4 using the key word `var`:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PHP 4中，所有属性都使用关键字`var`进行标识：
- en: '[PRE87]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `initialize()` method is almost the same, except that syntax such as `$this->getServerParams()[''REQUEST_URI'']`
    was not allowed in PHP 4\. Accordingly, we need to split this out into a separate
    variable:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`initialize()`方法几乎相同，只是在PHP 4中不允许使用`$this->getServerParams()[''REQUEST_URI'']`这样的语法。因此，我们需要将其拆分为一个单独的变量：'
- en: '[PRE88]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'All of the `$_XXX` super-globals were present in later versions of PHP 4:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有`$_XXX`超全局变量都出现在PHP 4的后续版本中：
- en: '[PRE89]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The null coalesce operator was only introduced in PHP 7\. We need to use `isset(XXX)
    ? XXX : '''';` instead:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '空合并运算符是在PHP 7中引入的。我们需要使用`isset(XXX) ? XXX : '''';`代替：'
- en: '[PRE90]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The JSON extension was not introduced until PHP 5\. Accordingly, we need to
    be satisfied with raw input. We could also possibly use `serialize()` or `unserialize()`
    in place of `json_encode()` and `json_decode()`:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSON扩展是在PHP 5中引入的。因此，我们需要满足于原始输入。我们还可以在`json_encode()`和`json_decode()`的位置使用`serialize()`或`unserialize()`：
- en: '[PRE91]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `withXXX()` methods work pretty much the same in PHP 4:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`withXXX()`方法在PHP 4中基本相同：'
- en: '[PRE92]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Likewise, the `withoutXXX()` methods work the same as well:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`withoutXXX()`方法也是一样的：
- en: '[PRE93]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'For websites using other languages, we could use the PSR-7 classes to formulate
    requests and responses, but would then need to use an HTTP client to communicate
    with the other website. As an example, recall the demonstration of a `Request`
    discussed in the recipe *Developing a PSR-7 request class* from this chapter.
    Here is the example from the *How it works...* section:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于使用其他语言的网站，我们可以使用PSR-7类来制定请求和响应，但随后需要使用HTTP客户端与其他网站进行通信。例如，回想一下本章中讨论的“开发PSR-7请求类”食谱中的`Request`演示。以下是*它是如何工作的...*部分的示例：
- en: '[PRE94]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
