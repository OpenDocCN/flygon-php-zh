- en: Testing the Important Bits
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试重要部分
- en: Writing quality software is a technically challenging and expensive activity.
    The technically challenging part comes from the need to understand and implement
    more than one type of application testing. Whereas, the expensive part comes from
    the fact that proper testing usually yields more code than the code we are testing,
    which translates to more time needed to get the job done.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写高质量的软件是一项技术上具有挑战性和昂贵的活动。技术上具有挑战性的部分来自于需要理解和实现多种类型的应用程序测试。而昂贵的部分来自于适当的测试通常产生的代码比我们正在测试的代码更多，这意味着需要更多的时间来完成工作。
- en: Unlike developers, businesses don't care as much about technicalities, as they
    care about reducing cost. This is where the two worlds clash at the expense of
    quality. While both understand the implications of a *technical debt* concept,
    rarely few take it seriously. Web applications come to mind as a nice example
    of this clash. The good enough UX and design is often sufficient to meet the needs
    of shareholders, while many of the internals and far-from-the-eye parts of the
    software are left untested.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与开发人员不同，企业不太关心技术细节，而更关心降低成本。这就是两个世界在质量的代价上发生冲突的地方。虽然两者都理解“技术债务”概念的影响，但很少有人认真对待。网页应用程序是这种冲突的一个很好的例子。足够好的用户体验和设计通常足以满足股东的需求，而软件的许多内部和远离视线的部分则被忽视。
- en: Check out [https://en.wikipedia.org/wiki/Technical_debt](https://en.wikipedia.org/wiki/Technical_debt)
    for more information on the technical debt concept.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 查看有关技术债务概念的更多信息，请访问[https://en.wikipedia.org/wiki/Technical_debt](https://en.wikipedia.org/wiki/Technical_debt)。
- en: 'There are many types of testing we can apply to our application, some of which
    are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对应用程序应用许多类型的测试，其中一些如下：
- en: Unit Testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Functional Testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试
- en: Performance Testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试
- en: Usability Testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性测试
- en: Acceptance Testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验收测试
- en: 'It would be unjust to say that one is more important than the other, as each
    addresses a very distinct segment of the application. The current state of the
    PHP ecosystem and tooling indicates *unit*, *functional*, and *performance testing* to
    be among the popular ones. In this chapter, we will take a quick look at a few
    of the tools and libraries that accommodate these types of testing:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 说一个比另一个更重要是不公平的，因为每个都涉及应用程序的一个非常不同的部分。PHP生态系统和工具的当前状态表明“单元”、“功能”和“性能测试”是其中流行的一些。在本章中，我们将快速查看一些适应这些测试类型的工具和库：
- en: PHPUnit
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHPUnit
- en: Behat
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Behat
- en: phpspec
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: phpspec
- en: jMeter
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jMeter
- en: Software that a typical programmer believes to be thoroughly tested has often
    had only about 55 to 60 percent of its logic paths executed. Using automated support,
    such as coverage analyzers, can raise that roughly to 85 to 90 percent. It is
    nearly impossible to test software at the level of 100 percent of its logic paths.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 典型程序员认为经过彻底测试的软件通常只执行了大约55到60％的逻辑路径。使用自动化支持，如覆盖分析器，可以将其提高到大约85到90％。几乎不可能以100％的逻辑路径测试软件。
- en: '- Facts and Fallacies of Software Engineering book.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '- 《软件工程的事实与谬误》一书。'
- en: PHPUnit
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHPUnit
- en: PHPUnit is a representative of unit testing frameworks, whose overall idea is
    to provide a *strict contract* over an isolated piece of code that must be satisfied.
    This piece of code is what we call *unit*, which translates to the class and its
    methods in PHP. Using the *assertions* functionality, the PHPUnit framework verifies
    that these units behave as expected. The benefit of unit testing is that its early
    problem detection helps mitigate *compound* or *down-the-line* errors that might
    not be obvious initially. The more possible paths of a program the unit test covers,
    the better.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit是单元测试框架的代表，其总体思想是为必须满足的孤立代码提供严格的合同。这段代码就是我们所谓的“单元”，在PHP中对应于类及其方法。使用“断言”功能，PHPUnit框架验证这些单元的行为是否符合预期。单元测试的好处在于，它早期发现问题有助于减轻可能不明显的“复合”或“下游”错误。程序的可能路径越多，单元测试覆盖的越好。
- en: Setting up the PHPUnit
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置PHPUnit
- en: PHPUnit can be installed as, provisionally named, a tool or a library. Both
    are the same things actually, just differing in a way we install and use them.
    The *tool* version is really just a PHP *phar* archive we can run via console,
    which then provides a set of console commands we can execute globally. The *library*
    version on the other hand is a set of PHPUnit libraries packed as a Composer package,
    as well as a binary that gets dumped into the project's `vendor/bin/` directory.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit可以作为一个临时命名的“工具”或“库”安装。实际上两者是相同的，只是在安装和使用方式上有所不同。“工具”版本实际上只是一个我们可以通过控制台运行的PHP“phar”存档，然后提供一组我们可以全局执行的控制台命令。“库”版本则是一组作为Composer包打包的PHPUnit库，以及一个被转储到项目的`vendor/bin/`目录下的二进制文件。
- en: 'Assuming that we are using the Ubuntu 16.10 (Yakkety Yak) installation, installing
    the PHPUnit as a tool is easy via the following commands:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在使用Ubuntu 16.10（Yakkety Yak）安装，通过以下命令安装PHPUnit作为工具非常容易：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should give us the final output, much like the following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们最终的输出，就像以下屏幕截图一样：
- en: '![](assets/04a8301f-9170-475d-9cf6-9f06da6b1be5.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/04a8301f-9170-475d-9cf6-9f06da6b1be5.png)
- en: The PHPUnit becomes a system-wide accessible console tool, not related to any
    project specifically.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit成为一个系统范围内可访问的控制台工具，与任何特定项目无关。
- en: 'Installing PHPUnit as a library is easy as running the following console command
    within the root of our project:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将PHPUnit安装为库就像在项目根目录中运行以下控制台命令一样容易：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This should give us the final output, much like the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们最终的输出，就像以下屏幕截图一样：
- en: '![](assets/c9cf5e36-7f37-4e8f-be79-813ff7590a43.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/c9cf5e36-7f37-4e8f-be79-813ff7590a43.png)
- en: This installs all the PHPUnit library files within our project's `vendor/phpunit/`
    directory, as well as the `phpunit` executable file under the `vendor/bin/` directory.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们项目的`vendor/phpunit/`目录中安装所有PHPUnit库文件，以及在`vendor/bin/`目录下的`phpunit`可执行文件。
- en: Setting up a sample application
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置一个示例应用程序
- en: Before we start writing some PHPUnit test scripts, let's go ahead and create
    a very simple application consisting of merely a few files. This will allow us
    to focus on the essence of writing a test later on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写一些PHPUnit测试脚本之前，让我们继续创建一个非常简单的应用程序，仅由几个文件组成。这将使我们能够专注于稍后编写测试的本质。
- en: '**Test driven development** (**TDD**), such as the one done with PHPUnit, encourages
    writing tests before the implementations. This way, the tests set the expectations
    for the functionality and not the other way around. This approach requires a certain
    level of experience and discipline, which might not sit well with newcomers to
    PHPUnit.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**），例如使用PHPUnit进行的开发，鼓励在实现之前编写测试。这样，测试设置了功能的期望，而不是相反。这种方法需要一定水平的经验和纪律，这可能不适合PHPUnit的新手。'
- en: 'Let''s assume that we are making a part of the web shopping functionality,
    thus dealing with product and category entities for a start. The first class we
    address is the `Product` model. We will do so by creating the `src\Foggyline\Catalog\Model\Product.php`
    file, with its content as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在制作网购功能的一部分，因此首先处理产品和类别实体。我们首先要处理的类是`Product`模型。我们将通过创建`src\Foggyline\Catalog\Model\Product.php`文件来实现这一点，其内容如下：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Product` class relies on the constructor for setting up the product''s
    ID, title, price, and tax rate. Other than that, there is no actual logic to the
    class, aside from the simple getter methods. With the `Product` class in place,
    let''s go ahead and create a `Category` class. We will add it to the `src\Foggyline\Catalog\Model\Category.php`
    file, with its content as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product`类依赖于构造函数来设置产品的ID、标题、价格和税率。除此之外，该类没有实际的逻辑，除了简单的getter方法。有了`Product`类，让我们继续创建一个`Category`类。我们将把它添加到`src\Foggyline\Catalog\Model\Category.php`文件中，其内容如下：'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Category` class relies on the constructor for setting up the category title
    and its products. Other than that, there is no logic in it, aside from the two
    getter methods, which merely return the values set through the constructor.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Category`类依赖于构造函数来设置类别标题及其产品。除此之外，它没有其他逻辑，除了两个getter方法，这些方法仅返回通过构造函数设置的值。'
- en: 'To spice things up a bit, for testing purposes, let''s go ahead and create
    a dummy `Layer` class as a part of the `src\Foggyline\Catalog\Model\Layer.php`
    file, with its content as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加一些调味料，为了测试目的，让我们继续创建一个虚拟的`Layer`类，作为`src\Foggyline\Catalog\Model\Layer.php`文件的一部分，其内容如下：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will use this class merely as an example, with the code coverage analysis
    later on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将仅将这个类用作示例，稍后进行代码覆盖分析。
- en: 'With the `Product` and `Category` models, let''s go ahead and create the `Block\Category\View`
    class as a part of the `src\Foggyline\Catalog\Block\Category\View.php` file, with
    its content as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`Product`和`Category`模型，让我们继续创建`Block\Category\View`类，作为`src\Foggyline\Catalog\Block\Category\View.php`文件的一部分，其内容如下：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are using the `render()` method to render the entire category page. The
    page itself consists of a category title, and a container of all of its products
    with their individual titles and prices. Now that we have our truly basic application
    classes outlined, let''s add a simple PSR4 type loader to the `autoload.php` file,
    with its content as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`render()`方法来渲染整个类别页面。页面本身包括类别标题，以及所有产品及其各自的标题和价格的容器。现在我们已经概述了我们真正基本的应用程序类，让我们在`autoload.php`文件中添加一个简单的PSR4类型加载器，其内容如下：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we set up the entry point to our application as a part of the `index.php`
    file, with its content as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将设置应用程序的入口点作为`index.php`文件的一部分，其内容如下：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will be using this utterly simple application across other types of tests
    as well, so it's worth keeping its files and structure in mind.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在其他类型的测试中使用这个非常简单的应用程序，因此值得记住它的文件和结构。
- en: Writing test
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: 'Getting started with writing PHPUnit tests requires grasping a few basic concepts,
    such as the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 开始编写PHPUnit测试需要掌握一些基本概念，例如以下内容：
- en: '**The setUp() method**: Analogous to the constructor, this is where we create
    the objects against which we will perform the test.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setUp()方法**：类似于构造函数，这是我们创建针对测试执行的对象的地方。'
- en: '**The tearDown() method**: Analogous to the destructor, this is where we clean
    up objects against which we performed the test.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tearDown()方法**：类似于析构函数，这是我们清理针对测试执行的对象的地方。'
- en: '**The test*() methods**: Every public method whose name begins with test, for
    example, `testSomething()`, `testItAgain()`, and so on, is considered a single
    test. The same effect can be achieved by adding the `@test` annotation in a method''s
    docblock; although, this seems to be a less used case.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**test*()方法**：每个公共方法的名称以test开头，例如`testSomething()`，`testItAgain()`等，被视为单个测试。通过在方法的文档块中添加`@test`注释也可以实现相同的效果；尽管这似乎是一个不太常用的情况。'
- en: '**The @depends annotation**: This allows expressing dependencies between the
    test methods.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@depends注释**：这允许表达测试方法之间的依赖关系。'
- en: '**Assertions**: The heart of the PHPUnit, this set of methods allows us to reason
    about correctness.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：这是PHPUnit的核心，这组方法允许我们推理正确性。'
- en: The `vendor\phpunit\phpunit\src\Framework\Assert\Functions.php` file contains
    an extensive list of the `assert*` function declarations, such as `assertEquals()`,
    `assertContains()`, `assertLessThan()`, and others, totaling to over 90 different
    assert functions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`vendor\phpunit\phpunit\src\Framework\Assert\Functions.php`文件包含了大量的`assert*`函数声明，例如`assertEquals()`，`assertContains()`，`assertLessThan()`等，总共超过90个不同的断言函数。'
- en: 'With these in mind, let''s go ahead and write the `src\Foggyline\Catalog\Test\Unit\Model\ProductTest.php`
    file, with its content as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，让我们继续编写`src\Foggyline\Catalog\Test\Unit\Model\ProductTest.php`文件，其内容如下：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our `ProductTest` class is using a `setUp()` method to set up an instance of
    a `Product` class. The two `test*()` methods then use the PHPUnit's built-in `assertEquals()`
    method to test the value of the product title and price.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ProductTest`类使用`setUp()`方法来设置`Product`类的实例。然后，两个`test*()`方法使用PHPUnit内置的`assertEquals()`方法来测试产品标题和价格的值。
- en: 'We then add the `src\Foggyline\Catalog\Test\Unit\Model\CategoryTest.php` file,
    with its content as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了`src\Foggyline\Catalog\Test\Unit\Model\CategoryTest.php`文件，其内容如下：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our `CategoryTest` class is using a `setUp()` method to set up an instance of
    a `Category` class, along with the two products passed onto the `Category` class
    constructor. The two `test*()` methods then use the PHPUnit's built-in `assertCount()` and
    `assertEquals()` methods to test the instantiated values.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`CategoryTest`类使用`setUp()`方法来设置`Category`类的实例，以及传递给`Category`类构造函数的两个产品。然后，两个`test*()`方法使用PHPUnit内置的`assertCount()`和`assertEquals()`方法来测试实例化的值。
- en: 'We then add the `src\Foggyline\Catalog\Test\Unit\Block\Category\ViewTest.php`
    file, with its content as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了`src\Foggyline\Catalog\Test\Unit\Block\Category\ViewTest.php`文件，其内容如下：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our `ViewTest` class is using a `setUp()` method to set up an instance of a
    `Category` class, alongside with the two products passed onto the `Category` class
    constructor. The two `test*()` methods then use the PHPUnit's built-in `assertContains()` method
    to test the presence of the value that should be returned through the category
    view `render()` method call.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ViewTest`类使用`setUp()`方法来设置`Category`类的实例，以及传递给`Category`类构造函数的两个产品。然后，两个`test*()`方法使用PHPUnit内置的`assertContains()`方法来测试通过类别视图`render()`方法调用返回的值的存在。
- en: 'We then add the `phpunit.xml` file, with its content as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了`phpunit.xml`文件，其内容如下：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `phpunit.xml` configuration file supports quite a robust list of options.
    Using the bootstrap attribute of a PHPUnit element, we are instructing the PHPUnit
    tool to load the `autoload.php` file prior to running the tests. This ensures
    that our PSR4 autoloader will kick in, and that our test classes will see our
    classes within the `src/Foggyline` directory. The `foggyline` test suite we defined
    within `testsuites` uses the directory option to specify, in regex form, the path
    to our unit tests. The path we used was such so that all of the files under both
    `src/Foggyline/Catalog/Test/Unit/` and possibly `src/Foggyline/Checkout/Test/Unit/`
    directories are picked up.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`phpunit.xml`配置文件支持相当丰富的选项列表。使用PHPUnit元素的bootstrap属性，我们指示PHPUnit工具在运行测试之前加载`autoload.php`文件。这确保我们的PSR4自动加载程序将启动，并且我们的测试类将在`src/Foggyline`目录中看到我们的类。我们在`testsuites`中定义的`foggyline`测试套件使用directory选项以正则表达式形式指定我们单元测试的路径。我们使用的路径是这样的，以便捡起`src/Foggyline/Catalog/Test/Unit/`和可能`src/Foggyline/Checkout/Test/Unit/`目录下的所有文件。'
- en: Check out [https://phpunit.de/manual/current/en/appendixes.configuration.html](https://phpunit.de/manual/current/en/appendixes.configuration.html)
    for more information on `phpunit.xml` configuration options.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[https://phpunit.de/manual/current/en/appendixes.configuration.html](https://phpunit.de/manual/current/en/appendixes.configuration.html)以获取有关`phpunit.xml`配置选项的更多信息。
- en: Executing tests
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行测试
- en: Running the test suite we have just written is as easy as executing the `phpunit` command
    within our project root directory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们刚刚编写的测试套件就像在项目根目录中执行`phpunit`命令一样简单。
- en: 'Upon execution, `phpunit` will look for the `phpunit.xml` file and act accordingly.
    This means that `phpunit` will know where to look for the test files. Successfully
    executed tests show an output like the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，`phpunit`将查找`phpunit.xml`文件并相应地采取行动。这意味着`phpunit`将知道在哪里查找测试文件。成功执行的测试显示如下屏幕截图所示：
- en: '![](assets/371e6760-3391-4cf7-9c0d-91f1ba2ae855.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/371e6760-3391-4cf7-9c0d-91f1ba2ae855.png)'
- en: 'However, the unsuccessfully executed tests show an output like the following
    screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，未成功执行的测试显示如下屏幕截图所示：
- en: '![](assets/e1bdf825-0c30-4e10-bdc1-a40343b12fb6.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e1bdf825-0c30-4e10-bdc1-a40343b12fb6.png)'
- en: We can easily modify one of the test classes, as we did with the preceding `ViewTest`,
    in order to trigger and observe the reactions of `phpunit` to failures.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松修改其中一个测试类，就像我们之前对`ViewTest`所做的那样，以触发并观察`phpunit`对失败的反应。
- en: Code coverage
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: 'The great thing about PHPUnit is its code coverage reporting functionality.
    We can easily add code coverage to our testing suite just by extending the `phpunit.xml`
    file as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit的一个很棒的功能是其代码覆盖率报告功能。我们可以通过扩展`phpunit.xml`文件轻松地将代码覆盖率添加到我们的测试套件中，如下所示：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we added the `filter` element, with an extra `whitelist` and `logging`
    element. We can now trigger the testing again, but, this time, with a slightly
    modified command, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了`filter`元素，还有额外的`whitelist`和`logging`元素。现在我们可以再次触发测试，但是，这次稍微修改了命令，如下所示：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This should give us the final output, as shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们最终的输出，如下屏幕截图所示：
- en: '![](assets/4d9fe7f1-a837-4d1c-b5c1-44817ffd4ced.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4d9fe7f1-a837-4d1c-b5c1-44817ffd4ced.png)'
- en: 'The `log/report` directory should now be filled with HTML report files. If
    we expose it to the browser, we can see a nicely generated report with valuable
    pieces of information about our code base, as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`log/report`目录现在应该填满了HTML报告文件。如果我们将其暴露给浏览器，我们可以看到一个生成良好的报告，其中包含有关我们代码库的有价值的信息，如下面的屏幕截图所示：'
- en: '![](assets/b05dae90-7045-4860-b173-4e4b77db6144.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b05dae90-7045-4860-b173-4e4b77db6144.png)'
- en: 'The preceding screenshot shows a code coverage percentage across the `src/Foggyline/Catalog/`
    directory structure. Drilling further down into a `Model` directory, we see our
    `Layer` class having 0% code coverage, which is expected, as we haven''t written
    any test for it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示了`src/Foggyline/Catalog/`目录结构中的代码覆盖率百分比。进一步深入到`Model`目录，我们看到我们的`Layer`类的代码覆盖率为0%，这是预期的，因为我们还没有为它编写任何测试：
- en: '![](assets/55600582-e0c2-488f-afd6-7a0f177a8f85.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/55600582-e0c2-488f-afd6-7a0f177a8f85.png)'
- en: 'Drilling further down into the actual `Product` class itself, we can see the
    PHPUnit code coverage outlining each and every line of code covered by our test:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步深入到实际的`Product`类本身，我们可以看到PHPUnit代码覆盖概述了我们的测试覆盖的每一行代码。
- en: '![](assets/968f95fa-563d-412a-92c7-c1a14a8fe066.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/968f95fa-563d-412a-92c7-c1a14a8fe066.png)'
- en: 'Looking directly into the actual `Layer` class gives us a nice visual on the
    lack of any code coverage within this class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 直接查看实际的`Layer`类，我们可以清楚地看到这个类中没有任何代码覆盖：
- en: '![](assets/bdf1bb00-292b-4d00-b8a7-fd7356d68d5b.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bdf1bb00-292b-4d00-b8a7-fd7356d68d5b.png)'
- en: Code coverage provides valuable visual and statistical information about the
    amount of code we have covered with tests. Although this information is easily
    misinterpreted, having 100% code coverage is by no means a measure of our individual
    test quality. Writing quality tests requires the writer, that is, the developer,
    to have a clear understanding of what exactly is the unit testing. It goes to
    say that we can easily have 100% code coverage, with 100% passing tests, and yet
    fail to address certain test cases or paths of logic.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖提供了有关我们用测试覆盖的代码量的宝贵的视觉和统计信息。尽管这些信息很容易被误解，但拥有100%的代码覆盖绝不是我们个别测试质量的衡量标准。编写质量测试需要编写者，也就是开发人员，清楚了解单元测试的确切内容。可以说，我们可以很容易地实现100%的代码覆盖率，通过100%的测试，但仍然未能解决某些测试用例或逻辑路径。
- en: Behat
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Behat
- en: Behat is an open source and free testing framework based on a notion of **behavior-driven
    developmen**t (**BDD**). The great benefit of the BDD frameworks, including Behat,
    is that a significant portion of the functional documentation gets poured into
    the actual user stories we end up testing. That is, to some extent, the documentation
    itself becomes a test.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Behat是一个基于**行为驱动开发**（**BDD**）概念的开源免费测试框架。包括Behat在内的BDD框架的巨大好处是，大部分功能文档都被倾入到我们最终测试的实际用户故事中。也就是说，在某种程度上，文档本身就成为了测试。
- en: Setting up Behat
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Behat
- en: Much like PHPUnit, Behat can be installed as a tool and library. The tool version
    being the `.phar` archive, we can download it from the official GitHub repository,
    where the library version comes packed as a Composer package.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与PHPUnit类似，Behat可以安装为工具和库。工具版本是`.phar`存档，我们可以从官方GitHub存储库下载，而库版本则打包为Composer包。
- en: 'Assuming that we are using the Ubuntu 16.10 (Yakkety Yak) installation, installing
    the Behat as a tool is easy through the following commands:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在使用Ubuntu 16.10（Yakkety Yak）安装，通过以下命令安装Behat作为工具很容易：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This should give us the following output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们以下输出：
- en: '![](assets/5f379429-0c4c-42f1-ac5b-7c579c618288.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5f379429-0c4c-42f1-ac5b-7c579c618288.png)'
- en: 'Installing Behat as a library is as easy as running the following console command
    within the root of our project:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将Behat安装为库就像在项目的根目录中运行以下控制台命令一样简单：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This should give us the final output, as shown in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们最终的输出，如下截图所示：
- en: '![](assets/43752f4f-bd6e-462d-a7d7-15ffa43ff2dc.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/43752f4f-bd6e-462d-a7d7-15ffa43ff2dc.png)'
- en: The Behat library now becomes available under the `vendor/behat` directory and
    its console tool executable under the `vendor/bin/behat` file.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Behat库现在可以在`vendor/behat`目录下使用，其控制台工具可执行文件在`vendor/bin/behat`文件下。
- en: Setting up a sample application
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置一个示例应用程序
- en: The sample application for Behat testing is the same one we used for PHPUnit
    testing. We will merely extend it a bit by adding an extra class to it. Given
    the lack of any real "behavior" in our PHPUnit sample application, our extension
    here will include a dummy shopping cart functionality.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Behat测试的示例应用程序与我们用于PHPUnit测试的相同。我们只需通过添加一个额外的类来扩展它。鉴于我们的PHPUnit示例应用程序中没有任何真正的“行为”，我们的扩展将包括一个虚拟的购物车功能。
- en: 'Therefore, we will add the `src\Foggyline\Checkout\Model\Cart.php` file, with
    its content as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将添加`src\Foggyline\Checkout\Model\Cart.php`文件，其内容如下：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Leaving the original `index.php` file as it is, let''s go ahead and create
    the `index_2.php` file, with its content as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 保留原始的`index.php`文件不变，让我们继续创建`index_2.php`文件，其内容如下：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We won't actually be needing this one for testing, but it goes to show how our
    dummy cart can be utilized.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上不需要这个来进行测试，但这表明了我们的虚拟购物车如何被利用。
- en: Writing test
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: 'Getting started with writing the Behat tests requires grasping a few basic
    concepts, such as the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 开始编写Behat测试需要掌握一些基本概念，例如以下内容：
- en: '**Gherkin language**: This is a whitespace, business-readable, domain-specific
    language created for behavior descriptions, with the ability to be used for a
    project’s documentation and automated test at once through its *Given-When-Then*
    concept.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gherkin语言**：这是一个空格、易读的、特定于业务的语言，用于描述行为，具有通过其*Given-When-Then*概念同时用于项目文档和自动化测试的能力。'
- en: '**Features**: This is a list of one or more scenarios saved under the `*.feature`
    file. By default, the Behat features are to be stored and found in the `features/`
    directory relative to our project.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特性**：这是一个或多个场景的列表，保存在`*.feature`文件下。默认情况下，Behat特性应存储在与我们的项目相关的`features/`目录中。'
- en: '**Scenarios**: These are the core Gherkin structures, consisting of one or
    more steps.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景**：这些是核心的Gherkin结构，由一个或多个步骤组成。'
- en: '**Steps**: These are also known as *Givens*, *Whens*, and *Thens.* Indistinguishable
    to Behat, they should be distinguishable to developers as they are carefully selected
    for their purpose. The *Given* steps put the system in a known state, prior to any
    user interaction. The *When* steps describe the key action that the user performs.
    The *Then* step observes the outcomes.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤**：这些也被称为*Givens*、*Whens*和*Thens*。对于Behat来说，它们应该是不可区分的，但对于开发人员来说，它们应该是为了特定目的而精心选择的。*Given*步骤将系统置于已知状态，然后进行任何用户交互。*When*步骤描述用户执行的关键操作。*Then*步骤观察结果。'
- en: With these in mind, let's go ahead and write and kick off our Behat tests.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些想法，让我们继续编写并启动我们的Behat测试。
- en: The `vendor\phpunit\phpunit\src\Framework\Assert\Functions.php` file contains
    an extensive list of `asert*` function declarations, such as `assertEquals()`,
    `assertContains()`, `assertLessThan()`, and others, totaling to over 90 different
    assert functions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`vendor\phpunit\phpunit\src\Framework\Assert\Functions.php`文件包含了大量的`asert*`函数声明，比如`assertEquals()`，`assertContains()`，`assertLessThan()`等，总共超过90个不同的断言函数。'
- en: 'Within the root of our project directory, if we run the `behat --init` console
    command, it will generate a `features/` directory, and, within it, a `features/bootstrap/FeatureContext.php`
    file with the following content:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们项目目录的根目录下，如果我们运行`behat --init`控制台命令，它将生成一个`features/`目录，并在其中生成一个`features/bootstrap/FeatureContext.php`文件，内容如下：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The newly created `features/` directory is where we write our tests. Ignoring
    the newly generated `FeatureContext` for the moment, let''s go ahead and create
    our first `.feature`. As we mentioned earlier, Behat tests are written in a special
    format called **Gherkin**. Let''s go ahead and write down our `features/checkout-cart.feature`
    file as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的`features/`目录是我们编写测试的地方。暂时忽略新生成的`FeatureContext`，让我们继续创建我们的第一个`.feature`。正如我们之前提到的，Behat测试是用一种特殊格式称为**Gherkin**编写的。让我们继续编写我们的`features/checkout-cart.feature`文件如下：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can see the `Given`, `When`, and `Then` keywords being put to use. However, there are
    also several occurrences of `And`. When there are several `Given`, `When`, and
    `Then `steps, we are free to use additional keywords such as `And` or `But` to
    flag a step, thus allowing our Scenario to be read more fluently. Behat does not
    differentiate any of these keywords; they are only meant to be differentiated
    and experienced by the developer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`Given`，`When`和`Then`关键字被使用。然而，也有几个`And`的出现。当有几个`Given`，`When`和`Then`步骤时，我们可以自由使用额外的关键字，比如`And`或`But`来标记一个步骤，从而使我们的场景更流畅地阅读。Behat不区分这些关键字；它们只是为了开发者进行区分和体验。
- en: 'Now, we can update our `FeatureContext` class with the tests, that is, steps,
    from `checkout-cart.feature`. All it takes is to run the following command, and
    the Behat tool will do this for us:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新我们的`FeatureContext`类与来自`checkout-cart.feature`的测试，也就是步骤。只需要运行以下命令，Behat工具就会为我们完成这个过程：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This should give us the following output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们以下输出：
- en: '![](assets/2a34934f-93ba-4ab4-b84c-53f756ab8238.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2a34934f-93ba-4ab4-b84c-53f756ab8238.png)'
- en: 'After executing this command, Behat automatically appends all the missing step
    methods into our `FeatureContext` class, which now looks like the following code
    block:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，Behat会自动将所有缺失的步骤方法附加到我们的`FeatureContext`类中，现在看起来像以下代码块：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we need to go in and edit these stub methods to reflect on the classes
    we are testing this behavior against. This means replacing all of the `throw new
    PendingException()` expressions with the proper logic and assertions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要进入并编辑这些存根方法，以反映我们正在针对的类的行为。这意味着用适当的逻辑和断言替换所有的`throw new PendingException()`表达式：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note the use of the PHPUnit framework for asserting. Using Behat does not mean
    we have to stop using the PHPUnit library. It would be a shame not to reuse the
    wast number of the assert functions available in PHPUnit. Adding it to the project
    is easy, as shown in the following line of code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用PHPUnit框架进行断言。使用Behat并不意味着我们必须停止使用PHPUnit库。不重用PHPUnit中可用的大量断言函数将是一种遗憾。将其添加到项目中很容易，如下代码所示：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Executing tests
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行测试
- en: 'Once we sort out all of the stub methods within the `features\bootstrap\FeatureContext.php`
    file, we can simply run the `behat` command in our project root to execute tests.
    This should give us the following output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们解决了`features\bootstrap\FeatureContext.php`文件中的所有存根方法，我们只需在项目根目录中运行`behat`命令来执行测试。这应该给我们以下输出：
- en: '![](assets/44c110d7-c8bc-4560-9bbc-aec1b47d8a2f.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/44c110d7-c8bc-4560-9bbc-aec1b47d8a2f.png)'
- en: The output indicates a total of 2 scenarios and 14 different steps, all of which
    are confirmed to be working.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明一共有2个场景和14个不同的步骤，所有这些步骤都经过确认是有效的。
- en: phpspec
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: phpspec
- en: Like Behat, **phpspec** is an open source and free testing framework based on
    the notion of BDD. However, its approach to testing is quite different than that
    of Behat; we may even say it sits somewhere in the middle of PHPUnit and Behat.
    Unlike Behat, phpspec does not use the Gherkin format stories to describe its
    tests. Doing so, phpspec shifts its focus on internal, rather than external application
    behavior. Much like PHPUnit, phpspec allows us to instantiate objects, call its
    methods, and perform various assertions on the results. The part where it differs
    is in its "think of specification", and not of "think of test" approach.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 像Behat一样，**phpspec**是一个基于BDD概念的开源免费测试框架。然而，它的测试方法与Behat大不相同；我们甚至可以说它处于PHPUnit和Behat之间的某个位置。与Behat不同，phpspec不使用Gherkin格式的故事来描述它的测试。这样做，phpspec将重点放在内部应用行为上，而不是外部行为。与PHPUnit类似，phpspec允许我们实例化对象，调用它的方法，并对结果进行各种断言。它与其他地方的不同之处在于它的“考虑规范”，而不是“考虑测试”的方法。
- en: Setting up phpspec
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置phpspec
- en: Much like PHPUnit and Behat, phpspec can be installed as a tool and a library.
    The tool version being the `.phar` archive, we can download it from the official
    GitHub repository, whereas the library version comes packed as a Composer package.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与PHPUnit和Behat一样，phpspec可以作为一个工具和一个库安装。工具版本是`.phar`存档，我们可以从官方GitHub存储库下载它，而库版本则打包为Composer包。
- en: 'Assuming that we are using the Ubuntu 16.10 (Yakkety Yak) installation, installing
    phpspec as a tool is easy, as shown in the following commands:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用的是Ubuntu 16.10（Yakkety Yak）安装，安装phpspec作为一个工具很容易，如下所示的命令：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This should give us the following output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们以下输出：
- en: '![](assets/ef2066ec-088b-48de-b2a5-7206e8191db5.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ef2066ec-088b-48de-b2a5-7206e8191db5.png)'
- en: 'Installing phpspec as a library is as easy as running the following console
    command within the root of our project:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将phpspec安装为库就像在项目的根目录中运行以下控制台命令一样容易：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This should give us the final output, which looks like the following screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们最终的输出，看起来像以下的截图：
- en: '![](assets/24ee6529-fe86-49f2-9f22-3870641305eb.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/24ee6529-fe86-49f2-9f22-3870641305eb.png)'
- en: The phpspec library now becomes available under the `vendor/phpspec` directory
    and its console tool is executable under the `vendor/bin/phpspec` file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: phpspec库现在可以在`vendor/phpspec`目录下使用，并且其控制台工具可以在`vendor/bin/phpspec`文件下执行。
- en: Writing test
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: 'Getting started with writing phpspec tests requires grasping a few basic concepts,
    such as the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 开始编写phpspec测试需要掌握一些基本概念，例如：
- en: '**The it_*() and its_*() methods**: This object behavior is made up of individual
    examples, each one being flagged with the `it_*()` or `its_*()` methods. We can
    have one or more of these methods defined per single specification. Each defined
    method gets triggered when a test is run.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**it_*()和its_*()方法**：这个对象行为由单个示例组成，每个示例都标有`it_*()`或`its_*()`方法。我们可以在单个规范中定义一个或多个这些方法。每个定义的方法在运行测试时都会触发。'
- en: '**Matchers methods**: These are analogous to assertions in PHPUnit. They describe
    how an object should behave.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匹配器方法**：这些类似于PHPUnit中的断言。它们描述了对象应该如何行为。'
- en: '**Object construction methods**: Every object we describe in phpspec is not
    a separate variable, but is `$this`. Sometimes, however, getting the proper `$this` variable
    requires managing constructor parameters. This is where the `beConstructedWith()`, `beConstructedThrough()`, `let()`,
    and `letGo()` methods come in handy.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象构造方法**：我们在phpspec中描述的每个对象都不是一个单独的变量，而是`$this`。然而，有时获取适当的`$this`变量需要管理构造函数参数。这就是`beConstructedWith()`、`beConstructedThrough()`、`let()`和`letGo()`方法派上用场的地方。'
- en: '**The let() method**: This runs before each example.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**let()方法**：这在每个示例之前运行。'
- en: '**The letGo() method**: This runs after each example.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**letGo()方法**：这在每个示例之后运行。'
- en: 'The matchers are likely something we will have most contact with, so it is
    worth knowing there are several different matchers in phpspec, all of which implement
    the `Matcher` interface declared in the `src\PhpSpec\Matcher\Matcher.php` file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配器可能是我们接触最多的内容，因此值得知道phpspec中有几种不同的匹配器，它们都实现了`src\PhpSpec\Matcher\Matcher.php`文件中声明的`Matcher`接口：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using the `phpspec describe` command, we can create a specification for either
    one of the existing or new concrete classes we are yet to write. Since we already
    have our project set, let's go ahead and generate a specification for our `Cart`
    and `Product` classes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`phpspec describe`命令，我们可以为我们即将编写的现有或新的具体类之一创建规范。由于我们已经设置了项目，让我们继续为我们的`Cart`和`Product`类生成规范。
- en: 'We will do so by running the following two commands within the root directory
    of our project:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在项目的根目录中运行以下两个命令来实现：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first command generates the `spec/Foggyline/Checkout/Model/CartSpec.php`
    file, with its initial content as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条命令生成了`spec/Foggyline/Checkout/Model/CartSpec.php`文件，其初始内容如下：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The second command generates the `spec/Foggyline/Catalog/Model/ProductSpec.php`
    file, with its initial content as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条命令生成了`spec/Foggyline/Catalog/Model/ProductSpec.php`文件，其初始内容如下：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The generated `CartSpec` and `ProductSpec` classes are nearly identical. The difference
    lies in the concrete classes they reference through the `shouldHaveType()` method
    call. Moving forward, we will try to write a few simple tests only for the `Cart`
    and `Product` models. That being said, let''s go ahead and modify our `CartSpec`
    and `ProductSpec` classes to reflect upon the use of matchers: the `it_*()` and
    `its_*()` functions.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`CartSpec`和`ProductSpec`类几乎相同。区别在于它们通过`shouldHaveType()`方法调用引用的具体类。接下来，我们将尝试仅为`Cart`和`Product`模型编写一些简单的测试。也就是说，让我们继续修改我们的`CartSpec`和`ProductSpec`类，以反映匹配器的使用：`it_*()`和`its_*()`函数。
- en: 'We will modify the `spec\Foggyline\Checkout\Model\CartSpec.php` file with the
    following content:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下内容修改`spec\Foggyline\Checkout\Model\CartSpec.php`文件：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will modify the `spec\Foggyline\Catalog\Model\ProductSpec.php` file with
    the following content:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改`spec\Foggyline\Catalog\Model\ProductSpec.php`文件，内容如下：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we are making use of the `let()` method, as it triggers before any of
    the `it_*()` or `its_*()` methods are executed. Within the `let()` method, we
    are calling `beConstructedWith()` with arguments we would normally pass to a `new
    Product(...)` expression. This builds our product instance, and allows all of the
    `it_*()` or `its_*()` methods to execute successfully.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用`let()`方法，因为它会在任何`it_*()`或`its_*()`方法执行之前触发。在`let()`方法中，我们使用通常传递给`new
    Product(...)`表达式的参数调用`beConstructedWith()`。这样就构建了我们的产品实例，并允许所有`it_*()`或`its_*()`方法成功执行。
- en: Check out [http://www.phpspec.net/en/stable/manual/introduction.html](http://www.phpspec.net/en/stable/manual/introduction.html)
    for more information on the advanced phpspec concepts.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[http://www.phpspec.net/en/stable/manual/introduction.html](http://www.phpspec.net/en/stable/manual/introduction.html)以获取有关高级phpspec概念的更多信息。
- en: Executing tests
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行测试
- en: 'Running only a `phpspec run` command at this point will likely fail with something
    like a class ... does not exist message, because phpspec assumes a PSR-0 mapping
    by default. To be able to work with the application we have done so far, we need
    to tell phpspec to include our `src/Foggyline/*` classes. We can do so either
    through a `phpspec.yml` configuration file, or using the `--bootstrap` option.
    Since we have already created the `autoload.php` file, let''s go ahead and run phpspec
    by bootstrapping this file as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此时仅运行`phpspec run`命令可能会失败，并显示类...不存在的消息，因为phpspec默认假定存在PSR-0映射。为了能够使用到目前为止我们所做的应用程序，我们需要告诉phpspec包括我们的`src/Foggyline/*`类。我们可以通过`phpspec.yml`配置文件或使用`--bootstrap`选项来实现。由于我们已经创建了`autoload.php`文件，让我们继续通过引导该文件来运行phpspec：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This generates the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![](assets/b59deaed-e5a6-4198-a326-81ec14e65c38.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b59deaed-e5a6-4198-a326-81ec14e65c38.png)'
- en: 'We have involved these two specs using `phpspec describe` on the existing class.
    We could easily pass on the non-existing class name to the same command, as per
    the following example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`phpspec describe`命令涉及了这两个规范现有的类。我们可以轻松地将不存在的类名传递给相同的命令，如下例所示：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `Guest\Cart` class does not really exist in our `src/` directory. phpspec
    has no trouble creating a `spec/Foggyline/Checkout/Model/Guest/CartSpec.php` specification
    file, just like it did for `Cart` and `Product`. However, running the phpspec
    describe now raises a class ... does not exist error message, along with the interactive
    generator, as per the following output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Guest\Cart`类实际上并不存在于我们的`src/`目录中。phpspec创建`spec/Foggyline/Checkout/Model/Guest/CartSpec.php`规范文件时没有问题，就像它为`Cart`和`Product`做的那样。然而，现在运行phpspec描述会引发一个类...不存在的错误消息，以及交互式生成器，如下输出所示：'
- en: '![](assets/eebb8e02-8603-49e6-83d0-34ea130bd066.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/eebb8e02-8603-49e6-83d0-34ea130bd066.png)'
- en: 'As a result, the `src\Foggyline\Checkout\Model\Guest\Cart.php` file is additionally
    generated with the following content:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`src\Foggyline\Checkout\Model\Guest\Cart.php`文件还会生成，内容如下：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'While all of these are simple examples, it goes to show that phpspec works
    both ways:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些都是简单的例子，但它表明phpspec可以双向工作：
- en: Creating specifications based on existing concrete classes
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据现有具体类创建规范
- en: Generating concrete classes based on a specification
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据规范生成具体类
- en: 'Running our test now should give us the following output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行我们的测试应该给我们以下输出：
- en: '![](assets/76813f42-6a63-4d83-8854-b19eb771672d.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/76813f42-6a63-4d83-8854-b19eb771672d.png)'
- en: 'Now, lets''s deliberately fail a test by changing the `its_title_should_be_like()`
    method of `spec\Foggyline\Catalog\Model\ProductSpec.php` into the following line
    of code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们故意通过将`spec\Foggyline\Catalog\Model\ProductSpec.php`的`its_title_should_be_like()`方法更改为以下代码来失败一个测试：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Running the test now should give us the following output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行测试应该给我们以下输出：
- en: '![](assets/1a5261f7-36c4-4c25-9872-1793b9ebed46.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1a5261f7-36c4-4c25-9872-1793b9ebed46.png)'
- en: There is much more to be said about phpspec. Things such as Stubs, Mocks, Spies,
    templates, and extensions further enrich our phpspec testing experience. This
    section, however, focuses on the basics to get us started.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 关于phpspec还有很多要说的。像存根、模拟、间谍、模板和扩展等东西进一步丰富了我们的phpspec测试体验。然而，本节重点介绍了基础知识，以便让我们开始。
- en: jMeter
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jMeter
- en: The Apache jMeter is a free and open source application designed for load and
    performance testing. The functionality of jMeter extends across many different
    applications, servers, and protocol types. In the context of web applications,
    we might be tempted to compare it to the browser. However, jMeter works with HTTP
    and https at a protocol level. It does not render HTML or execute JavaScript.
    Although jMeter is primarily a GUI application, it can easily be installed and
    have its tests run in console mode. This makes it a convenient tool of choice
    for quickly building our tests in GUI mode, and then running them on a server
    console later on.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Apache jMeter是一个用于负载和性能测试的免费开源应用程序。jMeter的功能跨越了许多不同的应用程序、服务器和协议类型。在Web应用程序的上下文中，我们可能会倾向于将其与浏览器进行比较。然而，jMeter在协议级别上使用HTTP和https。它不渲染HTML或执行JavaScript。虽然jMeter主要是一个GUI应用程序，但它可以轻松安装并在控制台模式下运行其测试。这使得它成为一个方便的选择工具，可以在GUI模式下快速构建我们的测试，然后稍后在服务器控制台上运行它们。
- en: 'Assuming that we are using the Ubuntu 16.10 (Yakkety Yak) installation, installing
    jMeter as a tool is easy, as shown in the following command line:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用Ubuntu 16.10（Yakkety Yak）安装，安装jMeter作为工具很容易，如下命令行所示：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, this might not give us the latest version of jMeter, in which case,
    we can get one from the official jMeter download page ([http://jmeter.apache.org/download_jmeter.cgi](http://jmeter.apache.org/download_jmeter.cgi)):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能不会给我们jMeter的最新版本，如果是这种情况，我们可以从官方jMeter下载页面([http://jmeter.apache.org/download_jmeter.cgi](http://jmeter.apache.org/download_jmeter.cgi))获取一个版本：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Using this second method of installation, we will find the jMeter executable
    at `apache-jmeter-3.2/bin/jmeter`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种第二种安装方法，我们将在`apache-jmeter-3.2/bin/jmeter`找到jMeter可执行文件。
- en: Writing test
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: Throughout this chapter, we used a simple project with a few classes in the `src/Foggyline` directory
    to demonstrate the use of PHPUnit, Behat, and phpspec testing. Those, however,
    can't quite serve the purpose of this type of testing. Since we don't have any
    HTML pages to showcase in the browser, our focus with jMeter is on kicking off
    a simple built-in web test plan in order to understand its components and how
    we can run it later on.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了一个简单的项目，在`src/Foggyline`目录中有几个类，以演示如何使用PHPUnit、Behat和phpspec进行测试。然而，这些测试无法完全满足这种类型的测试需求。由于我们没有任何HTML页面在浏览器中展示，我们使用jMeter的重点是启动一个简单的内置Web测试计划，以了解其组件以及如何稍后运行它。
- en: 'Writing jMeter tests for web applications requires a basic understanding of
    several key concepts, which are as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为Web应用程序编写jMeter测试需要对几个关键概念有基本的理解，这些概念如下：
- en: '**Thread Group**: This defines a pool of users who execute a specific test
    case against our web server. The GUI allows us to control the several Thread Group
    options, as shown in the following screenshot:![](assets/2eea3707-2530-4ab6-951a-343829a39dbb.png)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程组**：这定义了一组用户，他们针对我们的Web服务器执行特定的测试用例。GUI允许我们控制几个线程组选项，如下截图所示：![](assets/2eea3707-2530-4ab6-951a-343829a39dbb.png)'
- en: '**HTTP Request Defaults**: This sets the default values that our HTTP Request
    controllers use. The GUI allows us to control the several HTTP Request Defaults
    options, as shown in the following screenshot:![](assets/74b84049-bc01-4933-b3cb-206566e9b0bd.png)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP请求默认值**：这设置了我们的HTTP请求控制器使用的默认值。GUI允许我们控制几个HTTP请求默认选项，如下截图所示：![](assets/74b84049-bc01-4933-b3cb-206566e9b0bd.png)'
- en: '**HTTP Request**: This sends the HTTP/HTTPS request to a web server. The GUI
    allows us to control the several HTTP Request options, as shown in the following
    screenshot:![](assets/3bcaef6d-9709-4d6a-a590-e845d143232f.png)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP请求**：这将HTTP/HTTPS请求发送到Web服务器。GUI允许我们控制几个HTTP请求选项，如下截图所示：![](assets/3bcaef6d-9709-4d6a-a590-e845d143232f.png)'
- en: '**HTTP Cookie Manager**: This stores and sends cookies, just like a web browser
    does. The GUI allows us to control the several HTTP Cookie Manager options, as
    shown in the following screenshot:![](assets/7e73cd63-0927-4f0e-8d4d-6d52285cd564.png)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP Cookie管理器**：这将存储和发送cookie，就像Web浏览器一样。GUI允许我们控制几个HTTP Cookie管理器选项，如下面的屏幕截图所示：![](assets/7e73cd63-0927-4f0e-8d4d-6d52285cd564.png)'
- en: '**HTTP Header Manager**: This adds or overrides HTTP request headers. The GUI
    allows us to control the several HTTP Header Manager options, as shown in the
    following screenshot:![](assets/4207e9af-8c39-469f-9d06-58d70086b159.png)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP头管理器**：这将添加或覆盖HTTP请求头。GUI允许我们控制几个HTTP头管理器选项，如下面的屏幕截图所示：![](assets/4207e9af-8c39-469f-9d06-58d70086b159.png)'
- en: '**Graph Results**: This generates a graph with all the sample times plotted
    out. The GUI allows us to control the several Graph Results options, as shown
    in the following screenshot:![](assets/6bb97a85-ff3e-46ab-ad0b-c237b2d243e8.png)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形结果**：这将生成一个图表，显示出所有样本时间。GUI允许我们控制几个图形结果选项，如下面的屏幕截图所示：![](assets/6bb97a85-ff3e-46ab-ad0b-c237b2d243e8.png)'
- en: We should never use the Graph Results listener component during production load
    tests as it consumes a lot of memory and CPU resources.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产负载测试期间，我们不应该使用图形结果监听器组件，因为它会消耗大量内存和CPU资源。
- en: 'The great thing about jMeter is that it already provides several different
    test plan templates. We can easily generate a Web Test Plan simply by following
    these steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: jMeter的一个很棒的地方是它已经提供了几种不同的测试计划模板。我们可以通过以下步骤轻松生成Web测试计划：
- en: Click on the File | Templates... menu under the main application menu, as shown
    here:![](assets/5bd910de-fbc2-4d8b-80cc-b51bac504e64.png)
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击主应用程序菜单下的“文件” | “模板...”菜单，如下所示：![](assets/5bd910de-fbc2-4d8b-80cc-b51bac504e64.png)
- en: 'This in turn triggers the Templates selection screen:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将触发“模板选择”屏幕：
- en: '![](assets/a8bf6e16-7286-4ceb-b0ec-d89552aaf584.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a8bf6e16-7286-4ceb-b0ec-d89552aaf584.png)'
- en: Clicking on the Create button should kick off a new test plan, as shown in the
    following screenshot:![](assets/56d47f1a-24c4-4d61-8e5e-2b150e90c8ed.png)
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“创建”按钮应该启动一个新的测试计划，如下面的屏幕截图所示：![](assets/56d47f1a-24c4-4d61-8e5e-2b150e90c8ed.png)
- en: 'While the test is just fine as it is, let''s go ahead and change a few things
    before we run it:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然测试本身已经很好了，但在运行之前让我们继续做一些修改：
- en: Right-click on View Results Tree and click on Remove.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击“查看结果树”，然后单击“删除”。
- en: Right-click on build-web-test-plan and Add | Listener | Graph Results, then set Filename
    to `jmeter-result-tests.csv`, as follows:![](assets/279110e8-eb42-481d-8e62-4de00d400eaf.png)
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击“build-web-test-plan”，然后选择“添加” | “监听器” | “图形结果”，然后将“文件名”设置为`jmeter-result-tests.csv`，如下所示：![](assets/279110e8-eb42-481d-8e62-4de00d400eaf.png)
- en: Click on Scenario 1 and edit Loop Count to value `2`:![](assets/0cbe46a8-b7b1-4dbf-8509-52a74c08acfa.png)
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“场景1”，然后将“循环计数”编辑为值`2`：![](assets/0cbe46a8-b7b1-4dbf-8509-52a74c08acfa.png)
- en: With these modifications in place, let's click on File | Save under the main
    menu and name our test `web-test-plan.jmx`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行这些修改后，让我们单击主菜单下的“文件” | “保存”，并将我们的测试命名为`web-test-plan.jmx`。
- en: Out test is now ready to be run. While the test itself won't be load testing
    our own server in this case, rather [example.org](http://example.org), the value
    of this exercise lies in understanding how to build the test via a GUI tool, run
    it via console, and generate the test results log for later inspection.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试现在已经准备就绪。虽然这个测试本身不会在这种情况下对我们自己的服务器进行负载测试，而是[example.org](http://example.org)，但这个练习的价值在于理解如何通过GUI工具构建测试，通过控制台运行测试，并生成测试结果日志以供以后检查。
- en: Executing tests
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行测试
- en: 'Running a jMeter test via a console is quite easy, as the following command
    shows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过控制台运行jMeter测试非常容易，如下命令所示：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `-n` parameter, also works with `--nongui`, stands for run JMeter in nongui
    mode. Whereas,, the `-t` parameter that also works with `--testfile`, stands for the
    jmeter test(.jmx) file to run.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`-n`参数，也适用于`--nongui`，表示在nongui模式下运行JMeter。而`-t`参数，也适用于`--testfile`，表示要运行的jmeter测试(.jmx)文件。'
- en: 'The resulting output should look the following screenshot:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出应该如下屏幕截图所示：
- en: '![](assets/6259fa47-a861-47f1-b4c5-bd77f2737c1f.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6259fa47-a861-47f1-b4c5-bd77f2737c1f.png)'
- en: 'A quick look into the `jmeter-result-tests.csv` file reveals the structure
    and data captured:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看`jmeter-result-tests.csv`文件，可以看到捕获的结构和数据：
- en: '![](assets/7e4cb059-f943-48c3-8350-2ce468321f3c.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7e4cb059-f943-48c3-8350-2ce468321f3c.png)'
- en: While the example demonstrated here relies on a default test plan with some
    minor modifications, the overall capabilities of Apache jMeter can enrich the
    whole testing experience by multiple factors.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里演示的示例依赖于带有一些小修改的默认测试计划，但Apache jMeter的整体能力可以通过多种因素丰富整个测试体验。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we very briefly scratched the surface of some of the
    most popular types of PHP application testing. The test driven development (TDD)
    and behaviour driven development comprise of a very large and important chunk
    of it. Luckily, the PHP ecosystem provides two excellent frameworks, PHPUnit and
    Behat, which makes these types of testing easy to work with. Although fundamentally
    different, PHPUnit and Behat complete each other in a sense that they ensure our
    application is tested both from the smallest unit of functionality to a logical outcome
    of overall functionality point of view. phpspec on the other hand seems to sit
    in the middle of the two, trying to address these two challenges in its own uniform
    way. We further glossed over Apache jMeter, seeing how easy it is to kick off
    a performance test with a simple web test plan. This allows us to take an important
    step forward and confirms that our application not only works, but works fast
    enough to meet user expectations.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们非常简要地涉及了一些最流行的PHP应用程序测试类型。测试驱动开发（TDD）和行为驱动开发包括其中非常重要的部分。幸运的是，PHP生态系统提供了两个优秀的框架，PHPUnit和Behat，使这些类型的测试变得容易处理。尽管在根本上不同，PHPUnit和Behat在某种意义上互补，它们确保我们的应用程序在从最小的功能单元到整体功能的逻辑结果方面都经过了测试。另一方面，phpspec似乎处于这两者之间，试图以自己的统一方式解决这两个挑战。我们还简要介绍了Apache
    jMeter，看到了使用简单的Web测试计划启动性能测试有多么容易。这使我们能够迈出重要的一步，并确认我们的应用程序不仅能够正常工作，而且能够快速到达用户的期望。
- en: Moving forward, we will take a closer look at the debugging, tracing, and profiling
    PHP applications.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更仔细地研究调试、跟踪和分析PHP应用程序。
