- en: Chapter 7. Building an Asynchronous Microservice Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。构建异步微服务架构
- en: In this chapter, we will build an application consisting of a set of small and
    independent components that communicate with each other over network protocols.
    Often, these so-called **Microservice architectures** are built using HTTP-based
    communication procotols, often in the form of RESTful APIs, which we've already
    implemented in [Chapter 5](ch05.html "Chapter 5.  Creating a RESTful Web Service"),
    *Creating a RESTful Web Service*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个由一组小型独立组件组成的应用程序，这些组件通过网络协议进行通信。通常，这些所谓的**微服务架构**是使用基于HTTP的通信协议构建的，通常以RESTful
    API的形式，我们已经在[第5章](ch05.html "第5章。创建RESTful Web服务")中实现了*创建RESTful Web服务*。
- en: 'Instead of focusing on REST, in this chapter we will explore an alternative
    communication protocol that focuses on asynchronicity, loose coupling, and high
    performance: **ZeroMQ**. We will use ZeroMQ to build a simple**checkout service**
    for an (entirely fictional) e-commerce scenario that will handle a wide range
    of concerns, beginning with e-mail messaging, order processing, inventory management,
    and more.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一种关注异步性、松散耦合和高性能的替代通信协议：**ZeroMQ**，而不是专注于REST。我们将使用ZeroMQ为一个（完全虚构的）电子商务场景构建一个简单的**结账服务**，该服务将处理广泛的问题，从电子邮件消息、订单处理、库存管理等等。
- en: The target architecture
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标架构
- en: 'The central service of our Microservice architecture will be the checkout service.
    This service will offer an API for a checkout process that is common to many e-commerce
    systems. For each checkout process, we will require the following input data:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的微服务架构的中心服务将是结账服务。该服务将为许多电子商务系统共有的结账流程提供API。对于每个结账流程，我们将需要以下输入数据：
- en: A **cart** that can contain an arbitrary number of articles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以包含任意数量的文章的**购物车**
- en: The customer's **contact data**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户的**联系数据**
- en: 'The checkout service will then be responsible for executing the actual checkout
    process, which will involve a number of additional services, each handling a single
    step or concern of the checkout process:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，结账服务将负责执行实际的结账流程，其中涉及多个额外的服务，每个服务处理结账流程的单个步骤或关注点：
- en: Our fictional e-commerce venture will handle physical goods (or more abstract
    goods, of which we can only have a limited quantity in stock). So, for each article
    in a cart, the checkout service will need to ensure that the desired quantity
    of said article is actually in stock, and if possible, reduce the available stock
    by that amount. This will be the responsibility of the **inventory service**.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们虚构的电子商务企业将处理实物商品（或更抽象的商品，我们只能有限数量地存货）。因此，对于购物车中的每件商品，结账服务将需要确保所需数量的商品实际上有库存，并且如果可能的话，减少相应数量的可用库存。这将是**库存服务**的责任。
- en: After successfully completing a checkout process, the user needs to be notified
    via e-mail about the successful checkout. This will be the responsibility of the
    **mailing service**.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功完成结账流程后，用户需要通过电子邮件收到有关成功结账的通知。这将是**邮件服务**的责任。
- en: Also, after completing the checkout process, the order has to be forwarded to
    a shipping service that starts the shipping for this order.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在完成结账流程后，订单必须转发给一个开始为该订单发货的运输服务。
- en: 'The following diagram shows a high-level view of the desired target architecture
    for this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了本章所需的目标架构的高层视图：
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, the focus will be on using ZeroMQ for implementing the communication
    patterns between the different services. We will not implement the entire business
    logic that would be required for such a checkout process to actually work (as
    you could very well fill another book with this). Instead, we will implement the
    actual services as simple stubs that offer the APIs that we want them to implement,
    but contain only a prototypical implementation of the actual business logic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，重点将放在使用ZeroMQ实现不同服务之间的通信模式上。我们不会实现实际的业务逻辑，这需要实际工作（因为您完全可以用另一本书来填补这部分）。相反，我们将实现实际服务作为提供我们希望它们实现的API的简单存根，但只包含实际业务逻辑的原型实现。
- en: '![The target architecture](graphics/image_07_001.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![目标架构](graphics/image_07_001.jpg)'
- en: The target architecture of our application
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的目标架构
- en: The labels beside the depicted interfaces (**RES** and **PUB**) are the different
    ZeroMQ socket types that you'll learn about in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图中所示接口旁边的标签（**RES**和**PUB**）是您将在本章中了解的不同ZeroMQ套接字类型。
- en: ZeroMQ patterns
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ZeroMQ模式
- en: In this chapter, you will learn about the basic communication patterns that
    are supported by ZeroMQ. Do not worry if all that sound a bit theoretical; you
    will implement all of these patterns yourself throughout the chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解ZeroMQ支持的基本通信模式。如果这些听起来有点理论化，不要担心；您将在整个章节中自己实现所有这些模式。
- en: Request/reply pattern
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求/回复模式
- en: The ZeroMQ library supports a variety of different communication patterns. For
    each of these, you will need different ZeroMQ socket types. The easiest communication
    pattern is the Request/reply pattern, in which a client opens an REQ socket and
    connects to a server listening on an REP socket. The client sends a request that
    is then replied to by the server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ZeroMQ库支持各种不同的通信模式。对于每种模式，您将需要不同的ZeroMQ套接字类型。最简单的通信模式是请求/回复模式，其中客户端打开一个REQ套接字并连接到监听REP套接字的服务器。客户端发送一个请求，然后服务器进行回复。
- en: '![Request/reply pattern](graphics/image_07_002.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![请求/回复模式](graphics/image_07_002.jpg)'
- en: ZeroMQ Request/Reply sockets
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ZeroMQ请求/回复套接字
- en: It's important to know that REQ and REP sockets are always *synchronous*. Each
    REQ socket can be sending requests to a single REP socket at a time, and more
    importantly, each REP socket can also only be connected to a single REQ socket
    at a time. The ZeroMQ library even enforces this on the protocol level and triggers
    errors when an REQ socket tries to receive new requests before replying to the
    current one. There are advanced communication patterns to work around this limitation
    that we'll work with later.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，REQ和REP套接字始终是*同步*的。每个REQ套接字一次只能向单个REP套接字发送请求，更重要的是，每个REP套接字也只能连接到单个REQ套接字。ZeroMQ库甚至在协议级别强制执行这一点，并在REQ套接字尝试在回复当前请求之前接收新请求时触发错误。我们将在以后使用高级通信模式来解决这个限制。
- en: Publish/subscribe pattern
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布/订阅模式
- en: The publish/subscribe pattern consists of a PUB socket on which messages can
    be published. To this socket, any number of SUB sockets can be connected. When
    a new message is published on a PUB socket, it will be forwarded to all connected
    SUB sockets.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 发布/订阅模式由一个PUB套接字组成，可以在其上发布消息。可以连接任意数量的SUB套接字到此套接字。当在PUB套接字上发布新消息时，它将转发到所有连接的SUB套接字。
- en: '![Publish/subscribe pattern](graphics/image_07_003.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![发布/订阅模式](graphics/image_07_003.jpg)'
- en: Publish/subscribe sockets
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 发布/订阅套接字
- en: Each subscriber in a PUB/SUB architecture needs to specify at least one subscription
    - a string that works as a filter for each message. Messages will be filtered
    by the publisher so that each subscriber only receives messages that they have
    subscribed to.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: PUB/SUB架构中的每个订阅者都需要指定至少一个订阅 - 一个作为每条消息过滤器的字符串。发布者将根据订阅者过滤消息，以便每个订阅者只接收他们订阅的消息。
- en: Publish/Subscribe works strictly in one direction. Publishers cannot receive
    messages from the subscribers, and subscribers cannot send messages back to the
    publishers. However, just as multiple SUB sockets can be connected to a single
    PUB socket, a single SUB socket can also be connected to multiple PUB sockets.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 发布/订阅严格单向工作。发布者无法从订阅者那里接收消息，订阅者也无法将消息发送回发布者。然而，就像多个SUB套接字可以连接到单个PUB套接字一样，单个SUB套接字也可以连接到多个PUB套接字。
- en: Push/pull pattern
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推/拉模式
- en: The push/pull pattern works similar to the publish/subscribe pattern. A PUSH
    socket is used to publish messages to any number of PULL sockets (just like with
    PUB/SUB, a single PULL sockets can also be connected to any number of PUSH sockets).
    In contrast to publish/subscribe patterns, however, each message that is sent
    on a PUSH socket is dispatched to only one of the connected PULL sockets. This
    behavior makes the PUSH/PULL patterns are ideal to implement worker pools that
    you can, for example, use to distribute tasks to any number of workers to process
    in parallel. Similarly, a PULL socket may also be used to collect results from
    any number of PUSH sockets (which may in turn be results that are sent back from
    a worker pool).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 推/拉模式与发布/订阅模式类似。PUSH套接字用于向任意数量的PULL套接字发布消息（就像PUB/SUB一样，单个PULL套接字也可以连接到任意数量的PUSH套接字）。然而，与发布/订阅模式相反，发送到PUSH套接字的每条消息只会分发到连接的PULL套接字中的一个。这种行为使得PUSH/PULL模式非常适合实现工作池，例如，您可以使用它来将任务分发给任意数量的工作者以并行处理。同样，PULL套接字也可以用于从任意数量的PUSH套接字收集结果（这可能是从工作池返回的结果）。
- en: Using a PUSH/PULL socket to distribute tasks to a worker pool and then using
    a second PUSH/PULL layer to collect results from that pool in a single socket
    is also called *fan-out/fan-in*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PUSH/PULL套接字将任务分发给工作池，然后使用第二个PUSH/PULL层从该池中收集结果到单个套接字中，也称为*扇出/扇入*。
- en: '![Push/pull pattern](graphics/image_07_004.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![推/拉模式](graphics/image_07_004.jpg)'
- en: Using PUSH and PULL sockets to implement a fan-out/fan-in architecture
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PUSH和PULL套接字实现扇出/扇入架构
- en: Bootstrapping the project
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导项目
- en: 'As usual, we will begin by bootstrapping our project for this chapter. For
    using the ZeroMQ library in PHP applications, you will need the **php-zmq extension**
    that you can install via PECL. You will also need the `libzmq-dev` package that
    contains the C header files for the ZeroMQ library. You can install it via your
    operating system''s package manager. The following commands will work on both
    Ubuntu and Debian Linux:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们将从为本章的项目进行引导开始。在PHP应用程序中使用ZeroMQ库，您将需要通过PECL安装的**php-zmq扩展**。您还需要包含ZeroMQ库的C头文件的`libzmq-dev`软件包。您可以通过操作系统的软件包管理器安装它。以下命令将在Ubuntu和Debian
    Linux上都适用：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As usual, we will be using composer to manage our PHP dependencies and Docker
    for managing the required system libraries. As our application will consist of
    multiple services that run in multiple processes, we will be working with multiple
    composer projects and multiple Docker images.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们将使用composer来管理我们的PHP依赖项，并使用Docker来管理所需的系统库。由于我们的应用程序将由多个在多个进程中运行的服务组成，我们将使用多个composer项目和多个Docker镜像。
- en: If you are using Windows and want to run your ZeroMQ/PHP applications natively
    without using Docker, you can download the ZeroMQ extension from the PECL website
    ([https://pecl.php.net/package/zmq/1.1.3/windows](https://pecl.php.net/package/zmq/1.1.3/windows))
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Windows，并希望在不使用Docker的情况下本地运行ZeroMQ/PHP应用程序，您可以从PECL网站（[https://pecl.php.net/package/zmq/1.1.3/windows](https://pecl.php.net/package/zmq/1.1.3/windows)）下载ZeroMQ扩展。
- en: 'All of our services will use the same software (PHP with the ZeroMQ extension
    installed). We''ll start by implementing the inventory service, but you will be
    able to use the same Docker image (or at least the same Dockerfile) for all services
    that we will be creating in this example. Start by creating an `inventory/Dockerfile`
    file in your project directory with the following contents:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的服务将使用相同的软件（安装了ZeroMQ扩展的PHP）。我们将从实现库存服务开始，但您将能够在本示例中创建的所有服务中使用相同的Docker镜像（或至少相同的Dockerfile）。首先，在项目目录中创建一个`inventory/Dockerfile`文件，内容如下：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You'll notice that we're also installing the `pcntl` and `ev` extensions. You've
    already worked with the `ev` extension in [Chapter 6](ch06.html "Chapter 6.  Building
    a Chat Application"), *Building a Chat Application*. It offers an asynchronous
    event loop that works well with the `react/zmq` library that we will be using
    later in this chapter. The `pcntl` extension offers some features that will help
    you control the process state of long-running PHP processes later on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们还安装了`pcntl`和`ev`扩展。您已经在[第6章](ch06.html "第6章。构建聊天应用程序")中使用过`ev`扩展，*构建聊天应用程序*。它提供了一个与我们稍后在本章中将使用的`react/zmq`库很好配合的异步事件循环。`pcntl`扩展提供了一些功能，将帮助您控制后续长时间运行的PHP进程的进程状态。
- en: To make life easier, you can also create a `docker-compose.yml` file in your
    project directory in order to use Docker compose to manage the multitude of containers
    in your application. We'll get to that once you have the first service that you
    can run in a container.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使生活更轻松，您还可以在项目目录中创建一个`docker-compose.yml`文件，以便使用Docker compose来管理应用程序中的众多容器。一旦您有了可以在容器中运行的第一个服务，我们将介绍这一点。
- en: Building the inventory service
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建库存服务
- en: We will start by implementing the inventory service, as it will use a simple
    request/reply pattern for communication and it does not have any other dependencies.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从实现库存服务开始，因为它将使用简单的请求/回复模式进行通信，而且没有其他依赖关系。
- en: Getting started with ZeroMQ REQ/REP sockets
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用ZeroMQ REQ/REP套接字
- en: 'Start by creating the service''s `composer.json` file in the `inventory/` directory:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在`inventory/`目录中创建服务的`composer.json`文件：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After creating the `composer.json` file, install the project's dependencies
    using the `composer install` command on a command line within the `inventory/`
    directory.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`composer.json`文件后，在`inventory/`目录中使用`composer install`命令来安装项目的依赖项。
- en: Let's start by creating a `server.php` file for the inventory. Just like the
    Ratchet application from [Chapter 6](ch06.html "Chapter 6.  Building a Chat Application"),
    *Building a Chat Application*, this file will later be our main server process
    - remember, in this example, we're not even using HTTP as a communication protocol,
    so there's no web server and no FPM involved anywhere.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先为库存创建一个`server.php`文件。就像[第6章](ch06.html "第6章。构建聊天应用程序")中的Ratchet应用程序一样，这个文件稍后将成为我们的主服务器进程
    - 请记住，在这个例子中，我们甚至没有使用HTTP作为通信协议，因此没有Web服务器，也没有FPM涉及到任何地方。
- en: 'The starting point of each ZeroMQ application is the context. The context stores
    all kind of states that the ZeroMQ library needs for maintaining sockets and communicating
    with other sockets. You can then use this context to create a new socket and bind
    this context to a port:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个ZeroMQ应用程序的起点是上下文。上下文存储了ZeroMQ库需要维护套接字和与其他套接字通信所需的各种状态。然后，您可以使用此上下文创建一个新的套接字，并将此上下文绑定到一个端口：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code creates a new ZeroMQ REP socket (a socket that can reply to requests)
    and binds this socket to a configurable TCP port (5557 by default). You can now
    receive messages on this socket and reply to them:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个新的ZeroMQ REP套接字（可以回复请求的套接字），并将此套接字绑定到可配置的TCP端口（默认为5557）。现在您可以在此套接字上接收消息并回复它们：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, this loop will poll infinitely for new messages and then respond
    to them. The socket's `recv()` method will block the script execution until a
    new message has been received (you can later use the `react/zmq` library to easily
    implement non-blocking sockets, but this will suffice for now).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个循环将无限期地轮询新消息，然后对其进行响应。套接字的`recv()`方法将阻塞脚本执行，直到接收到新消息（稍后您可以使用`react/zmq`库轻松实现非阻塞套接字，但现在这就足够了）。
- en: 'In order to test your ZeroMQ server, you can create a second file, `client.php`,
    in your `inventory/` directory in which you can use an REQ socket to send requests
    to the server:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试您的ZeroMQ服务器，您可以在`inventory/`目录中创建第二个文件`client.php`，在其中可以使用REQ套接字向服务器发送请求：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When your server script is running, you can simply run the `client.php` script
    to connect to the server's REP socket, send a request, and wait for the server's
    reply. Just like with the REP socket, the REQ socket's `recv` method will also
    block until a reply has been received from the server.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的服务器脚本正在运行时，您可以简单地运行`client.php`脚本来连接到服务器的REP套接字，发送请求，并等待服务器的回复。就像REP套接字一样，REQ套接字的`recv`方法也会阻塞，直到从服务器接收到回复。
- en: 'If you are using Docker compose to manage the multitude of containers in your
    development environment (currently, it''s only one, but there will be more), add
    the following section to your `docker-compose.yml` file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Docker compose来管理开发环境中的众多容器（目前只有一个，但将会有更多），请将以下部分添加到您的`docker-compose.yml`文件中：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After adding the inventory service to the `docker-compose.yml` configuration
    file, you can start the container by simply running the following command on a
    command line:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`docker-compose.yml`配置文件中添加库存服务后，您可以通过在命令行上运行以下命令来启动容器：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using JsonRPC for communication
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JsonRPC进行通信
- en: Now we have a server that can receive text messages from a client and then send
    responses back to that client. However, in order to build a working and maintainable
    Microservice architecture, we'll need some kind of protocol and format that these
    messages can follow and all services can agree upon. Often in Microservice architectures,
    this common denominator is HTTP, whose rich protocol semantics can be used to
    easily build REST web services. However, ZeroMQ as a protocol is much more low-level
    and does not concern itself with different request methods, headers, caching,
    and all the other features that come *for free* with HTTP.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个服务器，可以从客户端接收文本消息，然后将响应发送回该客户端。但是，为了构建一个可工作且易于维护的微服务架构，我们需要一种协议和格式，使这些消息可以遵循，并且所有服务都可以达成一致。在微服务架构中，这个共同点通常是HTTP，其丰富的协议语义可用于轻松构建REST
    Web服务。但是，ZeroMQ作为一种协议要低级得多，不涉及不同的请求方法、标头、缓存以及HTTP所附带的所有其他功能。
- en: 'Instead of a RESTful service, we will implement the inventory service as a
    simple **Remote Procedure Call** (**RPC**) service. A quick and easy format that
    can be used for this is JSON-RPC, which implements RPCs with JSON messages. Using
    JSON-RPC, a client can send a method call using the following JSON format:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将库存服务实现为一个简单的**远程过程调用**（**RPC**）服务，而不是一个RESTful服务。一个快速简单的格式是JSON-RPC，它使用JSON消息实现RPC。使用JSON-RPC，客户端可以使用以下JSON格式发送方法调用：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The server can then respond to this message using the following format:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器随后可以使用以下格式响应此消息：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or alternatively, when an error occurred during processing:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，当处理过程中发生错误时：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This protocol is relatively simple and we can easily implement it on top of
    ZeroMQ. For this, start by creating a new `Packt\Chp7\Inventory\JsonRpcServer`
    class. This server will need a ZeroMQ socket and also an object that provides
    the methods that clients should be able to invoke using RPCs:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协议相对简单，我们可以很容易地在ZeroMQ之上实现它。为此，首先创建一个新的`Packt\Chp7\Inventory\JsonRpcServer`类。这个服务器将需要一个ZeroMQ套接字，还需要一个对象，该对象提供客户端应该能够使用RPC调用的方法：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now implement a method that receives messages from the socket, tries
    to parse them as JSON-RPC messages, and invokes the respective method on the `$server`
    object and returns that method''s result value:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以实现一个方法，接收来自套接字的消息，尝试将它们解析为JSON-RPC消息，并调用`$server`对象上的相应方法，并返回该方法的结果值：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As in the previous example, this method will run infinitely and will process
    any number of requests. Now, let''s have a look at the `handleMessage` method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，这个方法将无限运行，并处理任意数量的请求。现在，让我们来看看`handleMessage`方法：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This method checks if the `$this->server` object has a callable method with
    the same name as the `method` property of the JSON-RPC request. If so, this method
    is invoked with the request's `param` property as arguments and the return value
    is incorporated into the JSON-RPC response.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法检查`$this->server`对象是否有一个与JSON-RPC请求的`method`属性相同的可调用方法。如果是，将使用请求的`param`属性作为参数调用此方法，并将返回值合并到JSON-RPC响应中。
- en: 'Currently, this method is still missing some basic exception handling. As a
    single unhandled exception, a fatal error can terminate the entire server process,
    so we need to be extra careful here. First, we need to make sure that the incoming
    message is really a valid JSON string:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个方法仍然缺少一些基本的异常处理。一个未处理的异常，一个致命错误可以终止整个服务器进程，所以我们在这里需要特别小心。首先，我们需要确保传入的消息确实是一个有效的JSON字符串：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Also, make sure that you catch anything that might be thrown from the actual
    service function. As we''re working with PHP 7, remember that regular PHP errors
    are now also thrown, so it''s important to not only catch exceptions, but errors
    as well. You can catch both exceptions and errors by using the `Throwable` interface
    in your `catch` clause:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保捕获可能从实际服务函数中抛出的任何异常。由于我们使用的是PHP 7，记住常规的PHP错误现在也会被抛出，因此不仅要捕获异常，还要捕获错误。您可以通过在`catch`子句中使用`Throwable`接口来捕获异常和错误：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can now continue by implementing the actual service containing the inventory
    service business logic. As we''ve spent a fair amount of time with low-level protocols
    until now, let''s recapitulate the requirements for this service: the inventory
    service manages the inventories of articles in stock. During the checkout process,
    the inventory service needs to check if the required amount of an article is in
    stock, and if possible, reduce the inventory amount by the given amount.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以继续实现包含库存服务业务逻辑的实际服务。由于我们到目前为止花了相当多的时间处理低级协议，让我们回顾一下这个服务的要求：库存服务管理库存中的文章。在结账过程中，库存服务需要检查所需文章的数量是否有库存，并在可能的情况下，减少给定数量的库存数量。
- en: 'We will implement this logic in the `Packt\Chp7\Inventory\InventoryService`
    class. Note that we''ll try to keep the example simple and manage our article
    inventories simply in-memory. In a production setup, you''d probably use a database
    management system for storing your article data:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`Packt\Chp7\Inventory\InventoryService`类中实现这个逻辑。请注意，我们将尝试保持示例简单，并简单地在内存中管理我们的文章库存。在生产环境中，您可能会使用数据库管理系统来存储文章数据：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, we're starting off with three articles with the article numbers
    `1000` to `1002`. The `checkArticle` function tests if the required amount of
    a given article is in stock. The `takeArticle` function attempts to reduce the
    amount of articles by the required amount, if possible. If this was successful,
    the function returns `true`. If the required amount is not in stock, or the article
    is not known at all, the function will return `false`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从文章编号`1000`到`1002`开始。`checkArticle`函数测试给定文章的所需数量是否有库存。`takeArticle`函数尝试减少所需数量的文章数量，如果可能的话。如果成功，函数返回`true`。如果所需数量不在库存中，或者根本不知道这篇文章，函数将返回`false`。
- en: 'We now have a class that implements a JSON-RPC server and another class containing
    the actual business logic for our inventory service. We can now put both of these
    classes together in our `server.php` file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个实现JSON-RPC服务器的类，另一个类包含我们库存服务的实际业务逻辑。我们现在可以将这两个类放在我们的`server.php`文件中一起使用：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To test this service, at least until you have a first version of the checkout
    service up and running, you can adjust the `client.php` script that you''ve created
    in the previous section to also send and receive JSON-RPC messages:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个服务，至少在您的结账服务的第一个版本运行起来之前，您可以调整在上一节中创建的`client.php`脚本，以便发送和接收JSON-RPC消息：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Each call of this script will remove two items of article #1001 from your inventory.
    In our example, we''re working with a locally managed inventory that is always
    initialized with four items of this article, so the first two invocations of the
    `client.php` script will return true as a result, and all subsequent invocations
    will return false.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用此脚本都会从库存中删除两件编号为＃1001的物品。在我们的例子中，我们使用的是一个在本地管理的库存，始终初始化为此文章的四件物品，因此`client.php`脚本的前两次调用将返回true作为结果，而所有后续调用将返回false。
- en: Making the inventory service multithreaded
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使库存服务多线程化
- en: Currently, the inventory service works in a single thread, and with a blocking
    socket. This means that it can handle only one request at a time; if a new request
    is received while other requests are being processed, the client will have to
    wait until all previous requests have finished processing. Obviously, this does
    not scale very well.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，库存服务在单个线程中运行，并且使用阻塞套接字。这意味着它一次只能处理一个请求；如果在处理其他请求时收到新请求，客户端将不得不等待直到所有先前的请求都完成处理。显然，这不是很好的扩展。
- en: In order to implement a server that can handle multiple requests in parallel,
    you can employ ZeroMQ's **ROUTER**/**DEALER** pattern. A ROUTER is a special kind
    of ZeroMQ socket that behaves very much like a regular REP socket, with the only
    difference being that multiple REQ sockets can connect to in parallel. Likewise,
    a DEALER socket is another kind of socket that is similar to an REQ socket, only
    that it can be connected to multiple REP sockets. This allows you to construct
    a load balancer that simply consists of one ROUTER and one DEALER socket that
    pipes packages from a set of multiple clients to a set of multiple servers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个可以并行处理多个请求的服务器，您可以使用ZeroMQ的**ROUTER**/**DEALER**模式。ROUTER是一种特殊类型的ZeroMQ套接字，行为非常类似于常规的REP套接字，唯一的区别是可以并行连接多个REQ套接字。同样，DEALER套接字是另一种类似于REQ套接字的套接字，唯一的区别是可以连接到多个REP套接字。这使您可以构建一个负载均衡器，它只包括一个ROUTER和一个DEALER套接字，将多个客户端的数据包传输到多个服务器。
- en: '![Making the inventory service multithreaded](graphics/image_07_005.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![使库存服务多线程化](graphics/image_07_005.jpg)'
- en: The ROUTER/DEALER pattern
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ROUTER/DEALER模式
- en: As PHP does not support multithreading (at least, not very well), we will resort
    to using multiple processes in this example. Our multithreaded server will consist
    of one master process that handles the ROUTER and DEALER sockets, and multiple
    worker processes that each work with one REP socket. To implement this, you can
    fork a number of worker processes using the `pcntl_fork` function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PHP不支持多线程（至少不是很好），在这个例子中我们将采用多进程。我们的多线程服务器将由一个处理ROUTER和DEALER套接字的主进程以及多个每个使用一个REP套接字的worker进程组成。要实现这一点，您可以使用`pcntl_fork`函数分叉多个worker进程。
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For the `pcntl_fork` function to work, you need the `pcntl` extension enabled.
    In nearly all distributions, this extension is enabled by default; in the Dockerfile
    that you have built in the previous section, it is also explicitly installed.
    If you compiled PHP yourself, you will need the -- `enable-pcntl` flag when calling
    the `configure` script.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`pcntl_fork`函数工作，您需要启用`pcntl`扩展。在几乎所有的发行版中，这个扩展默认是启用的；在您之前构建的Dockerfile中，它也被明确安装了。如果您自己编译PHP，那么在调用`configure`脚本时，您将需要`--enable-pcntl`标志。
- en: 'In this example, our inventory service will consist of multiple ZeroMQ sockets:
    first a multitude of worker processes, each listening on a RES socket that responds
    to requests, and a master process with each ROUTER and DEALER socket that accepts
    and dispatches these requests. Only the ROUTER socket will be visible to outside
    services and reachable via TCP; for all other sockets, we will use UNIX sockets
    for communicating - they are faster and not reachable via network.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的库存服务将由多个ZeroMQ套接字组成：首先是大量的worker进程，每个进程都监听一个RES套接字以响应请求，以及一个主进程，每个ROUTER和DEALER套接字都接受和分发这些请求。只有ROUTER套接字对外部服务可见，并且可以通过TCP到达；对于所有其他套接字，我们将使用UNIX套接字进行通信
    - 它们更快，且无法通过网络到达。
- en: 'Start by implementing a worker function; create a new file called `server_multithreaded.php`
    for this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先实现一个worker函数；为此创建一个名为`server_multithreaded.php`的新文件：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `worker()` function creates a new REP socket and connects this socket to
    the UNIX socket `ipc://workers.ipc` (this will be created by the master process
    later). It then runs the usual `JsonRpcServer` that you've already worked with
    before.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`worker()`函数创建一个新的REP套接字，并将此套接字连接到UNIX套接字`ipc://workers.ipc`（这将由主进程稍后创建）。然后运行您之前已经使用过的`JsonRpcServer`。'
- en: 'You can now start any number (in this case, four) of these worker processes
    using the `pcntl_fork` function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`pcntl_fork`函数启动任意数量（在本例中为四个）的这些worker进程：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In case you''re not familiar with the `fork` function: it duplicates the currently
    running process. The forked process will continue to run at the same code location
    at which it was forked. However, in the parent process, the return value of `pcntl_fork()`
    will return the process ID of the newly created process. However, within the new
    process, this value will be 0\. In this case, the child processes now become our
    worker processes and the actual master process will pass the loop without exiting.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉`fork`函数：它会复制当前运行的进程。分叉的进程将继续在分叉时的相同代码位置运行。然而，在父进程中，`pcntl_fork()`的返回值将返回新创建进程的进程ID。然而，在新进程中，这个值将是0。在这种情况下，子进程现在成为我们的worker进程，而实际的主进程将在不退出的情况下通过循环。
- en: 'After this, you can start the actual load balancer by creating a ROUTER and
    a DEALER socket:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，您可以通过创建一个ROUTER和一个DEALER套接字来启动实际的负载均衡器：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The ROUTER socket is bound to the actual network address at which the service
    is intended to be reachable (in this case, a TCP socket, allowing the service
    to be reached via a network). The DEALER socket, on the other hand, is bound to
    a local UNIX socket that will not be exposed to the outside world. The only purpose
    of the UNIX socket `ipc://workers.ipc` is that the worker processes can connect
    their REP sockets to it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ROUTER套接字绑定到服务预期可到达的实际网络地址（在本例中，允许通过网络到达服务的TCP套接字）。另一方面，DEALER套接字绑定到一个本地UNIX套接字，不会暴露给外部世界。UNIX套接字`ipc://workers.ipc`的唯一目的是工作进程可以将其REP套接字连接到它。
- en: 'After having created both the ROUTER and the DEALER socket, you can use the
    `ZMQDevice` class to pipe incoming packages from the ROUTER socket to the DEALER
    socket, which will then distribute equally to all connected REP sockets. Response
    packages that are sent back from the REP sockets will also be dispatched back
    to the original clients:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了ROUTER和DEALER套接字后，您可以使用`ZMQDevice`类将来自ROUTER套接字的传入数据包传输到DEALER套接字，然后平均分配到所有连接的REP套接字。从REP套接字发送回来的响应数据包也将被分发回原始客户端：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Changing the inventory service this way does not require any modification of
    the client code; the ROUTER socket that the load balancer is listening on behaves
    very much like a REP socket, and any REQ socket can connect to it in exactly the
    same way.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式更改库存服务不需要修改客户端代码；负载均衡器正在监听的ROUTER套接字行为非常类似于REP套接字，并且任何REQ套接字都可以以完全相同的方式连接到它。
- en: Building the checkout service
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建结账服务
- en: We now have a service that manages the inventory stock of your small, fictional
    e-commerce venture. In the next step, we will now implement a first version of
    the actual checkout service. The checkout service will offer an API for completing
    a checkout process, using a cart consisting of multiple articles and basic customer
    contact data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个管理您小型虚构电子商务企业库存的服务。接下来，我们将实现实际结账服务的第一个版本。结账服务将提供一个用于完成结账流程的API，使用由多个文章和基本客户联系数据组成的购物车。
- en: Using react/zmq
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用react/zmq
- en: For this, the checkout service will offer a simple REP ZeroMQ socket (or a ROUTER
    socket, in a concurrent setup). After receiving a checkout order, the checkout
    service will then communicate with the inventory service to check if the required
    items are available and to reduce the stock amount by the item amounts in the
    cart. If that was successful, it will publish the checkout order on a PUB socket
    that other services can listen on.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，结账服务将提供一个简单的REP ZeroMQ套接字（或在并发设置中的ROUTER套接字）。在接收结账订单后，结账服务将与库存服务通信，以检查所需物品是否可用，并通过购物车中的物品数量减少库存数量。如果成功，它将在PUB套接字上发布结账订单，其他服务可以监听。
- en: If a cart consists of multiple items, the checkout service will need to make
    multiple calls to the inventory service. In this example, you will learn how to
    make multiple requests in parallel in order to speed up execution. We will also
    use the `react/zmq` library, which offers an asynchronous interface for the ZeroMQ
    library and the `react/promise` library that will help you to better handle an
    asynchronous application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果购物车包含多个物品，结账服务将需要多次调用库存服务。在本例中，您将学习如何并行进行多个请求以加快执行速度。我们还将使用`react/zmq`库，该库为ZeroMQ库提供了异步接口，以及`react/promise`库，它将帮助您更好地处理异步应用程序。
- en: 'Start by creating a new `composer.json` file in a new `checkout/` directory
    and initialize the project with `composer install`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在新的`checkout/`目录中创建一个新的`composer.json`文件，并使用`composer install`初始化项目：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This file is similar to the inventory service's `composer.json`; the only difference
    is the PSR-4 namespace and the additional requirements `react/zmq`, `react/promise`,
    and `ext-ev`. If you are using Docker for your development setup, you can simply
    copy your existing Dockerfile from the inventory service.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件类似于库存服务的`composer.json`；唯一的区别是PSR-4命名空间和额外的要求`react/zmq`，`react/promise`和`ext-ev`。如果您正在使用Docker进行开发设置，您可以直接从库存服务中复制现有的Dockerfile。
- en: 'Continue by creating a `server.json` file in your `checkout/` directory. As
    with any React application (remember the Ratchet application from [Chapter 6](ch06.html
    "Chapter 6.  Building a Chat Application"), *Building a Chat Application*), the
    first thing you need to do is to create an event loop that you can then run:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 继续在您的`checkout/`目录中创建一个`server.json`文件。与任何React应用程序一样（记得[第6章](ch06.html "第6章。构建聊天应用程序")中的Ratchet应用程序，*构建聊天应用程序*），您需要做的第一件事是创建一个事件循环，然后运行它：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that we're using the `React\ZMQ\Context` class instead of the `ZMQContext`
    class now. The React context class offers the same interface, but extends its
    base class by some functionalities to better support asynchronous programming.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们现在使用`React\ZMQ\Context`类而不是`ZMQContext`类。React上下文类提供相同的接口，但通过一些功能扩展了其基类，以更好地支持异步编程。
- en: 'You can already start this program and it will run infinitely, but it will
    not actually do anything just yet. As the checkout service should offer a REP
    socket to which clients should send requests, you should continue by creating
    and binding a new REP socket before running the event loop:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以启动此程序，它将无限运行，但目前还不会执行任何操作。由于结账服务应该提供一个REP套接字，客户端应该发送请求到该套接字，因此在运行事件循环之前，您应该继续创建并绑定一个新的REP套接字：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**ReactPHP** applications are asynchronous; instead of just calling `recv()`
    on the socket to wait for the next incoming message, you can now register an event
    handler on the socket that will be called by ReactPHP''s event loop as soon as
    a message is received:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**ReactPHP**应用程序是异步的；现在，您可以在套接字上注册事件处理程序，而不是只调用`recv()`等待下一个传入消息，ReactPHP的事件循环将在收到消息时立即调用它：'
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This callback solution works similar to other asynchronous libraries that you
    will most commonly encounter when developing client-site JavaScript code. The
    basic principle is the same: the `$socket->on(...)` method simply registers an
    event listener that can be called at any later point in time whenever a new message
    is received. The execution of the code will continue immediately (in contrast
    to this, compare the regular `$socket->recv()` function that blocks until a new
    message is received) and the `$loop->run()` method is called. This call starts
    the actual event loop that is responsible for calling the registered event listener
    when new messages are received. The event loop will block until it is interrupted
    (for example, by a SIGINT signal that you can trigger with *Ctrl* + *C* on the
    command line).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种回调解决方案类似于您在开发客户端JavaScript代码时最常遇到的其他异步库。基本原则是相同的：`$socket->on(...)`方法只是注册一个事件监听器，可以在以后的任何时间点调用，每当收到新消息时。代码的执行将立即继续（与此相反，比较常规的`$socket->recv()`函数会阻塞，直到收到新消息），然后调用`$loop->run()`方法。这个调用启动了实际的事件循环，负责在收到新消息时调用注册的事件监听器。事件循环将一直阻塞，直到被中断（例如，通过命令行上的*Ctrl*
    + *C*触发的SIGINT信号）。
- en: Working with promises
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用承诺
- en: 'When working with asynchronous code, it is often just a matter of time until
    you find yourself in "callback hell". Imagine you want to send two consecutive
    ZeroMQ requests (for example, first asking the inventory service if a given article
    is available and then actually instructing the inventory service to reduce the
    stock by the required amount). You can implement this using multiple sockets and
    the ''message'' event that you have seen previously. However, this will quickly
    become an unmaintainable mess:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理异步代码时，通常只是时间的问题，直到您发现自己陷入了“回调地狱”。想象一下，您想发送两个连续的 ZeroMQ 请求（例如，首先询问库存服务给定的文章是否可用，然后实际上指示库存服务减少所需数量的库存）。您可以使用多个套接字和您之前看到的“消息”事件来实现这一点。然而，这很快就会变成一个难以维护的混乱：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code snippet is just an example of how complicated this might
    get; in our case, you would even need to consider that each checkout order can
    contain any number of articles, each of them requiring two new requests to the
    identity service.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段只是说明了这可能变得多么复杂的一个例子；在我们的情况下，您甚至需要考虑每个结账订单可能包含任意数量的文章，每篇文章都需要两个新请求到身份服务。
- en: To make life better, you can implement this functionality using promises (see
    the following box for a detailed explanation of the concept). A good implementation
    of promises is provided by the `react/promise` library that should already be
    declared in your `composer.json` file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让生活更美好，您可以使用承诺来实现这个功能（有关该概念的详细解释，请参见下面的框）。`react/promise`库提供了良好的承诺实现，应该已经在您的`composer.json`文件中声明。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**What are promises?** Promises (sometimes also called futures) are a concept
    commonly found in asynchronous libraries. They present an alternative to the regular
    callback-based approach.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是承诺？** 承诺（有时也称为未来）是异步库中常见的概念。它们提供了一种替代常规基于回调的方法。'
- en: 'Basically, a promise is an object that represents a value that is not yet available
    (for example, because the ZeroMQ request that was supposed to retrieve the value
    has not yet received a reply). In an asynchronous application, a promise may become
    available (fulfilled) at any time. You can then register functions that should
    be called whenever a promise was fulfilled, to further process the promised, and
    now resolved value:`$promise = $someService->someFunction();` `$promise->then(function($promisedValue)
    {` `    echo "Promise resolved: $promisedValue\n";` `});`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '基本上，承诺是一个代表尚未可用的值的对象（例如，因为应该检索该值的 ZeroMQ 请求尚未收到回复）。在异步应用程序中，承诺可能随时变得可用（实现）。然后，您可以注册应该在承诺实现时调用的函数，以进一步处理承诺的已解析值：`$promise
    = $someService->someFunction();` `$promise->then(function($promisedValue) {` `    echo
    "Promise resolved: $promisedValue\n";` `});`'
- en: 'Each call of the `then()` function returns a new promise, this time for the
    value that will be returned by the callback passed to `then()`. This allows you
    to easily chain multiple promises together:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`then()`函数的每次调用都会返回一个新的承诺，这次是由传递给`then()`的回调返回的值。这使您可以轻松地将多个承诺链接在一起：'
- en: '`$promise` `    ->then(function($value) use ($someService) {` `        $newPromise
    = $someService->someOtherFunc($value);` `         return $newPromise;` `    })`
    `    ->then(function ($newValue) {` `        echo "Promise resolved: $newValue\n";`
    `    });`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`$promise` `    ->then(function($value) use ($someService) {` `        $newPromise
    = $someService->someOtherFunc($value);` `        return $newPromise;` `    })`
    `    ->then(function ($newValue) {` `        echo "Promise resolved: $newValue\n";`
    `    });`'
- en: 'We can now put this principle to use by writing an asynchronous client class
    for communicating with our inventory service. As that service communicates using
    JSON-RPC, we will now implement the `Packt\Chp7\Checkout\JsonRpcClient` class.
    This class is initialized with a ZeroMQ context, and for convenience, also the
    remote service''s URL:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过编写一个用于与我们的库存服务通信的异步客户端类来利用这个原则。由于该服务使用JSON-RPC进行通信，我们现在将实现`Packt\Chp7\Checkout\JsonRpcClient`类。该类使用ZeroMQ上下文进行初始化，并且为了方便起见，还包括远程服务的URL：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, the class already contains a `request` method that accepts
    a method name and a set of parameters, and should return an implementation of
    `React\Promise\PromiseInterface`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，该类已经包含一个`request`方法，该方法接受一个方法名和一组参数，并应返回`React\Promise\PromiseInterface`的实现。
- en: 'In the `request()` method, you can now open a new REQ socket and send a JSON-RPC
    request to it:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`request()`方法中，您现在可以打开一个新的 REQ套接字并向其发送一个JSON-RPC请求：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since the `request()` method is supposed to work asynchronously, you cannot
    simply call the `recv()` method and block until a result is received. Instead,
    we will need to return a promise for the response value that can be resolved later,
    whenever a response message is received on the REQ socket. For this, you can use
    the `React\Promise\Deferred` class:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`request()`方法应该是异步工作的，您不能简单地调用`recv()`方法并阻塞，直到收到结果。相反，我们需要返回一个对响应值的承诺，以便稍后可以解决，每当在REQ套接字上收到响应消息时。为此，您可以使用`React\Promise\Deferred`类：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is a prime example of how promises work: you can use the `Deferred` class
    to create and return a promise for a value that is not yet available. Remember:
    the function passed into the `$sock->on(...)` method will not be called immediately,
    but at any later point in time when a response was actually received. As soon
    as this event occurs, the promise that was returned by the request function is
    resolved with the actual response value.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是承诺如何工作的一个典型例子：您可以使用`Deferred`类来创建并返回一个尚未可用的值的承诺。记住：传递给`$sock->on(...)`方法的函数不会立即被调用，而是在任何以后的时间点，当实际收到响应时。一旦发生这种事件，由请求函数返回的承诺将以实际的响应值解决。
- en: 'As the response message contains a JSON-RPC response, you need to evaluate
    this response before fulfilling the promise that you made to the caller of the
    request function. As a JSON-RPC response can also contain an error, it is worth
    noting that you can also reject a promise (for example, when an error occurred
    while waiting for the response):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于响应消息包含JSON-RPC响应，您需要在满足对请求函数的调用者所做的承诺之前评估这个响应。由于JSON-RPC响应也可能包含错误，值得注意的是，您也可以拒绝一个承诺（例如，在等待响应时发生错误时）：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can now use this JSON-RPC client class in your `server.php` to actually
    communicate with the inventory service on each incoming checkout request. Let''s
    start with a simple example on how you can use the new class to chain two consecutive
    JSON-RPC calls together:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在您的`server.php`中使用这个JSON-RPC客户端类，以便在每个传入的结账请求上实际与库存服务进行通信。让我们从一个简单的例子开始，演示如何使用新类将两个连续的JSON-RPC调用链接在一起：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, the `PromiseInterface`''s `then` function accepts two parameters
    (each both a new function): the first function will be called as soon as the promise
    was resolved with an actual value; the second function will be called in case
    the promise was rejected.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`PromiseInterface`的`then`函数接受两个参数（每个都是一个新函数）：第一个函数将在承诺以实际值解决时被调用；第二个函数将在承诺被拒绝时被调用。
- en: If a function passed to `then(...)` returns a new value, the then function will
    return a new promise for this value. An exception to this rule is when the callback
    function returns a new promise itself (in our case, in which `$client->request`
    is called again within the `then()` callback). In this case, the returned promise
    replaces the original promise. This means that chained calls to the `then()` function
    actually listen on the second promise.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递给`then(...)`的函数返回一个新值，那么then函数将返回一个新的承诺。这个规则的一个例外是当回调函数本身返回一个新的承诺（在我们的情况下，在`then()`回调中再次调用了`$client->request`）。在这种情况下，返回的承诺将替换原始承诺。这意味着对`then()`函数的链接调用实际上是在第二个承诺上监听。
- en: 'Let''s put this to use in the `server.php` file. In contrast to the preceding
    example, you need to consider that each checkout order may contain multiple articles.
    This means that you will need to execute multiple `checkArticle` requests to the
    inventory service:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`server.php`文件中使用这个。与前面的例子相比，您需要考虑每个结账订单可能包含多个文章。这意味着您需要对库存服务执行多个`checkArticle`请求：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In this example, we assume that incoming checkout orders are JSON encoded messages
    that look like the following example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们假设传入的结账订单是JSON编码的消息，看起来像下面的例子：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the current version of our `server.php`, we call the JSON-RPC client multiple
    times and collect the returned promises in an array. However, we do not actually
    do anything with them yet. You could now call the `then()` function on each of
    these promises with a callback that will be called for each article with a boolean
    parameter indicating whether this one article is available. However, for processing
    the order correctly, we need to know if all articles from the checkout order are
    available. So what you need to do is not to wait on each promise separately, but
    to wait until all of them are completed. This is what the `React\Promise\all`
    function is for: this function takes a list of promises as parameters and returns
    a new promise that is fulfilled as soon as all supplied promises are fulfilled:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`server.php`的当前版本中，我们多次调用JSON-RPC客户端，并将返回的承诺收集到一个数组中。然而，我们实际上还没有对它们做任何事情。现在，您可以对这些承诺中的每一个调用`then()`函数，其中包含一个回调，该回调将对每个文章进行调用，并传递一个布尔参数，指示这篇文章是否可用。然而，为了正确处理订单，我们需要知道结账订单中的所有文章是否都可用。所以你需要做的不是等待每个承诺单独完成，而是等待它们全部完成。这就是`React\Promise\all`函数的作用：这个函数以承诺列表作为参数，并返回一个新的承诺，一旦所有提供的承诺都被实现，它就会被实现：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If not all required articles are available in the inventory service, you can
    answer the request early with an error message, as there is no need to continue
    any further. If all articles are available, you'll need a set of subsequent requests
    to actually reduce the inventory by the specified amounts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库存服务中没有所有所需的文章，您可以提前用错误消息回答请求，因为没有必要继续下去。如果所有文章都可用，您将需要一系列后续请求来实际减少指定数量的库存。
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `array_sum($values) == count($values)` construct used in this example is
    a quick hack to ensure that an array of boolean values contains only true values.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中使用的`array_sum($values) == count($values)`构造是一个快速的解决方法，用来确保布尔值数组只包含true值。
- en: 'In the next step, you can now extend your server to run the second set of requests
    to the inventory service after all of the `checkArticle` method calls have successfully
    returned. This can be done by following the same way as before using the `React\Promise\all`
    method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您现在可以扩展您的服务器，以在所有`checkArticle`方法调用成功返回后运行第二组请求到库存服务。这可以通过使用`React\Promise\all`方法按照之前的方式完成：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In order to actually test this new server, let''s write a short test script
    that tries to execute an example checkout order. For this, create a new `client.php`
    file in your `checkout/` directory:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际测试这个新的服务器，让我们编写一个简短的测试脚本，尝试执行一个示例结账订单。为此，在您的`checkout/`目录中创建一个新的`client.php`文件：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To run both the checkout service and the test script, you can extend your `docker-compose.yml`
    file in your project''s root directory with the new checkout service:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行结账服务和测试脚本，可以在项目的根目录中使用新的结账服务扩展您的`docker-compose.yml`文件：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For the test script, add a second Compose configuration file, `docker-compose.testing.yml`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试脚本，添加第二个Compose配置文件`docker-compose.testing.yml`：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Afterwards, you can test your checkout service using the following command
    line commands:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以使用以下命令行命令测试您的结账服务：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following screenshot shows an example output of both the test script and
    both server scripts (in this example, some additional `echo` statements have been
    added to make the server more verbose):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了测试脚本和两个服务器脚本的示例输出（在此示例中，添加了一些额外的`echo`语句，使服务器更加详细）：
- en: '![Working with promises](graphics/image_07_006.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![使用承诺工作](graphics/image_07_006.jpg)'
- en: An example output of a checkout order being processed by the checkout and inventory
    services
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 结账和库存服务处理结账订单的示例输出
- en: Building the mailing service
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建邮寄服务
- en: In the next step, we will put a mailing service into our Microservice architecture.
    After a checkout was processed, the user should be notified via e-mail about the
    status of the checkout.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在我们的微服务架构中加入一个邮寄服务。在处理结账后，用户应该通过电子邮件收到有关结账状态的通知。
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As mentioned before, the focus of this chapter is on building the communication
    patterns between individual services. Because of this, we will not implement the
    mailing service's actual mailing functionality in this section, but instead focus
    on how this service will communicate with other services. Have a look at [Chapter
    3](ch03.html "Chapter 3.  Building a Social Newsletter Service"), *Building a
    Social Newsletter Service*, to see how you can use PHP to actually send e-mails
    to other recipients.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，本章的重点是构建个别服务之间的通信模式。因此，在本节中，我们不会实现邮寄服务的实际邮寄功能，而是专注于该服务如何与其他服务通信。查看[第3章](ch03.html
    "第3章。构建社交通讯服务")*构建社交通讯服务*，了解如何使用PHP实际向其他收件人发送电子邮件。
- en: In theory, you could implement the mailing service just as you did the inventory
    service - build a standalone PHP program that listens on a ZeroMQ REP socket,
    have the checkout service open an REQ socket, and send requests to the mailing
    service. However, the same can also be achieved using the publish/subscribe pattern.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，您可以像实现库存服务一样实现邮寄服务-构建一个独立的PHP程序，监听ZeroMQ REP套接字，让结账服务打开一个REQ套接字，并向邮寄服务发送请求。但是，也可以使用发布/订阅模式来实现相同的功能。
- en: Using the publish/subscribe pattern, the checkout service does not even need
    to know about the mailing service. Instead, the checkout service simply opens
    a PUB socket that other services can connect to. Any and all messages that are
    sent on the PUB socket are distributed to all connected (subscribing) services.
    This allows you to implement a very loosely coupled architecture that is also
    very extensible - you can add new functionality to your checkout process by having
    more and different services subscribe to the same PUB socket, without having to
    modify the checkout service itself.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用发布/订阅模式，结账服务甚至不需要知道邮寄服务。相反，结账服务只需打开其他服务可以连接到的PUB套接字。在PUB套接字上发送的任何消息都会分发到所有连接的（订阅）服务。这允许您实现一个非常松散耦合的架构，也非常可扩展-您可以通过让更多和不同的服务订阅相同的PUB套接字来为您的结账流程添加新功能，而无需修改结账服务本身。
- en: This is possible, because in the case of the mailing service, communication
    does not need to be synchronous - the checkout service does not need to wait for
    the mailing service to complete its action before continuing with the process,
    nor does it need any kind of data that might be returned from the mailing service.
    Instead, messages can flow strictly in one direction - from checkout service to
    mailing service.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能的，因为在邮寄服务的情况下，通信不需要是同步的-结账服务在继续流程之前不需要等待邮寄服务完成其操作，也不需要来自邮寄服务的任何数据。相反，消息可以严格单向流动-从结账服务到邮寄服务。
- en: 'First, you need to open the PUB socket in the checkout service. For this, modify
    the checkout service''s `server.php`, create a new PUB socket, and bind it to
    a TCP address:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要在结账服务中打开PUB套接字。为此，请修改结账服务的`server.php`，创建一个新的PUB套接字，并将其绑定到TCP地址：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After having successfully taken the required items from the inventory service,
    you can then publish a message on this socket. In this case, we''ll simply resend
    the original message on the PUB socket:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 成功从库存服务中取得所需物品后，您可以在此套接字上发布消息。在这种情况下，我们将简单地在PUB套接字上重新发送原始消息：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now that you have a PUB socket on which accepted checkout orders are published,
    you can write the actual mailing service that creates a SUB socket that subscribes
    to this PUB socket.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经在接受的结账订单上发布了一个PUB套接字，可以编写实际的邮寄服务，创建一个订阅此PUB套接字的SUB套接字。
- en: 'For this, start by creating a new directory, `mailing/`, in your project directory.
    Copy the Dockerfile from the previous examples and create a new `composer.json`
    file with the following contents:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，在项目目录中创建一个名为`mailing/`的新目录。从先前的示例中复制Dockerfile，并创建一个新的`composer.json`文件，内容如下：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In contrast to the previous examples, the only difference is the new package
    name and the different PSR-4 autoloading namespace. Also, you will not need the
    `react/promise` library for the mailing service. As usual, continue by running
    `composer install` on a command line within the `mailing/` directory to download
    the required dependencies.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前的示例相比，唯一的区别是新的包名称和不同的PSR-4自动加载命名空间。此外，您不需要`react/promise`库来进行邮寄服务。像往常一样，在`mailing/`目录中的命令行上运行`composer
    install`来下载所需的依赖项。
- en: 'You can now create a new `server.php` file in the `mailing/` directory in which
    you create a new SUB socket that you can then connect to the checkout service:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以在`mailing/`目录中创建一个新的`server.php`文件，其中创建一个新的SUB套接字，然后可以连接到结帐服务：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Pay attention to the `$socket->subscribe()` call. Each SUB socket can subscribe
    to a given *topic* or *channel*. A channel is identified by a string prefix that
    can be submitted as part of each published message. Clients will then only receive
    messages that match the channel that they have subscribed to. If you do not care
    about different channels on one PUB socket, you can simply subscribe to the empty
    channel by calling `$socket->subscribe` with an empty string to receive all messages
    that are published on the PUB socket. However, if you do not call the subscribe
    method; you will not receive any messages at all.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`$socket->subscribe()`调用。每个SUB套接字可以订阅给定的*主题*或*频道*。频道由一个字符串前缀标识，可以作为每个发布的消息的一部分提交。然后客户端只会接收与他们订阅的频道匹配的消息。如果您不关心一个PUB套接字上的不同频道，您可以通过调用`$socket->subscribe`并传递一个空字符串来订阅空频道，从而接收在PUB套接字上发布的所有消息。但是，如果您不调用subscribe方法，您将根本不会收到任何消息。
- en: 'After the socket is connected, you can provide a listener function for the
    `''message''` event in which you decode the JSON-encoded message and process it
    accordingly:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字连接后，您可以为`'message'`事件提供一个监听函数，在其中解码JSON编码的消息并相应地处理它：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Also note that PUB and SUB sockets are strictly unidirectional: you send messages
    from the PUB sockets to any number of subscribing SUB sockets, but you cannot
    send a reply back to the publisher-at least, not on the same socket. If you really
    need some kind of feedback channel, you could have the publisher listening on
    a separate REP or SUB socket and the subscriber connecting with a new REQ or PUB
    socket. The following diagram illustrates two strategies to implement a feedback
    channel like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，PUB和SUB套接字是严格单向的：您可以从PUB套接字向任意数量的订阅的SUB套接字发送消息，但您不能在同一个套接字上回复给发布者-至少不能。如果您真的需要某种反馈渠道，您可以让发布者在一个单独的REP或SUB套接字上监听，订阅者使用新的REQ或PUB套接字连接。以下图表说明了实现这样的反馈渠道的两种策略：
- en: '![Building the mailing service](graphics/image_07_007.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![构建邮寄服务](graphics/image_07_007.jpg)'
- en: Different strategies for implementing feedback channels in a publish/subscribe
    architecture
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布/订阅架构中实现反馈通道的不同策略
- en: 'To test the new mailing service, you can reuse the `client.php` script from
    the previous section. As the mailing service requires the checkout order to contain
    an e-mail address, you''ll need to add one to the message body:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试新的邮寄服务，您可以重用上一节中的`client.php`脚本。由于邮寄服务要求结帐订单包含电子邮件地址，您需要将其添加到消息正文中：
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also, remember to add the new mailing service to the `docker-compose.yml` file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记得将新的邮寄服务添加到`docker-compose.yml`文件中：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After adding the new service to `docker-compose.yml`, start all services and
    run the test script again:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`docker-compose.yml`中添加新服务后，启动所有服务并再次运行测试脚本：
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After that, inspect the output of the separate containers to check if the checkout
    order was correctly processed:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，检查单独的容器的输出，以检查结帐订单是否被正确处理：
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Building the shipping service
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建邮寄服务
- en: In our small e-commerce example, we are still missing the shipping service.
    In real-world scenarios, this would be a really complex task, and you would often
    need to communicate with outside parties and maybe integrate with APIs of external
    transport service providers. For this reason, we will now build our shipping service
    as a worker pool using PUSH and PULL sockets and an arbitrary number of worker
    processes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的小型电子商务示例中，我们还缺少邮寄服务。在现实世界的场景中，这将是一个非常复杂的任务，您通常需要与外部方进行通信，也许需要与外部运输服务提供商的API集成。因此，我们现在将使用PUSH和PULL套接字以及任意数量的工作进程构建我们的邮寄服务作为工作池。
- en: PUSH/PULL for beginners
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初学者的PUSH/PULL
- en: A PUB socket publishes each message to all connected subscribers. ZeroMQ also
    offers the PUSH and PULL socket types - they work similar to PUB/SUB, but each
    message published on a PUSH socket is sent to only one of potentially many connected
    PULL sockets. You can use this to implement a worker pool into which you can push
    long-running tasks that are then executed in parallel.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: PUB套接字将每条消息发布到所有连接的订阅者。ZeroMQ还提供了PUSH和PULL套接字类型-它们的工作方式类似于PUB/SUB，但在PUSH套接字上发布的每条消息只发送到潜在的多个连接的PULL套接字中的一个。您可以使用这个来实现一个工作池，将长时间运行的任务推送到其中，然后并行执行。
- en: 'For this, we will need one master process that uses a SUB socket to subscribe
    to completed checkout orders. The same process needs to offer a PUSH socket that
    the individual worker processes can connect to. The following diagram illustrates
    this architecture:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要一个使用SUB套接字订阅已完成结帐订单的主进程。同一进程需要提供一个PUSH套接字，以便各个工作进程可以连接到它。以下图表说明了这种架构：
- en: '![PUSH/PULL for beginners](graphics/image_07_008.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![初学者的PUSH/PULL](graphics/image_07_008.jpg)'
- en: PUB/SUB and PUSH/PULL in combination
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: PUB/SUB和PUSH/PULL的组合
- en: 'As usual, start by creating a new directory, `shipping/`, in your project folder.
    Copy the Dockerfile from one of the previous services, create a new `composer.json`
    file, and initialize the project with `composer install`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，首先在项目文件夹中创建一个新的`shipping/`目录。从以前的服务中复制Dockerfile，创建一个新的`composer.json`文件，并使用`composer
    install`初始化项目：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We''ll start by implementing the master process. This master process needs
    to do three simple things:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从实现主进程开始。这个主进程需要做三件简单的事情：
- en: Open a SUB socket and connect this socket to the checkout service's PUB socket.
    This will allow the shipping service to receive all checkout orders that were
    accepted by the checkout service.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个SUB套接字，并将此套接字连接到结帐服务的PUB套接字。这将允许运输服务接收结帐服务接受的所有结帐订单。
- en: Open a PUSH socket and bind this socket to a new TCP port. This will allow the
    worker processes to connect and receive checkout orders.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个PUSH套接字，并将此套接字绑定到一个新的TCP端口。这将允许工作进程连接并接收结帐订单。
- en: Forward each message received on the SUB socket to the PUSH socket.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将在SUB套接字上接收的每条消息转发到PUSH套接字。
- en: 'For this, create a new `master.php` file in your `shipping/` directory in which
    you can create a new event loop and create the two required sockets:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，在您的`shipping/`目录中创建一个新的`master.php`文件，您可以在其中创建一个新的事件循环并创建两个所需的套接字：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'For actually processing messages that are received on the SUB socket, register
    a listener function on the `$subSocket` variable that sends each received message
    on the PUSH socket:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际处理在SUB套接字上接收的消息，注册一个监听器函数在`$subSocket`变量上，将每个接收到的消息发送到PUSH套接字：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, create a new file, `worker.php`, also in the `shipping/` directory. In
    this file, you will create a PULL socket that receives messages from the PUSH
    socket opened in the master process:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`shipping/`目录中创建一个名为`worker.php`的新文件。在这个文件中，您将创建一个PULL套接字，用于接收主进程中打开的PUSH套接字上的消息：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Again, attach a listener function to the `$pullSocket` in order to process
    incoming messages:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，附加一个监听器函数到`$pullSocket`，以处理传入的消息：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`sleep(5)`, in this example, just simulates the execution of a shipping order
    which may take a longer amount of time. As usual in this chapter, we will not
    implement the actual business logic any more than we need to, to demonstrate the
    communication patterns between the individual services.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep(5)`，在这个例子中，只是模拟执行可能需要更长时间的运输订单。与本章中一样，我们不会实现实际的业务逻辑，只需要演示各个服务之间的通信模式。'
- en: 'In order to test the shipping service, now add both the master process and
    the worker process to your `docker-compose.yml` file:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试运输服务，现在将主进程和工作进程添加到您的`docker-compose.yml`文件中：
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'After this, you can start all containers and then follow their output using
    the following commands:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以启动所有容器，然后使用以下命令跟踪它们的输出：
- en: '[PRE56]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'By default, Docker compose will always start one instance of each service.
    However, you can start additional instances of each service by using the `docker-compose
    scale` command. This is a good idea for the `shippingworker` service, as the PUSH/PULL
    architecture that we''ve chosen for this service actually allows any number of
    instances of this service to be running in parallel:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker compose将始终启动每个服务的一个实例。但是，您可以使用`docker-compose scale`命令启动每个服务的附加实例。这对于`shippingworker`服务来说是一个好主意，因为我们为该服务选择的PUSH/PULL架构实际上允许任意数量的该服务实例并行运行：
- en: '[PRE57]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'After having started some more instances of the `shippingworker` service, you
    can attach to all container''s log output using the `docker-compose logs` command.
    Then, use a second terminal to start the client test script that you''ve created
    in the previous section:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动了一些更多的`shippingworker`服务实例之后，您可以使用`docker-compose logs`命令附加到所有容器的日志输出。然后，使用第二个终端启动您在上一节中创建的客户端测试脚本：
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When you run this command multiple times, you will see that the debug output
    within the shipping worker process is printed by different instances of the container
    for subsequent invocations. You can see an example output in the following screenshot:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当您多次运行此命令时，您将看到在后续调用的容器的不同实例中打印的运输工作进程中的调试输出。您可以在以下截图中看到一个示例输出：
- en: '![PUSH/PULL for beginners](graphics/image_07_009.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![初学者的PUSH/PULL](graphics/image_07_009.jpg)'
- en: An example output, demonstrating a working push/pull architecture with multiple
    workers
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 演示具有多个工作进程的工作推/拉架构的示例输出
- en: Fan-out/fan-in
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扇出/扇入
- en: 'In addition to distributing time-consuming tasks to a number of worker processes,
    you can also use PUSH and PULL sockets to have the workers push results back to
    their master process. This pattern is called **fan-out/fan-in**. For this example,
    have the master process in the `master.php` file listen on a separate PULL socket:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将耗时的任务分配给多个工作进程外，您还可以使用PUSH和PULL套接字让工作进程将结果推送回主进程。这种模式称为**扇出/扇入**。对于本例，让`master.php`文件中的主进程监听一个单独的PULL套接字：
- en: '[PRE59]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the `worker.php` file, you can now connect to this PULL socket with a new
    PUSH socket and send a message as soon as a checkout order has successfully been
    processed:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在`worker.php`文件中，您现在可以使用新的PUSH套接字连接到此PULL套接字，并在成功处理结帐订单时发送消息：
- en: '[PRE60]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This will push the message back to the master process as soon as it has been
    processed. Note that PUSH/PULL is used the other way around than in the previous
    section - before we had one PUSH socket and multiple PULL sockets; for the fan-in
    we have one PULL socket on the master process and multiple PUSH sockets on the
    worker processes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦处理完消息，这将立即将消息推送回主进程。请注意，PUSH/PULL的使用方式与上一节中的方式相反-之前我们有一个PUSH套接字和多个PULL套接字；对于扇入，我们在主进程上有一个PULL套接字，而在工作进程上有多个PUSH套接字。
- en: Tip
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Using bind() and connect()**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用bind()和connect()**'
- en: In this section, we have used both the `bind()` and `connect()` method for both
    PUSH and PULL sockets. In general, `bind()` is used to have a socket listen on
    a new TCP port (or UNIX socket), while `connect()` is used to have a socket connect
    to another, already existing socket. In general, you can use both `bind()` and
    `connect()` with any socket type. In some cases, like REQ/REP, you'll intuitively
    `bind()` the REP socket and then `connect()` the REQ socket, but both PUSH/PULL
    and PUB/SUB actually work both ways. You can have a PULL socket connect to a listening
    PUSH socket, but you can also have a PUSH socket connect to a listening PULL socket.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经使用了PUSH和PULL套接字的`bind()`和`connect()`方法。通常，`bind()`用于让套接字监听新的TCP端口（或UNIX套接字），而`connect()`用于让套接字连接到另一个已经存在的套接字。通常情况下，您可以在任何套接字类型上使用`bind()`和`connect()`。在某些情况下，比如REQ/REP，您会直觉地`bind()`REP套接字，然后`connect()`REQ套接字，但PUSH/PULL和PUB/SUB实际上都可以双向工作。您可以让PULL套接字连接到监听的PUSH套接字，但也可以让PUSH套接字连接到监听的PULL套接字。
- en: 'The following screenshot shows an example output of both the shipping service''s
    master and worker processes handling multiple checkout orders in parallel. Note
    that the actual processing is done by different worker processes (`shippingworker_1`
    to `shippingworker_3` in this example), but are "fanned-in" back to the master
    process after that:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了运输服务的主进程和工作进程并行处理多个结账订单的示例输出。请注意，实际处理是由不同的工作进程（在此示例中为`shippingworker_1`到`shippingworker_3`）完成的，但之后被"扇入"回主进程：
- en: '![Fan-out/fan-in](graphics/image_07_010.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![扇出/扇入](graphics/image_07_010.jpg)'
- en: Fan-out/fan-in in action
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 扇出/扇入的实际操作
- en: Bridging ZeroMQ and HTTP
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接ZeroMQ和HTTP
- en: As you have seen in this chapter, ZeroMQ offers a lot of different possibilities
    for implementing communication between separate services. In particular, patterns
    such as publish/subscribe and push/pull are not that easy to implement with PHP's
    de-facto standard protocol, HTTP.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在本章中所看到的，ZeroMQ提供了许多不同的可能性，用于在不同的服务之间实现通信。特别是，发布/订阅和推/拉等模式在PHP的事实标准协议HTTP中并不容易实现。
- en: On the other hand, HTTP is more widely adopted and offers a richer set of protocol
    semantics, handling concerns such as caching or authentication already at the
    protocol-level. Because of this, especially when offering external APIs, you might
    prefer offering an HTTP-based API instead of a ZeroMQ-based API. Luckily, it's
    easy to bridge between the two protocols. In our example architecture, the checkout
    service is the only service that will be used by outside services. In order to
    offer a better interface for the checkout service, we will now implement an HTTP-based
    wrapper for the checkout service that can be used in a RESTful way.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，HTTP更广泛地被采用，并提供了更丰富的协议语义集，处理诸如缓存或身份验证等问题已经在协议级别上。因此，特别是在提供外部API时，您可能更喜欢提供基于HTTP而不是基于ZeroMQ的API。幸运的是，在两种协议之间进行桥接很容易。在我们的示例架构中，结账服务是唯一会被外部服务使用的服务。为了为结账服务提供更好的接口，我们现在将实现一个基于HTTP的结账服务包装器，可以以RESTful方式使用。
- en: 'For this, you can use the `react/http` package. This package offers a minimalist
    HTTP server that - just like `react/zmq` - works asynchronously and uses an event
    loop for handling requests. This means that a react-based HTTP server can even
    run in the same process using the same event loop as the REP ZeroMQ socket that
    is already offered by the checkout service. Start by installing the `react/http`
    package by running the following command in the `checkout/` folder in your project
    directory:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您可以使用`react/http`包。该包提供了一个极简的HTTP服务器，就像`react/zmq`一样，它是异步工作的，并使用事件循环来处理请求。这意味着基于react的HTTP服务器甚至可以在同一个进程中，使用与结账服务已经提供的REP
    ZeroMQ套接字相同的事件循环来运行。首先，在项目目录中的`checkout/`文件夹中运行以下命令来安装`react/http`包：
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Before extending the checkout service with an HTTP server, the `server.php`
    script needs a bit of refactoring. Currently, the `server.php` creates a REP ZeroMQ
    socket with an event listener function in which the request is processed. As our
    goal is now to add an HTTP API that triggers the same functionality, we''ll need
    to extract this logic into a separate class. Start by creating the `Packt\Chp7\Checkout\CheckoutService`
    class:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展结账服务以使用HTTP服务器之前，`server.php`脚本需要进行一些重构。当前，`server.php`创建了一个带有事件监听函数的REP
    ZeroMQ套接字，其中处理请求。由于我们的目标现在是添加一个触发相同功能的HTTP API，我们需要将此逻辑提取到一个单独的类中。首先创建`Packt\Chp7\Checkout\CheckoutService`类：
- en: '[PRE62]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `handleCheckoutOrder` method will be holding the logic that was previously
    implemented directly in the `server.php` file. As this method will later be used
    by both the ZeroMQ REP socket and the HTTP server, this method cannot directly
    send a response message, but will simply return a promise that can then be used
    in the `server.php`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleCheckoutOrder`方法将保存之前直接在`server.php`文件中实现的逻辑。由于此方法稍后将被ZeroMQ REP套接字和HTTP服务器同时使用，因此此方法不能直接发送响应消息，而只能返回一个promise，然后可以在`server.php`中使用：'
- en: '[PRE63]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The consistent use of promises and not caring about the return message actually
    allows some simplifications; instead of directly sending back an error message,
    you can simply throw an exception, which will cause the *promise* returned by
    this function to be automatically rejected.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一致使用promise并不关心返回消息实际上允许一些简化；而不是直接发送错误消息，您可以简单地抛出异常，这将导致此函数返回的*promise*被自动拒绝。
- en: 'The existing `server.php` file can now be simplified by quite a few lines of
    code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的`server.php`文件现在可以简化为几行代码：
- en: '[PRE64]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, you can get to work on the HTTP server. For this, you''ll first need
    a simple socket server that you can then pass into the actual HTTP server class.
    This can be done at any point in the `server.php` before the event loop is run:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以开始处理HTTP服务器。为此，您首先需要一个简单的套接字服务器，然后将其传递到实际的HTTP服务器类中。这可以在运行事件循环之前的`server.php`中的任何时间点完成：
- en: '[PRE65]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The HTTP server itself has a `''request''` event for which you can register
    a listener function (similar to the `''message''` event of the ZeroMQ sockets).
    The listener function gets a request and a response object passed as a parameter.
    These are instances of the `React\Http\Request` respective `React\Http\Response`
    classes:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP服务器本身有一个`'request'`事件，您可以为其注册一个监听函数（类似于ZeroMQ套接字的`'message'`事件）。监听函数作为参数传递了一个请求和一个响应对象。这些都是`React\Http\Request`和`React\Http\Response`类的实例：
- en: '[PRE66]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Unfortunately, React HTTP's `Request` and `Response` classes are not compatible
    with the respective PSR-7 interfaces. However, if the need arises you can convert
    them relatively easily, as already seen in the section *Bridging Ratchet and PSR-7
    applications* in [Chapter 6](ch06.html "Chapter 6.  Building a Chat Application"),
    *Building a Chat Application*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，React HTTP的`Request`和`Response`类与相应的PSR-7接口不兼容。但是，如果有需要，您可以相对容易地将它们转换，就像在[第6章](ch06.html
    "第6章。构建聊天应用程序")*构建聊天应用程序*中已经看到的那样，*桥接Ratchet和PSR-7应用程序*部分中。
- en: 'Within this listener function, you can first check for a correct request method
    and path, and send an error code, otherwise:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在此监听函数中，您可以首先检查正确的请求方法和路径，并发送错误代码，否则：
- en: '[PRE67]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This is where it gets tricky. The ReactPHP HTTP server is so asynchronous,
    that when the `request` event is triggered the request body has not yet been read
    from the network socket. To get the actual request body, you need to listen on
    the request''s `data` event. However, the request body is read in chunks of 4096
    bytes, so for large request bodies, the data event may actually be called multiple
    times. The easiest way to read the full request body is to check the `Content-Length`
    header and check in the data event handler if exactly this amount of bytes has
    already been read:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是问题所在。ReactPHP HTTP服务器是如此异步，以至于当触发`request`事件时，请求正文尚未从网络套接字中读取。要获取实际的请求正文，您需要监听请求的`data`事件。但是，请求正文以4096字节的块读取，因此对于大型请求正文，数据事件实际上可能会被多次调用。读取完整的请求正文的最简单方法是检查`Content-Length`标头，并在数据事件处理程序中检查是否已经读取了确切数量的字节：
- en: '[PRE68]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Of course, this won't work when the sender uses the so-called chunked transfer
    encoding in their request. However, reading a request body using chunked transfer
    would work a similar way; in this case, the exit condition is not dependent on
    the `Content-Length` header, but instead when the first empty chunk has been read.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送方在其请求中使用所谓的分块传输编码时，这是行不通的。但是，使用分块传输读取请求正文的工作方式类似；在这种情况下，退出条件不依赖于`Content-Length`标头，而是在读取第一个空块时。
- en: 'After the complete request body has been read, you can then pass this body
    into the `$checkoutService` that you have already used before:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在完整的请求正文被读取后，您可以将此正文传递给之前已经使用过的`$checkoutService`：
- en: '[PRE69]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `CheckoutService` class is used exactly the same way as before. The only
    difference now is how the response is sent back to the client; if the original
    request was received by the ZeroMQ REP socket, a respective response was sent
    to the REQ socket that sent the request. Now, if the request was received by the
    HTTP server, an HTTP response with the same content is sent.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckoutService`类的使用方式与以前完全相同。现在唯一的区别是如何将响应发送回客户端；如果原始请求是由ZeroMQ REP套接字接收的，则将相应的响应发送到发送请求的REQ套接字。现在，如果请求是由HTTP服务器接收的，则会发送具有相同内容的HTTP响应。'
- en: 'You can test your new HTTP API using a command-line tool such as curl or HTTPie:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用curl或HTTPie等命令行工具测试新的HTTP API：
- en: '[PRE70]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following screenshot shows an example output when testing the new API endpoint
    using the preceding HTTPie command:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用前面的HTTPie命令测试新API端点时的示例输出：
- en: '![Bridging ZeroMQ and HTTP](graphics/image_07_011.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![桥接ZeroMQ和HTTP](graphics/image_07_011.jpg)'
- en: Testing the new HTTP API
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 测试新的HTTP API
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned about ZeroMQ as a new communication protocol
    and how you can use it in PHP. In contrast to HTTP, ZeroMQ supports other and
    more complex communication patterns than the simple request/reply pattern. Especially
    the publish/subscribe and the push/pull pattern, which allow you to build loosely
    coupled architectures that are easily extensible by new functionalities and scale
    very well.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了ZeroMQ作为一种新的通信协议以及如何在PHP中使用它。与HTTP相比，ZeroMQ支持比简单的请求/响应模式更复杂的通信模式。特别是发布/订阅和推送/拉取模式，它们允许您构建松散耦合的架构，可以轻松扩展新功能并且可以很好地扩展。
- en: You have also learned how you can use the ReactPHP framework to build asynchronous
    services using event loops and how you can make asynchronicity manageable using
    promises. We have also discussed how you can integrate ZeroMQ-based applications
    with *regular* HTTP APIs.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学会了如何使用ReactPHP框架构建使用事件循环的异步服务，以及如何使用承诺使异步性可管理。我们还讨论了如何将基于ZeroMQ的应用程序与*常规*HTTP
    API集成。
- en: While the previous chapters have all focused on different network communication
    patterns (RESTful HTTP in [Chapter 5](ch05.html "Chapter 5.  Creating a RESTful
    Web Service"), *Creating a RESTful Web Service*, WebSockets in [Chapter 6](ch06.html
    "Chapter 6.  Building a Chat Application"), *Building a Chat Application*, and
    now ZeroMQ), we will make a fresh start in the following chapter and learn how
    PHP can be used to build parsers for custom expression languages.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以前的章节都集中在不同的网络通信模式上（[第5章](ch05.html "第5章。创建RESTful Web服务")中的RESTful HTTP，*创建RESTful
    Web服务*，[第6章](ch06.html "第6章。构建聊天应用程序")中的WebSockets，*构建聊天应用程序*，以及现在的ZeroMQ），我们将在接下来的章节中重新开始，并学习如何使用PHP构建用于自定义表达式语言的解析器。
