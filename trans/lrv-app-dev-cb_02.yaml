- en: Chapter 2. Using Forms and Gathering Input
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。使用表单和收集输入
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating a simple form
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的表单
- en: Gathering form input to display on another page
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集表单输入以在另一页上显示
- en: Validating user input
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证用户输入
- en: Creating a file uploader
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个文件上传器
- en: Validating a file upload
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证文件上传
- en: Creating a custom error message
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义错误消息
- en: Adding a "honey pot" to a form
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向表单添加“蜜罐”
- en: Uploading an image using Redactor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redactor上传图像
- en: Cropping an image with Jcrop
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jcrop裁剪图像
- en: Creating an autocomplete text input
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个自动完成文本输入
- en: Making a CAPTCHA style spam catcher
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个验证码样式的垃圾邮件捕捉器
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we'll learn about using forms in Laravel, and how to accomplish
    some typical tasks. We'll begin with some simple form validation and file uploads,
    and move on to incorporating some frontend tools, such as Redactor and jCrop,
    into Laravel.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在Laravel中使用表单，以及如何完成一些典型的任务。我们将从一些简单的表单验证和文件上传开始，然后继续将一些前端工具，如Redactor和jCrop，整合到Laravel中。
- en: Creating a simple form
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的表单
- en: One of the most basic aspects of any web application is the form. Laravel provides
    easy ways to build HTML for our forms.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Web应用程序的最基本方面之一是表单。Laravel提供了一种简单的方法来为我们的表单构建HTML。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, we need a fresh installation of Laravel.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要一个全新的Laravel安装。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'To complete this recipe, follow these steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此示例，请按照以下步骤操作：
- en: In the `app/views` folder, create a new `userform.php` file.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/views`文件夹中，创建一个新的`userform.php`文件。
- en: 'In `routes.php`, create a route to load the view:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`routes.php`中，创建一个路由来加载视图：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `userform.php` view, create a form using the following code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`userform.php`视图中，使用以下代码创建一个表单：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: View your form in the web page, by going to `http://{your-server}/userform`
    (where `{your-server}` is the name of your server).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过转到`http://{your-server}/userform`（其中`{your-server}`是您的服务器的名称）在Web页面中查看您的表单。
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: For this task, we created a simple form using Laravel's built-in `Form` class.
    This allows us to easily create form elements with minimal code, and it's W3C
    (World Wide Web Consortium) compliant.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，我们使用Laravel内置的`Form`类创建了一个简单的表单。这使我们能够轻松地使用最少的代码创建表单元素，并且它符合W3C（万维网联盟）标准。
- en: First, we open the form. Laravel automatically creates the `<form>` html, including
    the action, the method, and the accept-charset parameters. When there are no options
    passed in, the default action is the current URL, the default method is `POST,`
    and the charset is taken from the application config file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们打开表单。Laravel会自动创建`<form>`html，包括action、method和accept-charset参数。当没有传递选项时，默认操作是当前URL，默认方法是`POST`，字符集取自应用配置文件。
- en: Next we create normal text and password input fields, along with their labels.
    The first parameter in the label is the name of the text field and the second
    is the actual text to print. In the form builder, the label should appear before
    the actual form input.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建普通文本和密码输入字段，以及它们的标签。标签中的第一个参数是文本字段的名称，第二个参数是要打印的实际文本。在表单构建器中，标签应该出现在实际表单输入之前。
- en: The form select requires a second parameter, an array of the value in the drop-down
    box. In this example, we're creating an array using the `'key' => 'value'` syntax.
    If we want to create option groups, we just need to create nested arrays.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表单选择需要第二个参数，即下拉框中值的数组。在本例中，我们使用`'key' => 'value'`语法创建一个数组。如果我们想创建选项组，我们只需要创建嵌套数组。
- en: Finally, we create our Submit button and close the form.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了提交按钮并关闭了表单。
- en: There's more...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Most of Laravel's form methods can also include parameters for a default value
    and custom attributes (classes, IDs, and so on). We could also use `Form::input()`
    for many fields, if we didn't want to use the specific methods. For example, we
    could have `Form::input('submit', NULL, 'Send it!')` to create a submit button.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Laravel的表单方法也可以包括默认值和自定义属性（类、ID等）的参数。如果我们不想使用特定的方法，我们也可以对许多字段使用`Form::input()`。例如，我们可以使用`Form::input('submit',
    NULL, 'Send it!')`来创建一个提交按钮。
- en: See also
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Gathering form input to display on another page* recipe
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*收集表单输入以在另一页上显示*示例'
- en: Gathering form input to display on another page
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集表单输入以在另一页上显示
- en: After a user submits a form, we need to be able to take that information and
    pass it to another page. This recipe shows how we can use Laravel's built-in methods
    to handle our POST data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 用户提交表单后，我们需要能够获取该信息并将其传递到另一页。这个示例展示了我们如何使用Laravel的内置方法来处理我们的POST数据。
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need the simple form set up from the *Creating a simple form* section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从*创建一个简单的表单*部分设置简单的表单。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Follow these steps to complete this recipe:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此示例：
- en: 'Create a route to handle the POST data from the form:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个路由来处理表单中的POST数据：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a route to redirect to, and to display the data:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个重定向到的路由，并显示数据：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In our simple form, we're POSTing the data back to the same URL, so we need
    to create a route that accepts `POST` using the same path. This is where we would
    do any processing of the data, including saving to a database or validating the
    input.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简单表单中，我们将数据POST回相同的URL，因此我们需要创建一个接受相同路径的`POST`路由。这是我们将对数据进行任何处理的地方，包括保存到数据库或验证输入。
- en: 'In this case, we simply want to pass the data to the next page. There are a
    number of ways to accomplish this. For example, we could use the `Input` class''s
    `flashOnly()` method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只是想将数据传递到下一页。有许多方法可以实现这一点。例如，我们可以使用`Input`类的`flashOnly()`方法：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, we're using a shortcut that Laravel provides, and only passing along
    two of the three form fields we asked for.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们使用了Laravel提供的一个快捷方式，只传递了我们要求的三个表单字段中的两个。
- en: On the next page, we use `Input::old()` to display the flashed input.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一页上，我们使用`Input::old()`来显示闪存输入。
- en: See also
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a simple form* recipe
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个简单的表单*示例'
- en: Validating user input
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证用户输入
- en: In most web applications, there will be certain form fields that are required
    to process the form. We also want to be sure that all the e-mail addresses are
    formatted correctly, or the input must have a certain number of characters. Using
    Laravel's `Validator` class, we can check for these rules and let the user know
    if something is not correct.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数Web应用程序中，将需要某些必填的表单字段来处理表单。我们还希望确保所有电子邮件地址的格式正确，或者输入必须具有一定数量的字符。使用Laravel的`Validator`类，我们可以检查这些规则，并让用户知道是否有不正确的地方。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we just need a standard installation of Laravel.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们只需要一个标准的Laravel安装。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To complete this recipe, follow these steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个食谱，按照以下步骤进行：
- en: 'Create a route to hold the form:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个路由来保存表单：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a view named `userform.php` and add a form:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`userform.php`的视图并添加一个表单：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a route that handles our `POST` data and validates it:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个处理我们的`POST`数据并验证它的路由：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a route to handle a successful form submission:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个路由来处理成功的表单提交：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In our form page, we begin by checking if there are any errors and displaying
    them if found. Inside the error, we can set the default style for each error message.
    We also have the option of checking for and displaying errors for individual fields
    using `$errors->get('email')`. The `$errors` variable is automatically created
    by Laravel if it detects a flashed error.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的表单页面中，我们首先检查是否有任何错误，并在找到错误时显示它们。在错误内部，我们可以为每个错误消息设置默认样式。我们还可以选择使用`$errors->get('email')`来检查并显示单个字段的错误。如果Laravel检测到闪存错误，`$errors`变量将自动创建。
- en: Next, we create our form. In the last parameter of the form elements, we're
    getting `Input::old()`, which we use to store the previous input if the validation
    happens to fail. That way, the user won't need to keep filling out the entire
    form.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的表单。在表单元素的最后一个参数中，我们获取`Input::old()`，如果验证失败，我们将使用它来存储先前的输入。这样，用户就不需要一直填写整个表单。
- en: We then create a route where the form is POSTed, and set up our validation rules.
    In this case, we use the required rule for `email`, `username`, and `password`,
    to make sure something is typed into those fields.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个路由，表单被POST提交，并设置我们的验证规则。在这种情况下，我们对`email`，`username`和`password`使用必填规则，以确保这些字段中有内容输入。
- en: The `email` field also gets the `email` rule, which uses PHP's built-in `FILTER_VALIDATE_EMAIL`
    filter of the `filter_var` function. The `email` field must also not be the same
    as the `username` field. The `username` field uses the size validation to check
    for at least six characters. Then the `password` field checks the value of the
    `password_confirm` field and makes sure they're the same.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`email`字段还使用`email`规则，该规则使用PHP的内置`FILTER_VALIDATE_EMAIL`过滤器的`filter_var`函数。`email`字段也不能与`username`字段相同。`username`字段使用大小验证来检查至少六个字符。然后`password`字段检查`password_confirm`字段的值，并确保它们相同。'
- en: Then, we create the validator and pass in all of the form data. If any of those
    rules aren't met, we navigate the user back to the form, and also send back any
    validation error messages as well as the original form input.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建验证器并传入所有表单数据。如果其中任何规则不符合，我们将用户导航回表单，并返回任何验证错误消息以及原始表单输入。
- en: If the validation passes, we go to the next page using Laravel's `dd()` helper
    function, which uses `var_dump()` to show the form values on the page.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果验证通过，我们使用Laravel的`dd()`辅助函数转到下一个页面，该函数使用`var_dump()`在页面上显示表单值。
- en: See also
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*The Creating a simple form recipe*'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个简单的表单食谱*'
- en: Creating a file uploader
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个文件上传程序
- en: There may be times when we'd like the user to upload a file to our server. This
    recipe shows how Laravel can handle file uploads through a web form.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望用户将文件上传到我们的服务器。这个食谱展示了Laravel如何通过Web表单处理文件上传。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To create a file uploader, we need a standard version of Laravel installed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个文件上传程序，我们需要安装标准版本的Laravel。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To complete this recipe, follow these steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个食谱，按照以下步骤进行：
- en: 'Create a route in our `routes.php` file to hold the form:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`routes.php`文件中创建一个路由来保存表单：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create the `fileform.php` View in our `app/views` directory:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`app/views`目录中创建`fileform.php`视图：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a route to upload and save the file:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个路由来上传和保存文件：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In our View, we use `Form::open ()` and pass in an array with `'files' => TRUE`
    that automatically sets the enctype in the `Form` tag; then we add a form field
    to take the file. Without using any other parameters in `Form::open()`, the form
    will use the default method of `POST` and action of the current URL. `Form::file()`
    is our input field to accept the files.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的视图中，我们使用`Form::open()`并传入一个数组，其中包含`'files' => TRUE`，这会自动设置`Form`标签中的enctype；然后我们添加一个表单字段来接受文件。在`Form::open()`中不使用任何其他参数，表单将使用默认的`POST`方法和当前URL的操作。`Form::file()`是我们接受文件的输入字段。
- en: Since our form is posting to the same URL, we need to create a route to accept
    the `POST` input. The `$file` variable will hold all the file information.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的表单正在提交到相同的URL，我们需要创建一个路由来接受`POST`输入。`$file`变量将保存所有文件信息。
- en: Next, we want to save the file with a different name but first we need to get
    the extension of the uploaded file. So we use the `guessExtension()` method, and
    store that in a variable. Most of the methods for using files are found in Symfony's
    File libraries.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要使用不同的名称保存文件，但首先我们需要获取上传文件的扩展名。因此，我们使用`guessExtension()`方法，并将其存储在一个变量中。大多数文件使用方法都可以在Symfony的文件库中找到。
- en: Finally, we move the file to its permanent location using the file's `move()`
    method, with the first parameter being the directory where we will save the file;
    the second is the new name of the file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用文件的`move()`方法将文件移动到其永久位置，第一个参数是我们将保存文件的目录；第二个是文件的新名称。
- en: If everything uploads correctly, we show `'Success'`, and if not we show `'Error'`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切上传正确，我们显示`'Success'`，如果不是，我们显示`'Error'`。
- en: See also
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Validating a file upload* recipe
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*验证文件上传*食谱'
- en: Validating a file upload
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证文件上传
- en: If we want to allow users to upload a file through our web form, we may want
    to restrict which kind of file they upload. Using Laravel's `Validator` class,
    we can check for a specific file type, and even limit the upload to a certain
    file size.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望允许用户通过我们的网络表单上传文件，我们可能希望限制他们上传的文件类型。使用Laravel的`Validator`类，我们可以检查特定的文件类型，甚至限制上传到特定文件大小。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need a standard Laravel installation, and an example file
    to test our upload.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要一个标准的Laravel安装和一个示例文件来测试我们的上传。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to complete this recipe:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个配方：
- en: 'Create a route for the form in our `routes.php` file:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`routes.php`文件中为表单创建一个路由：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create the form view:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建表单视图：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a route to validate and process our file:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个路由来验证和处理我们的文件：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start with a route to hold our form, and then a view for the form's html.
    At the top of the view, if we get any errors in validation, they will be echoed
    out here. The form begins with `Form::open (array('files' => TRUE))`, which will
    set the default action, method, and `enctype` for us.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个用于保存我们的表单的路由，然后是表单的html视图。在视图顶部，如果我们在验证中得到任何错误，它们将在这里被输出。表单以`Form::open
    (array('files' => TRUE))`开始，这将为我们设置默认的操作、方法和`enctype`。
- en: Next we create a route to capture the post data and validate it. We set a `$rules`
    variable as an array, first checking for a specific mime type. There can be as
    few or as many as we want. Then we make sure the file is less than 1000 kilobytes,
    or 1 megabyte.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个路由来捕获POST数据并验证它。我们将一个`$rules`变量设置为一个数组，首先检查特定的MIME类型。我们可以使用尽可能少或尽可能多的规则。然后我们确保文件小于1000千字节，或1兆字节。
- en: If the file isn't valid, we navigate the user back to the form with the error
    messages. The `$error` variable is automatically created in our view if Laravel
    detects a flashed error message. If it is valid, we attempt to save the file to
    the server. If it saves correctly, we'll see `"Success"`, and if not, we'll see
    `"Error"`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件无效，我们将用户导航回带有错误消息的表单。如果Laravel检测到闪存的错误消息，`$error`变量会自动在我们的视图中创建。如果它是有效的，我们尝试将文件保存到服务器。如果保存正确，我们将看到`"Success"`，如果不是，我们将看到`"Error"`。
- en: There's more...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'One other common validation for files is to check for an image. For that, we
    can use this in our `$rules` array:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的另一个常见验证是检查图像。为此，我们可以在我们的`$rules`数组中使用以下内容：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will check to make sure the file is either a `.jpg`, `.png`, `.gif`, or
    `.bmp` file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检查文件是否是`.jpg`、`.png`、`.gif`或`.bmp`文件。
- en: See also
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a file uploader* recipe
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建文件上传器*配方'
- en: Creating a custom error message
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义错误消息
- en: Laravel has built-in error messages if a validation fails, but we may want to
    customize those messages to make our application unique. This recipe shows a few
    different ways to create custom error messages.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果验证失败，Laravel内置了错误消息，但我们可能希望自定义这些消息，使我们的应用程序变得独特。这个配方展示了创建自定义错误消息的几种不同方法。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we just need a standard installation of Laravel.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们只需要一个标准的Laravel安装。
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To complete this recipe, follow these steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，请按照以下步骤：
- en: 'Create a route in `routes.php` to hold the form:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`routes.php`中创建一个路由来保存表单：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a view named `myform.php` and add a form:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`myform.php`的视图并添加一个表单：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a route that handles our POST data and validates it:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个路由来处理我们的POST数据并验证它：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Open the file `app/lang/en/validation.php`, where `en` is the default language
    of the app. In our case, we''re using English. At the bottom of the file, update
    the `attributes` array as the following:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件`app/lang/en/validation.php`，其中`en`是应用程序的默认语言。在我们的情况下，我们使用的是英语。在文件底部，更新`attributes`数组如下：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a route to handle a successful form submission:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个路由来处理成功的表单提交：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We first create a fairly simple form, and since we aren't passing any parameters
    to `Form::open()`, it will POST the data to the same URL. We then create a route
    to accept the `POST` data and validate it. As a best practice, we're also adding
    in the `csrf` filter before our `post` route. This will provide some extra security
    against cross-site request frogeries.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个相当简单的表单，由于我们没有向`Form::open()`传递任何参数，它将把数据POST到相同的URL。然后我们创建一个路由来接受`POST`数据并验证它。作为最佳实践，我们还在我们的`post`路由之前添加了`csrf`过滤器。这将提供一些额外的安全性，防止跨站点请求伪造。
- en: The first variable we set in our `post` route will hold our rules. The next
    variable will hold any custom messages we want to use if there's an error. There
    are a few different ways to set the message.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`post`路由中设置的第一个变量将保存我们的规则。下一个变量将保存我们希望在出现错误时使用的任何自定义消息。有几种不同的方法来设置消息。
- en: The first message to customize is for `min` size. In this case, it will display
    the same message for any validation errors where there's a `min` rule. We can
    use `:attribute` and `:min` to hold the form field name and minimum size when
    the error is displayed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义的第一个消息是`min`大小。在这种情况下，它将显示相同的消息，用于任何验证错误，其中有一个`min`规则。我们可以使用`:attribute`和`:min`来保存表单字段名称和错误显示时的最小大小。
- en: Our second message is used only for a specific form field and for a specific
    validation rule. We put the form field name first, followed by a period, and then
    the rule. Here, we are checking whether the username is required and setting the
    error message.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个消息仅用于特定的表单字段和特定的验证规则。我们首先放置表单字段名称，然后是一个句号，然后是规则。在这里，我们正在检查用户名是否必填，并设置错误消息。
- en: Our third message is set in the language file for validations. In the `attributes`
    array, we can set any of our form field names to display any custom text we'd
    like. Also, if we decide to customize a particular error message across the entire
    application, we can alter the default message at the top of this file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个消息是在验证的语言文件中设置的。在`attributes`数组中，我们可以将我们的任何表单字段名称设置为显示我们想要的任何自定义文本。此外，如果我们决定自定义整个应用程序中的特定错误消息，我们可以在该文件的顶部更改默认消息。
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If we look in the `app/lang` directory, we see quite a few translations that
    are already part of Laravel. If our application is localized, we can set custom
    validation error messages in any language we choose.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`app/lang`目录，我们会看到许多翻译已经是Laravel的一部分。如果我们的应用程序是本地化的，我们可以选择任何语言设置自定义验证错误消息。
- en: See also
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a simple form* recipe
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个简单的表单*教程'
- en: Adding a honey pot to a form
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向表单添加蜜罐
- en: A sad reality of the Web is that there are "spam bots" that search the web and
    look for forms to submit spam to. One way to help combat this is to use a technique
    called a **honey pot**. In this recipe, we'll create a custom validation to check
    for spam submissions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的一个悲哀现实是存在“垃圾邮件机器人”，它们搜索网络并寻找要提交垃圾邮件的表单。帮助应对这一问题的一种方法是使用一种称为**蜜罐**的技术。在这个教程中，我们将创建一个自定义验证来检查垃圾邮件提交。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we just need a standard Laravel installation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们只需要一个标准的Laravel安装。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To complete this recipe, follow these steps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个教程，请按照以下步骤进行：
- en: 'Create a route in `routes.php` to hold our form:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`routes.php`中创建一个路由来保存我们的表单：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a view in our `app/view` directory named as `myform.php` and add the
    form:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`app/view`目录中创建一个名为`myform.php`的视图，并添加表单：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a route in our `routes.php` file to handle the `post` data, and validate
    it:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`routes.php`文件中创建一个路由来处理`post`数据，并对其进行验证：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In our `routes.php` file, create a custom validation:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`routes.php`文件中，创建一个自定义验证：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a simple route to use for a success page:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的路由用于成功页面：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We first create a fairly simple form; since we aren't passing any parameters
    to `Form::open()`, it will POST the data to the same URL. In the form, we create
    a field that's designed to be empty, but hide it from the user using CSS. By naming
    it as something with the word `email` in it, many spam bots will mistake it for
    an `email` field and try to populate it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个相当简单的表单；因为我们没有向`Form::open()`传递任何参数，它将把数据POST到相同的URL。在表单中，我们创建一个旨在为空的字段，但使用CSS隐藏它。通过将其命名为带有`email`一词的内容，许多垃圾邮件机器人会误以为它是一个`email`字段并尝试填充它。
- en: We then create a route to accept the `post` data and validate it, along with
    having a `csrf` filter added before the route. We add a custom validation rule
    to our `no_email` field, which will make sure that field stays empty. We also
    create an error message for that rule in the `$messages` array.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个路由来接受`post`数据并对其进行验证，并在路由之前添加一个`csrf`过滤器。我们为我们的`no_email`字段添加一个自定义验证规则，以确保该字段保持为空。我们还在`$messages`数组中为该规则创建一个错误消息。
- en: Next, we actually create our custom validation rule in the `routes` file. This
    rule will get the value from the form field and return `TRUE` if the value is
    empty.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实际上在`routes`文件中创建我们的自定义验证规则。这个规则将从表单字段获取值，并在值为空时返回`TRUE`。
- en: Now, if a bot tries to fill in the entire form, it will not validate since that
    extra field is designed to stay empty.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果一个机器人试图填写整个表单，它将无法验证，因为额外的字段设计为保持为空。
- en: There's more...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'One alternative to creating a custom validation is to use the rule `size: 0`,
    which will make sure the `honey_pot` field is exactly `0` characters in length.
    However, this method keeps the validation check much simpler.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '创建自定义验证的另一种选择是使用规则`size: 0`，这将确保`honey_pot`字段的长度正好为`0`个字符。然而，这种方法使验证检查变得简单得多。'
- en: We might also want to redirect any honey pot errors to another page that doesn't
    have a form. That way, any automatic form submission scripts won't continue to
    try and submit the form.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还希望将任何蜜罐错误重定向到另一个没有表单的页面。这样，任何自动表单提交脚本都不会继续尝试提交表单。
- en: Uploading an image using Redactor
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redactor上传图片
- en: There are a few different JavaScript libraries that can turn a form's text area
    into a WYSIWYG editor. Redactor is a newer library but is very well coded and
    has gained quite a bit of popularity in a short amount of time. For this recipe,
    we'll apply Redactor to our Laravel form, and create routes to allow for image
    uploads through Redactor.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些不同的JavaScript库可以将表单的文本区域转换为所见即所得的编辑器。Redactor是一个较新的库，但编码非常好，并在短时间内获得了相当大的流行。在这个教程中，我们将把Redactor应用到我们的Laravel表单中，并创建路由以允许通过Redactor上传图片。
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to download a copy of Redactor from [https://github.com/dybskiy/redactor-js/tree/master/redactor](https://github.com/dybskiy/redactor-js/tree/master/redactor).
    Download `redactor.min.js` and save it to the `public/js` directory. Download
    `redactor.css` and save it to the `public/css` directory.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从[https://github.com/dybskiy/redactor-js/tree/master/redactor](https://github.com/dybskiy/redactor-js/tree/master/redactor)下载Redactor的副本。下载`redactor.min.js`并保存到`public/js`目录。下载`redactor.css`并保存到`public/css`目录。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To complete this recipe, follow these steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个教程，请按照以下步骤进行：
- en: 'Create a route in our `routes.php` file to hold our form with the `redactor`
    field:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`routes.php`文件中创建一个路由来保存带有`redactor`字段的表单：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a view in our `app/views` directory and name it as `redactor.php`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`app/views`目录中创建一个名为`redactor.php`的视图：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Make a route that will handle the image upload:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个处理图片上传的路由：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create another route to show our form input after it''s submitted:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个路由来显示我们的表单输入后。
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After creating our form route, we create the view to hold our form HTML. In
    the head of the page, we load in the redactor CSS, the jquery library (using Google's
    CDN), and the redactor JavaScript file.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完我们的表单路由后，我们创建视图来保存我们的表单HTML。在页面的头部，我们加载redactor CSS，jquery库（使用Google的CDN），和redactor
    JavaScript文件。
- en: Our form will only have one field, a text area named `mytext`. In our script
    area, we initialize Redactor on the text area field and set the `imageUpload`
    parameter to a route or controller that will accept the image upload. Ours is
    set to `redactorupload`, so we create a route for it that accepts `post` data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单只有一个字段，一个名为`mytext`的文本区域。在我们的脚本区域中，我们在文本区域字段上初始化Redactor，并将`imageUpload`参数设置为一个接受图片上传的路由或控制器。我们的设置为`redactorupload`，所以我们为它创建一个接受`post`数据的路由。
- en: In our `redactorupload` route, we do some validation and, if everything is okay,
    the image will upload to our images directory. To get the image to display in
    our text area, it needs a JSON array with a file link as the key and the image
    path as the value. For this, we'll use Laravel's built-in `Response::json` method,
    and pass in an array with the image's location.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`redactorupload`路由中，我们进行一些验证，如果一切正常，图像将上传到我们的图像目录。要在文本区域中显示图像，它需要一个带有文件链接的JSON数组作为键，图像路径作为值。为此，我们将使用Laravel内置的`Response::json`方法，并传入一个带有图像位置的数组。
- en: On our form page, if the image validated and uploaded correctly, Redactor will
    display the image inside the text area. If we submit, we'll see the text included
    the `<img>` tag and the image path.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的表单页面上，如果图像验证和上传正确，Redactor将在文本区域内显示图像。如果我们提交，我们将看到文本包括`<img>`标签和图像路径。
- en: There's more...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While this recipe is specifically for image uploads, non-image file uploads
    work in a very similar manner. The only real difference is that file upload route
    should also return filename in the JSON output.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个示例是专门用于图像上传的，但非图像文件上传的工作方式非常类似。唯一的真正区别是文件上传路由还应该在JSON输出中返回文件名。
- en: Cropping an image with Jcrop
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jcrop裁剪图像
- en: Image editing and manipulation can sometimes be a difficult thing to implement
    in our application. Using Laravel and the Jcrop JavaScript library, we can make
    the task much simpler.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图像编辑和处理有时可能是我们应用程序中难以实现的事情。使用Laravel和Jcrop JavaScript库，我们可以使任务变得更简单。
- en: Tip
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)购买的所有Packt图书的帐户中下载示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接将文件发送到您的电子邮件。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to download the Jcrop library from [http://deepliquid.com/content/Jcrop_Download.html](http://deepliquid.com/content/Jcrop_Download.html)
    and unzip it. Put the file `jquery.Jcrop.min.js` into our `public/js` directory,
    and the `jquery.Jcrop.min.css` and `Jcrop.gif` files into our `public/css` directory.
    We'll use the Google CDN version of jQuery. We also need to make sure we have
    the GD library installed on our server, so we can do image manipulation. In our
    `public` directory, we'll need an images folder to store the images, and should
    have the permission set for it to be writable.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从[http://deepliquid.com/content/Jcrop_Download.html](http://deepliquid.com/content/Jcrop_Download.html)下载Jcrop库并解压缩。将文件`jquery.Jcrop.min.js`放入我们的`public/js`目录，将`jquery.Jcrop.min.css`和`Jcrop.gif`文件放入我们的`public/css`目录。我们将使用Google
    CDN版本的jQuery。我们还需要确保在服务器上安装了GD库，以便进行图像处理。在我们的`public`目录中，我们需要一个图像文件夹来存储图像，并且应该对其进行可写权限设置。
- en: How to do it...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to finish this recipe:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此示例：
- en: 'Let''s create a route in our `routes.php` file to hold our form:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在我们的`routes.php`文件中创建一个路由来保存我们的表单：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create the form for uploading an image, in `app/views` with the filename `imageform.php`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/views`中创建用于上传图像的表单，文件名为`imageform.php`：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Make a route to handle the image upload and validation:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个路由来处理图像上传和验证：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a route for our Jcrop form:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的Jcrop表单创建一个路由：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Make a form, where we can crop the image, in our `app/views` directory with
    the filename `jcrop.php`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`app/views`目录中创建一个表单，我们可以在其中裁剪图像，文件名为`jcrop.php`：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a route that will process the image and display it:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个处理图像并显示图像的路由：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start with a basic file upload; to make it easier, we'll only be using `.jpg`
    files. We use the validation to check for the image type as well as making sure
    the file size is under 10,000 kilobytes. After the file is uploaded, we send the
    path to our Jcrop route.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从基本的文件上传开始；为了简化，我们只使用`.jpg`文件。我们使用验证来检查图像类型，以及确保文件大小在10,000千字节以下。文件上传后，我们将路径发送到我们的Jcrop路由。
- en: In the HTML for the Jcrop route, we create a form with hidden fields that will
    hold the dimensions of the cropping. The JavaScript function `updateCoords` takes
    the cropping dimensions and updates the values of those hidden fields.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jcrop路由的HTML中，我们创建一个带有隐藏字段的表单，该字段将保存裁剪的尺寸。JavaScript函数`updateCoords`获取裁剪尺寸并更新这些隐藏字段的值。
- en: When we're done cropping, we submit the form and our route gets the POST data.
    The image is run through the GD library and cropped, based on the dimensions that
    were posted. We then overwrite the image and display the updated and cropped file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成裁剪时，我们提交表单，我们的路由获取POST数据。图像通过GD库进行裁剪，基于发布的尺寸。然后我们覆盖图像并显示更新和裁剪后的文件。
- en: There's more...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While this recipe only covers cropping a jpg image, adding in `gif` and `png`
    images wouldn't be very difficult. We'd just need to get the file extension by
    passing the file name to Laravel using `File::extension()`. Then, we could either
    do a `switch` or `if` statement to use the appropriate PHP function. For example,
    if the extension is `.png`, we'd use `imagecreatefrompng()` and `imagepng()`.
    More information can be found at [http://www.php.net/manual/en/ref.image.php](http://www.php.net/manual/en/ref.image.php).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个示例只涵盖了裁剪jpg图像，添加`gif`和`png`图像也不会很困难。我们只需要通过将文件名传递给Laravel并使用`File::extension()`来获取文件扩展名。然后，我们可以使用适当的PHP函数进行`switch`或`if`语句。例如，如果扩展名是`.png`，我们将使用`imagecreatefrompng()`和`imagepng()`。更多信息可以在[http://www.php.net/manual/en/ref.image.php](http://www.php.net/manual/en/ref.image.php)找到。
- en: Creating an autocomplete text input
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自动完成文本输入
- en: On our web forms, there may be times when we want to have an autocomplete text
    field. This can be handy for populating common search terms or product names.
    Using the jQueryUI Autocomplete library along with Laravel, that becomes an easy
    task.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的网络表单上，可能会有时候我们想要有一个自动完成文本字段。这对于填充常见搜索词或产品名称非常方便。使用jQueryUI自动完成库以及Laravel，这变得非常容易。
- en: Getting ready
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we'll be using the CDN versions of jQuery and jQueryUI; however,
    we could also download them and place them in our `public/js` directory, if we
    wanted to have them locally.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用jQuery和jQueryUI的CDN版本；但是，如果我们想要本地拥有它们，我们也可以下载它们并将它们放在我们的`public/js`目录中。
- en: How to do it...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To complete this recipe, follow these steps:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个食谱，请按照以下步骤进行：
- en: 'Create a route to hold our autocomplete form:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个路由来保存我们的自动完成表单：
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Make a view in the `app/views` directory named `autocomplete.php` with our
    form''s HTML and JavaScript:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/views`目录中创建一个名为`autocomplete.php`的视图，其中包含我们表单的HTML和JavaScript：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a route that will populate the data for the `autocomplete` field:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个路由，用于填充`autocomplete`字段的数据：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In our form, we're creating a text field to accept user input that will be used
    for the `autocomplete`. There's also a disabled text field that we can use to
    see the ID of the value that was selected. This can be useful if you have an ID
    for a particular value that's numeric, or otherwise not named in a standard way.
    In our example, we're using the first letter of the color as the ID.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的表单中，我们正在创建一个文本字段来接受用户输入，该输入将用于`autocomplete`。还有一个禁用的文本字段，我们可以用来查看所选值的ID。如果您对特定值有一个数字的ID，或者以非标准方式命名，这可能会很有用。在我们的示例中，我们使用颜色的第一个字母作为ID。
- en: As the user starts typing, `autocomplete` sends a `GET` request to the source
    that we added, using the word `term` in the query string. To process this, we
    create a route that gets the input, and convert it to lower-case. For our data,
    we're using a simple array of values but it would be fairly easy to add in a database
    query at this point. Our route checks the values in the array to see if there
    are any matches with the user input and, if so, adds the ID and value to the array
    we will return. Then, we output the array as JSON, for the `autocomplete` script.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户开始输入时，`autocomplete`会向我们添加的源发送一个`GET`请求，使用查询字符串中的单词`term`。为了处理这个，我们创建一个路由来获取输入，并将其转换为小写。对于我们的数据，我们使用一个简单的值数组，但在这一点上添加数据库查询也是相当容易的。我们的路由检查数组中的值，看看是否有任何与用户输入匹配的值，如果有，就将ID和值添加到我们将返回的数组中。然后，我们将数组输出为JSON，供`autocomplete`脚本使用。
- en: Back on our form page, when the user selects a value, we add the ID to the disabled
    response field. Many times, this will be a hidden field, which we can then pass
    on when we submit the form.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的表单页面，当用户选择一个值时，我们将ID添加到禁用的响应字段中。很多时候，这将是一个隐藏字段，我们可以在提交表单时传递它。
- en: There's more...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If we'd like to have our `getdata` route only accessible from our autocomplete
    form, or some other AJAX request, we could simply wrap the code in `if (Request::ajax())
    {}` or create a filter that rejects any non-AJAX requests.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要让我们的`getdata`路由只能从我们的自动完成表单或其他AJAX请求中访问，我们可以简单地将代码包装在`if (Request::ajax())
    {}`中，或者创建一个拒绝任何非AJAX请求的过滤器。
- en: Making a CAPTCHA-style spam catcher
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作类似CAPTCHA的垃圾邮件捕捉器
- en: One way to combat "bots" that automatically fill in web forms is by using the
    CAPTCHA technique. This shows the user an image with some random letters; the
    user must fill in a text field with those letters. In this recipe, we will create
    a CAPTCHA image and verify that the user has entered it correctly.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对抗自动填写网络表单的“机器人”的一种方法是使用CAPTCHA技术。这向用户显示一个带有一些随机字母的图像；用户必须在文本字段中填写这些字母。在这个食谱中，我们将创建一个CAPTCHA图像，并验证用户是否已正确输入。
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need a standard Laravel installation and make sure we have the GD2 library
    installed on our server, so we can create an image.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个标准的Laravel安装，并确保我们的服务器上安装了GD2库，这样我们就可以创建一个图像。
- en: How to do it...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To complete this recipe, follow these steps:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个食谱，请按照以下步骤进行：
- en: 'In our `app` directory, create a directory named `libraries`, and in our `composer.json`
    file, update it as follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`app`目录中，创建一个名为`libraries`的目录，并在我们的`composer.json`文件中更新如下：
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In our `app/libraries` directory, create a file named `Captcha.php` to hold
    our simple `Captcha` class:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`app/libraries`目录中，创建一个名为`Captcha.php`的文件，用于保存我们简单的`Captcha`类：
- en: '[PRE40]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the root of our app, open the command-line interface to update the `composer`
    autoloader:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的应用程序根目录中，打开命令行界面以更新`composer`自动加载程序：
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a route in `routes.php` to hold the form with `captcha`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`routes.php`中创建一个路由来保存带有`captcha`的表单：
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create our `captcha` view in the `app/views` directory with the name `captcha.php`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/views`目录中创建我们的`captcha`视图，名称为`captcha.php`：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a route to compare the `captcha` value and the user input:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个路由来比较`captcha`值和用户输入：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We begin by updating our `composer.json` file to add our `libraries` directory
    to the autoloader. Now, we can add any classes or libraries we'd like into that
    directory, even if they're custom classes or possibly some legacy code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先更新我们的`composer.json`文件，将我们的`libraries`目录添加到自动加载程序中。现在，我们可以将任何我们想要的类或库添加到该目录中，即使它们是自定义类或可能是一些旧代码。
- en: To keep things simple, we create a simple `Captcha` class with a single `make()`
    method. In this method, we first create a random string using Laravel's `Str:random()`,
    which we tell to output a 6-character string of only letters. We then save that
    string to a session, so we can use it for validation later.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们创建了一个简单的`Captcha`类，其中只有一个`make()`方法。在这个方法中，我们首先使用Laravel的`Str:random()`创建一个随机字符串，我们告诉它输出一个只包含字母的6个字符的字符串。然后我们将该字符串保存到会话中，以便以后用于验证。
- en: Using the string, we create a 100x25 pixel jpg image, with a gray background
    and darker gray text. Instead of saving the file to the server, we use the output
    buffer and save the image data to a variable. That way, we can create a data URI
    to send back to our route.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串，我们创建了一个100x25像素的jpg图像，背景为灰色，文本为深灰色。我们不是将文件保存到服务器，而是使用输出缓冲区并将图像数据保存到一个变量中。这样，我们可以创建一个数据URI并发送回我们的路由。
- en: Next, we need to run composer's `dump-autoload` command, so our new class can
    be used by the application.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要运行composer的`dump-autoload`命令，这样我们的新类才能被应用程序使用。
- en: In our `captcha` route, we use the `Captcha` class to create the `captcha` data
    URI and send it to our form. For our purposes, the form will simply display the
    image and ask for the characters in a text field.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`captcha`路由中，我们使用`Captcha`类来创建`captcha`数据URI并将其发送到我们的表单。对于我们的目的，表单将简单地显示图像并要求在文本字段中输入字符。
- en: When the user submits the form, we compare the Session that the `Captcha` class
    created with the user input. In this recipe, we're just checking if the two values
    match but we could also create a custom validation method and add it our rules.
    We then set a session saying if it matched or not, and return the user back to
    the CAPTCHA page.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户提交表单时，我们将比较`Captcha`类创建的Session与用户输入。在这个示例中，我们只是检查这两个值是否匹配，但我们也可以创建一个自定义验证方法并将其添加到我们的规则中。然后我们设置一个会话来表示是否匹配，并将用户返回到CAPTCHA页面。
