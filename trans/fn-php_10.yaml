- en: Chapter 10. PHP Frameworks and FP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 PHP框架和FP
- en: Now that we've seen how functional programming can be used to solve common programming
    issues, it is time we apply these techniques when developing with a framework.
    This chapter will present various ways to do so with a few of the most common
    PHP frameworks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了功能编程如何可以用来解决常见的编程问题，是时候在使用框架开发时应用这些技术了。本章将介绍使用一些最常见的PHP框架的各种方法。
- en: Before we start, a little disclaimer. I am by no means an expert in each of
    the frameworks we will discuss here. I have worked with all of them at different
    levels, but this doesn't mean I know everything there is to know about them. So,
    it is possible I will not be presenting the latest best practices here, despite
    the research conducted while writing this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，有一个小免责声明。我绝对不是我们将在这里讨论的每个框架的专家。我在不同层面上都与它们一起工作过，但这并不意味着我知道有关它们的一切。因此，尽管在撰写本章时进行了研究，但我可能不会呈现最新的最佳实践。
- en: This being said, we won't write a lot of code in this chapter. We will mainly
    look at how you can interface existing functional code with the framework structure
    and how you can leverage the various framework features to help you write in a
    functional way. We will also discuss the pros and cons of each framework regarding
    functional programming.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在本章中我们不会写很多代码。我们主要会看看如何将现有的功能代码与框架结构进行接口化，以及如何利用各种框架功能来帮助您以功能方式编写代码。我们还将讨论每个框架在功能编程方面的利弊。
- en: 'In this chapter, we will have a look at the following frameworks:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看以下框架：
- en: Symfony
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Symfony
- en: Laravel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Laravel
- en: Drupal
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drupal
- en: WordPress
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WordPress
- en: I hear some of you in the background whispering that Drupal and WordPress are
    not frameworks but content management systems. I agree with you, but keep in mind
    that people are using both of them to create full-blown applications with e-commerce
    and other features, so they have their place here.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我听到一些人在背景中低声说Drupal和WordPress不是框架，而是内容管理系统。我同意你的观点，但请记住，人们正在使用它们来创建具有电子商务和其他功能的完整应用程序，因此它们在这里有其位置。
- en: Also, the **CodeIgniter** framework is missing from the list as I have never
    worked with it. However, you can probably use most of the advice that will be
    presented here with any framework, including CodeIgniter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**CodeIgniter**框架没有出现在列表中，因为我从未使用过它。但是，您可能可以使用将在这里介绍的大部分建议与任何框架一起使用，包括CodeIgniter。
- en: As a matter of fact, most of the advice in each part is useful in a variety
    of contexts. This is why I strongly suggest you read the sections about each framework.
    This will allow me to avoid repeating myself too much.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每个部分中的大部分建议在各种情境中都是有用的。这就是为什么我强烈建议您阅读关于每个框架的部分。这将使我避免重复太多。
- en: Symfony
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Symfony
- en: With the focus firmly on Dependency Injection, the Symfony framework is well
    suited to write functional code. Symfony developers are accustomed to declaring
    their controllers and services in a way that explicitly define their dependencies.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于依赖注入，Symfony框架非常适合编写功能代码。Symfony开发人员习惯于以一种明确定义其依赖关系的方式声明其控制器和服务。
- en: We could argue that injecting the whole container is a bit problematic. In a
    strict sense, the controller and service can still be pure, but obviously the
    cognitive burden is a bit heavier since you need to read the code to know exactly
    which dependency is used.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以争论整个容器的注入有点问题。在严格意义上，控制器和服务仍然可以是纯粹的，但显然认知负担会更重一些，因为您需要阅读代码才能确切知道使用了哪些依赖。
- en: In this part, we will discuss what parts of Symfony are well suited to functional
    programming and where you need to be cautious. We won't be able to cover everything
    as Symfony is a really complete framework with a lot of components but is should
    suffice to get you started.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们将讨论Symfony的哪些部分非常适合功能编程，以及您需要注意什么。我们无法覆盖所有内容，因为Symfony是一个非常完整的框架，具有��多组件，但它应该足以让您入门。
- en: Handling the request
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理请求
- en: 'The original `Request` class is not compliant with the `PSR-7 HTTP` message
    interfaces we already spoke about. This means it is not immutable, as the specification
    proposes. It is, however, really easy to obtain a PSR version of the request if
    you are using at least version 3.0.7 of the `SensioFrameworkExtraBundle` framework.
    You only need to install the required dependencies using Composer and change your
    controller actions signature a bit:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`Request`类不符合我们已经讨论过的`PSR-7 HTTP`消息接口。这意味着它不是不可变的，正如规范所建议的那样。但是，如果您使用的是`SensioFrameworkExtraBundle`框架的至少3.0.7版本，那么很容易获得请求的PSR版本。您只需要使用Composer安装所需的依赖项，并稍微更改您的控制器操作签名：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Your controller needs to use the new `ServerRequestInterface` classes instead
    of the more traditional `Request` class in its method signature:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您的控制器需要在其方法签名中使用新的`ServerRequestInterface`类，而不是更传统的`Request`类：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If, for any reason, you need to get hold of a `Request` or `Response` instance
    that is compatible with Symfony's interfaces, you can use the **Symfony PSR-7**
    Bridge.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于任何原因，您需要获取与Symfony接口兼容的`Request`或`Response`实例，您可以使用**Symfony PSR-7**桥接器。
- en: If you correctly inject only the dependencies you need in your controllers and
    services, with the help of the new PSR-7-compliant HTTP messages, you are now
    well prepared to write functional code for your Symfony application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在控制器和服务中正确注入了您需要的依赖项，并且使用了新的符合PSR-7标准的HTTP消息，那么您现在已经准备好为Symfony应用程序编写功能代码了。
- en: Database entities
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库实体
- en: One challenge you might encounter when writing completely pure function code
    is database access. Usually, developers use **Doctrine** with Symfony and, as
    far as I know, Doctrine does not yet have any facilities to help with writing
    referentially transparent code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写完全纯函数代码时，您可能会遇到的一个挑战是数据库访问。通常，开发人员在Symfony中使用**Doctrine**，据我所知，Doctrine目前还没有任何设施来帮助编写引用透明的代码。
- en: Using something like an IO monad is also cumbersome in the context of a framework
    because, at each entry and exit point of your functions, you will have to either
    encapsulate the parameters or transform the results to the format expected by
    the framework.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在框架的上下文中使用像IO单子这样的东西也很麻烦，因为在函数的每个入口和出口点，你都必须封装参数或将结果转换为框架期望的格式。
- en: We will try to see how we can mitigate this issue using various techniques.
    While we are at it, we will also learn how to leverage the `Maybe` type when using
    Doctrine.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试看看如何使用各种技术来减轻这个问题。在此过程中，我们还将学习如何在使用Doctrine时利用`Maybe`类型。
- en: Embeddables
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可嵌入对象
- en: Although not strictly related to functional programming, the idea of value objects
    can be used to attain some sort of immutability on your entities. It is also an
    idea worth exploring for its own benefits.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与函数式编程没有严格相关，但价值对象的概念可以用来实现实体的某种不可变性。这也是一个值得探索的想法，因为它本身也有一些好处。
- en: 'It is an idea we have already discussed in [Chapter 2](ch02.html "Chapter 2. 
    Pure Functions, Referential Transparency, and Immutability"), *Pure Functions,
    Referential Transparency, and Immutability*. I will, however, take this opportunity
    to give a somewhat different definition taken from domain-driven design:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在[第2章](ch02.html "第2章。纯函数、引用透明度和不可变性")中已经讨论过的想法，*纯函数、引用透明度和不可变性*。然而，我将借此机会给出一个有些不同的定义，这个定义来自领域驱动设计：
- en: '**Entity**: something that has an identity independent from its properties.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体**：具有与其属性无关的身份的东西。'
- en: '**Value object**: something that has no identity separate from its properties.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**价值对象**：没有与其属性分开的身份的东西。'
- en: A common example is a person having an address. The person is an entity and
    the address is a value object. If you change the name, address, or any other property
    of a person, it is still the same person. However, if you change anything on the
    address, it becomes a totally different address.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的例子是一个人有一个地址。人是一个实体，地址是一个值对象。如果你改变一个人的姓名、地址或任何其他属性，它仍然是同一个人。然而，如果你改变地址上的任何东西，它就成了完全不同的地址。
- en: Doctrine implements this idea under the name **Embeddables**. The term comes
    from the fact that a value object is always related to an entity, or embedded,
    as it has no point of existing on its own. You can find documentation on the official
    website at [http://docs.doctrine-project.org/en/latest/tutorials/embeddables.html](http://docs.doctrine-project.org/en/latest/tutorials/embeddables.html).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine在**可嵌入对象**的名称下实现了这个想法。这个术语来自于价值对象总是与实体相关联或嵌入的事实，因为它本身没有存在的意义。你可以在官方网站上找到文档[http://docs.doctrine-project.org/en/latest/tutorials/embeddables.html](http://docs.doctrine-project.org/en/latest/tutorials/embeddables.html)。
- en: Although I doesn't recommend hijacking this feature, to implement immutability
    for every relations you have, I strongly urge you to think of embeddables when
    designing your entities and using them whenever you can. It will help you with
    both coding functionally and improving the quality of your data model.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我不建议利用这个特性，来为你拥有的每个关系实现不可变性，但我强烈建议你在设计实体时考虑可嵌入对象，并在可以使用时使用它们。这将帮助你在功能上编码和提高数据模型的质量。
- en: Avoiding setters
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免使用setter
- en: If you start looking for best practices regarding the use of Doctrine and most
    ORMs, there is a good chance you will one day find someone proposing we avoid
    creating setter methods. There are usually a multitude of good arguments to do
    so. In our case, we will just concentrate on one of them-we want immutable entities
    to help us write pure functional code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始寻找关于使用Doctrine和大多数ORM的最佳实践，很有可能有一天你会发现有人建议我们避免创建setter方法。通常会有许多很好的理由这样做。在我们的情况下，我们只会集中在其中一个上——我们希望不可变的实体帮助我们编写纯函数式代码。
- en: In most cases, the proposed solution to get rid of setters will be to think
    in terms of tasks. For example, instead of having a `setState` and a `setPublicationDate`
    method setter on a `BlogPost` class, you will have a `publish` method, which will
    in turn change those two fields.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，摆脱setter的建议解决方案将是以任务为思考方式。例如，不是在`BlogPost`类上有一个`setState`和一个`setPublicationDate`方法，而是有一个`publish`方法，该方法将依次更改这两个字段。
- en: 'This is great advice as it allows you to have most of the business logic inside
    the entity where it belongs and it avoids having the object in some weird state
    because not all necessary steps were taken by the developer. A traditional class
    with setters would be something like the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的建议，因为它允许你将大部分业务逻辑放在实体内，避免因为开发人员没有采取所有必要的步骤而使对象处于一种奇怪的状态。一个传统的具有setter的类可能是以下的样子：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It can be transformed to the following implementation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以转换为以下实现：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we modify the values in place, leaving us with a side-effect.
    We might naively think that it's enough to clone the current object in the `publish`
    method and return the new version with the modified properties to obtain an immutable
    version of our method; sadly, this solution does not work.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在原地修改值，留下了副作用。我们可能天真地认为，在`publish`方法中克隆当前对象并返回具有修改属性的新版本就足以获得我们方法的不可变版本；遗憾的是，这种解决方案并不起作用。
- en: 'Doctrine stores which entities are managed by one of its units of work and
    a cloned entity is not in a managed state. We could attach the entity using some
    trick but then we would be in one of two situations:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine存储了哪些实体由其工作单元管理，克隆的实体不处于受控状态。我们可以使用一些技巧附加实体，但然后我们将处于以下两种情况之一：
- en: Both entities are managed, leading to possible issues with the internal coherence
    of metadata inside Doctrine itself
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个实体都是受控的，这可能会导致Doctrine内部元数据的一致性问题
- en: Only the latest entity is managed, meaning our call to the `publish` method
    had the side effect of detaching the previous entity from Doctrine
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有最新的实体是受控的，这意味着我们对`publish`方法的调用具有将先前的实体从Doctrine中分离的副作用
- en: The nail in the coffin is that there is currently no API available to do this
    from inside an entity. This is why I don't recommend pursuing immutable entities
    with the current Doctrine version at the time of writing (that is, version 2.5.5).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个问题的关键在于目前没有可用的API来在实体内部执行此操作。这就是为什么我不建议在写作时使用当前Doctrine版本（即版本2.5.5）追求不可变实体。
- en: Anyway, avoiding creating setters on your entities will already be a huge step
    in the direction of a referentially transparent codebase. It will also help you
    a lot with keeping your business logic all in one place with no possibility of entities
    being left in an invalid state.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，避免在实体上创建setter已经是朝着引用透明代码库的方向迈出了一大步。这也将帮助您将所有业务逻辑集中在一个地方，而不会出现实体处于无效状态的可能性。
- en: Why immutable entities?
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么要使用不可变实体？
- en: 'Instead of a long speech, let''s demonstrate this using a simple example. Doctrine
    uses instances of the `DateTime` class for anything related to dates and times.
    Since the `DateTime` class is mutable, this can lead to issues not at all easy
    to pinpoint:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不用多说，让我们用一个简单的例子来演示。Doctrine在与日期和时间相关的任何事务中使用`DateTime`类的实例。由于`DateTime`类是可变的，这可能会导致非常难以准确定位的问题。
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first issue is that you have a reference to the same object stored inside
    the entity. This means that if, for any reason, you change it, the date will also
    change inside the post. This might be what you want, but there is absolutely no
    doubt that this is a side-effect. Especially if you return the `$date` variable
    to a potential caller. How is it supposed to know that modifying the date will
    lead to modifying an entity?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是你在实体内部存储了对同一对象的引用。这意味着如果出于任何原因你对它进行了更改，日期也会在帖子内部发生变化。这可能是你想要的，但毫无疑问这是一个副作用。特别是如果你将`$date`变量返回给潜在的调用者。它怎么知道修改日期会导致修改实体呢？
- en: The second issue is more problematic. As Doctrine uses the object identity and
    not its value to determine whether something has changed, it will not know the
    date is now different and saving the post back into the database will amount to
    nothing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题更加棘手。由于Doctrine使用对象标识而不是其值来确定是否发生了变化，它将不知道日期现在已经不同，将帖子保存回数据库将毫无意义。
- en: There is a package available on GitHub ([https://github.com/VasekPurchart/Doctrine-Date-Time-Immutable-Types](https://github.com/VasekPurchart/Doctrine-Date-Time-Immutable-Types))
    for this particular issue, but, any time you use mutable instances instead of
    embeddables or any other kind of value objects, you can run into similar problems.
    Do yourself a favor and use immutability whenever possible.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub上有一个可用的包（[https://github.com/VasekPurchart/Doctrine-Date-Time-Immutable-Types](https://github.com/VasekPurchart/Doctrine-Date-Time-Immutable-Types)）来解决这个特定问题，但是，任何时候你使用可变实例而不是可嵌入的或任何其他类型的值对象，你都可能遇到类似的问题。请尽量使用不可变性。
- en: Symfony ParamConverter
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Symfony ParamConverter
- en: We discussed modifying already instantiated entities and persisting them back
    to the database. But what about getting them in the first place? The `SensioFrameworkExtraBundle`
    framework contains a nice little annotation called `@ParamConverter`, which allows
    us to let the framework do the job and keep the side-effect of getting entities
    from the database outside our codebase.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了修改已经实例化的实体并将其持久化到数据库中。但是首先如何获取它们呢？`SensioFrameworkExtraBundle`框架包含一个名为`@ParamConverter`的很好的小注解，它允许我们让框架来完成这项工作，并将从数据库获取实体的副作用放在我们的代码库之外。
- en: 'Here is a small example so that you understand how to use this annotation (if
    you want to know more, you can read the official documentation on the Symfony
    website at [http://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/converters.html](http://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/converters.html)):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小例子，以便你了解如何使用这个注解（如果你想了解更多，你可以在Symfony网站的官方文档中阅读：[http://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/converters.html](http://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/converters.html)）：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using the information from the route alongside the defined parameters conversion,
    the framework is able to give you the `Post` instance directly or generate a `404
    error` if it isn't able to find it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用路由中的信息以及定义的参数转换，框架能够直接给你`Post`实例，或者在找不到时生成`404错误`。
- en: Using the annotation, your method does not need to perform database access anymore
    as it will receive the data directly. We might argue that impure code exists somewhere
    else and it would be true, but Symfony is not supposed to be a pure codebase anyway.
    We were able to push the impurity out of our own code and that is what matters
    to us.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注解，你的方法不需要再执行数据库访问，因为它将直接接收数据。我们可能会争论说不纯的代码存在于其他地方，这是正确的，但Symfony本来就不应该是一个纯净的代码库。我们已经将不纯度从我们自己的代码中挤出去了，这对我们来说是最重要的。
- en: In this particular case, the type-hint would have been sufficient in relation
    to the route. The `ParamConverter` annotation will automatically enter an action
    when a function signature references an entity class. There is no harm in keeping
    the annotation if you find it clearer, or you can decide to only use it in more
    complex cases.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特殊情况下，类型提示已经足够与路由相关。`ParamConverter`注解将在函数签名引用实体类时自动进入操作。如果你觉得更清晰，保留这个注解也没有坏处，或者你可以决定只在更复杂的情况下使用它。
- en: There will obviously be circumstances where this mechanism is not powerful enough.
    I know some bundles provide similar features with more flexibility; you might
    be able to find one that suits your needs. And if nothing else works, you can
    still perform the query yourself or use an IO monad to do it for you.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 显然会有情况下这种机制不够强大。我知道一些包提供了类似的功能，更加灵活；你可能能够找到一个适合你需求的包。如果其他方法都不起作用，你仍然可以自己执行查询，或者使用IO单子来代替你执行查询。
- en: Maybe there is an entity
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 也许有一个实体
- en: 'Doctrine can be quite easily adapted to return instances of the Collection
    and Maybe monads. The first step is to create a new repository:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine可以很容易地适应返回Collection和Maybe单子的实例。第一步是创建一个新的存储库：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, you need to configure Symfony to use this new class as the default repository;
    this can be easily done by adding the following key to your YAML configuration:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要配置Symfony以使用这个新类作为默认存储库；这可以通过将以下键添加到您的YAML配置文件中轻松完成：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you aren't using Symfony, you can use the `setDefaultRepositoryClassName`
    method on a Doctrine `Configuration` class instance to achieve the same effect.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用Symfony，可以在Doctrine的`Configuration`类实例上使用`setDefaultRepositoryClassName`方法来实现相同的效果。
- en: With everything we have discussed regarding Doctrine, you won't be able to have
    a purely functional code when the database is involved but you are prepared enough
    to reap most of the benefits.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们讨论的有关Doctrine的一切，当涉及到数据库时，您将无法拥有纯粹的功能性代码，但您已经准备好获得大部分的好处。
- en: Organizing your business logic
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织您的业务逻辑
- en: The official Symfony best practices contain some advice on how and where to
    write your business logic. We will expand upon them a bit to facilitate writing
    functional code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 官方Symfony最佳实践包含一些建议，指导如何以及在哪里编写业务逻辑。我们将对其进行扩展，以便更容易编写功能性代码。
- en: 'The first advice is to avoid writing any logic in parts related to the framework
    itself: routing and the controllers. Those should be as straightforward as possible.
    It is a good idea to follow this advice because this way it doesn''t matter as
    much if you are forced to do some database access in the controller.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个建议是避免在与框架本身相关的部分（路由和控制器）中编写任何逻辑。这些部分应尽可能简单明了。遵循这个建议是个好主意，因为这样做的话，如果您被迫在控制器中进行一些数据库访问，也不会那么重要。
- en: I recommend you to do everything database-related inside the controller itself,
    so anything with side-effects is segregated there and your business logic can
    follow proper functional techniques.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您将所有与数据库相关的操作都放在控制器内部，这样具有副作用的内容就会被隔离在那里，您的业务逻辑可以遵循适当的功能性技术。
- en: Also, instead of using the service container, you should inject only the dependencies
    you need both in your controller and your services. This will greatly reduce the
    cognitive burden as the signature of your methods and constructors will be enough
    to determine the dependencies of your business logic.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您应该只在控制器和服务中注入您需要的依赖项，而不是使用服务容器。这将大大减轻认知负担，因为您的方法和构造函数的签名足以确定业务逻辑的依赖关系。
- en: I would also recommend you avoid using setter injection as calling the setter
    will modify the state of your service, thus breaking immutability and also leading
    to possible issues if the setter is called multiple times.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我还建议您避免使用setter注入，因为调用setter将修改服务的状态，从而破坏不可变性，并且如果多次调用setter可能会导致潜在问题。
- en: By taking the decision to limit your side effects to the controller, you can
    concentrate on writing functional code in your entities and services. This will
    make the entities and services easy to reason about and to test. Then, since the
    controller should contain no logic of its own, you can test the final parts using
    integration and functional tests and quickly gain confidence in your application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过决定将副作用限制在控制器中，您可以集中精力在实体和服务中编写功能性代码。这将使实体和服务易于理解和测试。然后，由于控制器不应包含自己的逻辑，您可以使用集成和功能测试来测试最终部分，并迅速对应用程序获得信心。
- en: Flash messages, sessions, and other APIs with side-effects
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flash消息、会话和其他具有副作用的API
- en: Flash messages are often used to communicate information to your users in a
    non-obtrusive way. The API proposed by Symfony to manage them is sadly not referentially
    transparent as you need to call a method on the controller that will add the message
    to a queue. The same is true for session data management.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Flash消息通常用于以不显眼的方式向用户传达信息。Symfony提出的管理API遗憾地不是引用透明的，因为您需要在控制器上调用一个方法来将消息添加到队列中。会话数据管理也是如此。
- en: This issue could be solved by integrating them somehow inside the `Response`
    object. This would, however, need to be done at the framework level. Such changes
    would either need to be incorporated upstream or would require a lot of maintenance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可以通过在`Response`对象内部以某种方式集成它们来解决。然而，这需要在框架级别完成。这些更改要么需要上游整合，要么需要大量的维护。
- en: One solution is to leverage the Writer or State monads in your services to hold
    that information and then persist them in the controller as we already decided
    to use it for side effects related to the database.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是在服务中利用Writer或State单子来保存信息，然后在控制器中持久化它们，因为我们已经决定在控制器中处理与数据库相关的副作用。
- en: However, I don't recommend using the IO monad as it will prove complicated without
    some kind of support at the framework level, especially since PHP lacks a good
    alternative to the *do notation* annotation available in Haskell. It will only
    complicate your code without real benefits.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我不建议使用IO单子，因为在没有框架级别的支持的情况下，它将变得复杂，特别是因为PHP缺乏Haskell中可用的*do notation*注释的良好替代方案。这只会使您的代码变得更加复杂，而没有真正的好处。
- en: The `Form` API is another example of instances with a lot of inner state and
    impure methods. It is, however, declarative enough for this fact to not pose a
    lot of issues. The fact that you can abstract the form creation into its own class
    also helps a lot with being able to consider it side-effect free.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Form` API是另一个具有大量内部状态和不纯方法的实例。然而，它足够声明性，以至于这个事实不会带来太多问题。您可以将表单创建抽象成自己的类，这也有助于考虑它是无副作用的。'
- en: I strongly suggest you create `Form` types whenever you can and treat the resulting
    `Form` instances as immutable objects as much as possible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您在可能的情况下创建`Form`类型，并尽可能将生成的`Form`实例视为不可变对象。
- en: Closing words
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束语
- en: Although designed with a strong emphasis on object-oriented design, Symfony
    offers us a good foundation to write functional code. Some concessions are needed,
    especially when it comes to database access and non-functional APIs provided by
    the framework, but the code you write yourself can be pretty much functional from
    start to end except in the controller itself.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Symfony在面向对象设计方面有着很强的重点，但它为我们提供了一个很好的基础来编写函数式代码。特别是在涉及数据库访问和框架提供的非函数式API时，需要做出一些让步，但您自己编写的代码基本上可以从头到尾都是函数式的，除了控制器本身。
- en: One downside of using a functional approach might be that you find yourself
    creating more services and classes to segregate all side-effects in a single part
    of your request life cycle.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数式方法的一个缺点可能是您发现自己创建了更多的服务和类，以将所有副作用隔离在请求生命周期的一个单独部分中。
- en: This has, however, the benefit of having a clearly decoupled codebase that might
    even be reused outside of Symfony if given the proper care. You will also be able
    to test each part more easily in separation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做的好处是拥有一个明确定义的代码库，甚至可以在Symfony之外得到重复使用，如果得到适当的关注。您还将能够更容易地分开测试每个部分。
- en: 'There is also nothing preventing you from applying functional techniques gradually
    in some parts and services of your application. By being able to slowly migrate
    your code to something more functional, you are able to apply the techniques immediately
    and it also helps with the learning curve of other people. You can use the following
    resources to better understanding the application of functional techniques:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序的某些部分和服务中逐渐应用函数式技术也没有任何阻碍。通过能够慢慢地将您的代码迁移到更加函数式的东西，您能够立即应用这些技术，这也有助于其他人的学习曲线。您可以使用以下资源更好地理解函数式技术的应用：
- en: '[https://vimeo.com/177154259](https://vimeo.com/177154259)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://vimeo.com/177154259](https://vimeo.com/177154259)'
- en: '[http://www.slideshare.net/boerdedavid/being-functional-in-php](http://www.slideshare.net/boerdedavid/being-functional-in-php)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.slideshare.net/boerdedavid/being-functional-in-php](http://www.slideshare.net/boerdedavid/being-functional-in-php)'
- en: Laravel
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Laravel
- en: As we have already discussed, the `collection` API from Laravel is a good example
    of an immutable data structure with nice functional methods on top of it. The
    database layer returning instances of the `Collection` class really helps with
    streamlining its use.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，Laravel的`collection` API是一个很好的不可变数据结构的例子，它在其顶部具有很好的函数式方法。返回`Collection`类实例的数据库层真的有助于简化其使用。
- en: However, the **Facade**pattern proposed by the framework is a no-go if you want
    to keep your functions pure. As soon as you use a façade, you end up using an
    external dependency that is not declared in your function signature.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您想保持函数的纯净，框架提出的**Facade**模式是不可取的。一旦您使用一个Facade，您就会使用一个未在函数签名中声明的外部依赖。
- en: Whatever your take on this pattern is, if you want to write referentially transparent
    code, you have to get rid of them. Luckily, Laravel provides helper functions
    for most common tasks and a way to access the container that is baking the facade.
    As we will see, it is thus not that difficult to use something different.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您对这种模式的看法如何，如果您想编写引用透明的代码，您必须摆脱它们。幸运的是，Laravel为大多数常见任务提供了辅助函数和访问容器的方法。正如我们将看到的那样，因此使用不同的东西并不那么困难。
- en: Since Laravel is also a framework based on object-oriented principles and the
    MVC pattern, all general advice from the Symfony sections also applies, especially
    the ones about decoupling the various parts and trying to segregate side effects
    in a unique place for each request, often the controller.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Laravel也是一个基于面向对象原则和MVC模式的框架，Symfony部分的所有一般建议也适用，特别是关于解耦各个部分并尝试将副作用隔离在每个请求的一个唯一位置的建议，通常是控制器。
- en: The way of achieving that may differ a bit but not too much; this is why I encourage
    you to read the previous section if you haven't done so already, as that advice
    will not be repeated here.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的方式可能有所不同，但并不会有太大差异；这就是为什么我鼓励您阅读前一节，如果您还没有这样做的话，因为那些建议将不会在这里重复。
- en: Database results
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库结果
- en: 'As already said, Laravel has a really great immutable collection implementation.
    All database queries returning multiple entities will return an instance of it.
    There''s a really good book presenting in detail all the ways you can leverage
    its features. You can find it alongside screencasts and other tutorials on the
    author''s website at [https://adamwathan.me/refactoring-to-collections/](https://adamwathan.me/refactoring-to-collections/).
    The collection might be immutable, but the objects in it are not. Since the Laravel
    ORM, Eloquent, is really different from Doctrine, it is, however, possible for
    us to make them so. Instead of using a `Repository` pattern and the `UnitOfWork`
    pattern, you simply have methods on a `Model` class that you have to extend, the
    `ActiveRecord` pattern. This means it is possible to implement your methods in
    a way that makes your entities immutable without having the issues we encountered
    about the internal state of Doctrine itself:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如已经提到的，Laravel有一个非常好的不可变集合实现。返回多个实体的所有数据库查询都将返回它的一个实例。有一本非常好的书详细介绍了您可以利用其功能的所有方法。您可以在作者的网站上找到它，以及相关的视频教程和其他教程，网址为[https://adamwathan.me/refactoring-to-collections/](https://adamwathan.me/refactoring-to-collections/)。集合可能是不可变的，但其中的对象不是。由于Laravel的ORM，Eloquent，与Doctrine非常不同，因此我们有可能使它们成为不可变的。您只需在一个`Model`类上扩展方法，而不是使用`Repository`模式和`UnitOfWork`模式，这意味着可以以一种使实体不可变的方式实现您的方法，而不会遇到有关Doctrine内部状态的问题：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As long as you don't modify the field used for the primary key, any call to
    the `save` method of your object will update the current row in the database.
    You might, however, want to add a `__clone` method on your object if you have
    non-scalar properties. PHP will only perform a shallow copy by default, meaning
    all references will stay the same. It might be what you want, but you need to
    make sure of it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 只要不修改用于主键的字段，对对象的`save`方法的任何调用都将更新数据库中的当前行。但是，如果您的对象具有非标量属性，则可能需要在对象上添加`__clone`方法。
    PHP默认只执行浅复制，这意味着所有引用将保持不变。这可能是您想要的，但您需要确保它。
- en: If you want to enforce the immutability of certain properties, there is a package
    available on GitHub ([https://github.com/davidmpeace/immutability](https://github.com/davidmpeace/immutability))
    to do exactly that. It should not be necessary if you are rigorous, but it might
    be a nice feature to have in a legacy codebase with both traditional and functional
    parts.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想强制某些属性的不可变性，GitHub上有一个可用的软件包([https://github.com/davidmpeace/immutability](https://github.com/davidmpeace/immutability))可以做到这一点。如果您严格遵守规定，则不需要，但在传统和功能部分都存在的遗留代码库中，这可能是一个不错的功能。
- en: Using Maybe
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Maybe
- en: 'As with Doctrine, it is also possible to return an instance of `Maybe` instead
    of `null`. As the structure is a bit different, we first need to create a new
    `Builder` class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与Doctrine一样，也可以返回`Maybe`的实例，而不是`null`。由于结构有些不同，我们首先需要创建一个新的`Builder`类：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Multiple methods were redefined because of the use of the `first` function which
    now returns an instance of the`Maybe` type instead of null. There is, however,
    no need to return instances of the `Collection` as the Laravel version is already
    a nice implementation even if it is not a monad.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`first`函数的使用，多个方法被重新定义，该函数现在返回`Maybe`类型的实例，而不是`null`。但是，无需返回`Collection`的实例，因为Laravel版本已经是一个很好的实现，即使它不是一个monad。
- en: 'Now we need our own `Model` class, which will use our `FunctionalBuilder` method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要我们自己的`Model`类，它将使用我们的`FunctionalBuilder`方法：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Those two new classes should work in most cases, but as we are redefining methods
    used by the framework itself, it is possible you might run into trouble. If this
    is the case, I would love to hear from you so the implementation can be refined
    to avoid the issue.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个新类在大多数情况下应该能够正常工作，但由于我们正在重新定义框架本身使用的方法，可能会遇到问题。如果是这种情况，我很乐意听取您的意见，以便改进实现以避免问题。
- en: You might also want to modify Collection monad so that an instance of the Maybe
    monad is returned instead of `null` in the various methods where it is appropriate.
    This will, however, require many more modifications than what we have done so
    far. As far as I know, there is currently no package providing this feature.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还希望修改Collection monad，以便在适当的各种方法中返回Maybe monad的实例，而不是`null`。但是，这将需要比我们迄今为止所做的更多的修改。据我所知，目前没有提供此功能的软件包。
- en: Getting rid of facades
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摆脱facade
- en: The concept of Facades might be useful to reduce the learning curve for newcomers
    and it might facilitate the use of the services proposed by Laravel. But whatever
    your opinion of them is, they are not functional for one bit because they introduce
    side-causes as soon as you use them.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Facades的概念可能对新手减少学习曲线有所帮助，并且可能有助于使用Laravel提供的服务。但无论您对它们的看法如何，它们都不是一点功能，因为一旦使用它们，就会引入副作用。
- en: It is fairly easy to get rid of them by injecting the dependencies inside your
    controllers and services, as is common practice in the Symfony world. Besides
    allowing you to write functional code, there is a hidden benefit to stopping using
    facades-your code will be less tied to Laravel and thus you might be able to reuse
    it more.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在控制器和服务中注入依赖项，可以很容易地摆脱它们，这是Symfony世界中的常见做法。除了允许您编写功能代码之外，停止使用facade还有一个隐藏的好处-您的代码将与Laravel的联系更少，因此您可能能够更多地重用它。
- en: Laravel offers a feature called **automatic injection** which will allow you
    to very easily get hold of the various components available through a Facade.
    It uses the type-hints to automatically inject the wanted dependency upon the
    class instantiation. It works in a multitude of contexts-controllers, event listeners,
    and middleware, for example.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel提供了一个名为**自动注入**的功能，它将允许您通过Facade非常轻松地获取各种组件。它使用类型提示在类实例化时自动注入所需的依赖项。它在多种上下文中都有效-例如控制器、事件监听器和中间件。
- en: 'Getting an instance of the `UserRepository` class is as simple as the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`UserRepository`类的实例就像下面这样简单：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The type-hint to use can be easily found by referring to the table available
    in the documentation at [https://laravel.com/docs/5.3/facades#facade-class-reference](https://laravel.com/docs/5.3/facades#facade-class-reference).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过参考文档中提供的表格轻松找到要使用的类型提示[https://laravel.com/docs/5.3/facades#facade-class-reference](https://laravel.com/docs/5.3/facades#facade-class-reference)。
- en: This nifty mechanism doesn't really decouple you from the framework, however,
    as you need to use the correct type-hint. Another way to manually inject your
    dependencies via the `bootstrap/start.php` of your project is described in the
    article at[http://programmingarehard.com/2014/01/11/stop-using-facades.html/](http://programmingarehard.com/2014/01/11/stop-using-facades.html/).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个巧妙的机制并没有真正将您与框架解耦，因为您需要使用正确的类型提示。通过项目的`bootstrap/start.php`手动注入依赖项的另一种方法在这篇文章中有描述[http://programmingarehard.com/2014/01/11/stop-using-facades.html/](http://programmingarehard.com/2014/01/11/stop-using-facades.html/)。
- en: HTTP request
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP请求
- en: 'As with Symfony, it is really easy to use the interfaces defined in PSR-7 instead
    of the one from the framework. Laravel uses the same bridge as Symfony to perform
    the transformation. You only need to install two packages using Composer:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与Symfony一样，使用PSR-7中定义的接口而不是框架中的接口非常容易。 Laravel使用与Symfony相同的桥梁执行转换。您只需要使用Composer安装两个软件包：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And then it is enough to use the `ServerRequestInterface` class as the type-hint
    instead of `Request` method when you want to obtain an instance of the PSR-7 version.
    Laravel will take care of converting the `Response` method to its own format itself
    if your controller action returns the PSR-7 version.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当你想要获取PSR-7版本的实例时，只需使用`ServerRequestInterface`类作为类型提示，而不是`Request`方法。如果你的控制器动作返回PSR-7版本，Laravel会自行将`Response`方法转换为自己的格式。
- en: Closing words
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束语
- en: The implementation decisions taken by the Laravel core developers go both ways.
    Some of them, such as the immutable collection implementation, are great when
    it comes to functional programming. Others, such as the use of Facades, make our
    life a bit more difficult.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel核心开发人员所做的实现决策有两面性。其中一些，比如不可变集合实现，在功能性编程方面非常出色。而另一些，比如使用Facades，会让我们的生活变得有些困难。
- en: It is, however, fairly simple to transform our code in order to use a more functional
    approach. The only difficulty you might encounter is when reading the documentation
    or tutorials, which will often describe patterns and practices we are trying to
    avoid.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将我们的代码转换为更加功能性的方法是相当简单的。你可能会遇到的唯一困难是阅读文档或教程时，它们通常描述我们试图避免的模式和实践。
- en: All in all, Laravel is as good as Symfony when it comes to writing functional
    code. The book about its collection implementation mentioned earlier is also a
    great way to learn how to use some functional techniques in relation to the Collection
    monad implementation. As far as I know, this kind of resource does not exist for
    Symfony.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，当涉及到编写功能性代码时，Laravel和Symfony一样出色。前面提到的关于其集合实现的书籍也是学习如何使用一些功能性技术与集合单子实现相关的绝佳方式。据我所知，Symfony没有这种资源。
- en: Drupal
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Drupal
- en: Drupal modules until version 7 relied on hooks to perform operations. Drupal
    hooks are functions following a certain naming pattern that get called by Drupal
    when various events occur when responding to a request to modify various aspects
    of the generated web page.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal模块直到版本7都依赖于钩子来执行操作。Drupal钩子是遵循特定命名模式的函数，当Drupal在响应请求时发生各种事件时，会调用这些函数来修改生成的网页的各个方面。
- en: In an ideal world, all hooks would receive all needed information to perform
    their work and the way to modify something would be using the return value. This
    is mostly true for some parts of the module API. Sadly, there are some functions
    that receive parameters passed by reference, such as the `hook_block_list_alter`
    function. Also, you sometimes need to access global variables, for example, to
    get hold of the current language.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界中，所有的钩子都会接收到执行工作所需的所有信息，并且修改某些东西的方式将使用返回值。这在某些模块API的部分是基本正确的。不幸的是，有一些函数会接收通过引用传递的参数，比如`hook_block_list_alter`函数。此外，有时你需要访问全局变量，例如获取当前语言。
- en: Drupal 8 moved to a class-based approach. The content should now be created
    inside a controller in order to be closer to Symfony terminology. The reason is
    that this new version now uses some of Symfony's core components. This does not
    mean it is impossible to use functional programing anymore, just that things are
    a bit different.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8转向了基于类的方法。现在应该在控制器中创建内容，以便更接近Symfony的术语。原因是这个新版本现在使用了Symfony的一些核心组件。这并不意味着不再可能使用功能性编程，只是事情有些不同。
- en: It is not the role of this book to explain in detail what changed from version
    7 to version 8\. There are plenty of tutorials out there doing a great job of
    that. Most of what will be presented here is general enough to be useful and true
    for both Drupal versions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的角色并不是详细解释从版本7到版本8发生了什么变化。有很多教程在做这方面的出色工作。这里将呈现的大部分内容都是足够通用并且对Drupal的两个版本都适用的。
- en: Database access
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库访问
- en: In Drupal 7, there are multiple functions you can use to perform database queries
    and access the results. Usually, you start with a `db_query` function, which returns
    a result object with various methods to inspect and process the data. The preferred
    Drupal 8 way is not to get a database connection injected inside your module or
    service and use it in a more object-oriented way.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drupal 7中，你可以使用多个函数来执行数据库查询并访问结果。通常，你会从`db_query`函数开始，该函数返回一个带有各种方法来检查和处理数据的结果对象。Drupal
    8的首选方式不是在模块或服务中注入数据库连接并以更面向对象的方式使用它。
- en: This change does not really affect us as, in both cases, it is not possible
    to query the database in a referentially transparent way. Also, people usually
    don't use an ORM with Drupal; most requests to the database are done using SQL
    directly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化实际上并不影响我们，因为在这两种情况下，都不可能以引用透明的方式查询数据库。此外，人们通常不会在Drupal中使用ORM；大多数对数据库的请求都是直接使用SQL进行的。
- en: This is why we won't linger on this subject besides repeating that it is important
    to segregate database access as much as possible so that the rest of your code
    can be functional.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们不会在这个主题上停留，除了重复强调尽可能隔离数据库访问，以便代码的其余部分可以是功能性的。
- en: Dealing with hooks requiring side effects
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理需要副作用的钩子
- en: The minimal Drupal module is composed of two files, the `info` file and the
    `module` file. The format of the `info` file changed from an ad hoc text file
    in Drupal 7 to a YAML file in Drupal 8, but the file still contains information
    about the module. The `module` file is the main PHP file of the module.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的Drupal模块由两个文件组成，`info`文件和`module`文件。`info`文件的格式从Drupal 7中的特定文本文件变为Drupal
    8中的YAML文件，但文件仍然包含有关模块的信息。`module`文件是模块的主要PHP文件。
- en: As we saw, some hooks require side-effects to perform their job and there is
    hardly a way around that fact. What I can recommend is to use the module file
    as the one that will hold all non-strictly functional code and putting all computations
    somewhere else.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，一些钩子需要副作用来执行它们的工作，几乎没有其他方法。我可以建议的是，将模块文件作为保存所有非严格功能性代码的文件，并将所有计算放在其他地方。
- en: 'In the case of Drupal 8, some controller methods might also need to have side-effects.
    In this case, I''ll give you the same advice as for Laravel and Symfony: keep
    those in the controller and use external services/helpers to perform referentially
    transparent computation.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drupal 8的情况下，一些控制器方法可能也需要具有副作用。在这种情况下，我会给您与Laravel和Symfony相同的建议：将这些保留在控制器中，并使用外部服务/助手来执行引用透明计算。
- en: How will we do that for the `hook_block_list_alter` function we spoke about
    earlier? First of all, this applies only for Drupal 7 as, in the next version,
    blocks are managed through a class, which kind of solves the issue of referential
    transparency for this particular case.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何为我们之前讨论过的`hook_block_list_alter`函数做到这一点？首先，这仅适用于Drupal 7，因为在下一个版本中，块是通过类管理的，这在这种特定情况下解决了引用透明性的问题。
- en: My advice is simply to create a second PHP file in your module, containing only
    pure functions. For example, this file could contain a `new_blocks` function taking
    the current blocks and language as its only parameters.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议只是在您的模块中创建第二个PHP文件，其中只包含纯函数。例如，这个文件可以包含一个`new_blocks`函数，它只接受当前块和语言作为参数。
- en: 'Then, in the module file, you can do the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在模块文件中，您可以执行以下操作：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function clearly has both side causes and side-effects; there is not much
    we can do about that. However, the `new_blocks` function can be pure, which means
    you can easily reason about it and test it like we saw in the previous chapters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数显然既有副作用又有副作用；我们对此无能为力。然而，`new_blocks`函数可以是纯的，这意味着您可以轻松地对其进行推理和测试，就像我们在前几章中看到的那样。
- en: This method can be applied to nearly anything. As soon as you get side causes
    or side-effects, perform those in the module file and then use a different file
    to hold your pure functions, which will do the necessary processing and computations.
    If you are using Drupal 8, instead of using the `module` file, you can use the
    controller as we already discussed for Symfony and Laravel.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法几乎可以应用于任何事物。一旦您遇到副作用或副作用，就在模块文件中执行这些操作，然后使用不同的文件来保存您的纯函数，这些函数将进行必要的处理和计算。如果您使用Drupal
    8，可以使用控制器，而不是使用`module`文件，就像我们已经讨论过的Symfony和Laravel一样。
- en: Hook orders
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 钩子顺序
- en: The beauty of Drupal comes from all the various modules available. This is so
    true that some people came up with a variation of one of the Apple marketing slogans: *There's
    a module for that!*. This comes with some difficulties, however. Not all modules
    are equal when it comes to quality, and you usually end up with a bunch of them
    for any given application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal的美妙之处在于所有可用的各种模块。这是如此真实，以至于有些人提出了苹果营销口号的变体之一：*有一个模块可以做到！*。然而，这也带来了一些困难。然而，当涉及到质量时，并非所有模块都是平等的，通常您会为任何给定的应用程序得到一堆模块。
- en: The corollary is that the information your own hooks receive may already have
    been altered by previous modules. Say you are writing a module to reorder some
    blocks on the page; it is perfectly possible that some of the blocks you expect
    to be present were already removed. Or maybe a key you are using in an associative
    array is already registered or will be overwritten.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 其推论是，您自己的钩子接收到的信息可能已经被之前的模块修改过。比如，您正在编写一个模块来重新排列页面上的一些块；很可能您期望存在的一些块已经被移除了。或者您在关联数组中使用的键已经被注册或将被覆盖。
- en: This can lead to some issues that are a bit hard to pinpoint exactly. Since
    your functions will be pure, it is, however, relatively easy to detect the fact
    that it comes from something else by explicitly adding a test to ensure it works
    as expected for a given dataset.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致一些问题，有点难以准确地确定。由于您的函数将是纯净的，因此相对容易检测到它来自其他地方的事实，方法是通过明确添加一个测试来确保它针对给定数据集按预期工作。
- en: A good piece of advice concerning this problem is to not make assumptions about
    what may or may not be present in anything you receive from Drupal. Always apply
    some kind of check to ensure that the data you receive is correctly structured
    and present.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个问题的一个很好的建议是，不要假设您从Drupal接收的任何内容中可能存在或不存在的内容。始终应用某种检查来确保您接收的数据结构正确并且存在。
- en: Closing words
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束语
- en: Probably for historical reasons, some Drupal hooks need to have side-effects
    in order to perform their duty. Also, not all information is passed as parameters
    to them, requiring us to access the global scope to get them. This fact requires
    that we find workarounds to keep as much code as possible pure.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 出于历史原因，一些Drupal钩子需要具有副作用才能执行其职责。此外，并非所有信息都作为参数传递给它们，这要求我们访问全局范围以获取它们。这个事实要求我们找到解决方法，以保持尽可能多的纯净代码。
- en: By introducing a more object-oriented approach coupled with service injection,
    Drupal 8 makes things a bit easier. Quite on a par with the experience we can
    have with Symfony or Laravel, but things are still not perfect.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入更多的面向对象的方法以及服务注入，Drupal 8使事情变得更容易。与我们在Symfony或Laravel中的经验相当，但事情仍然不完美。
- en: If you are rigorous in separating your impure functions from your pure ones
    in at least two files, your experience writing functional code can be really good.
    It might seem cumbersome to always create two functions to implement one hook,
    but it is the price you have to pay if you want pure functions and, in my opinion,
    it is worth it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在至少两个文件中严格区分您的不纯函数和纯函数，那么您编写功能代码的体验将非常好。如果您想要纯函数，那么实现一个钩子需要创建两个函数可能看起来很麻烦，但这是您必须付出的代价，而且在我看来，这是值得的。
- en: As we discussed, you can still experience issues on the final page rendering
    even if your pure code is thoroughly tested due to the order some hooks are called
    in, but those are usually easier to spot if you can have confidence in your functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论过的，即使您的纯代码经过了彻底测试，由于一些钩子的调用顺序，您仍然可能在最终页面呈现时遇到问题，但是如果您对函数有信心，这些问题通常更容易发现。
- en: The functional developer experience with Drupal is not perfect, but it gets
    close. You will have to make some concessions, but you can bind those to a few
    files to limit their impact on the rest of your code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal的功能开发者体验并不完美，但它接近。您将不得不做一些让步，但您可以将它们绑定到少数文件中，以限制它们对代码其余部分的影响。
- en: WordPress
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WordPress
- en: 'WordPress also has a hook system in place, although different from Drupal''s
    one. Instead of creating functions with a certain name, you register functions
    to a certain hook. Sadly, most of those hooks need to have side-effects by definition.
    For example, we can do this with the help of the `wp_footer` hook:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress也有一个钩子系统，尽管与Drupal的不同。您不是创建具有特定名称的函数，而是将函数注册到特定的钩子上。遗憾的是，根据定义，大多数这些钩子需要具有副作用。例如，我们可以通过`wp_footer`钩子来实现这一点：
- en: '*This hook provides no parameters. You use this hook by having your function
    echo output to the browser, or by having it perform background tasks. Your functions
    shouldn''t return, and shouldn''t take any parameters.*'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*此钩子不提供参数。您可以通过让您的函数向浏览器输出内容，或者让它执行后台任务来使用此钩子。您的函数不应返回，也不应该带任何参数。*'
- en: No return value, no parameters; we are forced to create a function with side-effects.
    This means that you will have to create wrapper functions around your code even
    more than what we just demonstrated with Drupal.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 没有返回值，没有参数；我们被迫创建一个具有副作用的函数。这意味着您将不得不在您的代码周围创建包装函数，甚至比我们刚刚在Drupal中演示的更多。
- en: Luckily, WordPress also allows you to have multiple files per plugin. Thus,
    the recommendation is the same-put all your impure code in the main file. Get
    all the information you need from the global context and perform any kind of operation
    with side-effects there. Once you have everything you need, call your pure functions
    for processing and computation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，WordPress还允许您在插件中拥有多个文件。因此，建议是一样的-将所有不纯的代码放在主文件中。从全局上下文中获取您需要的所有信息，并在那里执行任何类型的具有副作用的操作。一旦您获得所需的一切，调用您的纯函数进行处理和计算。
- en: Some WordPress tutorials present object-oriented programming as the next evolution
    for developers when they have mastered a more procedural way of writing plugins.
    If you plan on using functional techniques, it does not matter. You can organize
    your code using only functions or you can group them in classes. I would advise
    you to stick to the method you are more at ease with.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一些WordPress教程将面向对象编程呈现为开发人员掌握更为程序化的插件编写方式后的下一个进化阶段。如果您打算使用功能技术，这并不重要。您可以仅使用函数组织您的代码，也可以将它们分组到类中。我建议您坚持您更熟悉的方法。
- en: Database access
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库访问
- en: There are basically two ways to access databases in a WordPress plugin. You
    can use the `WP_Query` method directly and its object-oriented interface. Or you
    can use helper functions such as `get_posts` and `get_pages`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在WordPress插件中，基本上有两种访问数据库的方式。您可以直接使用`WP_Query`方法及其面向对象的接口。或者您可以使用辅助函数，如`get_posts`和`get_pages`。
- en: You might have heard or read somewhere that it is best to use the `WP_Query`
    function when writing your plugin using classes, and helpers when using functions.
    From a functional standpoint, it doesn't matter. None of them are in any way referentially
    transparent. You can use whichever you like best or suits your needs better.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经在某处听说或读到，当使用类编写插件时，最好使用`WP_Query`函数，而在使用函数时使用辅助函数。从功能的角度来看，这并不重要。它们都不是引用透明的。您可以使用您喜欢的或更适合您需求的任何一个。
- en: There is nothing much to be said about database access in a WordPress codebase.
    The issue is the same as with the other frameworks-there is currently no way to
    perform them in a pure way.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在WordPress代码库中，关于数据库访问并没有太多可说的。问题与其他框架相同-目前没有纯粹的方法来执行它们。
- en: This being said, the advice stays the same-try to segregate any code with side-causes
    and side-effects to a single file of your plugin and then delegate the computation
    and processing to pure functions living somewhere else.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，建议仍然是一样的-尽量将任何具有副作用的代码与副作用隔离到插件的单个文件中，然后将计算和处理委托给其他地方的纯函数。
- en: Benefits of a functional approach
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能方法的好处
- en: I said in the introduction of this part that it does not matter whether you
    use functions or objects to organize your code. This is only partially true. WordPress
    lacks all the injection features of frameworks such as Symfony or Laravel. This
    means that, if you are using objects, you will encounter difficulty in sharing
    instances around.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本部分的介绍中说过，无论您使用函数还是对象来组织您的代码都无关紧要。这只是部分正确。WordPress缺乏像Symfony或Laravel等框架的所有注入功能。这意味着，如果您使用对象，您将遇到在各处共享实例的困难。
- en: It isn't really an issue if your object is only used to hold pure methods that
    don't use any kind of internal state, but as we saw, it is sometimes necessary
    to make concessions. If you need to share an instance with such a state, your
    only solution is to make it available globally. The problem with such a variable
    is that it can be reassigned to something else, causing issues later on.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的对象仅用于保存不使用任何内部状态的纯方法，那么这并不是问题，但正如我们所看到的，有时需要做出让步。如果您需要与此类状态共享实例，您唯一的解决方案是将其全局可用。这样的变量的问题在于它可能被重新分配给其他内容，从而在以后引起问题。
- en: On the contrary, a function is available from anywhere and you cannot redefine
    it. This leads to more robust code as you limit the possibilities of side-effects.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，函数可以从任何地方使用，您无法重新定义它。这会导致更健壮的代码，因为您限制了副作用的可能性。
- en: Closing words
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束语
- en: Drupal's first release dates back to 2000, making it the oldest tool presented
    here. WordPress was born in 2003\. Drupal, however, has been rewritten since then,
    whereas the WordPress codebase was mostly extended without a full rewrite.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal的第一个版本可以追溯到2000年，使其成为这里介绍的最古老的工具。WordPress诞生于2003年。然而，Drupal自那时起已经被重写，而WordPress的代码库大多是在没有完全重写的情况下进行扩展。
- en: Why am I telling you this? Because most of the issues you encounter when trying
    to write functional code in WordPress will be related to its legacy codebase.
    The way software was written in 2000 is a bit different than the best practices
    we expect now.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我要告诉你这些？因为在尝试在WordPress中编写函数式代码时，你遇到的大部分问题都与其遗留代码库有关。2000年编写软件的方式与我们现在期望的最佳实践有些不同。
- en: A lot of work was done to modernize WordPress, but there is only so much you
    can do. Especially when the focus is not to make the framework functional-developer
    friendly. It is nonetheless possible to write functional code if you are willing
    to jump through some hoops to isolate the parts with side-effects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress进行了大量的现代化工作，但你能做的也只有这么多。特别是当重点不是使框架对函数式开发者友好时。然而，如果你愿意跳过一些障碍来隔离具有副作用的部分，仍然可以编写函数式代码。
- en: 'WordPress being mostly based on hooks, most of the API is composed of functions.
    Some of them referentially transparent, others not at all. It will take you some
    rigor to cleanly isolate those from the rest of your code. The benefits are always
    the same:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress主要基于钩子，大部分API由函数组成。其中一些是引用透明的，而另一些则完全不是。你需要一些严谨性来清晰地将它们与你的其余代码隔离开来。好处总是一样的：
- en: Reduced cognitive burden
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少认知负担
- en: Facilitated code reuse
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进代码重用
- en: Easier testing
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易的测试
- en: The downside will be that your main plugin file will mostly be composed of really
    small functions that only serves as wrapper around the impure functions of the
    WordPress API and then call your referentially transparent functions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是，你的主要插件文件将主要由一些非常小的函数组成，这些函数只是作为WordPress API的不纯函数的包装器，然后调用你的引用透明函数。
- en: If the name of your wrappers are close enough to their Wordpress counterpart,
    reading your code and navigating through it should be pretty easy for anyone having
    Wordpress knowledge. In the end, it is still a good idea to write as much functional
    code you are capable of.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的包装器的名称与它们的WordPress对应物足够接近，那么阅读你的代码并在其中导航对于任何熟悉WordPress的人来说应该是相当容易的。最终，尽可能多地编写函数式代码仍然是一个好主意。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As we already discussed earlier, there is no mainstream framework having a functional
    approach at its core. In this chapter, we tried to see how the techniques we've
    learned can be applied more or less successfully to some available frameworks
    and CMSes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论过的，没有一个主流框架在其核心具有函数式方法。在本章中，我们试图看到我们学到的技术如何更多或更少地应用于一些可用的框架和CMS。
- en: As we saw, it is always possible to use functional programming at least at some
    level. Sadly, depending on the framework, you will have to create non referentially
    transparent code at some point.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，至少在某个层面上总是可以使用函数式编程。遗憾的是，根据框架的不同，你将不得不在某个时候创建非引用透明的代码。
- en: As I said in the introduction, I am not an expert in all the libraries we discussed
    in this chapter, so take everything with a grain of salt. A more seasoned developer
    might do things differently. The examples provide, however, a good starting point
    for anyone wanting to try functional programming.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在介绍中所说的，我并不是本章讨论的所有库的专家，所以要持保留态度。更有经验的开发者可能会有不同的做法。然而，这些示例为任何想尝试函数式编程的人提供了一个很好的起点。
- en: Also, when doing so, remember that it is first and foremost a way of thinking.
    It will be the way you approach the issue at hand that is the most important.
    If, at some point, you need to create non-pure code to accommodate an external
    dependencies or the framework you are using, so be it. This won't change the benefits
    you can get for the functional code you've written.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当这样做时，请记住，这首先是一种思维方式。最重要的是你解决问题的方式。如果在某个时候，你需要创建非纯代码来适应外部依赖或你正在使用的框架，那就这样吧。这不会改变你编写的函数式代码所能获得的好处。
- en: Now that we've seen how to use functional programming in an existing framework
    or a legacy codebase, the next chapter will cover designing a whole application
    using a paradigm known as Functional Reactive Programming or FRP.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何在现有框架或遗留代码库中使用函数式编程，下一章将涵盖使用一种称为函数响应式编程或FRP的范式来设计整个应用程序。
