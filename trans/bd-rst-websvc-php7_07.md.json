["```php\ncomposer require dingo/api:1.0.x@dev\n```", "```php\n$app->register(Dingo\\Api\\Provider\\LumenServiceProvider::class);\n```", "```php\nAPI_PREFIX=api\nAPI_VERSION=v1\nAPI_DEBUG=true\nAPI_NAME=\"Blog API\"\nAPI_DEFAULT_FORMAT=json\n```", "```php\n<?php   /* |---------------------------------------------------------------- | Application Routes |---------------------------------------------------------------- | | Here is where you can register all of the routes for an application. | It is a breeze. Simply tell Lumen the URIs it should respond to | and give it the Closure to call when that URI is requested. | */ $api = app('Dingo\\Api\\Routing\\Router');\n\n$api->version('v1', function ($api) {\n\n    $api->resource('posts', \"App\\Http\\Controllers\\PostController\");\n    $api->resource('comments', \"App\\Http\\Controllers\\CommentController\", [\n        'except' => ['store', 'index']\n    ]); \n $api->post('posts/{id}/comments', 'App\\Http\\Controllers\\CommentController@store');\n\n $api->get('posts/{id}/comments', 'App\\Http\\Controllers\\CommentController@index'); **});** $app->get('/', function () use ($app) {\n  return $app->version(); });  \n```", "```php\nphp artisan route:list\n```", "```php\n$api->version('v1', ['prefix' => 'api/v1'], function ($api) {\n\n     $api->resource('posts', \"App\\Http\\Controllers\\PostController\");\n     $api->resource('comments', \"App\\Http\\Controllers\\CommentController\", [\n 'except' => ['store', 'index']\n ]);\n\n     $api->post('posts/{id}/comments', 'App\\Http\\Controllers\\CommentController@store');\n\n     $api->get('posts/{id}/comments', 'App\\Http\\Controllers\\CommentController@index');\n});\n```", "```php\nhttp://localhost:8000/api/v1/posts\nhttp://localhost:8000/api/v1/posts/1\nhttp://localhost:8000/api/v1/posts/1/comments\n```", "```php\nnamespace App\\Http\\Controllers**\\V1**;\n```", "```php\nClass 'App\\Http\\Controllers\\V1\\Controller' not found\n```", "```php\nclass PostController extends **\\App\\Http\\Controllers\\Controller**  {..\n```", "```php\n$api->version('v1', ['middleware' => 'api.throttle','prefix' => 'api/v1']**,** function ($api) {   $api->resource('posts', \"App\\Http\\Controllers\\V1\\PostController\");\n  $api->resource('comments', \"App\\Http\\Controllers\\V1\\CommentController\", [\n  'except' => ['store', 'index']\n ]);  $api->post('posts/{id}/comments', 'App\\Http\\V1\\Controllers\\CommentController@store'); $api->get('posts/{id}/comments', 'App\\Http\\V1\\Controllers\\CommentController@index');  });\n```", "```php\n$api->version('v1', [\n  'middleware' => 'api.throttle',\n 'limit' => 100,\n    'expires' => 5**,**\n  'prefix' => 'api/v1',\n  'namespace' => 'App\\Http\\Controllers\\V1'\n  ], function ($api) {\n  $api->resource('posts', \"PostController\");\n  $api->resource('comments', \"CommentController\", [\n  'except' => ['store', 'index']\n ]);    $api->post('posts/{id}/comments', 'CommentController@store');\n  $api->get('posts/{id}/comments', 'CommentController@index');   });\n```", "```php\nuse  Illuminate\\Http\\Request; use Illuminate\\Http\\Response; use Illuminate\\Http\\JsonResponse; use **Dingo\\Api\\Routing\\Helpers;**   class PostController extends Controller {\n use **Helpers;**    public function __construct(\\App\\Post $post)\n {  $this->post = $post;\n }\n.... /**\n * Display the specified resource. * * @param int  $id\n * @return \\Illuminate\\Http\\Response\n */ public function show($id) {\n $comments = $this->api->get(\"api/posts/$id/comments\"**);**    $post = $this->post->find($id); ....\n }\n....\n} \n```", "```php\n $comments = $this->api->get(\"api/posts/$id/comments\");\n```", "```php\n$this->api->post(\"api/v1/posts/$id/comments\", ['comment' => 'a nice post']);\n```", "```php\n composer require tymon/jwt-auth 1.0.0-beta.3\n```", "```php\n$app->register(Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider::class);\n```", "```php\nclass_alias('Tymon\\JWTAuth\\Facades\\JWTAuth', 'JWTAuth'); class_alias('Tymon\\JWTAuth\\Facades\\JWTFactory', 'JWTFactory');\n```", "```php\nphp artisan jwt:generate\n```", "```php\n$app->alias('cache', 'Illuminate\\Cache\\CacheManager'); $app->alias('auth', 'Illuminate\\Auth\\AuthManager');\n```", "```php\n<?php if ( ! function_exists('config_path')) {\n  /**\n * Get the configuration path. * * @param string $path\n * @return string\n */  function config_path($path = '')\n {  return app()->basePath() . '/config' . ($path ? '/' . $path : $path);\n } }\n```", "```php\n\"autoload\": {\n  \"psr-4\": {\n    \"App\\\\\": \"app/\"\n  },\n  \"files\": [\n    \"app/helpers.php\"\n  ]\n},\n```", "```php\ncomposer dump-autoload\n```", "```php\nphp artisan vendor:publish --provider=\"Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider\"\n```", "```php\n[Symfony\\Component\\Console\\Exception\\CommandNotFoundException]\n There are no commands defined in the \"vendor\" namespace.\n```", "```php\ncomposer require laravelista/lumen-vendor-publish\n```", "```php\nphp artisan vendor:publish --provider=\"Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider\"\n```", "```php\nCopied File [/vendor/tymon/jwt-auth/src/config/config.php] To [/config/jwt.php]\nPublishing complete for tag []!\n```", "```php\nphp artisan jwt:generate\n```", "```php\n'secret' => env('JWT_SECRET', 'RusJ3fiLAp4DmUNNzqGpC7IcQI8bfar7'),\n```", "```php\napp('Dingo\\Api\\Auth\\Auth')->extend('jwt', function ($app) {\n return new Dingo\\Api\\Auth\\Provider\\JWT($app['Tymon\\JWTAuth\\JWTAuth']);\n});\n```", "```php\ncomposer require krisanalfa/lumen-dingo-adapter\n```", "```php\n$app->register(Zeek\\LumenDingoAdapter\\Providers\\LumenDingoAdapterServiceProvider::class);\n```", "```php\n<?php   require_once __DIR__.'/../vendor/autoload.php';   try {\n (new Dotenv\\Dotenv(__DIR__.'/../'))->load(); } catch (Dotenv\\Exception\\InvalidPathException $e) {\n  // }   /* |-------------------------------------------------------------------------- | Create The Application |-------------------------------------------------------------------------- | | Here we will load the environment and create the application instance | that serves as the central piece of this framework. We'll use this | application as an \"IoC\" container and router for this framework. | */   $app = new Laravel\\Lumen\\Application(\n  realpath(__DIR__.'/../') );     $app->withFacades();\n\n $app**->withEloquent();**   /* |-------------------------------------------------------------------------- | Register Container Bindings |-------------------------------------------------------------------------- | | Now we will register a few bindings in the service container. We will | register the exception handler and the console kernel. You may add | your own bindings here if you like or you can make another file. | */   $app->singleton(\n Illuminate\\Contracts\\Debug\\ExceptionHandler::class,\n App\\Exceptions\\Handler::class );   $app->singleton(\n Illuminate\\Contracts\\Console\\Kernel::class,\n App\\Console\\Kernel::class );   $app->register(Zeek\\LumenDingoAdapter\\Providers\\LumenDingoAdapterServiceProvider::class);     /* |-------------------------------------------------------------------------- | Register Middleware |-------------------------------------------------------------------------- | | Next, we will register the middleware with the application. These can | be global middleware that run before and after each request into a | route or middleware that'll be assigned to some specific routes. | */   // $app->middleware([ //    App\\Http\\Middleware\\ExampleMiddleware::class // ]);   // $app->routeMiddleware([ //     'auth' => App\\Http\\Middleware\\Authenticate::class, // ]);   /* |-------------------------------------------------------------------------- | Register Service Providers |-------------------------------------------------------------------------- | | Here we will register all of the application's service providers which | are used to bind services into the container. Service providers are | totally optional, so you are not required to uncomment this line. | */   // $app->register(App\\Providers\\AppServiceProvider::class); // $app->register(App\\Providers\\AuthServiceProvider::class); // $app->register(App\\Providers\\EventServiceProvider::class);   /* |-------------------------------------------------------------------------- | Load The Application Routes |-------------------------------------------------------------------------- | | Next we will include the routes file so that they can all be added to | the application. This will provide all of the URLs the application | can respond to, as well as the controllers that may handle them. | */   $app->group(['namespace' => 'App\\Http\\Controllers'], function ($app) {\n  require __DIR__.'/../routes/web.php'; });   return $app; \n```", "```php\n<?php   namespace App\\Http\\Controllers\\Auth;   use Illuminate\\Http\\Request; use Illuminate\\Http\\Response; use Illuminate\\Http\\JsonResponse; use Tymon\\JWTAuth\\Facades\\JWTAuth; use App\\Http\\Controllers\\Controller; use Tymon\\JWTAuth\\Exceptions\\JWTException; use Illuminate\\Http\\Exception\\HttpResponseException;   class AuthController extends Controller {\n  /**\n * Handle a login request to the application. * * @param \\Illuminate\\Http\\Request $request\n * * @return \\Illuminate\\Http\\Response;\n */  public function login(Request $request)\n {  try {\n  $this->validateLoginRequest($request);\n } catch (HttpResponseException $e) {\n  return $this->onBadRequest();\n }    try {\n  // Attempt to verify the credentials and create a token for the user\n  if (!$token = JWTAuth::attempt(\n  $this->getCredentials($request)\n )) {  return $this->onUnauthorized();\n } } catch (JWTException $e) {\n  // Something went wrong whilst attempting to encode the token\n  return $this->onJwtGenerationError();\n }    // All good so return the token\n  return $this->onAuthorized($token);\n }    /**\n * Validate authentication request. * * @param Request $request\n * @return void\n * @throws HttpResponseException\n */  protected function validateLoginRequest(Request $request)\n {  $this->validate(\n  $request, [\n  'email' => 'required|email|max:255',\n  'password' => 'required',\n ] ); }    /**\n * What response should be returned on bad request. * * @return JsonResponse\n */  protected function onBadRequest()\n {  return new JsonResponse(\n [  'message' => 'invalid_credentials'\n  ], Response::HTTP_BAD_REQUEST\n  );\n }    /**\n * What response should be returned on invalid credentials. * * @return JsonResponse\n */  protected function onUnauthorized()\n {  return new JsonResponse(\n [  'message' => 'invalid_credentials'\n  ], Response::HTTP_UNAUTHORIZED\n  );\n }    /**\n * What response should be returned on error while generate JWT. * * @return JsonResponse\n */  protected function onJwtGenerationError()\n {  return new JsonResponse(\n [  'message' => 'could_not_create_token'\n  ], Response::HTTP_INTERNAL_SERVER_ERROR\n  );\n }    /**\n * What response should be returned on authorized. * * @return JsonResponse\n */  protected function onAuthorized($token)\n {  return new JsonResponse(\n [  'message' => 'token_generated',\n  'data' => [\n  'token' => $token,\n ] ] ); }    /**\n * Get the needed authorization credentials from the request. * * @param \\Illuminate\\Http\\Request $request\n * * @return array\n */  protected function getCredentials(Request $request)\n {  return $request->only('email', 'password');\n }    /**\n * Invalidate a token. * * @return \\Illuminate\\Http\\Response\n */  public function invalidateToken()\n {  $token = JWTAuth::parseToken();    $token->invalidate();    return new JsonResponse(['message' => 'token_invalidated']);\n }    /**\n * Refresh a token. * * @return \\Illuminate\\Http\\Response\n */  public function refreshToken()\n {  $token = JWTAuth::parseToken();    $newToken = $token->refresh();    return new JsonResponse(\n [  'message' => 'token_refreshed',\n  'data' => [\n  'token' => $newToken\n  ]\n ] ); }    /**\n * Get authenticated user. * * @return \\Illuminate\\Http\\Response\n */  public function getUser()\n {  return new JsonResponse(\n [  'message' => 'authenticated_user',\n  'data' => JWTAuth::parseToken()->authenticate()\n ] ); } } \n```", "```php\n$api->post(\n  '/auth/login', [\n  'as' => 'api.auth.login',\n  'uses' => 'Auth\\AuthController@login',\n ] );\n```", "```php\n$api->delete(\n  '/', [\n  'uses' => 'Auth/AuthController@invalidateToken',\n  'as' => 'api.auth.invalidate'\n  ] );\n```", "```php\n$api->patch(\n  '/', [\n  'uses' => 'Auth/AuthController@refreshToken',\n  'as' => 'api.auth.refresh'\n  ] );\n```", "```php\nPOST /api/v1/auth/login\nParams: email, passsword\n```", "```php\n<?php   /* |-------------------------------------------------------------------------- | Application Routes |-------------------------------------------------------------------------- | | Here is where you can register all of the routes for an application. | It is a breeze. Simply tell Lumen the URIs it should respond to | and give it the Closure to call when that URI is requested. | */ $api = app('Dingo\\Api\\Routing\\Router');     $api->version('v1', [\n  'middleware' => ['api.throttle'],\n  'limit' => 100,\n  'expires' => 5,\n  'prefix' => 'api/v1',\n  'namespace' => 'App\\Http\\Controllers\\V1' ],\n  function ($api) {\n $api->group(['middleware' => 'api.auth'], function ($api) {\n            //Posts protected routes\n            $api->resource('posts', \"PostController\", [\n                'except' => ['show', 'index']\n            ]);\n\n            //Comments protected routes\n            $api->resource('comments', \"CommentController\", [\n                'except' => ['show', 'index']\n            ]);\n\n            $api->post('posts/{id}/comments', 'CommentController@store'**);**      // Logout user by removing token\n  $api->delete(\n  '/', [\n  'uses' => 'Auth/AuthController@invalidateToken',\n  'as' => 'api.Auth.invalidate'\n  ]\n );      // Refresh token\n  $api->patch(\n  '/', [\n  'uses' => 'Auth/AuthController@refreshToken',\n  'as' => 'api.Auth.refresh'\n  ]\n ); **});**  $api->get('posts', 'PostController@index');\n $api->get('posts/{id}', 'PostController@show'**);**\n\n  $api->get('posts/{id}/comments', 'CommentController@index');\n $api->get('comments/{id}', 'CommentController@show'**);**    $api->post(\n  '/auth/login', [\n  'as' => 'api.Auth.login',\n  'uses' => 'Auth\\AuthController@login',\n ] );  });    $app->get('/', function () use ($app) {\n  return $app->version(); });   \n```", "```php\n<?php   namespace App\\Http\\Controllers\\V1;   use Illuminate\\Http\\Request; use Illuminate\\Http\\Response; use Illuminate\\Http\\JsonResponse; use Tymon\\JWTAuth\\Facades\\JWTAuth; use Dingo\\Api\\Routing\\Helpers;   class PostController extends Controller {\n  use Helpers;    public function __construct(\\App\\Post $post)\n {     $this->post = $post;   }    /**\n * Display a listing of the resource. * * @return \\Illuminate\\Http\\Response\n */  public function index(Request $request)\n {  $posts = $this->post->paginate(20);    return $posts;\n }    /**\n * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request  $request\n * @return \\Illuminate\\Http\\Response\n */  public function store(Request $request)\n {    $input = $request->all();\n $input['user_id'] = $this->user->id**;**    $validationRules = [\n  'content' => 'required|min:1',\n  'title' => 'required|min:1',\n  'status' => 'required|in:draft,published',\n  'user_id' => 'required|exists:users,id'\n  ];    $validator = \\Validator::make($input, $validationRules);\n  if ($validator->fails()) {\n  return new JsonResponse(\n [  'errors' => $validator->errors()\n ], Response::HTTP_BAD_REQUEST\n  );\n }    $this->post->create($input);    return [\n  'data' => $input\n  ];\n }    /**\n * Display the specified resource. * * @param int  $id\n * @return \\Illuminate\\Http\\Response\n */  public function show($id)\n {  $post = $this->post->find($id);    if(!$post) {\n abort(404);\n }    return $post;\n }    /**\n * Update the specified resource in storage. * * @param \\Illuminate\\Http\\Request  $request\n * @param int  $id\n * @return \\Illuminate\\Http\\Response\n */  public function update(Request $request, $id)\n {  $input = $request->all();    $post = $this->post->find($id);    if(!$post) {\n abort(404);\n } if($this->user->id != $post->user_id){\n            return new JsonResponse(\n                [\n                    'errors' => 'Only Post Owner can update it'\n                ], Response::HTTP_FORBIDDEN\n            ); **}**    $post->fill($input);\n  $post->save();    return $post;\n }    /**\n * Remove the specified resource from storage. * * @param int  $id\n * @return \\Illuminate\\Http\\Response\n */  public function destroy($id)\n {  $post = $this->post->find($id);    if(!$post) {\n abort(404);\n } if($this->user->id != $post->user_id){\n            return new JsonResponse(\n                [\n                    'errors' => 'Only Post Owner can delete it'\n                ], Response::HTTP_FORBIDDEN\n            ); **}**    $post->delete();    return ['message' => 'deleted successfully', 'post_id' => $id];\n } } \n```", "```php\n<?php   namespace App\\Transformers;   use League\\Fractal;   class PostTransformer extends Fractal\\TransformerAbstract {   public function transform(\\App\\Post $post)\n {   return $post->toArray();\n } }\n```", "```php\npublic function index(**\\App\\Transformers\\PostTransformer** $postTransformer) {\n  $posts = $this->post->paginate(20);   return $this->response->paginator($posts, $postTransformer**);** } \n```", "```php\nhttp://localhost:8000/api/v1/posts\n```", "```php\n{ \"data\": [\n { \"id\": 1,\n \"title\": \"test\",\n \"status\": \"draft\",\n \"content\": \"test post\",\n \"user_id\": 2,\n \"created_at\": null,\n \"updated_at\": \"2017-06-28 00:47:50\"\n }, {  \"id\": 3,\n  \"title\": \"test\",\n  \"status\": \"published\",\n  \"content\": \"test post\",\n  \"user_id\": 2,\n \"created_at\": \"2017-06-28 00:00:44\",\n  \"updated_at\": \"2017-06-28 00:00:44\"\n  },\n {  \"id\": 4,\n  \"title\": \"test\",\n  \"status\": \"published\",\n  \"content\": \"test post\",\n  \"user_id\": 2,\n  \"created_at\": \"2017-06-28 03:21:36\",\n  \"updated_at\": \"2017-06-28 03:21:36\"\n  },\n {  \"id\": 5,\n  \"title\": \"test post\",\n  \"status\": \"draft\",\n  \"content\": \"This is yet another post for testing purpose\",\n  \"user_id\": 8,\n  \"created_at\": \"2017-07-15 00:45:29\",\n  \"updated_at\": \"2017-07-15 00:45:29\"\n  },\n {  \"id\": 6,\n  \"title\": \"test post\",\n  \"status\": \"draft\",\n  \"content\": \"This is yet another post for testing purpose\",\n  \"user_id\": 8,\n  \"created_at\": \"2017-07-15 23:53:23\",\n  \"updated_at\": \"2017-07-15 23:53:23\"\n  } ], \"meta\": {\n    \"pagination\": {\n        \"total\": 5,\n            \"count\": 5,\n            \"per_page\": 20,\n            \"current_page\": 1,\n            \"total_pages\": 1,\n            \"links\": []\n        }\n    }\n}\n```", "```php\n<?php   namespace App\\Http\\Controllers\\V1;   use Illuminate\\Http\\Request; use Illuminate\\Http\\Response; use Illuminate\\Http\\JsonResponse;  use **Dingo\\Api\\Routing\\Helpers;** use App\\Transformers\\PostTransformer;   class PostController extends Controller {\n use **Helpers;**    public function __construct(\\App\\Post $post, \\App\\Transformers\\PostTransformer $postTransformer)\n {   $this->post = $post;    $this->transformer = $postTransformer;   }    /**\n * Display a listing of the resource. * * @return \\Illuminate\\Http\\Response\n */  public function index()\n {  $posts = $this->post->paginate(20);   return $this->response->paginator($posts, $this->transformer**);**\n }    /**\n * Store a newly created resource in storage. * * @param \\Illuminate\\Http\\Request  $request\n * @return \\Illuminate\\Http\\Response\n */  public function store(Request $request)\n {    $input = $request->all();\n  $input['user_id'] = $this->user->id;    $validationRules = [\n  'content' => 'required|min:1',\n  'title' => 'required|min:1',\n  'status' => 'required|in:draft,published',\n  'user_id' => 'required|exists:users,id'\n  ];    $validator = \\Validator::make($input, $validationRules);\n  if ($validator->fails()) {\n  return new JsonResponse(\n [  'errors' => $validator->errors()\n ], Response::HTTP_BAD_REQUEST\n  );\n }   $post = $this->post->create($input);   return $this->response->item($post, $this->transformer**);**\n }    /**\n * Display the specified resource. * * @param int  $id\n * @return \\Illuminate\\Http\\Response\n */  public function show($id)\n {  $post = $this->post->find($id);    if(!$post) {\n abort(404);\n }   return $this->response->item($post, $this->transformer**);**\n }    /**\n * Update the specified resource in storage. * * @param \\Illuminate\\Http\\Request  $request\n * @param int  $id\n * @return \\Illuminate\\Http\\Response\n */  public function update(Request $request, $id)\n {  $input = $request->all();    $post = $this->post->find($id);    if(!$post) {\n abort(404);\n }    if($this->user->id != $post->user_id){\n  return new JsonResponse(\n [  'errors' => 'Only Post Owner can update it'\n  ], Response::HTTP_FORBIDDEN\n  );\n }    $post->fill($input);\n  $post->save();   return $this->response->item($post, $this->transformer**);**\n }    /**\n * Remove the specified resource from storage. * * @param int  $id\n * @return \\Illuminate\\Http\\Response\n */  public function destroy($id)\n {  $post = $this->post->find($id);    if(!$post) {\n abort(404);\n }    if($this->user->id != $post->user_id){\n  return new JsonResponse(\n [  'errors' => 'Only Post Owner can delete it'\n  ], Response::HTTP_FORBIDDEN\n  );\n }    $post->delete();    return ['message' => 'deleted successfully', 'post_id' => $id];\n } } \n```"]