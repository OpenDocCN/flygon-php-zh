- en: Chapter 6. Architectural Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。架构模式
- en: Architectural patterns, sometimes referred to as an architectural style, provide
    solutions to recurring problems in software architecture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 架构模式，有时被称为架构风格，为软件架构中的重复问题提供解决方案。
- en: Though similar to software design patterns, they have a broader scope, addressing
    various issues in software engineering as opposed to simply the development of
    software itself.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与软件设计模式类似，但其范围更广，涉及软件工程中的各种问题，而不仅仅是软件本身的开发。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Model-View-Controller (MVC)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-控制器（MVC）
- en: Service-oriented architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向服务的架构
- en: Microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务
- en: Asynchronous queuing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步排队
- en: Message Queue pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息队列模式
- en: Model-View-Controller (MVC)
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-控制器（MVC）
- en: MVC is the most common type of Architectural pattern that PHP developers encounter.
    Fundamentally, MVC is an Architectural pattern for implementing user interfaces.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: MVC是PHP开发人员遇到的最常见类型的架构模式。基本上，MVC是一种用于实现用户界面的架构模式。
- en: 'It largely works around the following methodology:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它主要围绕以下方法论展开：
- en: '**Model**: This supplies the data to the application, whether it''s from a
    MySQL database or any other data store.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：为应用程序提供数据，无论是来自MySQL数据库还是其他任何数据存储。'
- en: '**Controller**: A Controller is essentially where the business logic is. The
    Controller handles whatever queries the View provides, using the Model to assist
    it in this behavior.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：控制器基本上是业务逻辑所在。控制器处理视图提供的任何查询，使用模型来协助其进行此行为。'
- en: '**View**: The actual content that is supplied to the end-user. This commonly
    is an HTML template.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：提供给最终用户的实际内容。这通常是一个HTML模板。'
- en: Business logic for one interaction isn't strictly separated from another interaction.
    There is no formal separation between the different classes of an application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个交互的业务逻辑并不严格分离于另一个交互。应用程序的不同类之间没有正式的分离。
- en: It is critical to consider that the MVC pattern is principally a UI pattern,
    so it doesn't scale well throughout an application. That said, the rendering of
    UIs is increasingly being done via JavaScript applications, a single page JavaScript
    HTML app that simply consumes a RESTful APIs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的关键是MVC模式主要是一种UI模式，因此在整个应用程序中无法很好地扩展。也就是说，UI的呈现越来越多地通过JavaScript应用程序完成，即一个简单消耗RESTful
    API的单页面JavaScript HTML应用程序。
- en: If you're using JavaScript, you may use a framework such as Backbone.js (Model-View-Presenter),
    React.js, or Angular to communicate with your backend APIs, though this will of
    course, require a JavaScript enabled web browser, which some of us can take for
    granted from our users.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用JavaScript，可以使用诸如Backbone.js（模型-视图-控制器）、React.js或Angular等框架与后端API进行通信，尽管这当然需要一个启用JavaScript的Web浏览器，这对我们的一些用户来说可能是理所当然的。
- en: In the event you exist in an environment where you cannot use a JavaScript app
    and must instead serve rendered HTML, it often is a good idea for your MVC app
    to simply consume a REST API. The REST API performs all the business logic, but
    the rendering of markup is done in the MVC app. Although this increases complexity,
    it offers a greater separation of responsibilities and as a result, you don't
    have HTML being merged with core business logic. That said, even within this REST
    API you need some form of separation of concerns, you need to be able to separate,
    the rendering of the markup from the actual business logic.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您处于无法使用JavaScript应用程序且必须提供渲染的HTML的环境中，对于您的MVC应用程序来说，将其简单地消耗REST API通常是一个好主意。REST
    API执行所有业务逻辑，但标记的呈现是在MVC应用程序中完成的。尽管这增加了复杂性，但它提供了更大的责任分离，因此您不会将HTML与核心业务逻辑合并。也就是说，即使在这个REST
    API中，您也需要某种形式的关注点分离，您需要能够将标记的呈现与实际业务逻辑分开。
- en: A key element to choosing an Architectural pattern suitable for an app is whether
    the complexity is appropriate for the size of the app. Thus, choosing an MVC framework
    should also be based on the complexity of the app itself and its intended complexity
    later on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 选择适合应用程序的架构模式的关键因素是复杂性是否适合应用程序的规模。因此，选择MVC框架也应基于应用程序本身的复杂性及其后续预期的复杂性。
- en: Given the growth of infrastructure as code, it is possible to deploy the infrastructure
    of multiple web services in an entirely orchestrated fashion. Indeed, using containerization
    technology such as Docker, it is possible to deploy multiple architectures (such
    as an MVC application with a separate API service) with little overhead (no need
    to spin up a new server for each service).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于基础设施即代码的增长，可以以完全编排的方式部署多个Web服务的基础设施。事实上，使用诸如Docker之类的容器化技术，可以以很小的开销（无需为每个服务启动新服务器）部署多个架构（例如具有单独API服务的MVC应用程序）。
- en: Separation of concerns is a vital trait when developing great architectures,
    which includes separating UI from business logic.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发出色的架构时，关注点分离是一个重要特征，其中包括将UI与业务逻辑分离。
- en: 'When thinking in terms of an MVC pattern, it is important to remember the interactions
    as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当以MVC模式思考时，重要的是要记住以下交互：
- en: The Model stores data, which is retrieved according to the query put by the
    Model and displayed by the View
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型存储数据，根据模型提出的查询检索数据，并由视图显示
- en: The View generates outputs based on changes to the Model
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图根据模型的更改生成输出
- en: The Controller sends the command to update the Model's state; it can also update
    the View associated to it to alter how a given Model is presented
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器发送命令以更新模型的状态；它还可以更新与之关联的视图，以改变给定模型的呈现方式
- en: 'Or, it is commonly expressed using the following diagram:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，通常使用以下图表表示：
- en: '![Model-View-Controller (MVC)](graphics/image_06_001.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![模型-视图-控制器（MVC）](graphics/image_06_001.jpg)'
- en: Don't use an MVC framework for the sake of using one, understand why they exist
    and where they can fit well into a use case. Remember that when you take on a
    bloated framework with lots of functionality, you are taking responsibility for
    maintaining the whole thing going forward.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不要仅仅为了使用而使用MVC框架，要理解它们存在的原因以及它们在特定用例中的适用性。记住，当你使用一个功能繁多的框架时，你要负责维护整个框架的运行。
- en: Pulling in the components as you need them (that is, through Composer) is a
    far more practical approach to developing software with considerable business
    logic.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要引入组件（即通过Composer）是开发具有相当多业务逻辑的软件的更实际的方法。
- en: Service-oriented architecture
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向服务的架构
- en: Service-oriented architectures largely consist of business logic in services
    that communicate with data repositories.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务的架构主要由与数据存储库通信的服务中的业务逻辑组成。
- en: These services can be derived in different forms to build applications. These
    applications adopt these services in different formats to build various applications.
    Consider the services as Lego blocks that can be put together to build an application
    in a given format.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务可以以不同的形式衍生出来构建应用程序。这些应用程序以不同的格式采用这些服务来构建各种应用程序。将这些服务视为可以组合在一起以构建特定格式应用程序的乐高积木。
- en: 'This description is rather crude; let me clarify further:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个描述相当粗糙，让我进一步澄清：
- en: Boundaries for services are explicit (they may separate web services on different
    domains, and so on.)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务的边界是明确的（它们可以将不同域上的Web服务分开，等等。）
- en: Services can inter-communicate using a common communication protocol (for example
    all use RESTful APIs)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务可以使用共同的通信协议进行相互通信（例如都使用RESTful API）
- en: Services are autonomous (they are decoupled and not related to another service
    in any way)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务是自治的（它们是解耦的，与其他服务没有任何关联）
- en: The message processing mechanism and the schema are understandable by every
    other microservice (and therefore are often the same), but the programming environment
    can be different
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息处理机制和架构对每个微服务都是可理解的（因此通常是相同的），但编程环境可以是不同的。
- en: Service-oriented architectures are inherently distributed, thus they can have
    higher up-front complexity than other architectures.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务的架构本质上是分布式的，因此其初始复杂性可能比其他架构更高。
- en: Microservices
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: A microservices architecture can be considered a subset of service-oriented
    architectures.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构可以被认为是面向服务的架构的一个子集。
- en: Fundamentally, microservices form complex applications by composing them of
    small independent process which intercommunicate over a language-agnostic API
    that makes each services accessible to each other. Microservices can be individually
    deployed as services.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，微服务通过由小型独立进程组成的复杂应用程序，这些进程通过语言无关的API进行相互通信，使每个服务都可以相互访问。微服务可以作为单独的服务进行部署。
- en: In microservices, the business logic is separated into self-contained loosely-coupled
    services. A key tenet of microservices is that each database should have their
    own database, which is vital to ensure that the microservices do not become tightly
    coupled to each other.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务中，业务逻辑被分离成独立的、松耦合的服务。微服务的一个关键原则是每个数据库都应该有自己的数据库，这对确保微服务不会彼此紧密耦合至关重要。
- en: By reducing the complexity of a single service, we can aim to reduce the amount
    of points at which this service will fail. In theory, by having a single service
    comply with the Single Responsibility Principle, it is easier to debug and reduce
    chances of failure in our application as a whole.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过减少单个服务的复杂性，我们可以减少该服务可能出现故障的点。理论上，通过使单个服务符合单一职责原则，我们可以更容易地调试和减少整个应用程序中出现故障的机会。
- en: In computer science, the CAP theorem dictates that it is impossible to guarantee
    consistency, availability, and partition tolerance concurrently in a given distributed
    computer system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，CAP定理规定在给定的分布式计算机系统中不可能同时保证一致性、可用性和分区容错性。
- en: Imagine two distributed databases both containing the e-mail address of a user.
    If we want to update this e-mail address, there is no way we can do so in a way
    that is instantaneously available across both databases with the e-mail consistently
    updated at the same time while not bringing the two datasets back together. In
    a distributed system we would have to either delay the access to the data to validate
    the data is consistent or present a non-updated copy of the data.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，有两个分布式数据库都包含用户的电子邮件地址。如果我们想要更新这个电子邮件地址，没有办法可以在两个数据库中同时实时更新电子邮件地址，同时不将两个数据集重新合并。在分布式系统中，我们要么延迟访问数据以验证数据的一致性，要么呈现一个未更新的数据副本。
- en: This makes traditional database transaction difficult. Thus, the best way to
    address data handling in a microservices architecture is to use an eventually
    consistent, event-driven architecture.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得传统的数据库事务变得困难。因此，在微服务架构中处理数据的最佳方式是使用一种最终一致的、事件驱动的架构。
- en: Each service publishes an event whenever there is a change, and other services
    may subscribe to this. When an event is received, the data is accordingly updated.
    Thus, the application is able to maintain data consistency across multiple services
    without needing to use distributed transactions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务在发生变化时都会发布一个事件，其他服务可以订阅此事件。当接收到事件时，数据会相应地更新。因此，应用程序能够在不需要使用分布式事务的情况下在多个服务之间保持数据一致性。
- en: In order to see how such an architecture for inter-process communication can
    be implemented for communication between microservices, please see the *Message
    Queue pattern (Getting started with RabbitMQ)* section in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解如何在微服务之间实现进程间通信的架构，请参阅本章节中的*消息队列模式（使用RabbitMQ入门）*部分。
- en: In this situation, one simple way to mitigate against this restriction is simply
    by using a time verification system in order to verify the data is consistent.
    Thus, we surrender availability for consistency and partition tolerance.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，缓解这种限制的一种简单方法是通过使用时间验证系统来验证数据的一致性。因此，我们为一致性和分区容忍性而放弃了可用性。
- en: If you can foresee this as a problem in a given microservices architecture,
    it is often best to group the services that need to satisfy the CAP theorem together
    into a single service.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以预见在给定的微服务架构中会出现这种问题，通常最好将需要满足CAP定理的服务分组到一个单一的服务中。
- en: 'Let''s consider a pizza delivery web application that consists of the following
    microservices:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个比萨外卖网站应用，它由以下微服务组成：
- en: User
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户
- en: Deals
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优惠
- en: Recipe
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 食谱
- en: Cart
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车
- en: Billing
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计费
- en: Payments
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支付
- en: Restaurant
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 餐厅
- en: Delivery
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交付
- en: Pizza
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比萨
- en: Reviews
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论
- en: Frontend microservice
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端微服务
- en: 'In this example, we could have the following user journey:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可能会有以下用户旅程：
- en: The user is authenticated using the User microservice.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户通过用户微服务进行身份验证。
- en: The user can select offers using the Deals microservice.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可以使用优惠微服务选择优惠。
- en: The user selects the pizza they want to order using the Recipe microservice.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户使用食谱微服务选择他们想要订购的比萨。
- en: Selected pizza(s) are added to the cart using the Cart microservice.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用购物车微服务将所选的比萨添加到购物车中。
- en: Billing credentials optimated through the Billing microservice.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计费凭据通过计费微服务进行优化。
- en: The user pays using the Payments microservice.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户使用支付微服务进行支付。
- en: The order is sent to the restaurant using the Restaurant microservice.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订单通过餐厅微服务发送到餐厅。
- en: When the Restaurant has cooked the food, the Delivery microservice sends a driver
    to collect the food and deliver it.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当餐厅烹饪食物时，交付微服务会派遣司机去取食物并送达。
- en: Once the Delivery microservice indicates the food has been delivered, the user
    is invited to complete a review using the Review microservice (which notifies
    the user using the User microservice).
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦交付微服务表明食物已经送达，用户就会被邀请使用评论微服务完成评论（评论微服务通过用户微服务通知用户）。
- en: The web front of this is wrapped together using the Frontend microservice.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web前端使用前端微服务包装在一起。
- en: The Frontend microservice can simply be a microservice that consumes the other
    microservices and presents the content to the web frontend. This frontend may
    communicate with the other microservices over REST, perhaps implemented in a JavaScript
    client in the browser, or a PHP app that merely acts as a consumer of other microservice
    APIs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前端微服务可以简单地是一个消费其他微服务并将内容呈现给Web前端的微服务。这个前端可以通过REST与其他微服务通信，可能在浏览器中实现为JavaScript客户端，或者仅作为其他微服务API的消费者的PHP应用。
- en: Either way, it is often a good idea to place a gateway between the frontend
    consumer of your API and the backend. This allows us to put some middleware before
    communication to microservices is ascertained; for example, we can use the gateway
    to query the User microservice to check that a user is authorized before allowing
    access to the Cart microservice.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，将前端API消费者与后端之间放置一个网关通常是一个好主意。这使我们能够在确定与微服务的通信之前放置一些中间件；例如，我们可以使用网关查询用户微服务，以检查用户是否经过授权，然后允许访问购物车微服务。
- en: If you're using JavaScript to communicate directly with the microservices, you
    may find cross-origin issues when your web frontend tries to communicate with
    microservices on different hostnames/ports; a microservice gateway can help prevent
    this by putting the gateway on the same origin as the web frontend itself.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用JavaScript直接与微服务通信，当您的Web前端尝试与不同主机名/端口上的微服务通信时，可能会遇到跨域问题；微服务网关可以通过将网关放置在与Web前端本身相同的源上来防止这种情况。
- en: In exchange for this convenience of a gateway, you'll likely feel the drawbacks
    in terms of the fact that you will have another system to worry about and additional
    response time (though you can add caching at the gateway level should you want
    to improve performance there).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便使用网关，您可能会感受到缺点，因为您将需要担心另一个系统和额外的响应时间（尽管您可以在网关级别添加缓存以改善性能）。
- en: 'Given the addition of a gateway, our architecture could now look something
    like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到网关的添加，我们的架构现在可能看起来像这样：
- en: '![Microservices](graphics/image_06_002.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![微服务](graphics/image_06_002.jpg)'
- en: Increasingly emerging in PHP are micro-frameworks such as Lumen, Silex, and
    Slim; these are API-oriented frameworks that make it easy to build microservices
    to support our applications. That said, you may often be better to adopt an even
    more lightweight approach and merely pull in the components you require through
    Composer as and when you need them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中越来越多地出现微框架，比如Lumen、Silex和Slim；这些都是面向API的框架，可以轻松构建支持我们应用的微服务。也就是说，您可能更好地采用更轻量级的方法，只需在需要时通过Composer引入所需的组件。
- en: 'Remember that adding another technology or framework adds additional complexity
    to your overall situation. Think not only of the technical reasons of implementing
    a new solution but also how this will benefit the customer and the architecture.
    Microservices aren''t an excuse to add unnecessary complexity: *Keep It Simple,
    Stupid*.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，添加另一种技术或框架会给整体情况增加额外的复杂性。不仅要考虑实施新解决方案的技术原因，还要考虑这将如何使客户和架构受益。微服务不是增加不必要复杂性的借口：*保持简单，愚蠢*。
- en: Asynchronous queueing
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步排队
- en: Message queues provide an asynchronous communication protocol. In an asynchronous
    communication protocol, the sender and the receiver need not interact with the
    message queue simultaneously.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列提供异步通信协议。在异步通信协议中，发送方和接收方不需要同时与消息队列交互。
- en: Typical HTTP, on the other hand, is a synchronous communication protocol, meaning
    that the client is blocked until the operation is completed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，典型的HTTP是一种同步通信协议，这意味着客户端在操作完成之前被阻塞。
- en: Consider this; you call someone on the phone, then you wait for the phone to
    ring and the person you talk to listens to whatever you have to say then and there.
    At the end of the communication you say *goodbye* and that is acknowledged by
    someone on the other end saying *goodbye* back. This can be considered synchronous
    as you don't do anything until you get a response from the person you're communicating
    with to end the communication.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下；您给某人打电话，然后等待电话响起，您与之交谈的人立即倾听您要说的话。在通信结束时，您说“再见”，对方也会回答“再见”。这可以被认为是同步的，因为在您收到与您交流的人的响应以结束通信之前，您不会做任何事情。
- en: However, if you were to send a text message to someone instead, after you send
    that message you can go off and do whatever behavior you please; you can receive
    a message in return to the one you sent when they want to communicate back to
    you. While someone is drafting the response to send back, you can go off and do
    whatever you want. While you don't communicate directly with the sender, you do
    still maintain synchronous communication with your phone, which notifies you when
    you get a new message (or simply check your phone every few minutes); but the
    communication with the other party itself is asynchronous. Neither party needs
    to know anything about the other party, they just merely are looking out for their
    own text messages in order to communicate with each other.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您要发送短信给某人，发送完短信后，您可以随心所欲地进行任何行为；当对方想要与您交流时，您可以收到对您发送的消息的回复。当某人正在起草要发送的回复时，您可以随心所欲地进行任何行为。虽然您不直接与发送方进行通信，但您仍然通过手机保持同步通信，当您收到新消息时通知您（或者每隔几分钟检查手机）；但与对方的通信本身是异步的。双方都不需要了解对方的任何信息，他们只是在寻找自己的短信以便彼此进行通信。
- en: Message Queue pattern (Getting started with RabbitMQ)
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息队列模式（使用RabbitMQ）
- en: RabbitMQ is a message broker; it accepts and forwards messages. Here, let's
    configure it so that we can send messages from one PHP script to another.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ是一个消息代理；它接受并转发消息。在这里，让我们配置它，以便我们可以从一个PHP脚本发送消息到另一个脚本。
- en: Imagine we are giving a package to a courier in order for them to give to the
    client; RabbitMQ is the courier, while the scripts are the individuals receiving
    and sending the packages respectively.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们正在将一个包裹交给快递员，以便他们交给客户；RabbitMQ就是快递员，而脚本是分别接收和发送包裹的个体。
- en: As the first step, let's install RabbitMQ; I'm going to demonstrate this on
    an Ubuntu 14.04 system.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们在Ubuntu 14.04系统上安装RabbitMQ；我将在此演示。
- en: 'To start with, we need to add the RabbitMQ APT repository to our `/etc/apt/sources.list.d`
    folder. This can fortunately be actioned with a command, like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将RabbitMQ APT存储库添加到我们的`/etc/apt/sources.list.d`文件夹中。幸运的是，可以使用以下命令执行此操作：
- en: '[PRE0]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the repository may be liable to change; if it does, you can find the
    latest details at [https://www.rabbitmq.com/install-debian.html](https://www.rabbitmq.com/install-debian.html).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，存储库可能会发生变化；如果发生变化，您可以在[https://www.rabbitmq.com/install-debian.html](https://www.rabbitmq.com/install-debian.html)找到最新的详细信息。
- en: 'We can optionally also add the RabbitMQ public key to the trusted key list
    to avoid any warnings indicating packages are unsigned when we install or upgrade
    the packages through the `apt` command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以选择将RabbitMQ公钥添加到受信任的密钥列表中，以避免在通过`apt`命令安装或升级软件包时出现未签名的警告：
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So far, so good:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好：
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_003.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![消息队列模式（使用RabbitMQ入门）](graphics/image_06_003.jpg)'
- en: 'Next, let''s just run an `apt-get update` command to fetch the packages from
    the new repository we''ve included. After this is done we can get around to installing
    the package we need using the `apt-get install rabbitmq-server` command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们运行`apt-get update`命令，从我们包含的新存储库中获取软件包。完成后，我们可以使用`apt-get install rabbitmq-server`命令安装我们需要的软件包：
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_004.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![消息队列模式（使用RabbitMQ入门）](graphics/image_06_004.jpg)'
- en: 'Be sure to accept the various prompts when asked:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在被询问时，请务必接受各种提示：
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_005.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![消息队列模式（使用RabbitMQ入门）](graphics/image_06_005.jpg)'
- en: 'After installation, you may run `rabbitmqctl status` to check the status of
    the application to check it''s running OK:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您可以运行`rabbitmqctl status`来检查应用程序的状态，以确保它正常运行：
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_006.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![消息队列模式（使用RabbitMQ入门）](graphics/image_06_006.jpg)'
- en: 'Let''s make our lives easier for a second. We can use a web GUI to manage RabbitMQ;
    simply run the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简化一下生活。我们可以使用Web GUI来管理RabbitMQ；只需运行以下命令：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_007.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![消息队列模式（使用RabbitMQ入门）](graphics/image_06_007.jpg)'
- en: 'We can now see an admin interface at  `<your server IP here>:15672`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在`<您的服务器IP地址>:15672`看到管理界面：
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_008.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![消息队列模式（使用RabbitMQ入门）](graphics/image_06_008.jpg)'
- en: But before we can log in, we're going to have to create some login credentials.
    In order to do this we're going to have to head back to the command line.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们登录之前，我们需要创建一些登录凭据。为了做到这一点，我们需要回到命令行。
- en: 'Firstly, we''ll need to set a new account with a username of `junade` and a
    password of `insecurepassword`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置一个新帐户，用户名为`junade`，密码为`insecurepassword`：
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we can add some admin privileges:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以添加一些管理员权限：
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Returning to the login page, we can now see our cool admin interface after
    we enter in these credentials:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 返回登录页面后，我们现在可以在输入这些凭据后看到我们很酷的管理界面：
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_009.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![消息队列模式（使用RabbitMQ入门）](graphics/image_06_009.jpg)'
- en: This is the web interface for the RabbitMQ service, accessible through our web
    browser
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是RabbitMQ服务的Web界面，可通过我们的Web浏览器访问
- en: 'Now we can test what we''ve installed. Let''s start off by writing a `composer.json`
    file for this new project:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试我们安装的东西。让我们首先为这个新项目编写一个`composer.json`文件：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: RabbitMQ uses the **advanced message queuing protocol** (**AMQP**), which is
    why we're installing a PHP library that will essentially help us communicate with
    it over this protocol.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ使用**高级消息队列协议**（**AMQP**），这就是为什么我们正在安装一个PHP库，它基本上将帮助我们通过这个协议与它进行通信。
- en: 'Next up, we can write some code to send a message using the RabbitMQ message
    broker we just installed:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以编写一些代码来使用我们刚刚安装的RabbitMQ消息代理发送消息：
- en: This assumes the port is `5672` and the install is on `localhost`, which may
    change depending on your circumstances.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设端口是`5672`，安装在`localhost`上，这可能会根据您的情况而改变。
- en: 'Let''s write a little PHP script to utilize this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个小的PHP脚本来利用这个：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So let's break this down a little bit. In the first few lines, we just include
    the library from the Composer `autoload` and `state` which namespaces we're going
    to use. When we instantiate the `AMQPStreamConnection` object we actually connect
    to the message broker; we can then create a new channel object that we then use
    to declare a new queue on. We declare a queue by calling the `queue_declare` message.
    The durable option allows messages to survive reboots in RabbitMQ. Finally, we
    just go ahead and send out our message.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们来详细分析一下。在前几行中，我们只是从Composer的`autoload`中包含库，并且`state`了我们要使用的命名空间。当我们实例化`AMQPStreamConnection`对象时，我们实际上连接到了消息代理；然后我们可以创建一个新的通道对象，然后用它来声明一个新的队列。我们通过调用`queue_declare`消息来声明一个队列。持久选项允许消息在RabbitMQ重新启动时存活。最后，我们只需发送出我们的消息。
- en: 'Let''s now run this script:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行这个脚本：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of this looks like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出看起来像这样：
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_010.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![消息队列模式（使用RabbitMQ入门）](graphics/image_06_010.jpg)'
- en: 'If you now go to the web interface for RabbitMQ, click the queues tab and toggle
    the Get Message(s) dialog; you should be able to pull in the message we just sent
    to the broker:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在转到RabbitMQ的Web界面，点击队列选项卡并切换到获取消息对话框；您应该能够拉取我们刚刚发送到代理的消息：
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_011.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![消息队列模式（使用RabbitMQ入门）](graphics/image_06_011.jpg)'
- en: Using this web page in the interface, we can extract messages from the queue
    so we can look at their contents
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在界面中使用这个网页，我们可以从队列中提取消息，这样我们就可以查看它们的内容
- en: Of course, this is just half the story. We now need to actually retrieve this
    message using another app.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是故事的一半。我们现在需要使用另一个应用程序实际检索这条消息。
- en: 'Let''s write a `receive.php` script:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个`receive.php`脚本：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the first few lines are identical to our sending script; we even re-declare
    the queue in case this receive script is run before the `send.php` script is run.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前几行与我们的发送脚本是相同的；我们甚至重新声明队列，以防在运行`send.php`脚本之前运行此接收脚本。
- en: 'Let''s run our `receive.php` script:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的`receive.php`脚本：
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_012.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![消息队列模式（使用RabbitMQ入门）](graphics/image_06_012.jpg)'
- en: 'In another bash Terminal, let''s run the `send.php` script a few times:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个bash终端中，让我们运行`send.php`脚本几次：
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_013.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![消息队列模式（使用RabbitMQ入门）](graphics/image_06_013.jpg)'
- en: 'Accordingly, in the `receive.php` Terminal tab, we can now see we''ve received
    the messages we''ve been sending:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`receive.php`终端选项卡中，我们现在可以看到我们已经收到了我们发送的消息：
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_014.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![消息队列模式（使用RabbitMQ入门）](graphics/image_06_014.jpg)'
- en: 'The RabbitMQ documentation uses the following diagram to describe the basic
    accepting and forwarding of messages:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ文档使用以下图表来描述消息的基本接受和转发：
- en: '![Message Queue pattern (Getting started with RabbitMQ)](graphics/image_06_015.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![消息队列模式（使用RabbitMQ入门）](graphics/image_06_015.jpg)'
- en: Publish-Subscriber pattern
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布-订阅模式
- en: The Publish-Subscriber pattern (or Pub/Sub for short) is a design pattern whereby
    messages aren't directly sent from publisher to subscribers; instead, publishers
    push out the message without any knowledge.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅模式（或简称Pub/Sub）是一种设计模式，其中消息不是直接从发布者发送到订阅者；相反，发布者在没有任何知识的情况下推送消息。
- en: In RabbitMQ, the *producer* never sends any messages directly to the queue.
    Quite often, the producer doesn't even know if the message will end up in a queue
    at all. Instead, the producer must send messages to an *exchange*. It receives
    messages from producers then pushes them out to queues.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在RabbitMQ中，*生产者*从不直接发送任何消息到队列。生产者甚至经常不知道消息是否最终会进入队列。相反，生产者必须将消息发送到*交换机*。它从生产者那里接收消息，然后将它们推送到队列。
- en: The *consumer* is the application that will receive the messages.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*消费者*是将接收消息的应用程序。'
- en: The exchange must be told exactly how to handle a given message, and which queue(s)
    it should be appended to. These rules are defined by the *exchange type*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 必须告诉交换机如何处理给定的消息，以及应该将其附加到哪个队列。这些规则由*交换类型*定义。
- en: 'The RabbitMQ documentation describes a Publish-Subscriber relationship (connecting
    the publisher, exchange, queue, and consumer) as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ文档描述了发布-订阅关系（连接发布者、交换机、队列和消费者）如下：
- en: '![Publish-Subscriber pattern](graphics/image_06_016.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![发布-订阅模式](graphics/image_06_016.jpg)'
- en: A *direct* exchange type delivers messages based on a routing key. It can be
    used both for one-to-one and one-to-many forms of routing, but it is best suited
    to a one-to-one relationship.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*直接*交换类型根据路由键传递消息。它可以用于一对一和一对多形式的路由，但最适合一对一的关系。'
- en: A *fanout* exchange type routes messages to all queues that are bound to it and
    the routing key is completely ignored. Effectively, you cannot differentiate between
    which workers messages will be distributed to based on the routing key.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*扇出*交换类型将消息路由到绑定到它的所有队列，并且路由键完全被忽略。实际上，您无法区分消息将基于路由键分发到哪些工作者。'
- en: A *topic* exchange type works by routing messages to one or many queues on the
    basis of a messaging routing queue and the pattern that was used to bind a queue
    to an exchange. This exchange has the potential to work well when are multiple
    consumers/applications that want to choose the type of messages they want to receive,
    usually in a many-to-many relationship.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*主题* 交换类型通过根据消息路由队列和用于将队列绑定到交换的模式来将消息路由到一个或多个队列。当有多个消费者/应用程序想要选择他们想要接收的消息类型时，这种交换有潜力很好地工作，通常是多对多的关系。'
- en: The *headers* exchange type is commonly used to route on a set of attributes
    that are better expressed in message headers than the routing queue. Instead of
    using routing keys, the attributes to the route are based on the headers attribute.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*headers* 交换类型通常用于根据消息头中更好地表达的一组属性进行路由。与使用路由键不同，路由的属性基于头属性。'
- en: 'In order to test a Pub/Sub queue, we will be using the following scripts. They
    are similar to the one in the example earlier, except I have modified them so
    that they use exchanges. Here is our `send.php` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试发布/订阅队列，我们将使用以下脚本。它们与之前的示例类似，只是我修改了它们以便它们使用交换。这是我们的 `send.php` 文件：
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is our `receive.php` file. Like before, I have modified this script so
    that it also uses exchanges:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的 `receive.php` 文件。和之前一样，我修改了这个脚本，以便它也使用交换：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let's test these scripts. We'll first need to have our `receive.php` script
    running, then we can send messages across using our `send.php` script.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试这些脚本。我们首先需要运行我们的 `receive.php` 脚本，然后我们可以使用我们的 `send.php` 脚本发送消息。
- en: 'First, let''s trigger our `receive.php` script so that it starts running:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们触发我们的 `receive.php` 脚本，以便它开始运行：
- en: '![Publish-Subscriber pattern](graphics/image_06_017.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '*发布-订阅模式* 图片'
- en: 'After this is complete we can then move on to sending messages by running our
    `send.php` script:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以通过运行我们的 `send.php` 脚本来发送消息：
- en: '![Publish-Subscriber pattern](graphics/image_06_018.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '*发布-订阅模式* 图片'
- en: 'This will now populate our Terminal running `receive.php` with the following
    information:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在运行 `receive.php` 的终端中填充以下信息：
- en: '![Publish-Subscriber pattern](graphics/image_06_019.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '*发布-订阅模式* 图片'
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about Architectural patterns. Starting with MVC,
    we learned the benefits and challenges of using UI frameworks and discussed how
    we can decouple our UI from our business logic in a stricter fashion.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了架构模式。从MVC开始，我们学习了使用UI框架的好处和挑战，并讨论了如何以更严格的方式将我们的UI与业务逻辑解耦。
- en: We then moved onto SOA and learned how this compared to microservices and where
    such architectures make sense, given the challenges distributed systems pose.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向了SOA，并学习了它与微服务的比较，以及在分布式系统提出挑战的情况下，这样的架构在哪些情况下是合理的。
- en: Finally, we did an in-depth tour of queuing systems, where they are appropriate,
    and how you can implement them in RabbitMQ.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们深入了解了队列系统，它们适用的情况以及如何在RabbitMQ中实现它们。
- en: In the next, and then the final chapter, we'll cover the best practice use conditions
    of Architectural patterns.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍架构模式的最佳实践使用条件。
