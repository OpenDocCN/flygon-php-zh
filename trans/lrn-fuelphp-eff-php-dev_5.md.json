["```php\n**oil r migrate --package=auth**\n\n```", "```php\n\"require\" : {\n    \"monolog/monolog\": \"1.2.*\"\n    }\n```", "```php\n**$ cd ~/Sites/journal**\n**$ git submodule add git@github.com:digitales/journal-text.git fuel/packages/string**\n**$ cd fuel/packages/string**\n\n```", "```php\n**/packages**\n **/package**\n **/bootstrap.php**\n **/classes**\n **/class1.php**\n **/second-class.php**\n **/config**\n **/packageconfig.php**\n\n```", "```php\nAutoloader::add_core_namespace( 'String', true );\n```", "```php\n**packages/**\n **/journal/**\n **/classes/**\n **string.php**\n **/config/**\n **string.php**\n **bootstrap.php**\n **readme.md**\n\n```", "```php\n<?php\n/**\n * NOTICE:\n *\n * If you need to make modifications to the default configuration, copy\n * this file to your app/config folder, and make them in there.\n *\n * This will allow you to upgrade without losing your custom config.\n */\nreturn array(\n    'active' => Fuel::$env,\n    'development' => array(\n        'salt' => 'put_your_salt_here',\n    ),\n    'production' => array(\n        'salt' => 'put_your_salt_here',\n    ),  \n);\n```", "```php\n<?php\n/**\n * String manipulation Package\n *\n * This is a simple set of methods for string manipulation\n *\n * @license    MIT License\n */\nnamespace String;\n```", "```php\nclass StringException extends \\Exception {}\n\nclass String {\n    protected static $config;\n\n    /**\n     * @var  object  PHPSecLib hash object\n     */\n    protected static $hasher;\n```", "```php\n    protected static function get_config()\n    {\n        if ( !static::$config ):\n            $config = \\Config::load('string', true);\n            static::$config = $config[ $config['active'] ];\n        endif;\n        return static::$config;    \n    }\n\n    /**\n     * Encode a string using the core encode function\n     *\n     *  This will retrieve the salt and use that for the encoding.\n     *\n     *  @param string $string The string to be encoded\n     *  @param null | string $salt If the salt is null, the config will be used instead.\n     *  @return string\n     */\n    public static function encode( $string, $salt = null )\n    {   \n        if ( ! $salt) {\n             $config = self::get_config();\n    $salt = $config['salt']; \n        }\n        return \\Crypt::encode( $string, $salt );\n    }\n```", "```php\n\n    /**\n     * Decode a string using the core decode function\n     *\n     *  This will retrieve the salt and use that for the decoding\n     *\n     *  @param string $string The string to be decoded\n     *  @param null | string $salt If the salt is null, the config will be used instead.\n     *  @return string\n     */\n    public static function decode( $string, $salt = null )\n    {\n        if ( ! $salt) {\n            $config = self::get_config();\n            $salt = $config['salt'];   \n        }    \n        return \\Crypt::decode ( $string, $salt );\n    }\n```", "```php\n\n    /**\n     * Default password hash method\n     *\n     * @param   string\n     * @return  string\n     */\n    public static function hash_password($password)\n    {    \n        $config = self::get_config();       \n            $salt = $config['salt'];\n        return base64_encode(self::hasher()->pbkdf2($password, $config['salt'], 10000, 32));\n    }\n\n    /**\n     * Returns the hash object and creates it if necessary\n     *\n     * @return  PHPSecLib\\Crypt_Hash\n     */\n    public static function hasher()\n    {\n        if ( !static::$hasher ):\n            if ( ! class_exists('PHPSecLib\\\\Crypt_Hash', false))\n            {\n                import('phpseclib/Crypt/Hash', 'vendor');\n            }\n            $hasher = new \\PHPSecLib\\Crypt_Hash();\n            return $hasher;\n        endif;\n\n        return static::$hasher;\n    }\n```", "```php\n\n    /**\n     * Convert the string to lowercase.\n     *\n     * @param   string  $str       required\n     * @param   string  $encoding  default UTF-8\n     * @return  string\n     */\n    public static function lower($str, $encoding = null)\n    {\n        $encoding = \\Fuel::$encoding;\n\n        if ( function_exists('mb_strtolower') ){\n            return mb_strtolower($str, $encoding);\n        } else {\n            return strtolower($str);\n        }\n\n    }\n```", "```php\n    /**\n     * Covert the string to uppercase.\n     *\n     * @param   string  $str       required\n     * @param   string  $encoding  default UTF-8\n     * @return  string\n     */\n    public static function upper($str, $encoding = null)\n    {\n        $encoding or $encoding = \\Fuel::$encoding;\n\n        if ( function_exists('mb_strtoupper') {\n            return mb_strtoupper($str, $encoding);\n        } else {\n            return strtoupper($str);\n        }\n\n    }\n```", "```php\n    /**\n     * lcfirst\n     *\n     * Does not strtoupper first\n     *\n     * @param   string  $str       required\n     * @param   string  $encoding  default UTF-8\n     * @return  string\n     */\n    public static function lcfirst($str, $encoding = null)\n    {\n        $encoding or $encoding = \\Fuel::$encoding;\n\n        if(function_exists('mb_strtolower')){\n            return mb_strtolower(mb_substr($str, 0, 1, $encoding), $encoding).\n                mb_substr($str, 1, mb_strlen($str, $encoding), $encoding);\n        }else{\n            return lcfirst($str);\n        }\n\n    }\n```", "```php\n    /**\n     * ucfirst\n     *\n     * Does not strtolower first\n     *\n     * @param    string $str       required\n     * @param    string $encoding  default UTF-8\n     * @return   string\n     */\n    public static function ucfirst($str, $encoding = null)\n    {\n        $encoding or $encoding = \\Fuel::$encoding;\n\n        if(function_exists('mb_strtoupper')_{\n            return mb_strtoupper(mb_substr($str, 0, 1, $encoding), $encoding).\n                mb_substr($str, 1, mb_strlen($str, $encoding), $encoding);\n        }else{\n            return ucfirst($str);\n        }\n\n    }\n```", "```php\n    /**\n     * ucwords\n     *\n     * First strtolower then ucwords\n     *\n     * ucwords normally doesn't strtolower first\n     * but MB_CASE_TITLE does, so ucwords now too\n     *\n     * @param   string   $str       required\n     * @param   string   $encoding  default UTF-8\n     * @return  string\n     */\n    public static function ucwords($str, $encoding = null)\n    {\n        $encoding or $encoding = \\Fuel::$encoding;\n\n        if ( function_exists('mb_convert_case') ){\n            return mb_convert_case($str, MB_CASE_TITLE, $encoding);\n        } else {\n            return ucwords(strtolower($str));\n        }\n\n    }\n}\n```", "```php\n<?php\nAutoloader::add_core_namespace('String');\n\nAutoloader::add_classes(array(\n    'String\\\\String' => __DIR__.'/classes/string.php',\n    'String\\\\StringException' => __DIR__.'/classes/string.php'\n));\n```", "```php\nString::decode( $the_string );\n```", "```php\n**$ cp ~/Sites/journal/fuel/packages/journal-string/config/string.php  ~/Sites/journal/fuel/app/config/string.php**\n\n```", "```php\nreturn array(\n    'active' => Fuel::$env,\n    'development' => array(\n        'salt' => '(my awesome salt)',\n    ),\n    'production' => array(\n        'salt' => '(my awesome salt)',\n    ),  \n);\n```", "```php\n**$encoded_string = String::encode( 'something to encode');**\n**$decoded_string = String::decode();**\n**echo $decoded_string;**\n\n```"]