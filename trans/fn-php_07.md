# 第七章。函数式技术和主题

我们已经涵盖了与函数式编程相关的基础技术。但是，你可能可以想象，还有很多其他主题需要涵盖。在本章中，你将学习一些这些模式和想法。

一些主题将被深入讨论，其他主题将被提及，并指向外部资源，如果你想了解更多。由于这是一本关于 PHP 函数式编程的入门书，最先进的想法超出了范围。然而，如果你在某个地方遇到了关于这样一个主题的文章，你应该有足够的理解力，至少能够理解其要点。

本章的各节并不一定彼此关联。有些内容可能对你来说是新的，有些则与之前呈现的摘录相关。

在本章中，我们将涵盖以下主题：

+   类型系统、类型签名及其用途

+   无点风格

+   使用`const`关键字来方便匿名函数的使用

+   递归、堆栈溢出和跳板

+   模式匹配

+   类型类

+   代数结构和范畴论

+   单子变换器

+   镜头

# 类型系统

免责声明：我并不打算在静态和动态类型的爱好者之间挑起争端。讨论哪种更好以及为什么并不是本书的目标，我会让你们每个人自己决定喜欢什么。如果你对这个主题感兴趣，我可以推荐阅读[`pchiusano.github.io/2016-09-15/static-vs-dynamic.html`](http://pchiusano.github.io/2016-09-15/static-vs-dynamic.html)，这是一个很好的总结，尽管有点偏向静态类型。

话虽如此，类型和类型系统是函数式编程中的重要主题，即使这些类型并不是由语言强制执行的。函数签名的类型是一种元语言，可以简洁有效地传达有关函数目的的信息。

正如我们将看到的那样，清楚地声明函数的输入和输出的预期类型是其文档的重要部分。它不仅通过允许你跳过阅读函数代码来减轻认知负担，还允许你推断出关于正在发生的重要事实并推导出“自由定理”。

## Hindley-Milner 类型系统

Hindley-Milner，也称为 Damas-Milner 或 Damas-Hindley-Milner，以最早理论化它的人的名字命名，是一种类型系统。类型系统是一组规则，定义变量或参数可以具有的类型以及不同类型如何相互作用。

Hindley-Milner 的主要特点之一是它允许类型推断。这意味着你通常不需要明确地定义类型；它可以从其他来源推断出，比如上下文或周围元素的类型。确切地说，类型推断是由一种叫做**算法 W**的算法完成的，它与 Hindley-Milner 类型系统有关，但并不完全相同。

它还允许多态性；这意味着如果你有一个返回列表长度的函数，列表元素的类型不需要被知道，因为它对计算没有影响。这类似于你可以在 C++或 Java 中找到的泛型，但并不完全相同，因为它更加强大。

大多数静态类型的函数式语言，如 Haskell、OCaml 和 F#，使用 Hindley-Milner 作为它们的类型系统，通常还会使用扩展来处理一些边缘情况。Scala 以其自己的类型系统而著称。

除了关于类型系统的理论，还有一种通常被接受的方法来描述函数的输入和输出参数，这正是我们感兴趣的。这与你可以在 PHP 中使用的类型提示非常不同，当语言不使用这种特定语法时，它通常被放在函数顶部的注释中。从现在开始，我们将把这样的类型注释称为函数的“类型签名”。

## 类型签名

作为第一个简单的例子，我们将从`strtoupper`和`strlen` PHP 函数的类型签名开始：

```php
// strtoupper :: string -> string 
// strlen :: string -> int 
```

这很简单理解：我们从函数名开始，后面是参数的类型，一个箭头，和返回值的类型。

那么有多个参数的函数呢？考虑以下情况：

```php
// implode :: string -> [string] -> string 
```

为什么有多个箭头？如果您考虑到柯里化，这可能会帮助您得到答案。如果我们使用括号编写相同的函数签名，这可能会进一步帮助您：

```php
// implode :: string -> ([string] -> string) 
```

基本上，我们有一个接受`string`类型并返回一个接受字符串数组并返回字符串的新函数。最右边的类型始终是返回值的类型。所有其他类型都是按顺序的各种参数。括号用于表示函数。让我们看看它在有更多参数的情况下是什么样子的：

```php
// number_format :: float -> (int -> (string -> (string -> string))) 
```

或者不使用括号：

```php
// number_format :: float -> int -> string -> string -> string 
```

我不知道您的意见是什么，但我个人更喜欢后者，因为它的噪音较小，一旦您习惯了它，括号就不会带来太多信息。

如果您熟悉`number_format`函数，您可能已经注意到我提出的类型签名包含所有参数，甚至是可选参数。这是因为没有一种传达这些信息的标准方法，因为函数式语言通常不允许这样的参数。然而，Haskell 有一个`Optional`数据类型，用于模拟这一点。有了这些信息，具有默认值的参数有时会显示如下：

```php
// number_format :: float -> Optional int -> Optional string -> Optional string -> string 
```

这很有效，并且很容易理解，直到你有一个名为`Optional`的数据类型。也没有一种常见的方法来表达默认值是什么。

据我所知，没有办法传达函数接受可变数量参数的信息。由于 PHP 7.0 引入了一个新的语法，我建议我们在本书的其余部分使用它：

```php
// printf :: string -> ...string -> int 
```

我们之前看到括号用于表示函数的概念，但通常出于可读性的原因通常不使用。然而，当使用函数作为参数时，情况并非如此。在这种情况下，我们需要保留函数期望或返回另一个函数的信息：

```php
// array_reduce :: [a] -> (b -> a -> b) -> Optional a -> b 
// array_map :: (a -> b) -> ...[a] -> [b] 
```

您可能会问自己，那些`a`和`b`变量是什么？这是我们之前谈到的多态特性。`array_reduce`和`array_map`函数不关心数组中包含的元素的真实类型是什么，它们不需要知道这些信息来执行它们的工作。我们可以像我们之前使用`printf`方法那样使用`mixed`函数，但那样我们将丢失一些有用的数据。

`a`变量是某种类型，`b`变量是另一种类型，或者也可以是相同的。像`a`和`b`这样的变量有时被称为**类型变量**。这些类型签名所说的是，我们有一个具有某种类型（类型`a`）的值数组，一个接受这样一个值并返回另一个类型（类型`b`）的函数；显然，最终值与回调的值相同。

名称`a`和`b`是一种约定，但您可以自由使用任何您想要的东西。在某些情况下，使用更长的名称或某些特定字母可能有助于传达更多信息。

### 注意

如果您对`array_reduce`函数的签名有困难，这是完全正常的。您还不熟悉语法。让我们尝试逐个接受参数：

+   包含`a`类型元素的数组

+   一个函数，接受类型`b`（累加器），类型`a`（当前值），并返回类型`b`（新的累加器内容）

+   一个与数组元素相同类型的可选初始值

+   返回值是`b`类型，与累加器相同类型

这个签名没有告诉我们`a`和`b`的确切类型。就我们所知，`b`本身可能是一个数组，一个类，一个布尔值，真的可以是任何东西。类型`a`和`b`也可以是相同的类型。

您还可以有一个唯一的类型变量，就像`array_filter`函数一样：

```php
// array_filter :: (a -> bool) -> [a] -> [a] 
```

由于类型签名只使用了`a`类型，这意味着输入数组中的元素和返回的数组将具有完全相同的类型。由于`a`类型不是特定类型，这个类型签名也告诉我们`array_filter`函数适用于所有类型，这意味着它不能转换值。列表中的元素只能被重新排列或过滤。

类型签名的最后一个特点是，您可以缩小给定类型变量的可能类型。例如，您可以指定某个类型`m`应该是给定类的子类：

```php
// filterM :: Monad m => (a -> m Bool) -> [a] -> m [a] 
```

我们刚刚引入了一个新的双箭头符号。您将始终在类型签名的开头找到它，而不会在中间找到。这意味着前面的内容定义了某种特定性。

在我们的例子中，我们将`m`类型变量约束为`Monad`类的后代。这使我们能够声明`filterM`方法首先接受一个返回布尔值的函数封装在一个 monad 中作为第一个参数，并且它的返回值将被封装在相同的 monad 中。

如果您愿意，可以指定多个约束。如果我们想象有两种类型，`TypeA`和`TypeB`类型，我们可以有以下类型签名：

```php
// some_function :: TypeA a TypeB b => a -> b -> string 
```

仅仅通过查看类型签名就无法清楚地知道这个函数的作用，但我们知道它期望`TypeA`类型的一个实例和`TypeB`类型的一个实例。返回值将是一个字符串，显然是基于参数计算的结果。

在这种情况下，我们不能像`array_filter`方法那样做出相同的假设，即不会发生任何转换，因为我们对类型变量有约束。我们的函数很可能知道如何操作我们的数据，因为它们是某种类型或其子类的实例。

我知道有很多东西要理解，但正如前面的`array_reduce`函数示例所证明的那样，类型签名允许我们以简洁的方式编码大量信息。它们也比 PHP 类型提示更精确，因为它们允许我们说`array_map`方法可以从一种类型转换为另一种类型，而`array_filter`方法将保持数组中的类型。

如果您浏览过`php-functional`库的代码，您可能已经注意到作者在大多数函数的文档块中使用了这样的类型签名。您还会发现一些其他函数式库也在做同样的事情，这种习惯在 JavaScript 世界也在传播。

## 自由定理

类型签名不仅让我们了解函数的作用，还允许我们根据类型信息推导出有用的定理和规则。这些被称为**自由定理**，因为它们随类型签名免费提供。这个想法是由 Philip Walder 在 1989 年发表的论文*Theorems for free!*中发展起来的。

通过使用一个自由定理，我们可以肯定以下事实：

```php
// head :: [a] -> a 
// map :: (a -> b) -> [a] -> [b] 
head(map(f, $x)) == f(head($x) 
```

这对您来说可能显而易见，因为您有一些常识并知道函数的作用，但计算机缺乏常识。因此，为了将等式的左边优化到右边，我们的编译器或解释器必须依赖自由定理来实现。

类型签名如何证明这个定理？还记得我们说过`a`类型是我们的函数一无所知的通用类型吗？推论是它们不能修改数组中的值，因为这样的通用函数不存在。唯一知道如何转换的函数是`f`，因为它需要符合 map 强制的`(a -> b)`类型签名。

由于`head`和`map`函数都不修改元素，我们可以推断先应用函数然后取第一个元素与先取第一个元素再应用函数是完全相同的。只是第二种方式更快：

```php
// filter :: (a -> Bool) -> [a] -> [a] 
map(f, filter(compose(p, f), $x)) === filter(p, map(f, $x)) 
```

稍微复杂一些，这个自由定理说，如果你的谓词需要使用函数`f`转换一个值，然后你在结果上应用`f`函数，这与首先对所有元素应用`f`然后进行过滤完全相同。再次的想法是通过只应用一次`f`来优化性能，而不是两次。

当将函数组合在一起或在彼此之后调用它们时，尝试查看类型签名，看看是否可以通过推导一些自由定理来改进你的代码。

Haskell 用户甚至可以在[`www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi`](http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi)上使用自由定理生成器。

## 结束语

类型签名为我们带来了很多东西，你可以找到基于它们的函数搜索引擎。像[`www.haskell.org/hoogle/`](https://www.haskell.org/hoogle/)和[`scala-search.org/`](http://scala-search.org/)这样的网站允许你仅基于它们的类型签名搜索函数。

当使用函数式技术时，经常会出现这样的情况，你的数据有一定的结构，你需要将其转换为其他形式。由于大多数函数都是完全通用的，很难找到正确的关键字来搜索你要找的东西。这也是类型签名和**Hoogle**这样的搜索引擎派上用场的地方。只需输入你的输入的类型结构，想要的输出类型，然后浏览搜索引擎返回的函数列表。

PHP 是一种动态类型的语言，而且最近才引入了标量类型，显然还没有围绕类型签名的有用工具。但也许只是时间的问题，人们会想出一些东西。

# 无点风格

无点风格，也称为暗示编程，是一种编写函数的方式，其中你不明确定义参数或点，因此得名。根据语言的不同，可以在不同的层次上应用这种特定的风格。你如何有没有确定参数的函数？通过使用函数组合或柯里化。

事实上，在本书中我们之前已经进行了一些无点风格的编程。让我们使用第四章中的一个例子，*组合函数*，来说明它是关于什么的：

```php
<?php 
// traditional 
function safe_title(string $s) 
{ 
    return strtoupper(htmlspecialchars($s)); 
} 

// point-free 
$safe_title = compose('htmlspecialchars', 'strtoupper'); 
```

第一部分是传统函数，其中你声明一个输入参数。然而，在第二种情况下，你看不到明确的参数声明；你依赖于组合函数的定义。第二个函数被称为无点风格。

PHP 语法要求我们将组合或柯里化的函数分配给一个变量，但在一些其他语言中并没有这样清晰的分离。以下是 Haskell 中的三个例子：

```php
-- traditional 
sum (x:xs) = x + sum xs 
sum [] = 0 

-- using foldr 
sum xs = foldr (+) 0 xs 

-- point-free 
sum = foldr (+) 0 
```

正如我们所看到的，这三种情况下函数定义的结构是相同的。第一个是在不使用折叠的情况下定义`sum`方法的方式。第二个例子承认我们可以简单地对数据进行折叠，但仍然明确声明了参数。最后一个例子是无点风格的，因为没有任何参数的痕迹。

另一种语言中，函数和变量之间的区别比在 PHP 中更微妙的是 JavaScript。事实上，所有函数都是变量，由于没有变量的特殊语法，传统函数和分配给变量的匿名函数之间没有区别：

```php
// traditional 
function snakeCase(word) { 
    return word.toLowerCase().replace(/\s+/ig, '_'); 
}; 

// point-free 
var snakeCase = compose(replace(/\s+/ig, '_'), toLowerCase); 
```

显然，这不是有效的 JavaScript，因为没有原生的`compose`函数，而且两个作用于字符串的函数不能这样简单地调用。然而，有多个库可以让你轻松编写这样的代码，比如**Ramda**，我强烈推荐。这个例子的重点只是为了证明你无法区分传统函数和 JavaScript 中的匿名函数，就像在 PHP 中一样。

使用这种风格有一些好处：

+   通常你会有更简洁的代码，有些人认为这样更清晰，更容易阅读。

+   它有助于以抽象的方式思考。JavaScript 示例中的参数名`word`暗示该函数只对单词起作用，而它实际上可以对任何字符串起作用。这对于更通用的函数尤其如此，比如那些在列表上工作的函数。

+   它有助于开发人员以函数组合而不是数据结构的方式思考，这通常会导致更好的代码。

然而，也有一些可能的缺点：

+   从定义中去掉显式参数可能会使事情更难理解；没有参数名，例如，有时会去掉有用的信息。

+   长链的组合函数可能导致失去对数据结构和类型的视野。

+   代码可能更难维护。当你有一个明确的函数时，你可以很容易地添加新的行，进行调试等。但是当函数组合在一起时，这几乎是不可能的。

有些反对者有时会使用术语*无意义的风格*来描述这种技术的结果。

阅读和使用无点代码肯定需要一些时间来适应。我个人对此没有强烈的意见。我建议你使用最适合你的风格，而且即使你更喜欢其中一种，也有一些情况下另一种可能更好，所以不要犹豫混合使用两种风格。

最后，我想提醒你，“参数顺序很重要！”就像我们在第四章中讨论的那样，*组合函数*。如果你想使用无点风格，这一点尤其重要。如果你需要处理的数据不是最后一个参数，你将无法使用。

# 使用 const 关键字来定义函数

这种技术与函数式编程无关，而是 PHP 本身的一个巧妙技巧。然而，它可能会帮助你很多，所以我们来试试。

如果你看过`functional-php`库的代码，你可能已经注意到几乎所有函数顶部都有常量的定义。这里有一个小例子：

```php
<?php 
const push = 'Widmogrod\Functional\push'; 

function push(array $array, array $values) 
{ 
    // [...] 
} 
```

这背后的想法是允许更简单地使用函数作为参数。我们之前看到，你传递函数或方法作为参数的方式是使用一个叫做`callable`的东西，通常是一个字符串或一个由对象实例和要调用的方法的字符串组成的数组。

使用`const`关键字使我们更接近于在函数与变量不是分开构造的语言中找到的东西：

```php
<?php const increment = 'increment'; 

function increment(int $i) { return $i + 1; } 

// using a 'callable' 
array_map('increment' [1, 2, 3, 4]); 

// using our const 
array_map(increment, [1, 2, 3, 4]); 
```

去掉我们函数名周围的尴尬引号。这看起来真的像你在传递函数本身，就像其他语言如 Python 或 JavaScript 中的情况一样。

如果你使用的是 IDE，情况会更好。你可以使用*转到声明*或等效的功能，定义`const`的文件将在定义它的行上打开。如果你将它声明在*真正*函数的顶部或底部，你将快速访问到它的定义。

一些我不知道的 IDE 可能会为`callable`提供相同的功能，但至少对我使用的这个来说并不是这样。然而，如果我在第二个例子中按下*Ctrl* +点击`increment`函数，它会聚焦在`const`声明上，这真的节省了很多时间。

当像这样声明常量时，你不仅限于影子函数；它也适用于静态对象方法。你还可以使用**DocBlock**注释来声明你的常量代表一个`callable`类型：

```php
<?php 
class A { 
    public static function static_test() {} 
    public function test() {} 
} 

/** @var callable */ 
const A_static = ['A', 'static_test']; 
```

遗憾的是，这个技巧对存储在变量中的匿名函数或在对象实例上调用方法不起作用。如果你尝试这样做，PHP 会用一个响亮的`Warning: Constants may only evaluate to scalar values or arrays`警告来回报你。

尽管不是万能的，而且伴随着一些限制，这个小技巧将帮助你编写更清晰、更容易在 IDE 中导航的代码。

# 递归、堆栈溢出和跳板

我们首先在第三章中将递归作为解决编程问题的可能解决方案进行了介绍，*PHP 中的函数基础*。一些内存问题已经被暗示出来；现在是时候进一步调查了。

## 尾调用

在返回值之前执行的最后一个语句是称为**尾调用**的函数调用。让我们看一些例子来理解它的含义：

```php
<?php 
function simple() { 
    return strtoupper('Hello!'); 
} 
```

毫无疑问，这是一个尾调用。函数的最后一个语句返回`strtoupper`函数的结果：

```php
<?php 

function multiple_branches($name) { 
    if($name == 'Gilles') { 
        return strtoupper('Hi friend!'); 
    } 
    return strtoupper('Greetings'); 
} 
```

在这里，对`strtoupper`函数的两次调用都是尾调用。函数内的位置并不重要；重要的是在函数调用之后是否进行了任何操作。在我们的例子中，如果参数值是`Gilles`，函数将做的最后一件事是调用`strtoupper`函数，使其成为尾调用：

```php
<?php 
function not_a_tail_call($name) { 
    return strtoupper('Hello') + ' ' + $name; 
} 

function also_not_a_tail_call($a) { 
    return 2 * max($a, 10); 
} 
```

这两个函数都没有尾调用。在这两种情况下，调用的返回值被用来计算最终值，然后函数返回。操作的顺序并不重要，解释器需要首先获取`strtoupper`和`max`函数的值，以计算结果。

正如我们刚才看到的，发现尾调用并不总是容易的。你可以在一个非常长的函数的前几行中有一个尾调用，并且处于最后一行并不是一个充分的标准。

如果尾调用是对函数本身的调用，或者换句话说是递归调用，那么**尾递归**这个术语经常被使用。

## 尾调用消除

为什么要费心呢？也许你正在问自己？因为编译器和解析器可以执行一种称为尾调用消除或有时称为**尾调用优化**（**TCO**）的东西。

程序不是执行一个新的函数调用并遭受所有相关的开销，而是简单地跳转到下一个函数，而不向堆栈添加更多信息并浪费宝贵的时间传递参数。

这在尾递归的情况下特别重要，因为它允许堆栈保持平坦，不使用比第一个函数调用更多的内存。

听起来很棒，但是像大多数高级编译技术一样，PHP 引擎并没有实现尾调用消除。然而，其他语言做到了：

+   任何符合**ECMAScript** 6 标准的 JavaScript 引擎

+   安装了 tco 模块后的 Python

+   在 Scala 中，甚至有一个注解（`@tailrec`）可以触发编译器错误，如果你的方法不是尾递归的

+   **Elixir**

+   **Lua**

+   **Perl**

+   Haskell

在**Java 虚拟机**（**JVM**）级别也有正在进行的提案和工作来执行尾调用消除，但到目前为止在 Java 8 中还没有具体的实现，因为这不被认为是一个优先特性。

尾递归函数通常更容易处理，特别是在折叠方面；正如我们在本节中看到的，存在一些技术来缓解堆栈增长问题，但代价是一些处理能力。

## 从递归到尾递归

既然我们对我们正在谈论的内容有了更清晰的理解，让我们学习如何将递归函数转换为尾递归函数，如果还不是的话。

我们拒绝将计算阶乘作为第三章中好的递归示例，*PHP 中的函数基础*，但是因为它可能是最简单的递归函数，我们将从这个例子开始：

```php
<?php 
function fact($n) 
{ 
    return $n <= 1 ? 1 : $n * fact($n - 1); 
} 
```

这个函数是尾递归的吗？不是，我们将一个值与我们递归调用`fact`方法的结果相乘。让我们更详细地看一下各个步骤：

```php
fact(4) 
4 * fact(3) 
4 * 3 * fact(2) 
4 * 3 * 2 * fact(1) 
4 * 3 * 2 * 1 
-> 24 
```

你有什么想法可以将这个转换为尾递归函数吗？在继续阅读之前，花点时间玩一下一些想法。如果你需要提示，想一想用于折叠的函数是如何操作的。

当涉及到尾递归时，通常的答案是使用累加器：

```php
<?php 
function fact2($n) 
{ 
    $fact = function($n, $acc) use (&$fact) { 
        return $n <= 1 ? $acc : $fact($n - 1, $n * $acc); 
    }; 

    return $fact($n, 1); 
} 
```

这里我们使用了一个内部辅助函数来隐藏累加器的实现细节，但我们也可以只使用一个唯一的函数来写它：

```php
<?php 

function fact3($n, $acc = 1) 
{ 
    return $n <= 1 ? $acc : fact3($n - 1, $n * $acc); 
} 
```

让我们再次看一下这些步骤：

```php
fact(4) 
fact(3, 4 * 1) 
fact(2, 3 * 4) 
fact(1, 2 * 12) -> 24 
```

太好了，在每个递归调用之后没有未决操作了；我们真的有一个尾递归函数。我们的`fact`函数非常简单。我们之前写的*汉诺塔*求解器呢？这里有它，这样你就不用再去找了：

```php
<?php 
function hanoi(int $disc, string $source, string $destination,  string $via) 
{ 
    if ($disc === 1) { 
        echo("Move a disc from the $source rod to the $destination  rod\n"); 
    } else { 
        // step 1 : move all discs but the first to the "via" rod 
        hanoi($disc - 1, $source, $via, $destination); 
        // step 2 : move the last disc to the destination 
        hanoi(1, $source, $destination, $via); 
        // step 3 : move the discs from the "via" rod to the  destination 
        hanoi($disc - 1, $via, $destination, $source); 
    } 
} 
```

就像我们的阶乘计算一样，花点时间尝试将函数转换为尾递归函数：

```php
<?php 
use Functional as f; 

class Position 
{ 
    public $disc; 
    public $src; 
    public $dst; 
    public $via; 

    public function __construct($n, $s, $d, $v) 
    { 
        $this->disc = $n; 
        $this->src = $s; 
        $this->dst = $d; 
        $this->via = $v; 
    } 
} 

function hanoi(Position $pos, array $moves = []) 
{ 
    if ($pos->disc === 1) { 
        echo("Move a disc from the {$pos->src} rod to the {$pos- >dst} rod\n"); 

        if(count($moves) > 0) { 
            hanoi(f\head($moves), f\tail($moves)); 
        } 
    } else { 
        $pos1 = new Position($pos->disc - 1, $pos->src, $pos->via,  $pos->dst); 
        $pos2 = new Position(1, $pos->src, $pos->dst, $pos->via); 
        $pos3 = new Position($pos->disc - 1, $pos->via, $pos->dst,  $pos->src); 

        hanoi($pos1, array_merge([$pos2, $pos3], $moves)); 
    } 
} 
hanoi(new Position(3, 'left', 'right', 'middle')); 
```

正如你所看到的，解决方案非常相似，即使在函数内部有多个递归调用时，我们仍然可以使用一个累加器。诀窍是使用一个数组而不是仅存储当前值。在大多数情况下，累加器将是一个**堆栈**，这意味着你只能在开头添加元素并从开头删除它们。堆栈被称为**后进先出**（**LIFO**）结构。

如果你不太明白这个重构是如何工作的，我鼓励你写下两种变体的步骤，就像我们为`fact`方法所做的那样，这样你就可以更好地理解涉及的机制。

事实上，花时间写下递归算法的步骤通常是清楚地理解发生了什么以及如何重构为尾递归或修复错误的好方法。

## 堆栈溢出

我们为尾递归的汉诺塔求解器使用类似堆栈的数据结构并非巧合。当你调用函数时，所有需要的信息也会存储在内存中类似堆栈的结构中。在递归的情况下，它看起来会像这样：

![堆栈溢出](img/image_07_001.jpg)

这个堆栈有一个有限的大小。它通过`memory_limit`配置选项进行限制，即使你移除了限制，也无法超出系统中可用的内存。此外，诸如**Xdebug**之类的扩展引入了特定的机制，以避免有太多嵌套的递归调用。例如，你有一个名为`xdebug.max_nesting_level`的配置选项，默认值为 256，这意味着如果你递归调用一个函数超过这个值，就会引发错误。

如果 PHP 执行尾调用优化，而不是将函数信息的各个部分堆叠在一起，调用将会替换堆栈中的当前信息。这样做是安全的，因为尾调用的最终结果不依赖于函数局部变量。

由于 PHP 不执行这种优化，我们需要找到另一个解决方案来避免堆栈溢出。如果你遇到这个问题，并且愿意牺牲一些处理能力来限制内存使用，你可以使用**trampolines**。

## trampolines

我们避免堆栈增长的唯一方法是返回一个值而不是调用一个新函数。这个值可以保存执行新函数调用所需的信息，从而继续计算。这也意味着我们需要函数的调用者的一些合作。

这个有用的调用者就是 trampoline，这是它的工作原理：

+   trampoline 调用我们的函数`f`

+   `f`函数不再进行递归调用，而是返回封装在数据结构中的下一个调用和所有参数

+   trampoline 提取信息并对`f`函数进行新的调用

+   重复最后两个步骤，直到`f`函数返回一个*真实*值

+   trampoline 接收一个值并返回给*真实*的调用者

这些步骤也应该解释了这个技术的名称来源，每次函数返回到 trampoline 时，它都会以下一个参数弹回来。

为了执行这些步骤，我们需要一个数据结构，其中包含以`callable`形式调用的函数和参数。我们还需要一个辅助函数，它将继续调用数据结构中存储的任何内容，直到获得真实值：

```php
<?php 
class Bounce 
{ 
    private $f; 
    private $args; 

    public function __construct(callable $f, ...$args) 
    { 
        $this->f = $f; 
        $this->args = $args; 
    } 

    public function __invoke() 
    { 
        return call_user_func_array($this->f, $this->args); 
    } 
} 

function trampoline(callable $f, ...$args) { 
    $return = call_user_func_array($f, $args); 

    while($return instanceof Bounce) { 
        $return = $return(); 
    } 
    return $return; 
} 
```

足够简单，让我们试试：

```php
<?php 

function fact4($n, $acc = 1) 
{ 
    return $n <= 1 ? $acc : new Bounce('fact4', $n - 1, $n *  $acc); 
} 

echo trampoline('fact4', 5) 
// 120 
```

效果很好，代码也没有那么难读。然而，在使用蹦床时会有性能损失。在计算阶乘的情况下，蹦床版本在我的笔记本电脑上大约慢了五倍。这是因为解释器需要做的工作比简单调用下一个函数要多得多。

知道这一点，如果你的递归算法有一个有限的深度，并且你确信不会发生堆栈溢出，我建议你只执行传统的递归，而不是使用蹦床。然而，如果有疑问，不要犹豫，因为堆栈溢出错误可能对生产系统造成严重影响。

### 多步递归

蹦床甚至对执行不完全尾调用消除的语言也有用处。例如，当涉及两个函数时，Scala 无法执行这样的优化。不要试图解释我在说什么，让我们看一些代码：

```php
<?php 

function even($n) { 
    return $n == 0 ? 'yes' : odd($n - 1); 
} 

function odd($n) { 
    return $n == 0 ? 'no' : even($n - 1); 
} 

echo even(10); 
// yes 

echo odd(10); 
// no 
```

这可能不是确定一个数字是奇数还是偶数的最佳最有效的方法，但它有简单说明我在谈论什么的优点。两个函数都在调用自己，直到数字达到 0 为止，这时我们可以决定它是奇数还是偶数。

根据你问的人，这可能是递归，也可能不是。它符合我们在第三章中给出的学术定义，*PHP 中的函数基础*：

> *递归是将问题分解为相同问题的较小实例的想法。*

然而，该函数并没有调用自身，所以这就是为什么有些人会尝试用其他术语来定义这里发生的事情。最终，我们称之为什么并不重要；在一个大数字上，我们将会遇到堆栈溢出。

正如我所说，Scala 执行不完全的尾调用消除，只有当函数调用自身作为最后一条指令时才会这样做，这会导致堆栈溢出错误，就像 PHP 会做的那样。这就是为什么即使在一些函数式语言中也会使用蹦床来解决堆栈溢出问题。

作为一个真正简单的练习，我邀请你使用蹦床来重写`odd`和`even`函数。

### 蹦床库

如果你想在自己的项目中使用蹦床，我邀请你使用`composer`命令安装以下库，因为它相对于我们的粗糙实现提供了一些帮助：

```php
**composer require functional-php/trampoline**

```

数据结构和功能已经合并在同一个名为`Trampoline`的类中。助手以函数的形式可用：

+   `bounce`助手用于创建一个新的函数包装器。它接受一个`callable`和参数。

+   `trampoline`助手运行一个可调用对象直到完成。它接受一个`callable`和它的参数。该方法还接受`Trampoline`类实例作为参数，但在这种情况下，参数将被忽略，因为它们已经包装在实例中。

该类还定义了`__callStatic`，这允许我们直接在类上调用全局命名空间中的任何函数。

以下是从文档中摘取的一些示例：

```php
<?php 

use FunctionalPHP\Trampoline as t; 
use FunctionalPHP\Trampoline\Trampoline; 

function factorial($n, $acc = 1) { 
    return $n <= 1 ? $acc : t\bounce('factorial', $n - 1, $n * $acc); 
}; 

echo t\trampoline('factorial', 5); 
// 120 

echo Trampoline::factorial(5); 
// 120 

echo Trampoline::strtoupper('Hello!'); 
// HELLO! 
```

还有另一个带有所有蹦床功能的可调用返回助手，它被称为`trampoline_wrapper`助手：

```php
<?php 
$fact = t\trampoline_wrapper('factorial'); 

echo $fact(5); 
// 120 
```

作为练习，你可以尝试将我们的*汉诺塔*求解器转换为使用`trampoline`库，并看看是否得到相同的结果。

## 替代方法

除了使用蹦床来解决堆栈溢出问题之外，还可以使用队列来存储对我们函数的连续递归调用的所有参数。

原始函数需要包装在一个辅助函数中，该函数将保存队列并以链式调用所有参数调用原始函数。为了使其工作，递归调用需要在包装器而不是原始函数中进行：

+   创建包装器函数

+   使用第一个参数调用包装器的第一次调用

+   当队列中有参数时，包装器进入一个循环，调用原始函数

+   每次对包装器的后续调用都会将参数添加到队列中，而不是调用原始函数

+   循环完成后（即所有递归调用都已完成），包装器返回最终值

为了使其工作，原始函数在进行递归调用时真的很重要。这可以通过在包装函数内部使用的匿名函数或使用`Closure`类的`bindTo`方法来完成，正如我们在第一章中讨论的那样，“PHP 中的一等公民函数”。

`trampoline`库使用后一种技术实现了这种方法。以下是您可以使用它而不是蹦床的方法：

```php
<?php 

use FunctionalPHP\Trampoline as t; 

$fact = T\pool(function($n, $acc = 1) { 
    return $n <= 1 ? $acc : $this($n - 1, $n * $acc); 
}); 

echo $fact(5); 
// 120 
```

由`pool`函数创建的包装器将`Pool`类的实例绑定到`$this`。该类具有一个`__invoke`方法，在我们的原始函数中可调用。这样做将再次调用包装器，但这次它将把参数添加到队列中，而不是调用原始函数。

从性能的角度来看，这种方法和蹦床之间没有区别，两者的性能应该大致相同。然而，使用`pool`函数时，不能进行多步递归，因为包装器只知道一个函数。

此外，直到 PHP 7.1 发布，由于一些困难将可调用的字符串形式转换为`Closure`类的实例以绑定类，此方法也仅限于匿名函数。PHP 7.1 将在`Closure`上引入一个新的`fromCallable`方法，允许解除此限制。

## 结束语

最后要注意的是，我们已经看到的蹦床和队列技术只有在递归函数是尾递归时才能解决堆栈溢出问题。这是一个强制条件，因为函数需要完全返回，以便辅助函数继续计算。

此外，由于蹦床方法的缺点较少，我建议使用它而不是`pool`函数实现。

# 模式匹配

模式匹配是大多数函数式语言中非常强大的功能。它嵌入在语言的各个层面。例如，在 Scala 中，您可以将其用作强化的`switch`语句，在 Haskell 中，它是函数定义的一个组成部分。

模式匹配是检查一系列标记与模式是否匹配的过程。它不同于模式识别，因为匹配需要精确。该过程不仅匹配，还分配值，就像 PHP 中的`list`构造一样，这个过程称为**解构赋值**。

不要与正则表达式混淆。正则表达式只能操作字符串的内容，而模式匹配还可以操作数据的结构。例如，您可以匹配数组的元素数量。

让我们在 Haskell 中看一些例子，以便我们对其有所了解。最简单的模式匹配形式是匹配特定值：

```php
fact :: (Integral a) => a -> a 
fact 0 = 1 
fact n = n * fact (n-1) 
```

这是您可以在 Haskell 中定义`fact`函数的方式：

+   第一行是类型签名，应该让您想起本章前面看到的内容；`Integral`是一种比`Integer`类型不那么严格的类型，不详细介绍。

+   第二行是如果参数的值为 0 的函数体。

+   最后一行在所有其他情况下执行。该值分配给`n`变量。

如果您对某些值不感兴趣，可以使用`_`（下划线）通配符模式来忽略它们。例如，您可以轻松地定义函数来从元组中获取第一个、第二个和第三个值：

```php
first :: (a, b, c) -> a 
first (x, _, _) = x 

second :: (a, b, c) -> b 
second (_, y, _) = y 

third :: (a, b, c) -> c 
third (_, _, z) = z 
```

### 注意

元组是一个具有固定数量元素的数据结构，与可以改变大小的数组相对。`(1, 2)`和`('a', 'b')`元组的大小都是两个。在已知元素数量的情况下使用元组而不是数组的优势在于强制正确的大小和性能。

诸如 Haskell、Scala、Python、C#和 Ruby 之类的语言在其核心或标准库中都有元组类型。

您可以将值解构为不止一个变量。为了理解以下示例，您需要知道“:`”（冒号）是将元素前置到列表的操作符。这意味着`1:[2, 3]`元组将返回列表`[1, 2, 3]`：

```php
head :: [a] -> a 
head [] = error "empty list" 
head (x:_) = x 

tail :: [a] -> [a] 
tail [] = error "empty list" 
tail (_:xs) = xs 

sum :: (Num a) => [a] -> a 
sum [] = 0 
sum (x:xs) = x + sum xs 
```

`head`和`tail`变量具有相同的结构，如果列表为空，它们返回一个错误。否则，返回`x`，即列表开头的元素，或者`xs`，即列表的其余部分。`sum`变量也类似，但它同时使用`x`和`xs`。顺便说一句，Haskell 将不允许定义这两个函数，因为它们已经存在：

```php
firstThree :: [a] -> (a, a, a) 
firstThree (x:y:z:_) = (x, y, z) 
firstThree _ = error "need at least 3 elements" 
```

`firstThree`变量有点不同。它首先尝试匹配至少三个元素的列表，`x`，`y`和`z`。在这种情况下，`_`模式可以是空列表，也可以不是，模式将匹配。如果匹配不成功，我们知道列表少于三个元素，然后显示一个错误。

您还可以将模式匹配用作强化的开关语句。例如，这也是`head`的有效实现：

```php
head :: [a] -> a 
head xs = case xs of []    -> error "empty lists" 
(x:_) -> x 
```

如果您想同时使用解构数据和整个值，可以使用**as 模式**：

```php
firstLetter :: String -> String 
firstLetter "" = error "empty string" 
firstLetter all@(x:_) = "The first letter of " ++ all ++ " is " ++ [x] 
```

最后，您还可以在进行模式匹配时使用构造函数。以下是使用`Maybe`类型的一个小例子：

```php
increment :: Maybe Int -> Int 
increment Nothing = 0 
increment (Just x) = x + 1 
```

是的，您可以像这样轻松地获取 Monad 中的值，使用解构。

您可以有重叠的模式；Haskell 将使用第一个匹配的模式。如果它无法找到匹配的模式，它将引发一个错误，显示`函数 XXX 中的非穷尽模式`。

我们可以大致展示 Scala、Clojure 或其他函数语言的相同类型的功能，但由于这只是一个了解模式匹配的示例，如果您对此话题感兴趣，我建议您阅读有关该主题的教程。相反，我们将尝试在 PHP 中模拟这一强大功能的一部分。

## PHP 中的模式匹配

显然，我们永远无法像在 Haskell 中看到的那样声明函数，因为这需要在语言的核心实现。但是，一个库试图尽可能地模拟模式匹配，以创建一个更强大的开关语句版本，具有自动解构功能。

您可以使用 Composer 中的`composer`命令安装该库：

```php
**composer require functional-php/pattern-matching**

```

为了尽可能地表达 Haskell 中的可用内容，它使用字符串来保存模式。以下是定义各种可能语法的表格：

| 名称 | 格式 | 示例 |
| --- | --- | --- |
| 常量 | 任何标量值（整数、浮点数、字符串、布尔值） | `1.0`，`42`，"test" |
| 变量 | 标识符 | `a`，`name`，`anything` |
| 数组 | [<模式>, ..., <模式>] | `[]`，`[a]`，`[a, b, c]` |
| Cons | (标识符:列表标识符) | `(x:xs)`，`(x:y:z:xs)` |
| 通配符 | _ | _ |
| As | 标识符@(<模式>) | all@(x:xs) |

在撰写本文时，尚不支持在 Monad 或其他类型内部自动解构值，也不支持约束我们匹配的特定项的类型的可能性。但是，关于这两个功能存在已打开的问题[`github.com/functional-php/pattern-matching/issues`](https://github.com/functional-php/pattern-matching/issues)。

由于在 PHP 中无法使用命名参数，参数将按照它们在模式中定义的顺序传递，并且不会根据它们的名称进行匹配。这使得有时使用该库会有点麻烦。

### 更好的 switch 语句

该库还可以用于执行更高级的`switch`语句，还可以使用结构并提取数据，而不仅仅是对值进行等价判断。由于函数是柯里化的，您还可以将它们映射到数组上，与`switch`语句相反。

```php
<?php 

use FunctionalPHP\PatternMatching as m; 

$users = [ 
    [ 'name' => 'Gilles', 'status' => 10 ], 
    [ 'name' => 'John', 'status' => 5 ], 
    [ 'name' => 'Ben', 'status' => 0], 
    [], 
    'some random string' 
]; 

$statuses = array_map(m\match([ 
    '[_, 10]' => function() { return 'admin'; }, 
    '[_, 5]' => 'moderator', 
    '[_, _]' => 'normal user', 
    '_' => 'n/a', 
]), $users); 

print_r($statuses); 
// Array ( 
//    [0] => Gilles - admin 
//    [1] => John - moderator 
//    [2] => Ben - normal user 
//    [3] => incomplete array 
//    [4] => n/a 
// ) 
```

列表中匹配的第一个模式将被使用。如您所见，回调可以是一个函数，如第一个模式，也可以是一个将被返回的常量。显然，在这种情况下，它们都可以是常量，但这是为了举例。

传统的`switch`语句无法像您所看到的那样灵活，因为您不受数据结构的约束。在我们的例子中，我们为错误的数据创建了一个通用模式。使用`switch`语句，您需要过滤数据或执行某种其他数据规范化。

这个例子也可以使用解构来避免具有常量的三个模式（同时，我们还将使用数组中的名称）。

```php
<?php 

$group_names = [ 10 => 'admin', 5 => 'moderator' ]; 

$statuses = array_map(m\match([ 
    '[name, s]' => function($name, $s) use($group_names) { 
        return $name. ' - '. (isset($group_names[$s]) ? $group_names[$s] : 'normal user'); 
    }, 
    '[]' => 'incomplete array', 
    '_' => 'n/a',]), $users); 
print_r($statuses); 
// Array ( 
//    [0] => admin 
//    [1] => moderator 
//    [2] => normal user 
//    [3] => incomplete array 
//    [4] => n/a 
// ) 
```

您还可以编写匹配各种不同结构的模式，并根据它确定要执行的操作。它还可以用于在 Web 应用程序内执行某种基本路由。

```php
$url = 'user/10'; 

function homepage() { return "Hello!"; } 
function user($id) { return "user $id"; } 
function add_user_to_group($group, $user) { return "done."; } 

$result = m\match([ 
    '["user", id]' => 'user', 
    '["group", group, "add", user]' => 'add_user_to_group', 
    '_' => 'homepage', 
], explode('/', $url)); 

echo $result; 
// user 10 
```

显然，一个更专业的库会更好地执行路由并具有更好的性能，但牢记这种可能性会很方便，并且它展示了模式匹配的多功能性。

### 其他用途

如果您只对解构数据感兴趣，`extract`函数可以满足您的需求。

```php
<?php 
$data = [ 
  'Gilles', 
  ['Some street', '12345', 'Some City'], 
  'xxx xx-xx-xx', 
  ['admin', 'staff'], 
  ['username' => 'gilles', 'password' => '******'], 
  [12, 34, 53, 65, 78, 95, 102] 
]; 

print_r(m\extract('[name, _, phone, groups, [username, _],  posts@(first:_)]', $data)); 
// Array ( 
//    [name] => Gilles 
//    [phone] => xxx xx-xx-xx 
//    [groups] => Array ( [0] => admin [1] => staff ) 
//    [username] => gilles 
//    [posts] => Array ( ... ) 
//    [first] => 12 
//) 
```

提取数据后，您可以使用 PHP 的`extract`函数将变量导入当前作用域。

如果您想创建类似我们在 Haskell 示例中看到的函数，可以使用`func`辅助方法。显然，语法不太好，但它可能会派上用场。

```php
<?php 
$fact = m\func([ 
    '0' => 1, 
    'n' => function($n) use(&$fact) { 
        return $n * $fact($n - 1); 
    } 
]); 
```

请注意，函数创建仍处于测试阶段。存在一些问题，因此 API 可能会在将来更改。如果遇到任何问题，请参阅文档。

# 类型类

在阅读有关函数式编程的论文、帖子或教程时，您经常会遇到的另一个概念是类型类，特别是如果内容涉及 Haskell。

类型类的概念最初是在 Haskell 中引入的，作为一种实现可以轻松地为各种类型进行重载的操作符的方法。从那时起，人们发现了它们的许多其他用途。例如，在 Haskell 中，函子、应用函子和单子都是类型类。

Haskell 主要需要类型类，因为它不是面向对象的语言。例如，操作符的重载在 Scala 中是以不同的方式解决的。您可以在 Scala 中编写类型类的等效物，但这更像是一种模式而不是一种语言特性。在其他语言中，可以使用*traits*和*interfaces*来模拟 Haskell 类型类的一些特性。

在 Haskell 中，类型类是一组需要在给定类型上实现的函数。最简单的例子之一是`Eq`类型类。

```php
class Eq a where 
    (==) :: a -> a -> Bool 
    (/=) :: a -> a -> Bool 
```

任何实现`Eq`类的类型，都必须为`==`和`/=`操作符实现相应的实现，否则将出现编译错误。这与类的接口非常相似，但适用于类型而不是类。这意味着您可以强制创建操作符，就像我们的情况一样，而不仅仅是方法。

您可以相当容易地为您的类型类创建实例；这是`Maybe`实例的一个例子。

```php
instance (Eq m) => Eq (Maybe m) where 
    Just x == Just y = x == y 
    Nothing == Nothing = True 
    _ == _ = False 
```

这应该很容易理解。 左侧的两个`Just`值在其内部内容相等时是相等的，`Nothing`值等于自身，其他任何值都是不同的。 定义这些`Eq`实例允许您在 Haskell 代码中的任何地方检查两个单子的相等性。 实例定义本身只是强制要求存储在单子内的类型`m`变量也实现了`Eq`类型类。

正如您所看到的，类型类的函数并未在类型内部实现。 它是作为一个单独的实例来完成的。 这使您可以在代码的任何地方声明此实例。

甚至可以为任何给定类型拥有相同类型类的多个实例，并导入你需要的实例。 想象一下，例如，为整数有两个单子实例，一个是乘积，另一个是总和。 然而，这是不鼓励的，因为当导入两个实例时会导致冲突：

```php
Prelude> Just 2 == Just 2 
True 
Prelude> Just 2 == Just 3 
False 
Prelude> Just 2 == Nothing 
False 
```

### 注意

`Prelude>`是 Haskell REPL 中的提示符，您可以在其中简单地运行 Haskell 代码，就像在 CLI 上运行 PHP 时使用`-a`参数一样。

我们可能认为类型类只是接口，或者更确切地说是特征，因为它们也可以包含实现。 但是，如果我们仔细看看我们的类型类及其单子实现，至少有三个缺点，任何我们在 PHP 中所做的事情，至少在合理的范围内，都会有。

为了证明这一点，让我们想象我们创建了一个名为`Comparable`的 PHP 接口：

```php
<?php 
interface Comparable 
{ 
    /** 
     * @param Comparable $a the object to compare with 
     * @return int 
     *    0 if both object are equal 
     *    1 is $a is smaller 
     *    -1 otherwise 
     */ 
    public function compare(Comparable $a): int; 
} 
```

撇开 PHP 不允许像我们在 Haskell 中用`==`符号演示的那样进行运算符重载这一事实，试着想一想 Haskell 类型类允许的三个特性，这在 PHP 中几乎不可能模拟。

其中两个问题与强制正确类型有关。 Haskell 将自动为我们进行检查，但在 PHP 中，我们将不得不编写代码来检查我们的值是否是正确的类型。 第三个问题与可扩展性有关。 例如，考虑在外部库中声明的要比较的类。

第一个问题与`compare`函数期望与接口相同类型的值有关，这意味着如果您有两个不相关的类`A`和`B`，都实现了`Comparable`接口，您可以比较类`A`的实例与类`B`的实例而不会出现 PHP 的任何错误。 显然这是错误的，这迫使您首先检查两个值是否是相同类型，然后再进行比较。

当您有一个类层次结构时，情况变得更加棘手，因为您真的不知道要测试什么类型。 然而，Haskell 将自动获取两个值共享的第一个公共类型，并使用相关的比较器。

第二个问题更加复杂。 如果我们在任何类型的容器上实现`Comparable`接口，我们将需要在比较运行时检查包含的值是否也是可比较的。 在 Haskell 中，类型签名`(Eq m) => Eq (Maybe m)`已经为我们处理了这个问题，如果您尝试比较包含不可比较值的两个单子，将自动引发错误。

Haskell 类型系统还强制要求单子内的值是相同类型，这与我们之前发现的第一个问题有关。

最后，第三个问题可能是关于在外部库或 PHP 核心的类上实现`Comparable`接口的可能性。 由于 Haskell 类型类实例位于类本身之外，您可以随时为任何类型添加一个实例，无论是现有类型类还是您刚刚创建的新类型类。

您可以创建适配器或包装类来包围这些对象，但然后您将不得不执行某种装箱/拆箱操作，以将正确的类型传递给使用对象的各种方法，这远非愉快的体验。

Scala 是一种面向对象的语言，没有对类型类提供核心支持，可扩展性问题通过使用语言特性**隐式转换**巧妙地解决了。广义上来说，这个想法是你定义了从类型`A`到类型`B`的转换，当编译器发现一个方法期望一个`B`类的实例，但你传递了一个`A`类的实例时，它会寻找这个转换并在可用时应用它。

这样，你可以创建我们之前提出的适配器或包装器，但是不需要手动执行转换，Scala 编译器会为你处理，使整个过程完全透明。

最后，由于我们谈到了比较对象和重新定义运算符，目前有两个关于 PHP 的 RFC 提出了关于这两个主题的讨论：

+   [`wiki.php.net/rfc/operator-overloading`](https://wiki.php.net/rfc/operator-overloading)

+   [`wiki.php.net/rfc/comparable`](https://wiki.php.net/rfc/comparable)

然而，目前还没有关于类型类或隐式类型转换的 RFC，就像我们在 Scala 中看到的那样。

# 代数结构和范畴论

到目前为止，我们一直避免谈论数学。本节将试图以轻松的方式这样做，因为大多数函数概念都源于数学，我们已经讨论过的许多抽象都是从范畴论领域借鉴的想法。本节的内容可能会帮助你更好地理解本书的内容，但并不需要完全理解它们才能使用函数式编程。

在本节中，遇到数学术语时将对其进行定义。重要的不是你理解所有的细微差别，而是给你一个大致的概念。

函数式编程的根源是*λ演算*，或*λ-演算*。它是数理逻辑中的一个*图灵完备形式系统*，用于表达计算。将 lambda 这个术语用于闭包和匿名函数是来自于这个。你写的任何代码都可以转换为λ演算。

### 注意

当一个语言或系统可以用来模拟图灵机时，就被称为图灵完备。一个同义词是计算通用。所有主要的编程语言都是图灵完备的，这意味着你可以在 C、Java、PHP、Haskell、JavaScript 等任何一种语言中编写的任何东西也可以在其他任何一种语言中编写。一个形式系统由以下元素组成：

+   一组符号或关键词的有限集

+   定义一个有效语法的语法

+   一组公理，或者基本规则

+   一组推理规则，用于从公理中推导出其他规则

代数结构是在其上定义了一个或多个操作的集合，并且有一系列公理或法则。我们在前几章中学习的所有抽象都是代数结构：幺半群、函子、应用函子和单子。这很重要，因为当一个新问题被证明遵循与现有集合相同的规则时，以前理论化的任何东西都可以被重用。

### 注意

*集合是数学中的一个基本概念。它是一组不同对象的集合*。你可以决定将任何东西组合在一起并称之为集合，例如，数字 5、23 和 42 可以形成一个集合{5, 23, 42}。集合可以明确地定义，就像我们刚刚做的那样，也可以使用规则来定义，例如，所有正整数。

范畴论是研究两个或多个数学结构之间关系的领域。它以对象和箭头或**态射**的集合来形式化它们。态射将一个对象或一个类别转换为另一个。一个范畴具有两个属性：

+   能够**组合态射**以关联

+   一个从一个对象或类别到自身的**恒等态射**

集合是满足这两个属性的多个可能类别之一。类别、对象和态射的概念可以非常抽象。例如，你可以将类型、函数、函子或幺半群视为类别。只要这两个属性得到遵守，它们可以是有限的或无限的，并且持有各种对象。

如果你对这个主题感兴趣，并想了解更多数学方面的知识，我可以推荐 Eugenia Cheng 写的书《蛋糕、卡斯塔和范畴论：理解复杂数学的简单配方》。这本书非常易懂，不需要先前的数学知识，而且读起来很有趣。

纯函数和引用透明的整个概念来自于λ演算。类型系统，特别是 Hindley-Milner，深深植根于形式逻辑和范畴论中。态射的概念与函数的概念非常接近，而组合处于范畴论的中心，导致了在过去几年对函数式语言的大多数进展在某种程度上与这个数学领域相关。

## 从数学到计算机科学

正如我们刚刚看到的，范畴论是函数式世界中的一个重要基石。你不必了解它来编写函数式代码，但它绝对有助于你理解基本概念并推理最抽象的东西。此外，关于函数式编程甚至库的论文中使用的许多术语都直接来自范畴论。因此，如果你对它有良好的直觉，通常会更容易理解你所阅读的内容。

类别实际上是一个非常简单的概念。它只是一些对象和它们之间的箭头。如果你能够使用这些想法以图形方式表示某些东西，那么它很可能是正确的，并且将极大地帮助你理解发生了什么。例如，如果我们决定表示函数组合，我们最终会得到类似这样的东西：

![从数学到计算机科学](img/image_07_002.jpg)

在图中，我们的三个形状是整个类别或给定类别中的对象并不重要。然而，立即清楚的是，如果我们有两个态射`f`和`g`，如果我们按顺序应用它们或者应用组合版本，结果是相同的。函数可以在相同类型上工作，例如，我们从一个形状转换到另一个形状，或者三角形代表字符串，菱形代表字符，圆圈代表整数。这没有区别。

另一个例子是 applicative 的同态定律；`pure(f)->apply($x) == pure(f($x))`。如果我们将`pure`函数视为从一个类别到表示 applicative 可能对象的类别的态射，我们可以将这个定律可视化如下：

![从数学到计算机科学](img/image_07_003.jpg)

虚线箭头是`pure`函数，用于在 applicative 类别中移动`x`，`f`和`y`。当我们这样看时，这个定律显然是正确的。你觉得呢？顺便说一句，这两个图表都被称为**可交换图表**。在可交换图表中，每条具有相同起点和终点的路径在箭头之间使用组合时是等价的。

另外，你可以考虑每种类型都是一个类别，而态射是一个函数。你可以想象函数作为从一个类别中的对象到同一个类别或不同类别中的对象的态射。你可以通过更小的类别在更大的类别中表示类型和类别的层次结构。例如，整数和浮点数将是数值类别中的两个类别，并且它们在一些数字上重叠。

这可能不是最学术上正确的描述类型、函数和范畴论的方式，但这是一个容易理解的方式。它使得更容易将抽象概念（如函子或单子）与我们习惯的东西并行概念化。

你可以将更传统的函数可视化为对值本身的操作。例如，`strtoupper`函数是从`string`类别中的一个对象到同一类别中的另一个对象的态射，而`count`方法是从`array`类别中的一个对象到`integer`类别中的一个对象的态射。因此，这些都是从一个对象到另一个对象的箭头。

如果我们像在第二个图表中那样，从我们的基本类型中退后一步，我们可以想象函数作用于类型本身。例如，单子的`pure`函数接受某个类别，无论是类型还是函数，并将其提升到一个新的类别中，在这个类别中，所有对象现在都被包裹在单子的上下文中。

这个想法很有趣，因为你以前的任何箭头也可以被提升，并且将继续在它们的新上下文中产生相同的结果，正如我们刚刚可视化的*同态*法则所证明的那样。

这意味着，如果你在使用单子或任何抽象概念时遇到困难，只需在纸上使用类别、对象和箭头绘制操作，然后你可以通过删除或添加上下文将一切归结为其本质。

### 重要的数学术语

在阅读有关函数式编程时，你可能会遇到一些数学术语。它们被使用是因为它们让我们能够快速传达当前描述的结构是关于什么以及可以从中期望什么属性。

我们已经学习了一个这样的术语，那就是幺半群。你可以在数学定义中找到关于它的一个定义：*幺半群是一个在关联二进制操作下封闭并具有单位元素的集合*。在这一点上，你应该能够理解这个定义；然而，这里是一个关于字符串连接幺半群的快速概述：

+   集合是所有可能的字符串值

+   二进制操作是字符串连接运算符，`.`

+   单位元素是空字符串，`''`

集合在操作下封闭的概念表明给定操作的结果也是集合的一部分。例如，对两个整数进行加法运算总是会得到一个整数。

以下是你可能在阅读中遇到的各种数学术语的快速词汇表。

+   **关联性**：如果操作的顺序不重要，则操作是关联的；例如加法和乘法是 *a + (b + c) === (a + b) + c*。

+   **交换性**：如果你可以改变操作数的顺序，那么操作是可交换的。大多数关联操作也是可交换的，如 *a + b === b + a`*。一个不可交换的关联操作的例子是函数组合，如 *f (g h) === (f g) h*，但 *f g != g f*。

+   **分配性**：如果 *a * (b + c) == (a * b) + (a * c)*，则两个操作是分配的。在这种情况下，乘法是“分配于”加法。在这个例子中，***和*+*可以被任何二进制操作替换。

+   **半群**：在一个关联操作下封闭的集合。

+   **幺半群**：具有单位元素的半群。

+   **群**：具有逆元素的幺半群。逆元是一个值，你可以将其添加到另一个元素中以获得身份元素。例如，*10 + -10 = 0，-10*是整数加法群中 10 的逆元。

+   **阿贝尔群**：操作是可交换的群。

+   **环**：具有第二个幺半群操作的阿贝尔群，该操作对第一个操作具有分配性。例如，整数是一个环，其中加法是第一个操作，乘法是第二个操作。

+   **半环**：一个环，其中阿贝尔群被可交换的幺半群（即，逆元素不存在）所取代。

+   **余单子**、**余函子**、**余 XXX**：单子、函子或任何东西的对偶范畴。对偶的另一个词是相反的。如果一个单子是将某物放入上下文的一种方式，那么它的余单子将是从中取出的一种方式。这是一个非常模糊的定义，没有解释用途，这需要一个章节来解释。

## 幻想乡

既然我们已经讨论了理论，我想向你介绍一个描述常见代数结构接口的 JavaScript 项目，名为**Fantasy Land**，网址为[`github.com/fantasyland/fantasy-land`](https://github.com/fantasyland/fantasy-land)。

它已经被社区广泛采用，每天有越来越多的项目实现了这个提议的接口，以便更好地在这些代数结构的各种实现之间进行互操作。在幻想乡命名空间下，你可以找到我们之前发现的各种单子的实现，以及许多其他更高级的函数构造。值得注意的是，还有**Bilby**库([`bilby.brianmckenna.org/`](http://bilby.brianmckenna.org/))，它试图尽可能接近 Haskell 的哲学。

为什么我要谈论一个 JavaScript 库呢？因为`php-functional`库已经将幻想乡规范移植到了 PHP[`github.com/widmogrod/php-functional/tree/master/src/FantasyLand`](https://github.com/widmogrod/php-functional/tree/master/src/FantasyLand)。

我最希望其他项目以这些为基础，实现他们自己的函数代码，因为这将通过为开发人员提供更多可能使用的特性集，来增强 PHP 中的函数式编程。

在撰写本文时，有讨论要将幻想乡移植与库的其余部分分开，以便可以在不依赖其他一切的情况下使用。我希望在你阅读本文时，这项工作已经完成，我敦促你使用这套常见接口。

# 单子变换器

我们看到，如果你单独考虑每一个单子，它们已经是一个非常强大的想法。如果我告诉你，你可以将单子组合在一起，以便同时从它们的多个特性中受益，你会怎么想？例如，一个`Maybe`接口和一个`Writer`单子，可以告诉你为什么操作没有返回结果。

这正是单子变换器的意义所在。单子变换器在各个方面都类似于它所示范的单子，只是它不是一个独立的实体，而是修改另一个单子的行为。在某种程度上，我们可以想象这是在另一个单子的顶部添加一个新的单子层。当然，你可以将多个层堆叠在一起。

在 Haskell 中，大多数现有的单子都有对应的变换器。通常，它们的名称相同，只是后面加了一个`T`：`StateT`、`ReaderT`、`WriterT`。如果你要将一个变换器应用到恒等单子上，结果将具有与等效单子完全相同的特性，因为恒等单子只是一个简单的容器。

为了使其正确工作，`State`、`Reader`、`Writer`和其他 Haskell 单子实际上是具有两个实例的类型类；一个是变换器，另一个是传统单子。

我们将在这里结束我们的探索，因为我所知道的 PHP 中没有这个概念的实现；尝试自己做这件事将是相当困难的，至少需要一个完整的章节。

至少你已经听说过这个想法，谁知道，也许将来会有人创建一个库，为 PHP 添加单子变换器。

# 镜头

当一切都是不可变的时，修改数据可能会变得非常麻烦，特别是如果你有一些复杂的数据结构。比如，假设你有一个用户列表，每个用户都有与他们关联的帖子列表，你需要在其中一个帖子上做一些改变。由于你不能直接改变任何东西，你需要复制或重新创建一切来修改你的值。

就像我说的，很繁琐。但与大多数事物一样，镜头有一个漂亮干净的解决方案。想象一下您的镜头就像双筒望远镜的一部分；它让您可以轻松地聚焦在数据结构的一部分上。然后，您可以轻松地修改它，并获得一个全新的闪亮数据结构，其中您的数据已更改为您想要的任何内容。

镜头是一种查找函数，它让您可以在数据结构的当前深度获取特定字段。您可以从镜头中读取，它将返回指定的值。您也可以向镜头写入，它将返回您修改后的整个数据结构。

镜头真正伟大的地方在于，由于它们是函数，您可以将它们组合在一起，因此如果您想深入到第一级之下，可以将第二个查找函数与第一个组合。您还可以在其上添加第三、第四等查找。在每一步，您都可以获取或设置值（如果需要）。

由于它们是函数，您可以像使用其他函数一样使用它们，可以映射它们，将它们放入应用函子，将它们绑定到单子。突然之间，一个非常繁琐的操作可以利用您的语言的所有功能。

遗憾的是，由于 PHP 中不常见不可变数据结构，没有人花时间为其编写镜头库。此外，这种可能性的细节有些混乱，需要相当长的时间来解释。这就是为什么我们现在将其留在这里的原因。

如果您感兴趣，Haskell 的`lens`库有一个网页，上面有大量信息和很好的介绍，尽管有一个真正具有挑战性的视频，网址是[`lens.github.io/`](http://lens.github.io)。

# 总结

在本章中，我们涵盖了许多不同的主题。其中一些概念在 PHP 开发中会很有用，比如在递归时避免堆栈溢出、模式匹配、无点风格以及使用`const`关键字使您的代码更易于阅读。

其他一些主题纯粹是理论性的，在 PHP 中目前没有使用，这些想法只是为了让您能够更好地理解有关函数式编程的其他写作，比如单子变换器、函数式编程与范畴论之间的联系以及镜头。

最后，有些主题在日常编码中有一定用处，但在 PHP 中实践起来有些困难，因为支持不足。即使不完美，您现在也了解了类型类、类型签名和代数结构。

我相信您并没有因为本章中主题的不断变化而感到太过困扰，并且学到了一些有价值和有趣的东西。我也希望这些内容激发了您对这些主题的进一步学习的兴趣，也许尝试一种函数式语言，看看所有这些暗示的好处是什么。

在下一章中，我们将回到一个更实际的话题，首先讨论测试功能代码，其次学习一种称为基于属性的测试的方法论，这并不严格属于函数式编程，但最初是在 Haskell 中理论化的。
