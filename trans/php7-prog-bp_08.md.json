["```php\nDigit: '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9' \nNumber: Digit+ \n\n```", "```php\nDigit: '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9' \n**Integer: Digit+Decimal: Digit* '.' Digit+Number: Decimal | Integer**\n\n```", "```php\nDigit: '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9' \nInteger: '-'? Digit+ \nDecimal: '-'? Digit* '.' Digit+ \nNumber: Decimal | Integer \n\n```", "```php\nProduct: Number ('*' Number)* \n\n```", "```php\nProduct: Number (('*'|'/') Number)* \n\n```", "```php\nSum: Product (('+'|'-') Product)* \n\n```", "```php\nExpr: Sum \nValue: Number | '(' Expr ')' \n\n```", "```php\nProduct: Value ('*' Value)* \n\n```", "```php\nExpr: Sum \nSum: Product (('+' | '-') Product)* \nProduct: Value (('*' | '/') Value)* \nValue: Number | '(' Expr ')' \nNumber: (Decimal | Integer) \nDecimal: '-'? Digit* '.' Digit+ \nInteger: '-'? Digit+ \nDigit: '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9' \n\n```", "```php\n{ \n  \"name\": \"packt-php7/chp8-calculator\", \n  \"authors\": [{ \n    \"name\": \"Martin Helmich\", \n    \"email\": \"php7-book@martin-helmich.de\" \n  }], \n\n  \"require\": { \n    \"hafriedlander/php-peg\": \"dev-master\" \n  }, \n  \"autoload\": { \n    \"psr-4\": { \n      \"Packt\\\\Chp8\\\\DSL\": \"src/\" \n    }, \n    \"files\": [ \n      \"vendor/hafriedlander/php-peg/autoloader.php\" \n    ] \n  } \n} \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\Parser; \n\nuse hafriedlander\\Peg\\Parser\\Basic; \n\nclass Parser extends Basic \n{ \n    /*!* ExpressionLanguage \n\n    <Insert grammar here> \n\n    */ \n} \n\n```", "```php\n**$ php -d pcre.jit=0 vendor/hafriedlander/php-peg/cli.php \n    src/Parser/Parser.peg.inc > src/Parser/Parser.php**\n\n```", "```php\n/*!* ExpressionLanguage \n\n**Digit: /[0-9]/** \n**Integer: '-'? Digit+** \n**Decimal: '-'? Digit* '.' Digit+** \n**Number: Decimal | Integer** \n\n*/ \n\n```", "```php\nrequire_once 'vendor/autoload.php'; \n\nuse \\Packt\\Chp8\\DSL\\Parser\\Parser; \n\n$result1 = new (Parser('-143.25'))->match_Number(); \n$result2 = new (Parser('I am not a number'))->match_Number(); \n\nvar_dump($result1); \nvar_dump($result2); \n\n```", "```php\narray(3) { \n  '_matchrule' => \n  string(6) \"Number\" \n  'name' => \n  string(6) \"Number\" \n  'text' => \n  string(7) \"-143.25\" \n} \nbool(false) \n\n```", "```php\n/*!* ExpressionLanguage \n\nDigit: /[0-9]/ \nInteger: '-'? Digit+ \nDecimal: '-'? Digit* '.' Digit+ \nNumber: Decimal | Integer \n**Value: Number | '(' > Expr > ')'** \n**Product: Value (> ('*'|'/') > Value)*** \n**Sum: Product (> ('+'|'-') > Product)*** \n**Expr: Sum** \n\n*/ \n\n```", "```php\nvar_dump((new Parser('-143.25'))->match_Expr()); \nvar_dump((new Parser('12 + 3'))->match_Expr()); \nvar_dump((new Parser('1 + 2 * 3'))->match_Expr()); \nvar_dump((new Parser('(1 + 2) * 3'))->match_Expr()); \nvar_dump((new Parser('(1 + 2)) * 3'))->match_Expr()); \n\n```", "```php\narray(3) { \n  '_matchrule' => \n  string(4) \"Expr\" \n  'name' => \n  string(4) \"Expr\" \n  'text' => \n  string(7) \"(1 + 2)\" \n} \n\n```", "```php\nInteger: **value:('-'? Digit+)** \n **function value(array &$result, array $sub) {** \n **$result['value'] = (int) $sub['text'];** \n **}** \n\nDouble: **value:('-'? Digit* '.' Digit+)**\n **function value(array &$result, array $sub) {** \n **$result['value'] = (float) $sub['text'];** \n **}**\n\n```", "```php\nNumber: Decimal | Integer \n **function Decimal(array &$result, array $sub) {** \n **$result['value'] = $sub['value'];** \n **}** \n **function Integer(array &$result, array $sub) {** \n **$result['value'] = $sub['value'];** \n **}**\n\n```", "```php\nProduct: left:Value (operand:(> operator:('*'|'/') > right:Value))* \n\n```", "```php\nProduct: left:Value (operand:(> operator:('*'|'/') > right:Value))* \n **function left(array &$result, array $sub) {** \n **$result['value'] = $sub['value'];** \n **}** \n **function right(array &$result, array $sub) {** \n **$result['value'] = $sub['value'];** \n **}** \n **function operator(array &$result, array $sub) {** \n **$result['operator'] = $sub['text'];** \n **}** \n **function operand(array &$result, array $sub) {** \n **if ($sub['operator'] == '*') {** \n **$result['value'] *= $sub['value'];** \n **} else {** \n **$result['value'] /= $sub['value'];** \n **}** \n **}**\n\n```", "```php\nSum: left:Product (operand:(> operator:('+'|'-') > right:Product))* \n **function left(array &$result, array $sub) {** \n **$result['value'] = $sub['value'];** \n **}** \n **function right(array &$result, array $sub) {** \n **$result['value'] = $sub['value'];** \n **}** \n **function operator(array &$result, array $sub) {** \n **$result['operator'] = $sub['text'];** \n **}** \n **function operand(array &$result, array $sub) {** \n **if ($sub['operator'] == '+') {** \n **$result['value'] += $sub['value'];** \n **} else {** \n **$result['value'] -= $sub['value'];** \n **}** \n **}**\n\n```", "```php\nValue: Number | '(' > Expr > ')' \n **function Number(array &$result, array $sub) {** \n **$result['value'] = $sub['value'];** \n **}** \n **function Expr(array &$result, array $sub) {** \n **$result['value'] = $sub['value'];** \n **}** \nExpr: Sum \n **function Sum(array &$result, array $sub) {** \n **$result['value'] = $sub['value'];** \n **}**\n\n```", "```php\nvar_dump((new Parser('-143.25'))->match_Expr()['value']); \nvar_dump((new Parser('12 + 3'))->match_Expr()['value']); \nvar_dump((new Parser('1 + 2 * 3'))->match_Expr()['value']); \nvar_dump((new Parser('(1 + 2) * 3'))->match_Expr()['value']); \n\n```", "```php\ndouble(-143.25) \nint(15) \nint(7) \nint(9) \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\ninterface Expression \n{ \n    public function evaluate() \n} \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\nabstract class Number implements Expression \n{} \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\nclass Integer extends Number \n{ \n    private $value; \n\n    public function __construct(int $value) \n    { \n        $this->value = $value; \n    } \n\n    public function evaluate(): int \n    { \n        return $this->value; \n    } \n} \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\nclass Decimal extends Number \n{ \n    private $value; \n\n    public function __construct(float $value) \n    { \n        $this->value = $value; \n    } \n\n    public function evaluate(): float \n    { \n        return $this->value; \n    } \n} \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\nabstract class BinaryOperation implements Expression \n{ \n    protected $left; \n    protected $right; \n\n    public function __construct(Expression $left, Expression $right) \n    { \n        $this->left  = $left; \n        $this->right = $right; \n    } \n} \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\nclass Addition extends BinaryOperation \n{ \n    public function evaluate() \n    { \n **return $this->left->evaluate() + $this->right->evaluate();** \n    } \n} \n\n```", "```php\nInteger: value:('-'? Digit+) \n    function value(array &$result, array $sub) { \n **$result['node'] = new Integer((int) $sub['text']);** \n    } \n\nDecimal: value:('-'? Digit* '.' Digit+) \n    function value(array &$result, array $sub) { \n **$result['node']  = new Decimal((float) $sub['text']);** \n    } \n\nNumber: Decimal | Integer \n    function Decimal(&$result, $sub) { \n **$result['node']  = $sub['node'];** \n    } \n    function Integer(&$result, $sub) { \n **$result['node']  = $sub['node'];** \n    } \n\n```", "```php\nProduct: left:Value (operand:(> operator:('*'|'/') > right:Value))* \n    function left(array &$result, array $sub) { \n **$result['node']  = $sub['node'];** \n    } \n    function right(array &$result, array $sub) { \n **$result['node']  = $sub['node'];** \n    } \n    function operator(array &$result, array $sub) { \n **$result['operator'] = $sub['text'];** \n    } \n    function operand(array &$result, array $sub) { \n        if ($sub['operator'] == '*') { \n **$result['node'] = new Multiplication($result['node'], $sub['node']);** \n        } else { \n **$result['node'] = new Division($result['node'], $sub['node']);** \n        } \n    } \n\n```", "```php\nSum: left:Product (operand:(> operator:('+'|'-') > right:Product))* \n    function left(&$result, $sub) { \n **$result['node']  = $sub['node'];** \n    } \n    function right(&$result, $sub) { \n **$result['node']  = $sub['node'];** \n    } \n    function operator(&$result, $sub) { $result['operator'] = $sub['text']; } \n    function operand(&$result, $sub) { \n        if ($sub['operator'] == '+') { \n **$result['node'] = new Addition($result['node'], $sub['node']);** \n        } else { \n **$result['node'] = new Subtraction($result['node'], $sub['node']);** \n        } \n    } \n\n```", "```php\nValue: Number | '(' > Expr > ')' \n    function Number(array &$result, array $sub) { \n **$result['node'] = $sub['node'];** \n    } \n\nExpr: Sum \n    function Sum(array &$result, array $sub) { \n **$result['node'] = $sub['node'];** \n    } \n\n```", "```php\n$astRoot = (new Parser('1 + 2 * 3'))->match_Expr()['node']; \nvar_dump($astRoot, $astRoot->evaluate()); \n\n$astRoot = (new Parser('(1 + 2) * 3'))->match_Expr()['node']; \nvar_dump($astRoot, $astRoot->evaluate()); \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\ExpressionBuilder; \n\nuse Packt\\Chp8\\DSL\\AST\\Expression; \nuse Packt\\Chp8\\DSL\\Exception\\ParsingException; \nuse Packt\\Chp8\\DSL\\Parser\\Parser; \n\nclass ExpressionBuilder \n{ \n    public function parseExpression(string $expr): Expression \n    { \n        $parser = new Parser($expr); \n        $result = $parser->match_Expr(); \n\n        if ($result === false || $result['text'] !== $expr) { \n            throw new ParsingException(); \n        } \n\n        return $result['node']; \n    } \n} \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\Exception; \n\nclass ParsingException extends \\Exception \n{} \n\n```", "```php\n$builder = new \\Packt\\Chp8\\DSL\\ExpressionBuilder; \n\nvar_dump($builder->parseExpression('12 + 3')->evaluate()); \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\ninterface Expression \n{ \n **public function evaluate(array $variables = []);** \n} \n\n```", "```php\nclass Integer \n{ \n    // ... \n **public function evaluate(array $variables = []): int** \n    { \n        return $this->value; \n    } \n} \n\n```", "```php\nclass Addition \n{ \n **public function evaluate(array $variables = [])** \n    { \n **return $this->left->evaluate($variables)** \n **+ $this->right->evaluate($variables);** \n    } \n} \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\nuse Packt\\Chp8\\DSL\\Exception\\UndefinedVariableException; \n\nclass Variable implements Expression \n{ \n    private $name; \n\n    public function __construct(string $name) \n    { \n        $this->name = $name; \n    } \n\n    public function evaluate(array $variables = []) \n    { \n        if (isset($variables[$this->name])) { \n            return $variables[$this->name]; \n        } \n        throw new UndefinedVariableException($this->name); \n    } \n} \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\Exception; \n\nclass UndefinedVariableException extends \\Exception \n{ \n    private $name; \n\n    public function __construct(string $name) \n    { \n        parent::__construct('Undefined variable: ' . $name); \n        $this->name = $name; \n    } \n} \n\n```", "```php\nName: /[a-zA-z]+/ \nVariable: Name \n    function Name(&$result, $sub) { \n        $result['node'] = new Variable($sub['name']); \n    } \n\n```", "```php\n**Value: Number | Variable | '(' > Expr > ')'** \n    function Number(array &$result, $sub) { \n        $result['node'] = $sub['node']; \n    } \n **function Variable(array &$result, $sub) {** \n **$result['node'] = $sub['node'];** \n **}** \n    function Expr(array &$result, $sub) { \n        $result['node'] = $sub['node']; \n    } \n\n```", "```php\n$expr = $builder->parseExpression('1 + 2 * a'); \nvar_dump($expr->evaluate(['a' => 1])); \nvar_dump($expr->evaluate(['a' => 14])); \nvar_dump($expr->evaluate(['a' => -1])); \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\nclass Equals extends BinaryOperation \n{ \n    public function evaluate(array $variables = []) \n    { \n        return $this->left->evaluate($variables) \n            == $this->right->evaluate($variables); \n    } \n} \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\n**class NotEquals extends BinaryOperation** \n{ \n    public function evaluate(array $variables = []) \n    { \n **return $this->left->evaluate($variables)** \n **!= $this->right->evaluate($variables);** \n    } \n} \n\n```", "```php\nValue: Number | Variable | '(' > **NumExpr** > ')' \n    function Number(array &$result, array $sub) { \n        $result['node'] = $sub['node']; \n    } \n    function Variable(array &$result, array $sub) { \n        $result['node'] = $sub['node']; \n    } \n **function NumExpr(array &$result, array $sub) {** \n        $result['node'] = $sub['node']; \n    } \n\n```", "```php\n**NumExpr**: Sum \n    function Sum(array &$result, array $sub) { \n        $result['node'] = $sub['node']; \n    } \n\n```", "```php\nComparisonOperator: '=' | '|=' \nComparison: left:NumExpr (operand:(> op:ComparisonOperator > right:NumExpr)) \n    function left(&$result, $sub) { \n        $result['leftNode'] = $sub['node']; \n    } \n    function right(array &$result, array $sub) { \n        $result['node'] = $sub['node']; \n    } \n    function op(array &$result, array $sub) { \n        $result['op'] = $sub['text']; \n    } \n    function operand(&$result, $sub) { \n        if ($sub['op'] == '=') { \n            $result['node'] = new Equals($result['leftNode'], $sub['node']); \n        } else { \n            $result['node'] = new NotEquals($result['leftNode'], $sub['node']); \n        } \n    } \n\n```", "```php\nBoolExpr: Comparison \n    function Comparison(array &$result, array $sub) { \n        $result['node'] = $sub['node']; \n    } \n\nExpr: BoolExpr | NumExpr \n    function BoolExpr(array &$result, array $sub) { \n        $result['node'] = $sub['node']; \n    } \n    function NumExpr(array &$result, array $sub) { \n        $result['node'] = $sub['node']; \n    } \n\n```", "```php\n$expr = $builder->parseExpression('1 = 2'); \nvar_dump($expr->evaluate()); \n\n$expr = $builder->parseExpression('a * 2 = 6'); \nvar_dump($expr->evaluate(['a' => 3]); \nvar_dump($expr->evaluate(['a' => 4]); \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\nclass LogicalAnd extends BinaryOperation \n{ \n    public function evaluate(array $variables=[]) \n    { \n        return $this->left->evaluate($variables) \n            && $this->right->evaluate($variables); \n    } \n} \n\n```", "```php\nBoolValue: Comparison | '(' > BoolExpr > ')' \n    function Comparison(array &$res, array $sub) { \n        $res['node'] = $sub['node']; \n    } \n    function BoolExpr(array &$res, array $sub) { \n        $res['node'] = $sub['node']; \n    } \n\n```", "```php\nAnd: left:BoolValue (> \"and\" > right:BoolValue)* \n    function left(array &$res, array $sub) { \n        $res['node'] = $sub['node']; \n    } \n    function right(array &$res, array $sub) { \n        $res['node'] = new LogicalAnd($res['node'], $sub['node']); \n    } \n\nOr: left:And (> \"or\" > right:And)* \n    function left(array &$res, array $sub) { \n        $res['node'] = $sub['node']; \n    } \n    function right(array &$res, array $sub) { \n        $res['node'] = new LogicalOr($res['node'], $sub['node']); \n    } \n\n```", "```php\nBoolExpr: Or | Comparison \n **function Or(array &$result, array $sub) {** \n **$result['node'] = $sub['node'];** \n **}** \n    function Comparison(array &$result, array $sub) { \n        $result['node'] = $sub['node']; \n    } \n\n```", "```php\n$expr = $builder->parseExpression('a=1 or b=2 and c=3'); \nvar_dump($expr->evaluate([ \n    'a' => 0, \n    'b' => 2, \n    'c' => 3 \n]); \n\n```", "```php\n($b > 0) ? 1 : 2; \n\n```", "```php\n<?php \nnamespace Packt\\Chp8\\DSL\\AST; \n\nclass Condition implements Expression \n{ \n    private $when; \n    private $then; \n    private $else; \n\n    public function __construct(Expression $when, Expression $then, Expression $else) \n    { \n        $this->when = $when; \n        $this->then = $then; \n        $this->else = $else; \n    } \n\n    public function evaluate(array $variables = []) \n    { \n        if ($this->when->evaluate($variables)) { \n            return $this->then->evaluate($variables); \n        } \n        return $this->else->evaluate($variables); \n    } \n} \n\n```", "```php\nCondition: \"when\" > when:BoolExpr > \"then\" > then:Expr > \"else\" > else:Expr \n    function when(array &$res, array $sub) { \n        $res['when'] = $sub['node']; \n    } \n    function then(array &$res, $sub) { \n        $res['then'] = $sub['node']; \n    } \n    function else(array &$res, array $sub) { \n        $res['node'] = new Condition($res['when'], $res['then'], $sub['node']); \n    } \n\n```", "```php\nBoolExpr: **Condition |** Or | Comparison \n **function Condition(array &$result, array $sub) {** \n **$result['node'] = $sub['node'];** \n **}** \n    function Or(&$result, $sub) { \n        $result['node'] = $sub['node']; \n    } \n    function Comparison(&$result, $sub) { \n        $result['node'] = $sub['node']; \n    } \n\n```", "```php\n$expr = $builder->parseExpression('when a=1 then 3.14 else a*2'); \nvar_dump($expr->evaluate(['a' => 1]); \nvar_dump($expr->evaluate(['a' => 2]); \nvar_dump($expr->evaluate(['a' => 3]); \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\nuse Packt\\Chp8\\DSL\\Exception\\UnknownVariableException; \n\n**class NamedVariable implements Variable** \n{ \n    private $name; \n\n    public function __construct(string $name) \n    { \n        $this->name = $name; \n    } \n\n    public function evaluate(array $variables = []) \n    { \n        if (isset($variables[$this->name])) { \n            return $variables[$this->name]; \n        } \n        throw new UnknownVariableException(); \n    } \n} \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\ninterface Variable extends Expression \n{ \n} \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\nclass PropertyFetch implements Variable \n{ \n    private $left; \n    private $property; \n\n    public function __construct(Variable $left, string $property) \n    { \n        $this->left = $left; \n        $this->property = $property; \n    } \n\n    public function evaluate(array $variables = []) \n    { \n        $var = $this->left->evaluate($variables); \n        return $var[$this->property] ?? null; \n    } \n} \n\n```", "```php\nVariable: Name **('.' property:Name)*** \n    function Name(array &$result, array $sub) { \n        $result['node'] = new NamedVariable($sub['text']); \n    } \n **function property(&$result, $sub) {** \n **$result['node'] = new PropertyFetch($result['node'], $sub['text']);** \n **}**\n\n```", "```php\n$e = $builder->parseExpression('foo.bar * 2'); \nvar_dump($e->evaluate(['foo' => ['bar' => 2]])); \n\n```", "```php\npublic function evaluate(array $variables = []) \n{ \n    $var = $this->left->evaluate($variables); \n **if (is_object($var)) {** \n **$getterMethodName = 'get' . ucfirst($this->property);** \n **if (is_callable([$var, $getterMethodName])) {** \n **return $var->{$getterMethodName}();** \n **}**\n **$isMethodName = 'is' . ucfirst($this->property);** \n **if (is_callable([$var, $isMethodName])) {** \n **return $var->{$isMethodName}();** \n **}** \n **return $var->{$this->property} ?? null;** \n **}** return $var[$this->property] ?? null; \n} \n\n```", "```php\nuse Packt\\Chp8\\DSL\\AST\\Expression; \n\n$cachedExpr = new class implements Expression \n{ \n    public function evaluate(array $variables=[]) \n    { \n        return 2 + (3 * $variables['a']); \n    } \n} \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\ninterface Expression \n{ \n    public function evaluate(array $variables = []); \n\n **public function compile(): string;** \n} \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\nabstract class Number implements Expression \n{ \n **public function compile(): string** \n **{** \n **return var_export($this->evaluate(), true);** \n **}** \n} \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\nclass Addition extends BinaryOperation \n{ \n    // ... \n\n **public function compile(): string** \n **{** \n **return '(' . $this->left->compile() . ') + (' . $this->right->compile() . ')';** \n **}** \n} \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\nclass Condition implements Expression \n{ \n    // ... \n\n **public function compile(): string** \n **{** \n **return sprintf('%s ? (%s) : (%s)',\n             $this->when->compile(),** \n **$this->then->compile(),** \n **$this->else->compile()** \n **);** \n **}** \n} \n\n```", "```php\nnamespace Packt\\Chp8\\DSL\\AST; \n\nuse Packt\\Chp8\\DSL\\Exception\\UnknownVariableException; \n\nclass NamedVariable implements Variable \n{ \n    // ... \n\n    public function evaluate(array $variables = []) \n    { \n        if (isset($variables[$this->name])) { \n            return $variables[$this->name]; \n        } \n        throw new UnknownVariableException(); \n    } \n\n    public function compile(): string \n    { \n        return sprintf('(new %s(%s))->evaluate($variables)', \n            __CLASS__, \n            var_export($this->name, true) \n        ); \n    } \n} \n\n```", "```php\n(new \\Packt\\Chp8\\DSL\\AST\\NamedVariable('a'))->evaluate($variables) * 3 \n\n```", "```php\nis_object((new \\Packt\\Chp8\\DSL\\AST\\NamedVariable('foo'))->evaluate($variables)) ? ((is_callable([(new \\Packt\\Chp8\\DSL\\AST\\NamedVariable('foo'))->evaluate($variables), 'getBar']) ? (new \\Packt\\Chp8\\DSL\\AST\\NamedVariable('a'))->evaluate($variables)->getBar() : ((is_callable([(new \\Packt\\Chp8\\DSL\\AST\\NamedVariable('foo'))->evaluate($variables), 'isBar']) ? (new \\Packt\\Chp8\\DSL\\AST\\NamedVariable('a'))->evaluate($variables)->isBar() : (new \\Packt\\Chp8\\DSL\\AST\\NamedVariable('a'))->evaluate($variables)['bar'] ?? null)) : (new \\Packt\\Chp8\\DSL\\AST\\NamedVariable('foo'))->evaluate($variables)['bar'] \n\n```", "```php\n<?php \nnamespace Packt\\Chp8\\DSL\\AST; \n\nclass PropertyFetch implements Variable \n{ \n    private $left; \n    private $property; \n\n    public function __construct(Variable $left, string $property) \n    { \n        $this->left = $left; \n        $this->property = $property; \n    } \n\n    public function evaluate(array $variables = []) \n    { \n        $var = $this->left->evaluate($variables); \n **return static::evaluateStatic($var, $this->property);** \n    } \n\n **public static function evaluateStatic($var, string $property)** \n **{** \n **if (is_object($var)) {** \n **$getterMethodName = 'get' . ucfirst($property);** \n **if (is_callable([$var, $getterMethodName])) {** \n **return $var->{$getterMethodName}();** \n **}** \n **$isMethodName = 'is' . ucfirst($property);** \n **if (is_callable([$var, $isMethodName])) {** \n **return $var->{$isMethodName}();** \n **}** \n **return $var->{$property} ?? null;** \n **}** \n **return $var[$property] ?? null;** \n **}** \n **public function compile(): string** \n **{** \n **return __CLASS__ . '::evaluateStatic(' . $this->left->compile() . ', ' . var_export($this->property, true) . ')';** \n **}** \n} \n\n```", "```php\n\\Packt\\Chp8\\DSL\\AST\\PropertyFetch::evaluateStatic( \n    (new \\Packt\\Chp8\\DSL\\AST\\NamedVariable('foo'))->evaluate($variables), \n    'bar' \n) \n\n```", "```php\n<?php \nnamespace Packt\\Chp8\\DSL; \n\nclass CompilingExpressionBuilder \n{ \n    /** @var string */ \n    private $cacheDir; \n    /** \n     * @var ExpressionBuilder \n     */ \n    private $inner; \n\n    public function __construct(ExpressionBuilder $inner, string $cacheDir) \n    { \n        $this->cacheDir = $cacheDir; \n        $this->inner = $inner; \n    } \n} \n\n```", "```php\npublic function parseExpression(string $expr): Expression \n{ \n    $cacheKey = sha1($expr); \n    $cacheFile = $this->cacheDir . '/' . $cacheKey . '.php'; \n    if (file_exists($cacheFile)) { \n        return include($cacheFile); \n    } \n\n    $expr = $this->inner->parseExpression($expr); \n\n    if (!is_dir($this->cacheDir)) { \n        mkdir($this->cacheDir, 0755, true); \n    } \n\n    file_put_contents($cacheFile, '<?php return new class implements '.Expression::class.' { \n        public function evaluate(array $variables=[]) { \n            return ' . $expr->compile() . '; \n        } \n\n        public function compile(): string { \n            return ' . var_export($expr->compile(), true) . '; \n        } \n    };'); \n    return $expr; \n} \n\n```", "```php\n$cacheKey = sha1($expr); \n$cacheFile = $this->cacheDir . '/' . $cacheKey; \nif (file_exists($cacheFile)) { \n    return include($cacheFile); \n} \n\n```", "```php\n<?php \nreturn new class implements Packt\\Chp8\\DSL\\AST\\Expression \n{ \n    public function evaluate(array $variables = []) \n    { \n        return (Packt\\Chp8\\DSL\\AST\\PropertyFetch::evaluateStatic( \n            (new Packt\\Chp8\\DSL\\AST\\NamedVariable('foo'))->evaluate($variables), \n            'bar' \n        )) * (3); \n    } \n\n    public function compile(): string \n    { \n        return '(Packt\\\\Chp8\\\\DSL\\\\AST\\\\PropertyFetch::evaluateStatic((new Packt\\\\Chp8\\\\DSL\\\\AST\\\\NamedVariable('foo'))->evaluate($variables), 'bar'))*(3)'; \n    } \n}; \n\n```", "```php\n**$ composer require phpbench/phpbench**\n\n```", "```php\nrequire 'vendor/autoload.php'; \n\nuse Packt\\Chp8\\DSL\\ExpressionBuilder; \nuse Packt\\Chp8\\DSL\\CompilingExpressionBuilder; \n\nclass ParserBenchmark \n{ \n    public function benchSimpleExpressionWithBasicParser() \n    { \n        $builder = new ExpressionBuilder(); \n        $builder->parseExpression('a = 2')->evaluate(['a' => 1]); \n    } \n} \n\n```", "```php\n**vendor/bin/phpbench run bench.php --report default**\n\n```", "```php\n/** \n * @Revs(5000) \n */ \nclass ParserBenchmark \n{ \n    // ... \n} \n\n```", "```php\n/** \n * @Revs(5000) \n */ \nclass ParserBenchmark \n{ \n    public function benchSimpleExpressionWithBasicParser() \n    { \n        $builder = new ExpressionBuilder(); \n        $builder->parseExpression('a = 2')->evaluate(['a' => 1]); \n    } \n\n    public function benchSimpleExpressionWithCompilingParser() \n    { \n        $builder = new CompilingExpressionBuilder(); \n        $builder->parseExpression('a = 2')->evaluate(['a' => 1]); \n    } \n} \n\n```", "```php\npublic function benchComplexExpressionBasicParser() \n{ \n    $builder = new ExpressionBuilder(); \n    $builder \n        ->parseExpression('when (customer.age = 1 and cart.value = 200) then cart.value * 0.1 else cart.value * 0.2') \n        ->evaluate(['customer' => ['age' => 1], 'cart' => ['value' => 200]]); \n} \n\npublic function benchComplexExpressionCompilingParser() \n{ \n    $builder = new CompilingExpressionBuilder(new ExpressionBuilder(), 'cache/auto'); \n    $builder \n        ->parseExpression('when (customer.age = 1 and cart.value = 200) then cart.value * 0.1 else cart.value * 0.2') \n        ->evaluate(['customer' => ['age' => 1], 'cart' => ['value' => 200]]); \n} \n\n```"]