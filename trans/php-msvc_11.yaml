- en: Chapter 11. Best Practices and Conventions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。最佳实践和约定
- en: This chapter will teach you to stand out among the rest of the developers. This
    is possible by developing and executing the strategies learned in this book with
    style, and by following concrete standards.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章将教你在其他开发人员中脱颖而出。这是通过以风格开发和执行本书中学到的策略，并遵循具体的标准来实现的。
- en: Code versioning best practices
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码版本控制最佳实践
- en: Over time, your application will evolve and, at some point, you will be at the
    point where you are wondering what you will do with the API of any of your microservices.
    You can keep the changes to a minimum and be transparent to the users of your
    API, or you can create different versions of your code. The best solution is versioning
    your code (API).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，你的应用程序将不断发展，最终你会想知道你将如何处理任何微服务的API。你可以尽量减少更改并对你的API的用户透明，或者你可以创建不同版本的代码。最佳解决方案是对你的代码（API）进行版本控制。
- en: 'The well-known and commonly used ways for code versioning are as listed:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 代码版本控制的众所周知和常用的方式如下：
- en: '**URL**: In this method, you add the version of your API inside the URL of
    the requests. For example, the `https://phpmicroservices.com/api/v2/user` URL
    indicates that we are using the `v2` of our API. We used this method in our examples
    throughout the book.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL**：在这种方法中，你在请求的URL中添加API的版本。例如，`https://phpmicroservices.com/api/v2/user`的URL表示我们正在使用我们API的`v2`。我们在本书中的示例中使用了这种方法。'
- en: '**Custom request header**: In this method, we do not specify the version in
    our URL. Instead, we use HTTP headers to specify the version we want to use. For
    instance, we can do a HTTP call to `https://phpmicroservices.com/api/user`, but
    with an extra header, `"api-version: 2"`. In this case, our server will check
    the HTTP header and use the `v2` of our API.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义请求头**：在这种方法中，我们不在URL中指定版本。相反，我们使用HTTP头来指定我们想要使用的版本。例如，我们可以对`https://phpmicroservices.com/api/user`进行HTTP调用，但附加一个额外的头部`"api-version:
    2"`。在这种情况下，我们的服务器将检查HTTP头并使用我们API的`v2`。'
- en: '**Accept header**: This method is very similar to the previous one, but instead
    of using a custom header, we will use the `Accept` header. For our example, we
    will make a call to `https://phpmicroservices.com/api/user` but our Accept header
    will be `"Accept: application/vnd.phpmicroservices.v2+json"`. In this case, we
    are indicating that we want version 2 and the data will be on JSON.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接受头**：这种方法与前一种方法非常相似，但是我们将使用`Accept`头而不是自定义头。例如，我们将对`https://phpmicroservices.com/api/user`进行调用，但我们的Accept头将是`"Accept:
    application/vnd.phpmicroservices.v2+json"`。在这种情况下，我们指示我们想要版本2，并且数据将以JSON格式呈现。'
- en: As you can imagine, the easiest way to implement versioning in your code is
    with the version code inside your URL but, unfortunately, that is not considered
    the best option. What most developers consider the best way of versioning your
    code is to use HTTP headers to specify the version you want to use. Our recommendation
    is to use the method that suits your project best. Analyze who will use your APIs
    and how, and you will discover the versioning method you need to use.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以想象的那样，在你的代码中实现版本控制的最简单方法是在URL中使用版本代码，但不幸的是，这并不被认为是最佳选项。大多数开发人员认为最佳的代码版本控制方式是使用HTTP头来指定你想要使用的版本。我们建议使用最适合你的项目的方法。分析谁将使用你的API以及如何使用，你将发现你需要使用的版本控制方法。
- en: Caching best practices
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存最佳实践
- en: A cache is a place where you can store temporal data; it is used to increase
    the performance of the applications. Here, you can find some small tips to help
    you with your cache.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是一个可以存储临时数据的地方；它用于提高应用程序的性能。在这里，你可以找到一些小贴士来帮助你处理缓存。
- en: Performance impact
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能影响
- en: Adding a cache layer to your application always has a performance impact that
    you need to measure. It does not matter where you are adding the cache layer in
    your application. You need to measure the impact to know if the new cache layer
    is a good choice. First, make some metrics without the cache layer and, as soon
    as you have some stats, enable the cache layer and compare the result. Sometimes
    you can find that the benefit of a cache layer becomes a hell of management to
    keep the cache running. You can use some of the monitoring services we talked
    about in the previous chapters to monitor the performance impact.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 向你的应用程序添加缓存层总是会产生性能影响，你需要进行测量。无论你在应用程序的哪个位置添加缓存层，你都需要测量影响，以了解新的缓存层是否是一个好选择。首先，在没有缓存层的情况下进行一些度量，一旦你有了一些统计数据，启用缓存层并进行比较。有时你会发现，缓存层的好处变成了一个管理上的困扰。你可以使用我们在前几章中谈到的一些监控服务来监控性能影响。
- en: Handle cache misses
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理缓存未命中
- en: A cache miss is when a request is not saved in your cache and the application
    needs to get the data from your service/application. Ensure that your code can
    handle cache misses and the consequent updates. To keep track of the rate of missing
    cache hits, you can use any monitoring software or even a logging system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存未命中是指请求未保存在缓存中，应用程序需要从服务/应用程序中获取数据。确保你的代码可以处理缓存未命中和随之而来的更新。为了跟踪缺失缓存命中率，你可以使用任何监控软件或甚至日志系统。
- en: Group requests
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分组请求
- en: Whenever possible, try to group your cache requests as much as possible. Imagine
    that your frontend needs five different elements from your cache server to render
    a page. Instead of doing five calls, you can try to group the requests, saving
    you some time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地尝试将你的缓存请求分组。想象一下，你的前端需要从缓存服务器中获取五个不同的元素来渲染一个页面。你可以尝试将请求分组，而不是进行五次调用，从而节省时间。
- en: 'Imagine that you are using Redis as your cache layer and want to save some
    values in the `foo` and `bar` variables. Take a look at the following code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在使用Redis作为缓存层，并希望将一些值保存在`foo`和`bar`变量中。看一下以下代码：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Instead of doing that, you can do both the sets in a single transaction:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是这样做，你可以在一个事务中完成两个集合：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding example will do both the sets in one commit, saving you some time
    and improving the performance of your application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将在一个提交中完成两个集合，节省时间并提高应用程序的性能。
- en: Size of elements to be stored in cache
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存中存储的元素大小
- en: It is more efficient to store large items in your cache than storing small items.
    If you start caching loads of small items, the overall performance will decrease.
    In this case, the serialization size, time, cache commit time, and capacity usage
    will grow.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将大型项目存储在缓存中比存储小型项目更有效。如果你开始缓存大量小项目，整体性能将会降低。在这种情况下，序列化大小、时间、缓存提交时间和容量使用将会增加。
- en: Monitor your cache
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控你的缓存
- en: If you have decided to add a cache layer, at least keep it monitorized. Keeping
    some stats of your cache will help you know how well it is doing (the cache hit
    ratio) or if it is reaching its capacity limit. Most of the cache software is
    stable and robust, but it does not mean that you will not have any problems if
    you keep it unmanaged.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定添加一个缓存层，至少要监控它。保持一些关于你的缓存的统计数据将有助于你了解它的表现如何（缓存命中率），或者它是否达到了容量限制。大多数缓存软件都是稳定而强大的，但这并不意味着如果你不加管理就不会遇到任何问题。
- en: Choose your cache algorithm carefully
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细选择你的缓存算法
- en: Most of the cache engines support different algorithms. Each algorithm has its
    benefits and its own problems. Our recommendation is to analyze your requirements
    deeply and not use the default mode of the cache engine of your choice until you
    are sure that it's the correct algorithm for your use case.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数缓存引擎支持不同的算法。每种算法都有其优点和问题。我们建议你深入分析你的需求，并在确定它是你用例的正确算法之前，不要使用你选择的缓存引擎的默认模式。
- en: Performance best practices
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能最佳实践
- en: 'If you are reading this book, it is probably because you are interested in
    web development and, in the last few years, the importance of the performance
    of web applications (such as APIs) is becoming more and more relevant. Here are some
    stats to give you an idea:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书，很可能是因为你对Web开发感兴趣，而在过去几年中，Web应用程序（如API）的性能变得越来越重要。以下是一些统计数据，以便让你有一个概念：
- en: Amazon reported years ago that for every 100 ms of increase in the loading time,
    their sales decreased by 1%.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊多年前报告称，每增加100毫秒的加载时间，他们的销售额就会减少1%。
- en: Google found that reducing the size of the page from 100 KB to 80 KB diminished
    their traffic by 25%.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌发现，将页面大小从100 KB减少到80 KB会使他们的流量减少25%。
- en: 57% of online consumers will abandon a site after waiting for 3 seconds for
    a page to load.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 57%的在线消费者在等待页面加载3秒后会放弃一个网站。
- en: 80% of the people who abandoned the site will not return. About a 50% of these
    people will tell others their negative experience.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 80%的放弃网站的人不会回来。大约50%的这些人会告诉其他人他们的负面经历。
- en: As you can see, the performance of your app can impact your users and even your
    revenues. In this section, we will give you some tips to improve the overall performance
    of your web application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你的应用程序的性能可能会影响你的用户甚至你的收入。在本节中，我们将为你提供一些改善Web应用程序整体性能的建议。
- en: Minimize HTTP requests
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化HTTP请求
- en: Each HTTP request has a payload. For this reason, an easy way to increase the
    performance is to reduce the number of HTTP requests. You need to have this idea
    in mind in every aspect of your development. Try to do the minimum external calls
    to other services in your APIs/backends. In your frontends, you can combine files
    to attend to only one request. You only need to have a balance between the number
    of requests and the size of each request.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP请求都有一个有效负载。因此，提高性能的一种简单方法是减少HTTP请求的数量。你需要在开发的每个方面都牢记这个想法。尽量减少APIs/后端中对其他服务的最小外部调用。在前端，你可以合并文件以满足只有一个请求。你只需要在请求的数量和每个请求的大小之间取得平衡。
- en: Imagine that your frontend has its CSS split in several different files; instead
    of loading each one every time, you can combine them into a single or a few files.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的前端的CSS被分成了几个不同的文件；而不是每次加载一个文件，你可以将它们合并成一个或几个文件。
- en: Another quick and small change you can do with HTTP requests is to try to avoid
    `@import` functions in your CSS files. Using link tags instead of `@import` functions
    will allow your browser to download the CSS file in parallel.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过HTTP请求进行另一个快速而小的更改，那就是尽量避免在你的CSS文件中使用`@import`函数。使用链接标签而不是`@import`函数将允许你的浏览器并行下载CSS文件。
- en: Minimize HTML, CSS, and JavaScript
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化HTML、CSS和JavaScript
- en: As developers, we try to code in a format that is easier for us to read--a human-friendly
    format. By developing this way, we are increasing the size of our plain text files
    with unnecessary characters. Unnecessary characters can include white space, comments,
    and newline characters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，我们试图以对我们来说更容易阅读的格式编写代码--一种人类友好的格式。通过这种方式开发，我们增加了我们的纯文本文件的大小，其中包括不必要的字符。不必要的字符可能包括空格、注释和换行符。
- en: We are not saying that you need to write obfuscated code, but as soon as you
    have everything ready, why don't you remove the inessential characters?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不是说你需要编写混淆的代码，但是一旦你准备好了一切，为什么不删除不必要的字符呢？
- en: 'Imagine that the content of one of your JavaScript file (`myapp.js`) is as
    follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的一个JavaScript文件（`myapp.js`）的内容如下：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After the minimization, your code can be saved to a different file (`myapp.min.js`)
    and it can look as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小化之后，你的代码可以保存到一个不同的文件（`myapp.min.js`），它可能如下所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the new code, we reduced the size of the file around 60%, a huge saving.
    Note that our repository will have both versions of the file: the human-friendly
    to make our changes, and the minimized one, which we will load in our frontend.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的代码中，我们将文件大小减少了大约60%，节省了大量空间。请注意，我们的存储库将同时拥有文件的两个版本：人类可读的版本用于进行更改，以及我们将在前端加载的最小化版本。
- en: You can do the minimization with online tools, or you can integrate tools such
    as `gulp` or `grunt` in your pipeline. When you have set up these tools, they
    will track the changes of some specific files (CSS, JS, and others) and as soon
    as you save your changes to any of these files, the tool will minimize the content.
    Another hidden benefit of using tools for the minification is that most of them
    also check the code or rename your variables to keep them even smaller.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用在线工具进行最小化，或者您可以将`gulp`或`grunt`等工具集成到您的流程中。设置这些工具后，它们将跟踪某些特定文件（CSS、JS和其他文件）的更改，一旦您对这些文件中的任何一个进行保存，工具将最小化内容。使用最小化工具的另一个隐藏的好处是，大多数工具还会检查代码或重命名变量以使其更小。
- en: Image optimization
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像优化
- en: One of the most used assets in web development can be the images. They make
    your website look amazing, but they can make your site painfully slow. The main
    recommendation is to keep the number of images to the minimum, but if you need
    to keep images, at least try to optimize them before they are sent to your users.
    In this section, we will show you some things you can do to optimize your images
    and, as a consequence, the performance of your application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发中最常用的资源之一可能就是图像。它们让您的网站看起来很棒，但也可能使您的网站变得非常缓慢。主要建议是将图像数量保持最少，但如果您需要保留图像，至少在将它们发送给用户之前尝试优化它们。在本节中，我们将向您展示一些可以优化图像的方法，从而提高应用程序的性能。
- en: Use sprites
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用精灵图
- en: A sprite is an image composed by multiple images; later, you can use this image
    and show only the portion you are interested in. Imagine that you have a nice
    website and, on each page, you have some social icons (Facebook, Twitter, Instagram,
    and so on). Instead of having one image for each social icon, you can combine
    them in one and use CSS to show only the part you want for each icon. Doing this,
    you will have all the social icons with only one load, reducing the number of
    requests.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵图是由多个图像组成的图像；稍后，您可以使用此图像并仅显示您感兴趣的部分。想象一下，您有一个漂亮的网站，在每个页面上都有一些社交图标（Facebook、Twitter、Instagram等）。您可以将它们合并在一起，并使用CSS仅显示您想要的每个图标的部分，而不是为每个社交图标都有一个图像。这样做，您将只需加载一次所有社交图标，从而减少请求次数。
- en: Our recommendation is to keep your sprites small and include only the most used
    and shared images in them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议保持您的精灵图小，并只包含其中最常用和共享的图像。
- en: Use lossless image compression
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用无损图像压缩
- en: 'Not all image formats are suitable for the Web as some formats are either too
    big or do not support compression. The three most used image types on the Web
    nowadays are as listed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有图像格式都适合Web，因为某些格式要么太大，要么不支持压缩。当今Web上使用最多的三种图像类型如下：
- en: '**JPG**: This is one of the most commonly used method of lossless compression'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JPG**：这是最常用的无损压缩方法之一'
- en: '**PNG**: This is the best format with lossless data compression'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PNG**：这是具有无损数据压缩的最佳格式'
- en: '**GIF**: This is an old-school format that supports up to 8 bits per pixel
    for each image and is well known for its animated effects'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GIF**：这是一种老式格式，每个图像支持最多8位像素，并以其动画效果而闻名'
- en: The recommended format for the web at this moment is **PNG**. It is well supported
    by the browsers, easy to create, supports compression, and gives you all the power
    you need to improve the performance of your site to the maximum.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目前Web的推荐格式是**PNG**。它得到了浏览器的良好支持，易于创建，支持压缩，并且为您提供了改善网站性能所需的所有功能。
- en: Scale your images
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩放图像
- en: If you are using images and not data URIs, they should be sent at their original
    size. You should avoid resizing your images using CSS and send the image with
    the correct size to the browser. The only case when it is recommended to scale
    images by CSS is with fluid images (responsive design).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用图像而不是数据URI，则应以其原始尺寸发送图像。您应该避免使用CSS调整图像大小，并将具有正确尺寸的图像发送到浏览器。唯一建议使用CSS缩放图像的情况是在流体图像（响应式设计）中。
- en: You can scale your images easily with PHP libraries like Imagick or GD. With
    these libraries and a few lines of code, you can scale your images in seconds.
    Usually, you do not scale the images on the fly. Most of the time, as soon as
    an image is uploaded to your application, a batch process takes care of the image,
    creating the different sizes needed by your application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用像Imagick或GD这样的PHP库轻松缩放图像。使用这些库和几行代码，您可以在几秒钟内缩放图像。通常情况下，您不会即时缩放图像。大多数情况下，一旦图像上传到您的应用程序，批处理过程会处理图像，创建应用程序所需的不同尺寸。
- en: 'Imagine that you can upload images of any size to your application and you
    only show images with a maximum width of `350`px in your frontend. You can easily
    scale the previously stored image with Imagick:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您可以将任何尺寸的图像上传到您的应用程序，但在前端只显示最大宽度为`350`px的图像。您可以使用Imagick轻松缩放以前存储的图像：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code will load the `my_uploaded_image.png` file and resize the
    image to a width of `350`px using the Lanczos filter (refer to the PHP Imagick
    documentation to see all the available filters you can use).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将加载`my_uploaded_image.png`文件，并使用Lanczos滤镜将图像调整为宽度为`350`px（请参阅PHP Imagick文档，了解您可以使用的所有可用滤镜）。
- en: That's one way of doing it, another (and maybe even more effective) common way
    is to resize images on demand (that is, when first requested from client side),
    and then store the resized image either in cache or permanent storage.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种方法，另一种（也许更有效的）常见方法是按需调整图像大小（即在客户端首次请求时），然后将调整大小的图像存储在缓存或永久存储中。
- en: Use data URIs
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数据URI
- en: Another quick way of reducing the number of HTTP requests is embedding images
    as data URIs. This way, you will have the image as a string inside your code avoiding
    the request of the image, this method is the best fit for static pages. The best
    way to generate this kind of URIs is with external or online tools.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种快速减少HTTP请求次数的方法是将图像嵌入数据URI中。这样，您将在代码中将图像作为字符串，避免了对图像的请求，这种方法最适合静态页面。生成这种URI的最佳方式是使用外部或在线工具。
- en: 'The following example will show you how it will look in your HTML:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将向您展示它在您的HTML中的外观：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Cache, cache, and more cache
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存，缓存，还有更多的缓存
- en: Performance on the Web is all about serving data as fast as possible and, if
    our application already sent data that continues to be valid, why send it again?
    By default, modern browsers try to reduce the number of requests they make to
    the same site, so they keep a copy of some assets/resources in their internal
    cache for their future use. Thanks to this behavior, if you are browsing a website,
    we are not trying to load all the assets again and again as soon as you move between
    sections.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Web性能完全取决于尽快提供数据，如果我们的应用程序已经发送的数据仍然有效，为什么要再次发送呢？默认情况下，现代浏览器会尝试减少它们对同一站点发出的请求数量，因此它们会在内部缓存中保留一些资产/资源的副本以供将来使用。由于这种行为，如果您正在浏览网站，我们不会在您在各个部分之间移动时一次又一次地尝试加载所有资产。
- en: 'You can help your browser in specifying each request response with the following
    `Cache-Control` HTTP headers:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过指定每个请求响应来帮助浏览器，使用以下`Cache-Control` HTTP标头：
- en: '**max-age=[seconds]**: This sets the maximum amount of time that a response
    will be considered fresh. This directive is relative to the time of the request.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**max-age=[秒]**：这设置了响应被视为新鲜的最长时间。此指令是相对于请求的时间。'
- en: '**s-maxage=[seconds]**: This is similar to max-age, but for shared caches.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: s-maxage=[秒]：这类似于max-age，但适用于共享缓存。
- en: '**public**: This tag marks the response as cacheable.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public**：此标记将响应标记为可缓存。'
- en: '**private**: This tag allows you to store the response to one user. Shared
    caches are not allowed to store the response.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private**：此标记允许您将响应存储到一个用户。不允许共享缓存存储响应。'
- en: '**no-cache**: This tag instructs caches to submit the request to the original
    server for validation.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**no-cache**：此标记指示缓存将请求提交给原始服务器进行验证。'
- en: '**no-store**: This tag instructs caches not to keep a copy of the response.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**no-store**：此标记指示缓存不保留响应的副本。'
- en: '**must-revalidate**: This tag tells the caches that they must follow any fresh
    information you give them about a response.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**must-revalidate**：此标记告诉缓存它们必须遵循您提供的有关响应的任何新信息。'
- en: '**proxy-revalidate**: This is similar to must-revalidate, but for proxy caches.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**proxy-revalidate**：这类似于must-revalidate，但适用于代理缓存。'
- en: The main recommendation is to tag static assets with an expiration of at least
    one week or one day on long-life assets. In the case of assets that change frequently,
    the recommendation is to set the expiration to a couple of days or less. Adjust
    the cache expiration dates of your assets according to their life.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 主要建议是将静态资产标记为至少一周或长寿命资产的一天到期。对于频繁更改的资产，建议将到期日期设置为两天或更短。根据其生命周期调整资产的缓存到期日期。
- en: Imagine that you have one image that changes every 6 hours; in this case, you
    should not set the expiration date to a week, the best choice will be around 6
    hours.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您有一张图片，每6小时更改一次；在这种情况下，您不应该将到期日期设置为一周，最好的选择将是大约6小时。
- en: Avoid bad requests
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免不良请求
- en: There is nothing more annoying than bad requests as this kind of requests can
    reduce the performance of your application drastically. As you probably know,
    the browsers have a limited number of concurrent connections that they can manage
    at the same time for the same host. If your website makes a lot of requests, this
    list of available slots for connections can be full and the remaining requests
    are queued.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 没有比坏请求更令人讨厌的了，因为这种请求会严重降低应用程序的性能。您可能知道，浏览器对于同一主机可以同时管理的并发连接数量是有限的。如果您的网站发出了大量请求，这些可用连接插槽的列表可能已满，剩下的请求将被排队。
- en: Imagine that your browser can manage up to 10 concurrent connections and your
    web application makes 20 requests. Not all the requests can be attended to at
    the same time and some of them are queued. What happens now if your application
    is trying to get an asset and it does not exist? In this case, the browser will
    waste its time (and slot) waiting for the non-existent asset to be served, but
    it will never happen.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您的浏览器最多可以管理10个并发连接，而您的Web应用程序却发出了20个请求。并非所有请求都可以同时处理，其中一些请求被排队。现在，如果您的应用程序正在尝试获取一个不存在的资产会发生什么？在这种情况下，浏览器将浪费时间（和插槽）等待不存在的资产被提供，但这永远不会发生。
- en: As a recommendation, keep an eye on your browser developer tools (a set of web
    debugging tools built into the browsers you can use to debug and profile your
    site). These tools allow you to spot problematic requests and you can even check
    the amount of time used on each request. In most of the browsers, you can open
    the embedded developer tools pressing the *F12* key but, if your browser do not
    open the tools on pressing this key, check the browser's documentation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 作为建议，密切关注您的浏览器开发人员工具（一组内置于浏览器中的Web调试工具，可用于调试和分析您的站点）。这些工具可以帮助您发现问题请求，甚至可以检查每个请求使用的时间。在大多数浏览器中，您可以按下*F12*键打开嵌入式开发人员工具，但是，如果您的浏览器按下此键不打开工具，请查看浏览器的文档。
- en: Use Content Delivery Networks (CDNs)
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内容交付网络（CDN）
- en: A content delivery network hosts a copy of your assets in servers designed to
    respond quickly and from the closest server possible. That way, if you are moving
    the requests from your servers to the CDN servers, your web servers will be dealing
    with fewer requests, improving the performance of your application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 内容交付网络在旨在快速响应并从最近的服务器响应的服务器上托管您的资产的副本。这样，如果您将请求从您的服务器转移到CDN服务器，您的Web服务器将处理更少的请求，从而提高应用程序的性能。
- en: Imagine that you use jQuery in your frontend; if you change your code to load
    the library from an official CDN, the probability of an user having the library
    in their browser cache increases.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果您在前端使用jQuery；如果您将代码更改为从官方CDN加载库，则用户在其浏览器缓存中拥有该库的概率会增加。
- en: Our main recommendation is to use CDNs at least for your CSS, JavaScript, and
    images.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要建议是至少为您的CSS、JavaScript和图像使用CDN。
- en: Dependency management
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖管理
- en: You have multiple PHP libraries, frameworks, components, and tools available
    to use in your project. Until a few years ago, PHP did not have a modern way of
    managing project dependencies. At this moment we have Composer, a flexible project
    that was converted into the de facto standard of dependency management.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您有多个PHP库、框架、组件和工具可供在项目中使用。直到几年前，PHP没有一种现代的管理项目依赖关系的方式。此刻我们有Composer，一个灵活的项目，已经成为依赖管理的事实标准。
- en: You are probably familiar with Composer as we were using this tool all over
    the book to install new libraries in the `vendor` folder. At this point, you will
    be wondering whether you should commit the dependencies of your `vendor` folder.
    There is no quick response, but the general recommendation is no, you should not
    commit the `vendor` folder to your repository.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能对Composer很熟悉，因为我们在整本书中都在使用这个工具来在`vendor`文件夹中安装新库。此时，您可能会想知道是否应该提交`vendor`文件夹的依赖关系。没有快速的答复，但一般的建议是不要，您不应该将`vendor`文件夹提交到您的存储库中。
- en: 'The main disadvantages of committing the vendor folder can be summarized as
    follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 提交供应商文件夹的主要缺点可以总结如下：
- en: Increases the size of your repository
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加您的存储库的大小
- en: Duplicates the history of your dependencies
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制了您的依赖关系的历史记录
- en: 'As we told you before, not committing the vendor is the main recommendation,
    but if you really need to do it, here are some suggestions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前告诉过你的，不提交供应商是主要的建议，但如果你真的需要这样做，这里有一些建议：
- en: Use tagged releases (no dev versions) so that Composer fetches zipped sources
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标记的发布（不是开发版本），以便Composer获取压缩的源代码
- en: Use the `--prefer-dist` flag or set `preferred-install` to `dist` in your config
    file
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的配置文件中使用`--prefer-dist`标志或将`preferred-install`设置为`dist`
- en: Add the `/vendor/**/.git` rule to your `.gitignore` file
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`/vendor/**/.git`规则添加到您的`.gitignore`文件中
- en: Semantic versioning
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语义版本
- en: In any project you start, you should use semantic versioning on your master
    branch. Semantic versioning is a set of rules you can follow to tag the code of
    your application in your versioning control software. By following these rules,
    you will know the current status of your production environment at any moment.
    Another benefit of using tags in your code is that it allow us to move between
    versions or do roll backs in an easy and quick way.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始的任何项目中，您应该在主分支上使用语义版本。语义版本是一组规则，您可以遵循这些规则来标记您应用程序的代码在您的版本控制软件中。通过遵循这些规则，您将了解您的生产环境的当前状态。在您的代码中使用标签的另一个好处是，它允许我们在不同版本之间移动或以一种简单快捷的方式进行回滚。
- en: Another advantage of having your source code with release tags is that it allows
    you to work with release branches, allowing you to have better planification and
    control of the changes you are making to your code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有带有发布标签的源代码的另一个优势是，它允许您使用发布分支，从而使您能够更好地规划和控制对代码所做的更改。
- en: How semantic versioning works
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语义版本如何工作
- en: 'On semantic versioning, your code is marked with tags with the **`vX.Y.Z`**
    form, which means the version of your code. Each piece of your tag means something:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在语义版本中，您的代码标记为**`vX.Y.Z`**形式的标签，这意味着您代码的版本。您的每个标签部分都有特定的含义：
- en: '**X (major)**: An increase in this version number indicates that there are
    big changes in place; they are important enough to be incompatible with the current
    version'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X（主要）**：此版本号的增加表示正在进行重大改变；它们足够重要，与当前版本不兼容'
- en: '**Y (minor)**: An increment in this version number indicates that we are adding
    new features to our project'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Y（次要）**：此版本号的增加表示我们正在向项目添加新功能'
- en: '**Z (patch)**: An increment in this version number indicates that we added
    a patch to your source code'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Z（补丁）**：此版本号的增加表示我们向源代码添加了一个补丁'
- en: The actualization of the release tag is usually made by the developer who will
    push code to the production environment. Please remember to update the release
    tag before the deployment of your code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 发布标签的更新通常由将代码推送到生产环境的开发人员进行。请记住在部署代码之前更新发布标签。
- en: Semantic versioning in action
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语义版本在行动
- en: Imagine that you start in someone else's project and the master branch is tagged
    as `v1.2.3`. Let's look at some examples.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您开始在别人的项目中，主分支被标记为`v1.2.3`。让我们看一些例子。
- en: We have been told to add a new feature to the project
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们被告知要向项目添加一个新功能
- en: Working on a live project leads to receiving petitions for new features. In
    this case, we are clearly dealing with an increment of the minor version number
    because we are adding new code that is not incompatible with the actual base code.
    In our case, if our master branch is on `v1.2.3`, the new version tag will be
    `v1.3.0`. We have increased the minor version number and also, we reset the patch
    number because we are adding new code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行实时项目时，会收到新功能的请求。在这种情况下，我们明显正在增加次要版本号，因为我们正在添加新代码，这与实际基础代码不兼容。在我们的情况下，如果我们的主分支是`v1.2.3`，新版本标签将是`v1.3.0`。我们增加了次要版本号，同时重置了补丁号，因为我们正在添加新代码。
- en: We have been told that there is a bug in our project
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们被告知我们的项目中有一个错误
- en: On a day-to-day basis you will be fixing bugs in your code. In this case, we
    are dealing with a small change that the main function is to solve our issue,
    so we need to increase the patch version. In our example, if the current production
    version is `v1.2.3`, the new version tag will be `v1.2.4`. We only increased the
    patch number because our fix does not imply other, bigger changes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常工作中，您将修复代码中的错误。在这种情况下，我们正在处理的是一个小改变，主要功能是解决我们的问题，因此我们需要增加补丁版本。在我们的例子中，如果当前生产版本是`v1.2.3`，新版本标签将是`v1.2.4`。我们只增加了补丁号，因为我们的修复不涉及其他更大的改变。
- en: We have been asked for a big change
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们被要求进行重大改变
- en: Imagine now that we have been asked for a big change to our source code; once
    we apply our change, some parts of our source will be incompatible with the previous
    versions. For example, imagine that you are using `library_a` and we changed to
    using `library_b` and they are mutually exclusive. In this case, we are dealing
    with a very big change that indicates that we need to increase our major version
    number and also, we need to reset the minor and patch numbers. For example, if
    our production code is tagged as `v1.2.3`, the new version code after you apply
    your changes will be `v2.0.0`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们被要求对我们的源代码进行重大更改；一旦应用了我们的更改，我们的源代码的某些部分将与以前的版本不兼容。例如，想象一下，您正在使用`library_a`，我们改用`library_b`，它们是互斥的。在这种情况下，我们正在处理一个非常重大的变化，这表明我们需要增加我们的主要版本号，同时还需要重置次要和补丁号。例如，如果我们的生产代码标记为`v1.2.3`，则应用更改后的新版本代码将为`v2.0.0`。
- en: As you can see, doing semantic versioning will help you keep your source clean
    and makes it easier to know which kind of code changes are being done only by
    looking at the version number.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，进行语义版本控制将帮助您保持源代码的清洁，并使得通过查看版本号就能知道正在进行哪种类型的代码更改。
- en: Error handling
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: When we throw an exception because something happened during the execution of
    our application, we should give more information to our users or consumers about
    what happened. This is possible by adding describable standard codes, also known
    as status codes. Using these standard codes in your responses will help you (and
    your colleagues) to know quickly if something is going wrong in your application.
    Check the following list to know what are the correct and most common HTTP status
    codes to use them in your API.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们因为应用程序执行期间发生了某些事情而抛出异常时，我们应该向我们的用户或消费者提供更多关于发生了什么的信息。通过添加可描述的标准代码，也称为状态代码，可以实现这一点。在响应中使用这些标准代码将帮助您（和您的同事）快速了解应用程序中是否出现了问题。查看以下列表，了解在API中使用的正确和最常见的HTTP状态代码。
- en: Client request successful
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端请求成功
- en: 'If your application needs to inform the API client that the request was successful,
    you would usually reply with one of the following HTTP status codes:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序需要通知API客户端请求成功，通常会回复以下HTTP状态代码之一：
- en: '**200 - OK**: The request was done successfully'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**200 - 正常**：请求成功完成'
- en: '**201 - Created**: Successfully created the URI specified by the client'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**201 - 已创建**：成功创建了客户端指定的URI'
- en: '**202 - Accepted**: Accepted for processing but the server has not finished
    processing it'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**202 - 已接受**：已接受处理，但服务器尚未完成处理'
- en: '**204 - No Content**: Request is complete without any information being sent
    back in the response'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**204 - 无内容**：请求已完成，响应中没有发送任何信息'
- en: Request redirected
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求重定向
- en: 'When your application needs to reply to a request telling that the request
    was redirected, you will be using one of the following HTTP status codes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用程序需要回复请求被重定向时，您将使用以下HTTP状态代码之一：
- en: '**301 - Moved Permanently**: Requested resource does not exist on the server.
     A Location header is sent to the client to redirect it to the new URL. Client
    continues to use the new URL in the future requests.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**301 - 永久移动**：所请求的资源在服务器上不存在。服务器发送一个位置标头给客户端，将其重定向到新的URL。客户端在将来的请求中继续使用新的URL。'
- en: '**302 - Moved Temporarily**: Requested resource has temporarily moved.  A Location
    header is sent to the client to redirect it to the new URL. The client continues
    to use the old URL in the future requests.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**302 - 暂时移动**：所请求的资源已暂时移动。服务器发送一个位置标头给客户端，将其重定向到新的URL。客户端在将来的请求中继续使用旧的URL。'
- en: '**304 - Not Modified**: Used to respond to the `If-Modified-Since` request
    header. It indicates that the requested document has not been modified since the
    specified date, and the client should use a cached copy.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**304 - 未修改**：用于响应“If-Modified-Since”请求标头。它表示自指定日期以来所请求的文档未被修改，客户端应使用缓存副本。'
- en: Client request incomplete
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端请求不完整
- en: 'If the information you need to send to the API client is about an incomplete
    or wrong request, you will be returning one of the following HTTP codes:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要向API客户端发送的信息是关于不完整或错误的请求，您将返回以下HTTP代码之一：
- en: '**400 - Bad Request**: The server detected a syntax error in the client''s
    request.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**400 - 错误的请求**：服务器在客户端的请求中检测到语法错误。'
- en: '**401 - Unauthorized**: The request requires user authentication.  The server
    sends the WWW-Authenticate header to indicate the authentication type and realm
    for the requested resource.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**401 - 未经授权**：请求需要用户身份验证。服务器发送WWW-Authenticate标头以指示所请求资源的身份验证类型和领域。'
- en: '**402 - Payment Required**: This is reserved for the future.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**402 - 需要付款**：这是为将来保留的。'
- en: '**403 - Forbidden**: Access to the requested resource is forbidden. The request
    should not be repeated by the client.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**403 - 禁止**：禁止访问所请求的资源。客户端不应重复请求。'
- en: '**404 - Not Found**: The requested document does not exist on the server.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**404 - 未找到**：所请求的文档在服务器上不存在。'
- en: '**405 - Method Not Allowed**: The request method used by the client is unacceptable.
    The server sends the `Allow` header stating what methods are acceptable to access
    the requested resource.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**405 - 方法不允许**：客户端使用的请求方法是不可接受的。服务器发送“允许”标头，说明可以接受哪些方法来访问所请求的资源。'
- en: '**408 - Request Time-Out**: The client has failed to complete its request within
    the request timeout period used by the server. However, the client can re-request.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**408 - 请求超时**：客户端未能在服务器使用的请求超时期内完成其请求。但是，客户端可以重新请求。'
- en: '**410 - Gone**: The requested resource is permanently gone from the server.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**410 - 已消失**：所请求的资源已永久从服务器中消失。'
- en: '**413 - Request Entity Too Large**: The server refuses to process the request
    because its message body is too large. The server can close connection to stop
    the client from continuing the request.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 413 - 请求实体太大：服务器拒绝处理请求，因为其消息主体太大。服务器可以关闭连接以阻止客户端继续请求。
- en: '**414 - Request-URI Too Long**: The server refuses to process the request because
    the specified URI is too long.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**414 - 请求URI太长**：服务器拒绝处理请求，因为指定的URI太长。'
- en: '**415 - Unsupported Media Type**: The server refuses to process the request
    because it does not support the message body’s format.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**415 - 不支持的媒体类型**：服务器拒绝处理请求，因为它不支持消息正文的格式。'
- en: Server errors
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器错误
- en: 'On the unfortunate event of your application needing to inform the API client
    that there is some problem, you will be returning one of the following HTTP codes:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序不幸需要通知API客户端存在问题时，您将返回以下HTTP代码之一：
- en: '**500 - Internal server error**: A server configuration setting or an external
    program has caused an error.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**500 - 内部服务器错误**：服务器配置设置或外部程序导致错误。'
- en: '**501 - Not Implemented**: The server does not support the functionality required
    to fulfill the request.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**501 - 未实现**：服务器不支持满足请求所需的功能。'
- en: '**502 - Bad gateway**: The server encountered an invalid response from an upstream
    server or proxy.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**502 - 错误的网关**：服务器遇到上游服务器或代理的无效响应。'
- en: '**503 - Service unavailable**: The service is temporarily unavailable. The
    server can send a `Retry-After` header to indicate when the service may become
    available again.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**503 - 服务不可用**：服务暂时不可用。服务器可以发送`Retry-After`头来指示服务何时可能再次可用。'
- en: '**504 - Gateway Time-Out**: The gateway or proxy has timed out.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**504 - 网关超时**：网关或代理已超时。'
- en: Coding practices
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码实践
- en: Your code is the heart of your application; therefore, you want to write it
    properly, cleanly, and in an efficient manner. In this section, we will give you
    some hints to improve your code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码是应用程序的核心；因此，您希望以正确、清晰和高效的方式编写它。在本节中，我们将为您提供一些改进代码的提示。
- en: Dealing with strings
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理字符串
- en: One of the standards of the industry is to use the UTF-8 format in all your
    application levels. If you skip this recommendation, you will be dealing with
    encoding problems all your project's life. At the moment of writing this book,
    PHP does not support Unicode at low level, so you need to be careful when dealing
    with strings, specially with UTF-8\. The following recommendations are only if
    you are working with UTF-8.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 行业标准之一是在应用程序的所有级别中使用UTF-8格式。如果您忽略了这个建议，您将在整个项目的生命周期中处理编码问题。在撰写本书时，PHP不支持低级别的Unicode，因此在处理字符串时需要小心，特别是在处理UTF-8时。以下建议仅适用于使用UTF-8的情况。
- en: In PHP, the basic string operations such as assignation or concatenation don't
    need anything special in UTF-8; in other situations, you can use the core functions
    to deal with your strings. Most of the time, these functions have a counterpart
    (prefixed as `mb_*`) to deal with the Unicode. For example, in the PHP core, you
    can find the `substr()` and `mb_substr()` functions. You must use the multibyte
    functions whenever you operate with Unicode string. Imagine that you need to get
    a part of a UTF-8 string; if you use `substr()` instead of `mb_substr()`, there
    are good chances to get the result you are not expecting.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，基本的字符串操作，如赋值或连接，在UTF-8中不需要任何特殊处理；在其他情况下，您可以使用核心函数来处理字符串。大多数情况下，这些函数都有一个对应的函数（以`mb_*`为前缀）来处理Unicode。例如，在PHP核心中，您可以找到`substr()`和`mb_substr()`函数。每当您操作Unicode字符串时，都必须使用多字节函数。想象一下，如果您需要获取UTF-8字符串的一部分；如果您使用`substr()`而不是`mb_substr()`，有很大的机会得到您不期望的结果。
- en: Single quotes versus double quotes
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单引号与双引号
- en: Single quoted strings are not parsed by PHP, so it doesn't matter what you have
    in your string, PHP will return the string unchanged. In the case of double quoted
    strings, they are parsed by the PHP engine and any variable in the string will
    be evaluated. With double quoted strings, the escaped characters (t or n, for
    example) will also be evaluated.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号字符串不会被PHP解析，因此您的字符串中有什么并不重要，PHP将原样返回字符串。在双引号字符串的情况下，它们会被PHP引擎解析，并且字符串中的任何变量都将被评估。对于双引号字符串，转义字符（例如t或n）也将被评估。
- en: In real-life applications, the difference of performance of using one or another
    can pass unnoticed but, on high-load applications, the performance can be different.
    Our recommendation is to be consistent and use only double quotes if you need
    variables and escaped characters to be evaluated. In any other case, use single
    quotes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实应用中，使用其中一种方法的性能差异可能会被忽略，但在高负载应用中，性能可能会有所不同。我们建议保持一致，如果需要变量和转义字符被评估，请只使用双引号。在其他情况下，请使用单引号。
- en: Spaces versus tabs
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空格与制表符
- en: There is a war between developers who use spaces and developers who use tabs
    to tabulate their code. Each approach has its own benefits and inconveniences,
    but the PHP FIG recommendation is to use four spaces. Using only spaces avoids
    problems with diffs, patches, history, and annotations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员之间存在着使用空格和使用制表符来缩进他们的代码的战争。每种方法都有其自身的好处和不便，但PHP FIG建议使用四个空格。只使用空格可以避免与差异、补丁、历史和注释相关的问题。
- en: Regular expressions
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式
- en: 'In PHP, you have two options to write your regular expressions: the PCRE and
    the POSIX functions. The main recommendation is to use the PCRE functions (prefixed
    by `preg_*`) because the POSIX family of functions have been deprecated in PHP
    5.3.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，您有两种选项来编写您的正则表达式：PCRE和POSIX函数。主要建议使用PCRE函数（以`preg_*`为前缀），因为在PHP 5.3中，POSIX函数族已被弃用。
- en: Connection and queries to a database
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接和对数据库的查询
- en: You have multiple ways of connecting to a database in PHP but, among all of
    them, the recommended way of connecting is using PDO. One of the benefits of using
    PDO is that it has a standard interface to connect to multiple and different databases,
    allowing you to change your data storage without too much problem. When you are
    making queries against your database, and if you don't want any problem, ensure
    that you always use prepared statements. This way, you will avoid most of the
    SQL injection attacks.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，您有多种连接到数据库的方式，但在所有这些方式中，连接的推荐方式是使用PDO。使用PDO的好处之一是它具有标准接口，可以连接到多个不同的数据库，使您能够在不太麻烦的情况下更改数据存储。当您对数据库进行查询时，如果不想出现任何问题，请确保始终使用预处理语句。这样，您将避免大部分SQL注入攻击。
- en: Using the === operator
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用===运算符
- en: PHP is a loose type programming language, and this flexibility comes with some
    caveats when you are comparing your variables. If you use the `===` operator,
    PHP ensures that you are doing a strict comparison and avoiding false positives.
    Note that `===` is slightly faster than the `is_null()` and `is_bool()` functions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: PHP是一种松散类型的编程语言，当您比较变量时，这种灵活性会带来一些注意事项。如果使用`===`运算符，PHP会确保您进行严格比较，避免错误的结果。请注意，`===`比`is_null()`和`is_bool()`函数略快。
- en: Working with release branches
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用发布分支的工作
- en: Once we have our project following semantic versioning, we can start working
    with releases and release branches in our version control system, for example,
    Git. Using releases and release branches allows us to plan and organize the changes
    we will make in our code better.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的项目遵循语义版本控制，我们就可以开始在版本控制系统（例如Git）中使用发布和发布分支。使用发布和发布分支可以让我们更好地计划和组织我们对代码的更改。
- en: The work with releases is based on the semantic versioning due to the fact that
    each release branch will be created from master, usually from the latest master
    version that has a tag (for example, v1.2.3).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与发布版的工作基于语义版本控制，因为每个发布分支通常是从最新的主分支版本创建的（例如v1.2.3）。
- en: 'The main benefits of using release branches are as listed:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用发布分支的主要好处如下：
- en: Helps you follow a strict methodology for pushing your code to production
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助您遵循严格的方法将代码推送到生产环境
- en: Helps you easily plan and control the changes you make to your code
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助您轻松计划和控制对代码的更改
- en: Tries to avoid the common issue of dragging unwanted code to production
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试避免将不需要的代码拖入生产环境的常见问题
- en: Allows you to block special branches, such as dev or stage, to avoid commits
    without pull requests
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许您阻止特殊分支（例如dev或stage）以避免未经pull请求的提交
- en: Note that it is only a recommendation; each project is different, and this workflow
    can be unsuitable for your project.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这只是一个建议；每个项目都是不同的，这种工作流程可能不适合您的项目。
- en: Quick example
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速示例
- en: To use releases in your project, you need to work with a release branch and
    another temporal branch where you make the changes to the code. For the following
    example, imagine that our project has the master branch tagged as v1.2.3.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中使用发布版，您需要使用一个发布分支和另一个临时分支来对代码进行更改。对于以下示例，请想象我们的项目将主分支标记为v1.2.3。
- en: 'The first step is to check whether we already have a release branch against
    which we will be working. If it is not the case, you need to create a new one
    from master:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是检查我们是否已经有一个发布分支，我们将在其上进行工作。如果不是这种情况，您需要从主分支创建一个新的发布分支：
- en: First, we need to decide which will be our following version number; we will
    use all we have learned from the semantic versioning.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们需要决定我们的下一个版本号；我们将使用从语义版本控制中学到的所有内容。
- en: 'Once we know our following version number, we will create a release branch
    from master. The next command will show you how to get the latest master branch
    and create and push a new release branch:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们知道我们的下一个版本号，我们将从主分支创建一个发布分支。下一个命令将向您展示如何获取最新的主分支并创建并推送一个新的发布分支：
- en: '[PRE6]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After the preceding steps, our repository will have our release branch clean
    and ready to be used.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上述步骤之后，我们的存储库将拥有一个干净的发布分支，准备好使用。
- en: 'At this point, we have our release branch ready. This means that any code modification
    will be done in a temporal branch created from our release branch:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的发布分支已准备就绪。这意味着任何代码修改都将在从我们的发布分支创建的临时分支中进行：
- en: 'Imagine that we need to add a new feature to our project, so we need to create
    a temporal branch from our release branch:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们需要向项目添加一个新功能，因此我们需要从发布分支创建一个临时分支：
- en: '[PRE7]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As soon as we have our `feature/my_new_feature`, we can commit all our changes
    to this new branch. Once all our changes are committed and ready, we can merge
    our `feature/my_new_feature` with the release branch.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们有了`feature/my_new_feature`，我们可以将所有更改提交到这个新分支。一旦所有更改都已提交并准备就绪，我们可以将`feature/my_new_feature`与发布分支合并。
- en: The preceding steps can be repeated any number of times until all the tasks
    you have scheduled for the release are done.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤可以重复任意次数，直到您为发布计划的所有任务完成为止。
- en: Once you have finished all the release tasks and all your changes have been
    approved, you can merge the release branch with master. As soon as you finish
    the merge with master, remember to update the release tag.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成了所有发布任务并且所有更改都已经获得批准，您可以将发布分支与主分支合并。一旦完成与主分支的合并，请记得更新发布标签。
- en: 'We can summarize our example with the following reminder notes:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下提醒笔记总结我们的示例：
- en: New release branches are always created from master
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的发布分支始终是从主分支创建的
- en: Temporal branches are always created from the release branches
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时分支始终是从发布分支创建的
- en: Try to avoid the merge of other temporal branches with the current temporal
    branch
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量避免将其他临时分支与当前临时分支合并
- en: Try to avoid the merge of non-scheduled branches with your release branch
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量避免将非计划分支与发布分支合并
- en: 'In the preceding workflow, we recommend using the following branch prefixes
    to know the type of change associated with the branch:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述工作流程中，我们建议使用以下分支前缀来了解与分支关联的更改类型：
- en: '`release/*`: This prefix indicates that all the included changes will be deployed
    in the future release with the same version number'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release/*`: 这个前缀表示所有包含的更改将在将来的发布中部署，版本号相同'
- en: '`feature/*`: This prefix indicates that any change added to the branch is a
    new feature'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`feature/*`: 这个前缀表示添加到分支的任何更改都是新功能'
- en: '`hotfix/*`: This prefix indicates that the included changes are committed to
    fix bugs/issues'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hotfix/*`: 这个前缀表示包含的更改是为了修复错误/问题而提交的'
- en: Working this way, it will be more difficult to push unwanted code to production.
    Feel free to adapt the preceding workflow to your needs.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式工作，将更难将不需要的代码推送到生产环境。请随意根据您的需求调整前述工作流程。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we gave you some bits and bobs about the common best practices
    and conventions you can use in your projects. They are all recommendations, but
    they make the difference to stand out from the rest of the projects.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为您介绍了一些关于您项目中可以使用的常见最佳实践和约定的要点。它们都是建议，但它们使得项目与其他项目脱颖而出。
