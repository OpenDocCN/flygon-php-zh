["```php\n// chap4_IO_blocking.php \n\n$start = microtime(true); \n\n$i = 0; \n\n$responses = []; \n\nwhile ($i < 10) { \n\n    $curl = curl_init(); \n\n    curl_setopt_array($curl, array( \n        CURLOPT_RETURNTRANSFER => 1, \n        CURLOPT_URL => 'http://www.google.ca', \n        CURLOPT_USERAGENT => 'Faster Web cURL Request' \n    )); \n\n    $responses[] = curl_exec($curl); \n\n    curl_close($curl); \n\n    $i++; \n} \n\n$time = microtime(true) - $start; \n\necho 'Time elapsed: ' . $time . PHP_EOL; \n\necho memory_get_usage() . ' bytes' . PHP_EOL; \n```", "```php\n// chap4_IO_non_blocking.php \n\n$start = microtime(true); \n\n$i = 0; \n\n$curlHandles = []; \n\n$responses = []; \n\n$multiHandle = curl_multi_init(); \n\nfor ($i = 0; $i < 10; $i++) { \n\n    $curlHandles[$i] = curl_init(); \n\n    curl_setopt_array($curlHandles[$i], array( \n        CURLOPT_RETURNTRANSFER => 1, \n        CURLOPT_URL => 'http://www.google.ca', \n        CURLOPT_USERAGENT => 'Faster Web cURL Request' \n    )); \n\n    curl_multi_add_handle($multiHandle, $curlHandles[$i]); \n} \n\n$running = null; \n\ndo { \n    curl_multi_exec($multiHandle, $running); \n} while ($running); \n\nfor ($i = 0; $i < 10; $i++) { \n    curl_multi_remove_handle($multiHandle, $curlHandles[$i]); \n\n    $responses[] = curl_multi_getcontent($curlHandles[$i]); \n} \n\ncurl_multi_close($multiHandle); \n\n$time = microtime(true) - $start; \n\necho 'Time elapsed: ' . $time . PHP_EOL; \n\necho memory_get_usage() . ' bytes' . PHP_EOL; \n```", "```php\n// chap4_async_race.php\n\n$laps[] = 0;\n$laps[] = 0;\n$laps[] = 0;\n\nfunction car1(int &$lap) {\n    while ($lap <= 10) {\n        for ($x = 0; $x <= 200; $x++) {\n            yield 0;\n        }\n\n        yield 1;\n    }\n\n    // If the car has finished its race, return null in order to remove the car from the race\n    return;\n}\n\nfunction car2(int &$lap) {\n    while ($lap <= 10) {\n        for ($x = 0; $x <= 220; $x++) {\n            yield 0;\n        }\n\n        yield 1;\n    }\n\n    // If the car has finished its race, return null in order to remove the car from the race\n    return;\n}\n\nfunction car3(int &$lap) {\n    while ($lap <= 10) {\n        for ($x = 0; $x <= 230; $x++) {\n            yield 0;\n        }\n\n        yield 1;\n    }\n\n    // If the car has finished its race, return null in order to remove the car from the race\n    return;\n}\n\nfunction runner(array $cars, array &$laps) {\n    $flag = FALSE;\n\n    while (TRUE) {\n        foreach ($cars as $key => $car) {\n            $penalty = rand(0, 8);\n            if($key == $penalty) {\n                // We must advance the car pointer in order to truly apply the penalty \n                                                                to the \"current\" car\n                $car->next();\n            } else {\n                // Check if the \"current\" car pointer points to an active race car\n                if($car->current() !== NULL) {\n                    // Check if the \"current\" car pointer points to a car that has  \n                                                                    completed a lap\n                    if($car->current() == 1) {\n                        $lapNumber = $laps[$key]++;\n                        $carNumber = $key + 1;\n                        if ($lapNumber == 10 && $flag === FALSE) {\n                            echo \"*** Car $carNumber IS THE WINNER! ***\\n\";\n                            $flag = TRUE;\n                        } else {\n                            echo \"Car $carNumber has completed lap $lapNumber\\n\";\n                        }\n                    }\n                    // Advance the car pointer\n                    $car->next();\n                    // If the next car is no longer active, remove the car from the \n                                                                              race\n                    if (!$car->valid()) {\n                        unset($cars[$key]);\n                    }\n                }\n            }\n        }\n\n```", "```php\n        // No active cars left! The race is over!\n        if (empty($cars)) return;\n    }\n}\n\nrunner(array(car1($laps[0]), car2($laps[1]), car3($laps[2])), $laps); \n```", "```php\n# docker run -it --rm \\\n> -p 8282:80 \\\n> -v ${PWD}/:/srv/fasterweb \\\n> asclinux/linuxforphp-8.1:7.0.29-zts \\\n> /bin/bash\n```", "```php\n# mv /srv/www /srv/www.OLD\n# ln -s /srv/fasterweb/chapter_4 /srv/www\n# cd /srv/www\n# pecl install pthreads\n# echo \"extension=pthreads.so\" >> /etc/php.ini\n```", "```php\n// chap4_pthreads.php \n\n$start = microtime(true); \n\nclass TestThreads extends Thread { \n\n    protected $arg; \n\n    public function __construct($arg) { \n        $this->arg = $arg; \n    } \n\n    public function run() { \n        if ($this->arg) { \n            $sleep = mt_rand(1, 10); \n            printf('%s: %s  -start -sleeps %d' . \"\\n\", date(\"g:i:sa\"), $this->arg, \n                                                                          $sleep); \n            sleep($sleep); \n            printf('%s: %s  -finish' . \"\\n\", date(\"g:i:sa\"), $this->arg); \n        } \n    } \n} \n\n$stack = array(); \n\n// Create Multiple Thread \nforeach ( range('1', '9') as $id ) { \n    $stack[] = new TestThreads($id); \n} \n\n// Execute threads \nforeach ( $stack as $thread ) { \n    $thread->start(); \n} \n\nsleep(1); \n\n$time = microtime(true) - $start; \n\necho 'Time elapsed: ' . $time . PHP_EOL; \n\necho memory_get_usage() . ' bytes' . PHP_EOL; \n```", "```php\n# cd /srv/www/react \n# php composer.phar self-update\n# php composer.phar install \n# cd examples \n```", "```php\n// parallel-download.php \n\n$start = microtime(true); \n\n// downloading the two best technologies ever in parallel \n\nrequire __DIR__ \n    . DIRECTORY_SEPARATOR \n    .'..' \n    . DIRECTORY_SEPARATOR \n    . 'vendor' \n    . DIRECTORY_SEPARATOR \n    .'autoload.php'; \n\n$loop = React\\EventLoop\\Factory::create(); \n\n$files = array( \n    'node-v0.6.18.tar.gz' => 'http://nodejs.org/dist/v0.6.18/node-v0.6.18.tar.gz', \n    'php-5.5.15.tar.gz' => 'http://it.php.net/get/php-5.5.15.tar.gz/from/this/mirror', \n); \n\nforeach ($files as $file => $url) {\n    $readStream = fopen($url, 'r'); \n    $writeStream = fopen($file, 'w'); \n\n    stream_set_blocking($readStream, 0); \n    stream_set_blocking($writeStream, 0); \n\n    $read = new React\\Stream\\Stream($readStream, $loop); \n    $write = new React\\Stream\\Stream($writeStream, $loop); \n\n    $read->on('end', function () use ($file, &$files) { \n        unset($files[$file]); \n        echo \"Finished downloading $file\\n\"; \n    }); \n\n    $read->pipe($write);\n\n} \n\n$loop->addPeriodicTimer(5, function ($timer) use (&$files) { \n    if (0 === count($files)) { \n        $timer->cancel(); \n    } \n\n    foreach ($files as $file => $url) {\n\n        $mbytes = filesize($file) / (1024 * 1024); \n        $formatted = number_format($mbytes, 3); \n        echo \"$file: $formatted MiB\\n\"; \n    } \n}); \n\necho \"This script will show the download status every 5 seconds.\\n\"; \n\n$loop->run(); \n\n$time = microtime(true) - $start; \n\necho 'Time elapsed: ' . $time . PHP_EOL; \n\necho memory_get_usage() . ' bytes' . PHP_EOL; \n```", "```php\n # php parallel-download.php \n```", "```php\n// tcp-chat.php \n\n// socket based chat\n\nrequire __DIR__ \n    . DIRECTORY_SEPARATOR \n    .'..' \n    . DIRECTORY_SEPARATOR \n    . 'vendor' \n    . DIRECTORY_SEPARATOR \n    .'autoload.php';\n\n$loop = React\\EventLoop\\Factory::create();\n$socket = new React\\Socket\\Server($loop);\n\n$conns = new \\SplObjectStorage();\n\n$socket->on('connection', function ($conn) use ($conns) {\n    $conns->attach($conn);\n\n    $conn->on('data', function ($data) use ($conns, $conn) {\n        foreach ($conns as $current) {\n\n            if ($conn === $current) {\n               continue;\n            }\n\n            $current->write($conn->getRemoteAddress().': ');\n            $current->write($data);\n        }\n\n    });\n\n    $conn->on('end', function () use ($conns, $conn) {\n        $conns->detach($conn);\n    });\n});\n\necho \"Socket server listening on port 4000.\\n\";\necho \"You can connect to it by running: telnet localhost 4000\\n\";\n\n$socket->listen(4000);\n$loop->run();\n```", "```php\n # php tcp-chat.php \n```", "```php\n # **docker exec -it $( docker ps -q | awk '{ print $1 }' ) /bin/bash** \n```", "```php\n# telnet localhost 4000\n```", "```php\n// scalability.php \n\n// a simple, single-process, horizontal scalable http server listening on 10 ports\n\nrequire __DIR__ \n    . DIRECTORY_SEPARATOR \n    .'..' \n    . DIRECTORY_SEPARATOR \n    . 'vendor' \n    . DIRECTORY_SEPARATOR \n    .'autoload.php';\n\n$loop = React\\EventLoop\\Factory::create();\n\nfor ($i = 0; $i < 10; ++$i) {\n\n    $s = stream_socket_server('tcp://127.0.0.1:' . (8000 + $i));\n    $loop->addReadStream($s, function ($s) use ($i) {\n        $c = stream_socket_accept($s);\n        $len = strlen($i) + 4;\n        fwrite($c,\"HTTP/1.1 200 OK\\r\\nContent-Length: $len\\r\\n\\r\\nHi:$i\\n\");\n        echo \"Served on port 800$i\\n\";\n    });\n\n}\n\necho \"Access your brand new HTTP server on 127.0.0.1:800x. Replace x with any number from 0-9\\n\";\n\n$loop->run();\n```", "```php\n # php scalability.php\n```", "```php\n # **docker exec -it $( docker ps -q | awk '{ print $1 }' ) /bin/bash** \n```", "```php\n# wget -nv -O - http://localhost:8000\n# wget -nv -O - http://localhost:8001\n# wget -nv -O - http://localhost:8002\n# wget -nv -O - http://localhost:8003\n# wget -nv -O - http://localhost:8004\n# wget -nv -O - http://localhost:8005\n# wget -nv -O - http://localhost:8006\n# wget -nv -O - http://localhost:8007\n# wget -nv -O - http://localhost:8008\n# wget -nv -O - http://localhost:8009\n```"]