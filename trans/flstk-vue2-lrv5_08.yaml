- en: Managing Your Application State with Vuex
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vuex管理应用程序状态
- en: In the last chapter, you learned how Vue Router can be used to add virtual pages
    to a Vue.js single-page app. We will now add components to Vuebnb that share data
    across pages and therefore can't rely on transient local state. To do this, we
    will utilize Vuex, a Flux-inspired library for Vue.js that offers a robust means
    of managing global application state.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了如何使用Vue Router将虚拟页面添加到Vue.js单页面应用程序中。现在，我们将在Vuebnb中添加跨页面共享数据的组件，因此不能依赖于瞬态本地状态。为此，我们将利用Vuex，这是一个受Flux启发的Vue.js库，提供了一种强大的管理全局应用程序状态的方法。
- en: 'Topics covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题：
- en: An introduction to the Flux application architecture and why it is useful for
    building user interfaces
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux应用程序架构简介以及它在构建用户界面时的用处
- en: An overview of Vuex and its key features, including state and mutations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vuex的概述及其关键特性，包括状态和突变
- en: How to install Vuex and set up a global store that can be accessed by Vue.js
    components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装Vuex并设置可以被Vue.js组件访问的全局存储
- en: How Vuex allows for superior debugging with Vue Devtools via mutation logging
    and time-travel debugging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vuex如何通过突变日志和时间旅行调试实现更好的调试
- en: The creation of a save feature for Vuebnb listings and a saved listings page
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Vuebnb列表创建保存功能和保存列表页面
- en: Moving page state into Vuex to minimize unnecessary data retrieval from the
    server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将页面状态移入Vuex以减少从服务器检索不必要数据
- en: Flux application architecture
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux应用程序架构
- en: Imagine you've developed a multi-user chat app. The interface has a user list,
    private chat windows, an inbox with chat history and a notification bar to inform
    users of unread messages.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您开发了一个多用户聊天应用程序。界面上有用户列表、私人聊天窗口、带有聊天记录的收件箱和通知栏，用于通知用户有未读消息。
- en: 'Millions of users are chatting through your app on a daily basis. However,
    there are complaints about an annoying problem: the notification bar of the app
    will occasionally give false notifications; that is, a user will be notified of
    a new unread message, but when they check to see what it is, it''s just a message
    they''ve already seen.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数百万用户每天通过您的应用程序进行聊天。但是，有关一个令人讨厌的问题的投诉：应用程序的通知栏偶尔会发出虚假通知；也就是说，用户将收到新的未读消息的通知，但当他们检查时，发现只是他们已经看过的消息。
- en: What I've described is a real scenario that Facebook developers had with their
    chat system a few years ago. The process of solving this inspired their developers
    to create an application architecture they named *Flux*. Flux forms the basis
    of Vuex, Redux and other similar libraries.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我描述的是Facebook开发人员几年前在他们的聊天系统中遇到的一个真实场景。解决这个问题的过程激发了他们的开发人员创建了一个他们称之为*Flux*的应用程序架构。Flux是Vuex、Redux和其他类似库的基础。
- en: Facebook developers struggled with this *zombie notification* bug for some time.
    They eventually realized that its persistent nature was more than a simple bug;
    it pointed to an underlying flaw in the architecture of the app.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook的开发人员为这个*僵尸通知*问题苦苦挣扎了一段时间。他们最终意识到，它的持久性不仅仅是一个简单的错误；它指向了应用程序架构中的一个根本缺陷。
- en: 'The flaw is most easily understood in the abstract: when you have multiple
    components in an application that share data, the complexity of their interconnections
    will increase to a point where the state of the data is no longer predictable
    or understandable. When bugs like the one described inevitably arise, the complexity
    of the app data makes them near impossible to resolve:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个缺陷在抽象中最容易理解：当应用程序中有多个共享数据的组件时，它们之间的相互连接的复杂性将增加到一个程度，使得数据的状态不再可预测或可理解。当像上面描述的错误不可避免地出现时，应用程序数据的复杂性使得它们几乎不可能解决：
- en: '![](assets/d3af18a5-6ef2-4e3d-bbc3-421235671ed0.png)Figure 8.1\. The complexity
    of communication between components increases with every extra component'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/d3af18a5-6ef2-4e3d-bbc3-421235671ed0.png)图8.1。组件之间通信的复杂性随着每个额外组件的增加而增加'
- en: Flux is not a library. You can't go to GitHub and download it. Flux is a set
    of guiding principles that describe a scalable frontend architecture that sufficiently
    mitigates this flaw. It is not just for a chat app, but for any complex UI with
    components which share state, like Vuebnb.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Flux不是一个库。你不能去GitHub上下载它。Flux是一组指导原则，描述了一种可扩展的前端架构，足以减轻这个缺陷。它不仅适用于聊天应用程序，还适用于任何具有共享状态的复杂UI组件，比如Vuebnb。
- en: Let's now explore the guiding principles of Flux.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们探索Flux的指导原则。
- en: 'Principle #1 – Single source of truth'
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原则＃1-真相的唯一来源
- en: 'Components may have *local data* that only they need to know about. For example,
    the position of the scroll bar in the user list component is probably of no interest
    to other components:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可能有它们自己需要知道的*本地数据*。例如，用户列表组件中滚动条的位置可能对其他组件没有兴趣：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But any data that is to be shared between components, for example *application
    data*, needs to be kept in a single place, separate from the components that use
    it. This location is referred to as the *store*. Components must read application
    data from this location and not keep their own copy to prevent conflict or disagreement:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，任何要在组件之间共享的数据，例如*应用程序数据*，都需要保存在一个单独的位置，与使用它的组件分开。这个位置被称为*存储*。组件必须从这个位置读取应用程序数据，而不是保留自己的副本，以防冲突或分歧：
- en: '![](assets/3929a216-de2f-4ce7-b175-6399ecd98b4d.png)Figure 8.2\. Centralized
    data simplifies application state'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/3929a216-de2f-4ce7-b175-6399ecd98b4d.png)图8.2。集中式数据简化了应用程序状态'
- en: 'Principle #2 – Data is read-only'
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原则＃2-数据是只读的
- en: Components can freely read data from the store. But they cannot change data
    in the store, at least not directly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以自由地从存储中读取数据。但是它们不能直接改变存储中的数据，至少不能直接改变。
- en: Instead, they must inform the store of their intent to change the data and the
    store will be responsible for making those changes via a set of defined functions
    called *mutator methods*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，它们必须通知存储它们改变数据的意图，存储将负责通过一组定义的函数（称为*mutator方法*）进行这些更改。
- en: 'Why this approach? If we centralize the data-altering logic then we don''t
    have to look far if there are inconsistencies in the state. We''re minimizing
    the possibility that some random component (possibly in a third party module)
    has changed the data in an unexpected fashion:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要这样做？如果我们集中数据修改逻辑，那么如果状态存在不一致，我们就不必远程查找。我们正在最小化某些随机组件（可能在第三方模块中）以意想不到的方式改变数据的可能性：
- en: '![](assets/5913f05b-dd85-4450-8021-ed3d0ca3e211.png)Figure 8.3\. State is read-only.
    Mutator methods are used to write to the store'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3。状态是只读的。使用改变器方法来写入存储
- en: 'Principle #3 – Mutations are synchronous'
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原则＃3 - 变异是同步的
- en: It's much easier to debug state inconsistencies in an app that implements the
    above two principles in its architecture. You could log commits and observe how
    the state changes in response (which automatically happens with Vue Devtools,
    as we'll see).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现上述两个原则的应用程序中，调试状态不一致要容易得多。您可以记录提交并观察状态如何响应更改（这在Vue Devtools中自动发生，我们将看到）。
- en: But this ability would be undermined if our mutations were applied *asynchronously*.
    We'd know the order our commits came in, but we would not know the order in which
    our components committed them. Synchronous mutations ensure state is not dependent
    on the sequence and timing of unpredictable events.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们的变异被异步应用，这种能力将受到破坏。我们会知道我们提交的顺序，但我们不会知道我们的组件提交它们的顺序和时间。同步变异确保状态不依赖于不可预测事件的顺序和时间。
- en: Vuex
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vuex
- en: '*Vuex* (usually pronounced *veweks*) is the official Vue.js implementation
    of the Flux architecture. By enforcing the principles described previously, Vuex
    keeps your application data in a transparent and predictable state even when that
    data is being shared across many components.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*Vuex*（通常发音为*veweks*）是Flux架构的官方Vue.js实现。通过强制执行先前描述的原则，即使在数据被共享到许多组件时，Vuex也可以保持应用程序数据处于透明和可预测的状态。'
- en: Vuex includes a store with state and mutator methods, and will reactively update
    any components that are reading data from the store. It also allows for handy
    development features like hot module reloading (updating modules in a running
    application) and time-travel debugging (stepping back through mutations to trace
    bugs).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex包括具有状态和变异方法的存储，并且将对从存储中读取数据的任何组件进行反应性更新。它还允许方便的开发功能，如热模块重新加载（更新运行中应用程序中的模块）和时间旅行调试（通过回溯变异来跟踪错误）。
- en: 'In this chapter, we will add a *save* feature to our Vuebnb listings so that
    a user can keep track of the listings that they like best. Unlike other data in
    our app so far, the saved state must persist across pages; for example, when a
    user changes from one page to another, the app must remember which items the user
    has already saved. We will use Vuex to achieve this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为Vuebnb列表添加一个*保存*功能，以便用户可以跟踪他们最喜欢的列表。与迄今为止我们应用程序中的其他数据不同，保存的状态必须在页面之间持久存在；例如，当用户从一个页面切换到另一个页面时，应用程序必须记住用户已经保存了哪些项目。我们将使用Vuex来实现这一点：
- en: '![](assets/66e49fec-a7b3-422b-9015-ce5b934d5950.png)Figure 8.4\. Saved state
    is available to all page components'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4。保存状态对所有页面组件可用
- en: Installing Vuex
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Vuex
- en: 'Vuex is an NPM package that can be installed from the command line:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex是一个可以从命令行安装的NPM包：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will put our Vuex configuration into a new module file `store.js`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的Vuex配置放入一个新的模块文件`store.js`：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We need to import Vuex in this file and, like Vue Router, install it with `Vue.use`.
    This gives special properties to Vue that make it compatible with Vuex, such as
    allowing components to access the store via `this.$store`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在此文件中导入Vuex，并像Vue Router一样使用`Vue.use`进行安装。这使Vue具有特殊属性，使其与Vuex兼容，例如允许组件通过`this.$store`访问存储。
- en: '`resources/assets/js/store.js`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/store.js`：'
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will then import the store module in our main app file, and add it to our
    Vue instance.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将在我们的主应用程序文件中导入存储模块，并将其添加到我们的Vue实例中。
- en: '`resources/assets/js/app.js`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Save feature
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存功能
- en: 'As mentioned, we''ll be adding a *save* feature to our Vuebnb listings. The
    UI of this feature is a small, clickable icon that is overlaid on the top right
    of a listing summary''s thumbnail image. It acts similarly to a checkbox, allowing
    the user to toggle the saved status of any particular listing:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将为Vuebnb列表添加一个*保存*功能。该功能的UI是一个小的可点击图标，叠加在列表摘要的缩略图像的右上角。它类似于复选框，允许用户切换特定列表的保存状态：
- en: '![](assets/08d86e82-fae4-4b85-a5e4-275876a2c3e8.png)Figure 8.5\. The save feature
    shown on listing summaries'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5。在列表摘要上显示的保存功能
- en: 'The save feature will also be added as a button in the header image on the
    listing page:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 保存功能还将添加为列表页面上的标题图像中的按钮：
- en: '![](assets/8afceda7-510a-4be1-8a12-499eb511c473.png)Figure 8.6\. The save feature
    shown on the listing page'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6。在列表页面上显示的保存功能
- en: ListingSave component
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ListingSave组件
- en: 'Let''s begin by creating the new component:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建新组件：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The template of this component will include a Font Awesome *heart*icon. It will
    also include a click handler which will be used to toggle the saved state. Since
    this component will always be a child of a listing or listing summary, it will
    receive a listing ID as a prop. This prop will be used shortly to save the state
    in Vuex.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件的模板将包括一个Font Awesome *heart*图标。它还将包括一个点击处理程序，用于切换保存状态。由于此组件始终是列表或列表摘要的子级，因此它将很快使用列表ID作为prop来保存状态。不久将使用此prop。
- en: '`resources/assets/components/ListingSave.vue`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSave.vue`：'
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that the click handler has a `stop` modifier. This modifier prevents the
    click event from bubbling up to ancestor elements, especially any anchor tags
    which might trigger a page change!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，点击处理程序具有`stop`修饰符。此修饰符可防止点击事件冒泡到祖先元素，特别是可能触发页面更改的任何锚标签！
- en: 'We''ll now add `ListingSave` to the `ListingSummary` component. Remember to
    pass the listing''s ID as a prop. While we''re at it, let''s add a `position:
    relative` to the `.listing-summary` class rules so that `ListingSave` can be positioned
    absolutely against it.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们将`ListingSave`添加到`ListingSummary`组件中。记得将列表的ID作为prop传递。顺便说一句，让我们在`.listing-summary`类规则中添加`position:
    relative`，这样`ListingSave`可以绝对定位。'
- en: '`resources/assets/components/ListingSummary.vue`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSummary.vue`:'
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With that done, we will now see the `ListingSave` heart icon rendered on each
    summary:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们现在将在每个摘要中看到`ListingSave`心形图标的呈现：
- en: '![](assets/5b38719f-3f5c-4447-bc74-2cfc395ce643.png)Figure 8.7\. The ListingSave component
    within ListingSummary components'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5b38719f-3f5c-4447-bc74-2cfc395ce643.png)图8.7。`ListingSummary`组件中的`ListingSave`组件'
- en: Saved state
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已保存状态
- en: The `ListingSave` component does not have any local data; we will instead keep
    any saved listings in our Vuex store. To do this, we will create an array in the
    store called `saved`. Each time the user toggles the saved state of a listing
    its ID will be either added or removed from this array.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListingSave`组件没有任何本地数据；相反，我们将保存任何已保存的列表在我们的Vuex存储中。为此，我们将在存储中创建一个名为`saved`的数组。每当用户切换列表的保存状态时，其ID将被添加或从此数组中移除。'
- en: To begin, let's add a `state` property to our Vuex store. This object will hold
    any data we want to be globally available to the components of our app. We will
    add the `saved` property to this object and assign it an empty array.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在Vuex存储中添加一个`state`属性。这个对象将保存我们想要在应用程序组件中全局可用的任何数据。我们将在这个对象中添加`saved`属性，并将其分配为空数组。
- en: '`resources/assets/js/store.js`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/store.js`:'
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Mutator method
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更方法
- en: We created the stub for a `toggleSaved` method in our `ListingSave` component.
    This method should add or remove the listing's ID from the `saved` state in the
    store. Components can access the store as `this.$store`. More specifically, the `saved` array
    can be accessed at `this.$store.state.saved`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`ListingSave`组件中创建了`toggleSaved`方法的存根。此方法应该在存储中的`saved`状态中添加或删除列表的ID。组件可以通过`this.$store`访问存储。更具体地说，`saved`数组可以在`this.$store.state.saved`中访问。
- en: '`resources/assets/components/ListingSave.vue`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSave.vue`:'
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember that in the Flux architecture state is read-only. That means we cannot
    directly modify `saved` from a component. Instead, we must create a mutator method
    in the store which does the modification for us.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在Flux架构中，状态是只读的。这意味着我们不能直接从组件中修改`saved`。相反，我们必须在存储中创建一个变更方法来为我们进行修改。
- en: 'Let''s create a `mutations` property in our store configuration, and add a
    function property `toggleSaved`. Vuex mutator methods receive two arguments: the
    store state and a payload. This payload can be anything you want to pass from
    the component to the mutator. For the current case, we will send the listing ID.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在存储配置中创建一个`mutations`属性，并添加一个函数属性`toggleSaved`。Vuex变更方法接收两个参数：存储状态和有效负载。此有效负载可以是您想要从组件传递给变更方法的任何内容。对于当前情况，我们将发送列表ID。
- en: The logic for `toggleSaved` is to check if the listing ID is already in the `saved` array
    and if so, remove it, or if not, add it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`toggleSaved`的逻辑是检查列表ID是否已经在`saved`数组中，如果是，则将其移除，如果不是，则添加。'
- en: '`resources/assets/js/store.js`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/store.js`:'
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We now need to commit this mutation from `ListingSave`. *Commit*is Flux jargon
    that is synonymous with *call* or *trigger*. A commit looks like a custom event
    with the first argument being the name of the mutator method and the second being
    the payload.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要从`ListingSave`提交这个变更。*提交*是Flux术语，与*调用*或*触发*是同义词。提交看起来像一个自定义事件，第一个参数是变更方法的名称，第二个是有效负载。
- en: '`resources/assets/components/ListingSave.vue`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSave.vue`:'
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The main point of using mutator methods in the store architecture is that state
    is changed consistently. But there is an additional benefit: we can easily log
    these changes for debugging. If you check the Vuex tab in Vue Devtools after clicking
    one of the save buttons, you will see an entry for that mutation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储架构中使用变更方法的主要目的是保持状态的一致性。但还有一个额外的好处：我们可以轻松地记录这些更改以进行调试。如果您在单击保存按钮后检查Vue Devtools中的Vuex选项卡，您将看到该变更的条目：
- en: '![](assets/4f23bdf4-ebe3-4723-8e3f-3a3dfbf6160d.png)Figure 8.8: Mutation log'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/4f23bdf4-ebe3-4723-8e3f-3a3dfbf6160d.png)图8.8：变更日志'
- en: Each entry in the log can tell you the state after the change was committed,
    as well as the particulars of the mutation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 日志中的每个条目都可以告诉您在提交更改后的状态，以及变化的具体情况。
- en: If you double-click a logged mutation, Vue Devtools will revert the state of
    the app to what it was directly after that change. This is called *time-travel
    debugging* and can be useful for fine-grained debugging.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您双击已记录的变更，Vue Devtools将将应用程序的状态恢复到该更改后的状态。这被称为*时间旅行调试*，对于精细调试非常有用。
- en: Changing the icon to reflect the state
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图标更改以反映状态
- en: Our `ListingSave` component's icon will appear differently, depending on whether
    or not the listing is saved; it will be opaque if the listing is saved, and transparent
    if it is not. Since the component doesn't store its state locally, we need to
    retrieve state from the store to implement this feature.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ListingSave`组件的图标将以不同的方式显示，取决于列表是否已保存；如果列表已保存，它将是不透明的，如果没有保存，则是透明的。由于组件不会在本地存储其状态，因此我们需要从存储中检索状态以实现此功能。
- en: Vuex store state should generally be retrieved via a computed property. This
    ensures that the component is not keeping its own copy, which would violate the
    *single source of truth* principle, and that the component is re-rendered when
    the state is mutated by this component or another. Reactivity works with Vuex
    state, too!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex存储状态通常应通过计算属性检索。这确保了组件没有自己的副本，这违反了*单一数据源*原则，并且当状态被这个组件或其他组件改变时，组件会重新渲染。响应性也适用于Vuex状态！
- en: Let's create a computed property `isListingSaved`, which will return a Boolean
    value reflecting whether or not this particular listing has been saved.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个计算属性`isListingSaved`，它将返回一个布尔值，反映这个特定列表是否已保存。
- en: '`resources/assets/components/ListingSave.vue`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSave.vue`:'
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can now use this computed property to change the icon. Currently we're using
    the Font Awesome icon `fa-heart-o`. This should represent the *unsaved* state.
    When the listing is saved we should instead use the icon `fa-heart`. We can implement
    this with a dynamic class binding.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个计算属性来改变图标。目前我们使用的是Font Awesome图标fa-heart-o。这应该代表“未保存”状态。当列表被保存时，我们应该使用图标fa-heart。我们可以通过动态类绑定来实现这一点。
- en: '`resources/assets/components/ListingSave.vue`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSave.vue`:'
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now the user can visually identify which listings have been saved and which
    haven''t. Thanks to reactive Vuex data, the icon will instantly be updated when
    a change to the `saved` state is made from anywhere in the app:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以直观地识别哪些列表已经被保存，哪些没有。由于响应式的Vuex数据，当从应用程序的任何地方对saved状态进行更改时，图标将立即更新：
- en: '![](assets/7d161bd9-3d66-4d56-9fe3-101a47565018.png)Figure 8.9\. The ListingSave icon
    will change depending on the state'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/7d161bd9-3d66-4d56-9fe3-101a47565018.png)图8.9。ListingSave图标将根据状态改变'
- en: Adding to ListingPage
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加到ListingPage
- en: We also want the save feature to appear on the listing page. It will go inside
    the `HeaderImage` component alongside the View Photos button so that, like with
    the listing summaries, the button is overlaid on the listing's main image.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望保存功能出现在列表页面上。它将放在HeaderImage组件中，与查看照片按钮一起，这样，就像列表摘要一样，按钮将覆盖在列表的主图像上。
- en: '`resources/assets/components/HeaderImage.vue`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/HeaderImage.vue`:'
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that `HeaderImage` does not have the listing ID in its scope, so we'll
    have to pass this down as a prop from `ListingPage`. `id` is not currently a data
    property of `ListingPage` either, but, if we declare it, it will simply work.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，HeaderImage的范围中没有列表ID，因此我们将不得不从ListingPage将其作为属性传递下来。id当前也不是ListingPage的数据属性，但是，如果我们声明它，它将简单地工作。
- en: This is because the ID is already a property of the initial state/AJAX data
    the component receives, therefore `id` will automatically be populated by the `Object.assign` when
    the component is loaded by the router.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为ID已经是组件接收到的初始状态/AJAX数据的属性，因此当组件被路由加载时，id将自动由Object.assign填充。
- en: '`resources/assets/components/ListingPage.vue`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingPage.vue`:'
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With that done, the save feature will now appear on the listing page:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，保存功能现在将出现在列表页面上：
- en: '![](assets/26551ab4-8d6c-4bc1-97a5-c618aa9afd2f.png)Figure 8.10\. The listing
    save feature on the listing pageIf you save a listing via the listing page, then
    return to the home page, the equivalent listing summary will be saved. This is
    because our Vuex state is global and will persist across page changes (though
    not page refreshes...yet).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/26551ab4-8d6c-4bc1-97a5-c618aa9afd2f.png)图8.10。列表页面上的列表保存功能如果您通过列表页面保存一个列表，然后返回主页，相应的列表摘要将被保存。这是因为我们的Vuex状态是全局的，并且将在页面更改时持续存在（尽管不是页面刷新...但）。'
- en: Making ListingSave a button
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将ListingSave设置为按钮
- en: As it is, the `ListingSave` feature appears too small in the listing page header
    and will be easily overlooked by a user. Let's make it a proper button, similar
    to the View Photos button in the bottom left of the header.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，ListingSave功能在列表页面标题中显得太小，用户很容易忽略它。让我们把它做成一个合适的按钮，类似于标题左下角的查看照片按钮。
- en: To do this, we'll modify `ListingSave` to allow parent components to send a
    prop `button`. This Boolean prop will indicate if the component should include
    a `button` element wrapped around the icon or not.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将修改ListingSave以允许父组件发送一个名为button的prop。这个布尔prop将指示组件是否应该包含一个包裹在图标周围的按钮元素。
- en: The text for this button will be a computed property `message` which will change
    from Save to Saved depending on the value of `isListingSaved`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个按钮的文本将是一个计算属性message，它将根据isListingSaved的值从Save变为Saved。
- en: '`resources/assets/components/ListingSave.vue`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSave.vue`:'
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We will now set the `button` prop to `true` within `HeaderImage`. Even though
    the value is not dynamic, we use a `v-bind` to ensure the value is interpreted
    as a JavaScript value, not a string.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在HeaderImage中将button prop设置为true。即使值不是动态的，我们也使用v-bind来确保该值被解释为JavaScript值，而不是字符串。
- en: '`resources/assets/components/HeaderImage.vue`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/HeaderImage.vue`:'
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With that, the `ListingSave` will appear as a button on our listing pages:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，ListingSave将出现在我们的列表页面上：
- en: '![](assets/2f04270b-3b6f-4b66-988d-c523580b11d1.png)Figure 8.11\. The listing
    save feature appears as a button on the listing page'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2f04270b-3b6f-4b66-988d-c523580b11d1.png)图8.11。列表保存功能显示为列表页面上的按钮'
- en: Moving page state into the store
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将页面状态移入存储
- en: 'Now that the user can save any listings that they like, we will need a *saved*
    page where they can view those saved listings together. We will build this new
    page shortly, and it will look like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以保存他们喜欢的任何列表，我们将需要一个“保存”页面，他们可以在那里查看这些保存的列表。我们将很快构建这个新页面，它将如下所示：
- en: '![](assets/6e48bd76-0d44-4746-8cb8-26041676e739.png)Figure 8.12: Saved page'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6e48bd76-0d44-4746-8cb8-26041676e739.png)图8.12：已保存页面'
- en: Implementing the saved page will require an enhancement to our app architecture,
    however. Let's do a quick recap of how data is retrieved from the server to understand
    why.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 实现保存页面将需要对我们的应用架构进行增强。让我们快速回顾一下从服务器检索数据的方式，以了解为什么。
- en: All the pages in our app require a route on the server to return a view. This
    view includes the data for the relevant page component inlined in the document
    head. Or, if we navigate to that page via in-app links, an API endpoint will instead
    supply that same data. We set up this mechanism in [Chapter 7](08354437-8373-40d1-b1d5-c63219c85c95.xhtml), *Building
    A Multi-Page App With Vue Router*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用中的所有页面都需要服务器上的路由返回一个视图。这个视图包括相关页面组件的数据内联在文档头部。或者，如果我们通过应用内链接导航到该页面，一个API端点将提供相同的数据。我们在第7章中设置了这个机制，*使用Vue
    Router构建多页面应用*。
- en: The saved page will require the same data as the home page (the listing summary
    data), as the saved page is really just a slight variation on the home page. It
    makes sense, then, to share data between the home page and saved page. In other
    words, if a user loads Vuebnb from the home page, then navigates to the saved
    page, or vice versa, it would be a waste to load the listing summary data more
    than once.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 保存的页面将需要与主页相同的数据（列表摘要数据），因为保存的页面实际上只是主页的轻微变体。因此，在主页和保存的页面之间共享数据是有意义的。换句话说，如果用户从主页加载Vuebnb，然后导航到保存的页面，或者反之亦然，多次加载列表摘要数据将是一种浪费。
- en: 'Let''s decouple our page state from our page components and move it into Vuex.
    That way it can be used by whichever page needs and it and avoid unnecessary reloading:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将页面状态与页面组件解耦，并将其移入Vuex。这样，它可以被任何需要它的页面使用，并避免不必要的重新加载：
- en: '![](assets/cac3b0f4-d27d-47d1-aedc-bba44181e368.png)Figure 8.13\. Page state
    in store'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/cac3b0f4-d27d-47d1-aedc-bba44181e368.png)图8.13。存储中的页面状态'
- en: State and mutator methods
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态和变更方法
- en: Let's add two new state properties to our Vuex store: `listings` and `listing_summaries`.
    These will be arrays that store our listings and listing summaries respectively.
    When the page first loads, or when the route changes and the API is called, the
    loaded data will be put into these arrays rather than being assigned directly
    to the page components. The page components will instead retrieve this data from
    the store.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向Vuex存储添加两个新的状态属性：`listings`和`listing_summaries`。这些将是分别存储我们的列表和列表摘要的数组。当页面首次加载时，或者当路由更改并调用API时，加载的数据将被放入这些数组中，而不是直接分配给页面组件。页面组件将从存储中检索这些数据。
- en: We'll also add a mutator method, `addData`, for populating these arrays. It
    will accept a payload object with two properties: `route` and `data`. `route` is
    the name of the route, for example, *listing*, *home*,and so on. `data` is the
    listing or listing summary data retrieved from the document head or the API.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个变更方法`addData`，用于填充这些数组。它将接受一个带有两个属性`route`和`data`的有效负载对象。`route`是路由的名称，例如*listing*，*home*等。`data`是从文档头或API检索到的列表或列表摘要数据。
- en: '`resources/assets/js/store.js`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/store.js`：'
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Router
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器
- en: The logic for retrieving page state is in the mixin file  `route-mixin.js`.
    This mixin adds a `beforeRouteEnter` hook to a page component which applies the
    page state to the component instance when it becomes available.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 检索页面状态的逻辑在mixin文件`route-mixin.js`中。这个mixin为页面组件添加了一个`beforeRouteEnter`钩子，当组件实例可用时，将页面状态应用于组件实例。
- en: Now that we're storing page state in Vuex we will utilize a different approach.
    Firstly, we won't need a mixin anymore; we'll put this logic into `router.js` now.
    Secondly, we'll use a different navigation guard, `beforeEach`. This is not a
    component hook, but a hook that can be applied to the router itself, and it is
    triggered before every navigation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将页面状态存储在Vuex中，我们将利用不同的方法。首先，我们不再需要mixin；我们现在将这个逻辑放入`router.js`中。其次，我们将使用不同的导航守卫`beforeEach`。这不是一个组件钩子，而是一个可以应用于路由器本身的钩子，并且在每次导航之前触发。
- en: You can see in the following code block how I've implemented this in `router.js`.
    Note that before `next()` is called we commit the page state to the store.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下代码块中看到我如何在`router.js`中实现这一点。请注意，在调用`next()`之前，我们将页面状态提交到存储中。
- en: '`resources/assets/js/router.js`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/router.js`：'
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With that done, we can now delete the route mixin:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们现在可以删除路由mixin：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Retrieving page state from Vuex
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Vuex中检索页面状态
- en: 'Now that we''ve moved page state into Vuex we''ll need to modify our page components
    to retrieve it. Starting with `ListingPage`, the changes we must make are:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将页面状态移入Vuex，我们需要修改我们的页面组件来检索它。从`ListingPage`开始，我们必须进行的更改是：
- en: Remove local data properties.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除本地数据属性。
- en: Add a computed property `listing`. This will find the right listing data from
    the store based on the route.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个计算属性`listing`。这将根据路由从存储中找到正确的列表数据。
- en: Remove the mixin.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除mixin。
- en: 'Change template variables so they''re properties of `listing`: an example is  `{{
    title }}` , which will become `{{ listing.title }}`. Unfortunately, all variables
    are now properties of `listing` which makes our template slightly more verbose.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改模板变量，使它们成为`listing`的属性：例如`{{ title }}`，将变成`{{ listing.title }}`。不幸的是，现在所有变量都是`listing`的属性，这使得我们的模板稍微冗长。
- en: '`resources/assets/components/ListingPage.vue`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingPage.vue`：'
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Changes to `HomePage` are much simpler; just remove the mixin and the local
    state, and replace it with a computed property, `listing_groups`, which will retrieve
    all the listing summaries from the store.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对`HomePage`的更改要简单得多；只需删除mixin和本地状态，并用计算属性`listing_groups`替换它，该属性将从存储中检索所有列表摘要。
- en: '`resources/assets/components/HomePage.vue`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/HomePage.vue`：'
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After making these changes, reload the app and you should see no obvious change
    in behavior. However, inspecting the Vuex tab of Vue Devtools, you will see that
    page data is now in the store:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这些更改后，重新加载应用程序，您应该看不到行为上的明显变化。但是，检查Vue Devtools的Vuex选项卡，您将看到页面数据现在在存储中：
- en: '![](assets/dc5a618d-c18a-4ec3-8b43-229e5021393f.png)Figure 8.14\. Page state
    is now in the Vuex store'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/dc5a618d-c18a-4ec3-8b43-229e5021393f.png)图8.14。页面状态现在在Vuex存储中'
- en: Getters
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Getters
- en: 'Sometimes what we want to get from the store is not a direct value, but a derived
    value. For example, say we wanted to get only those listing summaries that were
    saved by the user. To do this, we can define a *getter,* which is like a computed
    property for the store:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想要从商店得到的不是直接的价值，而是一个派生的价值。例如，假设我们只想获取用户保存的那些列表摘要。为此，我们可以定义一个*getter*，它类似于存储的计算属性：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, any component that needs the getter data can retrieve it from the store
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何需要getter数据的组件都可以从存储中检索它：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Generally, you define a getter when several components need the same derived
    value, to save repeating code. Let's create a getter which retrieves a specific
    listing. We've already created this functionality in `ListingPage`, but since
    we're going to need it in our router as well, we'll refactor it as a getter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当几个组件需要相同的派生值时，您会定义一个getter来避免重复编写代码。让我们创建一个getter来检索特定的列表。我们已经在`ListingPage`中创建了这个功能，但由于我们在路由器中也需要它，我们将将其重构为getter。
- en: One thing about getters is that they don't accept a payload argument like mutations
    do. If you want to pass a value to a getter, you need to return a function where
    the payload is an argument of that function.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 关于getter的一件事是，它们不像mutations那样接受有效负载参数。如果要将值传递给getter，您需要返回一个函数，其中有效负载是该函数的参数。
- en: '`resources/assets/js/router.js`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/router.js`:'
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's now use this getter in our `ListingPage` to replace the previous logic.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`ListingPage`中使用这个getter来替换以前的逻辑。
- en: '`resources/assets/components/ListingPage.vue`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingPage.vue`:'
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Checking if page state is in the store
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查页面状态是否在存储中
- en: 'We''ve successfully moved page state into the store. Now in the navigation
    guard, we will check to see if the data a page needs is already stored to avoid
    retrieving the same data twice:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功将页面状态移入存储。现在在导航守卫中，我们将检查页面需要的数据是否已经存储，以避免两次检索相同的数据：
- en: '![](assets/f45f9b1b-793f-4022-8f0f-25675a8d8b5c.png)Figure 8.15\. Decision
    logic for getting page data'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/f45f9b1b-793f-4022-8f0f-25675a8d8b5c.png)图8.15。获取页面数据的决策逻辑'
- en: 'Let''s implement this logic in the `beforeEach` hook in `router.js`. We''ll
    add an `if` block at the start that will instantly resolve the hook if the data
    is already present. The `if` uses a ternary function with the following logic:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`router.js`的`beforeEach`钩子中实现这个逻辑。我们将在开头添加一个`if`块，如果数据已经存在，它将立即解析钩子。`if`使用一个带有以下逻辑的三元函数：
- en: If the route name is *listing*, use the `getListing` getter to see if that particular
    listing is available (this getter returns `undefined` if it is not)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果路由名称是*listing*，则使用`getListing` getter来查看特定列表是否可用（如果不可用，则此getter返回`undefined`）
- en: If the route name is *not* *listing*, check to see if the store has listing
    summaries available. Listing summaries are always retrieved all at once, so if
    there's at least one, you can assume they're all there
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果路由名称*不是* *listing*，请检查存储是否有列表摘要可用。列表摘要总是一次性检索的，因此如果至少有一个，您可以假定它们都在那里。
- en: '`resources/assets/js/router.js`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/router.js`:'
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With that done, if the in-app navigation is used to navigate from the home page
    to listing 1, then back to the home page, then back to listing 1, the app will
    retrieve listing 1 from the API just the once. It would have done it twice under
    the previous architecture!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，如果在应用内导航中从主页导航到列表1，然后返回主页，然后返回列表1，应用程序将只从API中检索列表1一次。在以前的架构下，它会做两次！
- en: Saved page
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存的页面
- en: 'We will now add the saved page to Vuebnb. Let''s begin by creating the component
    file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将保存的页面添加到Vuebnb。让我们首先创建组件文件：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Next, we'll create a new route with this component at the path `/saved`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在路径`/saved`上创建一个新的路由，并使用这个组件。
- en: '`resources/assets/js/router.js`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/router.js`:'
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's also add some server-side routes to the Laravel project. As discussed
    above, the saved page uses exactly the same data as the home page. This means
    that we can just call the same controller methods used for the home page.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还在Laravel项目中添加一些服务器端路由。如上所述，保存的页面使用与主页完全相同的数据。这意味着我们可以调用用于主页的相同控制器方法。
- en: '`routes/web.php`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes/web.php`:'
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`routes/api.php`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes/api.php`:'
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now we will define the `SavedPage` component. Beginning with the `script` tag,
    we will import the `ListingSummary` component we created back in [Chapter 6](c3b31042-0e33-40d8-ad31-d048ccf7082d.xhtml), *Composing
    Widgets with Vue.js Components*. We'll also create a computed property, `listings`, that
    will return the listing summaries from the store, filtered by whether or not they're
    saved.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将定义`SavedPage`组件。从`script`标签开始，我们将导入我们在[第6章](c3b31042-0e33-40d8-ad31-d048ccf7082d.xhtml)中创建的`ListingSummary`组件，*使用Vue.js组件组合小部件*。我们还将创建一个计算属性`listings`，它将从存储中返回列表摘要，并根据是否保存进行过滤。
- en: '`resources/assets/components/SavedPage.vue`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/SavedPage.vue`:'
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Next, we will add to the `template` tag of `SavedPage`. The main content includes
    a check for the length of the array returned by the `listings` computed property.
    If it is 0, no items have been saved yet. In this case, we display a message to
    inform the user. If there are listings saved, however, we'll iterate through them
    and display them with the `ListingSummary` component.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加到`SavedPage`的`template`标签。主要内容包括检查`listings`计算属性返回的数组长度。如果为0，则尚未保存任何项目。在这种情况下，我们会显示一条消息通知用户。然而，如果有保存的列表，我们将遍历它们并使用`ListingSummary`组件显示它们。
- en: '`resources/assets/components/SavedPage.vue`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/SavedPage.vue`:'
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Lastly, we''ll add to the `style` tag. The main thing to note here is that
    we''re utilizing the `flex-wrap: wrap` rule and justifying to the left. This ensures
    that our listing summaries will organize themselves in rows without gaps.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们将添加到`style`标签。这里需要注意的主要是我们正在利用`flex-wrap: wrap`规则并向左对齐。这确保我们的列表摘要将自行组织成没有间隙的行。'
- en: '`resources/assets/components/SavedPage.vue`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/SavedPage.vue`:'
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let's also add the `.saved-container` CSS rules in our global CSS file. This
    ensures that our custom footer has access to these rules as well.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还在全局CSS文件中添加`.saved-container` CSS规则。这确保我们的自定义页脚也可以访问这些规则。
- en: '`resources/assets/css/style.css`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/css/style.css`:'
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The final task is to add some default saved listings to the store. I've chosen
    1 and 15 at random, but you can add any you want. We'll remove these again in
    the next chapter when we use Laravel to persist saved listings to the database.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的任务是向存储中添加一些默认的保存列表。我随机选择了1和15，但您可以添加任何您想要的。在下一章中，当我们使用Laravel将保存的列表持久化到数据库时，我们将再次删除这些。
- en: '`resources/assets/js/store.js`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/store.js`:'
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With that done, here''s what our saved page looks like:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们的保存页面如下所示：
- en: '![](assets/dd5572ee-80c1-420e-b176-df3860c92fe3.png)Figure 8.16\. Saved page'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/dd5572ee-80c1-420e-b176-df3860c92fe3.png)图8.16。保存页面'
- en: 'If we remove all our saved listings, this is what we see:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们删除所有保存的列表，我们会看到：
- en: '![](assets/023a07de-c00d-4eb1-8f8c-26588e1c171e.png)Figure 8.17\. Saved page
    without listings'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/023a07de-c00d-4eb1-8f8c-26588e1c171e.png)图8.17。没有列表的保存页面'
- en: Toolbar links
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具栏链接
- en: The last thing we'll do in this chapter is to add a link to the saved page in
    the toolbar so that the saved page is accessible from any other page. To do this,
    we'll add an inline `ul` where links are enclosed within a child `li`(we'll add
    more links to the toolbar in [Chapter 9](046ff094-aa7d-43d0-9f9b-444652bcaf1d.xhtml),
    *Adding a User Login and API Authentication with Passport*).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一件事是在工具栏中添加一个链接到保存页面，以便从任何其他页面访问保存页面。为此，我们将添加一个内联`ul`，其中链接被包含在一个子`li`中（我们将在[第9章](046ff094-aa7d-43d0-9f9b-444652bcaf1d.xhtml)中在工具栏中添加更多链接，*添加用户登录和使用Passport进行API身份验证*）。
- en: '`resources/assets/components/App.vue`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/App.vue`:'
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To display this correctly, we'll have to add some extra CSS. Firstly, we'll
    modify the `#toolbar` declaration so that the toolbar uses flex for display. We'll
    also add some new rules below that for displaying the links.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确显示这一点，我们需要添加一些额外的CSS。首先，我们将修改`#toolbar`声明，使工具栏使用flex进行显示。我们还将在下面添加一些新规则来显示链接。
- en: '`resources/assets/components/App.vue`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/App.vue`:'
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We now have a link to the saved page in the toolbar:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在工具栏中有一个指向保存页面的链接：
- en: '![](assets/861e4bd0-2979-4ae1-8831-7b51702ed106.png)Figure 8.18: Saved link
    in toolbar'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/861e4bd0-2979-4ae1-8831-7b51702ed106.png)图8.18：工具栏中的保存链接'
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about Vuex, Vue's official state management library,
    which is based on the Flux architecture. We installed Vuex in Vuebnb and set up
    a store where global state could be written and retrieved.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Vuex，Vue的官方状态管理库，它基于Flux架构。我们在Vuebnb中安装了Vuex，并设置了一个存储库，可以在其中编写和检索全局状态。
- en: We then learned the main features of Vuex including state, mutator methods and
    getters, and how we can debug Vuex using Vue Devtools. We used this knowledge
    to implement a listing save component, which we then added to our main pages.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了Vuex的主要特性，包括状态、变化方法和获取器，以及我们如何使用Vue Devtools调试Vuex。我们利用这些知识实现了一个列表保存组件，然后将其添加到我们的主页面。
- en: Lastly, we married Vuex and Vue Router to allow page state to be more efficiently
    stored and retrieved when the route changes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将Vuex和Vue Router结合起来，以便在路由更改时更有效地存储和检索页面状态。
- en: In the next chapter, we'll cover one of the trickiest topics of full-stack apps
    - authentication. We'll add a user profile to Vuebnb so a user can persist their
    saved items to the database. We'll also continue to add to our knowledge of Vuex
    by utilizing some of its more advanced features.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖全栈应用程序中最棘手的主题之一 - 认证。我们将在Vuebnb中添加用户配置文件，以便用户可以将其保存的项目持久保存到数据库中。我们还将继续增加对Vuex的了解，利用一些更高级的功能。
