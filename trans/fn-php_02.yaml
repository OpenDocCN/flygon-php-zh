- en: Chapter 2.  Pure Functions, Referential Transparency, and Immutability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。纯函数、引用透明度和不可变性
- en: Those who have read the appendix about functional programming will have seen
    that it revolves around pure functions, or in other words, functions that only
    use their input to produce a result.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读有关函数式编程的附录的人会发现，它围绕纯函数展开，换句话说，只使用其输入来产生结果的函数。
- en: It might seem easy to determine whether a function is pure or not. It's just
    about checking that you don't call any global state, right? Sadly, it's not that
    simple. There are also multiple ways a function can produce side effects. Some
    of them are pretty easy to spot; others are more difficult.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 确定一个函数是否是纯的似乎很容易。只需检查是否调用了任何全局状态，对吗？遗憾的是，事情并不那么简单。函数产生副作用的方式也有多种。有些很容易发现，而其他一些则更难。
- en: This chapter will not cover the benefits of using functional programming. If
    you are interested in the benefits, I suggest you read the appendix which tackles
    the subject in depth. However, we will discuss the advantages offered by immutability
    and referential transparency, as they are quite specific and are glossed over
    in the appendix.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不会涵盖使用函数式编程的好处。如果您对好处感兴趣，我建议您阅读附录，其中深入讨论了这个主题。然而，我们将讨论不可变性和引用透明性所提供的优势，因为它们相当具体，并且在附录中只是粗略地提到。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Hidden input and output
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏的输入和输出
- en: Function purity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数纯度
- en: Immutability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性
- en: Referential transparency
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用透明度
- en: Two sets of input and output
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两组输入和输出
- en: 'Let''s start with a simple function:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的函数开始：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The input and output of this function are pretty obvious to spot. We have two
    parameters and one return value. We can say without doubt that this function is
    pure.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的输入和输出很容易发现。我们有两个参数和一个返回值。毫无疑问，这个函数是纯的。
- en: 'Parameters and return values are the first set of input and output a function
    can have. But there''s a second set, which is usually more difficult to spot.
    Have a look at the following two functions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 参数和返回值是函数可能具有的第一组输入和输出。但还有第二组，通常更难发现。看看以下两个函数：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first function has no obvious input. However, it's pretty clear that we
    get some data from the `$_SESSION` variable to create the output value, so we
    have one hidden input. We also have a hidden side-effect on the session because
    the `array_pop` method removes the message we just got from the list of messages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数没有明显的输入。然而，很明显我们从“$_SESSION”变量中获取一些数据来创建输出值，所以我们有一个隐藏的输入。我们还对会话产生了隐藏的副作用，因为“array_pop”方法从消息列表中删除了我们刚刚得到的消息。
- en: The second method has no obvious output. But, updating the score of the player
    is clearly a side effect. Besides, the `$score` that we get from the player might
    be considered as a second input to the function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法没有明显的输出。但是，更新玩家的得分显然是一个副作用。此外，我们从玩家那里得到的“$score”可能被视为函数的第二个输入。
- en: 'In such simple and code examples, the hidden input and output is pretty easy
    to spot. However, it quickly becomes more difficult, especially in an object-oriented
    codebase. And make no mistake, anything hidden like that, even in the most obvious
    way, can have consequences such as:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样简单的代码示例中，隐藏的输入和输出很容易发现。然而，随着时间的推移，尤其是在面向对象的代码库中，情况很快变得更加困难。不要误解，任何隐藏的东西，即使以最明显的方式隐藏，都可能产生后果，比如：
- en: Increasing the cognitive burden. Now you have to think about what happens in
    the `Session` or `Player` classes.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加认知负担。现在你必须考虑“Session”或“Player”类中发生了什么。
- en: Test results can vary for identical input parameters, as some other state of
    the software has changed, leading to difficult to understand behaviors.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的输入参数可能导致测试结果不同，因为软件的某些其他状态已经改变，导致难以理解的行为。
- en: The function signature, or API, is not clear about what you can expect from
    the functions, making it necessary to read the code or documentation for them.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数签名或API并不清楚您可以从函数中期望什么，这使得有必要阅读它们的代码或文档。
- en: The problem with those two simple looking functions is that they need to read
    and update the existing state of your program. It is not yet the topic of this
    chapter to show you ways to write them better, we will look at that in [Chapter
    6](ch06.html "Chapter 6.  Real-Life Monads"), *Real-life monads*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个看起来简单的函数的问题在于它们需要读取和更新程序的现有状态。本章的主题还不是向您展示如何更好地编写它们，我们将在第6章《真实生活中的单子》中讨论这个问题。
- en: For readers accustomed to Dependency Injection, the first function is using
    a static call and it can be avoided by injecting an instance of the Session variable.
    Doing so will solve the hidden input issue, but the fact that we modify the state
    of the `$_SESSION` variable remains as a side-effect.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于习惯于依赖注入的读者来说，第一个函数使用了静态调用，可以通过注入Session变量的实例来避免。这样做将解决隐藏输入的问题，但我们修改“$_SESSION”变量的事实仍然是副作用。
- en: The remainder of this chapter will try to teach you how to spot impure functions
    and why they are important, both for functional programming and code quality in
    general
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将尝试教会您如何发现不纯的函数以及它们对函数式编程和代码质量的重要性。
- en: For the rest of this book, we will use the terms **side cause** for hidden inputs,
    and **side effects** for hidden output. This dichotomy is not always used, but
    I think it helps with being able to describe with more accuracy when we are speaking
    about a hidden dependency or a hidden output of the code we will discuss.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将使用术语“副作用”来表示隐藏的输入，以及“副作用”来表示隐藏的输出。这种二分法并不总是被使用，但我认为它有助于更准确地描述我们讨论的代码中的隐藏依赖或隐藏输出。
- en: 'Although a broader concept, available functional literature might use the term
    **free variable** to refer to side causes. A Wikipedia article about the topic
    states the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管是一个更广泛的概念，可用的功能性文献可能会使用术语“自由变量”来指代副作用。维基百科关于这个主题的文章陈述如下：
- en: '*In computer programming, the term free variable refers to variables used in
    a function that are not local variables nor parameters of that function. The term
    non-local variable is often a synonym in this context.*'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在计算机编程中，自由变量是指在函数中使用的不是局部变量也不是该函数的参数的变量。在这个上下文中，非局部变量通常是一个同义词。*'
- en: Given this definition, variables passed using the use keyword to a PHP closure
    could be called a free variable; this is why I prefer using the term side cause
    to clearly separate the two.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，使用`use`关键字传递给PHP闭包的变量可以被称为自由变量；这就是为什么我更喜欢使用副作用这个术语来清楚地区分这两者。
- en: Pure functions
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数
- en: Let's say you have the function signature function `getCurrentTvProgram (Channel
    $channel`). Without any indication of the purity of the function, you have no
    idea of the complexity that may be hidden behind such a function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个函数签名`getCurrentTvProgram (Channel $channel)`。在没有函数纯度的指示的情况下，你无法知道这样一个函数背后可能隐藏的复杂性。
- en: You will probably get the program that is actually playing on the given channel.
    What you don't know is whether the function checked if you are logged into the
    system. Maybe there's some kind of database update for analytic purposes. Maybe
    the function will return an exception because the log file is in a read-only state.
    You cannot know for sure, and all of those are side causes or side effects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会得到实际播放在给定频道的节目。但你不知道函数是否检查了你是否已登录系统。也许有一些用于分析目的的数据库更新。也许函数会因为日志文件处于只读状态而返回异常。你无法确定，所有这些都是副作用或者副作用。
- en: 'Regarding all the complexity associated with those hidden dependencies, you
    are faced with three options:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有与这些隐藏依赖关系相关的复杂性，你面临三个选择：
- en: Dive deep down into the documentation or code to understand all that is happening
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入文档或代码，了解所有正在发生的事情
- en: Make the dependencies apparent
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让依赖关系显而易见
- en: Do nothing and pray for the best
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么都不做，祈求最好的结果
- en: The last option is clearly better in the really short term, but you might get
    bitten real hard. The first option might seem better, but what about your colleague
    who will also need to use this function somewhere else in the application, will
    they need to follow the same path as you?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项在短期内显然更好，但你可能会受到严重的打击。第一个选项可能看起来更好，但你的同事在应用程序的其他地方也需要使用这个函数，他们需要像你一样遵循相同的路径吗？
- en: The second option is probably the most difficult one, and it will require tremendous
    effort in the beginning because we are not at all accustomed to doing it this
    way. But the benefits will start to pile up as soon as you have finished. And
    it gets a lot easier with experience.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项可能是最困难的，因为一开始需要付出巨大的努力，因为我们根本不习惯这样做。但一旦你完成了，好处就会开始积累。并且随着经验的增加，这将变得更容易。
- en: What about encapsulation?
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装呢？
- en: Encapsulation is about hiding implementation detail. Purity is about making
    hidden dependencies known. Both are useful, good practices and they aren't in
    any kind of conflict. You can achieve both if you are careful enough and this
    is usually what functional programmers strive for. They like clean, simple solutions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是为了隐藏实现细节。纯度是为了让隐藏的依赖关系变得明显。这两者都是有用的，是良好的实践，它们并不冲突。如果你足够小心，你可以同时实现这两者，这通常是函数式程序员所追求的。他们喜欢简洁、简单的解决方案。
- en: 'To explain this in simple terms:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，这就是解释：
- en: Encapsulation is about hiding internal implementation
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装是为了隐藏内部实现
- en: Avoiding side causes is about making external inputs known
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免副作用是为了让外部输入变得明显
- en: Avoiding side effects is about making external changes known
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免副作用是为了让外部变化变得明显
- en: Spotting side causes
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现副作用的原因
- en: Let's get back to our `getCurrentTvProgram` function. The implementation that
    follows isn't pure, can you spot why?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`getCurrentTvProgram`函数。接下来的实现并不纯净，你能发现原因吗？
- en: 'To help you a bit, I will tell you that what we''ve learned so far about pure
    functions implies that they always return the same result when called with the
    same arguments:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你一点，我会告诉你到目前为止我们所学到的关于纯函数的东西意味着当使用相同的参数调用时，它们总是返回相同的结果：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Got it? Our suspect is the call to the `time()` method. Because of it, if you
    call the function at a different time, you will get different results. Let''s
    fix this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 明白了吗？我们的嫌疑对象是对`time()`方法的调用。因为如果你在不同的时间调用该函数，你会得到不同的结果。让我们来修复这个问题：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Not only is our function now pure, which is clearly an achievement in itself,
    we have just gained two benefits:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数不仅是纯净的，这本身就是一个成就，我们还获得了两个好处：
- en: We can now get the program for any time of the day as implied by the name change
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以根据名称更改隐含的意思来获取任何时间的节目
- en: The function can now be tested without having to use some kind of magic trick
    to change the current time
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在可以测试该函数，而无需使用某种魔术技巧来改变当前时间
- en: 'Let''s quickly look at some other examples of side causes. Try to spot the
    issue yourself as an exercise before reading:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一些其他副作用的例子。在阅读之前，尝试自己找出问题：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The use of the `global` keyword makes it pretty obvious that the first function
    uses some variable from the global scope, thus making the function impure. The
    key takeaway from this example is that PHP scoping rules work to our advantage.
    Any function where you can spot this keyword is most probably impure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`global`关键字很明显地表明第一个函数使用了全局范围的某个变量，因此使函数不纯。从这个例子中可以得出的关键点是PHP作用域规则对我们有利。任何你能发现这个关键字的函数很可能是不纯的。
- en: The static keyword in the second example is a good indicator that we might try
    to store a state between function calls. In this example, it is a counter that
    is incremented at each run. The function is clearly impure. However, contrary
    to the `global` variable, the use of the `static` keyword might only be a way
    to cache data between calls, so you will have to check why it is used before drawing
    a conclusion.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例中的静态关键字是一个很好的指示，表明我们可能会尝试在函数调用之间存储状态。在这个例子中，它是一个在每次运行时递增的计数器。该函数显然是不纯的。然而，与`global`变量相反，使用`static`关键字可能只是一种在调用之间缓存数据的方式，因此在得出结论之前，您将不得不检查为什么使用它。
- en: The third function is without a doubt impure because some database access is
    made. You might ask yourself how to get data from a database or the user if you
    are only allowed pure functions. The sixth chapter will dig deeper into this subject
    if you want to write purely functional code. If you can't or won't be functional
    all the way, I suggest you regroup your impure calls as much as possible and then
    try to call only pure functions from there to limit the place where you have side
    cause and side effects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个函数毫无疑问是不纯的，因为进行了一些数据库访问。如果您只允许使用纯函数，您可能会问自己如何从数据库或用户那里获取数据。如果您想编写纯函数式代码，第六章将更深入地探讨这个主题。如果您无法或不愿意完全使用函数式编程，我建议您尽可能将不纯的调用分组，然后尝试从那里仅调用纯函数，以限制产生副作用的地方。
- en: Concerning the fourth function, you cannot tell if it is pure just by looking
    at it. You will have to look at the code of the methods that are called. This
    is what you will encounter in most cases, a function calling other functions and
    methods, which you will also have to read in order to determine purity.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第四个函数，仅仅通过查看它，您无法确定它是否是纯的。您将不得不查看被调用的方法的代码。在大多数情况下，您将遇到这种情况，一个函数调用其他函数和方法，您也将不得不阅读以确定纯度。
- en: Spotting side effects
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现副作用
- en: Usually a spotting side effects is a bit easier than spotting side causes. Anytime
    you change a value that will have visible effects on the outside, or call another
    function in doing so, you are creating a side effect.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，发现副作用比发现副因更容易。每当您更改一个将对外部产生可见影响的值，或者在这样做时调用另一个函数，您都会产生副作用。
- en: 'If we go back to our two `increment` functions previously defined, what would
    you say about them? Consider the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到之前定义的两个`increment`函数，您对它们有什么看法？考虑以下代码：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first one clearly has a side effect on the global variable. But what about
    the second version? The variable itself is not accessible from the outside, so
    could we consider that the function is free of side-effects? The answer is no.
    Since the change implies that a following call to the function will return another
    value, this also qualifies as a side effect.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数显然对全局变量产生了副作用。但第二个版本呢？变量本身无法从外部访问，所以我们能认为该函数是没有副作用的吗？答案是否定的。因为更改意味着对函数的后续调用将返回另一个值，这也属于副作用。
- en: 'Let''s look at some functions to see if you can spot the side effects:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些函数，看看您是否能发现副作用：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first function obviously has a side effect because we update a value in
    the database.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数显然有副作用，因为我们更新了数据库中的值。
- en: The second method prints something to the screen. Usually this is considered
    a side effect because the function has an effect on something outside its scope,
    in our case, the screen.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法向屏幕打印了一些内容。通常这被认为是一个副作用，因为该函数对其范围之外的东西产生了影响，也就是我们的情况下，屏幕。
- en: Finally, the last function probably has side effects. This is a good, educated
    guess based on the name of the methods. But we can't say for sure until we've
    seen the code of the methods to verify it. As when spotting side causes, you will
    often have to dig a little deeper than just the one function in order to ascertain
    if it causes side effects or not.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一个函数可能会产生副作用。这是一个很好的、基于方法名称的猜测。但在我们看到方法的代码以验证之前，我们不能确定。当发现副作用时，通常需要深入挖掘，而不仅仅是一个函数，以确定它是否会产生副作用。
- en: What about object methods?
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象方法呢？
- en: In a purely functional language, as soon as you need to change a value inside
    an object, an array or any kind of collection, you will in fact return a copy
    with the new value. This means any method, such as the `updateScore` method, for
    example, will not modify an inner property of the object, but will return a new
    instance with the new score.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个纯粹的函数式语言中，一旦需要更改对象、数组或任何类型的集合中的值，实际上会返回一个具有新值的副本。这意味着任何方法，例如`updateScore`方法，都不会修改对象的内部属性，而是会返回一个具有新分数的新实例。
- en: This may not seem practical at all, and given the possibilities offered by PHP
    out of the box, I agree with you. However, we will see that there are some functional
    techniques that really help to manage this.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来一点也不实用，鉴于PHP本身提供的可能性，我同意。然而，我们将看到一些真正有助于管理这一点的函数式技术。
- en: 'Another option would be to decide that the instance is not the same value after
    a change. In a way, this is already the case with PHP. Consider the following
    example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是决定实例在更改后不是相同的值。在某种程度上，这已经是PHP的情况。考虑以下示例：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When doing a simple equality comparison between two objects, PHP considers the
    inner value and not the instances themselves to make the comparison. It's important
    to note that as soon as you use a strict comparison (such as, using the `===`
    operator), PHP verifies that both variables hold the same instance, returning
    the`'different'` string in all three cases.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行简单的对象相等比较时，PHP考虑的是内部值而不是实例本身来进行比较。重要的是要注意，一旦使用严格比较（例如使用`===`运算符），PHP会验证两个变量是否持有相同的实例，在所有三种情况下返回`'different'`字符串。
- en: However, this is incompatible with the idea of referential transparency, which
    we will discuss later in this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这与引用透明的概念是不兼容的，我们将在本章后面讨论。
- en: Closing words
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束语
- en: As we tried to show in the preceding examples, trying to determine if a function
    is pure or not can be tricky in the beginning. But as you start to get a feel
    for it, you will be a lot quicker and comfortable.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的例子中所尝试展示的，尝试确定一个函数是否是纯函数可能在开始时会有些棘手。但是当你开始对此有所感觉时，你会变得更快更舒适。
- en: 'The best course of action to check whether a function is pure is to verify
    the following :'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 检查函数是否是纯函数的最佳方法是验证以下内容：
- en: The use of the global keyword is a dead give away
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全局关键字是一个明显的暴露
- en: Check if you use any value that is not a parameter of the function itself
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否使用了任何不是函数本身参数的值
- en: Verify that all functions called by yours are also pure
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证你的函数调用的所有函数也都是纯函数
- en: Any access to outside storage is impure (database and files)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何对外部存储的访问都是不纯的（数据库和文件）
- en: Pay special attention to functions whose return value depends on an outside
    state (`time`, `random`)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别注意那些返回值依赖于外部状态（`time`，`random`）的函数
- en: Now that you know how to spot those impure functions, you might be wondering
    how to make them pure. There is no easy answer to this request sadly. The following
    chapters will try to give recipes and patterns to avoid impurity.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何发现那些不纯的函数了，你可能想知道如何使它们成为纯函数。遗憾的是，对于这个请求并没有简单的答案。接下来的章节将尝试提供避免不纯性的配方和模式。
- en: Immutability
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性
- en: We say a variable is immutable if, once it has been assigned a value, you cannot
    change its content. After function purity, this is the second most important thing
    about functional programming.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说一个变量是不可变的，如果它一旦被赋值，就不能改变其内容。在函数纯度之后，这是函数式编程中第二重要的事情。
- en: In some academic languages such as **Haskell**, you cannot declare variables
    at all. Everything has to be a function. Since all those functions are also pure,
    this means you have immutability for free. Some of these languages offers some
    kind of syntactic sugar that resembles variable declaration to avoid the potential
    tediousness of always declaring functions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些学术语言中，比如**Haskell**，你根本无法声明变量。一切都必须是函数。由于所有这些函数也都是纯函数，这意味着你可以免费获得不可变性。其中一些语言提供了一些类似变量声明的语法糖，以避免总是声明函数可能带来的繁琐。
- en: Most functional languages let you only declare immutable variables or constructs
    that serves the same purpose. This means you have a way of storing values but
    it is impossible to change the value after the initial assignment. There are also
    languages that let you choose what you want for each variable. In Scala, for example,
    you have the `var` keyword to declare traditional mutable variables and the `val`
    keyword to declare immutable variables.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数函数式语言只允许声明不可变变量或具有相同目的的构造。这意味着你有一种存储数值的方式，但是在初始赋值后无法更改数值。也有一些语言让你为每个变量选择你想要的方式。例如，在Scala中，你可以使用`var`关键字声明传统的可变变量，使用`val`关键字声明不可变变量。
- en: Most languages however, as is the case for PHP, have no notion of immutability
    for variables.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数语言，比如PHP，对变量没有不可变性的概念。
- en: Why does immutability matter?
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么不可变性很重要？
- en: First of all, it helps to reduce cognitive burden. It's already quite hard to
    keep in mind all the variables involved in an algorithm. Without immutability
    you also need to remember all value changes. It's a lot easier for the human mind
    to associate a value to a particular label (that is the variable name). If you
    can be sure that the value won't change, it will be a lot easier to reason about
    what is happening.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它有助于减少认知负担。在算法中记住所有涉及的变量已经相当困难了。没有不可变性，你还需要记住所有值的变化。对于人类大脑来说，将一个值与特定标签（即变量名）关联起来要容易得多。如果你能确信数值不会改变，推理发生的事情就会容易得多。
- en: Also, if you have some global state you can't get rid of, as long as it is immutable,
    you can just note the values on a piece of paper near you and keep it for reference.
    Whatever happens during execution, what is written will always be the current
    state of the program, meaning you don't have to fire up a debugger or echo the
    variable to ensure that the value has not changed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你有一些全局状态是无法摆脱的，只要它是不可变的，你可以在你附近的一张纸上记录数值并保留以供参考。无论执行过程中发生了什么，所写的内容始终是程序的当前状态，这意味着你不必启动调试器或回显变量来确保数值没有改变。
- en: Imagine that you pass an object to a function. You don't know whether the function
    is pure or not, meaning the object properties could be changed. This introduces
    worry in your mind and distracts you from your line of thought. The fact that
    you have to ask yourself if an internal state has changed, reduces your ability
    to reason about your code. If your object is immutable, you can be 100% assured
    that it is exactly as it was before, speeding up your understanding of what is
    happening.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你将一个对象传递给一个函数。你不知道这个函数是否是纯函数，也就是说对象的属性可能会被改变。这会让你感到担忧，分散你的思绪。你必须问自己内部状态是否改变，这降低了你推理代码的能力。如果你的对象是不可变的，你可以百分之百地确信它和以前一样，加快你对发生的事情的理解。
- en: You also have advantages linked to thread safety and parallelization. If all
    your state is immutable, is is much easier to ensure your program will be able
    to run on multiple cores or computers at the same time. Most concurrency issues
    happens because some thread modified a value without correctly synchronizing with
    other threads. This leads to inconsistency between them, and often, error in computations.
    If your variables are immutable, as long as all threads were sent the same data,
    this scenario is a lot less likely to happen. This is however not really useful
    as PHP is primarily used in non-threaded scenarios.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以获得与线程安全和并行化相关的优势。如果你的所有状态都是不可变的，那么确保你的程序能够在多个核心或多台计算机上同时运行就会更容易得多。大多数并发问题发生在某个线程在没有正确与其他线程同步的情况下修改了一个值。这导致它们之间的不一致，通常会导致计算错误。如果你的变量是不可变的，只要所有线程都收到了相同的数据，这种情况发生的可能性就会小得多。然而，由于PHP主要用于非线程场景，这并不是真正有用的。
- en: Data sharing
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据共享
- en: Another benefit of immutability is that when it is enforced by the language
    itself, the compiler can perform an optimization called **data sharing**. Since
    PHP does not support this yet, I will only present it in a few words.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性的另一个好处是，当语言本身强制执行时，编译器可以执行一种称为**数据共享**的优化。由于PHP目前还不支持这一点，我只会简单介绍一下。
- en: Data sharing is the process of sharing a common memory location for multiple
    variables containing the same data. This allows for smaller memory footprints,
    and "copying" data from one variable to another with almost no cost at all.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 数据共享是共享一个公共内存位置，用于包含相同数据的多个变量。这允许更小的内存占用，并且几乎没有成本地将数据从一个变量复制到另一个变量。
- en: 'For example, imagine the following piece of code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下以下代码片段：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In PHP, each new variable will be a new copy of the data. Meaning we have a
    memory and time cost that could become problematic the bigger our array is.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，每个新变量都将是数据的一个新副本。这意味着我们有一个内存和时间成本，当我们的数组越大时，这可能会成为一个问题。
- en: A functional language might, using clever techniques, only store the data once
    in memory and then describe using another mean which part of the data each variable
    contains. This will still require some computation, but with big structures you
    will gain a lot of memory and time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用巧妙的技术，函数式语言可能只在内存中存储一次数据，然后使用另一种方式描述每个变量包含的数据部分。这仍然需要一些计算，但对于大型结构，你将节省大量内存和时间。
- en: Such optimizations are also implementable in non-immutable languages. But it's
    often not done because you have to keep track of each write access to each variable
    to ensure data coherence. The implied complexity for the compiler is thought to
    outweigh the benefits of such an approach.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的优化也可以在非不可变语言中实现。但通常不这样做，因为你必须跟踪每个变量的每次写访问，以确保数据的一致性。编译器的隐含复杂性被认为超过了这种方法的好处。
- en: However, the time and memory penalty is not big enough in PHP to warrant avoiding
    using immutability. PHP has a pretty good garbage collector, meaning the memory
    is cleaned up pretty efficiently when an object is not used anymore. Also we often
    work with relatively small data structures, meaning the creation of nearly identical
    data is quite fast.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PHP中，时间和内存开销并不足以避免使用不可变性。PHP有一个相当不错的垃圾收集器，这意味着当对象不再使用时，内存会被清理得相当有效。而且我们通常使用相对较小的数据结构，这意味着几乎相同数据的创建速度相当快。
- en: Using constants
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用常量
- en: You could use constants and class constants to have some kind of immutability,
    but they work only for scalar values. You currently have no way to use them for
    objects or more complex data structures. Since it's the only available option
    out-of-the-box, let's have a look anyway.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用常量和类常量来实现某种不可变性，但它们只适用于标量值。目前，你无法将它们用于对象或更复杂的数据结构。由于这是唯一可用的选项，让我们还是来看一下吧。
- en: You can declare globally available constants containing any scalar value. Beginning
    with PHP 5.6, you can also store an array of scalar values inside constants when
    using the `const` keyword and, since PHP 7, it also works with the define syntax.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以声明包含任何标量值的全局可用常量。从PHP 5.6开始，当使用`const`关键字时，你还可以在常量中存储标量值的数组，并且自PHP 7开始，使用定义语法也可以。
- en: 'Constant names must start with a letter or an underscore, not a number. Usually,
    constants are in full caps so they can be easily spotted. It is also discouraged
    to begin with an underscore as it may collide with any constant defined by the
    PHP core:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 常量名称必须以字母或下划线开头，不能以数字开头。通常，常量都是大写的，这样它们就很容易被发现。以下划线开头也是不鼓励的，因为它可能与PHP核心定义的任何常量发生冲突：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can use the result of a function to populate the constant. This is possible
    only when using the defined syntax, however. If you use the `const` keyword you
    must use a scalar value directly:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用函数的结果来填充常量。但这只在使用定义的语法时才可能。如果你使用`const`关键字，你必须直接使用标量值：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you try to access a constant that does not exist, PHP will assume that you
    are in fact trying to use the value as a string:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试访问一个不存在的常量，PHP将假定你实际上是在尝试将该值用作字符串：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This can be pretty misleading, as the assumed string will evaluate to `true`,
    potentially breaking your code if you expected your constant to hold a `false`
    value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会非常误导，因为假定的字符串将计算为`true`，如果你期望你的常量保存一个`false`值，这可能会破坏你的代码。
- en: 'If you want to avoid this pitfall, you can use the defined or constant function.
    Sadly, this will add a lot of verbosity:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想避免这种陷阱，你可以使用defined或constant函数。遗憾的是，这将增加很多冗余性：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'PHP also allows you to declare constants inside of classes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: PHP还允许在类内部声明常量：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Sadly, you can only use scalar values directly when doing so; there is no way
    to use the return value of a function, as is the case with the `define` keyword:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，当这样做时，你只能直接使用标量值；无法使用函数的返回值，就像`define`关键字一样：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, beginning with PHP 5.6, you can use any scalar expression or previously
    declared constants with the `const` keyword:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从PHP 5.6开始，你可以使用任何标量表达式或先前声明的常量与`const`关键字一起使用：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There is also one other fundamental difference between constants and variables
    besides their immutability. The usual scoping rule does not apply. You can use
    a constant anywhere in your code as soon as it is declared:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它们的不可变性之外，常量和变量之间还有另一个基本区别。通常的作用域规则不适用。只要常量被声明，你就可以在代码中的任何地方使用它：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At the time of writing, PHP 7.1 is still in the beta phase. The release is
    planned at the end of fall 2016\. This new version will introduce class constants
    visibility modifiers:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，PHP 7.1仍处于测试阶段。发布计划于2016年秋末。这个新版本将引入类常量可见性修饰符：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A final word of warning. Although they are immutable, constants are global, and
    this makes them a state of your application. Any function using a constant is
    de facto impure, so you should use them with caution.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后警告一句。尽管它们是不可变的，但常量是全局的，这使它们成为你的应用程序的状态。任何使用常量的函数实际上都是不纯的，因此你应该谨慎使用它们。
- en: An RFC is on its way
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RFC正在进行中。
- en: As we just saw, constants, are at best, a wooden leg when it comes to immutability.
    They're quite alright to store simple information like the number of items we
    want displayed per page. But as soon as you want to have some complex data structures
    you will be stuck.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，常量在不可变性方面充其量只是一个木腿。它们非常适合存储诸如我们希望每页显示的项目数量之类的简单信息。但是一旦您想要有一些复杂的数据结构，您将会陷入困境。
- en: Fortunately, members of the PHP core team are well aware that immutability is
    important and there is currently some work being done on an RFC to include it
    at the language level ([https://wiki.php.net/rfc/immutability](https://wiki.php.net/rfc/immutability)).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，PHP核心团队的成员们都很清楚不可变性的重要性，目前正在进行一项RFC的工作，以在语言级别包含它（[https://wiki.php.net/rfc/immutability](https://wiki.php.net/rfc/immutability)）。
- en: For those not privy to the process involved for new PHP features, a **Request
    for Comment** (**RFC**), is a proposition from on the core team members to add
    something new to PHP. The proposition first gets through a draft phase, where
    it is written and some example implementation is done. Afterwards, there is a
    discussion phase where other people can give advice and recommendation. Finally,
    a vote occurs to decide whether the feature will be included in the next PHP version.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不了解新PHP功能涉及的流程的人来说，**请求评论**（**RFC**）是核心团队成员提出向PHP添加新内容的建议。该建议首先经过草案阶段，在此阶段编写并进行了一些示例实现。之后，进行讨论阶段，其他人可以提供建议和建议。最后，进行投票决定是否将该功能包含在下一个PHP版本中。
- en: At the time of writing, the *Immutable classes and properties* RFC is still
    in draft phase. There was no real argument either for or against it. Only time
    will tell if it is accepted or not.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，*不可变类和属性* RFC仍处于草案阶段。对此既没有真正的赞成意见，也没有反对意见。只有时间会告诉我们它是否被接受。
- en: Value objects
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值对象
- en: 'From [https://en.wikipedia.org/wiki/Value_object](https://en.wikipedia.org/wiki/Value_object):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[https://en.wikipedia.org/wiki/Value_object](https://en.wikipedia.org/wiki/Value_object)：
- en: '*In computer science, a value object is a small object that represents a simple
    entity whose equality is not based on identity: i.e. two value objects are equal
    when they have the same value, not necessarily being the same object.*'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在计算机科学中，值对象是表示简单实体的小对象，其相等性不是基于标识的：即两个值对象在具有相同值时是相等的，不一定是相同的对象。*'
- en: '>'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*[...]*'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*[...]*'
- en: '>'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Value objects should be immutable: this is required for the implicit contract
    that two value objects created equal, should remain equal. It is also useful for
    value objects to be immutable, as client code cannot put the value object in an
    invalid state or introduce buggy behavior after instantiation.*'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*值对象应该是不可变的：这是两个相等的值对象的隐式契约所要求的，应该保持相等。值对象不可变也是有用的，因为客户端代码不能在实例化后将值对象置于无效状态或引入错误行为。*'
- en: 'Since there is no mean to obtain real immutability in PHP, it is often achieved
    by having private properties and no setter on the class. Thus forcing the developer
    to create a new object when they want to modify a value. The class can also provide
    utility methods to ease the creation of new objects. Let''s look at a short example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在PHP中无法获得真正的不可变性，通常通过在类上具有私有属性和没有setter来实现。因此，当开发人员想要修改值时，强制他们创建一个新对象。该类还可以提供实用方法来简化新对象的创建。让我们看一个简短的例子：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This kind of pattern can be used to create data entities that are immutable
    from the point of view of the data consumer. However, you will have to take special
    care to guarantee that all the methods on the class do not break the immutability;
    otherwise all your efforts will be moot.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可以用于创建从数据使用者的角度来看是不可变的数据实体。但是，您必须特别小心，以确保类上的所有方法都不会破坏不可变性；否则，您所有的努力都将是徒劳的。
- en: 'Besides immutability, using value objects has other benefits as well. You can
    add some business or domain logic inside the object, thus keeping everything related
    in the same place. Also, if you use them instead of arrays, you can:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了不可变性之外，使用值对象还有其他好处。您可以在对象内部添加一些业务或领域逻辑，从而将所有相关内容保持在同一位置。此外，如果您使用它们而不是数组，您可以：
- en: Use them as type hint instead of simply array
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将它们用作类型提示，而不仅仅是数组
- en: Avoid any possible error due to a misspelled array key
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免由于拼写错误的数组键而导致任何可能的错误
- en: Enforce the presence or format of some items
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制存在或格式化某些项目
- en: Provide methods that format your values for different context
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供格式化值以适应不同上下文的方法
- en: A common use of value objects is to store and manipulate money related data.
    You can have a look at [http://money.rtfd.org](http://money.rtfd.org) which is
    a great example of how to efficiently use them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象的常见用途是存储和操作与货币相关的数据。您可以查看[http://money.rtfd.org](http://money.rtfd.org)，这是一个很好的如何有效使用它们的示例。
- en: 'Another use of value objects for a really important piece of code is the **PSR-7:
    "HTTP message interfaces"**. This standard introduced and formalized a way for
    frameworks and applications to manage HTTP requests and responses in an inter-operable
    way. All major frameworks either have core support or plugins available. I invite
    you to read their full rationale as to why you should use immutability for such
    an important part of the PHP ecosystem: [http://www.php-fig.org/psr/psr-7/meta/#why-value-objects](http://www.php-fig.org/psr/psr-7/meta/#why-value-objects).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '另一个对于真正重要的代码片段使用值对象的例子是**PSR-7: "HTTP消息接口"**。这个标准引入并规范了一种框架和应用程序以可互操作的方式管理HTTP请求和响应的方法。所有主要的框架都有核心支持或可用的插件。我邀请您阅读他们为什么应该在PHP生态系统的如此重要的部分使用不可变性的完整理由：[http://www.php-fig.org/psr/psr-7/meta/#why-value-objects](http://www.php-fig.org/psr/psr-7/meta/#why-value-objects)。'
- en: In essence, modeling HTTP messages as value objects ensures the integrity of
    the message state, and prevents the need for bi-directional dependencies, which
    can often go out of sync or lead to debugging or performance issues.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，将HTTP消息建模为值对象可以确保消息状态的完整性，并且可以避免双向依赖的需要，这往往会导致不同步或导致调试或性能问题。
- en: All in all, value objects are a good way to obtain some kind of immutability
    in PHP. You don't get all the benefits, especially those related to performance,
    but most of the cognitive burden is removed. Going further on this topic is out
    of the scope of this book; if you want to learn more, there is a dedicated website: [http://www.phpvalueobjects.info/](http://www.phpvalueobjects.info/).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，值对象是在PHP中获得某种不可变性的好方法。您不会获得所有的好处，特别是与性能相关的好处，但大部分认知负担都被移除了。进一步探讨这个话题超出了本书的范围；如果您想了解更多，可以访问专门的网站：[http://www.phpvalueobjects.info/](http://www.phpvalueobjects.info/)。
- en: Libraries for immutable collections
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变集合的库
- en: 'If you want to go further down the path of immutability, there are at least
    two libraries that offer immutable collections: **Laravel Collections** and **immutable.php**.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想进一步走向不可变性之路，至少有两个库提供不可变集合：**Laravel集合**和**immutable.php**。
- en: Both these libraries harmonize the discrepancies regarding the parameters order
    for array-related PHP functions such as `array_map` and `array_filter`. They also
    provide the possibilities to work with any kind of `Iterable` or `Traversable`;
    easily contrary to most PHP functions which require a real array.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个库都协调了与数组相关的PHP函数的参数顺序的差异，比如`array_map`和`array_filter`。它们还提供了与大多数PHP函数相反的工作任何类型的`Iterable`或`Traversable`的可能性；这些函数通常需要一个真正的数组。
- en: This chapter will only present the libraries quickly. Example of usage will
    be given in [Chapter 3](ch03.html "Chapter 3.  Functional Basis in PHP"), *Functional
    Basis in PHP* so that they can be shown alongside other libraries that allow the
    performance of the same task. Also, we haven't yet covered in detail techniques
    such as mapping or folding, so examples might not be as clear as possible right
    now.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将只是快速介绍这些库。示例用法将在[第3章](ch03.html "第3章。PHP中的功能基础")中给出，*PHP中的功能基础*，以便它们可以与允许执行相同任务的其他库一起显示。此外，我们还没有详细介绍诸如映射或折叠等技术，因此示例可能不够清晰。
- en: Laravel Collection
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Laravel集合
- en: The Laravel framework contains a class called `Collection` to supersede PHP
    arrays. This class uses a simple array internally, but it can be created from
    any collection like variable using the collect helper function. It then proposes
    a lot of really useful methods to work with the data, mostly in a functional way.
    This is also a central part of Laravel, as **Eloquent**, the ORM, returns database
    entities as `Collection` instances.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel框架包含一个名为`Collection`的类，用于取代PHP数组。这个类在内部使用一个简单的数组，但可以使用collect辅助函数从任何集合类型的变量创建。然后，它提供了许多非常有用的方法来处理数据，主要以一种功能性的方式。这也是Laravel的一个核心部分，因为**Eloquent**，ORM，将数据库实体作为`Collection`实例返回。
- en: If you are not using Laravel, but still want to benefit from this great library,
    you can use [https://github.com/tightenco/collect](https://github.com/tightenco/collect),
    which is only the Collection part separated from the rest of the Laravel support
    package in order to remain small. You can also refer to the official documentation
    of the Laravel collection ([https://laravel.com/docs/5.3/collections](https://laravel.com/docs/5.3/collections)).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用Laravel，但仍希望从这个优秀的库中受益，您可以使用[https://github.com/tightenco/collect](https://github.com/tightenco/collect)，这只是从Laravel支持包的其余部分中分离出来的Collection部分，以保持小巧。您也可以参考Laravel集合的官方文档([https://laravel.com/docs/5.3/collections](https://laravel.com/docs/5.3/collections))。
- en: Immutable.php
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Immutable.php
- en: This library defines the `ImmArray` class, which implements an immutable array
    like collection.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库定义了`ImmArray`类，它实现了一个类似数组的不可变集合。
- en: The `ImmArray` class is a wrapper around the`SplFixedArray`class to fix some
    of the shortcomings of its API by providing methods for performance operation
    that you usually want to perform on collections. The advantage of using the `SplFixedArray`class
    behind the scenes is that the implementation is written in C and is really performant
    and memory efficient. You can refer to the GitHub repository for more insight
    on Immutable.php at [https://github.com/jkoudys/immutable.php](https://github.com/jkoudys/immutable.php).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImmArray`类是`SplFixedArray`类的包装器，用于修复其API的一些缺陷，提供了通常希望在集合上执行的性能操作的方法。在幕后使用`SplFixedArray`类的优势在于其实现是用C编写的，性能非常高且内存效率高。您可以参考GitHub存储库以获取有关Immutable.php的更多信息：[https://github.com/jkoudys/immutable.php](https://github.com/jkoudys/immutable.php)。'
- en: Referential transparency
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用透明度
- en: An expression is said to be referentially transparent if you can substitute
    it by its output at any time without changing the behavior of your program. In
    order to do that for all expressions of your code base, all your functions have
    to be pure and all your variables have to be immutable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码库中的所有表达式都可以在任何时候用其输出替换而不改变程序的行为，则该表达式被称为引用透明。为了做到这一点，您的所有函数都必须是纯函数，所有变量都必须是不可变的。
- en: 'What do we gain from referential transparency? Once again, it helps a lot with
    reducing cognitive burden. Let''s imagine we have the following functions and
    data:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从引用透明性中获得了什么？再一次，它有助于减少认知负担。让我们想象一下我们有以下函数和数据：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now let''s simulate a really simple brawl between two people:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们模拟两个人之间的一场非常简单的争吵：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All functions defined above are pure, and since we don't have mutable data structures,
    they are also referentially transparent by extension. Now, in order to better
    understand our piece of code, we can use a technique called **equational reasoning**.
    The idea is pretty simple, you simply substitute *equals for equals* to reason
    about code. In a way, it is like evaluating the code manually.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上面定义的所有函数都是纯函数，由于我们没有可变的数据结构，它们也是引用透明的。现在，为了更好地理解我们的代码片段，我们可以使用一种称为**等式推理**的技术。这个想法非常简单，你只需要用*等于替换等于*来推理代码。在某种程度上，这就像手动评估代码。
- en: 'Let''s start by inlining our `isCloseEnough` function. Doing so, our hit function
    can be transformed as such:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先将我们的`isCloseEnough`函数内联。这样做，我们的hit函数可以被转换为如下形式：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our data being immutable, we can now simply use the values as the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据是不可变的，现在我们可以简单地使用以下值：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s do some math:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一些数学：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The condition clearly evaluates to true so we can keep only the right branch:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 条件显然评估为true，所以我们只保留右分支：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s keep at it with the remaining function call:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行剩余的函数调用：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once again, we replace the values:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 再次替换值：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, our initial function call becomes:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的初始函数调用变成了：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By using the fact that you can replace a referentially transparent expression
    with its resulting value, we were able to reduce a relatively lengthy piece of
    code with multiple function calls to a simple object creation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用可以用其结果值替换引用透明表达式的事实，我们能够将一个相对冗长的代码片段减少到一个简单的对象创建。
- en: This ability applied to refactoring or understanding code is very useful. If
    you have trouble understanding some code and you know some part of it is pure,
    you can simply replace it with the result while you are trying to understand it.
    This will probably help you get to the heart of the matter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种能力应用于重构或理解代码非常有用。如果你在理解一些代码时遇到困难，并且你知道其中的一部分是纯的，你可以在尝试理解它时简单地用结果替换它。这可能会帮助你找到问题的核心。
- en: Non-strictness or lazy evaluation
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非严格性或惰性评估
- en: One of the great benefits of referential transparency is the possibility for
    a compiler or parser to evaluate values lazily. For example, Haskell allows you
    to have an infinite list defined by a mathematical function. The lazy nature of
    the language ensures that values of the list will be computed only when you need
    the value.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 引用透明性的一个巨大好处是编译器或解析器可以惰性地评估值的可能性。例如，Haskell允许你通过数学函数定义无限列表。语言的惰性特性确保列表的值只在需要值时才计算。
- en: In the glossary, we defined non-strict languages as languages where evaluation
    happens lazily. In fact, there's a slight difference between laziness and non-strictness.
    If you are interested in the details, you can head to [https://wiki.haskell.org/Lazy_vs._non-strict](https://wiki.haskell.org/Lazy_vs._non-strict)
    and read about it. For the purpose of this book, we will use those terms interchangeably.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在术语表中，我们将非严格语言定义为评估发生惰性的语言。事实上，惰性和非严格性之间有一些细微差别。如果你对细节感兴趣，你可以访问[https://wiki.haskell.org/Lazy_vs._non-strict](https://wiki.haskell.org/Lazy_vs._non-strict)并阅读相关内容。在本书的目的上，我们将这些术语互换使用。
- en: You might ask yourself how this can be useful. Let's gloss over use cases.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己这有什么用。让我们简单地看一下用例。
- en: Performance
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能
- en: 'By using lazy evaluation, you ensure that only the values that are needed are
    effectively computed. Let''s have a look at a short and naive example to illustrate
    this benefit:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用惰性评估，你确保只有需要的值才会被有效计算。让我们看一个简短而天真的例子来说明这个好处：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since PHP does not perform lazy evaluation on function parameters, when calling
    `do_something` you will first have to wait two times 10 seconds before even starting
    to execute the function. If PHP were a non-strict language, only the value we
    need would have been computed, thus dividing by two the time needed. It gets even
    better, since the return value isn't even saved in a new variable, it might be
    possible to not execute the function at all.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PHP在函数参数上不执行惰性评估，当调用`do_something`时，你首先必须等待两次10秒，然后才能开始执行函数。如果PHP是一种非严格语言，只有我们需要的值才会被计算，从而将所需的时间减少了一半。情况甚至更好，因为返回值甚至没有保存在一个新变量中，可能根本不需要执行函数。
- en: 'There is one case where PHP performs a kind of lazy evaluation: Boolean operator
    short-circuits. When you have a series of Boolean operations, as soon as PHP can
    be certain of the outcome, it will stop the execution:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: PHP有一种情况下执行一种惰性评估：布尔运算符短路。当你有一系列布尔操作时，只要PHP能够确定结果，它就会停止执行：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We could rewrite our previous example to take advantage of that. But as you
    can see in the following example, it is at the expense of readability. Also, our
    example was really simple, not something you would encounter in real-life application
    code. Imagine doing the same for some complex function with multiple possible
    branches? This is shown in the following snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重写我们之前的例子以利用这一点。但正如你在下面的例子中看到的，这是以可读性为代价的。此外，我们的例子真的很简单，不是你在现实生活应用代码中会遇到的东西。想象一下为具有多个可能分支的复杂函数做同样的事情？这在下面的片段中显示：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There are also two bigger issues with the previous code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码还有两个更大的问题：
- en: If, for any reason, the first call to sleep returns a false value, the second
    call will also be executed
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果由于任何原因，第一次调用sleep返回false值，第二次调用也将被执行
- en: The return value of your methods will automatically be cast to Boolean
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的方法的返回值将自动转换为布尔值
- en: Code readability
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码可读性
- en: 'When your variable and function evaluation are lazy, you can spend less time
    considering which is the best order of declaration, or even whether the data you
    are computing will be used at all. Instead, you can concentrate on writing readable
    code. Imagine a blogging application with lots of posts, tags, categories, and
    archived by year. Would you rather have to write custom queries for each page,
    or use lazy evaluation, demonstrated as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的变量和函数评估是惰性的时，你可以花更少的时间考虑声明的最佳顺序，甚至你计算的数据是否会被使用。相反，你可以专注于编写可读的代码。想象一个博客应用程序有很多帖子、标签、类别，并按年份存档。你是想为每个页面编写自定义查询，还是使用惰性评估，如下所示：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To be clear, this code would probably work just fine if we loaded all posts
    into `$posts`, but the performance would be pretty bad. However, if we had lazy
    evaluation and an ORM powerful enough, the database queries could be delayed to
    the last moment. At that time, we would know exactly the data we need and the
    SQL will be tailored for this exact page automatically, leaving us with easy to
    read code and great performance.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 清楚地说，如果我们将所有帖子加载到`$posts`中，这段代码可能会工作得很好，但性能会非常糟糕。然而，如果我们有惰性评估和足够强大的ORM，数据库查询可以延迟到最后一刻。那时，我们将确切地知道我们需要的数据，SQL将自动为这个确切的页面定制，使我们拥有易于阅读的代码和出色的性能。
- en: As far as I can tell, this idea is purely hypothetical. I am not currently aware
    of any ORM powerful enough, even in the most functional languages, to attain this
    level of laziness. But wouldn't it be great if it were?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 据我所知，这个想法纯粹是假设的。我目前并不知道有任何ORM足够强大，即使在最功能强大的语言中，也无法达到这种程度的懒惰。但如果可以的话，那不是很好吗？
- en: If you are wondering about the syntax used in the example, it is inspired by
    the API of the Laravel's Collection we were discussing earlier.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对示例中使用的语法感到困惑，那是受到了我们之前讨论的Laravel的Collection的API的启发。
- en: Infinite lists or streams
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无限列表或流
- en: Lazy evaluation allows you to create infinite lists. In Haskell, to get the
    list of all positive integers, you can simply do `[1..]`. Then, if you want the
    first ten numbers, you can take `10 [1..]`. I admit this example isn't very exciting,
    but more complicated ones are more difficult to understand.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性求值允许你创建无限列表。在Haskell中，要获取所有正整数的列表，你可以简单地使用`[1..]`。然后，如果你想要前十个数字，你可以取`10 [1..]`。我承认这个例子并不是很令人兴奋，但更复杂的例子更难理解。
- en: 'PHP supports generators since version 5.5\. You can achieve something akin
    to infinite lists by using them. For example, our list of all positive integers
    is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: PHP自版本5.5起支持生成器。你可以通过使用它们来实现类似无限列表的东西。例如，我们所有正整数的列表如下：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: However, there is at least one notable difference between the lazy infinite
    list and our generator. You can perform any operation you would normally perform
    on collections with the Haskell version-computing its length and sorting it, for
    example. Whereas our generator is an `Iterator` and if you try to use say `iterator_to_array`
    on it there's a good chance that your PHP process will hang until you run out
    of memory.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，懒惰无限列表和我们的生成器之间至少有一个显著的区别。你可以对Haskell版本执行任何你通常对集合执行的操作-例如计算其长度和对其进行排序。而我们的生成器是一个`Iterator`，如果你尝试在其上使用`iterator_to_array`，你的PHP进程很可能会一直挂起，直到内存耗尽。
- en: How can you compute the length of an infinite list or sort it you ask me? It
    is in fact pretty simple; Haskell will only compute list values until it has enough
    to perform its computation. Say we have the the condition `count($list) < 10` in
    PHP, even if you have an infinite list, Haskell will stop counting items as soon
    as you reach 10 because it will have an answer for the comparison at that time.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你问我如何计算无限列表的长度或对其进行排序？实际上很简单；Haskell只会计算列表值，直到它有足够的值来执行计算。比如我们在PHP中有条件`count($list)
    < 10`，即使你有一个无限列表，Haskell会在达到10时停止计数，因为它在那时就会有一个比较的答案。
- en: Code optimization
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码优化
- en: 'Have a look at the next piece of code and try deciding which is faster:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的代码，然后尝试决定哪个更快：
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Version 2 should be a lot faster. Because you only compute the length of the
    array once, whereas in version 1, PHP has to compute the length each time it verifies
    the condition for the for loop. This example is pretty simple, but there are some
    cases where such a pattern is harder to spot. If you have referential transparency,
    this does not matter. The compiler can perform this optimization on its own. Any
    referentially transparent computation can be moved around without changing the
    result of the program. This is possible because we have the guarantee that the
    execution of each function does not depend on a global state. Thus, moving computation
    around to achieve better performance is possible without changing the outcome.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 版本2应该快得多。因为你只计算数组的长度一次，而在版本1中，PHP必须在每次验证for循环的条件时计算长度。这个例子很简单，但有些情况下这样的模式更难发现。如果你有引用透明性，这并不重要。编译器可以自行执行这种优化。任何引用透明的计算都可以在不改变程序结果的情况下移动。这是可能的，因为我们保证每个函数的执行不依赖于全局状态。因此，移动计算以实现更好的性能是可能的，而不改变结果。
- en: 'Another possible improvement is performing common sub expression elimination
    or CSE. Not only can the compiler move part of the code more freely, it can also
    transform some operations that share a common computation to use an intermediary
    value instead. Imagine the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的改进是执行常见子表达式消除或CSE。编译器不仅可以更自由地移动代码的一部分，还可以将一些共享公共计算的操作转换为使用中间值。想象一下以下代码：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If computing `$foo * $bar` has a big cost, the compiler could decide to transform
    it by using an intermediary value:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计算`$foo * $bar`的成本很高，编译器可以决定通过使用中间值来转换它：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Again, this is quite a simple example. This kind of optimization could be performed
    on the whole span of the code base.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这只是一个很简单的例子。这种优化可以在整个代码库的范围内进行。
- en: Memoization
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记忆化
- en: Memoization is a technique where you cache the results of a function for a given
    set of parameters so that you don't have to perform it again on the next call.
    We will see this in detail in [Chapter 8](ch09.html "Chapter 9.  Performance Efficiency"),
    *Performance Efficiency*. For now, let me just say that if your language only
    possesses referentially transparent expressions, it can perform memoization automatically
    when needed.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化是一种技术，它可以缓存给定参数集的函数的结果，这样你就不必在下一次调用时再次执行它。我们将在[第8章](ch09.html "第9章。性能效率")*性能效率*中详细讨论这个问题。现在，让我只说一下，如果你的语言只具有引用透明表达式，它可以在需要时自动执行记忆化。
- en: This means it can decide, based on the frequency of calls and various other
    parameters, whether it's worth memoizing a function automatically without any
    intervention or hint from the developer.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它可以根据调用的频率和其他各种参数来决定是否值得自动记忆函数，而无需开发人员的干预或提示。
- en: PHP in all that?
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP中的一切？
- en: Why bother with pure functions, immutability and, ultimately, referential transparency
    if PHP developers can only benefit from a small number of its advantages?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果PHP开发人员只能从其中的一小部分优势中受益，那么为什么要费心纯函数、不可变性，最终是引用透明呢？
- en: First of all, as with the RFC for immutability, things are going in the right
    direction. This means that, eventually, the PHP engine will start to incorporate
    some of those advanced compiler techniques. When this happens, if your codebase
    already uses those functional techniques, you will have a huge performance boost.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，就像不可变性的RFC一样，事情正在朝着正确的方向发展。这意味着，最终，PHP引擎将开始纳入一些先进的编译器技术。当这发生时，如果你的代码库已经使用了这些函数式技术，你将获得巨大的性能提升。
- en: Secondly, in my opinion, the major benefit of all that is the reduced cognitive
    burden. Sure, it takes some time to get used to this new style of programming.
    But once you have practiced a bit, you will quickly discover that your code is
    easier to read and reason about. The corollary being that your application will
    contain less bugs.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在我看来，所有这些的主要好处是减少认知负担。当然，要适应这种新的编程风格需要一些时间。但一旦你练习了一下，你很快就会发现你的代码更容易阅读和理解。其结果是你的应用程序将包含更少的错误。
- en: Finally, if you are willing to use some external libraries, or if you can cope
    with syntax that are not always well polished, you can already benefit from other
    improvements right now. Obviously, we won't be able to change the core of PHP
    to add the compiler optimization we were talking about earlier, but we will see
    in the following chapters how some of the benefits of referential transparency
    can be emulated.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你愿意使用一些外部库，或者如果你能够应对语法并不总是很完善的情况，你现在就可以从其他改进中受益了。显然，我们无法改变PHP的核心以添加我们之前谈到的编译器优化，但在接下来的章节中，我们将看到一些引用透明性的好处是如何被模拟的。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter contained a lot of theory. I hope you didn't mind too much. It
    was necessary to lay the foundation that will allow us to share a common vocabulary
    and also explain why the concepts are important. You are now well aware of what
    purity and immutability are and you learned some tricks to spot impure functions.
    We also discussed how those two properties lead to something called referential
    transparency what the benefits are.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章包含了很多理论。希望你不会介意太多。这是必要的，以奠定我们共同词汇的基础，并解释为什么这些概念很重要。你现在很清楚纯度和不可变性是什么，也学会了一些识别不纯函数的技巧。我们还讨论了这两个属性如何导致了所谓的引用透明性以及好处是什么。
- en: We also learned that, sadly, PHP does not support most of the benefits natively.
    However, the key takeaway is that using a functional approach reduces the cognitive
    burden of understanding your code, thus making it easier to read. The net benefit
    being that now your code will be easier to maintain and refactor and you can find
    and fix bugs quickly. Usually, pure functions are also easier to test, which also
    results in fewer bugs.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也了解到，遗憾的是，PHP并不原生支持大部分的好处。然而，关键的收获是使用函数式方法减少了理解代码的认知负担，从而使其更容易阅读。最终的好处是现在你的代码将更容易维护和重构，你可以快速找到并修复错误。通常，纯函数也更容易测试，这也会导致更少的错误。
- en: Now that we have the theoretical basis well discussed, the next chapter will
    focus on techniques that will help us achieve purity and immutability in our software.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地讨论了理论基础，接下来的章节将专注于帮助我们在软件中实现纯度和不可变性的技术。
