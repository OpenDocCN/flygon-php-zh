- en: Chapter 4. Build a Simple Blog with Search Capability using Elasticsearch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用Elasticsearch构建具有搜索功能的简单博客
- en: 'In this chapter, we will create a simple blog that can create and delete posts.
    Then we will work on adding some features to our blog such as the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个简单的博客，可以创建和删除帖子。然后我们将致力于为我们的博客添加一些功能，例如以下内容：
- en: Implement a very simple blog with CRUD and admin features
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个非常简单的带有CRUD和管理员功能的博客
- en: Work and install Elasticsearch and Logstash
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作和安装Elasticsearch和Logstash
- en: Try out the PHP client of Elasticsearch
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用Elasticsearch的PHP客户端
- en: Learn to build a tool for working with Elasticsearch
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习构建与Elasticsearch一起工作的工具
- en: Build a cache for searches to our database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的数据库构建搜索缓存
- en: Build a chart based on our Elasticsearch information
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于我们的Elasticsearch信息构建图表
- en: Creating the CRUD and admin system
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CRUD和管理员系统
- en: First, let's build the SQL of our posts. The database table should contain at
    the very least the post title, post content, post date, and modified and published
    dates.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们构建我们的帖子的SQL。数据库表至少应该包含帖子标题、帖子内容、帖子日期以及修改和发布日期。
- en: 'This is what the SQL should look like:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是SQL应该看起来的样子：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now let's create a function to read the data. A typical blog site has comments
    and some additional metadata for SEO related to the blog post. But in this chapter,
    we won't be creating this part. Anyway, it should be fairly trivial to add a table
    relating to comments data and to have data about SEO metadata about each post
    in another table.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个函数来读取数据。一个典型的博客网站有评论和与博客文章相关的一些额外的SEO元数据。但在本章中，我们不会创建这部分。无论如何，向评论数据添加表格并在另一个表格中添加有关每篇文章的SEO元数据应该是相当简单的。
- en: 'Let''s start by creating the admin system. We need to log in, so we''ll have
    to create a simple login-logout script:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建管理员系统开始。我们需要登录，所以我们将创建一个简单的登录-注销脚本：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you log in to `admin.php`, you set the sessions and are then redirected
    to the CRUD page.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当您登录到`admin.php`时，您设置了会话，然后被重定向到CRUD页面。
- en: 'The script for the admin CRUD page is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员CRUD页面的脚本如下：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding script, we simply defined some functions that will handle the
    CRUD operations for us. To display the data, we just simply loop through the database
    and output it in a table.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的脚本中，我们只是简单地定义了一些函数来处理CRUD操作。要显示数据，我们只需简单地循环遍历数据库并在表格中输出它。
- en: 'The edit and delete pages, which are the scripts needed for a user interface
    and functions to edit or delete the posts, are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑和删除页面，这些是用户界面和用于编辑或删除帖子的功能所需的脚本，如下所示：
- en: '`edit.php`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`edit.php`：'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s create the actual functionality for deleting the post. Following is
    how `delete.php` would look like:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建实际的删除帖子功能。以下是`delete.php`的样子：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our logger for PHP, Monolog, will add the posts to the Elasticsearch using the
    Logstash plugin for Elasticsearch.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的PHP记录器Monolog将使用Logstash插件将帖子添加到Elasticsearch中。
- en: We'll set up a Logstash plugin, which first checks if the document exists and,
    if not, then inserts it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个Logstash插件，首先检查文档是否存在，如果不存在，则插入。
- en: To update Elasticsearch, we'll need to perform an **upsert**, which will update
    the same record if it exists, and if it does not exist, it will create a new one.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新Elasticsearch，我们需要执行**upsert**，如果记录存在，则更新相同的记录，如果不存在，则创建一个新的记录。
- en: Also, we've implemented a way to delete the post from being visible in our CRUD,
    but not actually delete it from the database, as we'll need it for retrieval purposes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们已经实现了一种方法，可以从我们的CRUD中删除帖子，但实际上并没有从数据库中删除它，因为我们需要它来进行检索。
- en: For every action that needs to be done, we simply use the `$_GET['id']` to determine
    what we are going to do when that is clicked.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要执行的每个操作，我们只需使用`$_GET['id']`来确定在单击时我们要执行什么操作。
- en: 'Like any blog, we need a front page for the user to display the posts that
    are available to read:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何博客一样，我们需要一个首页供用户显示可阅读的帖子：
- en: '`index.php`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.php`：'
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we make extensive use of shorthand opening `php` tags
    so that we can focus on the page layout. Notice how it weaves in and out of PHP
    mode, but it looks like we are just using a template, meaning we can see the general
    outline of the HTML markup without getting too much into the details of the PHP
    code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们广泛使用了简写的`php`标记，这样我们就可以专注于页面布局。请注意它是如何在PHP模式中来回穿梭的，但看起来就像我们只是在使用模板，这意味着我们可以看到HTML标记的一般轮廓，而不会过多涉及PHP代码的细节。
- en: Seeding the post table
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充帖子表
- en: Without any data, our blog is useless. Therefore, for demonstration purposes,
    we'll just use a seeder script to automatically populate our table with data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何数据，我们的博客就是无用的。因此，为了演示目的，我们将使用一个种子脚本来自动填充我们的表格数据。
- en: Let's use a popular library for generating fake content, **Faker**, which is
    available at [https://github.com/fzaninotto/Faker](https://github.com/fzaninotto/Faker).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个用于生成虚假内容的流行库**Faker**，它可以在[https://github.com/fzaninotto/Faker](https://github.com/fzaninotto/Faker)上找到。
- en: With Faker, all you have to do is load it by providing the required path to
    its `autoload.php` file and load it using composer (`composer require fzaninotto/faker`).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Faker，您只需通过提供其`autoload.php`文件的所需路径来加载它，并使用composer进行加载（`composer require
    fzaninotto/faker`）。
- en: 'The complete script for generating fake content is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 生成虚假内容的完整脚本如下：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now let's move on to getting acquainted with Elasticsearch, the database search
    engine for our blog posts.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始熟悉Elasticsearch，这是我们博客文章的数据库搜索引擎。
- en: What is Elasticsearch?
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Elasticsearch？
- en: '**Elasticsearch** is a search server. It''s a full-text search engine that
    comes with an HTTP web interface and schema-free JSON documents. What this means
    is that we store new searchable data by using JSON. The API to enter these documents
    uses the HTTP protocol. In this chapter, we will learn how to use PHP and build
    a rich search engine that can do the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**Elasticsearch**是一个搜索服务器。它是一个带有HTTP Web界面和无模式JSON文档的全文搜索引擎。这意味着我们使用JSON存储新的可搜索数据。输入这些文档的API使用HTTP协议。在本章中，我们将学习如何使用PHP并构建一个功能丰富的搜索引擎，可以执行以下操作：'
- en: Set up the Elasticsearch PHP client
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Elasticsearch PHP客户端
- en: Add search data to Elasticsearch for indexing
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将搜索数据添加到Elasticsearch进行索引
- en: Learn how to use keywords for relevance
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用关键字进行相关性
- en: Cache our search results
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存我们的搜索结果
- en: Use Elasticsearch with Logstash to store apache logs
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Elasticsearch与Logstash存储apache日志
- en: Parse XML for storage into Elasticsearch
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析XML以存储到Elasticsearch
- en: Installing Elasticsearch and the PHP client
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Elasticsearch和PHP客户端
- en: Creating the web interface for consumption of Elasticsearch.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用于消费Elasticsearch的Web界面。
- en: As far as you need to know, Elasticsearch just needs to be installed by simply
    using the latest source code of Elasticsearch.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就您需要知道的而言，Elasticsearch只需要通过使用最新的Elasticsearch源代码进行安装。
- en: 'The installation instructions are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 安装说明如下：
- en: Go to [https://www.elastic.co/](https://www.elastic.co/) and download the source
    file that's related to your computer system, whether it's a Mac OSX, a Linux,
    or a Windows machine.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[https://www.elastic.co/](https://www.elastic.co/)并下载与您的计算机系统相关的源文件，无论是Mac
    OSX、Linux还是Windows机器。
- en: After downloading the file to your computer, you should run the setup installation
    notes.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载文件到计算机后，应运行设置安装说明。
- en: 'For example, for Mac OSX and Linux operating systems, you can do the following:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，对于Mac OSX和Linux操作系统，您可以执行以下操作：
- en: Install Java 1.8.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Java 1.8。
- en: 'Download Elasticsearch through curl (in the command line):'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过curl（在命令行中）下载Elasticsearch：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Extract the archive and change directory into it:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解压缩存档并切换到其中：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Start it up:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动它：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'An alternative way to install Elasticsearch for Mac OSX is using homebrew,
    which is available at [http://brew.sh/](http://brew.sh/) . Then, install it by
    using brew with the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OSX上安装Elasticsearch的另一种方法是使用homebrew，它可以在[http://brew.sh/](http://brew.sh/)上找到。然后，使用以下命令使用brew进行安装：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For Windows operating systems, you just need to click through the wizard installation
    program, as shown in the following screenshot:![Installing Elasticsearch and the
    PHP client](graphics/image_04_001.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Windows操作系统，您只需要按照向导安装程序进行点击，如下截图所示：![安装Elasticsearch和PHP客户端](graphics/image_04_001.jpg)
- en: Once that is installed, you also need to install the **Logstash agent**. The
    Logstash agent is in charge of sending data to Elasticsearch from various input
    sources.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，您还需要安装**Logstash代理**。Logstash代理负责从各种输入源向Elasticsearch发送数据。
- en: You can download it from the Elasticsearch website and follow the installation
    instructions for your computer system.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以从Elasticsearch网站下载它，并按照计算机系统的安装说明进行安装。
- en: For Linux, you can download a `tar` file and then you just have the other way
    for Linux, that is to use the package manager, which is either `apt-get` or `yum`,
    depending on your flavor of Linux.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Linux，您可以下载一个`tar`文件，然后您只需要使用Linux的另一种方式，即使用软件包管理器，即`apt-get`或`yum`，具体取决于您的Linux版本。
- en: 'You can test Elasticsearch by installing **Postman** and doing a `GET request`
    to `http://localhost:9200`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过安装**Postman**并进行`GET请求`到`http://localhost:9200`来测试Elasticsearch：
- en: Install Postman by opening Google Chrome and visiting [https://www.getpostman.com/](https://www.getpostman.com/).
    You can install it on Chrome by going to add-ons and searching for Postman.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过打开Google Chrome并访问[https://www.getpostman.com/](https://www.getpostman.com/)来安装Postman。您可以通过转到附加组件并搜索Postman来在Chrome上安装它。
- en: Once Postman is installed, you can register or skip registration:![Installing
    Elasticsearch and the PHP client](graphics/image_04_002.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Postman后，您可以注册或跳过注册：![安装Elasticsearch和PHP客户端](graphics/image_04_002.jpg)
- en: Now try doing a `GET request` to `http://localhost:9200`:![Installing Elasticsearch
    and the PHP client](graphics/image_04_003.jpg)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试进行`GET请求`到`http://localhost:9200`：![安装Elasticsearch和PHP客户端](graphics/image_04_003.jpg)
- en: 'The next step is to try out the PHP client library for Elasticsearch in your
    composer. Following is how to do that:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在您的composer中尝试使用Elasticsearch的PHP客户端库。以下是如何做到这一点：
- en: 'First, include Elasticsearch in your `composer.json` file:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在您的`composer.json`文件中包含Elasticsearch：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Get composer:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取composer：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Instantiate a new client by including it in your project:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将其包含在项目中来实例化一个新的客户端：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now let''s try indexing a document. To do so, let''s create a PHP file to use
    the PHP client as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试索引一个文档。为此，让我们创建一个使用PHP客户端的PHP文件，如下所示：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also retrieve that document by creating a script with the following
    code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过创建以下代码的脚本来检索该文档：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we''re performing a search, the code is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在执行搜索，代码如下：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In a nutshell, the Elasticsearch PHP client makes it easier to insert, search,
    and get a document from Elasticsearch.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Elasticsearch PHP客户端使得更容易将文档插入、搜索和从Elasticsearch获取文档。
- en: Building a PHP Elasticsearch tool
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建一个PHP Elasticsearch工具
- en: The aforementioned functionality can be used to create a PHP-backed user interface
    to insert, query, and search for documents using the Elasticsearch PHP client.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上述功能可用于使用Elasticsearch PHP客户端创建基于PHP的用户界面，以插入、查询和搜索文档。
- en: 'Here is a simple bootstrap (an HTML CSS framework) form:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的引导（HTML CSS框架）表单：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is what the form should look like:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是表单应该看起来的样子：
- en: '![Building a PHP Elasticsearch tool](graphics/image_04_004.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![构建PHP Elasticsearch工具](graphics/image_04_004.jpg)'
- en: 'When the user submits the details of the content, we''ll need to catch the
    content, keywords, or tags that the user has inputted. The PHP script that will
    enter the inputs into MySQL and then into our script, which will push it onto
    our Elasticsearch:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户提交内容的详细信息时，我们需要捕捉用户输入的内容、关键词或标签。PHP脚本将输入输入到MySQL，然后输入到我们的脚本，然后将其推送到我们的Elasticsearch中：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now let''s try to post this document to Elasticsearch as well:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们也尝试将此文档发布到Elasticsearch：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Adding documents to our Elasticsearch
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将文档添加到我们的Elasticsearch
- en: Elasticsearch uses indexes to store each data point into its database. From
    our MySQL database, we need to post the data into Elasticsearch.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch使用索引将每个数据点存储到其数据库中。从我们的MySQL数据库中，我们需要将数据发布到Elasticsearch。
- en: Let's discuss how indexing in Elasticsearch actually works. What makes it faster
    than conventional search by MySQL is that it searches the index instead.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论Elasticsearch中索引实际上是如何工作的。它比MySQL的传统搜索更快的原因在于它搜索索引而不是搜索每个条目。
- en: How does indexing work in Elasticsearch? It uses the **Apache Lucene** to create
    something called an **inverted index**. An inverted index means that it looks
    up the search terms without having to scan every single entry. It basically means
    that it has a lookup table that lists all the words ever entered the system.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch中的索引工作原理是什么？它使用**Apache Lucene**创建一种称为**倒排索引**的东西。倒排索引意味着它查找搜索项而无需扫描每个条目。基本上意味着它有一个查找表，列出了系统中输入的所有单词。
- en: 'Here is an overview of the architecture of the ELK stack:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ELK堆栈的架构概述如下：
- en: '![Adding documents to our Elasticsearch](graphics/image_04_005.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![将文档添加到我们的Elasticsearch](graphics/image_04_005.jpg)'
- en: In the preceding diagram, we can see that **INPUT SOURCES**, usually the logs
    or some other data source, goes into **Logstash**. From **Logstash**, it then
    goes into **Elasticsearch**.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们可以看到**输入源**，通常是日志或其他数据源，进入**Logstash**。然后从**Logstash**进入**Elasticsearch**。
- en: Once the data reaches **Elasticsearch**, it goes through some tokenizing and
    filtering. **Tokenizing** is the process of dissecting strings into different
    parts. **Filtering** is when some terms are sorted into separate indexes. For
    example, we may have an Apache log index, and then also have another input source,
    such as **Redis**, pushing into another searchable index.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据到达**Elasticsearch**，它会经过一些标记和过滤。**标记**是将字符串分解为不同部分的过程。**过滤**是当一些术语被分类到单独的索引中时。例如，我们可能有一个Apache日志索引，然后还有另一个输入源，比如**Redis**，推送到另一个可搜索的索引中。
- en: The searchable index is the reversed index we mentioned previously. A searchable
    index is basically made searchable by storing each term and referring to their
    original content into an index. It's similar to what is done in an indexed database.
    It is the same process when we create primary keys and use it as the index to
    search entire records.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可搜索的索引是我们之前提到的反向索引。可搜索的索引基本上是通过将每个术语存储并引用其原始内容到索引中来实现的。这类似于索引数据库中所做的操作。当我们创建主键并将其用作搜索整个记录的索引时，这是相同的过程。
- en: You can have many nodes performing this indexing in a cluster, all handled by
    the Elasticsearch engine. In the preceding diagram, the nodes are labeled **N1**
    to **N4**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在集群中有许多节点执行此索引操作，所有这些都由Elasticsearch引擎处理。在上图中，节点标记为**N1**到**N4**。
- en: Querying Elasticsearch
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询Elasticsearch
- en: We now understand each part, so how do we query Elasticsearch? First, let's
    get introduced to Elasticsearch. When you start running Elasticsearch, you should
    send an HTTP request to `http://localhost:9200`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了每个部分，那么我们如何查询Elasticsearch呢？首先，让我们介绍Elasticsearch。当您开始运行Elasticsearch时，您应该向`http://localhost:9200`发送HTTP请求。
- en: We can do this using the Elasticsearch web API, which allows us to use RESTful
    HTTP requests to the Elasticsearch server. This RESTful API is the only way to
    insert records into Elasticsearch.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Elasticsearch web API来实现这一点，它允许我们使用RESTful HTTP请求将记录插入到Elasticsearch服务器中。这个RESTful
    API是将记录插入到Elasticsearch的唯一方法。
- en: Installing Logstash
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Logstash
- en: Logstash is simply the central logging system where all the messages going to
    Elasticsearch will pass through.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Logstash只是所有传递到Elasticsearch的消息经过的中央日志系统。
- en: 'To set up Logstash, follow the guide that''s available on the Elasticsearch
    website:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置Logstash，请按照Elasticsearch网站上提供的指南进行操作：
- en: '[https://www.elastic.co/guide/en/logstash/current/getting-started-with-logstash.html](https://www.elastic.co/guide/en/logstash/current/getting-started-with-logstash.html).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.elastic.co/guide/en/logstash/current/getting-started-with-logstash.html](https://www.elastic.co/guide/en/logstash/current/getting-started-with-logstash.html)。'
- en: Elasticsearch and Logstash work together to get different types of indexed logs
    into Elasticsearch.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch和Logstash一起工作，将不同类型的索引日志输入Elasticsearch。
- en: We need to create something called a **transport** or middleware between the
    two data points. To do so, we need to set up Logstash. It is known as the **ingestion
    workhorse** for Elasticsearch and much more. It is a data collection engine that
    pipelines data from data source to the destination, which is Elasticsearch. Logstash
    is basically like a simple data pipeline.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在两个数据点之间创建一种称为**传输**或中间件。为此，我们需要设置Logstash。它被称为Elasticsearch的**摄入工作马**，还有更多。它是一个数据收集引擎，将数据从数据源管道传输到目的地，即Elasticsearch。Logstash基本上就像一个简单的数据管道。
- en: We will create a cronjob, which  is basically a background task, that will add
    new entries from our post table and put them into Elasticsearch.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个cron作业，这基本上是一个后台任务，它将从我们的帖子表中添加新条目并将它们放入Elasticsearch中。
- en: Unix and Linux users who are familiar with the concept of a pipe, | , will be
    familiar with what a pipeline does.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉管道概念的Unix和Linux用户，|，将熟悉管道的工作原理。
- en: Logstash simply transforms our raw log messages into a format called  **JSON**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Logstash只是将我们的原始日志消息转换为一种称为**JSON**的格式。
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**JSON**, also known as **JavaScript Object Notation**, is a popular format
    for transferring data between web services. It is lightweight, and many programming
    languages, including PHP, have a way to encode and decode JSON-formatted messages.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**，也称为**JavaScript对象表示法**，是在Web服务之间传输数据的流行格式。它很轻量，许多编程语言，包括PHP，都有一种方法来编码和解码JSON格式的消息。'
- en: Setting up the Logstash configuration
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置Logstash配置
- en: 'The input part of a Logstash configuration is concerned with reading and parsing
    log data correctly. It consists of the input data source and the parser to use.
    Here is a sample configuration where we will read from a `redis` input source:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Logstash配置的输入部分涉及正确读取和解析日志数据。它由输入数据源和要使用的解析器组成。这是一个示例配置，我们将从`redis`输入源中读取：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: But first, to be able to push to `redis`, we should install and use `phpredis`,
    an extension library that allows PHP to insert data into `redis`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，为了能够推送到`redis`，我们应该安装并使用`phpredis`，这是一个允许PHP将数据插入`redis`的扩展库。
- en: Installing PHP Redis
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装PHP Redis
- en: Installing PHP Redis should be simple. It's available in most package repositories
    for Linux platforms. You can read the documentation on how to install it at [https://github.com/phpredis/phpredis](https://github.com/phpredis/phpredis)
    .
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 安装PHP Redis应该很简单。它在大多数Linux平台的软件包存储库中都有。您可以阅读有关如何安装它的文档[https://github.com/phpredis/phpredis](https://github.com/phpredis/phpredis)。
- en: 'Once you have it installed, you can test that your PHP Redis installation is
    working by creating the following script and running it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以通过创建以下脚本并运行它来测试您的PHP Redis安装是否正常工作：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding example, we're able to start a new Redis connection and from
    there set a key called `random` to a number between `5000` and `6000`. Finally,
    we echo out the data that we've just entered by calling `echo $redis->get('random')`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们能够启动一个新的Redis连接，然后设置一个名为`random`的键，其值在`5000`和`6000`之间。最后，我们通过调用`echo
    $redis->get('random')`来输出我们刚刚输入的数据。
- en: With that in place, let's create the real PHP code using the logging library
    for PHP, called **Monolog**, to store our logs in Redis.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，让我们使用名为**Monolog**的PHP日志库来创建真正的PHP代码，将日志存储在Redis中。
- en: Let's create a `composer.json` that the logging project will use.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`composer.json`，供日志项目使用。
- en: 'In the terminal, let''s run the initialize composer:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，让我们运行初始化composer：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It will interactively ask some questions after which it should create a `composer.json`
    file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在之后交互式地询问一些问题，然后应该创建一个`composer.json`文件。
- en: 'Now install Monolog by typing the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过输入以下内容来安装Monolog：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s set up the PHP code that will read from our MySQL database and then
    push it over to Elasticsearch:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置从我们的MySQL数据库中读取数据，然后将其推送到Elasticsearch的PHP代码：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, we've created a `redisHandler` with the name of the logs
    to be called `phplogs`. We then set the `LogstashFormatter` instance to use the
    application name `my_app`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个名为`phplogs`的`redisHandler`。然后，我们设置`LogstashFormatter`实例以使用应用程序名称`my_app`。
- en: At the end of the script, we create a new `logger` instance, connect it to the
    `redisHandler`, and call the `info()` method of the `logger` to log the data.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的末尾，我们创建一个新的`logger`实例，将其连接到`redisHandler`，并调用`logger`的`info()`方法来记录数据。
- en: Monolog separates the responsibilities of the formatter from the actual logging.
    The `logger` is responsible for creating the messages, and the Formatter formats
    the messages into the appropriate format so that Logstash can understand it. Logstash,
    in turn, pipes it to Elasticsearch, where the data about the log is indexed and
    is stored in the Elasticsearch index for querying later.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Monolog将格式化程序的职责与实际日志记录分开。`logger`负责创建消息，而格式化程序将消息格式化为适当的格式，以便Logstash能够理解。Logstash将其传输到Elasticsearch，Logstash将其索引的日志数据存储在Elasticsearch索引中，以便以后进行查询。
- en: That's the wonderful thing about Elasticsearch. As long as you have Logstash,
    you can choose from different input sources for Logstash to process and Elasticsearch
    will do its job of saving the data when Logstash pushes to it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Elasticsearch的美妙之处。只要有Logstash，您可以选择不同的输入源供Logstash处理，Elasticsearch将在Logstash推送数据时保存数据。
- en: Encoding and decoding JSON messages
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码和解码JSON消息
- en: Now that we know how to work with the Monolog library, we need to integrate
    it into our blog application. We'll do so by creating a cronjob that will check
    for new blog posts for that day and store them in Elasticsearch through the use
    of a PHP script.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用Monolog库，我们需要将其集成到我们的博客应用程序中。我们将通过创建一个cronjob来实现这一点，该cronjob将检查当天是否有新的博客文章，并通过使用PHP脚本将它们存储在Elasticsearch中。
- en: 'First, let''s create a folder called `server_scripts` where we put all our
    cronjobs:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为`server_scripts`的文件夹，将所有cronjobs放在其中：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, here is our code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是我们的代码：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using Logstash, we can read from our `redis` data and let it do its work, which
    would then process it and output it with the following output plugin code for
    Logstash:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Logstash，我们可以从我们的`redis`数据中读取并让它完成工作，然后使用以下Logstash的输出插件代码输出它：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Storing Apache logs in Elasticsearch
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Elasticsearch中存储Apache日志
- en: Monitoring logs is an important aspect of any web application. Most critical
    systems have what is known as a dashboard, and that is exactly we will build in
    this segment with PHP.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 监控日志是任何Web应用程序的重要方面。大多数关键系统都有一个称为仪表板的东西，这正是我们将在本节中使用PHP构建的东西。
- en: As a bonus to this chapter, let's talk about another logging topic, server logs.
    Sometimes we want to be able to determine the performance of the server at a certain
    time.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的额外内容，让我们谈谈另一个日志主题，服务器日志。有时，我们希望能够确定服务器在某个特定时间的性能。
- en: Another thing you can do with Elasticsearch is to store Apache logs. For our
    application, we can add this so that we know about our users a little bit more.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch的另一项功能是存储Apache日志。对于我们的应用程序，我们可以添加这个功能，以便更多了解我们的用户。
- en: This could be useful, for example, if we're interested in monitoring the browser
    a user is using and where users are coming from when they access our site.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们对监视用户使用的浏览器以及用户访问我们网站时来自何处感兴趣，这可能会很有用。
- en: 'To do so, we just have to set up some configuration using the Apache input
    plugin as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们只需使用Apache输入插件设置一些配置，如下所示：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A **Kibana** dashboard may be created when you install Kibana from Elasticsearch;
    however, it requires end users to already know how to use the tool to create various
    queries.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从Elasticsearch安装Kibana时，可以创建**Kibana**仪表板；但是，这需要最终用户已经知道如何使用该工具来创建各种查询。
- en: However, there is a need to make it simpler for upper management to view the
    data without having to know how to create Kibana dashboards.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有必要使高层管理人员能够更简单地查看数据，而无需知道如何创建Kibana仪表板。
- en: For our end users to not have to learn how to use Kibana and create dashboards,
    we will simply query the **ILog** information when the dashboard page is requested.
    For the charting library, we will use a popular library known as **Highcharts**.
    To get the information, however, we will need to create a simple query that will
    return some information to us in JSON format.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的最终用户不必学习如何使用Kibana和创建仪表板，我们将在请求仪表板页面时简单地查询**ILog**信息。对于图表库，我们将使用一个名为**Highcharts**的流行库。但是，为了获取信息，我们需要创建一个简单的查询，以JSON格式返回一些信息给我们。
- en: Handle the Apache logs, we can create it using PHP Elasticsearch client library.
    It's a simple client library that allows us to query Elasticsearch for information
    that we need, including the number of hits.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 处理Apache日志，我们可以使用PHP Elasticsearch客户端库来创建。这是一个简单的客户端库，允许我们查询Elasticsearch以获取我们需要的信息，包括命中次数。
- en: We will create a simple histogram for our website to show the number of accesses
    that are logged in our database.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的网站创建一个简单的直方图，以显示在我们的数据库中记录的访问次数。
- en: For example, we'll use the PHP Elasticsearch SDK to query Elasticsearch and
    display the Elasticsearch results.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将使用PHP Elasticsearch SDK来查询Elasticsearch并显示Elasticsearch结果。
- en: We also have to make the histogram dynamic. Basically, when the user wants to
    select between certain dates, we should be able to set up Highcharts to just get
    the data points and create a graph. If you haven't checked out Highcharts, please
    refer to [http://www.highcharts.com/](http://www.highcharts.com/) .
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须使直方图动态化。基本上，当用户想要在某些日期之间进行选择时，我们应该能够设置Highcharts来获取数据点并创建图表。如果您还没有查看过Highcharts，请参考[http://www.highcharts.com/](http://www.highcharts.com/)。
- en: '![Storing Apache logs in Elasticsearch](graphics/image_04_006.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: 将Apache日志存储在Elasticsearch中
- en: Getting filtered data to display with Highcharts
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取过滤数据以显示在Highcharts中
- en: Like any chart user, we sometimes require the ability to filter down whatever
    we see in our graph. Instead of relying on Highcharts to give us controls to filter
    down our data, we should be able to do the filtering by changing the data that
    Highcharts will render.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何图表用户一样，我们有时需要过滤我们在图表中看到的内容的能力。我们不应该依赖Highcharts为我们提供控件来过滤我们的数据，而是应该能够通过改变Highcharts将呈现的数据来进行过滤。
- en: 'In the following Highcharts code, we are adding the following container divider
    for our page; first, we get the data from our Elasticsearch engine using JavaScript:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下Highcharts代码中，我们为我们的页面添加了以下容器分隔符；首先，我们使用JavaScript从我们的Elasticsearch引擎获取数据：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is done is using the filter command of JavaScript and then parsing that
    data into our Highcharts graph. You'll also need to use underscore for the filtering
    function, which will help sort out which data we want to present to the user.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用JavaScript的filter命令进行的，然后将数据解析到我们的Highcharts图表中。您还需要使用underscore进行过滤功能，这将有助于确定我们要向用户呈现哪些数据。
- en: Let's first build the form to filter our Highcharts histogram.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先构建过滤我们的Highcharts直方图的表单。
- en: 'This is what the HTML code for the search filter in the CRUD view will look
    like:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是CRUD视图中搜索过滤器的HTML代码将是这样的：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To enable quick re-rendering of our graph, we have to attach a listener using
    plain old JavaScript every time the filter button is clicked and then simply erase
    the information of the `div` element that contains our Highcharts graph.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现图表的快速重新渲染，我们必须在每次单击过滤按钮时使用普通的JavaScript附加一个监听器，然后简单地擦除包含我们的Highcharts图表的`div`元素的信息。
- en: 'The following JavaScript code will update the filter using jQuery and underscore
    and the same code in the first bar chart:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下JavaScript代码将使用jQuery和underscore更新过滤器，并在第一个条形图中使用相同的代码：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, we've included `jquery` and underscore libraries. When
    the button is clicked to focus on some dates, we set `$_GET['date']` through the
    form and then PHP gets the information using a simple trick where we re-render
    the `div` containing the graph by simply flushing the `ihtml` elements inside
    it, and then asking Highcharts to re-render the data.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们已经包含了`jquery`和underscore库。当单击按钮以聚焦某些日期时，我们通过表单设置`$_GET['date']`，然后PHP使用一个简单的技巧获取信息，即通过简单地刷新包含图表的`div`，然后要求Highcharts重新渲染数据。
- en: To make this a little cooler, we can use a CSS animation effect so it looks
    like we're focusing a camera.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这更酷一些，我们可以使用CSS动画效果，使其看起来像我们正在聚焦相机。
- en: 'This can be done using the jQuery CSS transform techniques, and then resizing
    it back to normal and reloading a new graph:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过jQuery CSS变换技术来实现，然后将其调整回正常大小并重新加载新的图表：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now we've learned how to filter using JavaScript and allow filtering of the
    JSON data using the filter style. Take note that filter is a relatively new JavaScript
    function; it only got introduced with  **ECMAScript 6**. We've used it to create
    the dashboard that upper management needs to be able to generate reports for their
    own purposes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用JavaScript进行过滤，并允许使用过滤样式过滤JSON数据。请注意，过滤是一个相对较新的JavaScript函数；它是在**ECMAScript
    6**中引入的。我们已经使用它来创建高层管理人员需要能够为其自己的目的生成报告的仪表板。
- en: We can use the underscore library, which has the filter function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用underscore库，它具有过滤功能。
- en: We'll just load the latest logs that are in Elasticsearch, and then, if we want
    to perform a search, we'll create a way to filter and specify what data to search
    in the logs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只加载Elasticsearch中的最新日志，然后，如果我们想要执行搜索，我们将创建一种过滤和指定要在日志中搜索的数据的方法。
- en: Let's create the Logstash configuration for Apache's logs to be grokked by Elasticsearch.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建Apache日志的Logstash配置，以便Elasticsearch进行处理。
- en: All we need to do is point the input Logstash configuration to our Apache logs
    location (usually a file in the `/var/log/apache2` directory).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要将输入Logstash配置指向我们的Apache日志位置（通常是`/var/log/apache2`目录中的文件）。
- en: 'This is the basic Logstash configuration for Apache, which reads the Apache
    access log file at `/var/log/apache2/access.log`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Apache的基本Logstash配置，它读取位于`/var/log/apache2/access.log`的Apache访问日志文件：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It uses something called a grok filter that matches anything that resembles
    an Apache log format and matches the timestamp to the `dd/MMM/yyyy:HH:mm:ss Z` date
    format.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用称为grok过滤器的东西，它匹配任何类似于Apache日志格式的内容，并将时间戳匹配到`dd/MMM/yyyy:HH:mm:ss Z`日期格式。
- en: If you think of Elasticsearch as the end of the rainbow and Apache logs as the
    start of the rainbow, then Logstash is like the rainbow that transports the logs
    from both ends into a format that Elasticsearch can understand.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将Elasticsearch视为彩虹的终点，将Apache日志视为彩虹的起点，那么Logstash就像是将日志从两端传输到Elasticsearch可以理解的格式的彩虹。
- en: '**Grokking** is the term used to describe reformatting a message format into
    something that Elasticsearch can interpret. This just means that it will search
    for a pattern and filter match for that pattern in particular, it will look up
    the log''s timestamp and message and other attributes in JSON, which is what Elasticsearch
    then stores in its database.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**Grokking**是用来描述将消息格式重新格式化为Elasticsearch可以解释的内容的术语。这意味着它将搜索一个模式，并过滤匹配该模式的内容，特别是它将在JSON中查找日志的时间戳和消息以及其他属性，这是Elasticsearch存储在其数据库中的内容。'
- en: Dashboard app for viewing Elasticsearch logs
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于查看Elasticsearch日志的仪表板应用
- en: Let's now create a dashboard for our blog that will allow us to see the data
    that we have in Elasticsearch, both posts and Apache logs. We'll use the PHP Elasticsearch
    SDK to query Elasticsearch and display the Elasticsearch results.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为我们的博客创建一个仪表板，以便我们可以查看我们在Elasticsearch中的数据，包括帖子和Apache日志。我们将使用PHP Elasticsearch
    SDK来查询Elasticsearch并显示Elasticsearch结果。
- en: We'll just load the latest logs that are in Elasticsearch, and then, if we want
    to perform a search, we'll create a way to filter and specify what data to search
    in the logs.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只加载Elasticsearch中的最新日志，然后，如果我们想要执行搜索，我们将创建一种过滤和指定要在日志中搜索的数据的方法。
- en: 'This is what the search filter form will look like:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是搜索过滤表单的样子：
- en: '![Dashboard app for viewing Elasticsearch logs](graphics/image_04_007.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![用于查看Elasticsearch日志的仪表板应用](graphics/image_04_007.jpg)'
- en: 'In `search.php`, we''ll create a simple form for searching values in Elasticsearch:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`search.php`中，我们将创建一个简单的表单来搜索Elasticsearch中的值：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When the user clicks on **Submit**, we will then show the results to the user.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**提交**时，我们将向用户显示结果。
- en: Our form should simply show us what records we have for that day for both the
    Apache logs and the blog posts.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单应该简单地显示出我们当天对于Apache日志和博客文章的记录。
- en: 'This is how we query `ElasticSearch` for that information in the command line
    using curl:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在命令行中使用curl查询`ElasticSearch`信息的方式：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we''ll get a JSON response from Elasticsearch:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将从Elasticsearch获得一个JSON响应：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can use a REST client (a way to query RESTful API''s in Firefox) as well
    to query the database just specify the `GET` method and the path and set the `q`
    variable in the URL to the parameters you want to search:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用REST客户端（一种在Firefox中查询RESTful API的方式）来查询数据库，只需指定`GET`方法和路径，并在URL中设置`q`变量为您想要搜索的参数：
- en: '![Dashboard app for viewing Elasticsearch logs](graphics/image_04_008.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![用于查看Elasticsearch日志的仪表板应用](graphics/image_04_008.jpg)'
- en: Simple search engine with result caching
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有结果缓存的简单搜索引擎
- en: To install the PHP Redis, visit [https://github.com/phpredis/phpredis](https://github.com/phpredis/phpredis)
    .
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装PHP Redis，请访问[https://github.com/phpredis/phpredis](https://github.com/phpredis/phpredis)。
- en: 'Every time the user searches, we can save their recent searches in Redis and
    just present those results if they already exist. The implementation might looks
    as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每次用户搜索时，我们可以将他们最近的搜索保存在Redis中，如果已经存在，就直接呈现这些结果。实现可能如下所示：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Redis is a simple dictionary. It stores a key and the value of that key in its
    database. In the preceding code, we use it to store a reference to the user's
    search results so that next time the same search is performed, we can just pull
    what we have from the Redis data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是一个简单的字典。它在数据库中存储一个键和该键的值。在前面的代码中，我们使用它来存储用户搜索结果的引用，这样下次执行相同的搜索时，我们可以直接从Redis数据中获取。
- en: In the preceding code, we converted the search term into a hash so that it can
    be easily identified as the same query that came through and it can be stored
    easily as the key (which should be one string only, no spaces allowed). If after
    hashing we find the key in Redis, then we get it from Redis instead of fetching
    it from the database.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将搜索词转换为哈希，以便可以轻松地识别为通过的相同查询，并且可以轻松地存储为键（应该只有一个字符串，不允许空格）。如果在哈希后在Redis中找到键，那么我们将从Redis中获取它，而不是从数据库中获取它。
- en: Redis can expire keys by saving the key using the `$redis->setEx` method, which
    allows us to store the key and expire it after *X* number of seconds. In this
    case, we're storing it for 3,600 seconds, which is equivalent to an hour.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Redis可以通过使用`$redis->setEx`方法保存键并在*X*秒后使其过期。在这种情况下，我们将其存储3,600秒，相当于一个小时。
- en: Cache basics
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存基础
- en: The concept of a cache is to return the already searched items back to the user
    so that for other users who are searching for the same exact search results, the
    application should no longer need to do a full database fetch from the MySQL database.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的概念是将已经搜索过的项目返回给用户，这样对于其他正在搜索相同搜索结果的用户，应用程序就不再需要从MySQL数据库中进行完整的数据库提取。
- en: The bad thing with having a cache is that you have to perform cache invalidation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有缓存的坏处是您必须执行缓存失效。
- en: Cache invalidation of Redis data
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Redis数据的缓存失效
- en: '**Cache invalidation** is when you need to expire and delete the cache data.
    This is because your cache may no longer be real time after a while. Of course,
    after invalidation, you need to renew the data in the cache, which happens when
    there is a new request to the data. The cache invalidation process can take one
    of the following three methods:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存失效**是指当您需要过期和删除缓存数据时。这是因为您的缓存在一段时间后可能不再是实时的。当然，在失效后，您需要更新缓存中的数据，这发生在有新的数据请求时。缓存失效过程可以采用以下三种方法之一：'
- en: '**Purge** is when we remove content from the cache data right away.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清除**是指立即从缓存数据中删除内容。'
- en: '**Refresh** just means get new data and overwrite the already existing data.
    This means that even though there is a match in the cache, we will refresh that
    match with the new information fresh from wherever it comes from.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**刷新**意味着获取新数据并覆盖已有数据。这意味着即使缓存中有匹配项，我们也将使用新信息刷新该匹配项。'
- en: '**Ban** is basically adding previously cached content to a ban list. When another
    client fetches the same information and, upon checking the blacklist, if it already
    exists, the cached content just gets updated.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封禁**基本上是将先前缓存的内容添加到封禁列表中。当另一个客户端获取相同信息并在检查黑名单时，如果已存在，缓存的内容将被更新。'
- en: We can run a cronjob continuously in the background that will update every cache
    result with new results for that search.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在后台连续运行cron作业，以更新该搜索的每个缓存结果为新的结果。
- en: 'This is what the background PHP script that runs every 15 minute might look
    like in crontab:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在crontab中每15分钟运行的后台PHP脚本可能的样子：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To get Logstash to put data in Redis, we just need to do the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要让Logstash将数据放入Redis中，我们只需要执行以下操作：
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is how the PHP script that deletes data from the cache would work:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是删除缓存数据的PHP脚本的工作原理：
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding script, we basically check the `searchDate` searched earlier,
    and if we have it, we set it to expire.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，我们基本上检查了之前搜索的`searchDate`，如果有，我们将其设置为过期。
- en: If it also appears in the `previousResults` array, we give that to the user;
    otherwise, we do a new `redis->get` command to get the results for that searched
    date.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它也出现在`previousResults`数组中，我们将把它给用户；否则，我们将执行一个新的`redis->get`命令来获取搜索日期的结果。
- en: Using browser localStorage as cache
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用浏览器的localStorage作为缓存
- en: Another option for cache storage is to save it in the client browser itself.
    The technology is known as **localStorage**.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存存储的另一个选项是将其保存在客户端浏览器中。这项技术被称为**localStorage**。
- en: We can use it as a simple cache for the user and store the search results, and
    if the user wants to search for the same thing, we just check the localStorage
    cache.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其用作用户的简单缓存，并存储搜索结果，如果用户想搜索相同的内容，我们只需检查localStorage缓存。
- en: Tip
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`localStorage` can only store 5 MB of data. But this is quite a lot considering
    that a regular text file is just a few kilobytes.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage`只能存储5MB的数据。但考虑到常规文本文件只有几千字节，这已经相当多了。'
- en: We can make use of the `elasticsearch.js` client instead of the PHP client to
    make requests to our Elasticsearch. The browser-compatible version can be downloaded
    from [https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/browser-builds.html](https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/browser-builds.html)
    .
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用`elasticsearch.js`客户端而不是PHP客户端来向Elasticsearch发出请求。浏览器兼容版本可以从[https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/browser-builds.html](https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/browser-builds.html)下载。
- en: 'We can also use Bower to install the `elasticsearch.js` client:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用Bower来安装`elasticsearch.js`客户端：
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For our purpose, we can take advantage of the jQuery Build by creating a client
    using jQuery:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到我们的目的，我们可以利用jQuery Build通过创建一个使用jQuery的客户端：
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We should now be able to use JavaScript to populate the `localStorage`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够使用JavaScript来填充`localStorage`。
- en: Since we are just querying and displaying on the client side, it's a perfect
    match!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只是在客户端进行查询和显示，这是完美的匹配！
- en: Take note that we might not be able to log the data that was searched for by
    using a client-side script. However, we could save the search query history as
    a model containing the items keys that were searched for.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可能无法使用客户端脚本记录搜索的数据。但是，我们可以将搜索查询历史保存为包含先前搜索的项目键的模型。
- en: 'The basic JavaScript `searchQuery` object would look like the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的JavaScript `searchQuery`对象将如下所示：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can test whether the client works by running the following JavaScript file:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下JavaScript文件来测试客户端是否工作：
- en: '[PRE44]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The results could be cached into `localStorage` by doing the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方式，搜索结果可以缓存在`localStorage`中：
- en: '[PRE45]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We'll populate the results with data we find from `elasticsearch` and then just
    check if the same query was done earlier.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用从`elasticsearch`中找到的数据填充结果，然后只需检查之前是否进行了相同的查询。
- en: We also need to keep the data fresh. Let's hypothesize that it takes about 15
    minutes before a user gets bored and would refresh the page to try to see new
    information.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要保持数据的新鲜。假设大约需要15分钟，用户会感到无聊并刷新页面以查看新信息。
- en: 'In the same manner, we check whether the search result have been displayed
    in the past:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们检查过去是否显示过搜索结果：
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, whenever we expire the search criteria, say after about 15 minutes, we
    will simply clear the cache and put in the new search results that Elasticsearch
    finds.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我们过期搜索条件，比如大约15分钟后，我们将简单地清除缓存并放入Elasticsearch找到的新搜索结果。
- en: Working with streams
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用流处理
- en: Here, we will take advantage of PHP's Monolog library and then stream the data
    instead of pushing complete strings. The nice thing about working with streams
    is that they can easily pipe into Logstash and, in turn, store it into Elasticsearch
    as indexed data. Logstash also has features for creating data streams and streaming
    the data.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将利用PHP的Monolog库，然后流式传输数据而不是推送完整的字符串。使用流的好处是它们可以轻松地管道到Logstash中，然后将其作为索引数据存储到Elasticsearch中。Logstash还具有创建数据流和流式传输数据的功能。
- en: We can directly input our data without even using Logstash, using something
    that is known as streams. For more information on streams, refer to [http://php.net/manual/en/book.stream.php](http://php.net/manual/en/book.stream.php)
    .
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在不使用Logstash的情况下直接输入我们的数据，使用一种称为流的东西。有关流的更多信息，请参阅[http://php.net/manual/en/book.stream.php](http://php.net/manual/en/book.stream.php)。
- en: 'Here, for example, is a way to push some data to Elasticsearch: `http://localhost/dev/streams/php_input.php`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是将一些数据推送到Elasticsearch的方法：`http://localhost/dev/streams/php_input.php`：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In `php_input`, we can put the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在`php_input`中，我们可以放入以下代码：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We'll be getting `Hello World&foo=bar&name=John`, which means that PHP was able
    to get the very first string as a stream using the PHP input stream.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得`Hello World&foo=bar&name=John`，这意味着PHP能够使用PHP输入流获取第一个字符串作为流。
- en: To play around with PHP streams, let's create a stream using PHP manually. PHP
    developers usually have some experience working with stream data already when
    working with output buffering.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要玩转PHP流，让我们手动使用PHP创建一个流。PHP开发人员通常在处理输出缓冲时已经有一些处理流数据的经验。
- en: The idea with output buffering is to collect the stream until it's complete
    and then show it to the user.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 输出缓冲的想法是收集流直到完整，然后将其显示给用户。
- en: This is especially useful when the stream isn't finished yet and we need to
    wait for the ending character for the data to be completely transferred.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当流尚未完成并且我们需要等待数据的结束字符以完全传输数据时，这是特别有用的。
- en: 'We can push streams into Elasticsearch! This can be done using the Logstash
    input plugin to handle streams. This is how PHP can output to a stream:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将流推送到Elasticsearch！这可以通过使用Logstash输入插件来处理流来实现。这就是PHP如何输出到流的方式：
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Storing and searching XML documents using PHP
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PHP存储和搜索XML文档
- en: We can also work with XML documents and insert them into Elasticsearch. To do
    so, we can transform the data into JSON and then push the JSON into Elasticsearch.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以处理XML文档并将其插入到Elasticsearch中。为此，我们可以将数据转换为JSON，然后将JSON推送到Elasticsearch中。
- en: 'First, you can check out the following XML to JSON converter:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以查看以下XML转JSON转换器：
- en: 'If you want to check that the XML has been converted correctly to JSON, check
    out the **XML TO JSON Converter** tool at [http://codebeautify.org/xmltojson](http://codebeautify.org/xmltojson)
    ; from there, you can easily check out how to export an XML to JSON:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想检查XML是否已正确转换为JSON，请查看[http://codebeautify.org/xmltojson](http://codebeautify.org/xmltojson)上的**XML
    TO JSON Converter**工具；从那里，您可以轻松查看如何将XML导出为JSON：
- en: '![Storing and searching XML documents using PHP](graphics/image_04_009.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![使用PHP存储和搜索XML文档](graphics/image_04_009.jpg)'
- en: Using Elasticsearch to search a social network database
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Elasticsearch搜索社交网络数据库
- en: In this section, we'll simply use our knowledge to apply it to an existing social
    network built with PHP.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简单地使用我们的知识将其应用于使用PHP构建的现有社交网络。
- en: Let's pretend we have users who want to be able to search their social feed.
    Here's where we build a full-blown auto-dropdown search system.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有用户希望能够搜索他们的社交动态。这就是我们构建完整的自动下拉搜索系统的地方。
- en: Every time the user posts, we need to be able to store all the data in Elasticsearch.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户发布帖子时，我们需要能够将所有数据存储在Elasticsearch中。
- en: However, in our search queries, we will match search results to the actual word
    that the user fetched. If it doesn't match the query in each, character-by-character,
    we won't display it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的搜索查询中，我们将匹配搜索结果与用户提取的实际单词。如果它不与每个查询逐字匹配，我们将不显示它。
- en: 'We first need to build the feed. The SQL schema will look as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要构建动态信息流。SQL模式如下所示：
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`Post_type` would handle the type of post—photo, video, link, or just plain
    text.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post_type`将处理帖子的类型 - 照片、视频、链接或纯文本。'
- en: So, if the user added a type of picture, it would be saved as an image type.
    And when a person searches for a post, they can filter by the type.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果用户添加了一种图片类型，它将被保存为图像类型。当某人搜索帖子时，他们可以按类型进行筛选。
- en: 'Every time users save a new photo, or a new post, we will also store the data
    into Elasticsearch, which will look as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户保存新照片或新帖子时，我们还将数据存储到Elasticsearch中，如下所示：
- en: '[PRE51]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we need to make an input form when the user inserts the preceding new posting.
    We''ll just build the one that can upload a photo with a title or just add text:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在用户插入前面的新帖子时制作一个输入表单。我们将构建一个可以上传带标题的照片或只添加文本的表单：
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `submit_status.php` script will have the following code to save into the
    database:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`submit_status.php`脚本将包含以下代码以保存到数据库中：'
- en: '[PRE53]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Displaying randomized search engine results
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示随机搜索引擎结果
- en: The preceding feed database table is the table that everyone will post to. We
    need to enable randomly showing what's on the feed. We can insert posts into feeds
    instead of storing.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的动态信息流数据库表是每个人都会发布的表。我们需要启用随机显示信息流中的内容。我们可以将帖子插入到信息流中而不是存储。
- en: By searching from Elasticsearch and randomly rearranging the data, we can make
    our searches more fun. In a way, this makes sure that people using our social
    network will be able to see random posts in their feed.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从Elasticsearch搜索并随机重新排列数据，我们可以使我们的搜索更有趣。在某种程度上，这确保了使用我们的社交网络的人能够在其信息流中看到随机的帖子。
- en: To search from the posts, instead of doing a direct query to SQL, we will search
    the Elasticsearch database for the data.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要从帖子中搜索，我们将不直接查询SQL，而是搜索Elasticsearch数据库中的数据。
- en: 'First, let''s figure out how to insert the data into an Elasticsearch index
    called `posts`. With Elasticsearch open, we simply do the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们弄清楚如何将数据插入名为“posts”的Elasticsearch索引中。打开Elasticsearch后，我们只需执行以下操作：
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We will probably also want to search our friends, and if we have a ton of friends,
    they won't all be on the feed. So, we just need another index to search called
    the `friends` index.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能也想搜索我们的朋友，如果我们有很多朋友，他们不会全部出现在动态中。所以，我们只需要另一个用于搜索的索引，称为“friends”索引。
- en: 'The following code, when run in the Linux command line, will allow us to create
    a new `friends` index:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux命令行中运行以下代码将允许我们创建一个新的“friends”索引：
- en: '[PRE55]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'So, we can now store data about our friends using the `friends` index:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在可以使用“friends”索引存储关于我们朋友的数据。
- en: '[PRE56]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We'll usually look for friends of friends and we'll, of course, show that to
    our user if there are any friends with the search query.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们会寻找朋友的朋友，当然，如果有任何朋友符合搜索条件，我们会向用户展示。
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we discussed how to create a blog system, experimented with
    Elasticsearch, and were able to do the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何创建一个博客系统，尝试了Elasticsearch，并能够做到以下几点：
- en: Create a simple blog application and store data in MySQL
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的博客应用程序并将数据存储在MySQL中
- en: Install Logstash and Elasticsearch
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Logstash和Elasticsearch
- en: Practice working with Elasticsearch using curl
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用curl练习与Elasticsearch一起工作
- en: Get data into Elasticsearch using the PHP Client
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PHP客户端将数据导入Elasticsearch
- en: Chart information (hits) from Elasticsearch using Highcharts
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Highcharts从Elasticsearch中的图表信息（点击数）
- en: Use the `elasticsearch.js` client to query Elasticsearch for information
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“elasticsearch.js”客户端查询Elasticsearch获取信息
- en: Use Redis and localStorage in the browser to work with caching
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中使用Redis和localStorage进行缓存处理
