["```php\n<?php \n\ninterface Functor \n{ \n    public function map(callable $f): Functor; \n} \n```", "```php\n<?php \n\nfunction id($value) \n{ \n    return $value; \n} \n```", "```php\ncompose(id, f) == compose(f, id) \n```", "```php\n<?php \n\n$data = [1, 2, 3, 4]; \n\nvar_dump(array_map('id', $data) === id($data)); \n// bool(true) \n\nfunction add2($a) \n{ \n    return $a + 2; \n} \n\nfunction times10($a) \n{ \n    return $a * 10; \n} \n\nfunction composed($a) { \n    return add2(times10($a)); \n} \n\nvar_dump( \narray_map('add2', array_map('times10', $data)) === array_map('composed', $data) \n); \n// bool(true) \n```", "```php\n<?php \n\n$just = Maybe::just(10); \n$nothing = Maybe::nothing(); \n\nvar_dump($just->map('id') == id($just)); \n// bool(true) \n\nvar_dump($nothing->map('id') === id($nothing)); \n// bool(true) \n```", "```php\n<?php \n\nvar_dump($just->map('times10')->map('add2') == $just->map('composed')); \n// bool(true) \n\nvar_dump($nothing->map('times10')->map('add2') === $nothing->map('composed')); \n// bool(true) \n```", "```php\n<?php \n\nclass IdentityFunctor implements Functor \n{ \n    private $value; \n\n    public function __construct($value) \n    { \n        $this->value = $value; \n    } \n\n    public function map(callable $f): Functor \n    { \n        return new static($f($this->value)); \n    } \n\n    public function get() \n    { \n        return $this->value; \n    } \n} \n```", "```php\n<?php \n\n$add = curry(function(int $a, int $b) { return $a + $b; }); \n\n$id = new IdentityFunctor(5); \n```", "```php\n<?php \n\n$hum = $id->map($add); \n\necho get_class($hum->get()); \n// Closure \n```", "```php\n<?php \n\n$result = $hum->map(function(callable $f) { \n    return $f(10); \n}); \necho $result->get(); \n// 15 \n```", "```php\n<?php \n\nclass IdentityFunctorExtended extends IdentityFunctor \n{ \n    public function apply(IdentityFunctorExtended $f) \n    { \n        return $f->map($this->get()); \n    } \n} \n\n$applicative = (new IdentityFunctorExtended(5))->map($add); \n$ten = new IdentityFunctorExtended(10); \necho $applicative->apply($ten)->get(); \n// 15 \n```", "```php\n<?php \n\n$five = new IdentityFunctorExtended(5); \n$ten = new IdentityFunctorExtended(10); \n$applicative = new IdentityFunctorExtended($add); \n\necho $applicative->apply($five)->apply($ten)->get(); \n// 15 \n```", "```php\n<?php \n\nabstract class Applicative implements Functor \n{ \n    public abstract static function pure($value): Applicative; \n    public abstract function apply(Applicative $f): Applicative; \n    public function map(callable $f): Functor \n    { \n        return $this->pure($f)->apply($this); \n    } \n} \n```", "```php\n<?php \n\n$five = IdentityApplicative::pure(5); \n$ten = IdentityApplicative::pure(10); \n$applicative = IdentityApplicative::pure($add); \n\necho $applicative->apply($five)->apply($ten)->get(); \n// 15 \n\n$hello = IdentityApplicative::pure('Hello world!'); \n\necho IdentityApplicative::pure('strtoupper')->apply($hello)->get(); \n// HELLO WORLD! echo $hello->map('strtoupper')->get(); \n// HELLO WORLD! \n```", "```php\n<?php \n\nclass IdentityApplicative extends Applicative \n{ \n    private $value; \n\n    protected function __construct($value) \n    { \n        $this->value = $value; \n    } \n\n    public static function pure($value): Applicative \n    { \n        return new static($value); \n    } \n\n    public function apply(Applicative $f): Applicative \n    { \n        return static::pure($this->get()($f->get())); \n    } \n\n    public function get() \n    { \n        return $this->value; \n    } \n} \n```", "```php\n<?php \n\nfunction check_applicative_laws(Applicative $f1, callable $f2, $x) \n{ \n    $identity = function($x) { return $x; }; \n    $compose = function(callable $a) { \n        return function(callable $b) use($a) { \n            return function($x) use($a, $b) { \n                return $a($b($x)); \n            }; \n        }; \n    }; \n\n    $pure_x = $f1->pure($x); \n    $pure_f2 = $f1->pure($f2); \n\n    return [ \n        'identity' => \n            $f1->pure($identity)->apply($pure_x) == \n            $pure_x, \n        'homomorphism' => \n            $f1->pure($f2)->apply($pure_x) == \n            $f1->pure($f2($x)), \n        'interchange' => \n            $f1->apply($pure_x) == \n            $f1->pure(function($f) use($x) { return $f($x); })->apply($f1), \n        'composition' => \n            $f1->pure($compose)->apply($f1)->apply($pure_f2)->apply($pure_x) == \n            $f1->apply($pure_f2->apply($pure_x)), \n        'map' => \n            $pure_f2->apply($pure_x) == \n            $pure_x->map($f2) \n    ]; \n} \n```", "```php\n<?php \n\nprint_r(check_applicative_laws( \nIdentityApplicative::pure('strtoupper'), \n    'trim', \n    ' Hello World! ' \n)); \n// Array \n// ( \n//     [identity] => 1 \n//     [homomorphism] => 1 \n//     [interchange] => 1 \n//     [composition] => 1 \n//     [map] => 1 \n// ) \n```", "```php\n<?php \n\nfunction check_functor_laws(Functor $func, callable $f, callable $g) \n{ \n    $id = function($a) { return $a; }; \n    $composed = function($a) use($f, $g) { return $g($f($a)); }; \n\n    return [ \n        'identity' => $func->map($id) == $id($func), \n        'composition' => $func->map($f)->map($g) == $func->map($composed) \n    ]; \n} \n```", "```php\n<?php \n\nprint_r(check_functor_laws( \n    new IdentityFunctor(10), \n    function($a) { return $a * 10; }, \n    function($a) { return $a + 2; } \n)); \n// Array \n// ( \n//     [identity] => 1 \n//     [composition] => 1 \n// ) \n```", "```php\n<?php \n\nclass CollectionApplicative extends Applicative implements IteratorAggregate \n{ \n    private $values; \n\n    protected function __construct($values) \n    { \n        $this->values = $values; \n    } \n\n    public static function pure($values): Applicative \n    { \n        if($values instanceof Traversable) { \n            $values = iterator_to_array($values); \n        } else if(! is_array($values)) { \n            $values = [$values]; \n        } \n\n        return new static($values); \n    } \n\n    public function apply(Applicative $data): Applicative \n    { \n        return $this->pure(array_reduce($this->values, \n            function($acc, callable $function) use($data) { \n                return array_merge($acc, array_map($function, $data->values) ); \n            }, []) \n        ); \n    } \n\n    public function getIterator() { \n        return new ArrayIterator($this->values); \n    } \n} \n```", "```php\n<?php \n\nprint_r(iterator_to_array(CollectionApplicative::pure([ \n  function($a) { return $a * 2; }, \n  function($a) { return $a + 10; } \n])->apply(CollectionApplicative::pure([1, 2, 3])))); \n// Array \n// ( \n//     [0] => 2 \n//     [1] => 4 \n//     [2] => 6 \n//     [3] => 11 \n//     [4] => 12 \n//     [5] => 13 \n// ) \n```", "```php\n<?php \n\nuse function Functional\\group; \n\nfunction limit_size($image) { return $image; } \nfunction thumbnail($image) { return $image.'_tn'; } \nfunction mobile($image) { return $image.'_small'; } \n\n$images = CollectionApplicative::pure(['one', 'two', 'three']); \n\n$process = CollectionApplicative::pure([ \n  'limit_size', 'thumbnail', 'mobile' \n]); \n\n$transformed = group($process->apply($images), function($image, $index) { \n    return $index % 3; \n}); \n```", "```php\n<?php \n\nprint_r($transformed); \n// Array \n// ( \n//     [0] => Array \n//         ( \n//             [0] => one \n//             [3] =>one_tn \n//             [6] =>one_small \n//         ) \n// \n//     [1] => Array \n//         ( \n//             [1] => two \n//             [4] =>two_tn \n//             [7] =>two_small \n//         ) \n// \n//     [2] => Array \n//         ( \n//             [2] => three \n//             [5] =>three_tn \n//             [8] =>three_small \n//         ) \n// \n//) \n```", "```php\n<?php \n\n$a = 10; $b = 20; $c = 30; \n\nvar_dump($a + 0 === $a); \n// bool(true) \nvar_dump(0 + $a === $a); \n// bool(true) \nvar_dump(($a + $b) + $c === $a + ($b + $c)); \n// bool(true) \n```", "```php\n<?php \n\nvar_dump($a * 1 === $a); \n// bool(true) \nvar_dump(1 * $a === $a); \n// bool(true) \nvar_dump(($a * $b) * $c === $a * ($b * $c)); \n// bool(true) \n```", "```php\n<?php \n\n$v1 = [1, 2, 3]; $v2 = [5]; $v3 = [10]; \n\nvar_dump(array_merge($v1, []) === $v1); \n// bool(true) \nvar_dump(array_merge([], $v1) === $v1); \n// bool(true) \nvar_dump( \narray_merge(array_merge($v1, $v2), $v3) === \narray_merge($v1, array_merge($v2, $v3)) \n); \n// bool(true) \n```", "```php\n<?php \n\n$s1 = \"Hello\"; $s2 = \" World\"; $s3 = \"!\"; \n\nvar_dump($s1 . '' === $s1); \n// bool(true) \nvar_dump('' . $s1 === $s1); \n// bool(true) \nvar_dump(($s1 . $s2) . $s3 == $s1 . ($s2 . $s3)); \n// bool(true) \n```", "```php\n<?php\n\nvar_dump(($a - $b) - $c === $a - ($b - $c));\n// bool(false)\nvar_dump(($a / $b) / $c === $a / ($b / $c));\n// bool(false) \n```", "```php\n<?php \n\nabstract class Monoid \n{ \n    public abstract static function id(); \n    public abstract static function op($a, $b); \n\n    public static function concat(array $values) \n    { \n        $class = get_called_class(); \n        return array_reduce($values, [$class, 'op'], [$class, 'id']()); \n    } \n\n    public function __invoke(...$args) \n    { \n        switch(count($args)) { \n            case 0: throw new RuntimeException(\"Except at least 1 parameter\"); \n            case 1: \n                return function($b) use($args) { \n                    return static::op($args[0], $b); \n                }; \n            default: \n                return static::concat($args); \n        } \n    } \n} \n```", "```php\n<?php \n\nfunction check_monoid_laws(Monoid $m, $a, $b, $c) \n{ \n    return [ \n        'left identity' => $m->op($m->id(), $a) == $a, \n        'right identity' => $m->op($a, $m->id()) == $a, \n        'associativity' => \n            $m->op($m->op($a, $b), $c) == \n            $m->op($a, $m->op($b, $c)) \n    ]; \n} \n```", "```php\n<?php \n\nclass IntSum extends Monoid \n{ \n    public static function id() { return 0; } \n    public static function op($a, $b) { return $a + $b; } \n} \n\nclass IntProduct extends Monoid \n{ \n    public static function id() { return 1; } \n    public static function op($a, $b) { return $a * $b; } \n} \n\nclass StringConcat extends Monoid \n{ \n    public static function id() { return ''; } \n    public static function op($a, $b) { return $a.$b; } \n} \n\nclass ArrayMerge extends Monoid \n{ \n    public static function id() { return []; } \n    public static function op($a, $b) { return array_merge($a, $b); } \n} \n```", "```php\n<?php \n\nprint_r(check_monoid_laws(new IntSum(), 5, 10, 20)); \n// Array \n// ( \n//     [left identity] => 1 \n//     [right identity] => 1 \n//     [associativity] => 1 \n// ) \n\nprint_r(check_monoid_laws(new IntProduct(), 5, 10, 20)); \n// Array \n// ( \n//     [left identity] => 1 \n//     [right identity] => 1 \n//     [associativity] => 1 \n// ) \n\nprint_r(check_monoid_laws(new StringConcat(), \"Hello \", \"World\", \"!\")); \n// Array \n// ( \n//     [left identity] => 1 \n//     [right identity] => 1 \n//     [associativity] => 1 \n// ) \n\nprint_r(check_monoid_laws(new ArrayMerge(), [1, 2, 3], [4, 5], [10])); \n// Array \n// ( \n//     [left identity] => 1 \n//     [right identity] => 1 \n//     [associativity] => 1 \n// ) \n```", "```php\n<?php \n\nclass IntSubtraction extends Monoid \n{ \n    public static function id() { return 0; } \n    public static function op($a, $b) { return $a - $b; } \n} \n\nprint_r(check_monoid_laws(new IntSubtraction(), 5, 10, 20)); \n// Array \n// ( \n//     [left identity] => \n//     [right identity] => 1 \n//     [associativity] => \n// ) \n```", "```php\n<?php \n\nclass Any extends Monoid \n{ \n    public static function id() { return false; } \n    public static function op($a, $b) { return $a || $b; } \n} \n\nclass All extends Monoid \n{ \n    public static function id() { return true; } \n    public static function op($a, $b) { return $a && $b; } \n} \n\nprint_r(check_monoid_laws(new Any(), true, false, true)); \n// Array \n// ( \n//     [left identity] => 1 \n//     [right identity] => 1 \n//     [associativity] => 1 \n// ) \n\nprint_r(check_monoid_laws(new All(), true, false, true)); \n// Array \n// ( \n//     [left identity] => 1 \n//     [right identity] => 1 \n//     [associativity] => 1 \n// ) \n```", "```php\n<?php \n\necho Any::concat([true, false, true, false]) ? 'true' : 'false'; \n// true \n\necho All::concat([true, false, true, false]) ? 'true' : 'false'; \n// false \n```", "```php\n<?php \n\n$numbers = [1, 23, 45, 187, 12]; \necho IntSum::concat($numbers); \n// 268 \n\n$words = ['Hello ', ', ', 'my ', 'name is John.']; \necho StringConcat::concat($words); \n// Hello , my name is John. $arrays = [[1, 2, 3], ['one', 'two', 'three'], [true, false]]; \nprint_r(ArrayMerge::concat($arrays)); \n// [1, 2, 3, 'one', 'two', 'three', true, false] \n```", "```php\n<?php \n\nuse function Functional\\compose; \n\n$add = new IntSum(); \n$times = new IntProduct(); \n\n$composed = compose($add(5), $times(2)); \necho $composed(2); \n// 14 \n```", "```php\n<?php \n\nabstract class Monad extends Applicative \n{ \n    public static function return($value): Monad \n    { \n        return static::pure($value); \n    } \n\n    public abstract function bind(callable $f): Monad; \n} \n```", "```php\n<?php \n\nfunction check_monad_laws($x, Monad $m, callable $f, callable $g) \n{ \n    return [ \n        'left identity' => $m->return($x)->bind($f) == $f($x), \n        'right identity' => $m->bind([$m, 'return']) == $m, \n        'associativity' => \n            $m->bind($f)->bind($g) ==             $m->bind(function($x) use($f, $g) { return $f($x)->bind($g); }), \n    ]; \n} \n```", "```php\nclass IdentityMonad extends Monad \n{ \n    private $value; \n\n    private function __construct($value) \n    { \n        $this->value = $value; \n    } \n\n    public static function pure($value): Applicative \n    { \n        return new static($value); \n    } \n\n    public function get() \n    { \n        return $this->value; \n    } \n\n    public function bind(callable $f): Monad \n    { \n        return $f($this->get()); \n    } \n\n    public function apply(Applicative $a): Applicative \n    { \n        return static::pure($this->get()($a->get())); \n    } \n} \n```", "```php\n<?php \n\nprint_r(check_monad_laws( \n    10, \nIdentityMonad::return(20), \n    function(int $a) { return IdentityMonad::return($a + 10); }, \n    function(int $a) { return IdentityMonad::return($a * 2); } \n)); \n// Array \n// ( \n//     [left identity] => 1 \n//     [right identity] => 1 \n//     [associativity] => 1 \n// ) \n```", "```php\n<?php \n\nfunction upload(string $path, callable $f) { \n    $content = read_file(filename); \n    if($content === false) { \n        return false; \n    } \n\n    $status = post('/uploads', $content); \n    if($status === false) { \n        return $false; \n    } \n\n    return $f($status); \n} \n```", "```php\n<?php \n\nfunction upload_fp(string $path, callable $f) { \n    return Either::pure($path) \n      ->bind('read_file') \n      ->bind(post('/uploads')) \n      ->bind($f); \n} \n```"]