- en: Chapter 3. Associations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 关联
- en: In the previous chapter, we learned how to use Doctrine annotations to add mapping
    information to an entity class. We used code and database schema generators provided
    by Doctrine command-line tools, and we created a minimalist blog software that
    uses an `EntityManager` class to create, update, delete, and display blog posts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用Doctrine注释向实体类添加映射信息。我们使用了Doctrine命令行工具提供的代码和数据库模式生成器，并创建了一个使用`EntityManager`类来创建、更新、删除和显示博客文章的极简主义博客软件。
- en: 'In the third chapter, we will learn how to handle associations between entities
    through the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三章中，我们将学习如何通过以下主题处理实体之间的关联：
- en: Getting started with the Doctrine associations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用Doctrine关联
- en: Understanding the @ManyToOne and @OneToMany annotations with the comment system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解注释系统中的@ManyToOne和@OneToMany注释
- en: Understanding the @ManyToMany annotation with tags
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解标签的@ManyToMany注释
- en: Getting started with the Doctrine associations
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Doctrine关联
- en: 'We will specify Doctrine associations, such as other mapping information, using
    annotations (other methods such as XML and YAML configuration files are also supported.
    See [Chapter 2](ch02.html "Chapter 2. Entities and Mapping Information"), *Entities
    and Mapping Information*). Doctrine supports the following association types:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用注释指定Doctrine关联，以及其他映射信息（还支持其他方法，如XML和YAML配置文件。请参阅[第2章](ch02.html "第2章.
    实体和映射信息")，*实体和映射信息*）。Doctrine支持以下关联类型：
- en: '**One-To-One**: One entity is linked to one entity'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一**：一个实体与一个实体相关联'
- en: '**Many-To-One**: Several entities are linked to one entity (only available
    for bidirectional associations and always the inverse side of a One-To-Many association)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对一**：多个实体与一个实体相关联（仅适用于双向关联，始终是一对多关联的反向方）'
- en: '**One-To-Many**: One entity is linked to several entities'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对多**：一个实体与多个实体相关联'
- en: '**Many-To-Many**: Several entities are linked to several entities'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对多**：多个实体与多个实体相关联'
- en: 'An association can be unidirectional or bidirectional. Unidirectional associations
    only have an owning side while bidirectional associations have both an owning
    side and an inverse side. In other words they can be explained as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关联可以是单向的或双向的。单向关联只有一个拥有方，而双向关联既有拥有方又有反向方。换句话说，它们可以解释如下：
- en: 'A unidirectional association can be used in only one way: related entities
    are retrievable from the main entities. For example, a user has associated addresses.
    Addresses can be retrieved from the user, but the user cannot be retrieved from
    an address.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单向关联只能以一种方式使用：相关实体可以从主实体中检索。例如，用户有关联地址。地址可以从用户中检索，但用户无法从地址中检索。
- en: 'A bidirectional association can be used in two ways: related entities are retrievable
    from main entities, and main entities are retrievable from related entities. For
    example, a user has associated orders. Orders can be retrieved from the user,
    and the user can be retrieved from an order.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向关联可以以两种方式使用：相关实体可以从主实体中检索，主实体可以从相关实体中检索。例如，用户有关联订单。订单可以从用户中检索，用户也可以从订单中检索。
- en: Doctrine only manages the owning side of an association. This means that you
    always need to set the owning side; otherwise, if you only set the inverse side
    of an association, it will not be persisted with by the `EntityManager` class.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine只管理关联的拥有方。这意味着您始终需要设置拥有方；否则，如果您只设置关联的反向方，它将不会由`EntityManager`类持久化。
- en: There is an easy way to identify the side of a bidirectional association. The
    owning side must have an `inversedBy` attribute, and the inverse side must have
    a `mappedBy` attribute. These attributes refer to the related entity class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种简单的方法来识别双向关联的方向。拥有方必须具有`inversedBy`属性，而反向方必须具有`mappedBy`属性。这些属性指的是相关的实体类。
- en: By default, One-To-One and Many-To-One associations are persisted with at the
    SQL level using a column storing the related ID and a foreign key. Many-To-Many
    associations always use an association table.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，一对一和多对一关联在SQL级别上使用存储相关ID和外键的列进行持久化。多对多关联始终使用关联表。
- en: The names of columns and tables (if applicable) are generated automatically
    by Doctrine. Names can be changed using the `@JoinColumn` annotation, and the
    use of an association table can be forced with the `@JoinTable` annotation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine会自动生成列和表的名称（如果适用）。可以使用`@JoinColumn`注释更改名称，并使用`@JoinTable`注释强制使用关联表。
- en: Understanding the @ManyToOne and @OneToMany annotations with the comment system
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解注释系统中的@ManyToOne和@OneToMany注释
- en: Let's start with the comments. Visitors to our blog should be able to react
    to our posts. We have to create a new `Comment` Doctrine entity type storing the
    reader's comments. `Comment` entities will be linked to one `Post` entity. One
    post can have many comments, and one comment is associated with a sole post.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从评论开始。我们博客的访问者应该能够对我们的帖子做出反应。我们必须创建一个新的`Comment` Doctrine实体类型，存储读者的评论。`Comment`实体将与一个`Post`实体相关联。一个帖子可以有多条评论，一条评论与一个帖子相关联。
- en: 'The following E-R diagram represents the MySQL schema that will be generated
    using mapping information:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下E-R图表示将使用映射信息生成的MySQL模式：
- en: '![Understanding the @ManyToOne and @OneToMany annotations with the comment
    system](graphics/4104_03_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![理解注释系统中的@ManyToOne和@OneToMany注释](graphics/4104_03_01.jpg)'
- en: Creating the Comment entity class (owning side)
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建评论实体类（拥有方）
- en: 'The `Comment` entity has the following four properties:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comment`实体具有以下四个属性：'
- en: '`id`: This is a unique identifier of the comment'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是评论的唯一标识符'
- en: '`body`: This represents the comment''s text'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`：这代表评论的文本'
- en: '`publicationDate`: This is the date of publication of the comment'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publicationDate`：这是评论发布的日期'
- en: '`post_id`: This represents the post related to the comment'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post_id`：这代表与评论相关的帖子'
- en: Here is the first code snippet of the `Comment` entity, containing annotated
    properties. It must be placed in the `Comment.php` file at the `src/Blog/Entity/`
    location.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Comment`实体的第一个代码片段，包含有注释的属性。它必须放在`Comment.php`文件中，位于`src/Blog/Entity/`位置。
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This entity class is similar to the `Post` entity class created in [Chapter
    2](ch02.html "Chapter 2. Entities and Mapping Information"), *Entities and Mapping
    Information*. We use the `@ManyToOne` annotation to create a Many-To-One association
    between the `Comment` and `Post` entities. The related entity class is specified
    using the `targetEntity` attribute. This attribute is mandatory for every association.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实体类类似于[第2章](ch02.html "第2章。实体和映射信息")中创建的`Post`实体类，*实体和映射信息*。我们使用`@ManyToOne`注释在`Comment`和`Post`实体之间创建多对一关联。使用`targetEntity`属性指定相关实体类是必需的。
- en: To be able to retrieve comments directly from the `Post` entity, this association
    must be bidirectional. The `inversedBy` attribute marks this association as bidirectional
    and indicates the property of the `Post` entity class that owns the inverse side
    of this association. Here, this is the `$comments` property of `Post`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够直接从`Post`实体中检索评论，这个关联必须是双向的。`inversedBy`属性将此关联标记为双向，并指示`Post`实体类拥有这个关联的反向端的属性。在这里，这是`Post`的`$comments`属性。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As for every entity class with `private` or `protected` properties, the `Comment`
    class must expose getters and setters to access them. We will generate getters
    and setters for every entity class of our app later in this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个具有`private`或`protected`属性的实体类，`Comment`类必须公开getter和setter来访问它们。我们将在本章后面为我们应用程序的每个实体类生成getter和setter。
- en: Adding the inverse side to the Post entity class
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为`Post`实体类添加反向端
- en: 'Now, we need to modify the `Post` entity class to add the inverse side of this
    association. The following steps need to be performed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改`Post`实体类以添加这个关联的反向端。需要执行以下步骤：
- en: 'Open the `Post.php` file at the `src/Blog/Entity/` location, and add the use
    statements from the previous code snippet:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/Blog/Entity/`位置的`Post.php`文件，并从前一个代码片段中添加use语句：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the `$comments` property as shown in the following code snippet:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码片段中所示添加`$comments`属性：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add its initialization code in the constructor as shown in the next code snippet:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其初始化代码添加到构造函数中，如下一个代码片段所示：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use the entity generator provided by Doctrine command-line tools to create
    getters and setters of the properties we have just added to the `Comment` and
    `Post` classes:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Doctrine命令行工具提供的实体生成器为我们刚刚添加到`Comment`和`Post`类的属性创建getter和setter：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the generated `addComment()` method, add the highlighted line of the following
    code snippet to automatically set the owning side of the association:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生成的`addComment()`方法中，添加以下代码片段中的突出显示行以自动设置关联的拥有端：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `$comments` property holds the collection of comments associated with the
    `Post` entity. We use the `@OneToMany` annotation to mark this property as the
    inverse side of the association, defined earlier in the `$post` property of `Comment`.
    We have already explained the `targetEntity` attribute. The `mappedBy` attribute
    is an equivalent of the `inversedBy` attribute for the inverse side of an association.
    It indicates the property of the related entity class owning the other side of
    the association.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`$comments`属性保存与`Post`实体相关联的评论集合。我们使用`@OneToMany`注释将此属性标记为关联的反向端，之前在`Comment`的`$post`属性中定义。我们已经解释了`targetEntity`属性。`mappedBy`属性是关联的反向端的`inversedBy`属性的等价物。它指示相关实体类的属性拥有关联的另一端。'
- en: To allow Doctrine to manage the collection of elements properly, a special class
    provided by the Doctrine Common component must be used. The `$comments` property
    of the `Post` entity is initialized in the constructor as an instance of `Doctrine\Common\Collections\ArrayCollection`.
    `ArrayCollection` implements the `Doctrine\Common\Collections\Collection` interface.
    This will enable Doctrine to populate and manage the collection.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Doctrine正确管理元素的集合，必须使用Doctrine Common组件提供的特殊类。`Post`实体的`$comments`属性在构造函数中初始化为`Doctrine\Common\Collections\ArrayCollection`的实例。`ArrayCollection`实现了`Doctrine\Common\Collections\Collection`接口。这将使Doctrine能够填充和管理集合。
- en: Doctrine `Collection` class implements the `Countable`, `IteratorAggregate`,
    and `ArrayAccess` interfaces (these interfaces are predefined in PHP or in the
    SPL). With that, Doctrine collections can be used like the standard PHP arrays
    and iterated transparently in the foreach loops.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine `Collection`类实现了`Countable`、`IteratorAggregate`和`ArrayAccess`接口（这些接口在PHP或SPL中预定义）。因此，Doctrine集合可以像标准的PHP数组一样使用，并且可以在foreach循环中透明地迭代。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More information about predefined interfaces and interfaces provided by the
    Standard PHP Library (SPL) can be found in the following PHP manual:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有关预定义接口和标准PHP库（SPL）提供的接口的更多信息，请参阅以下PHP手册：
- en: '[http://php.net/manual/en/reserved.interfaces.php](http://php.net/manual/en/reserved.interfaces.php)
    and [http://php.net/manual/en/spl.interfaces.php](http://php.net/manual/en/spl.interfaces.php)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://php.net/manual/en/reserved.interfaces.php](http://php.net/manual/en/reserved.interfaces.php)和[http://php.net/manual/en/spl.interfaces.php](http://php.net/manual/en/spl.interfaces.php)'
- en: The `addComment()` and `removeComment()` methods generated by Doctrine command-line
    tools demonstrate the ways to use the methods of a Doctrine `Collection` class
    to add and remove items.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine命令行工具生成的`addComment()`和`removeComment()`方法演示了如何使用Doctrine `Collection`类的方法来添加和删除项目。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The full list of available methods is documented on the Doctrine website as
    follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可用方法的完整列表在Doctrine网站上有文档，如下所示：
- en: '[http://docs.doctrine-project.org/en/latest/reference/working-with-associations.html](http://docs.doctrine-project.org/en/latest/reference/working-with-associations.html)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.doctrine-project.org/en/latest/reference/working-with-associations.html](http://docs.doctrine-project.org/en/latest/reference/working-with-associations.html)'
- en: Another important thing, as already explained, is that Doctrine only manages
    the owning side of an association. This is why we call the `setPost()` method
    of the `Comment` entity in the `addComment()` method. This allows persisting with
    an association from the inverse side.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情，正如已经解释的那样，Doctrine只管理关联的拥有方。这就是为什么我们在`addComment()`方法中调用`Comment`实体的`setPost()`方法。这允许从反向方面进行关联的持久化。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This works only if the change-tracking policy of the entity is Deferred Implicit
    (This is the case by default). The deferred implicit policy is the most convenient
    one to use but can have negative effects on performance.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅在实体的更改跟踪策略是延迟隐式时才有效（这是默认情况）。延迟隐式策略是最方便的使用方式，但可能对性能产生负面影响。
- en: 'Again, refer to the Doctrine documentation at the following website to learn
    more about the different change-tracking policies that can be used:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 再次参考Doctrine文档，了解更多可以使用的不同更改跟踪策略：
- en: '[http://docs.doctrine-project.org/en/latest/reference/change-tracking-policies.html](http://docs.doctrine-project.org/en/latest/reference/change-tracking-policies.html)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.doctrine-project.org/en/latest/reference/change-tracking-policies.html](http://docs.doctrine-project.org/en/latest/reference/change-tracking-policies.html)'
- en: In a moment, we will update our UI to add the comment feature. First the database
    schema must be updated.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新我们的UI以添加评论功能。首先必须更新数据库模式。
- en: Updating the database schema
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新数据库模式
- en: 'As with other annotations, Doctrine is able to automatically create the columns
    and foreign keys needed to store associations at the SQL layer. Run the `orm:schema-tool:update`
    command again bundled with the command-line tools as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他注释一样，Doctrine能够自动创建在SQL层存储关联所需的列和外键。再次运行`orm:schema-tool:update`命令，与命令行工具捆绑在一起，如下所示：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Doctrine will automatically detect changes done to the mapping and will update
    the SQL schema accordingly. The `--force` flag can be added to effectively execute
    queries.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine将自动检测对映的更改，并相应地更新SQL模式。可以添加`--force`标志来有效执行查询。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `orm:schema-tool:update` command must not be used in production. It can
    permanently delete data (when columns are dropped for instance). Instead, the
    Doctrine Migrations library should be used to properly handle complicated migrations.
    Even if this library is not considered stable yet, it is very convenient. We can
    find this library at the following website:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`orm:schema-tool:update`命令不应该在生产中使用。它可能会永久删除数据（例如，当删除列时）。相反，应该使用Doctrine Migrations库来正确处理复杂的迁移。即使这个库还没有被认为是稳定的，它非常方便。我们可以在以下网站找到这个库：'
- en: '[http://docs.doctrine-project.org/projects/doctrine-migrations/en/latest/reference/introduction.html](http://docs.doctrine-project.org/projects/doctrine-migrations/en/latest/reference/introduction.html)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.doctrine-project.org/projects/doctrine-migrations/en/latest/reference/introduction.html](http://docs.doctrine-project.org/projects/doctrine-migrations/en/latest/reference/introduction.html)'
- en: Adding fixtures for the comments
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为评论添加装置
- en: 'As for posts, we will create some fixtures for the comments. Create a new file,
    `LoadCommentData.php` in the `src/Blog/DataFixtures/` location. The next code
    snippet is used for this purpose:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 至于帖子，我们将为评论创建一些装置。在`src/Blog/DataFixtures/`位置创建一个名为`LoadCommentData.php`的新文件。下一个代码片段用于此目的：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We use the `EntityManager` class to retrieve the `Post` entity repository, and
    then we use this repository to retrieve all the posts. We add five comments to
    each post. This data fixture class implements the `Doctrine\Common\DataFixtures\DependentFixtureInterface`
    interface (the `getDependencies()` method). It tells the data loader to load `LoadPostData`
    first because this data fixture class is dependent on it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`EntityManager`类来检索`Post`实体存储库，然后我们使用这个存储库来检索所有的帖子。我们为每个帖子添加了五条评论。这个数据装置类实现了`Doctrine\Common\DataFixtures\DependentFixtureInterface`接口（`getDependencies()`方法）。它告诉数据加载器首先加载`LoadPostData`，因为这个数据装置类依赖于它。
- en: Listing and creating comments
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出和创建评论
- en: It's time to update the UI. Create a file, `view-post.php` in the `web/` location.
    This page displays a single post with all its comments and a form to add a new
    comment, and handles the comment creation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候更新UI了。在`web/`位置创建一个名为`view-post.php`的文件。这个页面显示一个帖子和它的所有评论，还有一个添加新评论的表单，并处理评论的创建。
- en: 'The code to retrieve the post and handle the comment creation is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检索帖子和处理评论创建的代码如下：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, managing simple associations with Doctrine is easy. Setting
    a relation is as simple as calling a setter with the entity to the link in the
    parameter. Related entities are accessible using getters. The code to display
    details of the post, associated comments, and a form to publish a new comment
    (put it at the bottom of the same file) is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用Doctrine管理简单的关联是很容易的。设置关系就像调用一个带有实体链接的setter一样简单。使用getter可以访问相关实体。用于显示帖子的详细信息、相关评论和发布新评论的表单的代码（将其放在同一个文件的底部）如下：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By default, Doctrine lazyloads the associated entities. It means that, in our
    example, Doctrine sends a first query to the DBMS to retrieve the post and then
    another to retrieve associated comments when `getComments()` is called. The benefit
    is that the query to retrieve the associated comments is never executed if the
    `getComments()` method is not called. But when the associated comments are always
    fetched, this is a useless overhead.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Doctrine会延迟加载关联的实体。这意味着，在我们的例子中，当调用`getComments()`时，Doctrine首先向DBMS发送一个查询来检索帖子，然后再发送另一个查询来检索关联的评论。好处是，如果不调用`getComments()`方法，检索关联评论的查询将永远不会执行。但是当关联评论总是被获取时，这是一个无用的开销。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To make the lazyloading feature work, Doctrine internally wraps the entities
    into proxy classes. Proxy classes are responsible for getting the data of associated
    entities not already loaded from the database, when requested. Some details about
    that can be found at:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使延迟加载功能起作用，Doctrine在内部将实体包装成代理类。代理类负责在请求时获取尚未从数据库加载的关联实体的数据。关于这方面的一些细节可以在以下网址找到：
- en: '[http://docs.doctrine-project.org/en/latest/reference/working-with-objects.html#entity-object-graph-traversal](http://docs.doctrine-project.org/en/latest/reference/working-with-objects.html#entity-object-graph-traversal)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.doctrine-project.org/en/latest/reference/working-with-objects.html#entity-object-graph-traversal](http://docs.doctrine-project.org/en/latest/reference/working-with-objects.html#entity-object-graph-traversal)'
- en: 'We can change this behavior by setting a `fetch` attribute on the association
    annotation. This attribute can take the following values:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在关联注释上设置`fetch`属性来更改这种行为。该属性可以采用以下值：
- en: '`EAGER`: The related entities are generally fetched in the first query using
    a SQL join.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EAGER`：通常在第一个查询中使用SQL连接获取相关实体。'
- en: '`LAZY`: The related entities are fetched only if requested with another SQL
    query. This is the default value.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`懒加载`：相关实体只有在使用另一个SQL查询请求时才会被获取。这是默认值。'
- en: '`EXTRA_LAZY`: This allows performing some operations such as counting on collections
    that are not already fetched without loading the entire collection in the memory.
    To learn more about this topic, consult the following tutorial:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXTRA_LAZY`：这允许在不加载整个集合到内存中的情况下执行一些操作，例如计数。要了解更多信息，请参阅以下教程：'
- en: '[http://docs.doctrine-project.org/en/latest/tutorials/extra-lazy-associations.html](http://docs.doctrine-project.org/en/latest/tutorials/extra-lazy-associations.html)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.doctrine-project.org/en/latest/tutorials/extra-lazy-associations.html](http://docs.doctrine-project.org/en/latest/tutorials/extra-lazy-associations.html)'
- en: Another way to eagerload the related entities is to use the Doctrine Query Builder
    to customize the generated request. We will demonstrate the power of the Query
    Builder in [Chapter 4](ch04.html "Chapter 4. Building Queries"), *Building Queries*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种急切加载相关实体的方法是使用Doctrine查询构建器来自定义生成的请求。我们将在[第4章](ch04.html "第4章。构建查询")中展示查询构建器的强大功能。
- en: 'By deleting comments in the `view-post.php` page, we have created a link allowing
    the deletion of comments. The code to put in the `delete-comment.php` file in
    the `web/` location to make this feature work is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`view-post.php`页面中删除评论，我们创建了一个允许删除评论的链接。要使此功能正常工作，需要在`web/`位置的`delete-comment.php`文件中放入以下代码：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This file is very similar to the `delete-post.php` file in the `web/` location
    created in [Chapter 1](ch01.html "Chapter 1. Getting Started with Doctrine 2"),
    *Getting Started with Doctrine 2*. It retrieves the repository through the `EntityManager`
    class, uses it to retrieve the comment to delete, calls `remove()`, and persists
    with the change to DBMS with `flush()`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件与[第1章](ch01.html "第1章。开始使用Doctrine 2")中在`web/`位置创建的`delete-post.php`文件非常相似，*开始使用Doctrine
    2*。它通过`EntityManager`类检索存储库，使用它检索要删除的评论，调用`remove()`，并使用`flush()`将更改持久化到DBMS。
- en: Updating the index
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新索引
- en: 'Update the `index.php` file in the `web/` location to create a link to the
    new, detailed post view as shown in the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`web/`位置的`index.php`文件，创建一个链接到新的详细帖子视图，如下所示：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To make our comment feature ready, replace the preceding code with the following
    code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的评论功能准备就绪，请使用以下代码替换前面的代码：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Understanding the @ManyToMany annotation with tags
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解标签的@ManyToMany注释
- en: 'Tags group posts by topics. A tag contains several posts, and a post has several
    tags. This is a Many-To-Many bidirectional association. Doctrine manages transparently
    the association table needed to store Many-To-Many relations at the SQL level.
    The MySQL schema that will be generated is shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 标签按主题对帖子进行分组。一个标签包含多个帖子，一个帖子有多个标签。这是一个多对多双向关联。Doctrine在SQL级别上透明地管理存储多对多关系所需的关联表。将生成的MySQL模式显示在以下截图中：
- en: '![Understanding the @ManyToMany annotation with tags](graphics/4104_03_02.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![理解标签的@ManyToMany注释](graphics/4104_03_02.jpg)'
- en: Creating the Tag entity class (inverse side)
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建`Tag`实体类（反向端）
- en: 'The `Tag` entity class has only two properties:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tag`实体类只有两个属性：'
- en: '`name`: This is the name of the tag, it is unique, and is the identifier of
    the entity'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是标签的名称，它是唯一的，并且是实体的标识符'
- en: '`posts`: This is the collection of posts associated with this tag'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`posts`：这是与此标签关联的帖子集合'
- en: 'The following are the steps to create the `Tag` entity class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建`Tag`实体类的步骤：
- en: 'Create a `Tag.php` file in the `src/Blog/Entity/` location that contains the
    entity class using the following code snippet:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/Blog/Entity/`位置创建一个`Tag.php`文件，其中包含使用以下代码片段的实体类：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Generate getters and setters using the following command:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令生成getter和setter：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following line of code to set the owning side of the association after
    `$this->posts[] = $posts;` in the `addPost()` method:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`addPost()`方法中的`$this->posts[] = $posts;`之后添加以下代码行以设置关联的拥有端：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The property `$name` is the identifier of the `Tag` entity. Unlike the `Post`
    and `Comment` entities, its value is not automatically generated by DBMS; it's
    the name of the tag. That's why the `@GeneratedValue` annotation is not used here.
    The name of the tag must be unique and must be set by the application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`$name`属性是`Tag`实体的标识符。与`Post`和`Comment`实体不同，它的值不是由DBMS自动生成的；它是标签的名称。这就是为什么这里不使用`@GeneratedValue`注释。标签的名称必须是唯一的，并且必须由应用程序设置。'
- en: The `@ManyToMany` annotation is used to mark the association. The meanings of
    the `targetEntity` and `mappedBy` attributes are the same as for the `@OneToMany`
    annotation. The `@ManyToMany` annotation accepts a `mappedBy` attribute for the
    inverse side and `inversedBy` for the owning side. The owning side of this association
    is on the `Post` entity. As for any Doctrine collection, the `$posts` property
    is initialized in the constructor. We also create a `__toString()` method returning
    the name of the tag to be able to cast instances of `Tag` to the string.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ManyToMany`注释用于标记关联。`targetEntity`和`mappedBy`属性的含义与`@OneToMany`注释相同。`@ManyToMany`注释接受`mappedBy`属性作为反向端，`inversedBy`作为拥有端。这个关联的拥有端在`Post`实体上。与任何Doctrine集合一样，`$posts`属性在构造函数中被初始化。我们还创建一个`__toString()`方法，返回标签的名称，以便能够将`Tag`的实例转换为字符串。'
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `__toString()` magic method allows us to convert an object to a string.
    For more details we can refer to the following link:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`__toString()`魔术方法允许我们将对象转换为字符串。有关更多详细信息，我们可以参考以下链接：'
- en: '[http://www.php.net/manual/en/language.oop5.magic.php#object.tostring](http://www.php.net/manual/en/language.oop5.magic.php#object.tostring)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.php.net/manual/en/language.oop5.magic.php#object.tostring](http://www.php.net/manual/en/language.oop5.magic.php#object.tostring)'
- en: Updating the Post entity class (owning side)
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新Post实体类（拥有方）
- en: 'Modify the `Post.php` file in the `src/Blog/Entity/` location to add the owning
    side of the association using the following steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`src/Blog/Entity/`位置的`Post.php`文件，以添加关联的拥有方使用以下步骤：
- en: 'Add the following use statements:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`use`语句：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the `mapped` property using the following code snippet:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段添加`mapped`属性：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Initialize the property in the constructor as shown in the following code snippet:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码片段中所示的方式在构造函数中初始化属性：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To generate getters and setters, you can use the following command:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要生成getter和setter，可以使用以下命令：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Two new attributes of the `@ManyToMany` annotation are introduced here, that
    is, `cascade` and `orphanRemoval`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍了`@ManyToMany`注释的两个新属性，即`cascade`和`orphanRemoval`。
- en: By default, the associated entities are not automatically set to the managed
    state when the main entity is set. This must be done manually with a call to the
    `persist()` method of the `EntityManager` class for each associated entity. If
    the `cascade` attribute is used with `persist` as value, the related entities
    will be automatically persisted with when the main entity is persisted with.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当设置主实体时，关联实体不会自动设置为托管状态。这必须通过对每个关联实体的`EntityManager`类的`persist()`方法进行手动调用来完成。如果`cascade`属性与`persist`一起使用，相关实体将在持久化主实体时自动持久化。
- en: Here, the related tags will be persisted with when the `Post` entity is persisted
    with. The `cascade` attribute can take other values, the most useful of which
    is `remove`. When `remove` is used, the related entities will be deleted when
    the main entity is deleted.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当持久化`Post`实体时，相关标签将一起持久化。`cascade`属性可以采用其他值，其中最有用的是`remove`。使用`remove`时，当删除主实体时，相关实体将被删除。
- en: The `CASCADE` operations are handled in memory by **Object Relational Mapper
    (ORM)** . They are not equivalent to the SQL `DELETE CASCADE` operations and can
    use a lot of memory. They should be used with parsimony to preserve the performance
    of the application.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象关系映射器（ORM）**在内存中处理`CASCADE`操作。它们不等同于SQL的`DELETE CASCADE`操作，并且可能使用大量内存。应该谨慎使用以保持应用程序的性能。'
- en: The SQL `DELETE CASCADE` operations can be added through the `onDelete` attribute
    of the `@JoinColumn` annotation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`@JoinColumn`注释的`onDelete`属性添加SQL`DELETE CASCADE`操作。
- en: With the `orphanRemoval` attribute set to `true`, Doctrine will automatically
    delete the entities not linked with the main entity anymore. If the `Tag` entity
    is removed from the `$tags` collection of a `Post` entity, and this `Post` entity
    was the only one linked to the `Tag` entity, the `Tag` entity will be permanently
    deleted.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将`orphanRemoval`属性设置为`true`，Doctrine将自动删除不再与主实体关联的实体。如果从`Post`实体的`$tags`集合中删除`Tag`实体，并且这个`Post`实体是唯一与`Tag`实体关联的实体，那么`Tag`实体将被永久删除。
- en: The `fetch` attribute has already been explained earlier in the chapter. With
    the `EAGER` value, it tells Doctrine to automatically retrieve the related tags
    with a `JOIN` query when the posts are retrieved. This is useful in the context
    of our app because the tags of the `Post` entity are displayed every time the
    post is displayed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch`属性已在本章中进行了解释。使用`EAGER`值，它告诉Doctrine在检索帖子时自动使用`JOIN`查询检索相关标签。在我们的应用程序环境中，这是有用的，因为`Post`实体的标签在每次显示帖子时都会显示。'
- en: Because the identifier of `Tag` is not marked with the `@GeneratedValue` annotation,
    Doctrine will not be able to guess it. The `@JoinTable` and `@JoinColumn` annotations
    are here to override the default behavior.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Tag`的标识符没有标记`@GeneratedValue`注释，Doctrine将无法猜测它。`@JoinTable`和`@JoinColumn`注释在这里用于覆盖默认行为。
- en: We set a custom `JOIN` column with `@JoinColumn` for the tag-related side of
    the association (inverse side) through the `inverseJoinColumns` attribute of `@JoinTable`.
    The `referencedColumnName` attribute of `@JoinColumn` tells Doctrine to look for
    the `$name` property (instead of `$id` by default) for the identifier of `Tag`.
    The `name` attribute sets the name of the column holding the identifier of `Tag`
    in the SQL level association table to `tag_name` (instead of `tag_id` by default).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@JoinColumn`为关联方（反向方）设置自定义`JOIN`列，通过`@JoinTable`的`inverseJoinColumns`属性。`@JoinColumn`的`referencedColumnName`属性告诉Doctrine在SQL级联表中查找`Tag`的标识符的`$name`属性（默认情况下是`$id`）。`name`属性将`Tag`的标识符的列名称设置为`tag_name`（默认情况下是`tag_id`）。
- en: Updating the schema again
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 再次更新模式
- en: 'It''s time to update the SQL schema again to match our changes. We use the
    following command on the command line:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候再次更新SQL模式以匹配我们的更改。我们在命令行上使用以下命令：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Creating tag fixtures
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建标签固定装置
- en: 'Create a `LoadTagData.php` file at `src/Blog/DataFixtures/`, which contains
    tag fixtures using the following code snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/Blog/DataFixtures/`创建一个`LoadTagData.php`文件，其中包含使用以下代码片段的标签固定装置：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Thanks to the `persist` attribute, we can add tags to posts without manually
    persisting with them.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`persist`属性，我们可以在不手动持久化的情况下向帖子添加标签。
- en: After the fixtures, we have to update the UI.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 固定装置后，我们必须更新UI。
- en: Managing the tags of a post
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理帖子的标签
- en: 'Edit the `edit-post.php` file at the `web/` location, and add the code to manage
    the tags with the following steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`web/`位置的`edit-post.php`文件，并按以下步骤添加代码来管理标签：
- en: 'Add the following `use` statement at the top of the file:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部添加以下`use`语句：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Find the following code snippet:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到以下代码片段：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add this code after `to extract` and manage the submitted tags:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`to extract`和管理提交的标签后添加此代码：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Find the following code snippet:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到以下代码片段：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the following form widget after `to display` and update the tags:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`to display`后添加以下表单部件以更新标签：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Each tag name is extracted from the submitted string. The corresponding `Tag`
    entity is retrieved from the repository or created if not found.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从提交的字符串中提取每个标签名称。从存储库中检索相应的`Tag`实体，如果找不到则创建。
- en: Thanks to its `toArray()` method, the `tag` collection of the `Post` object
    is converted to a standard PHP array.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它的`toArray()`方法，`Post`对象的`tag`集合被转换为标准的PHP数组。
- en: The standard `array_diff()` function is used to identify removed and added `Tag`
    objects. The arguments of `array_diff()` must be arrays of objects that can be
    converted to a string. It is okay here because our `Tag` class implements the
    `__toString()` magic method.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`array_diff()`函数用于识别已删除和已添加的`Tag`对象。`array_diff()`的参数必须是可以转换为字符串的对象数组。这里可以使用，因为我们的`Tag`类实现了`__toString()`魔术方法。
- en: Deleted tags are removed through the `Post::removeTag()` function, and new tags
    are added through `Post::addTag()`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 已删除的标签通过`Post::removeTag()`函数移除，新标签通过`Post::addTag()`添加。
- en: Thanks to the `CASCADE` attribute defined in the `Post` entity class, we don't
    need to persist individually with each new tag.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢在`Post`实体类中定义的`CASCADE`属性，我们不需要针对每个新标签单独持久化。
- en: In the template, the tag list is transformed to a string following the pattern
    "tagname1, tagname2, tagname3".
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，标签列表按照“tagname1，tagname2，tagname3”的模式转换为字符串。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned how to manage all types of associations supported
    by the Doctrine ORM. We learned about unidirectional and bidirectional associations
    and the concept of owning side and inverse side. We also used what we have learned
    in previous chapters, especially the `EntityManager` class, the fixture loader,
    and generators.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何管理Doctrine ORM支持的所有类型的关联。我们学习了单向和双向关联以及拥有方和反向方的概念。我们还运用了我们在之前章节学到的知识，特别是`EntityManager`类、装置加载器和生成器。
- en: In the next chapter, we will learn how to create complex queries with DQL and
    Query Builder.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用DQL和Query Builder创建复杂的查询。
- en: Thanks to them, we will create lists of posts grouped by their tags. We will
    also take a look at the aggregate functions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们，我们将创建按标签分组的帖子列表。我们还将研究聚合函数。
