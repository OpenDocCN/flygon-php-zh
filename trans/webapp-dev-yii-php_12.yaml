- en: Chapter 12. Production Readiness
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。投产准备
- en: Even though our application lacks a significant amount of feature functionality,
    our (albeit imaginary) deadlines are approaching and our (also imaginary) client
    is getting anxious about getting the application into a production environment.
    Even though it may be some time before our application actually sees the light
    of day in production, it is time to get the application "production ready". In
    this, our final chapter of development, we are going to do just that.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的应用程序缺乏大量的功能功能，我们（虽然是想象中的）截止日期正在临近，我们（同样是想象中的）客户对将应用程序投入生产环境感到焦虑。尽管我们的应用程序在生产中真正见到天日可能还需要一些时间，但现在是时候让应用程序“准备投产”了。在我们的最后一个开发章节中，我们将做到这一点。
- en: Feature planning
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能规划
- en: 'In order to achieve the goal of preparing our application for a production
    environment, we are going to focus on the following granular tasks:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的应用程序为生产环境做好准备的目标，我们将专注于以下细粒度的任务：
- en: Implement Yii's application logging framework to ensure we are logging information
    about critical production errors and events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Yii的应用程序日志记录框架，以确保我们记录关于关键生产错误和事件的信息
- en: Implement Yii's application error handling framework to ensure we properly handle
    errors in production and understand how this works differently in a production
    environment rather than in a development environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Yii的应用程序错误处理框架，以确保我们在生产中正确处理错误，并了解这在生产环境和开发环境中的工作方式有所不同
- en: Implement application data caching to help improve performance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现应用程序数据缓存以帮助提高性能
- en: Logging
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: Logging is a topic that should arguably have been covered before this late stage
    in the application development. Informational, warning, and severe error messages
    are invaluable when it comes to troubleshooting in software applications, and
    most certainly for those in a production environment being used by real users.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是一个在应用程序开发的这个后期阶段应该被讨论的话题。在软件应用程序的故障排除中，信息、警告和严重错误消息是非常宝贵的，尤其是对于那些在生产环境中由真实用户使用的应用程序。
- en: As developers, we are all familiar with this story. You have met all of the
    functional requirements of the application you are building. All of the unit and
    functional tests are passing. The application has been approved by QA, and everyone
    feels great about it being ready for production. But as soon as it goes in and
    is under real production load, with real users interacting with it, it behaves
    unexpectedly. A good logging strategy could make the difference between a swift
    resolution and rolling back weeks or even months of hard work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，我们都熟悉这个故事。您已经满足了您正在构建的应用程序的所有功能要求。所有单元和功能测试都通过了。应用程序已经通过了QA的批准，每个人都对它准备投产感到很满意。但是一旦它投入使用，并且承受着真实用户的真实生产负载，它的行为就会出乎意料。一个良好的日志记录策略可能会成为快速解决问题和回滚数周甚至数月的辛苦工作之间的区别。
- en: Yii provides flexible and extensible logging capabilities. The data logged can
    be classified according to log levels and message categories. Using level and
    category filters, log messages can be further routed to different destinations,
    such as written to files on disc, stored in a database, sent to administrators
    as emails, or displayed in browser windows.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Yii提供了灵活和可扩展的日志记录功能。记录的数据可以根据日志级别和消息类别进行分类。使用级别和类别过滤器，日志消息可以进一步路由到不同的目的地，例如写入磁盘上的文件，存储在数据库中，发送给管理员作为电子邮件，或在浏览器窗口中显示。
- en: Message logging
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息记录
- en: Our application has actually been logging many informational messages upon each
    request the entire time. When the initial application was created it was configured
    to be in *debug* mode and while in this mode, the Yii framework itself logs information
    messages. We can't actually see these messages because, by default, they are being
    logged to memory. So, they are around only for the lifetime of the request.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序实际上一直在每个请求时记录许多信息消息。当初始应用程序被创建时，它被配置为处于*调试*模式，而在此模式下，Yii框架本身会记录信息消息。我们实际上看不到这些消息，因为默认情况下它们被记录到内存中。因此，它们只在请求的生命周期内存在。
- en: 'Whether or not the application is in this debug mode is controlled by the following
    line in the root `index.php` file:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是否处于调试模式由根目录`index.php`文件中的以下行控制：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To see what is being logged, let''s whip up a quick little action method in
    our `SiteController` class to display the messages:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看被记录的内容，让我们在我们的`SiteController`类中快速创建一个动作方法来显示这些消息：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we are using Yii's `CVarDumper` helper class, which is an improved version
    of `var_dump` or `print_r`, due to its ability to properly handle recursive reference
    objects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Yii的`CVarDumper`辅助类，这是`var_dump`或`print_r`的改进版本，因为它能够正确处理递归引用对象。
- en: 'If we invoke this action by making the request `http://localhost/trackstar/site/showLog`,
    we see something similar to the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过发出请求`http://localhost/trackstar/site/showLog`来调用此动作，我们会看到类似以下截图的内容：
- en: '![Message logging](graphics/8727_12_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![消息记录](graphics/8727_12_01.jpg)'
- en: If we comment out our global application debug variable, defined in `index.php`,
    and refresh the page, we'll notice an empty array; that is, nothing was logged.
    This is because this system-level debugging information level logging is accomplished
    by calling `Yii::trace`, which only logs these messages if the application is
    in this special debug mode.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们注释掉在`index.php`中定义的全局应用程序调试变量，并刷新页面，我们会注意到一个空数组；也就是说，没有记录任何内容。这是因为这种系统级别的调试信息级别的日志记录是通过调用`Yii::trace`来实现的，只有在应用程序处于特殊的调试模式时才会记录这些消息。
- en: 'We can log messages in a Yii application using one of two static application
    methods:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种静态应用程序方法之一在Yii应用程序中记录消息：
- en: '`Yii::log($message, $level, $category);`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Yii::log($message, $level, $category);`'
- en: '`Yii::trace($message, $category);`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Yii::trace($message, $category);`'
- en: As mentioned, the main difference between these two methods is that `Yii::trace`
    logs the message only when the application is in debug mode.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，这两种方法之间的主要区别在于`Yii::trace`仅在应用程序处于调试模式时记录消息。
- en: Categories and levels
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类别和级别
- en: When logging a message using `Yii::log()`, we need to specify its category and
    level. **Category** is a string and is used to provide extra context to the message
    being logged. This string can be anything you like, but a convention that many
    use is a string in the format of `xxx.yyy.zzz`, which resembles the path alias.
    For example, if a message is logged in our application's `SiteController` class,
    we may choose to use the category `application.controllers.SiteController`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`Yii::log()`记录消息时，我们需要指定它的类别和级别。**类别**是一个字符串，用于为被记录的消息提供额外的上下文。这个字符串可以是任何你喜欢的，但许多人使用的约定是一个格式为`xxx.yyy.zzz`的字符串，类似于路径别名。例如，如果在我们的应用程序的`SiteController`类中记录了一条消息，我们可以选择使用类别`application.controllers.SiteController`。
- en: 'In addition to specifying the category, when using `Yii::log`, we can also
    specify a level for the message. The level can be thought of as the severity of
    the message. You can define your own levels, but typically they take on one of
    the following values:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指定类别，使用`Yii::log`时，我们还可以指定消息的级别。级别可以被认为是消息的严重程度。您可以定义自己的级别，但通常它们具有以下值之一：
- en: '**Trace**: This level is commonly used for tracing the execution flow of the
    application during development.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪**：这个级别通常用于跟踪应用程序在开发过程中的执行流程。'
- en: '**Info**: This is for logging general information. This is the default level
    if none is specified.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息**：这是用于记录一般信息。如果没有指定级别，则这是默认级别。'
- en: '**Profile**: This is to be used with the performance profile feature, which
    is described later in this chapter.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概要**：这是用于性能概要功能，稍后在本章中描述。'
- en: '**Warning**: This is for warning messages.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警告**：这是用于警告消息。'
- en: '**Error**: This is for fatal error messages.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**：这是用于致命错误消息。'
- en: Adding a login message log
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加登录消息日志
- en: As an example, let's add some logging to our user login method. We'll provide
    some basic debugging information at the beginning of the method to indicate that
    the method is being executed. We'll then log an informational message upon a successful
    login, as well as a warning message if the login fails. Alter our `SiteController::actionLogin()`
    method as the following highlighted code suggests (the entire method is present
    in the downloadable code or you can download the standalone method from [https://gist.github.com/3791860](https://gist.github.com/3791860)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们向我们的用户登录方法添加一些日志记录。我们将在方法开始时提供一些基本的调试信息，以指示方法正在执行。然后，我们将在成功登录时记录一条信息，以及在登录失败时记录一条警告信息。根据以下突出显示的代码修改我们的`SiteController::actionLogin()`方法（整个方法在可下载的代码中已经存在，或者您可以从[https://gist.github.com/3791860](https://gist.github.com/3791860)下载独立的方法）。
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we now successfully log in (or perform a failed attempt) and visit our page
    to view the logs, we don't see them (if you commented out the debug mode declaration,
    make sure you have put the application back in debug mode for this exercise).
    Again, the reason is that, by default, the logging implementation in Yii simply
    stores the messages in memory. They disappear when the request completes. This
    is not terribly useful. We need to route them to a more persistent storage area
    so we can view them outside of the request in which they are generated.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在成功登录（或进行了失败的尝试）并访问我们的页面查看日志，我们看不到它们（如果您注释掉了调试模式声明，请确保您已经将应用程序重新放回调试模式进行此练习）。同样，原因是，默认情况下，Yii中的日志实现只是将消息存储在内存中。它们在请求完成时消失。这并不是非常有用。我们需要将它们路由到一个更持久的存储区域，这样我们就可以在生成它们的请求之外查看它们。
- en: Message routing
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息路由
- en: As we mentioned earlier, by default, messages logged using `Yii::log` or `Yii::trace`
    are kept in memory. Typically, these messages are more useful if they are displayed
    in browser windows, saved to some persistent storage (such as in a file), in a
    database, or sent as an email. Yii's *message routing* allows for the log messages
    to be routed to different destinations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，默认情况下，使用`Yii::log`或`Yii::trace`记录的消息被保存在内存中。通常，如果这些消息在浏览器窗口中显示，保存到一些持久存储（如文件中），在数据库中，或作为电子邮件发送，它们会更有用。Yii的*消息路由*允许将日志消息路由到不同的目的地。
- en: In Yii, message routing is managed by a `CLogRouter` application component.
    It allows you to define a list of destinations to which the log messages should
    be routed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yii中，消息路由由`CLogRouter`应用组件管理。它允许您定义日志消息应路由到的目的地列表。
- en: In order to take advantage of this message routing, we need to configure the
    `CLogRouter` application component in our `protected/config/main.php` configuration
    file. We do this by setting its routes property with the desired log message destinations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这个消息路由，我们需要在`protected/config/main.php`配置文件中配置`CLogRouter`应用组件。我们通过设置它的routes属性与所需的日志消息目的地进行配置。
- en: 'If we open up the main configuration file, we see that some configuration has
    already been provided (again, courtesy of using the `yiic webapp` command to initially
    create our application). The following is already defined in our configuration:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开主配置文件，我们会看到一些配置已经提供（再次感谢使用`yiic webapp`命令最初创建我们的应用程序）。以下内容已在我们的配置中定义：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `log` application component is configured to use the framework class `CLogRouter`.
    Certainly, you could also create and use a custom child class of this if you have
    logging requirements not fully met by the base framework implementation; but in
    our case, this will work just fine.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`log`应用组件配置为使用框架类`CLogRouter`。当然，如果您有日志要求没有完全满足基础框架实现，您也可以创建和使用自定义子类；但在我们的情况下，这将工作得很好。'
- en: 'What follows the class definition in the previous configuration is the definition
    of the `routes` property. In this case, there is just one route specified. This
    one is using the Yii framework message routing class, `CFileLogRoute`. The `CFileLogRoute`
    message routing class uses the filesystem to save the messages. By default, messages
    are logged in a file under the application runtime directory, `/protected/runtime/application.log`.
    In fact, if you have been following along with us and have your own application,
    you can take a peek at this file and will see several messages that have been
    logged by the framework. The `levels` specification dictates that only messages
    whose log level is either `error` or `warning` will be routed to this file. The
    part of the configuration in the previous code that is commented out specifies
    another route, `CWebLogRoute`. If used, this will route the message to be displayed
    on the currently requested web page. The following is a list of message routes
    currently available in Version 1.1 of Yii:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前配置中类定义之后的是`routes`属性的定义。在这种情况下，只指定了一个路由。这个路由使用了Yii框架的消息路由类`CFileLogRoute`。`CFileLogRoute`消息路由类使用文件系统保存消息。默认情况下，消息被记录在应用运行时目录下的一个文件中，即`/protected/runtime/application.log`。实际上，如果您一直在跟着我们并且有自己的应用程序，您可以查看这个文件，会看到框架记录的几条消息。`levels`规定只有日志级别为`error`或`warning`的消息才会被路由到这个文件。在先前代码中被注释掉的部分指定了另一个路由`CWebLogRoute`。如果使用，这将把消息路由到当前请求的网页上。以下是Yii
    1.1版本当前可用的消息路由列表：
- en: '`CDbLogRoute`: Saves messages in a database table'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CDbLogRoute`：将消息保存在数据库表中'
- en: '`CEmailLogRoute`: Sends messages to specified e-mail addresses'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CEmailLogRoute`：将消息发送到指定的电子邮件地址'
- en: '`CFileLogRoute`: Saves messages in a file under the application''s `runtime`
    directory or any other directory of your choice'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CFileLogRoute`：将消息保存在应用程序的`runtime`目录下的文件中，或者您选择的任何其他目录中'
- en: '`CWebLogRoute`: Displays messages at the end of the current web page'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CWebLogRoute`：在当前网页末尾显示消息'
- en: '`CProfileLogRoute`: Displays profiling messages at the end of the current web
    page'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CProfileLogRoute`：在当前网页末尾显示分析消息'
- en: 'The logging that we added to our `SiteController::actionLogin()` method used
    `Yii::trace` for one message and then used `Yii::log` for two more. When using
    `Yii::trace` the log level is automatically set to `trace`. When using the `Yii::log`
    we specified an `info` log level if the login was successful, but a `warning`
    level if the login attempt failed. Let''s alter our log routing configuration
    to write the `trace` and `info` level messages to a new, separate file called
    `infoMessages.log` in the same directory as our `application.log` file. Also,
    let''s configure it to write the warning messages to the browser. To do that,
    we will make the following changes (highlighted) to the configuration:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`SiteController::actionLogin()`方法中添加的日志记录使用了`Yii::trace`来记录一条消息，然后使用`Yii::log`来记录另外两条消息。使用`Yii::trace`时，日志级别会自动设置为`trace`。当使用`Yii::log`时，如果登录成功，我们指定为`info`日志级别，但如果登录尝试失败，则为`warning`级别。让我们修改日志路由配置，将`trace`和`info`级别的消息写入到一个新的、单独的文件`infoMessages.log`中，该文件与我们的`application.log`文件在同一目录中。另外，让我们配置它将警告消息写入到浏览器。为此，我们将对配置进行以下更改（已突出显示）：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, after saving these changes, let''s try out the different scenarios. First,
    try a successful login. Doing so will write our two login messages out to our
    new `/protected/runtime/infoMessages.log` file, one for the trace and the other
    one logging the successful login. After successfully logging in, viewing that
    file reveals the following (the full listing was truncated to save a few trees):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在保存这些更改后，让我们尝试不同的场景。首先，尝试成功的登录。这样做将把我们的两条登录消息写入到我们的新的`/protected/runtime/infoMessages.log`文件中，一条是trace，另一条是记录成功登录。成功登录后，查看该文件会显示以下内容（完整列表被截断以节省一些树木）：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, there is a lot more in there than just our two messages! But
    our two did show up; they are in bold in the previous listing. Now that we are
    routing all trace messages to this new file, all framework trace messages are
    showing up here as well. This is actually very informative and really helps you
    get a picture of the lifecycle of a request as it makes its way through the framework.
    There is a lot going on under the covers. We would obviously turn off this verbose
    level of logging when moving this application to production. In non-debug mode,
    we would only see our single `info` level message. But this level of detail can
    be very informative when trying to track down bugs and just figuring out what
    the application is doing. It is very comforting to know it is here when/if ever
    needed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，其中有很多内容，不仅仅是我们的两条消息！但我们的两条确实显示出来了；它们在先前的列表中是加粗的。现在我们将所有的trace消息路由到这个新文件中，所有框架的trace消息也会显示在这里。这实际上非常有信息量，真的有助于您了解请求在框架中的生命周期。在幕后有很多事情发生。当将此应用程序移至生产环境时，我们显然会关闭这种冗长的日志记录。在非调试模式下，我们只会看到我们的单个`info`级别消息。但在追踪错误和弄清楚应用程序在做什么时，这种详细级别的信息非常有用。知道它在需要时/如果需要时存在是非常令人安心的。
- en: 'Now let''s try the failed login attempt scenario. If we now log back out and
    try our login again, but this time specify incorrect credentials to force a failed
    login, we see our **warning** level display along the bottom of the returned web
    page just as we configured it to do. The following screenshot shows this warning
    being displayed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试失败的登录尝试场景。如果我们现在注销并再次尝试登录，但这次指定不正确的凭据以强制登录失败，我们会看到我们的**警告**级别显示在返回的网页底部，就像我们配置的那样。以下屏幕截图显示了显示此警告：
- en: '![Message routing](graphics/8727_12_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![消息路由](graphics/8727_12_02.jpg)'
- en: When using the `CFileLogRouter` message router, the log files are stored under
    the `logPath` property and the filename is specified by the `logFile` method.
    Another great feature of this log router is automatic logfile rotation. If the
    size of the logfile is greater than the value set in the `maxFileSize` property
    (in kilobytes) a rotation is performed, which renames the current log file by
    suffixing the filename with `.1`. All existing logfiles are moved backwards one
    place, that is, `.2` to `.3`, `.1` to `.2`. The property `maxLogFiles` can be
    used to specify how many files are to be kept.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CFileLogRouter`消息路由器时，日志文件存储在`logPath`属性下，并且文件名由`logFile`方法指定。这个日志路由器的另一个很棒的功能是自动日志文件轮换。如果日志文件的大小大于`maxFileSize`属性中设置的值（以千字节为单位），则会执行轮换，将当前日志文件重命名为带有`.1`后缀的文件。所有现有的日志文件都向后移动一个位置，即`.2`到`.3`，`.1`到`.2`。属性`maxLogFiles`可用于指定要保留多少个文件。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you use `die;` or `exit;` in your application to terminate the execution,
    log messages may not be properly written to their intended destinations. If you
    need to explicitly terminate the execution of your Yii applications, use `Yii::app()->end().`
    This provides the application an opportunity to write out log messages successfully.
    Also, the `CLogger` component has an `$autoDump` property that, if set to `true`,
    will allow the writing of log messages to their destinations in real time (that
    is, as `->log()` is called). This should only be used for debugging purposes due
    to its potential performance impact, but can be a very valuable debugging option.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在应用程序中使用`die;`或`exit;`来终止执行，日志消息可能无法正确写入其预期的目的地。如果需要显式终止Yii应用程序的执行，请使用`Yii::app()->end()`。这提供了应用程序成功写出日志消息的机会。此外，`CLogger`组件具有一个`$autoDump`属性，如果设置为`true`，将允许实时将日志消息写入其目的地（即在调用`->log()`时）。由于潜在的性能影响，这应仅用于调试目的，但可以是一个非常有价值的调试选项。
- en: Handling errors
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: Properly handling the errors that invariably occur in software applications
    is of utmost importance. This, again, is a topic that arguably should have been
    covered prior to coding our application, rather than at this late stage. Luckily,
    though, since we have been leaning on tools within the Yii framework to autogenerate
    much of our core application skeleton, our application is already taking advantage
    of some of Yii's error handling features.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正确处理软件应用程序中不可避免发生的错误非常重要。这又是一个话题，可以说应该在编写应用程序之前就已经涵盖了，而不是在这个晚期阶段。幸运的是，由于我们一直在依赖Yii框架内的工具来自动生成我们的核心应用程序骨架，我们的应用程序已经在利用Yii的一些错误处理功能。
- en: Yii provides a complete error handling framework based on PHP 5 exceptions,
    a built-in mechanism for handling exceptional circumstances in the program through
    centralized points. When the main Yii application component is created to handle
    an incoming user request, it registers its `CApplication::handleError()` method
    to handle PHP warnings and notices, and it registers its `CApplication::handleException()`
    method to handle uncaught PHP exceptions. Consequently, if a PHP warning/notice
    or an uncaught exception occurs during the application execution, one of the error
    handlers will take over the control and start the necessary error handling procedure.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Yii提供了一个基于PHP 5异常的完整错误处理框架，这是通过集中的点处理程序中的异常情况的内置机制。当主Yii应用程序组件被创建来处理传入的用户请求时，它会注册其`CApplication::handleError()`方法来处理PHP警告和通知，并注册其`CApplication::handleException()`方法来处理未捕获的PHP异常。因此，如果在应用程序执行期间发生PHP警告/通知或未捕获的异常，其中一个错误处理程序将接管控制并启动必要的错误处理过程。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The registration of error handlers is done in the application's constructor
    by calling the PHP functions `set_exception_handler` and `set_error_handler`.
    If you prefer not to have Yii handle these types of errors and exceptions, you
    may override this default behavior by defining the global constants `YII_ENABLE_ERROR_HANDLER`
    and `YII_ENABLE_EXCEPTION_HANDLER` to be false in the main `index.php` entry script.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理程序的注册是在应用程序的构造函数中通过调用PHP函数`set_exception_handler`和`set_error_handler`来完成的。如果您不希望Yii处理这些类型的错误和异常，可以通过在主`index.php`入口脚本中将全局常量`YII_ENABLE_ERROR_HANDLER`和`YII_ENABLE_EXCEPTION_HANDLER`定义为false来覆盖此默认行为。
- en: By default, the application will use the framework class `CErrorHandler` as
    the application component tasked with handling PHP errors and uncaught exceptions.
    Part of the task of this built-in application component is displaying these errors
    using appropriate view files based on whether or not the application is running
    in *debug* mode or in *production* mode. This allows you to customize your error
    messages for these different environments. It makes sense to display much more
    verbose error information in a development environment to help troubleshoot problems.
    But allowing users of a production application to view this same information could
    compromise security. Also, if you have implemented your site in multiple languages,
    `CErrorHandler` also selects the preferred language for displaying the error.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，应用程序将使用框架类`CErrorHandler`作为负责处理PHP错误和未捕获异常的应用程序组件。这个内置应用程序组件的任务之一是使用适当的视图文件显示这些错误，这取决于应用程序是在*调试*模式还是*生产*模式下运行。这允许您为这些不同的环境自定义错误消息。在开发环境中显示更详细的错误信息以帮助解决问题是有意义的。但允许生产应用程序的用户查看相同的信息可能会影响安全性。此外，如果您在多种语言中实现了您的站点，`CErrorHandler`还会选择用于显示错误的首选语言。
- en: 'You raise exceptions in Yii in the same way you would normally raise a PHP
    exception. One uses the following general syntax to raise an exception when needed:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yii中，您引发异常的方式与通常引发PHP异常的方式相同。在需要时，可以使用以下一般语法引发异常：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The two exception classes Yii provides are:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Yii提供的两个异常类是：
- en: '`CException`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CException`'
- en: '`CHttpException`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CHttpException`'
- en: '`CException` is a generic exception class. `CHttpException` represents an HTTP
    error and also carries a `statusCode` property to represent the HTTP status code.
    Errors are displayed differently in the browser, depending on the exception class
    that is thrown.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`CException`是一个通用的异常类。`CHttpException`表示一个HTTP错误，并且还携带一个`statusCode`属性来表示HTTP状态码。在浏览器中，错误的显示方式取决于抛出的异常类。'
- en: Displaying errors
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示错误
- en: As was previously mentioned, when the `CErrorHandler` application component
    is handling an error, it makes a decision as to which view file to use when displaying
    the error. If the error is meant to be displayed to end users, as is the case
    when using `CHttpException`, the default behavior is to use a view named `errorXXX`,
    where `XXX` represents the HTTP status code (for example, 400, 404, or 500). If
    the error is an internal one and should only be displayed to developers, it will
    use a view named `Exception`. When the application is in debug mode, a complete
    call stack as well as the error line in the source file will be displayed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，当`CErrorHandler`应用组件处理错误时，它会决定在显示错误时使用哪个视图文件。如果错误是要显示给最终用户的，就像使用`CHttpException`时一样，其默认行为是使用一个名为`errorXXX`的视图，其中`XXX`代表HTTP状态码（例如，400、404或500）。如果错误是内部错误，只应显示给开发人员，它将使用一个名为`Exception`的视图。当应用程序处于调试模式时，将显示完整的调用堆栈以及源文件中的错误行。
- en: However, when the application is running in production mode, all errors will
    be displayed using the `errorXXX` view files. This is because the call stack of
    an error may contain sensitive information that should not be displayed to just
    any end user.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，当应用程序运行在生产模式下时，所有错误都将使用`errorXXX`视图文件显示。这是因为错误的调用堆栈可能包含不应该显示给任何最终用户的敏感信息。 '
- en: When the application is in production mode, developers should rely on the error
    logs to provide more information about an error. A message of level error will
    always be logged when an error occurs. If the error is caused by a PHP warning
    or notice, the message will be logged with the category `php`. If the error is
    caused by an uncaught `exception`, the category will be `exception.ExceptionClassName`,
    where the exception class name is one of, or a child class of, either `CHttpException`
    or `CException`. One can thus take advantage of the logging features discussed
    in the previous section to monitor errors that occur within a production application.
    Of course, if fatal PHP errors occur you will still need to check your error log
    defined by your PHP configuration settings instead of Yii's error log.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序处于生产模式时，开发人员应依靠错误日志提供有关错误的更多信息。当发生错误时，错误级别的消息将始终被记录。如果错误是由PHP警告或通知引起的，消息将被记录为`php`类别。如果错误是由未捕获的`exception`引起的，类别将是`exception.ExceptionClassName`，其中异常类名是`CHttpException`或`CException`的一个或子类。因此，可以利用前一节讨论的日志记录功能来监视生产应用程序中发生的错误。当然，如果发生致命的PHP错误，您仍然需要检查由PHP配置设置定义的错误日志，而不是Yii的错误日志。
- en: 'By default, `CErrorHandler` searches for the location of the corresponding
    view file in the following order:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`CErrorHandler`按以下顺序搜索相应视图文件的位置：
- en: '`WebRoot/themes/ThemeName/views/system`: The system view directory under the
    currently active theme'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebRoot/themes/ThemeName/views/system`：当前活动主题下的系统视图目录'
- en: '`WebRoot/protected/views/system`: The default system view directory for an
    application'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebRoot/protected/views/system`：应用程序的默认系统视图目录'
- en: '`YiiRoot/framework/views`: The standard system view directory provided by the
    Yii framework'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YiiRoot/framework/views`：Yii框架提供的标准系统视图目录'
- en: You can customize the error display by creating custom error view files under
    the system view directory of the application or theme.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在应用程序或主题的系统视图目录下创建自定义错误视图文件来自定义错误显示。
- en: Yii also allows you to define a specific controller action method to handle
    the display of the error. This is actually how our application is configured.
    We'll see this as we go through a couple of examples.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Yii还允许您定义一个特定的控制器动作方法来处理错误的显示。这实际上是我们的应用程序配置的方式。当我们通过一些示例时，我们会看到这一点。
- en: 'Some of the code that was generated for us as a by-product of using the Gii
    Crud Generator tool to create our CRUD scaffolding is already taking advantage
    of Yii''s error handling. One such example is the `ProjectController::loadModel()`
    method. That method is defined as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Gii Crud Generator工具创建CRUD脚手架时为我们生成的一些代码已经利用了Yii的错误处理。其中一个例子是`ProjectController::loadModel()`方法。该方法定义如下：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We see that it is attempting to load the appropriate project model AR instance
    based on the input `id` querystring parameter. If it is unable to locate the requested
    project, it throws a `CHttpException` as a way to let the user know that the page
    they are requesting, in this case the project details page, does not exist. We
    can test this in our browser by explicitly requesting a project that we know does
    not exist. Since we know our application does not have a project associated with
    an `id` of `99`, a request for `http://localhost/trackstar/project/view/id/99`
    will result in the following page being returned:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到它正在尝试基于输入的`id`查询字符串参数加载相应的项目模型AR实例。如果它无法定位请求的项目，它会抛出一个`CHttpException`，以通知用户他们请求的页面（在本例中是项目详细信息页面）不存在。我们可以通过明确请求我们知道不存在的项目来在浏览器中测试这一点。由于我们知道我们的应用程序没有与`id`为`99`相关联的项目，因此请求`http://localhost/trackstar/project/view/id/99`将导致返回以下页面：
- en: '![Displaying errors](graphics/8727_12_03.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![显示错误](graphics/8727_12_03.jpg)'
- en: This is nice, because the page looks like any other page in our application,
    with the same theme, header, footer, and so on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，因为页面看起来像我们应用程序中的任何其他页面，具有相同的主题、页眉、页脚等。
- en: 'This is actually not the default behavior for rendering this type of error
    page. Our initial application was configured to use a specific controller action
    for the handling of such errors. We mentioned this was another option as to how
    to handle errors in an application. If we take a peek into our main configuration
    file, `/protected/config/main.php`, we see the following application component
    declaration:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这不是呈现此类型错误页面的默认行为。 我们的初始应用程序配置为使用特定的控制器操作来处理此类错误。 我们提到这是处理应用程序中错误的另一种选项。
    如果我们查看主配置文件`/protected/config/main.php`，我们会看到以下应用程序组件声明：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This configures our error handler application component to use the `SiteController::actionError()`
    method to handle all of the exceptions intended to be displayed to users. If we
    take a look at that action method, we notice that it is rendering the `protected/views/site/error.php`
    view file. This is just a normal controller view file, so it will also render
    any relevant application layout files and will apply the appropriate theme. This
    way, we are able to provide the user with a very friendly experience when certain
    errors happen.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这配置了我们的错误处理程序应用组件使用`SiteController::actionError()`方法来处理所有打算显示给用户的异常。 如果我们查看该操作方法，我们会注意到它正在呈现`protected/views/site/error.php`视图文件。
    这只是一个普通的控制器视图文件，因此它还将呈现任何相关的应用程序布局文件，并将应用适当的主题。 通过这种方式，我们能够在发生某些错误时为用户提供非常友好的体验。
- en: 'To see what the default behavior is, without this added configuration, let''s
    temporarily comment out the previous lines of configuration code (in `protected/config/main.php`)
    and request the nonexistent project again. Now we see the following page:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看默认行为是什么，而不添加此配置，请暂时注释掉先前的配置代码行（在`protected/config/main.php`中），然后再次请求不存在的项目。
    现在我们看到以下页面：
- en: '![Displaying errors](graphics/8727_12_04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![显示错误](graphics/8727_12_04.jpg)'
- en: Since we have not explicitly defined any custom error pages following the convention
    outlined earlier, this is the `framework/views/error404.php` file in the Yii framework
    itself.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有明确定义任何遵循先前概述的自定义错误页面，这是Yii框架本身的`framework/views/error404.php`文件。
- en: Go ahead and revert these changes to the configuration file to have the error
    handling use the `SiteController::actionError()` method once again.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 继续并恢复对配置文件的更改，以再次使用`SiteController::actionError()`方法进行错误处理。
- en: 'Now let''s see how this compares to throwing a `CException` class, rather than
    the HTTP exception class. Let''s comment out the current line of code throwing
    the HTTP exception and add a new line to throw this other exception class. Make
    the highlighted changes to the `protected/controllers/ProjectController.php` file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这与抛出`CException`类相比如何。 让我们注释掉当前抛出HTTP异常的代码行，并添加一个新行来抛出这个其他异常类。 对`protected/controllers/ProjectController.php`文件进行突出显示的更改：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now if we make our request for a nonexistent project, we see a very different
    result. This time we see a system generated error page with a full stack trace
    error info dump along with the specific source file where the error occurred:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们请求一个不存在的项目，我们会看到一个非常不同的结果。 这次我们看到一个由系统生成的错误页面，其中包含完整的堆栈跟踪错误信息转储，以及发生错误的特定源文件：
- en: '![Displaying errors](graphics/8727_12_05.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![显示错误](graphics/8727_12_05.jpg)'
- en: It displays the fact that a `CException` class was thrown along with the description
    **This is an example of throwing a CException**, the source file, specific line
    in the file where the error occurred, and then the full stack trace.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了抛出`CException`类的事实，以及描述**这是抛出CException的示例**，源文件，发生错误的文件中的特定行，然后是完整的堆栈跟踪。
- en: 'So, throwing this different exception class, along with the fact the application
    is in debug mode, has a different result. This is the type of information we would
    like to display to help troubleshoot the problem, but only as long as our application
    is running in a private development environment. Let''s temporarily comment out
    the debug setting in the root `index.php` file in order to see how this would
    display when in "production" mode:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，抛出这个不同的异常类，以及应用程序处于调试模式的事实，会产生不同的结果。 这是我们希望显示以帮助排除问题的信息类型，但前提是我们的应用程序在私人开发环境中运行。
    让我们暂时注释掉根`index.php`文件中的调试设置，以查看在“生产”模式下如何显示：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With this commented out, if we refresh our request for our nonexistent project,
    we see that the exception is displayed as an end user friendly HTTP 500 error,
    as depicted in the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们刷新对不存在的项目的请求，我们会看到异常显示为面向最终用户友好的HTTP 500错误，如下截图所示：
- en: '![Displaying errors](graphics/8727_12_06.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![显示错误](graphics/8727_12_06.jpg)'
- en: So we see that none of our sensitive code or stack trace information is displayed
    when in the "production" mode.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们看到在“生产”模式下不会显示任何敏感代码或堆栈跟踪信息。
- en: Caching
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: '**Caching** data is a great method for helping to improve the performance of
    a production web application. If there is specific content that is not expected
    to change upon every request, using a cache to store and serve this content can
    decrease the time it takes to retrieve and process that data.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存**数据是帮助提高生产Web应用程序性能的一种很好的方法。 如果有特定内容不希望在每个请求时都更改，那么使用缓存来存储和提供此内容可以减少检索和处理数据所需的时间。'
- en: Yii provides some nice features when it comes to caching. To take advantage
    of Yii's caching features, you begin with configuring a cache application component.
    Such a component is one of several child classes extending `CCache`, the base
    class for cache classes with different cache storage implementations.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Yii在缓存方面提供了一些不错的功能。 要利用Yii的缓存功能，您首先需要配置一个缓存应用程序组件。 这样的组件是几个子类之一，它们扩展了`CCache`，这是具有不同缓存存储实现的缓存类的基类。
- en: 'Yii provides many specific cache component class implementations that store
    the data utilizing different approaches. The following is a list of the current
    cache implementations that Yii provides as of Version 1.1.12:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Yii提供了许多特定的缓存组件类实现，利用不同的方法存储数据。以下是Yii在版本1.1.12中提供的当前缓存实现的列表：
- en: '`CMemCache`: Uses the PHP memcache extension.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMemCache`：使用PHP memcache扩展。'
- en: '`CApcCache`: Uses the PHP APC extension.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CApcCache`：使用PHP APC扩展。'
- en: '`CXCache`: Uses PHP XCache extension.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CXCache`：使用PHP XCache扩展。'
- en: '`CEAcceleratorCache`: Uses the PHP EAccelerator extension.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CEAcceleratorCache`：使用PHP EAccelerator扩展。'
- en: '`CDbCache`: Uses a database table to store cached data. By default, it will
    create and use a SQLite3 database under the runtime directory. You can explicitly
    specify a database for it to use by setting its `connectionID` property.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CDbCache`：使用数据库表存储缓存数据。默认情况下，它将在运行时目录下创建并使用SQLite3数据库。您可以通过设置其`connectionID`属性来显式指定要使用的数据库。'
- en: '`CZendDataCache`: Uses Zend Data Cache as the underlying caching medium.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CZendDataCache`：使用Zend Data Cache作为底层缓存介质。'
- en: '`CFileCache`: Uses files to store cached data. This is particularly suitable
    to cache a large chunk of data (such as pages).'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CFileCache`：使用文件存储缓存数据。这对于缓存大量数据（如页面）特别合适。'
- en: '`CDummyCache`: Presents the consistent cache interface, but does not actually
    perform any caching. The reason for this implementation is that if you are faced
    with a situation where your development environment does not have cache support,
    you can still execute and test your code that will need to use cache once available.
    This allows you to continue to code to a consistent interface, and when the time
    comes to actually implement a real caching component you will not need to change
    the code written to write or retrieve data from cache.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CDummyCache`：提供一致的缓存接口，但实际上不执行任何缓存。这种实现的原因是，如果您面临开发环境不支持缓存的情况，您仍然可以执行和测试需要在可用时使用缓存的代码。这使您可以继续编写一致的接口代码，并且当实际实现真正的缓存组件时，您将不需要更改编写用于写入或检索缓存中的数据的代码。'
- en: '`CWinCache`: `CWinCache` implements a cache application component based on
    WinCache. For more information visit [http://www.iis.net/expand/wincacheforphp](http://www.iis.net/expand/wincacheforphp).'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CWinCache`：`CWinCache`基于WinCache实现了一个缓存应用程序组件。有关更多信息，请访问[http://www.iis.net/expand/wincacheforphp](http://www.iis.net/expand/wincacheforphp)。'
- en: All of these components extend from the same base class, `CCache`, and expose
    a consistent API. This means that you can change the implementation of the application
    component in order to use a different caching strategy without having to change
    any of the code that is using the cache.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些组件都是从同一个基类`CCache`继承，并公开一致的API。这意味着您可以更改应用程序组件的实现，以使用不同的缓存策略，而无需更改任何使用缓存的代码。
- en: Cache configuration
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存配置
- en: 'As was mentioned, using cache in Yii typically involves choosing one of these
    implementations and then configuring the application component for use in the
    `/protected/config/main.php` file. The specifics of the configuration will, of
    course, depend on the specific cache implementation. For example, if one were
    to use the memcached implementation, that is `CMemCache`, which is a distributed
    memory object caching system that allows you to specify multiple host servers
    as your cache servers, configuring it to use two servers might look something
    like the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，Yii中使用缓存通常涉及选择其中一种实现，然后在`/protected/config/main.php`文件中配置应用程序组件以供使用。配置的具体内容当然取决于具体的缓存实现。例如，如果要使用memcached实现，即`CMemCache`，这是一个分布式内存对象缓存系统，允许您指定多个主机服务器作为缓存服务器，配置它使用两个服务器可能如下所示：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To keep things relatively simple for the reader following along with the TrackStar
    development, we'll use the filesystem implementation `CFileCache` as we go through
    some examples. This should be readily available on any development environment
    that allows read and write access to files from the filesystem.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让读者在跟踪Star开发过程中保持相对简单，我们将在一些示例中使用文件系统实现`CFileCache`。这应该在任何允许从文件系统读取和写入文件的开发环境中都是readily
    available。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If for some reason this is not an option for you but you still want to follow
    along with the code examples, simply use the `CDummyCache` option. As mentioned,
    it won't actually store any data in the cache, but you can still write code against
    its API and change the implementation at a later time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因这对您来说不是一个选项，但您仍然想要跟随代码示例，只需使用`CDummyCache`选项。正如前面提到的，它实际上不会在缓存中存储任何数据，但您仍然可以根据其API编写代码，并在以后更改实现。
- en: '`CFileCache` provides a file-based caching mechanism. When using this implementation,
    each data value being cached is stored in a separate file. By default, these files
    are stored under the `protected/runtime/cache/` directory, but one can easily
    change this by setting the `cachePath` property when configuring the component.
    For our purposes this default is fine, so we simply need to add the following
    to the `components` array in our `/protected/config/main.php` configuration file,
    as such:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`CFileCache`提供了基于文件的缓存机制。使用这种实现时，每个被缓存的数据值都存储在一个单独的文件中。默认情况下，这些文件存储在`protected/runtime/cache/`目录下，但可以通过在配置组件时设置`cachePath`属性来轻松更改这一点。对于我们的目的，这个默认值是可以的，所以我们只需要在`/protected/config/main.php`配置文件的`components`数组中添加以下内容，如下所示：'
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this in place, we can access this new application component anywhere in
    our running application via `Yii::app()->cache`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，我们可以在运行的应用程序中的任何地方通过`Yii::app()->cache`访问这个新的应用程序组件。
- en: Using a file-based cache
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基于文件的缓存
- en: Let's try out this new component. Remember that system message we added as part
    of our administrative functionality in the previous chapter? Rather than retrieving
    it from the database upon every request, let's store the value initially returned
    from the database in our cache for a limited amount of time so that not every
    request has to retrieve the data from the database.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下这个新组件。还记得我们在上一章作为管理功能的一部分添加的系统消息吗？我们不必在每次请求时从数据库中检索它，而是将最初从数据库返回的值存储在我们的缓存中，以便有限的时间内不必从数据库中检索数据。
- en: Let's add a new public method to our `SysMessage` (`/protected/modules/admin/models/SysMessage.php`)
    AR model class to handle the retrieval of the latest system messages. Let's make
    this new method both `public` and `static` so that other parts of the application
    can easily use this method to access the latest system message without having
    to explicitly create an instance of `SysMessage`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的`SysMessage`（`/protected/modules/admin/models/SysMessage.php`）AR模型类添加一个新的公共方法来处理最新系统消息的检索。让我们将这个新方法同时设置为`public`和`static`，以便应用程序的其他部分可以轻松使用这个方法来访问最新的系统消息，而不必显式地创建`SysMessage`的实例。
- en: 'Add our method to the `SysMessage` class as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的方法添加到`SysMessage`类中，如下所示：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''ll cover the details in just a minute. First, let''s change our application
    to use this new method to verify whether caching is working. We still need to
    change the `ProjectController::actionIndex()` method to use this newly created
    method. This is easy. Just replace the code that was generating the system message
    from the database, with a call to this new method. That is, in `ProjectController::actionIndex()`,
    simply change the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的一分钟内详细介绍。首先，让我们更改我们的应用程序以使用这种新方法来验证缓存是否正常工作。我们仍然需要更改`ProjectController::actionIndex()`方法以使用这个新创建的方法。这很容易。只需用调用这个新方法替换从数据库生成系统消息的代码。也就是说，在`ProjectController::actionIndex()`中，只需更改以下代码：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到以下内容：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now the system message being displayed on the projects listing page should be
    taking advantage of the file cache. We can check the cache directory to verify.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在项目列表页面上显示的系统消息应该利用文件缓存。我们可以检查缓存目录以进行验证。
- en: If we do a directory listing for the default location being used for file caching,
    `protected/runtime/cache/`, we do indeed see that a couple of files were created.
    Both of them rather strangely named (yours may be slightly different) `18baacd814900e9b36b3b2e546513ce8.bin`
    and `2d0efd21cf59ad6eb310a0d70b25a854.bin`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对文件缓存的默认位置`protected/runtime/cache/`进行目录列表，我们确实会看到创建了一些文件。两个文件的名称都相当奇怪（您的可能略有不同）`18baacd814900e9b36b3b2e546513ce8.bin`和`2d0efd21cf59ad6eb310a0d70b25a854.bin`。
- en: One holds our system message data and the other is from our configuration of
    `CUrlManager` from previous chapters. By default, `CUrlManager` will use the cache
    component to cache the parsed URL rules. You can set the `cacheId` parameter of
    `CUrlManager` to `false` to disable caching for this component.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个保存我们的系统消息数据，另一个是我们在前几章中配置的`CUrlManager`的配置。默认情况下，`CUrlManager`将使用缓存组件来缓存解析的URL规则。您可以将`CUrlManager`的`cacheId`参数设置为`false`，以禁用此组件的缓存。
- en: 'If we open up the `18baacd814900e9b36b3b2e546513ce8.bin` file as text, we can
    see the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以文本形式打开`18baacd814900e9b36b3b2e546513ce8.bin`文件，我们可以看到以下内容：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is the serialized cached value of our most recently updated `SysMessage`
    AR class instance, which is exactly what we would expect to be there. So, we see
    that the caching is actually working.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们最近更新的`SysMessage` AR类实例的序列化缓存值，这正是我们希望看到的。因此，我们看到缓存实际上是在工作的。
- en: 'Now let''s revisit the code for our new `SysMessage::getLatest()` method in
    a bit more detail. The first thing the code is doing is checking to see if the
    requested data is already in the cache, and if so returning that value:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更详细地重新审视一下我们的新`SysMessage::getLatest()`方法的代码。代码的第一件事是检查所请求的数据是否已经在缓存中，如果是，则返回该值：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we mentioned, we configured the cache application component to be available
    anywhere in the application via `Yii::app()->cache`. So, it first checks to see
    if there even is such a component defined. If so, it attempts to look up the data
    in the cache via the `$cache->get($key)` method. This does more or less what you
    would expect. It attempts to retrieve a value from the cache based on the specified
    key. The key is a unique string identifier that is used to map to each piece of
    data stored in the cache. In our system message example, we only need to display
    one message at a time and therefore can have a fairly simple key identify the
    single system message to display. The key can be any string value as long as it
    remains unique for each piece of data we want to cache. In this case we have chosen
    the descriptive string `TrackStar.ProjectListing.SystemMessage` as the key used
    when storing and retrieving our cached system message.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所提到的，我们配置了缓存应用组件，可以通过`Yii::app()->cache`在应用程序的任何地方使用。因此，它首先检查是否已定义这样的组件。如果是，它尝试通过`$cache->get($key)`方法在缓存中查找数据。这做的更多或更少是您所期望的。它尝试根据指定的键从缓存中检索值。键是用于映射到缓存中存储的每个数据片段的唯一字符串标识符。在我们的系统消息示例中，我们只需要一次显示一条消息，因此可以使用一个相当简单的键来标识要显示的单个系统消息。只要对于我们想要缓存的每个数据片段保持唯一，键可以是任何字符串值。在这种情况下，我们选择了描述性字符串`TrackStar.ProjectListing.SystemMessage`作为存储和检索缓存系统消息时使用的键。
- en: 'When this code is executed for the very first time, there will not yet be any
    data associated with this key value in the cache. Therefore, a call to `$cache->get()`
    for this key will return `false`. So, our method will continue to the next bit
    of code, which simply attempts to retrieve the appropriate system message from
    the database, using the AR class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当此代码首次执行时，缓存中尚没有与此键值关联的任何数据。因此，对于此键的`$cache->get()`调用将返回`false`。因此，我们的方法将继续执行下一部分代码，简单地尝试从数据库中检索适当的系统消息，使用AR类：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then proceed with the following code that first checks if we did get anything
    back from the database. If we did, it stores it in the cache before returning
    the value; otherwise, `null` is returned:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们继续以下代码，首先检查我们是否从数据库中得到了任何返回。如果是，它会在返回值之前将其存储在缓存中；否则，将返回`null`：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If a valid system message was returned, we use the `$cache->set()` method to
    store the data into the cache. This method has the following general form:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回了有效的系统消息，我们使用`$cache->set()`方法将数据存储到缓存中。这个方法的一般形式如下：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When placing a piece of data into the cache, one must specify a unique key as
    well as the data to be stored. The key is a unique string value, as discussed
    previously, and the value is whatever data is desired to be cached. This can be
    in any format as long as it can be serialized. The duration parameter specifies
    an optional **time-to-live** (**TTL**) requirement. This can be used to ensure
    that the cached value is refreshed after some period of time. The default is `0`,
    which means it will never expire. (Actually, internally, Yii translates a value
    of `<=0` for the duration to expire in one year. So, not exactly *never*, but
    definitely a long time.)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据放入缓存时，必须指定一个唯一的键以及要存储的数据。键是一个唯一的字符串值，如前所述，值是希望缓存的任何数据。只要可以序列化，它可以是任何格式。持续时间参数指定了一个可选的**存活时间**（**TTL**）要求。这可以用来确保缓存的值在一段时间后被刷新。默认值为`0`，这意味着它永远不会过期。（实际上，Yii在内部将持续时间的值`<=0`翻译为一年后过期。所以，不完全是*永远*，但肯定是很长时间。）
- en: 'We call the `set()` method in the following manner:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以以下方式调用`set()`方法：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We set the key to be what we had defined it before, `TrackStar.ProjectListing.SystemMessage`;
    the data being stored is the message attribute of our returned `SystemMessage`
    AR class, that is the message column of our `tbl_sys_message` table; and then
    we set the duration to be `300` seconds. This way, the data in the cache will
    expire every 5 minutes, at which time the database is queried again for the most
    recent system message. We did not specify a dependency when we set the data. We'll
    discuss this optional parameter next.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将键设置为之前定义的`TrackStar.ProjectListing.SystemMessage`；要存储的数据是我们返回的`SystemMessage`
    AR类的消息属性，即我们的`tbl_sys_message`表的消息列；然后我们将持续时间设置为`300`秒。这样，缓存中的数据将在每5分钟后过期，届时将再次查询数据库以获取最新的系统消息。当我们设置数据时，我们没有指定依赖项。我们将在下面讨论这个可选参数。
- en: Cache dependencies
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存依赖项
- en: The dependency parameter allows for an alternative and much more sophisticated
    approach to deciding whether or not the stored data in the cache should be refreshed.
    Rather than declaring a simple time period for the expiration of cached data,
    your caching strategy may require that the data become invalid based on things
    such as the specific user making the request, the general mode, state of the application,
    or whether a file on the file system has been recently updated. This parameter
    allows you to specify such cache validation rules.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖参数允许采用一种替代和更复杂的方法来决定缓存中存储的数据是否应该刷新。您的缓存策略可能要求根据特定用户发出请求、应用程序的一般模式、状态或文件系统上的文件是否最近已更新等因素使数据无效，而不是声明缓存数据的过期时间。此参数允许您指定此类缓存验证规则。
- en: 'The dependency is an instance of `CCacheDependency` or its child class. Yii
    makes available the following specific cache dependencies:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项是`CCacheDependency`或其子类的实例。Yii提供了以下特定的缓存依赖项：
- en: '`CFileCacheDependency`: The data in the cache will be invalid if the specified
    file''s last modification time has changed since the previous cache lookup.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CFileCacheDependency`：如果指定文件的最后修改时间自上次缓存查找以来发生了变化，则缓存中的数据将无效。'
- en: '`CDirectoryCacheDependency`: Similar to the previous one for the file cache
    dependency, but this checks all the files and subdirectories within a given specified
    directory.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CDirectoryCacheDependency`：与文件缓存依赖项类似，但是它检查给定指定目录中的所有文件和子目录。'
- en: '`CDbCacheDependency`: The data in the cache will be invalid if the query result
    of a specified SQL statement is changed since the previous cache lookup.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CDbCacheDependency`：如果指定SQL语句的查询结果自上次缓存查找以来发生了变化，则缓存中的数据将无效。'
- en: '`CGlobalStateCacheDependency`: The data in the cache will be invalid if the
    value of the specified global state is changed. A global state is a variable that
    is persistent across multiple requests and multiple sessions in an application.
    It is defined via `CApplication::setGlobalState()`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CGlobalStateCacheDependency`：如果指定的全局状态的值发生了变化，则缓存中的数据将无效。全局状态是一个跨多个请求和多个会话持久存在的变量。它通过`CApplication::setGlobalState()`来定义。'
- en: '`CChainedCacheDependency`: This allows you to chain together multiple dependencies.
    The data in the cache will become invalid if any of the dependencies on the chain
    are changed.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CChainedCacheDependency`：这允许您将多个依赖项链接在一起。如果链中的任何依赖项发生变化，缓存中的数据将变得无效。'
- en: '`CExpressionDependency`: The data in the cache will be invalid if the result
    of the specified PHP expression is changed.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CExpressionDependency`：如果指定的PHP表达式的结果发生了变化，则缓存中的数据将无效。'
- en: To provide a concrete example, let's use a dependency to expire the data in
    the cache whenever a change to the `tbl_sys_message` database table is made. Rather
    than arbitrarily expiring our cached system message after five minutes, we'll
    expire it exactly when we need to, that is, when there has been a change to the
    `update_time` column for one of the system messages in the table. We'll use the
    `CDbCacheDependency` implementation to achieve this, since it is designed to invalidate
    cached data based on a change in the results of a SQL query.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个具体的例子，让我们使用一个依赖项，以便在`tbl_sys_message`数据库表发生更改时使缓存中的数据过期。我们将不再任意地在五分钟后使我们的缓存系统消息过期，而是在需要时精确地使其过期，也就是说，当表中的系统消息的`update_time`列发生更改时。我们将使用`CDbCacheDependency`实现这一点，因为它旨在根据SQL查询结果的更改来使缓存数据无效。
- en: 'We alter our call to the `set()` method to set the duration time to `0` so
    that it won''t expire based on time but pass in a new dependency instance with
    our specified SQL statement, as such:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改变了对`set()`方法的调用，将持续时间设置为`0`，这样它就不会根据时间过期，而是传入一个新的依赖实例和我们指定的SQL语句，如下所示：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Changing the duration TTL time to `0` is not at all a prerequisite of using
    a dependency. We could have just as easily left the duration in as `300` seconds.
    This would just stipulate another rule to render the data in the cache invalid.
    The data would only be valid in the cache for a maximum of 5 minutes, but would
    also be regenerated prior to this time limit if there is a newer message, that
    is, a later `update_time` value in the table.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将TTL时间更改为`0`并不是使用依赖的先决条件。我们可以将持续时间留在`300`秒。这只是规定了另一个规则，使缓存中的数据无效。数据在缓存中只有效5分钟，但如果表中有更新时间更晚的消息，也就是更新时间，数据也会在此时间限制之前重新生成。
- en: With this in place, the cache will only expire when the results of the query
    statement are changed. This example is a little contrived, since we were originally
    caching the data to avoid a database call altogether. Now we have configured it
    to execute a database query every time we attempt to retrieve data from the cache.
    However, if the cached data was a much more complex data set that involved much
    more overhead to retrieve and process, a simple SQL statement for cache validity
    could make a lot of sense. The specific caching implementation, the data stored,
    the expiration time, as well as any other data validation in the form of these
    dependencies, will all depend on the specific requirements of the application
    being built. It is good to know that Yii has many options available to help meet
    our varied requirements.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，缓存只有在查询语句的结果发生变化时才会过期。这个例子有点牵强，因为最初我们是为了避免完全调用数据库而缓存数据。现在我们已经配置它，每次尝试从缓存中检索数据时都会执行数据库查询。然而，如果缓存的数据集更复杂，涉及更多的开销来检索和处理，一个简单的SQL语句来验证缓存的有效性可能是有意义的。具体的缓存实现、存储的数据、过期时间，以及这些依赖形式的任何其他数据验证，都将取决于正在构建的应用程序的具体要求。知道Yii有许多选项可用于满足我们多样化的需求是很好的。
- en: Query caching
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询缓存
- en: The query caching approach of caching a database result is so often needed in
    database driven applications that Yii provides an even easier implementation for
    this, called **query caching**. As its name implies, query caching stores the
    results of a database query in cache and saves the query execution time on subsequent
    requests as these are served directly from cache. In order to enable a query,
    you need to ensure the `queryCacheID` property of the `CDbConnection` property
    refers to the `ID` attribute of a valid cache component. It refers to `'cache'`
    by default, which is what we already have configured from the preceding cache
    example.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 查询缓存的方法在数据库驱动应用程序中经常需要，Yii提供了更简单的实现，称为**查询缓存**。顾名思义，查询缓存将数据库查询的结果存储在缓存中，并在后续请求中节省查询执行时间，因为这些请求直接从缓存中提供。为了启用查询，您需要确保`CDbConnection`属性的`queryCacheID`属性引用有效缓存组件的`ID`属性。它默认引用`'cache'`，这就是我们从前面的缓存示例中已经配置的。
- en: To use query caching, we simply call the `cache()` method of `CDbConnection`.
    This method takes in a duration, to specify the number of seconds the query is
    to remain in cache. If the duration is set to `0`, caching is disabled. You can
    also specify a `CCacheDependency` instance as a second argument, and specify how
    many subsequent queries should be cached as a third argument. This third argument
    defaults to `1`, which means that only the next SQL query will be cached.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用查询缓存，我们只需调用`CDbConnection`的`cache()`方法。这个方法接受一个持续时间，用来指定查询在缓存中保留的秒数。如果持续时间设置为`0`，缓存就被禁用了。您还可以将`CCacheDependency`实例作为第二个参数传入，并指定多少个后续查询应该被缓存为第三个参数。这第三个参数默认为`1`，这意味着只有下一个SQL查询会被缓存。
- en: 'So, let''s change our previous cache implementation to use this cool query
    caching feature. Using the query caching, our implementation of the `SysMessage::getLatest()`
    method is greatly simplified. All we need to do is the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将以前的缓存实现更改为使用这个很酷的查询缓存功能。使用查询缓存，我们的`SysMessage::getLatest()`方法的实现大大简化了。我们只需要做以下操作：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here we have the same basic approach as before, but we don't have to deal with
    the explicit checking and setting of the cached values. We called the `cache()`
    method to indicate we want to cache the result for 30 minutes or, by specifying
    the dependency, refresh the value before that time if a more recent message becomes
    available.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们与以前的基本方法相同，但我们不必处理缓存值的显式检查和设置。我们调用`cache()`方法来指示我们要将结果缓存30分钟，或者通过指定依赖项，在此时间之前刷新值，如果有更近期的消息可用。
- en: Fragment caching
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 片段缓存
- en: The previous examples demonstrate the use of data caching. This is where we
    take a single piece of data and store it in the cache. There are other approaches
    available in Yii to store fragments of pages generated by a portion of a view
    script or even the entire page itself.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子演示了数据缓存的使用。这是我们将单个数据存储在缓存中。Yii还提供了其他方法来存储视图脚本的一部分生成的页面片段，甚至整个页面本身。
- en: 'Fragment caching refers to caching a fragment of a page. We can take advantage
    of fragment caching inside view scripts. To do so, we use the `CController::beginCache()`
    and `CController::endCache()` methods. These two methods are used to mark the
    beginning and the end of the rendered page content that should be stored in cache.
    Just as is the case when using a data caching approach, we need a unique key to
    identify the content being cached. In general, the syntax for using fragment caching
    inside a view script is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 片段缓存是指缓存页面的一部分。我们可以在视图脚本中利用片段缓存。为此，我们使用`CController::beginCache()`和`CController::endCache()`方法。这两种方法用于标记应该存储在缓存中的渲染页面内容的开始和结束。就像使用数据缓存方法时一样，我们需要一个唯一的键来标识被缓存的内容。一般来说，在视图脚本中使用片段缓存的语法如下：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The method `beginCache()` returns `false` when there is a cached version available,
    and the cached content will be automatically inserted at that place; otherwise,
    the content inside the if-statement will be executed and will be cached when `endCache()`
    is invoked.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当有缓存版本可用时，`beginCache()`方法返回`false`，并且缓存的内容将自动插入到该位置；否则，if语句内的内容将被执行，并且在调用`endCache()`时将被缓存。
- en: Declaring fragment caching options
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明片段缓存选项
- en: When calling `beginCache()`, we can supply an array as the second parameter
    consisting of caching options to customize the fragment caching. As a matter of
    fact, the `beginCache()` and `endCache()` methods are a convenient wrapper of
    the `COutputCache` filter/widget. Therefore, the caching options can be initial
    values for any properties of the `COutputCache` class.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`beginCache()`时，我们可以提供一个数组作为第二个参数，其中包含定制片段缓存的缓存选项。事实上，`beginCache()`和`endCache()`方法是`COutputCache`过滤器/小部件的便捷包装。因此，缓存选项可以是`COutputCache`类的任何属性的初始值。
- en: 'Arguably one of the most common options specified when caching data is the
    duration, which specifies how long the content can remain valid in the cache.
    It is similar to the `duration` parameter we used when caching our system messages.
    You can specify the `duration` parameter when calling `beginCache()` as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓存数据时，指定的最常见选项之一是持续时间，它指定内容在缓存中可以保持有效的时间。这类似于我们在缓存系统消息时使用的“持续时间”参数。在调用`beginCache()`时，可以指定`duration`参数如下：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The default setting for this fragment caching approach is different than that
    for the data caching. If we do not set the duration it defaults to 60 seconds,
    meaning the cached content will be invalidated after 60 seconds. There are many
    other options you can set when using fragment caching. For more information, refer
    to the API documentation for `COutputCache` as well as the fragment caching section
    of the Yii definitive guide, available on the Yii framework site: [http://www.yiiframework.com/doc/guide/1.1/en/caching.fragment](http://www.yiiframework.com/doc/guide/1.1/en/caching.fragment)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种片段缓存方法的默认设置与数据缓存的默认设置不同。如果我们不设置持续时间，它将默认为60秒，这意味着缓存的内容将在60秒后失效。在使用片段缓存时，您可以设置许多其他选项。有关更多信息，请参考`COutputCache`的API文档以及Yii权威指南的片段缓存部分，该指南可在Yii框架网站上找到：[http://www.yiiframework.com/doc/guide/1.1/en/caching.fragment](http://www.yiiframework.com/doc/guide/1.1/en/caching.fragment)
- en: Using fragment cache
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用片段缓存
- en: Let's implement this in our TrackStar application. We'll again focus on the
    project listings page. As you may recall, towards the bottom of the project listings
    page there is a list of the comments that users have left on the issues associated
    with each project. This list just indicates who left a comment on which issue.
    Rather than regenerating this list upon each request, let's use fragment caching
    to cache this list for, say, two minutes. The application can tolerate this data
    being slightly stale, and two minutes is really not that long to have to wait
    for an updated comment list.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在TrackStar应用程序中实现这一点。我们将再次专注于项目列表页面。您可能还记得，在项目列表页面的底部有一个列表，显示了用户在与每个项目相关的问题上留下的评论。这个列表只是指示谁在哪个问题上留下了评论。我们可以使用片段缓存来缓存这个列表，比如说两分钟。应用程序可以容忍这些数据略微过时，而两分钟对于等待更新的评论列表来说并不长。
- en: 'To do this, we make our changes to the listing view file, `protected/views/project/index.php`.
    We''ll wrap the call to our entire recent comments portlet inside this fragment
    caching approach, as such:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要对列表视图文件`protected/views/project/index.php`进行更改。我们将调用整个最近评论小部件的内容包裹在这个片段缓存方法中，如下所示：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With this in place, if we visit the project listings page for the first time,
    our comments list will be stored in the cache. If we then quickly (by quickly,
    we mean before two minutes have elapsed) add a new comment to one of the issues
    within a project, and then toggle back to the project listings page, we won't
    immediately see the newly added comment. But if we keep refreshing the page, once
    the content in the cache expires (a maximum of two minutes in this case), the
    data will be refreshed and our new comment will be displayed in the listing.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，如果我们第一次访问项目列表页面，我们的评论列表将被存储在缓存中。然后，如果我们在两分钟内快速（在两分钟之前）向项目中的问题之一添加新评论，然后切换回项目列表页面，我们不会立即看到新添加的评论。但是，如果我们不断刷新页面，一旦缓存中的内容过期（在这种情况下最多两分钟），数据将被刷新，我们的新评论将显示在列表中。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You could also simply add an `echo time();` PHP statement to the previously
    cached content to see if it is working as expected. If the content is properly
    caching, the time display will not update until the cache is refreshed. When using
    the file cache, remember to ensure that your `/protected/runtime/` directory is
    writable by the web server process, as this is where the cache content is stored
    by default.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以简单地在先前缓存的内容中添加`echo time();` PHP语句，以查看它是否按预期工作。如果内容正确缓存，时间显示将在缓存刷新之前不会更新。在使用文件缓存时，请记住确保您的`/protected/runtime/`目录对Web服务器进程是可写的，因为这是缓存内容默认存储的位置。
- en: 'We could avoid this situation by declaring a cache dependency, rather than
    a fixed duration. Fragment caching also supports cache dependencies. So, we could
    change the `beginCache()` method call, seen previously, to the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过声明缓存依赖项而不是固定持续时间来避免这种情况。片段缓存也支持缓存依赖项。因此，我们可以将之前看到的`beginCache()`方法调用更改为以下内容：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here we have used the `CDbCacheDependency` method to cache the content until
    an update is made to our comments table.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`CDbCacheDependency`方法来缓存内容，直到对我们的评论表进行更新。
- en: Page caching
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 页面缓存
- en: In addition to fragment caching, Yii offers options to cache the results of
    the entire page request. The page caching approach is similar to the fragment
    caching approach. However, because the content of an entire page is often generated
    by applying additional layouts to a view, we can't simply call `beginCache()`
    and `endCache()` in the layout file. The reason is that the layout is applied
    within the call to the `CController::render()` method after the content view is
    evaluated. So, we would always miss the opportunity to retrieve the content from
    the cache.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 除了片段缓存之外，Yii还提供了选项来缓存整个页面请求的结果。页面缓存方法类似于片段缓存方法。然而，由于整个页面的内容通常是通过将额外的布局应用于视图来生成的，我们不能简单地在布局文件中调用`beginCache()`和`endCache()`。原因是布局是在对`CController::render()`方法进行调用后应用的，内容视图被评估之后。因此，我们总是会错过从缓存中检索内容的机会。
- en: Therefore, to cache a whole page, we should entirely skip the execution of the
    action generating the page content. To accomplish this, we can use the `COutputCache`
    class as an action filter in our controller class.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要缓存整个页面，我们应该完全跳过生成页面内容的操作执行。为了实现这一点，我们可以在控制器类中使用`COutputCache`类作为操作过滤器。
- en: 'As an example, let''s use the page caching approach to cache the page results
    for every project detail page. The project detail pages in TrackStar are rendered
    by requesting URLs of the format `http://localhost/trackstar/project/view/id/[id]`,
    where `[id]` is the specific project ID we are requesting the details of. What
    we want to do is set up a page caching filter that will cache the entire contents
    of this page separately for every ID requested. We need to incorporate the project
    ID into the key value when we cache the content. That is, we don''t want to make
    a request for the details of project #1 and have the application return a cached
    result for project #2\. The `COutputCache` filter allows us to do just that.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们使用页面缓存方法来缓存每个项目详细页面的页面结果。TrackStar中的项目详细页面是通过请求格式为`http://localhost/trackstar/project/view/id/[id]`的URL来呈现的，其中`[id]`是我们请求详细信息的特定项目ID。我们要做的是设置一个页面缓存过滤器，将为每个请求的ID单独缓存此页面的整个内容。当我们缓存内容时，我们需要将项目ID合并到键值中。也就是说，我们不希望请求项目＃1的详细信息，然后应用程序返回项目＃2的缓存结果。`COutputCache`过滤器允许我们做到这一点。
- en: 'Open up `protected/controllers/ProjectController.php` and alter the existing
    `filters()` method as such:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`protected/controllers/ProjectController.php`并修改现有的`filters()`方法如下：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This filter configuration utilizes the `COutputCache` filter to cache the entire
    output generated by the application from a call to `ProjectController::actionView()`.
    The `+ view` parameter added just after the `COutputCache` declaration, as you
    may recall, is the standard way we include specific action methods to which a
    filter should apply. The duration parameter specifies a TTL of 120 seconds (two
    minutes), after which the page content will be regenerated.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此过滤器配置利用`COutputCache`过滤器来缓存应用程序从调用`ProjectController::actionView()`生成的整个输出。如您可能还记得的那样，在`COutputCache`声明之后添加的`+
    view`参数是我们包括特定操作方法的标准方式，以便过滤器应用。持续时间参数指定了120秒（两分钟）的TTL，之后页面内容将被重新生成。
- en: 'The `varyByParam` configuration is a really great option that we alluded to
    before. Rather than putting the responsibility on you, the developer, to come
    up with a unique key strategy for the content being cached, this feature allows
    the variation to be handled automatically. For example, in this case, by specifying
    a list of names that correspond to `GET` parameters in the input request. Since
    we are caching the page content of requests for projects by `project_id`, it makes
    perfect sense to use this ID as part of the unique key generation for caching
    the content. By specifying `''varyByParam''=>array(''id'')`, `COutputCache` does
    this for us based on the input querystring parameter `id`. There are more options
    available to achieve this type of autocontent variation strategy when using `COutputCache`
    to cache our data. As of Yii 1.1.12, the following variation features are available:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`varyByParam`配置是一个非常好的选项，我们之前提到过。这个功能允许自动处理变化，而不是将责任放在开发人员身上，为被缓存的内容想出一个独特的键策略。例如，在这种情况下，通过指定与输入请求中的`GET`参数对应的名称列表。由于我们正在缓存按`project_id`请求的项目的页面内容，因此使用此ID作为缓存内容的唯一键生成的一部分是非常合理的。通过指定`''varyByParam''=>array(''id'')`，`COutputCache`会根据输入查询字符串参数`id`为我们执行此操作。在使用`COutputCache`缓存数据时，还有更多可用的选项来实现这种自动内容变化策略。截至Yii
    1.1.12，以下变化功能可用：'
- en: '**varyByRoute**: By setting this option to `true`, the specific request route
    will be incorporated into the unique identifier for the cached data. Therefore,
    you can use the combination of the requested controller and action to distinguish
    cached content.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**varyByRoute**：通过将此选项设置为`true`，特定的请求路由将被合并到缓存数据的唯一标识符中。因此，您可以使用请求的控制器和操作的组合来区分缓存的内容。'
- en: '**varyBySession**: By setting this option to `true`, a unique session ID is
    used to distinguish the content in the cache. Each user session may see different
    content, but all of this content can still be served from the cache.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**varyBySession**：通过将此选项设置为`true`，将使用唯一的会话ID来区分缓存中的内容。每个用户会话可能会看到不同的内容，但所有这些内容仍然可以从缓存中提供。'
- en: '**varyByParam**: As discussed earlier, this uses the input `GET` querystring
    parameters to distinguish the content in the cache.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**varyByParam**：如前所述，这使用输入的`GET`查询字符串参数来区分缓存中的内容。'
- en: '**varyByExpression**: By setting this option to a PHP expression, we can use
    the result of this expression to distinguish the content in the cache.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**varyByExpression**：通过将此选项设置为PHP表达式，我们可以使用此表达式的结果来区分缓存中的内容。'
- en: So, with the above filter configured in our `ProjectController` class, each
    request for a specific project details page is stored in the cache for two minutes
    before being regenerated and again stored in the cache. You can test this out
    by first viewing a specific project, then updating that project in some way. Your
    updates will not be immediately displayed if done within the cache duration time
    of two minutes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的`ProjectController`类中配置了上述过滤器，对于特定项目详细信息页面的每个请求，在重新生成并再次存储在缓存之前，都会在缓存中存储两分钟。您可以通过首先查看特定项目，然后以某种方式更新该项目来测试这一点。如果在两分钟的缓存持续时间内进行更新，您的更新将不会立即显示。
- en: Caching entire page results is a great way to improve site performance, however
    it certainly does not make sense for every page in every application to be cached.
    Even in our example, caching the entire page for the project details page does
    not allow us to correctly use our pagination implementation for our issues listing.
    We used this as a quick example of how to implement page caching, but it is not
    always the right approach in every case. A combination of these three approaches,
    data, fragment, and page caching, allows you to adjust your caching strategy to
    meet your application requirements. We have really just scratched the surface
    of all caching options available within Yii. Hopefully this has whet your appetite
    to further investigate the full caching landscape available.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存整个页面结果是提高网站性能的好方法，但显然并不适用于每个应用程序中的每个页面。即使在我们的示例中，为项目详细信息页面缓存整个页面也不能正确使用分页实现我们的问题列表。我们使用这个作为一个快速示例来实现页面缓存，但并不总是适用于每种情况。数据、片段和页面缓存的结合允许您调整缓存策略以满足应用程序的要求。我们只是触及了Yii中所有可用缓存选项的表面。希望这激发了您进一步探索完整的缓存景观的兴趣。
- en: General performance tuning tips
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般性能调优提示
- en: As you are preparing your application for production, there are a few other
    things to take into consideration. The following sections briefly outline some
    other areas of consideration when working to tweak the performance of a Yii-based
    web application.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备应用程序投入生产时，还有一些其他事项需要考虑。以下部分简要概述了在调整基于Yii的Web应用程序性能时需要考虑的其他领域。
- en: Using APC
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用APC
- en: Enabling the PHP APC extension is perhaps the easiest way to improve the overall
    performance of an application. The extension caches and optimizes PHP intermediate
    code and avoids the time spent in parsing PHP scripts for every incoming request.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 启用PHP APC扩展可能是改善应用程序整体性能的最简单方法。该扩展缓存和优化PHP中间代码，并避免在每个传入请求中解析PHP脚本所花费的时间。
- en: It also provides a very fast storage mechanism for cached content. With APC
    enabled, you can use the `CApcCache` implementation for caching content, fragments,
    and pages.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 它还为缓存内容提供了一个非常快速的存储机制。启用APC后，可以使用`CApcCache`实现来缓存内容、片段和页面。
- en: Disabling the debug mode
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用调试模式
- en: We discussed the debug mode earlier in the chapter, but it won't hurt to hear
    it again. Disabling debug mode is another easy way to improve performance and
    security. A Yii application runs in debug mode if the constant `YII_DEBUG` is
    defined as `true` in the main `index.php` entry script. Many components, including
    those down in the framework itself, incur extra overhead when running in the debug
    mode.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的前面讨论了调试模式，但再次提及也无妨。禁用调试模式是另一种提高性能和安全性的简单方法。如果在主`index.php`入口脚本中定义常量`YII_DEBUG`为`true`，Yii应用程序将在调试模式下运行。许多组件，包括框架本身的组件，在调试模式下运行时会产生额外的开销。
- en: Also, as was mentioned way back in [Chapter 2](ch02.html "Chapter 2. Getting
    Started"), *Getting Started*, when we first created a Yii application, most of
    your Yii application files do not need to be, nor should they be, in the publically
    accessible web directory. A Yii application has just one entry script, which is
    often the only file that needs to be placed in the web directory. Other PHP scripts,
    including all of the Yii framework files, should be protected. This is why the
    default name of the primary application directory is called `protected/`. To avoid
    security issues, it is recommended to keep it from being publicly accessible.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，正如在[第2章](ch02.html "第2章.入门")中提到的，*入门*，当我们第一次创建Yii应用程序时，大多数Yii应用程序文件不需要，也不应该放在公共可访问的Web目录中。Yii应用程序只有一个入口脚本，通常是唯一需要放在Web目录中的文件。其他PHP脚本，包括所有Yii框架文件，都应该受到保护。这就是主应用程序目录的默认名称为`protected/`的原因。为了避免安全问题，建议不要公开访问它。
- en: Using yiilite.php
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用yiilite.php
- en: When the PHP APC extension is enabled, one can replace `yii.php` with a different
    Yii bootstrap file named `yiilite.php`. This can help to further boost the performance
    of a Yii-powered application. The file `yiilite.php` comes with every Yii release.
    It is the result of merging some commonly used Yii class files. Both comments
    and trace statements are stripped from the merged file. Therefore, using `yiilite.php`
    would reduce the number of files being included and avoid execution of trace statements.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用PHP APC扩展时，可以用名为`yiilite.php`的不同Yii引导文件替换`yii.php`。这有助于进一步提高Yii应用程序的性能。`yiilite.php`文件随每个Yii版本发布。它是合并了一些常用的Yii类文件的结果。合并文件中删除了注释和跟踪语句。因此，使用`yiilite.php`将减少被包含的文件数量，并避免执行跟踪语句。
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that using `yiilite.php` without APC may actually reduce performance. This
    is because `yiilite.php` contains some classes that are not necessarily used in
    every request and would take extra parsing time. It is also observed that using
    `yiilite.php` is slower with some server configurations; even when APC is turned
    on. The best way to judge whether to use `yiilite.php` or not is to run a benchmark
    using the "Hello World" demo that is included in the code bundle.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，没有APC的情况下使用`yiilite.php`可能会降低性能。这是因为`yiilite.php`包含一些不一定在每个请求中使用的类，并且会花费额外的解析时间。还观察到，在某些服务器配置下，即使启用了APC，使用`yiilite.php`也会更慢。判断是否使用`yiilite.php`的最佳方法是使用代码包中包含的“Hello
    World”演示运行基准测试。
- en: Using caching techniques
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用缓存技术
- en: As we described and demonstrated in this chapter, Yii provides many caching
    solutions that may improve the performance of a web application significantly.
    If the generation of some data takes a long time, we can use the data caching
    approach to reduce the data generation frequency; if a portion of page remains
    relatively static, we can use the fragment caching approach to reduce its rendering
    frequency; if a whole page remains relative static, we can use the page caching
    approach to save the rendering cost for the whole page.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中描述和演示的，Yii提供了许多缓存解决方案，可以显著提高Web应用程序的性能。如果生成某些数据需要很长时间，我们可以使用数据缓存方法来减少数据生成的频率；如果页面的某部分保持相对静态，我们可以使用片段缓存方法来减少其渲染频率；如果整个页面保持相对静态，我们可以使用页面缓存方法来节省整个页面请求的渲染成本。
- en: Enabling schema caching
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用模式缓存
- en: If the application is using **Active Record** (**AR**), you can turn on the
    schema caching in a production environment to save the time of parsing database
    schema. This can be done by configuring the `CDbConnection::schemaCachingDuration`
    property to be a value greater than zero.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序使用**Active Record**（**AR**），你可以在生产环境中启用模式缓存以节省解析数据库模式的时间。这可以通过将`CDbConnection::schemaCachingDuration`属性配置为大于零的值来实现。
- en: Besides these application-level caching techniques, we can also use server-side
    caching solutions to boost the application's performance. The enabling of APC
    caching that we described here, belongs to this category. There are other server-side
    techniques, such as Zend Optimizer, eAccelerator, and Squid, just to name a few.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些应用程序级别的缓存技术，我们还可以使用服务器端缓存解决方案来提升应用程序的性能。我们在这里描述的APC缓存的启用属于这个范畴。还有其他服务器端技术，比如Zend
    Optimizer、eAccelerator和Squid等。
- en: These, for the most part, just provide some good practice guidelines as you
    work to prepare your Yii application for production or troubleshoot an existing
    application for bottlenecks. General application performance tuning is much more
    of an art than a science, and there are many, many factors outside of the Yii
    framework that play into the overall performance. Yii has been built with performance
    in mind since its inception and continues to outperform many other PHP-based application
    development frameworks by a long shot (see [http://www.yiiframework.com/performance/](http://www.yiiframework.com/performance/)
    for more details). Of course, every single web application will need to be tweaked
    to enhance the performance, but making Yii the development framework of choice
    certainly puts your application on a great performance footing from the onset.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这些大部分只是在你准备将Yii应用程序投入生产或者为现有应用程序排除瓶颈时提供一些良好的实践指南。一般的应用程序性能调优更多的是一门艺术而不是科学，而且Yii框架之外有许多因素影响整体性能。Yii自问世以来就考虑了性能，并且继续远远超过许多其他基于PHP的应用程序开发框架（详见[http://www.yiiframework.com/performance/](http://www.yiiframework.com/performance/)）。当然，每个Web应用程序都需要进行调整以增强性能，但选择Yii作为开发框架肯定会让你的应用程序从一开始就具备良好的性能基础。
- en: For further details, see the *Performance Tuning* section of the Yii definitive
    guide at [http://www.yiiframework.com/doc/guide/1.1/en/topics.performance](http://www.yiiframework.com/doc/guide/1.1/en/topics.performance).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参阅Yii权威指南中的*性能调优*部分[http://www.yiiframework.com/doc/guide/1.1/en/topics.performance](http://www.yiiframework.com/doc/guide/1.1/en/topics.performance)。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have turned our attention to making changes to our application
    in order to help improve its maintainability and performance in a production environment.
    We first covered application logging strategies available in Yii, and how to log
    and route messages based on varying severity levels and categories. We then turned
    our focus to error handling and how Yii exploits the underlying exception implementation
    in PHP 5 to provide a flexible and robust error handling framework. We then learned
    about some different caching strategies available in Yii. We learned about the
    caching of application data and content at varying levels of granularity. Data
    caching for specific variables or individual pieces of data, fragment caching
    for content areas within pages, and full page caching to cache the entire rendered
    output of a page request. Finally, we provided a list of good practices to follow
    when working to improve the performance of a Yii-powered web application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将注意力转向对应用程序进行更改，以帮助提高其在生产环境中的可维护性和性能。我们首先介绍了Yii中可用的应用程序日志记录策略，以及如何根据不同的严重级别和类别记录和路由消息。然后我们转向错误处理，以及Yii如何利用PHP
    5中的基础异常实现来提供灵活和健壮的错误处理框架。然后我们了解了Yii中可用的一些不同的缓存策略。我们了解了在不同粒度级别上对应用程序数据和内容进行缓存的方法。对于特定变量或单个数据片段的数据缓存，对页面内的内容区域进行片段缓存，以及对整个渲染输出进行完整页面缓存。最后，我们提供了一系列在努力改善Yii驱动的Web应用程序性能时要遵循的良好实践。
- en: Congratulations! We should pat ourselves on the back. We have created an entire
    web application from conception to production readiness. Of course we should pat
    Yii on the back as well, as it helped ease and quicken the process at every turn.
    Our TrackStar application is already pretty great; but as is the case with all
    such projects, there is always room for enhancement and improvement. A nice foundation
    has been laid on which to build, and now that you have the power of Yii on your
    side you could very quickly turn this into a much more useable and feature-rich
    application. Also a great many of the examples covered will translate well to
    other types of web applications you may be building. I hope you now feel confident
    using Yii and will enjoy the benefits of doing so on your future projects. Happy
    developing!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们应该为自己鼓掌。我们已经从构思到生产准备阶段创建了一个完整的网络应用程序。当然，我们也应该为 Yii 鼓掌，因为它在每一个转折点都帮助我们简化和加快了这个过程。我们的
    TrackStar 应用程序已经相当不错；但就像所有这类项目一样，总会有改进和提高的空间。我们已经奠定了一个良好的基础，现在你拥有 Yii 的力量，你可以很快将其转变为一个更加易用和功能丰富的应用程序。此外，许多涵盖的示例也可以很好地应用到你可能正在构建的其他类型的网络应用程序上。我希望你现在对使用
    Yii 感到自信，并且会在未来的项目中享受到这样做的好处。开心开发！
