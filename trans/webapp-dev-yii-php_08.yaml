- en: Chapter 8. Adding User Comments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。添加用户评论
- en: With the implementation of user management throughout the two previous chapters,
    our Trackstar application is really starting to take shape. The bulk of our primary
    application feature functionality is now behind us. We can now start to focus
    on some of the nice-to-have features. The first of these that we will tackle is
    the ability for users to leave comments on the project issues.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前两章中对用户管理的实施，我们的Trackstar应用程序真的开始成形了。我们的主要应用程序功能的大部分功能现在已经完成。现在我们可以开始专注于一些很好有的功能。我们将首先解决的是用户在项目问题上留下评论的能力。
- en: The ability for users to engage in dialog about project issues is an important
    part of what any issue tracking tool should provide. One way to achieve this is
    to allow users to leave comments directly on the issues. The comments will form
    a conversation about the issue and provide immediate as well as historical context
    to help track the full lifespan of any issue. We will also use comments to demonstrate
    the use of Yii widgets and how to establish a portlet model for delivering content
    to the user (for more on portlets, see [http://en.wikipedia.org/wiki/Portlet](http://en.wikipedia.org/wiki/Portlet)).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 用户参与关于项目问题的对话的能力是任何问题跟踪工具应提供的重要部分。实现这一目标的一种方法是允许用户直接在问题上留下评论。评论将形成关于问题的对话，并提供即时和历史背景，以帮助跟踪任何问题的整个生命周期。我们还将使用评论来演示Yii小部件的使用以及如何建立一个小部件模型来向用户提供内容（有关小部件的更多信息，请参见[http://en.wikipedia.org/wiki/Portlet](http://en.wikipedia.org/wiki/Portlet)）。
- en: Feature planning
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能规划
- en: The goal of this chapter is to implement feature functionality in the Trackstar
    application that allows users to leave and read comments on issues. When the user
    is viewing the detail of any project issue, they should be able to read all comments
    previously added as well as create a new comment on the issue. We also want to
    add a small fragment of content or portlet to the project listing page to display
    a list of recent comments left on all of the issues. This will be a nice way to
    provide a window into recent user activity and allow easy access to the latest
    issues that have active conversations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是在Trackstar应用程序中实现功能，允许用户在问题上留下评论并阅读评论。当用户查看任何项目问题的详细信息时，他们应该能够阅读以前添加的所有评论，并在问题上创建新的评论。我们还希望在项目列表页面上添加一个小片段内容或小部件，以显示所有问题上最近留下的评论列表。这将是一个很好的方式，提供一个窗口进入最近的用户活动，并允许轻松访问最新的有活跃对话的问题。
- en: 'The following is a list of high-level tasks we will need to complete in order
    to achieve these goals:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要完成的高级任务列表：
- en: Design and create a new database table to support comments.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计并创建一个新的数据库表来支持评论。
- en: Create the Yii AR class associated with our new comments table.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建与我们的新评论表相关的Yii AR类。
- en: Add a form directly to the issue details page to allow users to submit comments.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在问题详细页面直接添加一个表单，允许用户提交评论。
- en: Display a list of all comments associated with an issue directly on its details
    page.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在问题的详细页面上显示与问题相关的所有评论列表。
- en: Take advantage of Yii widgets to display a list of the most recent comments
    on the projects listing page.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用Yii小部件在项目列表页面上显示最近评论的列表。
- en: Creating the model
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'We first need to create a new table to house our comments. As you might expect,
    we will use a database migration to make this addition to our database structure:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要创建一个新的表来存放我们的评论。正如您所期望的那样，我们将使用数据库迁移来对我们的数据库结构进行这个添加：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `up()` and `down()` methods are as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`up()`和`down()`方法如下：'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In order to implement this database change, we need to run the migration:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个数据库更改，我们需要运行迁移：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that our database table is in place, creating the associated AR class is
    a snap. We have seen this many times throughout the previous chapters. We know
    exactly how to do this. We simply use the Gii code creation tool's **Model Generator**
    command and create an AR class called `Comment`, based on our newly created table
    `tbl_comment`. If needed, refer back to [Chapter 4](ch04.html "Chapter 4. Project
    CRUD"), *Project CRUD* and [Chapter 5](ch05.html "Chapter 5. Managing Issues"),
    *Managing Issues*, for all the details on using this tool to create model classes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数据库表已经就位，创建相关的AR类就很容易了。我们在前几章中已经看到了很多次。我们知道如何做。我们只需使用Gii代码创建工具的**Model
    Generator**命令，并根据我们新创建的`tbl_comment`表创建一个名为`Comment`的AR类。如果需要，可以参考[第4章](ch04.html
    "第4章。项目CRUD")*项目CRUD*和[第5章](ch05.html "第5章。管理问题")*管理问题*，了解使用此工具创建模型类的所有细节。
- en: 'After using the Gii tool to create the model class for comments, you''ll notice
    that the code generated for us already has some relations defined. These are based
    on the foreign key relationships we defined on the `tbl_comments` table. The following
    is what was created for us:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Gii工具为评论创建模型类后，您会注意到为我们生成的代码已经定义了一些关系。这些关系是基于我们在`tbl_comments`表上定义的外键关系。以下是为我们创建的内容：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can see that we have a relationship that specifies a comment belongs to an
    issue. But we also need to define the one-to-many relationship between an issue
    and its comments. One issue can have many comments. This change needs to be made
    in the `Issue` model class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们有一个关系，指定评论属于一个问题。但我们还需要定义一个问题和它的评论之间的一对多关系。一个问题可以有多个评论。这个更改需要在`Issue`模型类中进行。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Had we created our comment model at the same time we created our Issue model,
    this relation would have been created for us.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在创建Issue模型的同时创建了我们的评论模型，这个关系就会为我们创建。
- en: 'In addition to this, we will also add a relationship as a statistical query
    to easily retrieve the number of comments associated with a given issue. Here
    are the changes we make to the `Issue::relations()` method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们还将添加一个关系作为统计查询，以便轻松检索与给定问题相关的评论数量。以下是我们对`Issue::relations()`方法所做的更改：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This establishes the one-to-many relationship between an issue and comments.
    It also defines a statistical query to allow us to easily retrieve the total comment
    count for any given issue instance.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这建立了问题和评论之间的一对多关系。它还定义了一个统计查询，允许我们轻松地检索任何给定问题实例的评论总数。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Statistical query**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 统计查询
- en: The `commentCount` relation defined previously is a new type of relation we
    have not seen before. In addition to relational queries, Yii also offers what
    is called a statistical or aggregational relationship. These are very useful in
    cases where there is a one-to-many (`HAS_MANY`) or many-to-many (`MANY_MANY`)
    relationship between objects. In such cases, we can define statistical relationships
    to allow us to easily get the total number of related objects. We have taken advantage
    of this in the previous relationship declarations to allow us to easily retrieve
    the total number of comments for any given issue instance. For more information
    on using statistical queries in Yii, refer to [http://www.yiiframework.com/doc/guide/1.1/en/database.arr#statistical-query](http://www.yiiframework.com/doc/guide/1.1/en/database.arr#statistical-query).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的`commentCount`关系是我们以前没有见过的一种新类型的关系。除了关联查询，Yii还提供了所谓的统计或聚合关系。在对象之间存在一对多（`HAS_MANY`）或多对多（`MANY_MANY`）关系的情况下，这些关系非常有用。在这种情况下，我们可以定义统计关系，以便轻松地获取相关对象的总数。我们已经利用了这一点，在之前的关系声明中，以便轻松地检索任何给定问题实例的评论总数。有关在Yii中使用统计查询的更多信息，请参阅[http://www.yiiframework.com/doc/guide/1.1/en/database.arr#statistical-query](http://www.yiiframework.com/doc/guide/1.1/en/database.arr#statistical-query)。
- en: 'We also need to change our newly created `Comment` AR class to extend our custom
    `TrackStarActiveRecord` base class, so that it benefits from the logic we placed
    in the `beforeSave()` method. Simply alter the beginning of the class definition,
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改我们新创建的`Comment` AR类，以扩展我们自定义的`TrackStarActiveRecord`基类，以便它从我们放置在`beforeSave()`方法中的逻辑中受益。只需修改类定义的开头，如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We'll make one last small change to the definitions in the `Comment::relations()`
    method. The relational attributes were named for us when the class was created.
    Let's change the one named `createUser`, to `author`, as this related user represents
    the author of the comment. This is just a semantic change, but it will help to
    make our code easier to read and understand. Change the definition from `'createUser'
    => array(self::BELONGS_TO, 'User', 'create_user_id'),` to `'author' => array(self::BELONGS_TO,
    'User', 'create_user_id')`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对`Comment::relations()`方法中的定义进行最后一次小的更改。在创建类时，关系属性已经为我们命名。让我们将名为`createUser`的属性更改为`author`，因为这个相关的用户代表评论的作者。这只是一个语义上的改变，但它将有助于使我们的代码更易于阅读和理解。将定义从`'createUser'
    => array(self::BELONGS_TO, 'User', 'create_user_id'),`更改为`'author' => array(self::BELONGS_TO,
    'User', 'create_user_id')`。
- en: Creating the comment CRUD
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建评论CRUD
- en: Now that we have our AR model class in place, creating the CRUD scaffolding
    to manage the related entity is easy. Simply use the Gii code generation tool's
    **Crud Generator** command with the AR class name, `Comment`, as the argument.
    We have seen this many times in previous chapters, so we won't go through it in
    detail again here. If needed, refer back to [Chapter 4](ch04.html "Chapter 4. Project
    CRUD"), *Project CRUD* and [Chapter 5](ch05.html "Chapter 5. Managing Issues"),
    *Managing Issues*, for all the details on using the Gii tool to create CRUD scaffolding
    code. Although we will not immediately implement full CRUD operations for our
    comments, it is nice to have the scaffolding for the other operations in place.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了AR模型类，创建用于管理相关实体的CRUD脚手架很容易。只需使用Gii代码生成工具的Crud生成器命令，参数为AR类名`Comment`。我们在之前的章节中已经看到了这个很多次，所以我们不会在这里再详细介绍。如果需要，可以参考[第4章](ch04.html
    "第4章。项目CRUD")，*项目CRUD*和[第5章](ch05.html "第5章。管理问题")，*管理问题*，了解使用Gii工具创建CRUD脚手架代码的所有细节。虽然我们不会立即为我们的评论实现完整的CRUD操作，但是有其他操作的脚手架是很好的。
- en: 'After using Gii''s Crud Generator, and as long as we are logged in, we should
    now be able to view the autogenerated comment submission form via the following
    URL:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Gii的Crud生成器之后，只要我们登录，现在我们应该能够通过以下URL查看自动生成的评论提交表单：
- en: '`http://localhost/trackstar/index.php?r=comment/create`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost/trackstar/index.php?r=comment/create`'
- en: Altering the scaffolding to meet our requirements
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改脚手架以满足我们的要求
- en: 'As we have seen many times before, we often have to make adjustments to the
    autogenerated scaffolding code in order to meet the specific requirements of the
    application. For one, our autogenerated form for creating a new comment has an
    input field for every single column defined in the `tbl_comment` database table.
    We don''t actually want all of these fields to be part of the form. In fact, we
    want to greatly simplify this form to only have a single input field for the comment
    content. What''s more, we don''t want the user to access the form via the previously
    mentioned URL, but rather only by visiting an issue details page. The user will
    add comments on the same page where they are viewing the details of the issue.
    We want to build towards something like what is depicted in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们以前经常看到的那样，我们经常需要调整自动生成的脚手架代码，以满足应用程序的特定要求。首先，我们用于创建新评论的自动生成表单为`tbl_comment`数据库表中定义的每个列都有一个输入字段。实际上，我们并不希望所有这些字段都成为表单的一部分。事实上，我们希望大大简化这个表单，只有一个用于评论内容的输入字段。而且，我们不希望用户通过之前提到的URL访问表单，而是只能通过访问问题详情页面来添加评论。用户将在查看问题详情的页面上添加评论。我们希望朝着以下截图所示的方式构建：
- en: '![Altering the scaffolding to meet our requirements](graphics/8727_08_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![修改脚手架以满足我们的要求](graphics/8727_08_01.jpg)'
- en: In order to achieve this, we are going to alter our `Issue` controller class
    to handle the post of the comment form as well as alter the issue details view
    to display the existing comments and new comment creation form. Also, since comments
    should only be created within the context of an issue, we'll add a new method
    to the issue model class to create new comments.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将修改我们的`Issue`控制器类，以处理评论表单的提交，并修改问题详细信息视图，以显示现有评论和新评论创建表单。此外，由于评论应该只在问题的上下文中创建，我们将在问题模型类中添加一个新方法来创建新评论。
- en: Adding a comment
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加评论
- en: 'As mentioned, we are going to have the issue instance create its own comments.
    For this, we want to add a method to the `Issue` AR class. Here is that method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，我们将让问题实例创建自己的评论。为此，我们希望在`Issue` AR类中添加一个方法。以下是该方法：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method ensures the proper setting of the comment issue ID before saving
    the new comment. That is, when an instance of `Issue` creates a new comment, it
    is understood that the comment belongs to that issue.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法确保在保存新评论之前正确设置评论问题ID。也就是说，当`Issue`的实例创建新评论时，我们知道该评论属于该问题。
- en: 'With this method in place, we can now turn our focus to the issue controller
    class. Since we want the comment creation form to display from and post its data
    back to the `IssueController::actionView()` method, we will need to alter that
    method. We will also add a new protected method to handle the form post request.
    First, alter the `actionView()` method to be the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个方法，我们现在可以把重点转向问题控制器类。由于我们希望评论创建表单从`IssueController::actionView()`方法显示并将其数据发送回来，我们需要修改该方法。我们还将添加一个新的受保护方法来处理表单提交请求。首先，修改`actionView()`方法如下：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, add the following protected method to create a new comment and handle
    the form post request for creating a new comment for this issue:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加以下受保护方法来创建一个新评论并处理创建此问题的新评论的表单提交请求：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our new protected method, `createComment()`, is responsible for handling the
    `POST` request submitted when a user is leaving a new comment on an issue. If
    the comment is successfully created, we set a flash message to display to the
    user and also do a page refresh so that our new comment will display. Of course,
    we still need to alter our view file to make all of this display to the user.
    The changes made to `IssueController::actionView()` are responsible for calling
    this new method and also for feeding the new comment instance to the view for
    display.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新受保护方法`createComment()`负责处理用户在问题上留下新评论时提交的`POST`请求。如果成功创建评论，我们设置一个闪存消息显示给用户，并进行页面刷新，以便我们的新评论将显示。当然，我们仍然需要修改我们的视图文件，以便所有这些显示给用户。对`IssueController::actionView()`所做的更改负责调用这个新方法，并为显示提供新评论实例。
- en: Displaying the form
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示表单
- en: Now, we need to alter our view. First we are going to create a new view file
    to render the display of our comments and the comment input form. We intend to
    display this view file within another view file. As such, we don't want to display
    all of the general page components, such as the header navigation and footer information,
    again. View files that are intended to be displayed within other view files, or
    without any extra decoration, are called **partial** views. You can then use the
    controller method `renderPartial()`, as opposed to the `render()` method. Using
    `renderPartial()` will only render the content contained within that view file
    and will not decorate the display with any other content. We will be discussing
    this in much more detail in [Chapter 10](ch10.html "Chapter 10. Making It Look
    Good"), *Making it Look Good*, when we discuss using layouts and decorating your
    view files.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改我们的视图。首先，我们将创建一个新的视图文件来呈现我们的评论显示和评论输入表单。我们打算在另一个视图文件中显示此视图文件。因此，我们不希望再次显示所有一般页面组件，例如页眉导航和页脚信息。打算在其他视图文件中显示或不带任何额外装饰的视图文件称为**partial**视图。然后，您可以使用控制器方法`renderPartial()`，而不是`render()`方法。使用`renderPartial()`将仅呈现该视图文件中包含的内容，并且不会用任何其他内容装饰显示。当我们讨论使用布局和装饰视图文件时，我们将在[第10章](ch10.html
    "第10章。让它看起来不错")*让它看起来不错*中详细讨论这一点。
- en: 'Yii uses a naming convention of a leading underscore (`_`) when creating partial
    view files. Since we''ll render this as a partial view, we''ll stick with the
    naming conventions and begin the filename with a leading underscore. Create a
    new file called `_comments.php` under the `protected/views/issue/` directory and
    add the following code to that file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Yii在创建部分视图文件时使用下划线（`_`）作为命名约定的前缀。由于我们将其呈现为部分视图，我们将遵循命名约定，并以下划线开头命名文件。在`protected/views/issue/`目录下创建一个名为`_comments.php`的新文件，并将以下代码添加到该文件中：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This file accepts an array of comment instances as an input parameter and displays
    them one by one. We now need to alter the view file for the issue detail to use
    this new file. We do this by opening up `protected/views/issue/view.php` and adding
    the following to the end of the file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件接受评论实例数组作为输入参数，并逐个显示它们。现在，我们需要修改问题详细信息的视图文件以使用这个新文件。我们通过打开`protected/views/issue/view.php`并在文件末尾添加以下内容来实现这一点：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we are taking advantage of the statistical query property, `commentCount`,
    which we added earlier to our `Issue` AR model class. This allows us to quickly
    determine if there are any comments available for the specific issue. If there
    are comments, it proceeds to render them using our `_comments.php` display view
    file. It then displays the input form that was created for us when we used the
    Gii Crud Generator functionality. It will also display the simple flash message
    set upon a successfully saved comment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用了我们之前添加到`Issue` AR模型类的统计查询属性`commentCount`。这使我们能够快速确定特定问题是否有任何可用的评论。如果有评论，它将继续使用我们的`_comments.php`显示视图文件来呈现它们。然后显示我们在使用Gii
    Crud Generator功能时为我们创建的输入表单。它还会显示成功保存评论时设置的简单闪存消息。
- en: 'One last change we need to make is to the comment input form itself. As we
    have seen many times in the past, the form created for us has an input field for
    every column defined in the underlying `tbl_comment` table. This is not what we
    want to display to the user. We want to make this a simple input form where the
    user only needs to submit the comment content. So, open up the view file that
    houses the input form, that is `protected/views/comment/_form.php`, and edit it
    to be as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一个改变是评论输入表单本身。正如我们过去多次看到的那样，为我们创建的表单在底层`tbl_comment`表中定义了每一列的输入字段。这不是我们想要显示给用户的。我们希望将其变成一个简单的输入表单，用户只需要提交评论内容。因此，打开包含输入表单的视图文件，即`protected/views/comment/_form.php`，并编辑如下：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With all of this in place, we can visit an issue listing page to see the comment
    form. For example, if we visit `http://localhost/trackstar/index.php?r=issue/view&id=111`,
    we see the following comment input form at the bottom of the page:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一切，我们可以访问问题列表页面查看评论表单。例如，如果我们访问`http://localhost/trackstar/index.php?r=issue/view&id=111`，我们将在页面底部看到以下评论输入表单：
- en: '![Displaying the form](graphics/8727_08_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![显示表单](graphics/8727_08_02.jpg)'
- en: 'If we attempt to submit the comment without specifying any content, we see
    the error as depicted in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试提交评论而没有指定任何内容，我们将看到以下截图中所示的错误：
- en: '![Displaying the form](graphics/8727_08_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![显示表单](graphics/8727_08_03.jpg)'
- en: 'And then, if we are logged in as `User One` and we submit the comment `My first
    test comment`, we are presented with the following display:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们以`User One`的身份登录并提交评论`My first test comment`，我们将看到以下显示：
- en: '![Displaying the form](graphics/8727_08_04.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![显示表单](graphics/8727_08_04.jpg)'
- en: Creating a recent comments widget
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个最近评论的小部件
- en: Now that we have the ability to leave comments on issues, we are going to turn
    our focus to the second goal of this chapter. We want to display a list of all
    of the recent comments that have been left on various issues across all of the
    projects. This will provide a nice snapshot of user communication activity within
    the application. We also want to build this small block of content in a manner
    that will allow it to be easily reused in various different locations throughout
    the site. This is very much in the style of myriad web portal applications across
    the internet. These small snippets of content are often referred to as **portlets**,
    and is why we referred to building portlet architecture at the beginning of this
    chapter. Again, you can refer to [http://en.wikipedia.org/wiki/Portlet](http://en.wikipedia.org/wiki/Portlet)
    for more information on this topic.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在问题上留下评论，我们将把重点转向本章的第二个目标。我们想要显示所有项目中留下的最近评论列表。这将提供应用程序中用户沟通活动的一个很好的快照。我们还希望以一种方式构建这个小的内容块，使它可以在站点的不同位置轻松重复使用。这在互联网上的许多网络门户应用程序中非常常见。这些小的内容片段通常被称为**portlet**，这也是为什么我们在本章开头提到构建portlet架构。您可以参考[http://en.wikipedia.org/wiki/Portlet](http://en.wikipedia.org/wiki/Portlet)了解更多关于这个主题的信息。
- en: Introducing CWidget
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍CWidget
- en: Lucky for us, Yii is ready-made to help us achieve this architecture. Yii provides
    a component class called `CWidget`, which is perfect for achieving this type of
    architecture. A Yii **widget** is an instance of the `CWidget` class (or a child
    class thereof), and is a presentational component typically embedded in a view
    file to display self-contained, reusable user interface features. We are going
    to use a Yii widget to build a recent comments component and display it on the
    main project details page so we can see comment activity across all issues related
    to the project. To demonstrate the ease of re-use, we'll take it one step further
    and also display a list of recent comments across all projects on the projects
    listings page.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Yii已经准备好帮助我们实现这种架构。Yii提供了一个名为`CWidget`的组件类，非常适合实现这种类型的架构。Yii的**widget**是`CWidget`类的一个实例（或其子类），通常嵌入在视图文件中以显示自包含、可重用的用户界面功能。我们将使用Yii的widget来构建一个最近评论组件，并在主项目详情页面上显示它，以便我们可以看到与项目相关的所有问题的评论活动。为了演示重用的便利性，我们将进一步显示一个最近评论列表，跨所有项目在项目列表页面上。
- en: Named scopes
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名作用域
- en: To begin creating our widget, we are going to first alter our `Comment` AR model
    class to return the most recently added comments. To do this, we are going to
    take advantage of another feature within Yii's AR model classes—named scopes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建我们的小部件，我们首先要修改我们的`Comment` AR模型类，以返回最近添加的评论。为此，我们将利用Yii的AR模型类中的另一个特性——命名作用域。
- en: '**Named scopes** allow us to specify a named query, which provides an elegant
    way to define SQL `where` conditions when retrieving lists of AR objects. Named
    scopes are typically defined in the `CActiveRecord::scopes()` method as `name=>criteria`
    pairs. For example, if we want to define a named scope called `recent` that would
    return the five most recent comments; we could create the `Comment::scopes()`
    method as such:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名作用域**允许我们指定一个命名查询，提供了一种优雅的方式来定义检索AR对象列表时的SQL `where`条件。命名作用域通常在`CActiveRecord::scopes()`方法中定义为`name=>criteria`对。例如，如果我们想定义一个名为`recent`的命名作用域，它将返回最近的五条评论；我们可以创建`Comment::scopes()`方法如下：'
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can easily retrieve a list of recent comments, using the following
    syntax:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下语法轻松检索最近评论的列表：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also chain named scopes together. If we had defined another named scope,
    for example, `approved` (if our application were to have an approval process before
    comments would be displayed), we could get a list of the most recent approved
    comments, thus:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以链接命名作用域。如果我们定义了另一个命名作用域，例如`approved`（如果我们的应用程序在显示评论之前需要经过批准过程），我们可以获取最近批准的评论列表，如下所示：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see that by chaining these together, we have a flexible and powerful
    way to retrieve our objects in specific contexts.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到通过将它们链接在一起，我们有一种灵活而强大的方式来在特定上下文中检索我们的对象。
- en: Named scopes must appear to the left of a `find` call (`find`, `findAll`, `findByPk`,
    and so on) and also can only be used in a class-level context. The named scope
    method call must be used along with `ClassName::model()`. See [http://www.yiiframework.com/doc/guide/1.1/en/database.ar#named-scopes](http://www.yiiframework.com/doc/guide/1.1/en/database.ar#named-scopes)
    for more information on named scopes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 命名范围必须出现在`find`调用的左侧（`find`，`findAll`，`findByPk`等），并且只能在类级上下文中使用。命名范围方法调用必须与`ClassName::model()`一起使用。有关命名范围的更多信息，请参见[http://www.yiiframework.com/doc/guide/1.1/en/database.ar#named-scopes](http://www.yiiframework.com/doc/guide/1.1/en/database.ar#named-scopes)。
- en: 'Named scopes can also be parameterized. In the earlier `recent` named scope
    for comments, we hardcoded the limit in the criteria to be `5`. However, we may
    want to be able to specify the limit number when we call the method. This is how
    we will set up our named scope for comments. To add parameters, we specify the
    named scope a bit differently. Rather than use the `scopes()` method to declare
    our scope, we define a new public method whose name is the same as the scope name.
    Add the following method to the `Comment` AR class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 命名范围也可以被参数化。在先前的评论`recent`命名范围中，我们在条件中硬编码了限制为`5`。然而，当我们调用该方法时，我们可能希望能够指定限制数量。这就是我们为评论设置命名范围的方式。要添加参数，我们以稍有不同的方式指定命名范围。我们不是使用`scopes()`方法来声明我们的范围，而是定义一个新的公共方法，其名称与范围名称相同。将以下方法添加到`Comment`
    AR类中：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: One thing to note about this query condition is the use of `t` in the order
    value. This is to help in the event that this is used along with another related
    table that has the same column name. Obviously, when two tables that are being
    joined have columns with the same name, we have to make a distinction between
    the two in our query. For example, if we use this in the same query where we are
    retrieving `Issue` AR information, both `tbl_issue` and `tbl_comment` tables have
    the `create_time` column defined. We are trying to order by this column in the
    `tbl_comment` table and not the one defined in the issue table. In relational
    AR query in Yii, the alias name for the primary table is fixed as `t`, while the
    alias name for a relational table, by default, is the same as the corresponding
    relation name. So, in this case, we specify `t.create_time` to indicate that we
    want to use the primary table's column.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个查询条件的一件事是在order值中使用了`t`。这是为了帮助在与另一个具有相同列名的相关表一起使用时。显然，当两个被连接的表具有相同的列名时，我们必须在查询中区分这两个表。例如，如果我们在相同的查询中使用这个查询来检索`Issue`
    AR信息，`tbl_issue`和`tbl_comment`表都有定义`create_time`列。我们试图按照`tbl_comment`表中的这一列进行排序，而不是在问题表中定义的那一列。在Yii的关系AR查询中，主表的别名固定为`t`，而关系表的别名默认情况下与相应的关系名称相同。因此，在这种情况下，我们指定`t.create_time`以指示我们要使用主表的列。
- en: More on relational AR queries in Yii
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Yii中关于关系AR查询的更多信息
- en: 'With this method in place, we could combine the named scope with an eager loading
    approach to also retrieve related `Issue` AR instances. For example, let''s say
    we want to get the last ten comments left on issues related to a project whose
    ID is `1`. We could use the following to do so:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这种方法，我们可以将命名范围与急切加载方法结合起来，以检索相关的`Issue` AR实例。例如，假设我们想要获取与ID为`1`的项目相关的最后十条评论，我们可以使用以下方法：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This query is new to us. We have not been using many of these options in our
    previous queries. Previously, we were using different approaches to execute relational
    queries:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询对我们来说是新的。在以前的查询中，我们没有使用许多这些选项。以前，我们使用不同的方法来执行关系查询：
- en: Load the AR instance
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载AR实例
- en: Access the relational properties defined in the `relations()` method
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`relations()`方法中定义的关系属性中访问
- en: 'For example, if we wanted to query for all of the issues associated with, say,
    project ID #1, we would have been using something similar to the following two
    lines of code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要查询与项目ID＃1关联的所有问题，我们将使用类似以下两行代码的内容：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This familiar approach uses what is referred to as **lazy loading**. When we
    first create the project instance, the query does not return all of the associated
    issues. It only retrieves the associated issues upon a subsequent, explicit request
    for them, that is when `$project->issues` is executed. This is referred to as
    "lazy" because it waits to load the issues until they are requested at a later
    time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种熟悉的方法使用了所谓的**懒加载**。当我们首次创建项目实例时，查询不会返回所有相关的问题。它只在以后明确请求它们时检索相关的问题，也就是当执行`$project->issues`时。这被称为“懒惰”，因为它等到以后请求时才加载问题。
- en: This approach is very convenient and can also be very efficient, especially
    in those cases where the associated issues are not required. However, in other
    circumstances, this approach can be somewhat inefficient. For example, if we wanted
    to retrieve the issue information across *N* projects, then using this lazy approach
    would involve executing *N* join queries. Depending on how large *N* is, this
    could be very inefficient. In these situations, we have another option. We can
    use what is called **eager loading**.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常方便，而且在那些不需要相关问题的情况下也可以非常高效。然而，在其他情况下，这种方法可能有些低效。例如，如果我们想要检索跨*N*项目的问题信息，那么使用这种懒惰的方法将涉及执行*N*个连接查询。根据*N*的大小，这可能非常低效。在这些情况下，我们有另一个选择。我们可以使用所谓的**急切加载**。
- en: 'The eager loading approach retrieves the related AR instances at the same time
    as the main AR instances are requested. This is accomplished by using the `with()`
    method in concert with either the `find()` or `findAll()` methods for AR query.
    Sticking with our project example, we could use eager loading to retrieve all
    issues for all projects by executing the following single line of code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 急切加载方法在请求主AR实例的同时检索相关的AR实例。这是通过在AR查询的`find()`或`findAll()`方法与`with()`方法一起使用来实现的。继续使用我们的项目示例，我们可以使用急切加载来检索所有项目的所有问题，只需执行以下一行代码：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, in this case, every project AR instance in the `$projects` array already
    has its associated `issues` property populated with an array of `Issue` AR instances.
    This result has been achieved by using just a single join query.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这种情况下，`$projects`数组中的每个项目AR实例已经具有其关联的`issues`属性，该属性填充有`Issue` AR实例的数组。这是通过使用单个连接查询实现的。
- en: 'So, let''s look back at our example of retrieving the last ten comments for
    a specific project:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们回顾一下我们检索特定项目的最后十条评论的示例：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We are using the eager loading approach to retrieve the issues along with the
    comments, but this one is slightly more complex. This query specifies a single
    join between the `tbl_comment` and `tbl_issue` tables. This relational AR query
    would basically execute something similar to the following SQL statement:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用急切加载方法来检索问题以及评论，但这个方法稍微复杂一些。这个查询在`tbl_comment`和`tbl_issue`表之间指定了一个连接。这个关系AR查询基本上会执行类似于以下SQL语句的操作：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Armed with the knowledge about the benefits of lazy loading versus eager loading
    in Yii, we should make an adjustment to how the issue model is loaded within the
    `IssueController::actionView()` method. Since we have altered the issues' detail
    view to display our comments, including the author of the comment, we know it
    will be more efficient to use the eager loading approach to load our comments
    along with their respective authors when we make the call to `IssueController::loadModel()`.
    To do this, we can add an additional parameter as a simple input flag to indicate
    whether or not we want to load the comments as well.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了Yii中延迟加载和急切加载的好处的知识后，我们应该调整`IssueController::actionView()`方法中加载问题模型的方式。由于我们已经修改了问题的详细视图以显示我们的评论，包括评论的作者，我们知道在调用`IssueController::loadModel()`时，使用急切加载方法加载评论以及它们各自的作者将更有效。为此，我们可以添加一个额外的参数作为简单的输入标志，以指示我们是否要加载评论。
- en: 'Alter the `IssueController::loadModel()` method as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`IssueController::loadModel()`方法如下：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are three places where the `loadModel()` method is called in the `IssueController`
    method: `actionView`, `actionUpdate`, and `actionDelete`. We only need the associated
    comments when we are viewing the issue details. So, we have made the default to
    not retrieve the associated comments. We just need to alter the `actionView()`
    method to add `true` to the `loadModel()` call.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`IssueController`方法中有三个地方调用了`loadModel()`方法：`actionView`，`actionUpdate`和`actionDelete`。当我们查看问题详情时，我们只需要关联的评论。因此，我们已经将默认设置为不检索关联的评论。我们只需要修改`actionView()`方法，在`loadModel()`调用中添加`true`。
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With this in place, we will load the issue along with all of its associated
    comments, and for each comment, we'll load the associated author information,
    all with just one database call.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们将加载问题以及其所有关联的评论，并且对于每条评论，我们将加载关联的作者信息，只需一次数据库调用。
- en: Creating the widget
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建小部件
- en: We are now ready to create our new widget to make use of all the previously
    mentioned changes to display our recent comments.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好创建我们的新小部件，以利用之前提到的所有更改来显示我们的最新评论。
- en: 'As we previously mentioned, a widget in Yii is a class that extends from the
    framework class, `CWidget`, or one of its child classes. We''ll add our new widget
    to the `protected/components/` directory, as the contents of this directory are
    already specified in the main configuration file to be autoloaded within the application.
    This way, we won''t have to explicitly import the class every time we wish to
    use it. We''ll call our widget `RecentComments` and add a `.php` file of the same
    name to this directory. Add the following class definition to this newly created
    `RecentComments.php` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Yii中的小部件是从框架类`CWidget`或其子类扩展的类。我们将把我们的新小部件添加到`protected/components/`目录中，因为该目录的内容已经在主配置文件中指定为在应用程序中自动加载。这样，我们就不必在每次使用时显式导入该类。我们将称我们的小部件为`RecentComments`，并在该目录中添加一个同名的`.php`文件。将以下类定义添加到这个新创建的`RecentComments.php`文件中：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The primary work involved when creating a new widget is to override the `init()`
    and `run()` methods of the base class. The `init()` method initializes the widget
    and is called after its properties have been initialized. The `run()` method executes
    the widget. In this case, we simply initialize the widget by requesting recent
    comments based on the `$displayLimit` and `$projectId` properties, using the query
    we discussed previously. The execution of the widget itself simply renders its
    associated view file, which we have yet to create. View files for widgets, by
    convention, are placed in a `views/` directory within the same directory where
    the widget resides and are named the same as the widget, except starting with
    a lowercase letter. Sticking with this convention, create a new file whose fully
    qualified path is `protected/components/views/recentCommentsWidget.php`. Once
    created, add the following to that file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新小部件时的主要工作是重写基类的`init()`和`run()`方法。`init()`方法初始化小部件，并在其属性被初始化后调用。`run()`方法执行小部件。在这种情况下，我们只需通过请求基于`$displayLimit`和`$projectId`属性的最新评论来初始化小部件，使用我们之前讨论过的查询。小部件本身的执行只是简单地呈现其关联的视图文件，我们还没有创建。按照惯例，小部件的视图文件放在与小部件相同的目录中的`views/`目录中，并且与小部件同名，但以小写字母开头。遵循这个惯例，创建一个新文件，其完全限定的路径是`protected/components/views/recentCommentsWidget.php`。创建后，在该文件中添加以下内容：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This calls the `RecentCommentsWidget::getData()` method, which returns an array
    of comments. It then iterates over each of them, displaying who added the comment
    and the associated issue on which the comment was left.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这调用了`RecentCommentsWidget::getData()`方法，该方法返回一个评论数组。然后遍历每个评论，显示添加评论的人以及留下评论的相关问题。
- en: In order to see the results, we need to embed this widget into an existing controller
    view file. As previously mentioned, we want to use this widget on the projects
    listing page to display all recent comments across all projects, and also on a
    specific project details page to display the recent comments for just that specific
    project.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到结果，我们需要将这个小部件嵌入到现有的控制器视图文件中。如前所述，我们希望在项目列表页面上使用这个小部件，以显示所有项目的最近评论，并且在特定项目详情页面上，只显示该特定项目的最近评论。
- en: 'Let''s start with the projects listing page. The view file responsible for
    displaying that content is `protected/views/project/index.php`. Open up that file
    and add the following at the bottom:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从项目列表页面开始。负责显示该内容的视图文件是`protected/views/project/index.php`。打开该文件，并在底部添加以下内容：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we view the projects listing page `http://localhost/trackstar/index.php?r=project`
    now, we see something similar to the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在查看项目列表页面`http://localhost/trackstar/index.php?r=project`，我们会看到类似以下截图的内容：
- en: '![Creating the widget](graphics/8727_08_05.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![创建小部件](graphics/8727_08_05.jpg)'
- en: We have now embedded our new recent comments data within the page, simply by
    calling the widget. This is nice, but we can take our little widget one step further
    to have it display in a consistent manner with all other potential *portlets*
    in the application. We can do this by taking advantage of another class provided
    to us by Yii, `CPortlet`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过调用小部件将我们的新最近评论数据嵌入到页面中。这很好，但我们可以进一步将我们的小部件显示为应用程序中所有其他潜在*小部件*的一致方式。我们可以利用Yii为我们提供的另一个类`CPortlet`来实现这一点。
- en: Introducing CPortlet
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍CPortlet
- en: '`CPortlet` is part of Zii, the official extension class library that comes
    packaged with Yii. It provides a nice base class for all portlet-style widgets.
    It will allow us to render a nice title as well as a consistent HTML markup, so
    that all portlets across the application can be easily styled in a similar manner.
    Once we have a widget that renders content, such as our `RecentCommentsWidget`,
    we can simply use the rendered content of our widget as the content for `CPortlet`,
    which itself is a widget, as it also extends from `CWidget`. We can do this by
    placing our call to the `RecentComments` widget between a `beginWidget()` and
    an `endWiget()` call for `CPortlet`, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`CPortlet`是Zii的一部分，它是Yii捆绑的官方扩展类库。它为所有小部件提供了一个不错的基类。它将允许我们渲染一个漂亮的标题以及一致的HTML标记，这样应用程序中的所有小部件都可以很容易地以类似的方式进行样式设置。一旦我们有一个渲染内容的小部件，比如我们的`RecentCommentsWidget`，我们可以简单地使用我们小部件的渲染内容作为`CPortlet`的内容，`CPortlet`本身也是一个小部件，因为它也是从`CWidget`继承而来。我们可以通过在`CPortlet`的`beginWidget()`和`endWiget()`调用之间放置我们对`RecentComments`小部件的调用来实现这一点，如下所示：'
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since `CPortlet` provides a title property, we set it to be something meaningful
    for our portlet. We then use the rendered content of the `RecentComments` widget
    to provide the content for the portlet widget. The end result of this is depicted
    in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CPortlet`提供了一个标题属性，我们将其设置为对我们的portlet有意义的内容。然后，我们使用`RecentComments`小部件的渲染内容来为portlet小部件提供内容。这样做的最终结果如下截图所示：
- en: '![Introducing CPortlet](graphics/8727_08_06.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![介绍CPortlet](graphics/8727_08_06.jpg)'
- en: 'This is not a huge change from what we had previously, but we have now placed
    our content into a consistent container that is already being used throughout
    the site. Note the similarity between the right-hand column menu content block
    and our newly created, recent comments content block. I am sure it will come as
    no surprise to you that this right-hand column menu block is also displayed within
    a `CPortlet` container. Taking a peek in `protected/views/layouts/column2.php`,
    which is a file that the `yiic webapp` command autogenerated for us when we initially
    created the application, reveals the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前的情况并没有太大的变化，但现在我们已经将我们的内容放入了一个一致的容器中，这个容器已经在整个网站中使用。请注意右侧列菜单内容块和我们新创建的最近评论内容块之间的相似之处。我相信你不会感到意外，右侧列菜单块也是在`CPortlet`容器中显示的。查看`protected/views/layouts/column2.php`，这是一个在我们最初创建应用程序时由`yiic
    webapp`命令自动生成的文件，会发现以下代码：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So, it seems that the application has been taking advantage of portlets all
    along!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，看来应用程序一直在利用小部件！
- en: Adding our widget to another page
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将我们的小部件添加到另一个页面
- en: Let's also add our portlet to the project details page and restrict the comments
    to just those associated with the specific project.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还将我们的小部件添加到项目详情页面，并将评论限制为与特定项目相关的评论。
- en: 'Add the following at the end of the `protected/views/project/view.php` file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`protected/views/project/view.php`文件的末尾添加以下内容：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is basically the same thing we added to the projects listing page, except
    we are initializing the widget's `$projectId` property by adding an array of `name=>value`
    pairs to the call.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与我们添加到项目列表页面的内容相同，只是我们通过向调用添加一个`name=>value`对的数组来初始化小部件的`$projectId`属性。
- en: 'If we visit a specific project details page now, we should see something similar
    to the following screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在访问特定项目详情页面，我们应该会看到类似以下截图的内容：
- en: '![Adding our widget to another page](graphics/8727_08_07.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![将我们的小部件添加到另一个页面](graphics/8727_08_07.jpg)'
- en: 'This preceding screenshot shows the details page for **Project #1**, which
    has one associated issue with just one comment on that issue, as depicted in the
    screenshot. You may need to add a few issues and comments on those issues in order
    to generate a similar display. We now have a way to display recent comments with
    a few different configurable parameters anywhere throughout the site, in a consistent
    and easily maintainable manner.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了**项目#1**的详情页面，该项目有一个关联的问题，该问题只有一个评论，如截图所示。您可能需要添加一些问题和这些问题的评论，以生成类似的显示。现在我们有一种方法可以在整个网站的任何地方以一致且易于维护的方式显示最近的评论。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With this chapter, we have started to flush out our Trackstar application with
    the functionality that has come to be expected of most user-based web applications
    today. The ability for users to communicate with each other within the application
    is an essential part of a successful issue management system.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们已经开始为我们的Trackstar应用程序添加功能，这些功能已经成为当今大多数基于用户的Web应用程序所期望的。用户在应用程序内部相互通信的能力是成功的问题管理系统的重要组成部分。
- en: As we created this essential feature, we were able to look deeper into how to
    write relational AR queries. We were also introduced to content components called
    widgets and portlets. This introduced us to an approach to developing small content
    blocks and being able to use them anywhere throughout the application. This approach
    greatly increases re-use, consistency, and ease of maintenance.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建了这一重要功能时，我们能够更深入地了解如何编写关系AR查询。我们还介绍了称为小部件和门户网站的内容组件。这使我们能够开发小的内容块，并能够在应用程序的任何地方使用它们。这种方法极大地增加了重用性、一致性和易于维护性。
- en: In the next chapter, we'll build upon the recent comments widget created here
    and expose the content generated by our widget as an RSS feed to allow users to
    track application or project activity without having to visit the application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在这里创建的最近评论小部件的基础上构建，并将我们小部件生成的内容作为RSS订阅公开，以便用户可以跟踪应用程序或项目的活动，而无需访问应用程序。
