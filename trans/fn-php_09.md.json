["```php\n<?php \n\nuse Functional as f; \n\nfunction add($a, $b) \n{ \n    return $a + $b; \n} \n\nfunction manualCurryAdd($a, $b = null) { \n    $func = function($b) use($a) { \n        return $a + $b; \n    }; \n\n    return func_num_args() > 1 ? $func($b) : $func; \n} \n\n$curryiedAdd = f\\curry('add'); \n\nfunction add2($b) \n{ \n    return $b + 2; \n} \n\nfunction add4($b) \n{ \n    return $b + 4; \n} \n\n$composedAdd4 = f\\compose('add2', 'add2'); \n\n$composerCurryedAdd = f\\compose($curryiedAdd(2), $curryiedAdd(2)); \n```", "```php\n<?php \n\nuse Oefenweb\\Statistics\\Statistics; \n\nfunction benchmark($function, $params, $expected) \n{ \n    $iteration   = 10; \n    $computation = 2000000; \n\n    $times = array_map(function() use($computation, $function,  $params, $expected) { \n        $start = microtime(true); \n\n        array_reduce(range(0, $computation), function($expected)  use ($function, $params) { \n            if(($res = call_user_func_array($function, $params))  !== $expected) { \n                throw new RuntimeException(\"Faulty computation\"); \n            } \n\n            return $expected; \n        }, $expected); \n\n        return microtime(true) - $start; \n    }, range(0, $iteration)); \n\n    echo sprintf(\"mean: %02.3f seconds\\n\",  Statistics::mean($times)); \n    echo sprintf(\"std:  %02.3f seconds\\n\",  Statistics::standardDeviation($times)); } \n```", "```php\n<?php \n\nbenchmark('add', [21, 33], 54); \n// mean: 0.447 seconds \n// std:  0.015 seconds \n\nbenchmark('manualCurryAdd', [21, 33], 54); \n// mean: 1.210 seconds \n// std:  0.016 seconds \n\nbenchmark($curryiedAdd, [21, 33], 54); \n// mean: 1.476 seconds \n// std:  0.007 seconds \n```", "```php\n<?php \n\nbenchmark('add4', [10], 14); \n// mean: 0.434 seconds \n// std:  0.001 seconds \n\nbenchmark($composedAdd4, [10], 14); \n// mean: 1.362 seconds \n// std:  0.005 seconds \n\nbenchmark($composerCurryedAdd, [10], 14); \n// mean: 3.555 seconds \n// std:  0.018 seconds \n```", "```php\n<?php \n\nclass Integer { \n    private $value; \n    public function __construct($v) { $this->value = $v; } \n    public function get() { return $this->value; } \n} \n\nclass Adder { \n    public function add(Integer $a, Integer $b) { \n        return $a->get() + $b->get(); \n    } \n} \n```", "```php\n<?php \n\nbenchmark([new Adder, 'add'], [new Integer(21), new Integer(33)], 54); \n// mean: 0.767 seconds \n// std:  0.019 seconds \n```", "```php\n<?php \n\nfunction long_computation($n) \n{ \n    static $cache = []; \n    $key = md5(serialize($n)); \n\n    if(! isset($cache[$key])) { \n        // your computation comes here, the rest is boilerplate \n        sleep(2); \n        $cache[$key] = $n; \n    } \n\n    return $cache[$key]; \n} \n```", "```php\n<?php \n\nclass Folder extends Thread { \n    private $collection; \n    private $callable; \n    private $initial; \n\n    private $results; \n\n    private function __construct($callable, $collection, $initial) \n    { \n        $this->callable = $callable; \n        $this->collection = $collection; \n        $this->initial = $initial; \n    } \n\n    public function run() \n    { \n        $this->results = array_reduce($this->collection, $this- >callable, $this->initial); \n    } \n\n    public static function fold($callable, array $collection,  $initial, $threads=4) \n    { \n        $chunks = array_chunk($collection, ceil(count($collection) / $threads)); \n\n        $threads = array_map(function($i) use ($chunks, $callable,  $initial) { \n            $t = new static($callable, $chunks[$i], $initial); \n            $t->start(); \n            return $t; \n        }, range(0, $threads - 1)); \n\n        $results = array_map(function(Thread $t) { \n            $t->join(); \n            return $t->results; \n        }, $threads); \n\n        return array_reduce($results, $callable, $initial); \n    } \n} \n```", "```php\n<?php \n\n$add = function($a, $b) { \n    return $a + $b; \n}; \n\n$collection = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; \n\necho Folder::fold($add, $collection, 0); \n// 55 \n```", "```php\n**composer require functional-php/parallel**\n\n```", "```php\n**composer require php-amqplib/php-amqplib**\n\n```", "```php\n<?php \n\nrequire_once './vendor/autoload.php'; \nuse PhpAmqpLib\\Connection\\AMQPStreamConnection; \n\n$connection = new AMQPStreamConnection('localhost', 5672, 'guest',  'guest'); \n$channel = $connection->channel(); \nlist($queue, ,) = $channel->queue_declare($queue_name, false,  false, false, false); \n\n$fold_function = function($a, $b) { \n    return $a + $b; \n}; \n```", "```php\n<?php \nuse PhpAmqpLib\\Message\\AMQPMessage; \n\n$queue_name = 'fold_queue'; \nrequire_once('09-rabbitmq.php'); \n\nfunction callback($r) { \n    global $fold_function; \n\n    $data = unserialize($r->body); \n\n    $result = array_reduce($data['collection'], $fold_function,  $data['initial']); \n\n    $msg = new AMQPMessage(serialize($result)); \n\n    $r->delivery_info['channel']->basic_publish($msg, '', $r- >get('reply_to')); \n    $r->delivery_info['channel']->basic_ack($r- >delivery_info['delivery_tag']); \n}; \n\n$channel->basic_qos(null, 1, null); \n$channel->basic_consume('fold_queue', '', false, false, false,  false, 'callback'); \n\nwhile(count($channel->callbacks)) { \n    $channel->wait(); \n} \n\n$channel->close(); \n$connection->close(); \n```", "```php\n<?php \nuse PhpAmqpLib\\Message\\AMQPMessage; \n\n$queue_name = ''; \nrequire_once('09-rabbitmq.php'); \n\nfunction send($channel, $queue, $chunk, $initial) \n{ \n    $data = [ \n        'collection' => $chunk, \n        'initial' => $initial \n    ]; \n    $msg = new AMQPMessage(serialize($data), array('reply_to' =>  $queue)); \n    $channel->basic_publish($msg, '', 'fold_queue'); \n} \n\nclass Results { \n    private $results = []; \n    private $channel; \n\n    public function register($channel, $queue) \n    { \n        $this->channel = $channel; \n        $channel->basic_consume($queue, '', false, false, false,  false, [$this, 'process']); \n    } \n\n    public function process($rep) \n    { \n        $this->results[] = unserialize($rep->body); \n    } \n\n    public function get($expected) \n    { \n        while(count($this->results) < $expected) { \n            $this->channel->wait(); \n        } \n\n        return $this->results; \n    } \n} \n\n$results = new Results(); \n$results->register($channel, $queue); \n\n$initial = 0; \n\nsend($channel, $queue, [1, 2, 3], 0); \nsend($channel, $queue, [4, 5, 6], 0); \nsend($channel, $queue, [7, 8, 9], 0); \nsend($channel, $queue, [10], 0); \n\necho array_reduce($results->get(4), $fold_function, $initial); \n// 55 \n```", "```php\n**composer require kzykhys/parallel**\n\n```"]