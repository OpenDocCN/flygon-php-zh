- en: Boosting a Web Server's Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升Web服务器性能
- en: Amongst the main points that Google had identified as being the first order
    of business of its Faster Web initiative was to update the aging web protocols.
    Many projects around the world were already underway as the new focus of web development
    was shifting from offering more and more features to users, even if these were
    slow, to offering features that were not incompatible with web performance. Google's
    initiative helped to change web development priorities and, thus, allowed existing
    projects to come to light and new projects to be created.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌确定其更快Web计划的首要任务之一是更新老化的Web协议。全球范围内已经有许多项目正在进行，因为Web开发的新重点正在从为用户提供更多功能（即使这些功能很慢）转向提供与Web性能不相冲突的功能。谷歌的倡议有助于改变Web开发的优先事项，从而使现有项目得以光明，新项目得以创建。
- en: 'In this chapter, we will cover a few projects that went along with Google''s
    new initiative for the web. Thus, we will cover the following points:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些与谷歌新的Web倡议一起进行的项目。因此，我们将涵盖以下几点：
- en: MOD_SPDY and HTTP/2
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MOD_SPDY和HTTP/2
- en: PHP-FPM and OPCache
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP-FPM和OPCache
- en: ESI and Varnish Cache
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ESI和Varnish Cache
- en: Client-side caching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端缓存
- en: Other Faster Web tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他更快Web工具
- en: MOD_SPDY and HTTP/2
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MOD_SPDY和HTTP/2
- en: In 2009, Google announced it would start to find ways to update the HTTP protocol
    by making use of a new session protocol named SPDY (`SPeeDY`). This new session
    protocol worked over an underlying TLS presentation layer and allowed for many
    HTTP speed optimizations at the application layer. Using SPDY was as easy as activating
    SSL, installing the `mod_spdy` module on your web server and activating it. No
    modifications to the websites were needed in order to benefit from its features.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 2009年，谷歌宣布将寻找更新HTTP协议的方法，通过使用名为SPDY（`SPeeDY`）的新会话协议。这个新的会话协议在底层TLS表示层上工作，并允许在应用层进行许多HTTP速度优化。使用SPDY就像激活SSL一样简单，在Web服务器上安装`mod_spdy`模块并激活它。为了从其功能中受益，不需要对网站进行任何修改。
- en: Moreover, all major browsers were supporting it. SPDY rapidly became a core
    element of the Faster Web and became, in November 2012, the basis of the next
    major revision of the HTTP protocol. Then, in 2015, it was deprecated in favor
    of the new HTTP/2 protocol. The most important optimizations that were introduced
    by SPDY and that would find their way into the new HTTP protocol's specifications
    were multiplexed and prioritized streams, server pushing and header compression.
    Let's have a look at each one of these optimizations in more detail before we
    get into some of the specifics of the HTTP/2 protocol.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有主要浏览器都支持它。SPDY迅速成为更快Web的核心元素，并在2012年11月成为下一次重大HTTP协议修订的基础。然后，在2015年，它被弃用，改为使用新的HTTP/2协议。SPDY引入的最重要的优化措施，并将其纳入新的HTTP协议规范的是多路复用和优先级流、服务器推送和头部压缩。在我们深入了解HTTP/2协议的一些具体内容之前，让我们更详细地看看这些优化措施中的每一个。
- en: Multiplexed and prioritized streams
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多路复用和优先级流
- en: 'SPDY''s multiplexed streams feature allowed for mapping multiple requests to
    multiple streams on a single connection. These streams were bidirectional and
    could be initiated by either the client or the server (the server push feature).
    Opening multiple streams over one single connection made it possible to avoid
    the overhead of establishing a new connection on each client/server exchange,
    especially when downloading multiple resources in parallel to complete the rendering
    of a single page. Thus, this first feature made it possible to get rid of the
    limited number of possible connections when using the HTTP/1 protocol:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SPDY的多路复用流功能允许将多个请求映射到单个连接上的多个流。这些流是双向的，可以由客户端或服务器（服务器推送功能）发起。在单个连接上打开多个流可以避免在每个客户端/服务器交换时建立新连接的开销，特别是在并行下载多个资源以完成单个页面的渲染时。因此，这个第一个功能使得在使用HTTP/1协议时摆脱了可能的连接数量限制：
- en: '![](assets/4607e136-5765-4972-8a01-6e09b4e07bb2.png)How multiplexed and prioritized
    streams work'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/4607e136-5765-4972-8a01-6e09b4e07bb2.png)多路复用和优先级流的工作原理'
- en: Moreover, SPDY's streams were prioritized. This additional feature allowed the
    client to determine which resources should be sent over the wire first. Thus,
    SPDY avoided the **first-in, first-out **(**FIFO**) issue that arose when trying
    to do server pipelining (that is, the `KeepAlive` directive) within the HTTP/1
    protocol.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，SPDY的流是有优先级的。这个额外的功能允许客户端确定哪些资源应该首先发送到网络上。因此，SPDY避免了在HTTP/1协议中进行服务器管线化（即`KeepAlive`指令）时出现的**先进先出**（FIFO）问题。
- en: Server pushing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器推送
- en: 'As already mentioned, SPDY''s new stream features made it possible for the
    server to push data to the client without responding to a client''s request. This
    made communication bidirectional and allowed the web server to anticipate the
    needs of the client. Indeed, even before the client had done parsing the HTML
    and determined all the files that would be necessary in order to render the page,
    the web server could push the files down the stream to the client, thus reducing
    the number of requests sent by the client in order to fetch all the necessary
    resources:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如已经提到的，SPDY的新流特性使得服务器能够在不响应客户端请求的情况下向客户端推送数据。这使得通信变得双向，并允许Web服务器预测客户端的需求。事实上，甚至在客户端解析HTML并确定渲染页面所需的所有文件之前，Web服务器就可以将文件推送到客户端，从而减少客户端发送请求以获取所有必要资源的次数：
- en: '![](assets/a80f24cc-3844-42b5-aaba-961cbf9953c2.jpg)How the ''server push''
    feature works'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a80f24cc-3844-42b5-aaba-961cbf9953c2.jpg)“服务器推送”功能的工作原理'
- en: By knowing that many studies show that, on average, most pages need from 70
    to 100 requests against 20 to 30 domains in order to complete their rendering,
    we can easily see how this feature can make the web less verbose and reduce network
    latency in a significant way.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解许多研究显示，平均而言，大多数页面需要70到100个请求，涉及20到30个域名，才能完成其渲染，我们可以很容易地看出这个功能如何使Web变得更简洁，并显著减少网络延迟。
- en: Header compression
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头部压缩
- en: SPDY's third important feature was header compression with `gzip`. By compressing
    the often high number of HTTP headers and reducing them by as much as 85% of their
    original sizes on average, SPDY could cut up to a full second off the load time
    of most HTTP transactions over the wire. Although the use of `gzip` to dynamically
    compress the headers was revealed to be unsafe, the idea of header compression
    remained and was re-implemented in the HTTP/2 protocol due to its great benefits
    to overall web performance.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: SPDY的第三个重要特性是使用`gzip`进行标头压缩。通过压缩通常较多的HTTP标头，并将其平均减少85%的原始大小，SPDY可以在网络上将大多数HTTP事务的加载时间缩短整整一秒。尽管使用`gzip`动态压缩标头被发现是不安全的，但标头压缩的概念仍然存在，并且由于对整体网络性能的巨大益处，它在HTTP/2协议中得到了重新实现。
- en: HTTP/2
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP/2
- en: Published in May 2015 as RFC 7540 [1], HTTP/2 is the latest major revision of
    the HTTP protocol. It is mostly based on Google's SPDY protocol and offers a new
    binary framing layer that is not backward-compatible with HTTP/1\. As mentioned
    previously, most of its features were developed through the SPDY project. The
    most notable difference between SPDY and HTTP/2 was the way that the new protocol
    compressed its headers. Whereas SPDY relied on dynamically compressing headers
    with `gzip`, the HTTP/2 protocol used a new method named `HPACK`, which made use
    of a fixed Huffman code-based algorithm. This new method was needed in order to
    avoid a problem that was found with SPDY, by which data compression led to the
    possible leakage of private data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为RFC 7540 [1]于2015年5月发布的HTTP/2是HTTP协议的最新主要修订版。它主要基于Google的SPDY协议，并提供了一个新的二进制帧层，与HTTP/1不兼容。正如之前提到的，它的大部分功能是通过SPDY项目开发的。SPDY和HTTP/2之间最显著的区别是新协议压缩其标头的方式。而SPDY依赖于使用`gzip`动态压缩标头，HTTP/2协议使用了一种名为`HPACK`的新方法，该方法利用了固定的Huffman编码算法。为了避免SPDY发现的数据压缩导致可能泄露私人数据的问题，需要这种新方法。
- en: Even though the new protocol reduced the loading time of most web pages by as
    much as two times, many critics voiced their disappointment by pointing out that
    the unrealistic deadlines imposed by Google on the project of updating the HTTP
    protocol made it impossible to base the new version of the protocol on anything
    else but its SPDY project and, thus, causing many missed occasions for further
    improvement of the new HTTP protocol. *Poul-Henning Kamp*, developer of *Varnish
    Cache*, even went on to say that HTTP/2 was inconsistent and that it was overly
    and needlessly complex. Moreover, he stated that it had violated the principle
    of protocol layering by duplicating flow control that should normally take place
    at the transport layer [2]. Finally, many security flaws were found in this new
    protocol, the most notable ones being those unveiled by the cybersecurity firm
    Imperva at the Black Hat USA 2016 conference [3]. These were the slow read attack,
    the dependency cycle attack, the stream multiplexing abuse and the HPACK Bomb.
    Essentially, all these attack vectors could be used to bring a server offline
    by submitting it to a **Denial of Service** (**DoS**) attack or by saturating
    its memory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管新协议将大多数网页的加载时间缩短了一倍，许多批评者对此表示失望，指出谷歌对更新HTTP协议项目施加的不切实际的最后期限使得新协议版本不可能基于其他任何东西而不是其SPDY项目，并因此错失了进一步改进新HTTP协议的许多机会。*Poul-Henning
    Kamp*，*Varnish Cache*的开发者，甚至表示HTTP/2是不一致的，过于复杂且不必要。此外，他指出它违反了协议分层的原则，通过复制应该在传输层正常进行的流量控制 [2]。最后，在这个新协议中发现了许多安全漏洞，其中最显著的是由网络安全公司Imperva在2016年Black
    Hat USA会议上披露的那些 [3]。这些漏洞包括慢速读取攻击、依赖循环攻击、流复用滥用和HPACK炸弹。基本上，所有这些攻击向量都可以用来通过提交**拒绝服务**（**DoS**）攻击或通过饱和其内存来使服务器下线。
- en: 'Despite all of this and the many issues related to encryption, all major web
    servers and browsers have adopted it and now offer support for it. Most of the
    time, if your web server was configured and compiled with the HTTP/2 flag, you
    only need to activate the module in the server’s `/etc/httpd/httpd.conf` file
    to start using it. In the case of the Apache Web server, you must also add the
    `Protocols` directive to the server''s configuration files. Please be aware that
    activating the HTTP/2 protocol on your server will have a considerable impact
    on resource consumption. For example, enabling such a feature on the Apache web
    server will result in the creation of many threads, as the server will serve HTTP/2
    requests by creating dedicated workers in order to process and stream the results
    back to the clients. Here is an example of how you can enable the HTTP/2 module
    in Apache''s `httpd.conf` and `httpd-ssl.conf` configuration files (presuming
    that the `mod_ssl` module has been enabled also):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在许多与加密相关的问题，但所有主要的网络服务器和浏览器都已经采用并提供了对其的支持。大多数情况下，如果您的网络服务器已经配置并编译了HTTP/2标志，您只需要在服务器的`/etc/httpd/httpd.conf`文件中激活模块即可开始使用它。在Apache
    Web服务器的情况下，您还必须在服务器的配置文件中添加`Protocols`指令。请注意，在服务器上激活HTTP/2协议将对资源消耗产生重大影响。例如，在Apache
    Web服务器上启用此功能将导致创建许多线程，因为服务器将通过创建专用工作程序来处理和流式传输结果以响应客户端的HTTP/2请求。以下是如何在Apache的`httpd.conf`和`httpd-ssl.conf`配置文件中启用HTTP/2模块的示例（假设`mod_ssl`模块也已启用）：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For more information on the HTTP/2 protocol, please visit the following address:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有关HTTP/2协议的更多信息，请访问以下网址：
- en: '[https://developers.google.com/web/fundamentals/performance/http2/](https://developers.google.com/web/fundamentals/performance/http2/)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/web/fundamentals/performance/http2/](https://developers.google.com/web/fundamentals/performance/http2/)'
- en: 'To learn more on Apache''s implementation of the same protocol, please visit
    these links:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Apache对相同协议的实现更多信息，请访问以下链接：
- en: '[https://httpd.apache.org/docs/2.4/howto/http2.html](https://httpd.apache.org/docs/2.4/howto/http2.html)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://httpd.apache.org/docs/2.4/howto/http2.html](https://httpd.apache.org/docs/2.4/howto/http2.html)'
- en: '[https://httpd.apache.org/docs/2.4/mod/mod_http2.html](https://httpd.apache.org/docs/2.4/mod/mod_http2.html)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://httpd.apache.org/docs/2.4/mod/mod_http2.html](https://httpd.apache.org/docs/2.4/mod/mod_http2.html)'
- en: 'And, finally, to know more about the implementation provided by NGINX, please
    consult their documentation:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要了解NGINX提供的实现更多信息，请参阅他们的文档：
- en: '[http://nginx.org/en/docs/http/ngx_http_v2_module.html](http://nginx.org/en/docs/http/ngx_http_v2_module.html)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://nginx.org/en/docs/http/ngx_http_v2_module.html](http://nginx.org/en/docs/http/ngx_http_v2_module.html)'
- en: PHP-FPM and OPCache
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP-FPM 和 OPCache
- en: When talking about the Faster Web, it is certainly important to consider how
    to make sure that the PHP binary itself is being run in an optimized way on web
    servers, considering that PHP is installed on seventy to eighty percent of servers
    around the world.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到更快的Web时，考虑如何确保PHP二进制本身在Web服务器上以优化的方式运行是非常重要的，考虑到PHP安装在全球70%至80%的服务器上。
- en: PHP-FPM
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP-FPM
- en: Since PHP 5.3, PHP now includes a FastCGI process manager that allows you to
    run much more secure, much faster and more reliable PHP code on web servers. Before
    PHP-FPM, the default way to run PHP code on a web server was usually through the
    `mod_php` module. What makes PHP-FPM so interesting is the possibility for it
    to adapt itself to the number of incoming requests and spawn new processes in
    a pool of workers in order to scale to the growing demand. Moreover, running PHP
    this way allows for better script termination, more graceful server restarts,
    more advanced error reporting and server logging, and fine-grained tuning of the
    PHP environment for each and every PHP pool of workers through the daemonization
    of the PHP binary.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 自PHP 5.3以来，PHP现在包括一个FastCGI进程管理器，允许您在Web服务器上运行更安全、更快速和更可靠的PHP代码。在PHP-FPM之前，在Web服务器上运行PHP代码的默认方式通常是通过`mod_php`模块。PHP-FPM如此有趣的原因在于它可以根据传入请求的数量自适应，并在工作池中生成新进程，以满足不断增长的需求。此外，以这种方式运行PHP允许更好的脚本终止、更优雅的服务器重启、更高级的错误报告和服务器日志记录，以及通过守护进程化PHP二进制对每个PHP工作池进行PHP环境的精细调整。
- en: It has been reported by many high-traffic websites that they have seen speed
    performance hikes of the order of 300% when changing from `mod_php` to `PHP-FPM`
    on their production servers. Of course, as Ilia Alshanetsky mentioned in one of
    his presentations[4], when serving static content, many other servers, like lighttpd,
    thttpd, Tux or Boa, can be as much as 400% faster than Apache. But, when it comes
    to dynamic content, no servers can be faster than Apache or NGINX, especially
    when they work in combination with PHP-FPM.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 许多高流量网站报告称，他们在将生产服务器上的 `mod_php` 更改为 `PHP-FPM` 后，看到了高达300%的速度提升。当然，正如Ilia Alshanetsky在他的一个演示中提到的那样[4]，在提供静态内容时，像lighttpd、thttpd、Tux或Boa这样的许多其他服务器，可能比Apache快400%。但是，当涉及到动态内容时，没有任何服务器可以比Apache或NGINX更快，特别是当它们与PHP-FPM结合使用时。
- en: Enabling PHP-FPM on a server is as easy as configuring PHP with the `--enable-fpm`
    switch at compile time. From there, it is a question of determining how to run
    PHP-FPM, depending of performance and security issues. For example, if you are
    in a production environment, you might decide to run PHP-FPM with many pools of
    workers on many servers in order to distribute the workload. Moreover, you might
    prefer running PHP-FPM through a UNIX socket on the server rather than on the
    network loopback (`127.0.0.1`) for performance and security reasons. Indeed, a
    UNIX socket is always faster in any scenario and will offer better security against
    a local network attacker, that could always try to compromise the loopback with
    a socket listener using domain autorizations, by enforcing appropriate access
    controls to ensure connection confidentiality.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上启用PHP-FPM就像在编译时使用 `--enable-fpm` 开关配置PHP一样简单。从那里开始，问题就是确定如何运行PHP-FPM，这取决于性能和安全问题。例如，如果您在生产环境中，您可能决定在许多服务器上运行许多工作池的PHP-FPM，以分发工作负载。此外，出于性能和安全原因，您可能更喜欢在服务器上通过UNIX套接字而不是网络环回(`127.0.0.1`)运行PHP-FPM。事实上，在任何情况下，UNIX套接字都更快，并且将提供更好的安全性，以防止本地网络攻击者，可能始终尝试使用域授权通过强制适当的访问控制来破坏环回的套接字监听器以确保连接机密性。
- en: Zend OPcache
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zend OPcache
- en: Since PHP 5.5, opcode caching is now available in PHP's core functionality when
    adding the `--enable-opcache` switch to the configure script at compile time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 自PHP 5.5以来，当在编译时向配置脚本添加 `--enable-opcache` 开关时，opcode缓存现在可以在PHP的核心功能中使用。
- en: Generally speaking, Zend OPcache will make any script from 8% to 80% faster.
    The more time a script's wall time is caused by the PHP binary, the more OPcache
    will make a difference. But, if the script's PHP code is very basic or if PHP
    is slowed down by latency due to I/O, such as a stream to a file or a connection
    to a database, OPcache will only slightly enhance script performance.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，Zend OPcache将使任何脚本的运行速度提高8%至80%。脚本的墙时间由PHP二进制引起的时间越长，OPcache的差异就越大。但是，如果脚本的PHP代码非常基本，或者如果PHP由于I/O引起的延迟而减慢，例如对文件的流或对数据库的连接，OPcache只会轻微提高脚本性能。
- en: In all cases, Zend OPcache will optimize PHP script performance and should be
    enabled on all production servers by default.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，Zend OPcache将优化PHP脚本性能，并应默认在所有生产服务器上启用。
- en: Let's have a look at how we could configure the PHP-FPM server included with
    the Linux for the PHP container that is running PHP 7.1.16 (NTS) to use a UNIX
    socket, instead of the network loopback, to establish a connection between Apache
    and PHP. Moreover, let's configure PHP-FPM to use Zend OPcache.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何配置运行PHP 7.1.16 (NTS) 的Linux中包含的PHP-FPM服务器，以使用UNIX套接字而不是网络环回来建立Apache和PHP之间的连接。此外，让我们配置PHP-FPM以使用Zend
    OPcache。
- en: 'Please make sure your container is still running and enter the following commands
    on its CLI:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您的容器仍在运行，并在其CLI上输入以下命令：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can now have a look at the modified `php.ini` file with the *vi* editor
    in order to make sure that the previous settings are no longer commented out and
    that the new `[OPcache]` section has been added to the file. Then, in your favorite
    browser, you should now see the following screen when visiting `http://localhost:8181/phpinfo.php`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用*vi*编辑器查看修改后的`php.ini`文件，以确保以前的设置不再被注释掉，并且新的`[OPcache]`部分已添加到文件中。然后，在您喜欢的浏览器中，当访问`http://localhost:8181/phpinfo.php`时，您应该会看到以下屏幕：
- en: '![](assets/4d7f8662-abf5-403b-8bfa-21105a6039a1.png)Confirmation that Zend
    Opcache is enabled and running'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/4d7f8662-abf5-403b-8bfa-21105a6039a1.png)确认Zend Opcache已启用并正在运行'
- en: If you do see the previous screen, you have successfully connected the *Apache*
    server to PHP-FPM through a UNIX socket and enabled *Zend OPcache*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到上一个屏幕，那么您已成功将*Apache*服务器通过UNIX套接字连接到PHP-FPM，并启用了*Zend OPcache*。
- en: 'If you wish to test compiling PHP from scratch with the FPM and *OPCache* configuration
    switches within a *Linux for PHP* base image (`asclinux/linuxforphp-8.1:src`),
    please enter the following command in a new Terminal window:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在*Linux for PHP*基础镜像（`asclinux/linuxforphp-8.1:src`）中使用FPM和*OPCache*配置开关从头开始编译PHP，请在新的终端窗口中输入以下命令：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you wish to accomplish the same thing manually, please visit the *Linux for
    PHP* website for further instructions ([https://linuxforphp.net/cookbook/production](https://linuxforphp.net/cookbook/production)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望手动完成相同的操作，请访问*Linux for PHP*网站以获取进一步的说明（[https://linuxforphp.net/cookbook/production](https://linuxforphp.net/cookbook/production)）。
- en: ESI and Varnish Cache
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ESI和Varnish缓存
- en: Another Faster Web technology is that of the **Edge Side Includes** (**ESI**)
    markup language and HTTP cache servers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更快的Web技术是**边缘包含**（**ESI**）标记语言和HTTP缓存服务器。
- en: Edge Side Includes (ESI)
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘包含（ESI）
- en: Originally formalized as a specification to be approved by the **World Wide
    Web Consortium** (**W3C**) back in 2001, ESI was thought to be a way of stepping
    up to the challenge of web infrastructure scaling by applying edge computing to
    it. Edge computing is a method of optimizing cloud computing by doing data processing
    near the source of the data instead of centralizing all data processing in the
    datacenter. In the case of ESI, the idea was to decentralize web page content
    to the logical extremes of the network in order to avoid having all content requests
    being sent to the web server every time.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最初作为**万维网联盟**（**W3C**）于2001年批准的规范，ESI被认为是通过将边缘计算应用于Web基础设施扩展的一种方式。边缘计算是一种通过在数据源附近进行数据处理来优化云计算的方法，而不是将所有数据处理集中在数据中心。在ESI的情况下，想法是将Web页面内容分散到网络的逻辑极端，以避免每次都将所有内容请求发送到Web服务器。
- en: The specification called for new HTML tags that would allow HTTP cache servers
    to determine if certain parts of a page needed to be fetched from the original
    web server or if cached versions of those parts could be sent back to the client
    without having to query the server for it. It is possible to think of ESI as a
    sort of HTML include feature that is used to assemble a web page's dynamic content
    from different external sources.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 规范要求新的HTML标记，这些标记将允许HTTP缓存服务器确定页面的某些部分是否需要从原始Web服务器获取，或者这些部分的缓存版本是否可以发送回客户端，而无需查询服务器。可以将ESI视为一种HTML包含功能，用于从不同的外部来源组装网页的动态内容。
- en: Many HTTP cache servers started using the new markup tags. Some **Content Delivery
    Networks** (**CDN**), such as Akamai, and many HTTP Proxy Servers, such as Varnish,
    Squid and Mongrel ESI, started implementing the specification over the years,
    although most did not implement the entire specification. Also, some of these
    servers, such as Akamai, added additional features that were not in the original
    specification.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 许多HTTP缓存服务器开始使用新的标记语言。一些**内容交付网络**（**CDN**），如Akamai，以及许多HTTP代理服务器，如Varnish、Squid和Mongrel
    ESI，多年来开始实施该规范，尽管大多数并未实施整个规范。此外，一些服务器，如Akamai，添加了原始规范中没有的其他功能。
- en: Moreover, important PHP frameworks, such as *Symfony*, started adding ESI functionality
    within their core configurations, thus allowing the PHP developer to immediately
    start thinking of ESI when developing an application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重要的PHP框架，如*Symfony*，开始在其核心配置中添加ESI功能，从而使PHP开发人员在开发应用程序时立即开始考虑ESI。
- en: Also, browsers started encouraging ESI usage by keeping a local cache of all
    files that were fetched on the web and reusing them when a different website requested
    the same file, for example. Thus, using a CDN-hosted JavaScript file on your website
    brought the advantage of reducing the number of client requests to one's web server
    just to get that same file over and over again.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，浏览器开始鼓励ESI的使用，通过在Web上保留所有获取的文件的本地缓存，并在其他网站请求相同文件时重复使用它们。因此，在您的网站上使用CDN托管的JavaScript文件可以减少客户端请求您的Web服务器的次数，只需一次获取相同的文件。
- en: 'It is very easy to start using `esi:include` tags within your HTML in order
    to cache parts of your web pages. For example, you could use it in this way:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`esi:include`标记在HTML中开始缓存网页的部分非常容易。例如，您可以这样使用：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Another example would be to use PHP and the *Symfony* framework to automatically
    generate the ESI include tags. This is easily accomplished by having *Symfony*
    trust the *Varnish Cache* server, enabling ESI in your YAML configuration file,
    setting the shared maximum age limit of the web page within its controller's method
    and adding the needed rendering helper methods within the corresponding templates.
    Let's go through these steps one at a time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是使用PHP和*Symfony*框架自动生成ESI包含标记。这可以通过让*Symfony*信任*Varnish Cache*服务器，在YAML配置文件中启用ESI，在其控制器方法中设置网页的共享最大年龄限制，并在相应的模板中添加所需的渲染辅助方法来轻松实现。让我们一步一步地进行这些步骤。
- en: 'Start by having *Symfony* trust the *Varnish Cache* server. In the most recent
    version of *Symfony*, you must add a call to the static `setTrustedProxies()`
    method of the `Request` class. In the `public/index.php` file of your *Symfony*
    installation, add the following lines:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让*Symfony*信任*Varnish Cache*服务器。在*Symfony*的最新版本中，您必须调用`Request`类的静态`setTrustedProxies()`方法。在*Symfony*安装的`public/index.php`文件中，添加以下行：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Depending on the version of *Symfony* and the version of *Varnish* that you
    are using, you might have different steps to follow in order to do so. Please
    consult the following page of the *Symfony* documentation in order to complete
    this first step: [https://symfony.com/doc/current/http_cache/varnish.html](https://symfony.com/doc/current/http_cache/varnish.html).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您使用的*Symfony*版本和*Varnish*版本，您可能需要遵循不同的步骤才能完成此操作。请参阅*Symfony*文档的以下页面以完成此第一步：[https://symfony.com/doc/current/http_cache/varnish.html](https://symfony.com/doc/current/http_cache/varnish.html)。
- en: 'Then, add the following lines to your *Symfony* configuration file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下行添加到您的*Symfony*配置文件中：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once done, modify a couple of controllers like so:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，修改一些控制器如下：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And, the second one should be modified as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个应该修改如下：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, perform the following modifications within your Twig template:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在您的Twig模板中执行以下修改：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You should now be able to see the effects of ESI when loading the pages of your
    *Symfony* application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够在加载*Symfony*应用程序的页面时看到ESI的效果。
- en: In order to get a better grasp of the inner workings of ESI, let's try installing
    and running an HTTP reverse proxy server that partially implements the ESI specification.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解ESI的内部工作原理，让我们尝试安装和运行部分实现ESI规范的HTTP反向代理服务器。
- en: Varnish Cache
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Varnish Cache
- en: One of the HTTP Reverse Proxy Servers that partially implements ESI is *Varnish
    Cache*. This HTTP Cache Server was originally thought out by its creators, *Poul-Henning
    Kamp*, *Anders Berg* and *Dag-Erling Smørgrav*, as being a highly needed [5] replacement
    for *Squid*, a well-known HTTP forward proxy server (client proxy). It was possible
    to make *Squid* work as a Reverse Proxy (server proxy), but it was very difficult
    to set it up to act in this way.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 部分实现ESI的HTTP反向代理服务器之一是*Varnish Cache*。这个HTTP缓存服务器最初是由其创始人*Poul-Henning Kamp*、*Anders
    Berg*和*Dag-Erling Smørgrav*构思的，作为* Squid *的一个非常需要的[5]替代品，* Squid *是一个著名的HTTP转发代理服务器（客户端代理）。*Squid*可以作为反向代理（服务器代理）工作，但很难设置它以这种方式工作。
- en: The original meeting that led to the creation of *Varnish Cache* took place
    in Oslo in February of 2006\. The basic concept behind the project was to find
    a way to quickly manipulate bytes that would be taken from passing network traffic
    and a way to determine what, where and when to cache those bytes. Many years later,
    *Varnish Cache* has become one of the most important HTTP cache servers on the
    web with almost three million websites using it in production [6].
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 导致创建*Varnish Cache*的原始会议于2006年2月在奥斯陆举行。该项目背后的基本概念是找到一种快速操纵从通过网络流量获取的字节的方法，以及确定何时何地以及何时缓存这些字节。多年后，*Varnish
    Cache*已成为Web上最重要的HTTP缓存服务器之一，几乎有三百万个网站在生产中使用它[6]。
- en: In order to better understand how *Varnish Cache* works, let's take the time
    to install it inside a Linux for the PHP base container.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解*Varnish Cache*的工作原理，让我们花点时间在Linux for the PHP基础容器中安装它。
- en: 'In a new Terminal window, please enter this Docker command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的终端窗口中，请输入以下Docker命令：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, enter these commands:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输入以下命令：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should now see the following messages on the CLI:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该在CLI上看到以下消息：
- en: '![](assets/b7dd6cc4-a249-4d3e-aa18-52ff033a7293.png)Confirmation that the requested
    Python modules have been installed'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](assets/b7dd6cc4-a249-4d3e-aa18-52ff033a7293.png)确认所请求的Python模块已安装
- en: 'Then, enter these commands:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输入以下命令：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once done, you should see a screen similar to this one:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您应该看到类似于这样的屏幕：
- en: '![](assets/93630a61-7072-4df1-865e-0fd84744a58c.png)The download of the archive
    containing the source code of Varnish Cache is completed'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](assets/93630a61-7072-4df1-865e-0fd84744a58c.png)下载包含Varnish Cache源代码的存档已完成
- en: 'Finally, please finish the installation by unpacking, configuring and installing
    *Varnish Cache* with the following commands:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请通过以下命令完成安装解压缩、配置和安装*Varnish Cache*：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once completed, you should receive the following message:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您应该收到以下消息：
- en: '![](assets/3a80a169-63f6-4e67-80d5-b349edbecf52.png)The Varnish Cache daemon
    is now running and waiting for connections'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](assets/3a80a169-63f6-4e67-80d5-b349edbecf52.png)Varnish Cache守护程序现在正在运行并等待连接
- en: 'As we mentioned in [Chapter 2](70f061eb-c289-43a1-9945-af4d22d48463.xhtml),
    *Continuous Profiling and Monitoring*, of this book when we were installing the
    *TICK* stack through *Docker* containers, you can get the IP addresses of the
    two containers (the one running the *Apache* server and this new one that is running
    the *Varnish* server), by issuing this command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书的[第2章](70f061eb-c289-43a1-9945-af4d22d48463.xhtml)“持续分析和监控”中提到的，当我们通过*Docker*容器安装*TICK*堆栈时，您可以通过发出此命令来获取两个容器（运行*Apache*服务器和运行*Varnish*服务器的新容器）的IP地址：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once you get the results, you can replace the [IP_ADDRESS_OR_DOMAIN_NAME_OF_WEB_SERVER]
    placeholder in the previous command with the IP address of the container running
    *Apache* (the *Linux for PHP* container). In my case, the IP address of the *Apache*
    Web server is `172.17.0.2` and the IP address of the *Varnish Cache* server is
    `172.17.0.3`. The command would therefore be:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 获得结果后，您可以将前一个命令中的[IP_ADDRESS_OR_DOMAIN_NAME_OF_WEB_SERVER]占位符替换为运行*Apache*（*Linux
    for PHP*容器）的容器的IP地址。在我的情况下，*Apache* Web服务器的IP地址是`172.17.0.2`，*Varnish Cache*服务器的IP地址是`172.17.0.3`。因此，命令将是：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once started, you can point a browser to the IP address of the *Varnish Cache*
    server and you should get the *Apache* Web server''s content. In my case, when
    pointing my browser to `172.17.0.3`, I obtain the expected result:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，您可以将浏览器指向*Varnish Cache*服务器的IP地址，您应该会得到*Apache* Web服务器的内容。在我的情况下，当我将浏览器指向`172.17.0.3`时，我得到了预期的结果：
- en: '![](assets/6b5f3e6e-eddb-4ccd-b8b4-6ad94f1877cd.png)Varnish is caching and
    returning the response obtained from the Apache server'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6b5f3e6e-eddb-4ccd-b8b4-6ad94f1877cd.png)Varnish正在缓存并返回从Apache服务器获取的响应'
- en: 'We can confirm that the *Varnish Cache* server is using our *Apache* Web server
    as its backend by issuing the following `curl` command in a new Terminal window
    and piping the results to `grep` in order to see the request and response headers:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在新的终端窗口中发出以下`curl`命令并将结果传输到`grep`来确认*Varnish Cache*服务器是否正在使用我们的*Apache*
    Web服务器作为其后端，以查看请求和响应头：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The result should be similar to the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该类似于以下截图：
- en: '![](assets/7049f671-29b2-466a-86bc-ec3ee7bc900b.png)The Varnish Cache headers
    are added to the Apache headers'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/7049f671-29b2-466a-86bc-ec3ee7bc900b.png)Varnish Cache头部被添加到Apache头部中'
- en: As we can see, the headers show that the *Apache* server is responding via the
    *Varnish Cache* server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，头部显示*Apache*服务器正在通过*Varnish Cache*服务器响应。
- en: Thus, with proper DNS configuration, it would become possible to redirect all
    the web traffic to the *Varnish Cache* server and use the web server as its backend
    only.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过正确的DNS配置，将所有的网络流量重定向到*Varnish Cache*服务器，并将Web服务器仅用作其后端成为可能。
- en: This example shows us how easy it is to configure a *Varnish Cache* server and
    how simple it is to start using it and benefiting from it right away in order
    to quickly boost web server performance.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向我们展示了配置*Varnish Cache*服务器是多么容易，以及开始使用它并立即从中受益以快速提升Web服务器性能是多么简单。
- en: Client-side caching
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端缓存
- en: 'Let''s continue with another Faster Web technology, which is client-side caching.
    This form of HTTP caching focuses on reducing the number of requests needed to
    render a page in order to avoid network latency as much as possible. Indeed, large
    responses often need many roundtrips over the network. HTTP client-side caching
    tries to minimize the number of these requests in order to complete the page''s
    rendering. Nowadays, all major browsers offer support for these techniques and
    enabling these technologies on your website is as easy as sending a few additional
    headers or using library files that are already available on **Content Delivery
    Networks** (**CDNs**). Let''s have a look at these two techniques: browser caching
    headers and CDNs.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续介绍另一种更快的Web技术，即客户端缓存。这种形式的HTTP缓存专注于减少呈现页面所需的请求次数，以尽量避免网络延迟。事实上，大型响应通常需要在网络上进行多次往返。HTTP客户端缓存试图最小化这些请求的数量，以完成页面的呈现。如今，所有主要浏览器都支持这些技术，并且在您的网站上启用这些技术就像发送一些额外的头部或使用已经在**内容交付网络**（**CDN**）上可用的库文件一样简单。让我们看看这两种技术：浏览器缓存头部和CDN。
- en: Browser caching
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器缓存
- en: Browser caching is based on the idea that it is not necessary to fetch all the
    files included in a response if some of these are exactly the same over a certain
    period of time. The way it works is through headers that are sent by the server
    to the browser in order to instruct it to avoid getting certain pages or files
    within a certain timeframe. Thus, the browser will display content kept within
    its cache rather than fetching the resources over the network within the span
    of that certain period of time, or until the resource changes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器缓存的基本思想是，如果在一定时间内某些文件完全相同，就不必获取响应中包含的所有文件。它的工作方式是通过服务器发送给浏览器的头部，以指示浏览器在一定时间内避免获取某些页面或文件。因此，浏览器将显示保存在其缓存中的内容，而不是在一定时间内通过网络获取资源，或者直到资源发生变化。
- en: Thus, browser caching relies on cache-control evaluation (expiration model)
    and response validation (validation model). Cache-control evaluation is defined
    as a set of directives that inform the browser of who can cache the response,
    under what circumstances and for how long. Response validation relies on a hash
    token in order to determine if the content of a response has changed or not. It
    also makes it possible for the browser to avoid fetching the results again even
    if cache-control indicates that the cached content has expired. In fact, upon
    receiving the response from the server indicating that the content has not been
    modified, based on the fact that the sent token has not changed on the server,
    the browser simply renews the cache-control and resets the time delay before expiration.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，浏览器缓存依赖于缓存控制评估（过期模型）和响应验证（验证模型）。缓存控制评估被定义为一组指令，它们告知浏览器谁可以缓存响应，在什么情况下以及多长时间。响应验证依赖于哈希令牌，以确定响应的内容是否已更改。它还使浏览器能够避免再次获取结果，即使缓存控制指示缓存的内容已过期。实际上，收到来自服务器的响应，指示内容未被修改，基于发送的令牌在服务器上未更改的事实，浏览器只需更新缓存控制并重置到期前的时间延迟。
- en: 'This is accomplished through the use of certain response headers. These are
    **Cache-Control** and **ETag** headers. Here is an example of these received headers
    within a response:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用某些响应头部来实现的。这些是**Cache-Control**和**ETag**头部。以下是在响应中接收到的这些头部的示例：
- en: '![](assets/046b2eaf-8ccf-42c0-baf5-ee1c70ff042c.png)How browser caching works'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/046b2eaf-8ccf-42c0-baf5-ee1c70ff042c.png)浏览器缓存的工作原理'
- en: In this example, Cache-Control indicates a **max-age** of **120** seconds and
    sets an **ETag** with value **"e4563ff"**. With these two headers, the browser
    will be able to manage its cache adequately. Thus, enabling browser caching is
    as easy as adding those response headers to the responses returned by the web
    server. In the case of *Apache*, it is a simple question of making sure that the
    FileETag directive was added to the server's configuration file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Cache-Control指示**最大年龄**为**120**秒，并设置了值为**"e4563ff"**的**ETag**。有了这两个头部，浏览器就能够充分管理其缓存。因此，启用浏览器缓存就像将这些响应头部添加到Web服务器返回的响应中一样简单。对于*Apache*来说，只需确保FileETag指令已添加到服务器的配置文件中即可。
- en: 'It is also possible to set the Cache-Control and Expires headers directly using
    the *Symfony* framework in PHP. Specifically, *Symfony*''s response object allows
    you to set all Cache-Control headers using its `setCache()` method. Here is an
    example when using this method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，也可以直接使用*Symfony*框架设置Cache-Control和Expires头。具体来说，*Symfony*的响应对象允许您使用其`setCache()`方法设置所有Cache-Control头。以下是使用此方法的示例：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Having seen how easy and simple it is to start using browser HTTP caching, let's
    take the time to see how HTTP caching has other benefits to offer when combined
    with a technology such as HTTP Reverse Proxy server technology.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 看到了开始使用浏览器HTTP缓存是多么容易和简单，让我们花点时间来看看当与HTTP反向代理服务器技术结合时，HTTP缓存还有其他好处。
- en: Content Delivery Networks (CDNs)
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容传送网络（CDN）
- en: Content Delivery Networks are distributed networks of proxy servers that allow
    for high-availability and high-performance distribution of common or popular web
    resources. These resources can be web objects such as text, images and scripts,
    including CSS and JavaScript libraries, downloadable objects, such as files and
    software, and live-streaming or on-demand streaming media. CDNs can therefore
    be used as a sort of internet common cache. Indeed, by using a CDN to host all
    of your library files, you are combining browser HTTP caching with HTTP Reverse
    Proxy caching. This means that if another website or web application is using
    the same library files as you, your user's browser will either use its cached
    versions of the libraries or submit a request to refresh the files to a CDN and
    not your web server. This not only reduces network latency by reducing the number
    of requests needed globally to render the same content, but also takes away a
    part of the workload from your web server by delegating the responsibility of
    refreshing expired browser caches to the CDN's Reverse Proxy cache.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 内容传送网络是分布式代理服务器网络，允许常见或流行的网页资源高可用和高性能分发。这些资源可以是文本、图像和脚本等网页对象，包括CSS和JavaScript库，可下载的对象，如文件和软件，以及实时流或点播流媒体。CDN因此可以被用作一种互联网公共缓存。通过使用CDN托管所有库文件，您将浏览器HTTP缓存与HTTP反向代理缓存结合在一起。这意味着如果另一个网站或网页应用程序使用与您相同的库文件，您的用户浏览器将使用其缓存版本的库文件或提交一个请求到CDN而不是您的网页服务器来刷新文件。这不仅通过减少全球渲染相同内容所需的请求数量来减少网络延迟，还通过将刷新过期浏览器缓存的责任委托给CDN的反向代理缓存，从您的网页服务器中减轻了一部分工作负载。
- en: 'This Faster Web solution is very easy to implement. It is often as simple as
    redirecting web traffic to the CDN by modifying your DNS configuration. For example,
    *Cloudflare* ([https://www.cloudflare.com/](https://www.cloudflare.com/)) does
    not require any changes to your web server configuration in order to start using
    its HTTP reverse proxy cache. Once you have registered the original domain name
    and IP address of your web server in the *Cloudflare* interface, you only have
    to modify your DNS settings by having the domain name point to the *Cloudflare*
    servers in order to start using it immediately. Let''s use cURL to query the [https://linuxforphp.net/](https://linuxforphp.net/)
    site, which uses *Cloudflare*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更快的网络解决方案非常容易实现。通常只需要通过修改DNS配置将网页流量重定向到CDN。例如，*Cloudflare* ([https://www.cloudflare.com/](https://www.cloudflare.com/))
    不需要对您的网页服务器配置进行任何更改就可以开始使用其HTTP反向代理缓存。一旦您在*Cloudflare*界面中注册了原始域名和您的网页服务器的IP地址，您只需要通过将域名指向*Cloudflare*服务器来修改您的DNS设置，就可以立即开始使用它。让我们使用cURL来查询使用*Cloudflare*的[https://linuxforphp.net/](https://linuxforphp.net/)网站：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Querying the website should yield the following result, which confirms that
    it is now only accessible through *Cloudflare*:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 查询网站应该产生以下结果，确认它现在只能通过*Cloudflare*访问：
- en: '![](assets/8c27ad15-75a7-45e9-8e00-64bd6dc6841b.png)Confirmation that the linuxforphp.net
    website is available through Cloudflare'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/8c27ad15-75a7-45e9-8e00-64bd6dc6841b.png)确认linuxforphp.net网站可以通过Cloudflare访问'
- en: As we can see, *Cloudflare* is indeed enabled and has added Cache-Control and
    Expires to the response headers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，*Cloudflare*确实已启用，并已将Cache-Control和Expires添加到响应头中。
- en: Other Faster Web tools
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他更快的网络工具
- en: Many other Faster Web tools exist that can help you optimize the performance
    of your web applications and websites. Amongst these many tools are those suggested
    by Google on their Faster Web site for developers ([https://developers.google.com/speed/](https://developers.google.com/speed/)).
    One tool that will help you further analyze the performance issues of web applications
    is *PageSpeed Insights*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他更快的网络工具可以帮助您优化您的网页应用程序和网站的性能。在这些众多工具中，有一些是谷歌在其开发者更快的网络网站上建议的（[https://developers.google.com/speed/](https://developers.google.com/speed/)）。其中一个工具将帮助您进一步分析网页应用程序的性能问题，那就是*PageSpeed
    Insights*。
- en: This tool quickly identifies any possible performance optimizations for your
    web application, based on the URL you submit. To further analyze the effects of
    using *Cloudflare* for the *Linux for PHP* website, let's submit the URL to the
    *PageSpeed Insights* tool.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具可以快速识别您的网页应用可能的性能优化，基于您提交的URL。为了进一步分析在*Linux for PHP*网站上使用*Cloudflare*的效果，让我们把URL提交到*PageSpeed
    Insights*工具。
- en: 'Here are the initial results before using *Cloudflare*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在使用*Cloudflare*之前的初始结果：
- en: '![](assets/cf0b7345-24ff-490c-b506-dd8b55efa9ac.png)Results of the performance
    analysis of the linuxforphp.net website when NOT using Cloudflare'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/cf0b7345-24ff-490c-b506-dd8b55efa9ac.png)在不使用Cloudflare时对linuxforphp.net网站性能分析的结果'
- en: 'And, here are the results after adding the *Cloudflare* reverse proxy server:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是添加*Cloudflare*反向代理服务器后的结果：
- en: '![](assets/72ee142a-8bdc-4159-ab87-096d6923b2f6.png)Results of the performance
    analysis of the linuxforphp.net website when using Cloudflare'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/72ee142a-8bdc-4159-ab87-096d6923b2f6.png)使用Cloudflare时对linuxforphp.net网站性能分析的结果'
- en: Not only can we see that the general performance of the website is much better,
    but *PageSpeed Insights* also gives suggestions as to how we can further optimize
    the web application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以看到网站的总体性能要好得多，而且*PageSpeed Insights*还提出了关于如何进一步优化Web应用程序的建议。
- en: 'The initial recommendations of this tool, before the switch to *Cloudflare,*
    were as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在切换到*Cloudflare*之前，该工具的初始建议如下：
- en: '![](assets/3f28ac91-6386-4a0a-afd0-eb25ccbdc22f.png)Suggestions to optimize
    the performance of the linuxforphp.net website when NOT using Cloudflare'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在不使用Cloudflare时优化linuxforphp.net网站的性能
- en: 'And, then, after the switch to *Cloudflare*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在切换到*Cloudflare*之后：
- en: '![](assets/9ac2f43b-8738-4889-ba86-82d0f3d9262e.png)Suggestions to optimize
    the performance of the linuxforphp.net website when using Cloudflare'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在使用Cloudflare时优化linuxforphp.net网站的性能
- en: As we can see, the list of optimization suggestions is much shorter, but if
    we were to leverage browser caching for certain specific image files that can
    be found on the site, eliminate some render-blocking JavaScript and CSS, reduce
    image sizes and try to reduce server response time in general, we would most certainly
    get a perfect score!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，优化建议的列表要短得多，但如果我们利用浏览器缓存特定的图像文件，消除一些阻塞渲染的JavaScript和CSS，减小图像大小，并尝试减少服务器响应时间，我们肯定会得到一个完美的分数！
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have covered a few projects that went along with *Google*'s
    new initiative of a Faster Web. We have seen what the HTTP/2 protocol is all about
    and how the SPDY project made it possible, how PHP-FPM and Zend OPCache can help
    you boost the performance of your PHP scripts, how to use ESI technology by setting
    up a Varnish Cache server, how to use client-side caching, and how other Faster
    Web tools can help you out when trying to optimize your web server's performance.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们涵盖了一些与*Google*的新倡议“更快的网络”相关的项目。我们已经了解了HTTP/2协议的内容以及SPDY项目是如何实现的，PHP-FPM和Zend
    OPCache如何帮助您提高PHP脚本的性能，如何通过设置Varnish Cache服务器来使用ESI技术，如何使用客户端缓存，以及其他更快的网络工具在优化Web服务器性能时如何帮助您。
- en: In the next chapter, we will see how, when everything seems to have been fully
    optimized, we can still go beyond performance.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到即使一切似乎已经完全优化，我们仍然可以超越性能。
- en: References
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[1] [https://tools.ietf.org/html/rfc7540](https://tools.ietf.org/html/rfc7540)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] [https://tools.ietf.org/html/rfc7540](https://tools.ietf.org/html/rfc7540)'
- en: '[2] [https://queue.acm.org/detail.cfm?id=2716278](https://queue.acm.org/detail.cfm?id=2716278)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] [https://queue.acm.org/detail.cfm?id=2716278](https://queue.acm.org/detail.cfm?id=2716278)'
- en: '[3] [https://www.imperva.com/docs/Imperva_HII_HTTP2.pdf](https://www.imperva.com/docs/Imperva_HII_HTTP2.pdf)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] [https://www.imperva.com/docs/Imperva_HII_HTTP2.pdf](https://www.imperva.com/docs/Imperva_HII_HTTP2.pdf)'
- en: '[4] [https://ilia.ws/files/zend_performance.pdf](https://ilia.ws/files/zend_performance.pdf)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] [https://ilia.ws/files/zend_performance.pdf](https://ilia.ws/files/zend_performance.pdf)'
- en: '[5][ https://varnish-cache.org/docs/trunk/phk/firstdesign.html](https://varnish-cache.org/docs/trunk/phk/firstdesign.html)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[5][ https://varnish-cache.org/docs/trunk/phk/firstdesign.html](https://varnish-cache.org/docs/trunk/phk/firstdesign.html)'
- en: '[6][ https://trends.builtwith.com/web-server](https://trends.builtwith.com/web-server),
    March 2018.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[6][ https://trends.builtwith.com/web-server](https://trends.builtwith.com/web-server)，2018年3月。'
