- en: Magic Behind Magic Methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 魔术方法背后的魔术
- en: The PHP language allows for both, a procedural and an **object-oriented** (**OO**)
    way of writing code. Whereas the procedural way is more of a remnant of initial
    versions of PHP, nothing really stops us from writing fully procedural applications
    even today. While both approaches have their advantages and disadvantages, the
    OO way is by far the most dominant one nowadays, the advantages of which are more
    evident in robust and modular applications, which are nearly impossible to work
    on with the procedural style.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PHP语言允许以过程化和**面向对象**（**OO**）的方式编写代码。虽然过程化方式更像是PHP初始版本的遗留物，但我们今天仍然可以编写完全过程化的应用程序。虽然两种方法都有各自的优缺点，但面向对象的方式如今是最主导的，其优势在健壮和模块化的应用程序中更加明显，而这些应用程序几乎不可能使用过程化风格进行工作。
- en: Knowing the individual features of the PHP OO model is vital to understand,
    write, and debug modern applications. The **magic methods** are one of the more
    interesting and often mystic features of the PHP language. They are the predefined
    class methods that the PHP compiler executes under some event, such as object
    initialized, object destroyed, object converted to string, object method accessed,
    object property accessed, object serialized, object deserialized, and more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 了解PHP OO模型的各个特性对于理解、编写和调试现代应用程序至关重要。**魔术方法**是PHP语言中更有趣和常常神秘的特性之一。它们是预定义的类方法，PHP编译器在某些事件下执行，比如对象初始化、对象销毁、对象转换为字符串、对象方法访问、对象属性访问、对象序列化、对象反序列化等等。
- en: 'In this chapter, we will cover the use of each of the magic methods available
    in PHP, as per the following list of sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将根据以下章节列表，介绍PHP中可用的每个魔术方法的使用：
- en: Using __construct()
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用__construct()
- en: Using __destruct()
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用__destruct()
- en: Using __call()
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用__call()
- en: Using __callStatic()
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用__callStatic()
- en: Using __set()
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用__set()
- en: Using __get()
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用__get()
- en: Using __isset()
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用__isset()
- en: Using __unset()
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用__unset()
- en: Using __sleep()
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用__sleep()
- en: Using __wakeup()
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用__wakeup()
- en: Using __toString()
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用__toString()
- en: Using __invoke()
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用__invoke()
- en: Using __set_state()
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用__set_state()
- en: Using __clone()
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用__clone()
- en: Using __debugInfo()
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用__debugInfo()
- en: Usage statistic across popular platforms
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨流行平台的使用统计
- en: PHP language reserves all function names starting with `__` as magical.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: PHP语言将所有以`__`开头的函数名称保留为魔术函数。
- en: Using __construct()
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用__construct()
- en: The `__construct()` magic method represents a PHP constructor concept similar
    to that of other OO languages. It allows developers to tap into the object creation
    process. Classes that have the `__construct()` method declared, call it on each
    newly-created object. This allows us to deal with any initialization that the
    object may need before it is used.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`__construct()`魔术方法代表了PHP构造函数概念，类似于其他OO语言。它允许开发人员参与对象创建过程。具有`__construct()`方法声明的类，在每个新创建的对象上调用它。这使我们能够处理对象在使用之前可能需要的任何初始化。'
- en: 'The following code snippet shows the simplest possible use of the `__construct()`
    method:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了`__construct()`方法的最简单可能的用法：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Both `User` instances will yield the same `string(11) "__construct"` output to
    the screen. The more complex example might include constructor parameters. Consider
    the following code snippet:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`User`实例将产生相同的`string(11) "__construct"`输出到屏幕上。更复杂的例子可能包括构造函数参数。考虑以下代码片段：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we see a `__construct()` method that accepts the two parameters--`$name`
    and `$age`. Right after the `User` class definition, we have four different object
    initialization attempts. Attempt `#3` is the only valid initialization attempt.
    Attempts `#1` and `#2` trigger the following error:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一个接受两个参数`$name`和`$age`的`__construct()`方法。在`User`类定义之后，我们有四个不同的对象初始化尝试。尝试`#3`是唯一有效的初始化尝试。尝试`#1`和`#2`触发以下错误：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Attempt `#4`, even though invalid, does not trigger the error. PHP does not generate
    an error message, unlike with other methods, when `__construct()` is overridden
    with extra parameters.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试`#4`，即使无效，也不会触发错误。与其他方法不同，当`__construct()`被额外参数覆盖时，PHP不会生成错误消息。
- en: 'Another interesting case for the `__construct()` method is with the parent
    classes. Let''s consider the following example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`__construct()`方法的另一个有趣的案例是与父类一起使用。让我们考虑以下例子：'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The reason for this is that parent constructors are not called implicitly if
    the child class defines a constructor. To trigger the parent constructor, we need
    to run `parent::__construct()` within the child constructor. Let''s amend our `Employee`
    class to do just that:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是如果子类定义了构造函数，父构造函数不会被隐式调用。要触发父构造函数，我们需要在子构造函数中运行`parent::__construct()`。让我们修改我们的`Employee`类来做到这一点：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will be the output now:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将输出如下：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s take a look at the following example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we have a simple `User` class with a magic `__construct()` and a static
    `hello()` method. Right after the class definition, we have a call towards the
    static `hello()` method. This does not trigger the `__construct()` method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个简单的`User`类，有一个魔术`__construct()`和一个静态`hello()`方法。在类定义之后，我们调用静态`hello()`方法。这不会触发`__construct()`方法。
- en: 'The only output from the preceding example is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前面例子的唯一输出如下：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `__construct()` method only triggers when an object is being initiated via
    the `new` keyword.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`__construct()`方法只在通过`new`关键字初始化对象时触发。'
- en: We would want to keep our `__construct()` method, as well as other magic methods,
    under `public` access modifier only. However, if the situation demands it, we
    are free to throw in the `finally` access modifier in the mix as
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望保持我们的`__construct()`方法，以及其他魔术方法，只在`public`访问修饰符下。然而，如果情况需要，我们可以自由地将`finally`访问修饰符混合在一起
- en: 'Consider the following example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 's, the initialization attempts `#1` and `#2` would operate even with the `final`
    access modifier. This is because `#1` instantiates the original `User` class that
    defines the final `__construct()` method, and `#2` instantiates the empty `Director`
    class that does not try to implement its own `__construct()` method. The initialization
    attempt `#3` would fail, resulting in the following error:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，初始化尝试`#1`和`#2`即使使用`final`访问修饰符也会运行。这是因为`#1`实例化了定义了final `__construct()`方法的原始`User`类，而`#2`实例化了不尝试实现自己的`__construct()`方法的空`Director`类。初始化尝试`#3`将失败，导致以下错误：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is really the basis of access modifiers and overrides, not specific to
    the `__construct()` magic method itself. However, it is worth knowing that it
    is possible to use the `final` modifier with the constructor, as it might come
    in handy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是访问修饰符和覆盖的基础，而不是特定于`__construct()`魔术方法本身。然而，值得知道的是，可以使用`final`修饰符与构造函数，因为这可能会派上用场。
- en: Aside from instantiating simple objects, the practical use of the `__construct()`
    method in OOP comes in the form of **dependency injection**. Nowadays, it is generally
    accepted that injecting dependencies is a for dealing with dependencies. While
    dependencies can be injected into an object through various setter methods, the
    use of the `__construct()` method prevails as a dominant approach with some of
    the leading PHP platforms, such as Magento.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实例化简单对象外，面向对象编程中`__construct()`方法的实际用途以**依赖注入**的形式出现。如今，注入依赖关系通常被认为是处理依赖关系的一种方法。虽然依赖关系可以通过各种setter方法注入到对象中，但在一些主要的PHP平台上，如Magento，使用`__construct()`方法作为主要方法仍然占主导地位。
- en: 'The following code block demonstrates the `__construct()` method of Magento''s
    `vendor/magento/module-gift-message/Model/Save.php` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块演示了Magento的`vendor/magento/module-gift-message/Model/Save.php`文件中的`__construct()`方法：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are several dependencies being passed here via the `__construct()` method,
    which seems quite a step up from previous examples. Even so, the majority of Magento's `__construct()`
    methods are much more robust than this, passing on tens of parameters to the object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`__construct()`方法传递了几个依赖项，这似乎比以前的例子要复杂得多。即便如此，Magento的大多数`__construct()`方法要比这个更加健壮，向对象传递了数十个参数。
- en: We could easily summarize the role of the `__construct()` method as sort of
    a class signature that represents how a consumer should fully instantiate a particular
    object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松总结`__construct()`方法的作用，它是一种类签名，表示消费者应该如何完全实例化特定对象。
- en: Using __destruct()
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用__destruct()
- en: Alongside the constructor, the destructor is a common feature of the OO language.
    The `__destruct()` magic method represents this concept. The method gets triggered
    as soon as there are no other references to a particular object. This can happen
    either when PHP decides to explicitly free the object, or when we force it using
    the `unset()`  language construct.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构造函数，析构函数是面向对象语言的常见特性。`__destruct()`魔术方法代表了这个概念。一旦没有其他引用指向特定对象，该方法就会被触发。这可能是当PHP决定显式释放对象时，也可能是我们使用`unset()`语言构造强制释放对象时发生的。
- en: As with constructors, parent destructors don't get called implicitly by PHP.
    In order to run a parent destructor, we need to explicitly call `parent::__destruct()`.
    Furthermore, the child class inherits the parent's destructor if it does not implement
    one for itself.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与构造函数一样，父析构函数不会被PHP隐式调用。为了运行父析构函数，我们需要显式调用`parent::__destruct()`。此外，如果子类没有实现自己的析构函数，则子类继承父类的析构函数。
- en: 'Let''s say we have a following simple `User` class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下简单的`User`类：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With the `User` class in place, let''s go ahead and look through instance creation examples:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`User`类，让我们继续查看实例创建示例：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `new User();` expression here instantiates an instance of the `User` class
    into *thin air *as it does not assign the newly instantiated object into the variable.
    This is a trigger for PHP to explicitly call the `__destruct()` method right there
    on the same line, resulting in the `A__destructB` string :'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`new User();`表达式将`User`类的一个实例实例化为*空气*，因为它没有将新实例化的对象分配给变量。这是PHP明确调用`__destruct()`方法的触发器，导致`A__destructB`字符串：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `new User();` expression here instantiates an instance of `User` class into
    the `$user` variable. This prevents PHP from triggering instantly, as the script
    might use the `$user` variable further down the path. Still, PHP explicitly calls
    the `__destruct()` method when it concludes that the `$user` variable is not being
    referenced, resulting in the `AB__destruct` string
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`new User();`表达式将`User`类的一个实例实例化为`$user`变量。这可以防止PHP立即触发，因为脚本可能会在路径的后面使用`$user`变量。尽管如此，PHP在得出结论`$user`变量没有被引用时，会显式调用`__destruct()`方法，导致`AB__destruct`字符串。
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we are extending the previous example a little bit. We are using the `unset()`
    language construct to force the destruction of the `$user` variable in between
    expressions. The call to `unset()` is basically an implicit trigger for PHP to
    execute the object's `__destruct()` method, resulting in the `AB__destructC` string
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们稍微扩展了前面的例子。我们使用`unset()`语言构造来强制销毁表达式之间的`$user`变量。调用`unset()`基本上是PHP执行对象的`__destruct()`方法的隐式触发器，导致`AB__destructC`字符串。
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we are calling the `exit()` language construct right before the `C` string
    output. This serves as an implicit trigger for PHP that there are no more references
    towards the `$user` variable, and, therefore, the object's `__destruct()` method
    can be executed. The resulting output is the `AB__destruct` string.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`C`字符串输出之前调用`exit()`语言构造。这作为PHP的隐式触发器，表明没有更多的引用指向`$user`变量，因此可以执行对象的`__destruct()`方法。结果输出是`AB__destruct`字符串。
- en: Certain situations might tempt us to call the `exit()` constructor from within
    the `__destruct()` method itself. , because calling `exit()` within `__destruct()`
    prevents the remaining shutdown routines from executing. Likewise, throwing an
    exception from the `__destruct()` method will trigger a fatal error, but only
    if thrown at the time of script termination. This is, by no means, a way to handle
    our application states.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 某些情况可能会诱使我们从`__destruct()`方法中调用`exit()`构造函数，因为在`__destruct()`中调用`exit()`会阻止剩余的关闭例程执行。同样，从`__destruct()`方法抛出异常只会在脚本终止时触发致命错误。这绝不是处理应用程序状态的方法。
- en: Most of the time, destructors are not something we will want or need to implement
    on our own. Chances are that a great majority of our classes won't have a need
    for it, as PHP itself does a pretty good job of cleaning up. There are, however,
    cases where we might want to instantly release the resource consumed by the object
    after the object is not being referenced anymore. The `__destruct()` method allows
    certain follow-up actions during the object's termination.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，析构函数不是我们想要或需要自己实现的东西。我们的大多数类可能不需要它，因为PHP本身在清理方面做得相当不错。然而，有些情况下，我们可能希望在对象不再被引用后立即释放对象消耗的资源。`__destruct()`方法允许在对象终止时进行某些后续操作。
- en: Using __call()
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用__call()
- en: Overloading is a familiar term in OOP. However, not all programming languages
    interpret it in the same way. The PHP notion of overloading is quite different
    than that of other OO languages. Where traditionally overloading provides the
    ability to have multiple methods with the same name but different arguments, in
    PHP overloading means to dynamically create methods and properties.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重载是面向对象编程中一个熟悉的术语。然而，并非所有编程语言都以相同的方式解释它。PHP中的重载概念与其他面向对象语言大不相同。传统上，重载提供了使用相同名称但不同参数的多个方法的能力，而在PHP中，重载意味着动态创建方法和属性。
- en: unfortunate misuse of the term overloading adds a layer of confusion for some developers,
    as the more proper term for this type of functionality might have been *interpreter
    hooks*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对术语重载的误用为一些开发人员增加了困惑，因为对于这种类型的功能，更合适的术语可能是*解释器挂钩*。
- en: 'There are two magic methods in PHP supporting method overloading: `__call()`
    and `__callStatic()`. Throughout this section, we will take a closer look at the
    `__call()` method.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中支持方法重载的两个魔术方法是`__call()`和`__callStatic()`。在本节中，我们将更仔细地看看`__call()`方法。
- en: 'The `__call()` magic method is triggered when invoking inaccessible methods
    in an *object context*. This method accepts two parameters, as per the following
    synopsis:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在*对象上下文*中调用不可访问方法时，将触发`__call()`魔术方法。该方法接受两个参数，如下概要所示：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However the `__call()` method parameters have the following meaning:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`__call()`方法的参数具有以下含义：
- en: '`$name`: This is the name of the method being called'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$name`：这是被调用的方法的名称'
- en: '`$arguments`: This is an enumerated array containing the parameters passed
    to the `$name` method'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$arguments`：这是一个包含传递给`$name`方法的参数的枚举数组'
- en: 'The following example demonstrates the use of the `__call()` method in the
    object context:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了在对象上下文中使用`__call()`方法：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `User` class itself declared only the `__call()` and `bonus()` methods.
    The `$user` object tries to call the `hello()`, `bonus()`, and `salary()` methods.
    This effectively means the object is trying to call two missing methods: `hello()`
    and `salary()`. The `__call()` method kicks in for the missing two methods, thus
    yielding the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`类本身只声明了`__call()`和`bonus()`方法。`$user`对象尝试调用`hello()`、`bonus()`和`salary()`方法。这实际上意味着对象试图调用两个缺失的方法：`hello()`和`salary()`。缺失的两个方法会触发`__call()`方法，从而产生以下输出：'
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can find a nice use case example of the `__call()` method in the Magento
    platform, as per the following entry taken from the `vendor/magento/framework/DataObject.php`
    class file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Magento平台中找到`__call()`方法的一个很好的用例示例，如下面从`vendor/magento/framework/DataObject.php`类文件中摘取的条目：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Without getting into the details of Magneto itself, it''s suffice to say that
    their `DataObject` class serves as a root data object throughout the entire framework. The
    code within the `__call()` method enables it to magically *get*, *set*, *unset*,
    and *check* for the existence of the property on the object instance. This is
    used later in expressions, such as the following entry taken from the `vendor/magento/module-checkout/Controller/Cart/Configure.php`
    file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要深入了解Magneto本身，可以说他们的`DataObject`类在整个框架中充当根数据对象。`__call()`方法中的代码使其能够在对象实例上魔法地*获取*、*设置*、*取消设置*和*检查*属性的存在。这在后续表达式中使用，例如从`vendor/magento/module-checkout/Controller/Cart/Configure.php`文件中摘取的以下条目：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The benefit is that we have easily empowered instances of `DataObject` here
    with magical methods that might and might not exist. For example, `setCategoryId()`
    is a method that does not exist on the `DataObject` class. Since it does not exist,
    calling it triggers the `__call()` method. This might not be that obvious at first,
    so let''s consider another imaginary example where our custom class extends from
    `DataObject`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 好处在于我们可以轻松地为`DataObject`的实例赋予可能存在也可能不存在的魔术方法。例如，`setCategoryId()`是`DataObject`类上不存在的方法。由于它不存在，调用它会触发`__call()`方法。这一点一开始可能不太明显，因此让我们考虑另一个想象的例子，我们的自定义类从`DataObject`继承：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice the *beauty and simplicity* of *setters* and *getters* we have achieved
    here with the help of the `__call()` magic method. Even though our `User` class
    is basically empty, we have inherited the magic behind the parent's `__call()`
    implementation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们通过`__call()`魔术方法在这里实现的*设置器*和*获取器*的*美丽和简单*。尽管我们的`User`类基本上是空的，但我们已经继承了父类`__call()`实现的魔术。
- en: The `__call()` method empowers us with some truly interesting possibilities,
    most of which will fit right in as a part of frameworks or libraries.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`__call()`方法赋予我们一些真正有趣的可能性，其中大部分将作为框架或库的一部分。'
- en: Using __callStatic()
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用__callStatic()
- en: The `__callStatic()` magic is nearly identical to the `__call()` method. Where
    the `__call()` method is bound to the *object context*, the `__callStatic()` method
    is bound to the *static context,* which means this method is triggered when invoking
    inaccessible methods via the scope resolution operator (`::`).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`__callStatic()`魔术几乎与`__call()`方法相同。`__call()`方法绑定到*对象上下文*，而`__callStatic()`方法绑定到*静态上下文*，这意味着在通过作用域解析运算符（`::`）调用不可访问的方法时会触发此方法。'
- en: 'The method accepts two parameters as per the following synopsis:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法根据以下概要接受两个参数：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice the use of the static access modifier in the method declaration that
    is required by the static context upon which this method operates. The following
    example demonstrates the use of the `__callStatic()` method in the static context:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在方法声明中使用静态访问修饰符，这是静态上下文所需的。以下示例演示了在静态上下文中使用`__callStatic()`方法：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'code will yield the following output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将产生以下输出：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `User` class itself declared only the `__callStatic()` and `bonus()` methods.
    The `User` class tries to call static `hello()`, `bonus()`, and `salary()` methods.
    This effectively means that the class is trying to call two missing methods: `hello()`
    and `salary()`. The `__callStatic()` method kicks in for the missing two methods,
    thus yielding the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`类本身只声明了`__callStatic()`和`bonus()`方法。`User`类尝试调用静态`hello()`，`bonus()`和`salary()`方法。这实际上意味着该类试图调用两个缺失的方法：`hello()`和`salary()`。对于缺失的两个方法，`__callStatic()`方法会启动，从而产生以下输出：'
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In OO programming, the static context is less frequent than the object context, which
    makes the `__callStatic()` method less frequently used than the `__call()` method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，静态上下文比对象上下文更少见，这使得`__callStatic()`方法比`__call()`方法更少使用。
- en: Using __set()
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用__set()
- en: 'Aside from *method overloading*, *property overloading* is another aspect of
    the PHP overloading capabilities. There are four magic methods in PHP that support
    the property overloading: `__set()`, `__get()`, `__isset()`, and `__unset()`.
    Throughout this section, we will take a closer look at the `__set()` method.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*方法重载*之外，*属性重载*是PHP重载功能的另一个方面。 PHP中有四个魔术方法支持属性重载：`__set()`，`__get()`，`__isset()`和`__unset()`。在本节中，我们将更仔细地看一下`__set()`方法。
- en: The `__set()` magic method is triggered when trying to write data to inaccessible
    properties.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试向不可访问的属性写入数据时，将触发`__set()`魔术方法。
- en: 'The method accepts two parameters, as per the following synopsis:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法根据以下概要接受两个参数：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Whereas, the `__set()` method parameters have the following meaning:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 而`__set()`方法的参数具有以下含义：
- en: '`$name`: This is the name of the property being interacted with'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$name`：这是正在交互的属性的名称'
- en: '`$value`: This is the value that the `$name` property should be set to'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$value`：这是`$name`属性应该设置的值'
- en: 'Let''s take a look at the following object context example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下对象上下文示例：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `User` class declares four properties with various access modifiers. It
    further declares the `__set()` method that intercepts all the property write attempts
    on the object context.  Attempting to set a non-existing (`$message`) or inaccessible (`$name`,
    `$age`) property triggers the `__set()` method. The inner workings of the  `__set()`
    method push the inaccessible data into the `$data` property array, which is visible
    in the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`类声明了四个具有不同访问修饰符的属性。它进一步声明了`__set()`方法，该方法拦截对象上下文中的所有属性写入尝试。尝试设置不存在的（`$message`）或不可访问的（`$name`，`$age`）属性会触发`__set()`方法。`__set()`方法的内部工作将不可访问的数据推送到`$data`属性数组中，这在以下输出中可见：'
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: One practical use of the `__set()` method might be allowing the setting of a
    property was set to `true` during object construction; otherwise, throw an exception.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`__set()`方法的一个实际用途可能是允许在对象构造期间将属性设置为`true`；否则，抛出异常。'
- en: 'Trying to use any of the four property overloading methods (`__set()`, `__get()`,
    `__isset()`, and `__unset()`) in a static context would result in the following
    error:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态上下文中尝试使用四种属性重载方法（`__set()`，`__get()`，`__isset()`和`__unset()`）将导致以下错误：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using __get()
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用__get()
- en: 'The `__get()` magic method is triggered when trying to read the data from an
    inaccessible property. The method accepts a single parameter, as per the following
    synopsis:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从不可访问的属性中读取数据时，将触发`__get()`魔术方法。该方法根据以下概要接受一个参数：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `$name` argument is the name of the property being interacted with.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`$name`参数是正在交互的属性的名称。'
- en: 'Let''s take a look at the following object context example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下对象上下文示例：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `User` class defines four different properties, across three different
    visibility access modifiers. Since we don''t have getter methods to access all
    of the individual properties, the only directly accessible property is `public
    $salary`.  This is where the `__get()` method comes in handy, as it kicks in as
    soon as we try to access a nonexistent or otherwise inaccessible property. The
    resulting output of the preceding code comes down to the following four lines:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`类定义了四个不同的属性，跨越三种不同的可见性访问修饰符。由于我们没有获取器方法来访问所有单独的属性，唯一可直接访问的属性是`public
    $salary`。这就是`__get()`方法派上用场的地方，因为一旦我们尝试访问不存在或无法访问的属性，它就会启动。前面代码的结果输出为以下四行：'
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `age` and the `name` values are fetched from within the `$data` property
    as a result of the `__get()` method's inner workings.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`age`和`name`的值是从`$data`属性中获取的，这是`__get()`方法内部工作的结果。'
- en: Using __isset()
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用__isset()
- en: 'The `__isset()` magic method is triggered by calling the `isset()` or `empty()` language
    constructs on inaccessible properties. The method accepts a single parameter,
    as per the following synopsis:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`__isset()`魔术方法是通过调用`isset()`或`empty()`语言结构来触发的。该方法根据以下概要接受一个参数：'
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `$name` argument is the name of the property being interacted with.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`$name`参数是正在交互的属性的名称。'
- en: 'Let''s take a look at the following object context example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下对象上下文示例：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `User` class defines a single protected array property called `$data`, and
    a magic `__isset()` method. The current method's inner workings simply do a name
    lookup against the `$data` array key names and return `true` if the key is found
    in the array, otherwise, `false`. The resulting output of the example is `bool(true)`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`类定义了一个名为`$data`的单个受保护的数组属性，以及一个魔术`__isset()`方法。当前方法的内部工作只是针对`$data`数组键名进行查找，并在数组中找到键时返回`true`，否则返回`false`。示例的结果输出为`bool(true)`。'
- en: 'The Magento platform provides an interesting and practical use case for the `__isset()`
    method as part of its `vendor/magento/framework/HTTP/PhpEnvironment/Request.php`
    class file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Magento平台为`vendor/magento/framework/HTTP/PhpEnvironment/Request.php`类文件的`__isset()`方法提供了一个有趣且实用的用例：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `Magento\Framework\HTTP\PhpEnvironment\Request` class here represents the
    PHP environment and all of its possible request data. The request data can come
    from many sources: a query string, `$_GET`, `$_POST`, and others. The `switch`
    case traverses through several of these source data variables (`$params`, `$queryParams`,
    `$postParams`, `$serverParams`, `$envParams`, `$_COOKIE`) in order to find and
    confirm the existence of the request parameter.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`Magento\Framework\HTTP\PhpEnvironment\Request`类代表了PHP环境及其所有可能的请求数据。请求数据可以来自许多来源：查询字符串、`$_GET`、`$_POST`等。`switch`语句遍历了这些源数据变量（`$params`、`$queryParams`、`$postParams`、`$serverParams`、`$envParams`、`$_COOKIE`），以查找并确认请求参数的存在。
- en: Using __unset()
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用__unset()
- en: 'The `__unset()` magic method is triggered by calling the `unset()` language
    constructs on inaccessible properties. The method accepts a single parameter,
    as per the following synopsis:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`unset()`语言构造函数来触发`__unset()`魔术方法，该方法接受一个参数，如下概要所示：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `$name` argument is the name of the property being interacted with.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`$name`参数是正在交互的属性的名称。'
- en: 'Let''s take a look at the following object context example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下对象上下文示例：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `User` class declares a single private `$data` array property, alongside
    the `__unset()` magic method. The method itself is quite simple; it merely calls
    for the `unset()` passing it the value at a given array key. We are trying to
    unset to the `$age` and `$salary` properties here. The `$salary` property does
    not really exist, neither as a class property nor as a `data` array key. Luckily,
    `unset()` won''t throw an `Undefined index` notice type of error, so we do not
    need additional `array_key_exists()` checks. The following resulting output shows
    the `$age` property being removed from the object instance:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`类声明了一个单个私有的`$data`数组属性，以及`__unset()`魔术方法。这个方法本身非常简单；它只是调用`unset()`并传递给它给定数组键的值。我们正在尝试取消`$age`和`$salary`属性。`$salary`属性实际上并不存在，既不是类属性，也不是`data`数组的键。幸运的是，`unset()`不会抛出`Undefined
    index`类型的错误，因此我们不需要额外的`array_key_exists()`检查。以下的输出显示了从对象实例中删除了`$age`属性：'
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We should not confuse the use of the `unset()` construct with the `(unset)`
    casting. These two are different operations, and as such the `(unset)` casting
    will not trigger the `__unset()` magic
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该混淆`unset()`构造与`(unset)`转换的用法。这两者是不同的操作，因此`(unset)`转换不会触发`__unset()`魔术方法。
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using __sleep()
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用__sleep()
- en: 'Object serialization is another important aspect of OOP. PHP provides a `serialize()`
    function that allows us to serialize a value passed to it. The result is a string
    containing a byte-stream representation of any value that can be stored in PHP.
    Serializing the scalar data types and simple objects is pretty straightforward,
    as per the following example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对象序列化是面向对象编程的另一个重要方面。PHP提供了一个`serialize()`函数，允许我们对传递给它的值进行序列化。结果是一个包含可以存储在PHP中的任何值的字节流表示的字符串。对标量数据类型和简单对象进行序列化是非常简单的，如下例所示：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The resulting output is shown as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出如下：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Even a simple custom class can be easily :'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是一个简单的自定义类也可以很容易地：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding code results in the following output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果如下：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The issue occurs when our classes are either significant in size, or contain resource-type
    references. The `__sleep()` magic method addresses these challenges in a way.
    Its intended use is to commit pending data or perform related cleanup tasks. The
    function is useful when we have large objects that do not need to be serialized
    completely.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的类在大小上要么很重要，要么包含资源类型的引用时，就会出现问题。`__sleep()`魔术方法以一种方式解决了这些挑战。它的预期用途是提交未决数据或执行相关的清理任务。当我们有不需要完全序列化的大型对象时，该函数非常有用。
- en: The  `serialize()` function triggers the object's `__sleep()` method if it exists.
    The actual triggering is done before the serialization process starts. This empowers
    the object to specifically list the fields it wants to allow for serialization.
    The return value of the `__sleep()` method must be an array with the names of
    all the object properties that we want to serialize. If the method doesn't return
    a serializable property name array, then `NULL` is serialized and `E_NOTICE` is
    issued.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`serialize()`函数会在对象存在时触发对象的`__sleep()`方法。实际触发是在序列化过程开始之前完成的。这使对象能够明确列出它想要允许序列化的字段。`__sleep()`方法的返回值必须是一个包含我们想要序列化的所有对象属性名称的数组。如果该方法不返回可序列化的属性名称数组，则会序列化为`NULL`并发出`E_NOTICE`。'
- en: 'The following example demonstrates a simple `User` class with a simple `__sleep()`
    method implementation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了一个简单的`User`类，其中包含一个简单的`__sleep()`方法的实现：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The implementation of the `__sleep()` method clearly states that the only two
    serializable properties of a `User` class are `name` and `salary`. Notice how
    the actual names are provided as a string, without a `$` sign, which results in
    an output as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`__sleep()`方法的实现清楚地说明`User`类的唯一两个可序列化属性是`name`和`salary`。请注意，实际名称以字符串形式提供，没有`$`符号，这导致输出如下：'
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Serializing objects in order to store them in a database is a dangerous practice,
    and should be avoided by any means possible. Rare are the cases that require complex
    object serialization. Even those are likely a mark of improper application design.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象序列化以存储在数据库中是一种危险的做法，应尽可能避免。需要复杂对象序列化的情况很少。即使有这样的情况，也很可能是应用设计不当的标志。
- en: Using __wakeup()
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用__wakeup()
- en: The topic of serializable objects would not be complete without the `serialize()`
    method counterpart--the  `unserialize()` method. If the `serialize()` method call
    triggers the object's `__sleep()` magic method, it is logical to expect there
    is a similar behavior for deserialization. Rightfully so, calling the `unserialize()` method
    upon a given object triggers its `__wakeup()` magic method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可序列化对象的主题如果没有`serialize()`方法的对应方法--`unserialize()`方法，将不完整。如果`serialize()`方法调用触发对象的`__sleep()`魔术方法，那么可以合理地期望反序列化也有类似的行为。因此，在给定对象上调用`unserialize()`方法将触发其`__wakeup()`魔术方法。
- en: The intended use of `__wakeup()` is to reestablish any resources that might have
    been lost during serialization and perform other reinitialization tasks.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`__wakeup()`的预期用途是重新建立在序列化过程中可能丢失的任何资源，并执行其他重新初始化任务。'
- en: 'Let''s take a look at the following example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `Backup` class accepts host, username, and password information through
    its constructor. Internally, it sets the core PHP `ftp_connect()` function to
    establish a connection towards the FTP server. A successfully established connection
    returns a resource we store into a protected `$ftpClient` property of a class.
    Since resources are not serializable, we made sure to exclude it from the `__sleep()`
    method return array. This ensures that our serialized string does not contain
    the `$ftpHost` property. We have further set a `$this->connect();` call within
    the `__wakeup()` method to reinitialize the `$ftpHost` resource. The overall example
    results in the following output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Backup`类通过其构造函数接受主机、用户名和密码信息。在内部，它将核心PHP的`ftp_connect()`函数设置为建立与FTP服务器的连接。成功建立的连接返回一个资源，我们将其存储到类的受保护的`$ftpClient`属性中。由于资源不可序列化，我们确保将其从`__sleep()`方法返回数组中排除。这确保我们的序列化字符串不包含`$ftpHost`属性。我们进一步在`__wakeup()`方法中设置了`$this->connect();`调用，以重新初始化`$ftpHost`资源。整体示例结果如下输出：'
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `__wakeup()` method sort of takes on the role of constructor during the `unserialize()`
    function call. Because the object's `__construct()` method is not called during
    deserialization, we need to be careful to implement the necessary `__wakeup()`
    method logic so that the object can reconstruct any resources it might need.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`__wakeup()`方法在`unserialize()`函数调用期间承担了构造函数的角色。因为对象的`__construct()`方法在反序列化期间不会被调用，所以我们需要小心地实现必要的`__wakeup()`方法逻辑，以便对象可以重建可能需要的任何资源。'
- en: Using __toString()
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用__toString()
- en: The `__toString()` magic method triggers when we use an object in a string context.
    It allows us to decide how the object will react when it is treated like a string.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`__toString()`魔术方法在我们将对象用于字符串上下文时触发。它允许我们决定对象在被视为字符串时的反应方式。'
- en: 'Let''s take a look at the following example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we have a simple `User` class that accepts the `$name` and `$age` parameters
    through its constructor method. Other than that, there is nothing else to indicate
    how the class should respond to the attempt of using it in the string context,
    which is exactly what we are doing right after the class declaration, as we are
    trying to `echo` the object instance itself.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个简单的`User`类，通过其构造方法接受`$name`和`$age`参数。除此之外，没有其他内容表明类应如何响应尝试在字符串上下文中使用它，这正是我们在类声明后立即做的，因为我们试图`echo`对象实例本身。
- en: 'In its current form, the resulting output would be as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在其当前形式下，生成的输出将如下所示：
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `__toString()` magic method allows us to circumvent this error in a simple
    and elegant :'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`__toString()`魔术方法允许我们简单而优雅地规避这个错误：'
- en: '[PRE51]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'By adding the `__toString()` magic method, we were able to tailor the resulting
    string representation of our object into the following code line:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`__toString()`魔术方法，我们能够将对象的结果字符串表示定制为以下代码行：
- en: '[PRE52]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The Guzzle HTTP client provides a practical use case example of the `__toString()`
    method through its PSR7 HTTP messaging interface implementations; whereas, some
    of the implementations make use of the  `__toString()` method. The following code
    snippet is a partial extract of Guzzle''s `vendor/guzzlehttp/psr7/src/Stream.php` class
    file that implements the `Psr\Http\Message\StreamInterface` interface:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Guzzle HTTP客户端通过其PSR7 HTTP消息接口实现提供了`__toString()`方法的实际用例示例；而一些实现使用了`__toString()`方法。以下代码片段是Guzzle的`vendor/guzzlehttp/psr7/src/Stream.php`类文件的部分提取，该文件实现了`Psr\Http\Message\StreamInterface`接口：
- en: '[PRE53]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `try...catch` block is pretty much a norm in the case of any logic-rich
    `__toString()` implementations. This is because we cannot throw an exception from
    within a `__toString()` method. Therefore, we need to make sure no error escapes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑丰富的`__toString()`实现中，`try...catch`块基本上是一种常态。这是因为我们不能从`__toString()`方法中抛出异常。因此，我们需要确保没有错误逃逸。
- en: Using __invoke()
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用__invoke()
- en: 'The `__invoke()` magic method gets triggered when the object is being called
    as a function. The method accepts an optional number of parameters and is is able
    to return various types of data, or no data at all, as per the following synopsis:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`__invoke()`魔术方法在对象被调用为函数时触发。该方法接受可选数量的参数，并能够返回各种类型的数据，或者根本不返回数据，如下概要所示：'
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If an object class implements the `__invoke()` method, we can call the method by
    specifying parentheses `()` right after the object's name. This type of object
    is known as a functor or function object.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象类实现了`__invoke()`方法，我们可以通过在对象名称后面加上括号`()`来调用该方法。这种类型的对象称为函数对象或函数对象。
- en: The Wikipedia page ([https://en.wikipedia.org/wiki/Functor](https://en.wikipedia.org/wiki/Functor))
    provides more information on the functor.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科页面（[https://en.wikipedia.org/wiki/Functor](https://en.wikipedia.org/wiki/Functor)）提供了有关函数子的更多信息。
- en: 'The following block of code illustrates the simple `__invoke()` implementation:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块演示了简单的`__invoke()`实现：
- en: '[PRE55]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `__invoke()` method can be triggered either by using the object instance
    as a function or by calling `call_user_func()`,
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`__invoke()`方法可以通过将对象实例作为函数使用或调用`call_user_func()`来触发。'
- en: '[PRE56]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Using the `__invoke()` method, we *masquerade* our classes as .
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`__invoke()`方法，我们可以将我们的类伪装成。
- en: '[PRE57]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: One of the benefits of using `__invoke()` is that it makes it possible to create
    a standard callback type across the language. This is much more convenient than using
    combinations of strings, objects, and arrays when referencing a function, object
    instance method, or class static method via the `call_user_func()` function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`__invoke()`的好处之一是，它可以创建一个跨语言的标准回调类型。这比在引用函数、对象实例方法或类静态方法时使用字符串、对象和数组的组合更方便，通过`call_user_func()`函数。
- en: The `__invoke()` method makes for powerful language additions as we perceive
    opportunities for new development patterns; although, its misuse can lead towards
    an unclear and messy code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`__invoke()`方法作为强大的语言补充，我们认为它提供了新的开发模式的机会；尽管它的滥用可能会导致代码不清晰和混乱。'
- en: Using __set_state()
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用__set_state()
- en: 'The `__set_state()` magic method is triggered (not really) for classes exported
    by the `var_export()` function. The method accepts a single array type parameter
    and returns an object, as per the following synopsis:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`__set_state()`魔术方法被触发（实际上并没有）用于`var_export()`函数导出的类。该方法接受一个单一的数组类型参数，并返回一个对象，如下概要所示：'
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `var_export()` function outputs or returns a parsable string representation
    of a given variable. It is somewhat similar to the `var_dump()` function, except
    that the returned representation is a valid PHP
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`var_export()`函数输出或返回给定变量的可解析字符串表示。它与`var_dump()`函数有些类似，不同之处在于返回的表示是有效的PHP。'
- en: '[PRE59]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This results in the following output:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下输出：
- en: '[PRE60]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Using the `var_export()` function does not actually trigger the `__set_state()`
    method of our `User` class. It merely yields a string representation of the `User::__set_state(array(...))` expression
    that we can either log, output, or pass through the `eval()` language construct
    for execution.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var_export()`函数实际上不会触发我们的`User`类的`__set_state()`方法。它只产生一个`User::__set_state(array(...))`表达式的字符串表示，我们可以记录、输出或通过`eval()`语言结构进行执行。
- en: 'The following piece of code is a more robust example demonstrating the use
    of `eval()`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是一个更健壮的示例，演示了`eval()`的使用：
- en: '[PRE61]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This results in the following output:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下输出：
- en: '[PRE62]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Knowing how the `eval()` language construct is very dangerous as it allows execution
    of arbitrary PHP code, its use is discouraged. Therefore, the use of `__set_state()` itself becomes
    questionable for anything other than debugging purposes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 了解`eval()`语言结构非常危险，因为它允许执行任意的PHP代码，因此不建议使用。因此，除了调试目的之外，使用`__set_state()`本身就变得值得怀疑。
- en: Using __clone()
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用__clone()
- en: 'The `__clone()` magic method is triggered on newly cloned objects, where cloning
    is done using the `clone` keyword. The method does not accept any parameters nor
    does it return any values, as per the following synopsis:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`__clone()`魔术方法在使用`clone`关键字进行克隆的新克隆对象上触发。该方法不接受任何参数，也不返回任何值，如下概要所示：'
- en: '[PRE63]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: When it comes to object cloning, we tend to differentiate deep copy and shallow
    copy. Deep copy copies everything--all of the objects an object might point to.
    Shallow copy copies as little as possible, leaving the object references as references
    where possible. While shallow copy might come in handy as a protection against
    circular references, replicating all properties whether they are references or
    values is not always the desired behavior.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象克隆方面，我们倾向于区分深拷贝和浅拷贝。深拷贝会复制所有对象可能指向的对象。浅拷贝尽可能少地复制，将对象引用留作引用。虽然浅拷贝可能对抗循环引用很有用，但不一定是期望的行为，因为它会复制所有属性，无论它们是引用还是值。
- en: 'The following example demonstrates the implementation of the `__clone()` method
    and the use of the `clone` keyword:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了`__clone()`方法的实现和`clone`关键字的使用：
- en: '[PRE64]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This results in the following output:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下输出：
- en: '[PRE65]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The important takeaway when it comes to the `__clone()` method is that it is not an
    override of the cloning process. The normal cloning process always occurs. The `__clone()`
    method merely takes on the responsibility of amending the wrong doing, where we
    might not normally be satisfied with the outcome.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`__clone()`方法的重要要点是，它并不是克隆过程的覆盖。正常的克隆过程总是会发生。`__clone()`方法只是承担了修正错误的责任，我们可能对结果不满意时会使用它。
- en: Using __debugInfo()
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用__debugInfo()
- en: 'The `__debugInfo()` magic method gets triggered when the `var_dump()` function
    is called. By default, the `var_dump()` function shows all public, protected,
    and private properties of an object. However, if an object class implements the
    `__debugInfo()` magic method, we get to control the output of the `var_dump()` function.
    The method does not accept any parameters, and returns an array of key-values to
    be shown, as per the following synopsis:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`var_dump()`函数时，`__debugInfo()`魔术方法会被触发。默认情况下，`var_dump()`函数显示对象的所有公共、受保护和私有属性。但是，如果对象类实现了`__debugInfo()`魔术方法，我们可以控制`var_dump()`函数的输出。该方法不接受任何参数，并返回一个要显示的键值数组，如下概要所示：
- en: '[PRE66]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following example demonstrates the `__debugInfo()` method implementation:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了`__debugInfo()`方法的实现：
- en: '[PRE67]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This results in the following output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下输出：
- en: '[PRE68]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: While the `__debugInfo()` method is useful for tailoring our own `var_dump()`
    output, this might not be something we will necessarily be doing in day-to-day
    development.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`__debugInfo()`方法对于定制我们自己的`var_dump()`输出很有用，但这可能不是我们在日常开发中必须做的事情。
- en: Usage statistics across popular platforms
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流行平台上的使用统计
- en: 'The PHP ecosystem is massive to say the least. There are dozens of free and
    open source CMS, CRM, shopping cart, blog, and other platforms and libraries out
    there. WordPress, Drupal, and Magento are probably among the most popular ones
    when it comes to blogs, content management, and shopping cart solutions. They
    are all available for download from their respective websites:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: PHP生态系统可以说是非常庞大的。有数十个免费和开源的CMS、CRM、购物车、博客和其他平台和库。WordPress、Drupal和Magento可能是在博客、内容管理和购物车解决方案方面最受欢迎的平台之一。它们都可以从各自的网站上下载：
- en: WordPress: [https://wordpress.org](https://wordpress.org)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'WordPress: [https://wordpress.org](https://wordpress.org)'
- en: Drupal: [https://www.drupal.org](https://www.drupal.org)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Drupal: [https://www.drupal.org](https://www.drupal.org)'
- en: Magento: [https://magento.com/](https://magento.com/)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Magento: [https://magento.com/](https://magento.com/)'
- en: 'Considering these popular platforms, the following table puts some perspective
    around the magic method use:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些流行平台，以下表格对魔术方法的使用进行了一些说明：
- en: '| **Magic method** | **WordPress 4.7****(702 .php files)** | **Drupal 8.2.4****(8199
    .php files)** | **Magento CE 2.1.3****(29649 .php files)** |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **魔术方法** | **WordPress 4.7****(702 .php files)** | **Drupal 8.2.4****(8199
    .php files)** | **Magento CE 2.1.3****(29649 .php files)** |'
- en: '| `__construct()` | 343 | 2547 | 12218 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '`__construct()` | 343 | 2547 | 12218'
- en: '| `__destruct()` | 19 | 19 | 77 |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '`__destruct()` | 19 | 19 | 77'
- en: '| `__call()` | 10 | 35 | 152 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '`__call()` | 10 | 35 | 152'
- en: '| `__callStatic()` | 1 | 2 | 4 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '`__callStatic()` | 1 | 2 | 4'
- en: '| `__get()` | 23 | 31 | 125 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '`__get()` | 23 | 31 | 125'
- en: '| `__set()` | 15 | 24 | 86 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '`__set()` | 15 | 24 | 86'
- en: '| `__isset()` | 21 | 15 | 57 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '`__isset()` | 21 | 15 | 57'
- en: '| `__unset()` | 11 | 13 | 34 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '`__unset()` | 11 | 13 | 34'
- en: '| `__sleep()` | 0 | 46 | 103 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '`__sleep()` | 0 | 46 | 103'
- en: '| `__wakeup()` | 0 | 10 | 94 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '`__wakeup()` | 0 | 10 | 94'
- en: '| `__toString()` | 15 | 181 | 460 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '`__toString()` | 15 | 181 | 460'
- en: '| `__invoke()` | 0 | 27 | 112 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '`__invoke()` | 0 | 27 | 112'
- en: '| `__set_state()` | 0 | 3 | 5 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '`__set_state()` | 0 | 3 | 5'
- en: '| `__clone()` | 0 | 32 | 68 |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '`__clone()` | 0 | 32 | 68'
- en: '| `__debugInfo()` | 0 | 0 | 2 |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '`__debugInfo()` | 0 | 0 | 2'
- en: The table is a result of a crude `function __[magic-method-name]` search across
    an entire codebase of individual platforms. It's hard to draw any conclusions
    on top of it, as platforms differ significantly in number of `.php` files. One
    thing we can say for sure--not all magic methods are equally popular. WordPress,
    for example, does not even seem to use the `__sleep()`, `__wakeup()`, and `__invoke()` methods,
    which are of importance in OOP. This might be because WordPress does not handle
    as many OO components as Magento, for example, which is much more of an OOP platform
    in architectural sense. Drupal sort of sits in the middle here, in terms of total
    `.php` file numbers and the magic methods it uses. Inconclusive or not, the preceding
    table outlines the active use of pretty much every magic method PHP has to offer.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 该表是对整个平台代码库中`function __[magic-method-name]`的粗略搜索结果。很难在此基础上得出任何结论，因为平台在`.php`文件数量上有显著差异。有一件事我们可以肯定——并非所有魔术方法都同样受欢迎。例如，WordPress似乎甚至没有使用`__sleep()`、`__wakeup()`和`__invoke()`方法，这些方法在面向对象编程中很重要。这可能是因为WordPress处理的OO组件没有像Magento那样多，后者在架构上更多地是一个面向对象的平台。Drupal在这里有点中庸，在总的`.php`文件数量和使用的魔术方法方面。无论是否有定论，上表概述了PHP提供的几乎每个魔术方法的活跃使用。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Throughout this chapter, we took a detailed look into each and every magic method
    PHP has to offer. The ease of their use is equally impressive as the power they
    bring to the language. Simply naming our class methods appropriately, we were
    able to tap into pretty much every aspect of an object state and behavior. While
    most of these magic methods are not something we will be using on a day-to-day
    basis, their existence empowers us with some nifty architectural styles and solutions
    that are not that easily possible with other languages.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细研究了PHP提供的每个魔术方法。它们的易用性和它们为语言带来的功能同样令人印象深刻。通过适当命名我们的类方法，我们能够利用对象状态和行为的几乎每个方面。虽然这些魔术方法大多数情况下不是我们日常使用的东西，但它们的存在赋予了我们一些巧妙的架构风格和解决方案，这些解决方案在其他语言中并不容易实现。
- en: Moving forward, we will step into the realm of CLI and the more elusive use
    of PHP.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 未来，我们将进入CLI领域和更难以捉摸的PHP使用。
