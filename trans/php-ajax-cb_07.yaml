- en: Chapter 7. Implementing Best Practices to Build Ajax Websites
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。实施构建Ajax网站的最佳实践
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Avoiding HTML markup-specific coding
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免HTML标记特定编码
- en: Building secure Ajax websites
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建安全的Ajax网站
- en: Building Search Engine Optimization (SEO)-friendly Ajax websites
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建搜索引擎优化（SEO）友好的Ajax网站
- en: Preserving browser history or un-breaking the browser's back button
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留浏览器历史记录或修复浏览器的后退按钮
- en: Implementing comet PHP and Ajax
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施彗星PHP和Ajax
- en: Getting things done is one thing and getting them done right is a whole other
    thing. JavaScript programmers often aim for best practices. As UI programming
    is gaining popularity, it demands better organization and practices. In this chapter,
    we'll see some common best practices.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 完成一件事是一回事，正确完成一件事是另一回事。JavaScript程序员经常追求最佳实践。随着UI编程的流行，它需要更好的组织和实践。在本章中，我们将看到一些常见的最佳实践。
- en: Avoiding HTML markup-specific coding
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免HTML标记特定编码
- en: In the unobtrusive JavaScript approach, where selector-based frameworks such
    as jQuery play major role, the interaction between HTML content and JavaScript
    is done through CSS selectors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在无侵入式JavaScript方法中，基于选择器的框架（如jQuery）起着重要作用，HTML内容与JavaScript之间的交互是通过CSS选择器完成的。
- en: Getting ready
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'Let''s assume we have a container with ID `alert` and our intention is to hide
    it and its neighbors—meaning, hide all elements of its parent:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个ID为`alert`的容器，我们的意图是隐藏它及其相邻元素-也就是隐藏其父元素的所有元素：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So far, so good. But, from the point of code maintainability, this approach
    is wrong.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好。但是，从代码可维护性的角度来看，这种方法是错误的。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the Web 2.0 world, where the design of the site has to change periodically
    to give a feel of freshness to customers, UI designers have to work hard to bring
    in freshness and as well as better usability. For the preceding markup, let''s
    assume that the UI designer has added an extra border around the `alert` container.
    The easier approach on the CSS programmer''s part is to wrap the `alert` container
    with another container to get the border:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web 2.0世界中，网站的设计必须定期更改，以给客户带来新鲜感，UI设计师必须努力带来新鲜感和更好的可用性。对于前面的标记，让我们假设UI设计师在`alert`容器周围添加了额外的边框。CSS程序员更容易的方法是将`alert`容器包装在另一个容器中以获得边框：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, the previous JavaScript functionality doesn't work as expected. The CSS
    programmer has unknowingly broken the site—even though they were able to add another
    border around the `alert` container.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以前的JavaScript功能不像预期的那样工作。CSS程序员无意中破坏了网站-即使他们能够在`alert`容器周围添加另一个边框。
- en: 'This illustrates the need for protocols and standards among JavaScript and
    CSS programmers—so they don''t break the site unknowingly. This can be done by:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了JavaScript和CSS程序员之间协议和标准的必要性-这样他们就不会无意中破坏网站。这可以通过以下方式实现：
- en: Introducing protocols through naming conventions
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过命名约定引入协议
- en: Approaching the situations differently
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以不同方式处理情况
- en: How it works...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We'll see how naming conventions and a different approach will help us here.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到命名约定和不同方法如何帮助我们在这里。
- en: 'Introducing protocols through naming conventions:'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过命名约定引入协议：
- en: 'When the CSS programmer changes the HTML markup, there is no clue that the
    markup is associated with the JavaScript functionality. So, here come the naming
    convention and rules:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当CSS程序员更改HTML标记时，没有线索表明标记与JavaScript功能相关联。因此，命名约定和规则就出现了：
- en: All selectors that are used for Ajax purposes should be prefixed with `js-`
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有用于Ajax目的的选择器都应该以`js-`为前缀
- en: Whenever the markup is associated with JavaScript functionality, it has to be
    commented on at the PHP level (as a, HTML comment will be exposed to the end user)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当标记与JavaScript功能相关联时，必须在PHP级别进行注释（因为HTML注释将暴露给最终用户）
- en: 'Note that we can introduce more such protocols after making mutual agreements
    with the CSS programmers. As per our introduced protocol, the HTML markup will
    have to be changed to:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在与CSS程序员达成共识后，我们可以引入更多这样的协议。根据我们引入的协议，HTML标记将需要更改为：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Approaching the problem statement:'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理问题陈述：
- en: 'Instead of approaching the elements to be hidden through the parent of the
    `alert` container, if we directly refer the parent element, the issue probability
    is reduced:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们直接引用父元素而不是通过`alert`容器的父元素来隐藏元素，问题的可能性就会降低：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that, here, we haven't used the `parent()` method. In other words, if we
    can avoid markup-specific usage of the `parent()` and `children()` methods, we're
    relatively safe from getting a broken site.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这里，我们没有使用`parent()`方法。换句话说，如果我们可以避免`parent()`和`children()`方法对特定标记的使用，我们就相对不太容易使网站崩溃。
- en: There's more...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In general, it would be easy to find the usage of `parent()` and `children()`
    through code search. But, in case if the usage is triggered from an unknown place,
    we may hack the jQuery code to throw notices into the Firebug console.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，通过代码搜索很容易找到`parent()`和`children()`的用法。但是，如果使用是从未知位置触发的，我们可以修改jQuery代码以在Firebug控制台中抛出通知。
- en: console.warn()
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: console.warn()
- en: 'To warn the developer to not use it, we may peak into jQuery core''s `parent()`
    method and add a warning through Firebug''s console API:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了警告开发人员不要使用它，我们可以查看jQuery核心的`parent()`方法，并通过Firebug的控制台API添加警告：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Similarly, we may add a warning in the `children()` method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们可以在`children()`方法中添加一个警告：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Building secure Ajax websites
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建安全的Ajax网站
- en: Ajax itself doesn't create any security risk, but the approaches in getting
    a website to be Ajaxified may open up security risks. The risks are common for
    all web applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Ajax本身并不会产生任何安全风险，但是将网站变成Ajax化的方法可能会带来安全风险。这些风险对所有Web应用程序都是普遍的。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: We'll require a web browser with developer tools installed. Possible tools for
    this purpose are Firefox with Firebug.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个安装了开发人员工具的Web浏览器。此目的可能的工具包括带有Firebug的Firefox。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Some common security threats either in Ajax or non-Ajax web-based applications
    are XSS, SQL injection, and session hijacking. We'll see how they can be prevented.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ajax或非Ajax基于Web的应用程序中一些常见的安全威胁包括XSS、SQL注入和会话劫持。我们将看到它们如何被防止。
- en: '**XSS**'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**XSS**'
- en: 'XSS or cross-site scripting attack capitalizes on the ability to add script
    to the website through user inputs or by some means of hacking the URL. Let''s
    take the popular Twitter website that allows users to enter their bio details.
    Consider the following input for the **Bio** field:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: XSS或跨站脚本攻击利用了通过用户输入或某种方式通过URL进行网站脚本添加的能力。让我们以允许用户输入其个人简介的流行Twitter网站为例。考虑以下输入**Bio**字段：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If Twitter engineers allowed HTML execution, or didn''t sanitize entries before
    displaying them, it would prompt with an alert box with the text **XSS**. In a
    real-world scenario, it won''t be an alert box, but may be malicious activities
    such as mimicking user input through a known URL or stealing of user data or hijacking
    of a session:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Twitter工程师允许HTML执行，或者在显示它们之前没有对条目进行净化，它将提示一个带有文本**XSS**的警报框。在现实世界的情况下，它不会是一个警报框，而可能是恶意活动，比如通过已知URL模仿用户输入或窃取用户数据或劫持会话：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Usually, a hacker may not have direct access for the `updateUser.php` page;
    but the JavaScript code gets full access as it''s under current session scope.
    So, here, we must also look at our architectures:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，黑客可能无法直接访问`updateUser.php`页面；但是JavaScript代码可以完全访问，因为它在当前会话范围内。因此，在这里，我们还必须看看我们的架构：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With the ability to execute this malicious code, the hacker may start stealing
    browser cookies. Through the session ID available in a cookie, the hacker may
    hijack the user's session.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有了执行这个恶意代码的能力，黑客可能开始窃取浏览器cookie。通过cookie中的会话ID，黑客可能劫持用户的会话。
- en: '**Solution:**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'Possible solutions for XSS are:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: XSS的可能解决方案包括：
- en: '`strip_tags()`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strip_tags()`'
- en: But, it may not be a good solution when we have to display HTML inputs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当我们必须显示HTML输入时，这可能不是一个好的解决方案。
- en: HTML Purifier library [http://htmlpurifier.org/](http://htmlpurifier.org/)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML净化器库[http://htmlpurifier.org/](http://htmlpurifier.org/)
- en: This library can purify HTML codes and, so, is a better choice for XSS problems.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库可以净化HTML代码，因此对于XSS问题是一个更好的选择。
- en: '**Session hijacking**'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**会话劫持**'
- en: As explained previously, the hacker may steal the cookie data and thus obtain
    the session ID of the user. When the hacker sets his/her browser's session value
    through cookie editing tools, the hacker will get access to the other user's session.
    This threat is usually common when the server or script is programmed to use same
    session ID for all communications.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，黑客可能窃取cookie数据，从而获取用户的会话ID。当黑客通过cookie编辑工具设置其浏览器的会话值时，黑客将获得对其他用户会话的访问权限。当服务器或脚本被编程为对所有通信使用相同的会话ID时，这种威胁通常很常见。
- en: '**Solution:**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'A possible quick solution is to generate a new session ID for every request
    with:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的快速解决方案是为每个请求生成一个新的会话ID：
- en: '`session_regenerate_id()`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`session_regenerate_id()`'
- en: '**SQL Injection**'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SQL注入**'
- en: 'When an SQL query is acting upon user inputs to get some results, and if the
    user inputs are not properly sanitized, it opens up the possibility of changing
    the SQL query. For example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当SQL查询根据用户输入来获取一些结果，并且如果用户输入没有得到适当的净化，它就会打开改变SQL查询的可能性。例如：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The previous code is a newbie''s code for login validation for username and
    password combination. This fails terribly when:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码是一个新手的代码，用于验证用户名和密码组合的登录。当发生以下情况时，这种方法会失败得很惨：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As these expand the query to be true due to `OR 1=1` injection:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`OR 1=1`注入而扩展查询为真：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Solution:**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'The only bulletproof solution for SQL injection is prepared statements available
    with the `mysqli` extension and PDO wrappers:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入的唯一防弹解决方案是使用`mysqli`扩展和PDO包中提供的准备好的语句：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Also, we must never store passwords in plaintext—we must store only salted hashes
    in the database. This way, we can avoid the passwords being exposed to an attacker
    in plain text when he/she somehow gains access to the database. Previously, developers
    used MD5 and then SHA-512 hash functions, but now bcrypt alone is recommended.
    This is because, with bcrypt, more time is required to crack the original password
    than with any other hashing algorithms.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们绝不能以明文形式存储密码——我们必须只在数据库中存储加盐哈希。这样，当攻击者以某种方式获得对数据库的访问权限时，我们可以避免密码以明文形式暴露给攻击者。以前，开发人员使用MD5，然后是SHA-512哈希函数，但现在只推荐bcrypt。这是因为，与其他哈希算法相比，使用bcrypt需要更多的时间来破解原始密码。
- en: Common mistakes on Ajax applications
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ajax应用程序的常见错误
- en: '**Client side-only decision:**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**仅客户端决策：**'
- en: Client side-only validation, data binding, and decision making are the very
    common mistakes with Ajax applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 仅客户端验证、数据绑定和决策是Ajax应用程序的常见错误。
- en: Client side-only validation can easily be broken by disabling JavaScript or
    attacking the URL through direct request via cURL.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 仅客户端验证可以很容易地通过禁用JavaScript或通过cURL直接请求攻击URL来破坏。
- en: In the shopping cart, the discount for coupons or coupon validation has to be
    done at the server end. For example, if the shopping cart page offers a discount
    for coupon codes, the validity of the coupon code has to be decided at the server
    end. It would be a poor approach to check the pattern of the coupon code in the
    client-side JavaScript—the user could find out the coupon code pattern by looking
    at the JavaScript code and generate any number of coupons! Similarly, the final
    amount to be paid has to be decided at the server end. It is also a poor approach
    to keep the final payable amount in a hidden form field or read-only input field
    without validating the payable amount and paid amount on placing orders. It is
    very easy to change any form fields—either hidden or read-only—through browser
    extensions such as Firebug and Web Developer extension.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在购物车中，优惠券的折扣或优惠券验证必须在服务器端完成。例如，如果购物车页面提供优惠券代码的折扣，优惠券代码的有效性必须在服务器端决定。在客户端JavaScript中检查优惠券代码的模式是一个不好的方法——用户可以通过查看JavaScript代码找出优惠券代码的模式并生成任意数量的优惠券！同样，要支付的最终金额必须在服务器端决定。在下订单时，将最终应付金额保留在隐藏的表单字段或只读输入字段中而不验证应付金额和已付金额是一个不好的方法。很容易通过浏览器扩展（如Firebug和Web
    Developer扩展）更改任何表单字段——无论是隐藏的还是只读的。
- en: '**Solution:**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: The solution is to always decide on the server end rather than on the client
    side. Remember that anything—even cryptic logic—wrapped in JavaScript is exposed
    to the world already.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是始终在服务器端决定而不是在客户端。请记住，即使是包装在JavaScript中的任何东西——甚至是神秘的逻辑——也已经暴露给了世界。
- en: '**Code architecture problem:**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码架构问题：**'
- en: Poorly architected code and code with poor logic are a great risk. They often
    expose unexpected data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕的架构代码和逻辑不良的代码是一个很大的风险。它们经常暴露意外的数据。
- en: Let's take`http://example.com/user.php?field=email&id=2`. This script is written
    to return the value of the field referred by the `field` param for a given `id`
    from the users table. The unexpected attack for this code architecture is the
    ability to expose any field, including password and other sensitive data by using,
    for example, `http://example.com/user.php?field=passwd&id=2`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看`http://example.com/user.php?field=email&id=2`。这个脚本被编写来返回用户表中给定`id`的`field`参数引用的值。这个代码架构的意外攻击是能够通过例如`http://example.com/user.php?field=passwd&id=2`来暴露任何字段，包括密码和其他敏感数据。
- en: Other such data exposure possibilities arise through web services that are common
    in Web 2.0 websites. When there's no limit on access to data, users can steal
    it through web services, even when they can't access it in the main websites.
    Web services usually expose data in JSON or XML and that allows hackers to easily
    tap in.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 其他这样的数据暴露可能性是通过Web 2.0网站中常见的Web服务产生的。当对数据访问没有限制时，用户可以通过Web服务窃取数据，即使他们无法在主要网站上访问它。Web服务通常以JSON或XML的形式暴露数据，这使得黑客可以轻松地进行窃取。
- en: '**Solution:**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'The solutions for these issues are:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的解决方案是：
- en: '**Whitelisting and blacklisting requests:**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**白名单和黑名单请求：**'
- en: By maintaining a list of requests that can be allowed or denied, the attack
    can be minimized.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过维护一个可以允许或拒绝的请求列表，可以最小化攻击。
- en: '**Throttling of requests:**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求的限制：**'
- en: The request can be rate-limited with access tokens so that hackers can't pull
    more data than allowed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请求可以通过访问令牌进行速率限制，这样黑客就无法获取更多的数据。
- en: '**Improving the code architecture from the beginning:**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从一开始改进代码架构：**'
- en: When the architecture and framework are planned from the beginning to target
    Ajax and Web 2.0, these issues can be minimized. Obviously, every architecture
    may have its own problems.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当架构和框架从一开始就计划针对Ajax和Web 2.0时，这些问题可以被最小化。显然，每种架构都可能有自己的问题。
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: XSS is the ability to execute JavaScript code on other domains when other users
    view the pages. Through this, an attacker may execute/trigger unexpected URLs.
    Also, an attacker can steal the session cookie and send it to their own webpage.
    Once the session cookie is available on the attacker's webpage, he or she can
    use it to hijack the session—without needing to know other users' login details.
    When SQL statements are not properly escaped, the original intended statement
    can be altered through form inputs; this is referred as SQL injection.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: XSS是在其他用户查看页面时执行JavaScript代码的能力。通过这种方式，攻击者可以执行/触发意外的URL。此外，攻击者可以窃取会话cookie并将其发送到自己的网页。一旦会话cookie在攻击者的网页上可用，他或她就可以使用它来劫持会话——而无需知道其他用户的登录详细信息。当SQL语句没有得到适当的转义时，原始的预期语句可以通过表单输入进行更改；这被称为SQL注入。
- en: 'The following table shows the same origin policy followed in web browsers when
    handling Ajax requests from [http://www.example.com/page.html](http://www.example.com/page.html)
    to different URLs:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了Web浏览器在处理从[http://www.example.com/page.html](http://www.example.com/page.html)到不同URL的Ajax请求时遵循的同源策略：
- en: '| URL | Access |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| URL | 访问 |'
- en: '| --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `http://subdomain.example.com/page.htm` | Not allowed. Different host |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `http://subdomain.example.com/page.htm` | 不允许。不同的主机 |'
- en: '| `http://example.com/page.html` | Not allowed. Different host |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `http://example.com/page.html` | 不允许。不同的主机 |'
- en: '| `http://www.example.com:8080/page.html` | Not allowed. Different port |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `http://www.example.com:8080/page.html` | 不允许。不同的端口 |'
- en: '| `"http://www.example.com/dir/page.html"` | Allowed. Same domain, protocol,
    and port |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `"http://www.example.com/dir/page.html"` | 允许。相同的域，协议和端口 |'
- en: '| `https://www.example.com/page.html` | Not allowed. Different protocol |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `https://www.example.com/page.html` | 不允许。不同的协议 |'
- en: The policy is rigidly followed in web browsers to avoid any direct security
    risks in Ajax. Other possible security risks are common for all web-based applications
    and arise out of common mistakes. Through proper security audits, we may avoid
    further risks.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web浏览器中严格遵循政策以避免Ajax中的任何直接安全风险。其他可能的安全风险对所有基于Web的应用程序都是普遍的，并源于常见的错误。通过适当的安全审计，我们可以避免进一步的风险。
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is usually easier to avoid security risks through automated audit tools than
    manual code inspection. There are few open source tools available to mitigate
    the security issues.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通过自动化审核工具来避免安全风险比手动代码检查更容易。有一些开源工具可用于减轻安全问题。
- en: Exploit-Me
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Exploit-Me
- en: Exploit-Me, available at [http://labs.securitycompass.com/index.php/exploit-me/](http://labs.securitycompass.com/index.php/exploit-me/),
    is a set of security-related Firefox extensions for testing XSS, SQL injection,
    and access vulnerabilities. This is a powerful open source approach to quickly
    audit the website.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Exploit-Me，网址为[http://labs.securitycompass.com/index.php/exploit-me/](http://labs.securitycompass.com/index.php/exploit-me/)，是一套用于测试XSS、SQL注入和访问漏洞的安全相关Firefox扩展。这是一种快速审核网站的强大的开源方法。
- en: WebInspect
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WebInspect
- en: The WebInspect web security audit tool from HP is an enterprise audit tool that
    scans for a lot of vulnerabilities and security vectors. It's available at [https://www.fortify.com/products/web_inspect.html](http://https://www.fortify.com/products/web_inspect.html).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: HP的WebInspect网络安全审核工具是一种企业审核工具，可扫描许多漏洞和安全向量。网址为[https://www.fortify.com/products/web_inspect.html](http://https://www.fortify.com/products/web_inspect.html)。
- en: Resources
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源
- en: 'There are few sites and tools dedicated to PHP security:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些专门致力于PHP安全的网站和工具：
- en: PHP Security Consortium, found at [http://phpsec.org/](http://phpsec.org/),
    provides security-related information.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP安全联盟，网址为[http://phpsec.org/](http://phpsec.org/)，提供与安全相关的信息。
- en: Suhosin of the Hardened-PHP Project, found at [http://www.hardened-php.org/suhosin/](http://www.hardened-php.org/suhosin/),
    provides a patch for common security vulnerabilities that are otherwise possible
    in a normal PHP build.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hardened-PHP项目的Suhosin，网址为[http://www.hardened-php.org/suhosin/](http://www.hardened-php.org/suhosin/)，提供了一个补丁，用于修补正常PHP构建中可能存在的常见安全漏洞。
- en: '`mod_security` Apache mod, available at [http://www.modsecurity.org/](http://www.modsecurity.org/),
    protects the server from common security attacks.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mod_security` Apache模块，网址为[http://www.modsecurity.org/](http://www.modsecurity.org/)，可以保护服务器免受常见的安全攻击。'
- en: Building SEO-friendly Ajax websites
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建SEO友好的Ajax网站
- en: On the Internet, websites and their business models mostly rely on search engines.
    Say, for example, when a user is searching for the keyword "book publishing" in
    the Google search engine, if Packt's website is listed on the first page of results,
    it will be an advantage for Packt—especially when its business model relies on
    Internet users.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上，网站及其商业模式大多依赖于搜索引擎。例如，当用户在Google搜索引擎中搜索关键词“图书出版”时，如果Packt的网站出现在结果的第一页，这对Packt来说将是一个优势，特别是当其商业模式依赖于互联网用户时。
- en: 'Search engines, such as Google, order the result page based on a number of
    factors, referred to as algorithms. These are: keyword density on the page, trusted
    inwards links to the page, popularity of the website, and so on. All these depend
    on how far the search engine''s spider can crawl (or reach) the website''s content.
    If the website''s index page doesn''t have links to the website''s inner pages,
    has restricted access to inner pages, or doesn''t expose the inner pages through
    the `sitemap.xml` file that the spider looks for when crawling, the contents will
    not be indexed and can''t be searched.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索引擎，如谷歌，根据一些因素（称为算法）对结果页面进行排序。这些因素包括页面上的关键词密度、页面的受信任的内部链接、网站的流行度等。所有这些都取决于搜索引擎的蜘蛛能够爬取（或到达）网站的内容的程度。如果网站的索引页面没有链接到网站的内部页面，对内部页面有限制访问，或者没有通过搜索引擎蜘蛛在爬取时查找的`sitemap.xml`文件暴露内部页面，那么这些内容将不会被索引，也无法被搜索到。
- en: The challenge with Web 2.0 websites that rely on search engine results for their
    business model is that they have to employ modern Ajax approaches for end-user
    usability and retention but also need to have content that is accessible and crawlable
    by search engine spiders. Enter Ajax and SEO.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖搜索引擎结果进行其商业模式的Web 2.0网站面临的挑战是，它们必须采用现代的Ajax方法来提高最终用户的可用性和留存率，但也需要具有可以被搜索引擎蜘蛛访问和爬取的内容。这就是Ajax和SEO的作用。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We'll require progressive enhancement through an unobtrusive JavaScript approach
    for developing search engine-friendly websites. This approach and terminology
    are explained next.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过一种不显眼的JavaScript方法来逐步增强开发搜索引擎友好的网站。下面将解释这种方法和术语。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: The easier approach to adopt SEO-friendly Ajax is progressive enhancement. This
    facilitates the pages being accessible for anyone—including someone who doesn't
    use the JavaScript engine in their browser.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 采用SEO友好的Ajax的更容易的方法是逐步增强。这使得页面对任何人都可以访问，包括那些不使用浏览器中的JavaScript引擎的人。
- en: 'To understand the concept, let''s take a case where we have a tabbed Ajax UI
    and tabs are loaded from different remote pages:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个概念，让我们来看一个案例，我们有一个带有标签的Ajax UI，标签是从不同的远程页面加载的：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As shown previously, each tab's contents are loaded from `page1.html, page2.html`,
    and so on. But, when checking the HTML source, the URL from where the contents
    are loaded is not known; the URLs are formed in JavaScript code, and content is
    dynamically loaded. As a majority of the search engine crawlers don't support
    the JavaScript engine, and can't support it at least for the moment, they'll miss
    out the content. Only when the crawler can "view" the content, can it be searchable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个标签页的内容都是从`page1.html、page2.html`等加载的。但是，在检查HTML源代码时，无法知道内容加载的URL；这些URL是在JavaScript代码中形成的，并且内容是动态加载的。由于大多数搜索引擎爬虫不支持JavaScript引擎，并且至少目前无法支持它，它们将错过内容。只有当爬虫可以“查看”内容时，它才能被搜索到。
- en: 'So, for the right search engine and SEO friendliness, we have the following
    approaches:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于正确的搜索引擎和SEO友好性，我们有以下方法：
- en: 'Cloaking:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐匿：
- en: This is the terminology used for presenting different content to the search
    engine spider by sniffing the user agent. But, search engines such as Google ban
    sites that cloak their contents, to improve search engine quality.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过嗅探用户代理向搜索引擎蜘蛛呈现不同内容的术语。但是，谷歌等搜索引擎会禁止对其内容进行隐匿的网站，以提高搜索引擎质量。
- en: '`Sitemap.xml:`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sitemap.xml:`'
- en: Presenting links for all internal links in `Sitemap.xml` may improve search
    engine accessibility. `Sitemap.xml` is the standard for exposing site links to
    Google. But, this is not sufficient and shouldn't accidentally be mingled with
    cloaking.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Sitemap.xml` 中为所有内部链接提供链接可能会提高搜索引擎的可访问性。`Sitemap.xml` 是向谷歌公开站点链接的标准。但是，这还不够，并且不应该意外地与隐匿混合在一起。
- en: 'Inline tabs:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联选项卡：
- en: By dumping all the content in a single entry page and employing hide and show,
    we can improve search engine accessibility. But, from the search engine optimization
    perspective, this solution fails as there won't be enough pages for the search
    engine spider to look for.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将所有内容倾倒在单个入口页面并使用隐藏和显示，我们可以改善搜索引擎的可访问性。但是，从搜索引擎优化的角度来看，这种解决方案失败了，因为搜索引擎蜘蛛找不到足够的页面。
- en: 'Progressive enhancements:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渐进增强：
- en: It is the approach by which a website will be accessible by all browsers. Ajax
    enhancements won't hamper the visibility/accessibility for non-JavaScript browsers.
    So far, this is the best method and, when combined with `Sitemap.xml`, can give
    better search engine visibility.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种网站将被所有浏览器访问的方法。Ajax 增强不会影响非 JavaScript 浏览器的可见性/可访问性。到目前为止，这是最好的方法，当与 `Sitemap.xml`
    结合使用时，可以提供更好的搜索引擎可见性。
- en: 'Now, let''s see how the tab system can be done by the progressive enhancement
    approach. For that, we''re going to use jQuery UI''s tabs library:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看渐进增强方法如何实现选项卡系统。为此，我们将使用 jQuery UI 的选项卡库：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As noted previously, we're not hiding the links and they're always accessible.
    When JavaScript is not enabled, clicking on the links will take you to separate
    pages. This is how the search engines "view" the site. Search engines will index
    pages with separate URLs, such as `http://example.com/page1.html, http://example.com/page2.html`,
    and so on.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所指出的，我们并没有隐藏链接，它们始终是可访问的。当 JavaScript 未启用时，单击链接将带您到单独的页面。这就是搜索引擎“查看”网站的方式。搜索引擎将索引具有单独
    URL 的页面，例如 `http://example.com/page1.html, http://example.com/page2.html` 等等。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Hijax, in simple terms, means Hijack + Ajax. It is a progressive enhancement
    technique where normal links are "hijacked" and Ajax effects are applied to give
    the website an Ajaxified feel.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Hijax，简单来说，意味着 Hijack + Ajax。这是一种渐进增强技术，其中普通链接被“劫持”，并应用了 Ajax 效果，使网站具有 Ajax
    化的感觉。
- en: When JavaScript is enabled, jQuery UI tabs get hooked; it applies the Hijax
    approach and converts the links into a beautiful tabbed interface. It also Ajaxifies
    the tabbed links and, thereby, avoids a page refresh when a user clicks on the
    tab.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 JavaScript 时，jQuery UI 选项卡会被挂钩；它应用 Hijax 方法，并将链接转换为漂亮的选项卡界面。它还将选项卡链接 Ajax
    化，从而在用户单击选项卡时避免页面刷新。
- en: More about jQuery UI tabs is covered in the *Creating tab navigation* recipe
    in [Chapter 3](ch03.html "Chapter 3. Useful Tools Using jQuery"),*Useful Tools
    Using jQuery*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 jQuery UI 选项卡的更多信息，请参阅 [第 3 章](ch03.html "第 3 章。使用 jQuery 的有用工具") 中的 *创建选项卡导航*
    配方，*使用 jQuery 的有用工具*。
- en: Google's proposal
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 谷歌的建议
- en: 'As of now, the previous, degradable Ajax approach is widely accepted practice
    for search-engine friendly Ajax. But, one thing to note is that when a user searches
    for the content of `page2.html`, the search engine will display the link as `http://example.com/page2.html`.
    For normal users with JavaScript-enabled browsers with Ajax experience, such direct
    links won''t be exposed. So, to have a consistent URL for all users, Google has
    proposed a solution. This technique, that is now referred to as **hashbang**,
    requires all Ajax URL hashes to be prefixed with `!` and a mechanism to access
    Ajax page content, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，先前的退化 Ajax 方法是搜索引擎友好的 Ajax 的广泛接受的做法。但是，需要注意的一点是，当用户搜索 `page2.html` 的内容时，搜索引擎将显示链接为
    `http://example.com/page2.html`。对于启用 JavaScript 的浏览器和具有 Ajax 经验的普通用户来说，这样的直接链接不会被暴露。因此，为了所有用户都有一致的
    URL，谷歌提出了一个解决方案。这种技术，现在被称为 **hashbang**，要求所有 Ajax URL 哈希都以 `!` 为前缀，并提供访问 Ajax
    页面内容的机制，如下所示：
- en: '`http://example.com/index.html#page1` has to be changed to `http://example.com/index.html#!page1`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://example.com/index.html#page1` 必须更改为 `http://example.com/index.html#!page1`。'
- en: When Google identifies an Ajax URL such as `http://example.com/index.html#!page1`
    it will crawl `http://example.com/index.html?_escaped_fragment_=page1`. This URL
    has to provide the Ajax content.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当谷歌识别到类似 `http://example.com/index.html#!page1` 的 Ajax URL 时，它将爬取 `http://example.com/index.html?_escaped_fragment_=page1`。这个
    URL 必须提供 Ajax 内容。
- en: When Google lists the URL in a search result page, it will display the Ajax
    URL `http://example.com/index.html#!page1`.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当谷歌在搜索结果页面中列出 URL 时，它将显示 Ajax URL `http://example.com/index.html#!page1`。
- en: In this way, all users can use the same URL to access the site.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，所有用户都可以使用相同的 URL 访问网站。
- en: Preserving browser history or un-breaking the browser's back button
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留浏览器历史或修复浏览器的返回按钮
- en: '![Preserving browser history or un-breaking the browser''s back button](graphics/3081_07_01.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![保留浏览器历史或修复浏览器的返回按钮](graphics/3081_07_01.jpg)'
- en: 'By underlying concept, Ajax lets the user view pages without a whole browser
    refresh. The subsequent browser calls are routed through XHR requests and the
    results are pushed to the browser window. In this scenario, there are two major
    usability concerns from the user''s point of view: first, the particular content
    cannot be bookmarked—as we have only one URL from where we have browsed subsequent
    pages without a browser refresh; second, the user cannot click the back button
    to return to browse previous content—as the page state has not changed in the
    browser.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 根据基本概念，Ajax 允许用户在不刷新整个浏览器的情况下查看页面。随后的浏览器调用通过 XHR 请求路由，并将结果推送到浏览器窗口。在这种情况下，从用户的角度来看，有两个主要的可用性问题：首先，特定内容无法被书签标记
    - 因为我们只有一个 URL，可以从中浏览后续页面而不刷新浏览器；其次，用户无法单击返回按钮返回以前的内容 - 因为页面状态在浏览器中没有改变。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll require a browser with Ajax components to test the functionality and a
    browser that supports the `window.onhashchange` event and HTML5's `window.history.pushState()`
    method to compare.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个带有 Ajax 组件的浏览器来测试功能，以及一个支持 `window.onhashchange` 事件和 HTML5 的 `window.history.pushState()`
    方法来进行比较。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: There are many jQuery plugins available to solve this issue. The jQuery History
    plugin by Benjamin Arthur Lupton, available at [http://www.balupton.com/projects/jquery-history](http://www.balupton.com/projects/jquery-history),
    handles history mechanism by all new methods and also provides a hack for older
    browsers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多jQuery插件可用于解决此问题。由Benjamin Arthur Lupton开发的jQuery History插件，可在[http://www.balupton.com/projects/jquery-history](http://www.balupton.com/projects/jquery-history)上获得，通过所有新方法处理历史机制，并为旧版浏览器提供了一个hack。
- en: 'Consider this HTML snippet with links to subpages:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下HTML片段，其中包含指向子页面的链接：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s the snippet to handle the state through jQuery History plugin:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过jQuery History插件处理状态的片段：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The plugin offers other methods to manually change the state and also triggers
    the state handler.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件提供其他方法来手动更改状态，并触发状态处理程序。
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that when the user clicks the link `"#/about`" the state would change to
    `/about`. But, if we programmatically want to change the state, say when a user
    clicks on the `div` instead of `anchor`, as shown previously, the `go()` method
    can be used.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当用户点击链接`"#/about"`时，状态将更改为`/about`。但是，如果我们希望以编程方式更改状态，例如当用户点击`div`而不是`anchor`时，如前所示，可以使用`go()`方法。
- en: 'When the state shouldn''t be visible to the user, but we require to trigger
    the state handler, the `trigger()` method is useful:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态不应对用户可见，但我们需要触发状态处理程序时，`trigger()`方法很有用：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As we noted, the browsers don''t save the state of Ajax requests, and so, the
    back button, browser history, and bookmarking don''t work usually. A tempting
    quick fix is to use the following JavaScript code that changes the URL in the
    browser:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所指出的，浏览器不保存Ajax请求的状态，因此，后退按钮，浏览器历史记录和书签通常不起作用。一个诱人的快速解决方法是使用以下JavaScript代码来更改浏览器中的URL：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The problem with this code is that it will reload the browser window and, thus,
    will defeat the purpose of Ajax.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题是它会重新加载浏览器窗口，因此会破坏Ajax的目的。
- en: '**Easier pushState() approach:**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**更简单的pushState()方法：**'
- en: In browsers that support HTML5 specifications, we may use
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持HTML5规范的浏览器中，我们可以使用
- en: '`window.history.pushState()`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.history.pushState()`'
- en: '`window.history.replaceState()`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.history.replaceState()`'
- en: '`window.onpopstate`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.onpopstate`'
- en: '`window.history.pushState()` allows us to change the URL in the browser but
    without letting the browser reload the page. The function takes three parameters:
    state object, title, and URL.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.history.pushState()`允许我们更改浏览器中的URL，但不会让浏览器重新加载页面。该函数接受三个参数：状态对象，标题和URL。'
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We also have `window.history.replaceState()` that will work similarly to `pushState()`,
    but without adding a new history entry, it will replace current URL.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有`window.history.replaceState()`，它将类似于`pushState()`工作，但不会添加新的历史记录条目，它将替换当前URL。
- en: The `window.onpopstate` event gets triggered on every state change, that is,
    when a user hits the back and forward buttons. Once the page gets reloaded, the
    `popstate` event would stop fire for the previous state preserved before page
    reload. In order to access those states, we may use `window.history.state` that
    gives access to states before page reload.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.onpopstate`事件在每次状态更改时触发，即当用户点击后退和前进按钮时。页面重新加载后，`popstate`事件将停止为页面重新加载之前保留的上一个状态触发。为了访问这些状态，我们可以使用`window.history.state`，它可以访问页面重新加载之前的状态。'
- en: 'The following snippet shows how these methods can be clubbed for a quick browser
    history solution:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段显示了如何将这些方法组合在一起以快速解决浏览器历史记录问题：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**onhashchange approach:**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**onhashchange方法：**'
- en: The prevailing approach to solve the browser history issue is through URL hashes
    that look like `#foo`. The major motivation to use a hash is that changing it
    through `location.hash` would not refresh the page (unlike `location.href)` and
    would also add an entry in browser history, for some browsers. But, when the user
    hit the back or forward button, there was no easy mechanism to see if the URL
    hash has been changed. The `window.onhashchange` event has been introduced in
    newer browsers and will get executed when a hash change occurs.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 解决浏览器历史记录问题的主要方法是通过看起来像`#foo`的URL哈希。使用哈希的主要动机是，通过`location.hash`更改它不会刷新页面（不像`location.href`），并且对于某些浏览器还会在浏览器历史记录中添加一个条目。但是，当用户点击后退或前进按钮时，没有简单的机制来查看URL哈希是否已更改。`window.onhashchange`事件已经在较新的浏览器中引入，并且在哈希更改时将被执行。
- en: The portability hack for the `hashchange` event is to constantly poll the hash
    changes through the `setInterval()` method. The shorter the polling interval,
    the better the responsiveness, but using too short a value will affect the performance.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashchange`事件的可移植性hack是通过`setInterval()`方法不断轮询哈希更改。轮询间隔越短，响应性越好，但使用太短的值会影响性能。'
- en: '**iframe hack approach:**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**iframe hack方法：**'
- en: Some browsers, especially IE6, don't save state on hash changes. So, here, the
    workaround is to create an invisible `iframe` element and change its `src` attribute
    to track state. This is because the browser tracks the state for `iframe src`
    changes. So, when a user hits the browser's back or forward button, they have
    to poll the `src` attribute of `iframe` to update the UI.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一些浏览器，特别是IE6，在哈希更改时不保存状态。因此，在这里，解决方法是创建一个不可见的`iframe`元素，并更改其`src`属性以跟踪状态。这是因为浏览器跟踪`iframe
    src`更改的状态。因此，当用户点击浏览器的后退或前进按钮时，他们必须轮询`iframe`的`src`属性以更新UI。
- en: '**Combining all approaches:**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**结合所有方法：**'
- en: For better browser compatibility and performance, it's essential to combine
    all of the previous approaches. The jQuery History plugin abstracts all these
    approaches and provides better functionality.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好的浏览器兼容性和性能，将所有先前的方法结合起来是至关重要的。jQuery History插件抽象了所有这些方法，并提供了更好的功能。
- en: Implementing comet PHP and Ajax
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现彗星PHP和Ajax
- en: In traditional client-server communication over HTTP, for every response from
    a server, a request is made by the client. In other words, there is no response
    without a request.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的客户端-服务器通过HTTP通信中，对于服务器的每个响应，客户端都会发出请求。换句话说，没有请求就没有响应。
- en: '![Implementing comet PHP and Ajax](graphics/3081_07_02.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![实现彗星PHP和Ajax](graphics/3081_07_02.jpg)'
- en: Comet, Ajax Push, Reverse Ajax, Two-way-web, HTTP Streaming, or HTTP server
    push are the collective terms used to refer to the implementation of instantaneous
    data changes pushed from the server. Unlike in traditional communication, here,
    the request from the client is made once and all the data/responses are pushed
    from the server—without further request calls from the client.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Comet、Ajax Push、Reverse Ajax、双向Web、HTTP流或HTTP服务器推送是用来指代从服务器推送即时数据更改的实现的集体术语。与传统通信不同，在这里，客户端的请求只需一次，所有数据/响应都是从服务器推送的，而不需要客户端进一步的请求调用。
- en: '![Implementing comet PHP and Ajax](graphics/3081_07_03.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![实现彗星PHP和Ajax](graphics/3081_07_03.jpg)'
- en: Through comet, we can create Ajax chat and other live applications. Before the
    introduction of HTML5's WebSocket API, JavaScript developers had to go for hacks,
    such as using `iframe`, long polling Ajax, and so on
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过彗星，我们可以创建Ajax聊天和其他实时应用程序。在HTML5的WebSocket API引入之前，JavaScript开发人员不得不使用`iframe`、长轮询Ajax等方法进行黑客攻击
- en: 'There are many comet technologies available, including a pure JavaScript approach
    over Apache web server. But, when looking at performance and approaches, the open
    source APE (Ajax Push Engine) technology looks promising. APE has two components:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可用的彗星技术，包括在Apache Web服务器上的纯JavaScript方法。但是，在性能和方法方面，开源的APE（Ajax Push Engine）技术看起来很有前途。APE有两个组件：
- en: APE Server
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: APE服务器
- en: APE JSF (APE JavaScript Framework)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: APE JSF（APE JavaScript框架）
- en: 'The server is written in C and the JavaScript framework is based on Mootools,
    but can also be used with other frameworks such as jQuery. APE Server modules
    are extensible through JavaScript code. It supports transport methods, such as
    Long Polling, XHR Streaming, JSONP, and Server Sent Events. Some of the mentioned
    advantages of APE Server are:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器是用C编写的，JavaScript框架基于Mootools，但也可以与其他框架一起使用，如jQuery。 APE服务器模块可以通过JavaScript代码进行扩展。它支持传输方法，如长轮询、XHR流、JSONP和服务器发送事件。APE服务器的一些优点包括：
- en: Apache-based solutions cannot do a real push
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Apache的解决方案无法进行真正的推送
- en: APE can handle more than 100k users
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: APE可以处理超过100,000个用户
- en: APE is faster than an Apache comet-based solution
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: APE比基于Apache的彗星解决方案更快
- en: APE saves lot of bandwith
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: APE节省了大量带宽
- en: APE provides more options than simple comet solutions
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: APE提供的选项比简单的彗星解决方案更多
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We'll require an APE Server for our comet experiments. An APE Server installed
    on Linux is recommended, though it can run on a Windows machine with VirutalBox.
    It can be downloaded from [http://www.ape-project.org/](http://www.ape-project.org/).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的彗星实验需要一个APE服务器。建议在Linux上安装APE服务器，尽管它也可以在带有VirutalBox的Windows机器上运行。它可以从[http://www.ape-project.org/](http://www.ape-project.org/)下载。
- en: We will have to configure the APE client script with server settings in `Build/uncompressed/apeClientJS.js:`
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不在`Build/uncompressed/apeClientJS.js`中配置APE客户端脚本的服务器设置：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll see how a simple comet client-server interaction can be done. We'll also
    see how the APE Server can be used to broadcast messages to clients over the comet
    setup. We need some basic understanding of APE terminologies before setting up
    the comet.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何进行简单的彗星客户端-服务器交互。我们还将看到如何使用APE服务器来通过彗星设置向客户端广播消息。在设置彗星之前，我们需要一些基本的APE术语理解。
- en: '**Pipe:**'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管道：**'
- en: 'Pipes are communication conduits to exchange data between the client and server
    and they are the core of the communication system. There are two main types of
    pipes:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是客户端和服务器之间交换数据的通信管道，是通信系统的核心。有两种主要类型的管道：
- en: Multi pipe or Channel
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多管道或频道
- en: Uni pipe or User
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Uni管道或用户
- en: A pipe is identified by a 32-character unique ID generated by a server called
    pubid.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 管道由服务器生成的名为pubid的32个字符的唯一ID标识。
- en: '**Channel:**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频道：**'
- en: 'A channel is a communication conduit that can be directly created by the server
    or by a user. It is automatically created if a user subscribes to a channel that
    doesn''t exist. Each channel has a list of properties and has two ways of working:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 频道是可以由服务器或用户直接创建的通信管道。如果用户订阅不存在的频道，则会自动创建频道。每个频道都有一系列属性，并且有两种工作方式：
- en: Interactive Channel
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式频道
- en: Non-Interactive Channel
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非交互式频道
- en: A user who subscribes to an existing interactive channel, will receive a list
    of all other users who have subscribed to that channel and can directly communicate
    with them via the channel pipe. In a non-interactive channel, the communication
    is read-only and users do not know each other, also, they can't communicate through
    the channel. The creation of a non-interactive channel can be initiated by prefixing
    the channel name with the * character.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅现有交互式频道的用户将收到所有其他订阅该频道的用户列表，并可以通过频道管道直接与它们进行通信。在非交互式频道中，通信是只读的，用户不互相认识，也不能通过频道进行通信。可以通过在频道名称前加上*字符来启动非交互式频道的创建。
- en: '**User:**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户：**'
- en: 'When a user connects to the APE, a pipe is created for communication with other
    entities, and a unique sessid is assigned to the pipe. That ID helps the server
    to identify the user that sends each command. A user can perform actions that
    allow them to:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户连接到APE时，将为与其他实体进行通信创建一个管道，并为管道分配一个唯一的sessid。该ID帮助服务器识别发送每个命令的用户。用户可以执行允许他们：
- en: Post a message on a pipe for a channel or another user
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在管道上为频道或其他用户发布消息
- en: Subscribe/join a channel
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅/加入频道
- en: Unsubscribe/leave a channel
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消订阅/离开频道
- en: Create a channel
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建频道
- en: 'Now, the code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，代码：
- en: '[PRE23]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code connects the client with the server and joins the user with
    a channel named `myChannel`. When a user joins the channel, it sends a test message
    to other users on the channel `myChannel`. Note that the message is shared through
    the channel name.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将客户端与服务器连接，并将用户加入名为`myChannel`的频道。当用户加入频道时，它会向频道`myChannel`上的其他用户发送测试消息。请注意，消息是通过频道名称共享的。
- en: 'To push some messages from the server side, APE offers a mechanism called `inlinepush`.
    This `inlinepush` can be triggered by invoking the APE Server''s URL:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从服务器端推送一些消息，APE提供了一种称为`inlinepush`的机制。这个`inlinepush`可以通过调用APE服务器的URL来触发：
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: APE's underlying protocol uses JSON for data transmission. Connection from client
    to server is initiated with APE's `start()` method. Joining a channel or creating
    a new channel is initiated with the `join()` method. Messages to other users available
    on the channel are then passed over the `send()` method. More than one browser
    window or tab should be opened to see the message transmitted from one window
    to the other windows.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: APE的底层协议使用JSON进行数据传输。从客户端到服务器的连接是通过APE的`start()`方法来初始化的。加入频道或创建新频道是通过`join()`方法来初始化的。然后通过`send()`方法将消息传递给频道上其他用户。应该打开多个浏览器窗口或标签页，以查看从一个窗口传输到其他窗口的消息。
- en: APE's `inlinepush` mechanism offers a way to push messages to the channel users
    without using a client. Such pushes can be initiated by invoking a JSON-encoded
    URL with commands. From PHP, such URLs can be triggered by cURL calls or a simple
    `file_get_contents()` call.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: APE的`inlinepush`机制提供了一种在不使用客户端的情况下向频道用户推送消息的方式。这样的推送可以通过调用带有命令的JSON编码的URL来启动。从PHP，这样的URL可以通过cURL调用或简单的`file_get_contents()`调用来触发。
