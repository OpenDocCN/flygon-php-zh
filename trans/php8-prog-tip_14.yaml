- en: '*Chapter 11*: Migrating Existing PHP Apps to PHP 8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：将现有PHP应用迁移到PHP 8'
- en: Throughout the book, you have been warned of potential code breaks. Unfortunately,
    there are not really any good tools available that can scan your existing code
    and check for potential code breaks. In this chapter, we take you through the
    development of a set of classes that form the basis of a PHP 8 **backward-compatible**
    (**BC**) break scanner. In addition, you learn the recommended process to migrate
    an existing customer PHP application to PHP 8.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，您已经被警告可能出现代码断裂的情况。不幸的是，目前没有真正好的工具可以扫描您现有的代码并检查潜在的代码断裂。在本章中，我们将带您了解一组类的开发过程，这些类构成了PHP
    8 **向后兼容**（**BC**）断裂扫描器的基础。此外，您还将学习将现有客户PHP应用迁移到PHP 8的推荐流程。
- en: After reading through this chapter and carefully studying the examples, you
    are much better equipped to handle a PHP 8 migration. With knowledge of the overall
    migration procedure, you gain confidence and are able to perform PHP 8 migrations
    with a minimal number of problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章并仔细研究示例后，您将更好地掌握PHP 8迁移。了解整体迁移过程后，您将更加自信，并能够以最少的问题执行PHP 8迁移。
- en: 'The topics covered in this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: Understanding development, staging, and production environments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解开发、暂存和生产环境
- en: Learning how to spot BC breaks before a migration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在迁移之前发现BC（向后兼容）断裂
- en: Performing the migration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行迁移
- en: Testing and troubleshooting the migration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和故障排除迁移
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To examine and run the code examples provided in this chapter, the minimum
    recommended hardware is the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查和运行本章提供的代码示例，最低推荐的硬件配置如下：
- en: An x86_64-based desktop PC or laptop
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于x86_64的台式PC或笔记本电脑
- en: 1 **gigabyte** (**GB**) free disk space
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 **千兆字节**（**GB**）的可用磁盘空间
- en: 4 GB of RAM
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4GB的RAM
- en: 500 **kilobits per second** (**Kbps**) or faster internet connection
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 500 **千比特每秒**（**Kbps**）或更快的互联网连接
- en: 'In addition, you will need to install the following software:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还需要安装以下软件：
- en: Docker
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Docker Compose
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Please refer to the *Technical requirements* section of [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013),
    *Introducing New PHP 8 OOP Features*, for more information on Docker and Docker
    Compose installation, as well as how to build the Docker container used to demonstrate
    the code explained in this book. In this book, we refer to the directory in which
    you restored the sample code for this book as `/repo`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Docker和Docker Compose安装的更多信息，以及如何构建用于演示本书中解释的代码的Docker容器，请参阅[*第1章*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013)的*技术要求*部分，介绍新的PHP
    8面向对象编程特性。在本书中，我们将您为本书恢复示例代码的目录称为`/repo`。
- en: The source code for this chapter is located at [https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices).
    We can now begin our discussion by having a look at environments used as part
    of the overall migration process.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于[https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices)。我们现在可以开始讨论使用作为整体迁移过程的一部分的环境。
- en: Understanding development, staging, and production environments
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解开发、暂存和生产环境
- en: The ultimate goal for a website update is to move the updated application code
    from development to production in as seamless a manner as possible. This movement
    of application code is referred to as **deployment**. Movement, in this context,
    involves copying application code and configuration files from one **environment**
    to another.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 网站更新的最终目标是以尽可能无缝的方式将更新的应用程序代码从开发环境移动到生产环境。这种应用程序代码的移动被称为**部署**。在这种情况下，移动涉及将应用程序代码和配置文件从一个**环境**复制到另一个环境。
- en: Before we get into the details of migrating an application to PHP 8, let's first
    have a look at what these environments are. Gaining an understanding of what form
    the different environments might take is critical to your role as a developer.
    With this understanding, you are in a better position to deploy your code to production
    with a minimal amount of errors.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论将应用程序迁移到PHP 8之前，让我们先看看这些环境是什么。了解不同环境可能采用的形式对于您作为开发人员的角色至关重要。有了这种理解，您就能更好地将代码部署到生产环境，减少错误的发生。
- en: Defining an environment
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义环境
- en: We use the word *environment* to describe a combination of software stacks that
    include the operating system, web server, database server, and PHP installation.
    In the past, the environment equated to a *server*. In this modern age, however,
    the term *server* is deceptive in that it implies a physical computer in a metal
    box sitting on a rack in some unseen server room. Today, this is more likely not
    going to be the case, given the abundance of cloud service providers and highly
    performant virtualization technologies (for example, Docker). Accordingly, when
    we use the term *environment*, understand this to mean either a physical or virtual
    server.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*环境*一词来描述包括操作系统、Web服务器、数据库服务器和PHP安装在内的软件堆栈的组合。过去，环境等同于*服务器*。然而，在现代，*服务器*这个术语是具有误导性的，因为它暗示着一个金属箱子中的物理计算机，放置在某个看不见的服务器房间的机架上。如今，鉴于云服务提供商和高性能的虚拟化技术（例如Docker）的丰富，这更有可能不是真实情况。因此，当我们使用*环境*这个术语时，请理解它指的是物理或虚拟服务器。
- en: 'Environments are generally classified into three distinct categories: **development**,
    **staging**, and **production**. Some organizations also provide a separate **testing**
    environment. Let''s first have a look at what is common across all environments.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 环境通常分为三个不同的类别：**开发**、**暂存**和**生产**。一些组织还提供单独的**测试**环境。让我们先看看所有环境中的共同点。
- en: Common components
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见组件
- en: It's important to note that what goes into all environments is driven by what
    is in the production environment. The production environment is the final destination
    of your application code. Accordingly, all other environments should match the
    operating system, database, web server, and PHP installation as closely as possible.
    Thus, for example, if the production environment enables the PHP OPCache extension,
    all other environments must enable this extension as well.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，所有环境中的内容都受生产环境的驱动。生产环境是应用程序代码的最终目的地。因此，所有其他环境应尽可能与操作系统、数据库、Web服务器和PHP安装匹配。因此，例如，如果生产环境启用了PHP
    OPCache扩展，所有其他环境也必须启用此扩展。
- en: All environments, including the production environment, need to have an operating
    system and PHP installation at a minimum. Depending on the needs of your application,
    it's also quite common to have a web server and database server installed. The
    type and version of the web and database server should match that of the production
    environment as closely as possible.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有环境，包括生产环境，至少需要安装操作系统和PHP。根据应用程序的需求，安装Web服务器和数据库服务器也是非常常见的。Web和数据库服务器的类型和版本应尽可能与生产环境匹配。
- en: As a general rule, the closer your development environment matches that of the
    production environment, the less chance there is of a bug cropping up after deployment.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，开发环境与生产环境越接近，部署后出现错误的几率就越小。
- en: We now look at what goes into a development environment.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看开发环境需要什么。
- en: Development environment
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发环境
- en: The development environment is where you initially develop and test your code.
    It is unique in that it has the tools needed for application maintenance and development.
    This would include housing a source code repository (for example, Git), as well
    as various scripts needed to start, stop, and reset the environment.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 开发环境是您最初开发和测试代码的地方。它具有应用程序维护和开发所需的工具。这包括存储源代码的存储库（例如Git），以及启动、停止和重置环境所需的各种脚本。
- en: Often the development environment will have scripts to trigger an automated
    deployment procedure. Such scripts could take the place of **commit hooks**, designed
    to activate when you issue a commit to your source code repository. One example
    of this is **Git Hooks**, script files that can be placed in the `.git/hooks`
    directory.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开发环境会有触发自动部署过程的脚本。这些脚本可以取代**提交钩子**，设计用于在提交到源代码存储库时激活。其中一个例子是**Git Hooks**，即可放置在`.git/hooks`目录中的脚本文件。
- en: Tip
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on Git Hooks, have a look at the documentation here: [https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Git Hooks的更多信息，请查看此处的文档：[https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)。
- en: The traditional development environment consisted of a personal computer with
    a database server, web server, and PHP. This conventional paradigm fails to take
    into account the variations that might be present in the target production environment.
    If you have 12 customers that you work with regularly, for example, it's highly
    unlikely that all 12 customers have exactly the same OS, database server, web
    server, and version of PHP! The *best practice* is to model the production environment
    as closely as possible in the form of a virtual machine or Docker container.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的开发环境包括个人计算机、数据库服务器、Web服务器和PHP。这种传统范式未能考虑到目标生产环境可能存在的变化。例如，如果您经常与12个客户合作，那么这12个客户几乎不可能拥有完全相同的操作系统、数据库服务器、Web服务器和PHP版本！*最佳实践*是尽可能模拟生产环境，可以采用虚拟机或Docker容器的形式。
- en: The code editor or **IDE** (**Integrated Development Environment**) is thus
    not located inside the development environment. Rather, you perform code creation
    and editing outside of the development environment. You would then push your changes
    locally either by directly copying files into the virtual development environment
    via a shared directory, or by committing changes to the source code repository,
    and then pulling the changes from inside the development environment virtual machine.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代码编辑器或**IDE**（集成开发环境）并不位于开发环境内。相反，您在开发环境之外进行代码创建和编辑。然后，您可以通过直接将文件复制到虚拟开发环境的共享目录，或者通过提交更改到源代码存储库，然后从开发环境虚拟机内拉取更改来本地推送更改。
- en: It's also appropriate to perform unit testing in the development environment.
    Developing unit tests will not only give you greater assurance that your code
    works in production, but is also a great way to spot bugs in the early stages
    of application development. And, of course, you need to do as much debugging as
    possible in the local environment! Catching and fixing a bug in development generally
    takes a tenth of the time you might spend fixing a bug found in production!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发环境进行单元测试也是合适的。开发单元测试不仅可以更好地保证您的代码在生产环境中运行，而且还是发现应用程序开发早期阶段的错误的好方法。当然，您需要在本地环境中尽可能多地进行调试！在开发中捕获和修复错误通常只需要在生产中发现错误所需的十分之一的时间！
- en: Let's now examine the staging environment.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看暂存环境。
- en: Staging environment
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暂存环境
- en: It's quite common for large application development projects to have multiple
    developers all working on the same code base. In this situation, using version
    control repositories is critical. The *staging* environment is where all of the
    developers upload their code after development environment testing and debugging
    phases are complete.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 大型应用程序开发项目通常会有多个开发人员共同在同一代码库上工作。在这种情况下，使用版本控制存储库至关重要。*暂存*环境是所有开发人员在开发环境测试和调试阶段完成后上传其代码的地方。
- en: The staging environment must be an *exact copy* of the production environment.
    You can visualize the staging environment as the last step on an assembly line
    in a car plant. This is where all of the various pieces coming from one or more
    development environments are fit into place. The staging environment is a prototype
    of how production should appear.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 暂存环境必须是生产环境的*精确副本*。你可以把暂存环境想象成汽车工厂装配线上的最后一步。这是所有来自一个或多个开发环境的各种部件安装到位的地方。暂存环境是生产应该出现的原型。
- en: It's important to note that often the staging server has direct internet access;
    however, it's usually located in a secure area that requires a password before
    you can gain access.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，暂存服务器通常可以直接访问互联网；然而，它通常位于一个需要密码才能访问的安全区域。
- en: Finally, let's have a look at the production environment.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看生产环境。
- en: Production environment
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生产环境
- en: The production environment is often maintained and hosted by the client directly.
    This environment is also referred to as the **live environment**. To make an analogy
    to a Bollywood production, if the development environment is practice, the staging
    environment is the dress rehearsal, and the production environment is the live
    show (perhaps minus the singing and dancing!).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境通常由客户直接维护和托管。这个环境也被称为**现场环境**。打个比方，如果开发环境是练习，暂存环境是彩排，那么生产环境就是现场演出（也许没有歌唱和舞蹈！）。
- en: The production environment has direct internet access but is protected by a
    firewall, and is often further protected by an intrusion detection and prevention
    system (for example, [https://snort.org/](https://snort.org/)). In addition, the
    production environment may be hidden behind a reverse proxy configuration that
    runs on an internet-facing web server. Otherwise, at least theoretically, the
    production environment should be an *exact clone* of the staging environment.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境可以直接访问互联网，但受到防火墙的保护，通常还受到入侵检测和防御系统的保护（例如，[https://snort.org/](https://snort.org/)）。此外，生产环境可能被隐藏在运行在面向互联网的Web服务器上的反向代理配置后面。否则，至少在理论上，生产环境应该是暂存环境的*精确克隆*。
- en: 'Now that you have an idea about the environments through which the application
    code moves on its way from development to production, let''s have a look at a
    critical first step in a PHP 8 migration: spotting potential BC code breaks.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对应用程序代码从开发到生产的环境有了一个概念，让我们来看看PHP 8迁移的一个关键第一步：发现潜在的BC代码中断。
- en: Learning how to spot BC breaks before a migration
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何在迁移前发现BC中断
- en: Ideally, you should go into the PHP 8 migration with an action plan in hand.
    A critical part of this action plan includes getting an idea of how many potential
    BC breaks exist in your current code base. In this section, we show you how to
    develop a BC break sniffer that automates the process of looking through hundreds
    of code files for potential BC breaks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该带着一个行动计划进入PHP 8迁移。这个行动计划的关键部分包括了解当前代码库中存在多少潜在的BC中断。在本节中，我们将向您展示如何开发一个自动化查找潜在BC中断的BC中断嗅探器。
- en: First, we'll step back and review what we've learned so far about BC issues
    that might arise in PHP 8.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下到目前为止关于PHP 8中可能出现的BC问题学到的东西。
- en: Gaining an overview of BC breaks
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取BC中断概述
- en: 'You already know, having read the previous chapters in this book, that potential
    code breaks originate from several sources. Let''s briefly summarize the general
    trends that might lead to code failure after a migration. Please note that we
    do not cover these topics in this chapter as these are the topics that have all
    been covered in earlier chapters in this book:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道，通过阅读本书的前几章，潜在的代码中断源自几个方面。让我们简要总结一下可能导致迁移后代码失败的一般趋势。请注意，我们在本章中不涵盖这些主题，因为这些主题在本书的早期章节中都已经涵盖过了：
- en: Resource-to-object migration
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源到对象的迁移
- en: Minimum versions for supporting OS libraries
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持OS库的最低版本
- en: '`Iterator` to `IteratorAggregate` migration'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterator`到`IteratorAggregate`的迁移'
- en: Removed functions
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已删除的函数
- en: Usage changes
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变化
- en: Magic method signature enforcement
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 魔术方法签名强制执行
- en: Many of the changes can be detected by adding a simple callback based upon `preg_match()`
    or `strpos()`. Usage changes are much more difficult to detect as at a glance
    there's no way for an automated break scanner to detect the result of usage without
    making extensive use of `eval()`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 许多变化可以通过添加基于`preg_match()`或`strpos()`的简单回调来检测。使用变化更难以检测，因为乍一看，自动断点扫描器无法在不广泛使用`eval()`的情况下检测使用结果。
- en: Let's now have a look at how a break scan configuration file might appear.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看一个中断扫描配置文件可能是什么样子。
- en: Creating a BC break scan configuration file
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个BC中断扫描配置文件
- en: A configuration file allows us to develop a set of search patterns independently
    of the BC break scanner class. Using this approach, the BC break scanner class
    defines the actual logic used to conduct the search whereas the configuration
    file provides a list of specific conditions along with a warning and suggested
    remedial actions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件允许我们独立于BC中断扫描器类开发一组搜索模式。使用这种方法，BC中断扫描器类定义了用于进行搜索的实际逻辑，而配置文件提供了一系列特定条件以及警告和建议的补救措施。
- en: Quite a few potential code breaks can be detected by simply looking for the
    presence of the functions that have been removed in PHP 8\. For this purpose,
    a simple `strpos()` search will suffice. On the other hand, a more complex search
    might require that we develop a series of callbacks. Let's first have a look at
    how configuration might be developed based on a simple `strpos()` search.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单查找已在PHP 8中删除的函数的存在来检测到许多潜在的代码中断。为此，简单的`strpos()`搜索就足够了。另一方面，更复杂的搜索可能需要我们开发一系列回调。让我们首先看看如何基于简单的`strpos()`搜索开发配置。
- en: Defining a simple strpos() search configuration
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义一个简单的strpos()搜索配置
- en: 'In the case of a simple `strpos()` search, all we need to do is to provide
    an array of key/value pairs, where the key is the name of the removed function,
    and the value is its suggested replacement. The search logic in the BC break scanner
    class can then do this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的`strpos()`搜索的情况下，我们只需要提供一个键/值对数组，其中键是被移除的函数的名称，值是它的建议替代品。BC破坏扫描器类中的搜索逻辑可以这样做：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will cover the full BC break scanner class implementation in the next section.
    For now, we just focus on the configuration file. Here''s how the first few `strpos()`
    search entries might appear:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中介绍完整的BC破坏扫描器类实现。现在，我们只关注配置文件。以下是前几个`strpos()`搜索条目可能出现的方式：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Unfortunately, some PHP 8 backward incompatibilities might prove beyond the
    abilities of a simple `strpos()` search. We now turn our attention toward detecting
    potential breaks caused by the PHP 8 resource-to-object migration.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，一些PHP 8向后不兼容性可能超出了简单的`strpos()`搜索的能力。我们现在将注意力转向检测由PHP 8资源到对象迁移引起的潜在破坏。
- en: Detecting BC breaks associated with is_resource()
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测与`is_resource()`相关的BC破坏
- en: In [*Chapter 7*](B16992_07_Final_JC_ePub.xhtml#_idTextAnchor162), *Avoiding
    Traps When Using PHP 8 Extensions*, in the *PHP 8 extension resource to object
    migration* section, you learned that there is a general trend in PHP away from
    resources and toward objects. As you may recall, this trend in and of itself does
    not pose any threat of a BC break. However, if, in confirming that the connection
    has been made, your code uses `is_resource()`, there is a potential for a BC break.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B16992_07_Final_JC_ePub.xhtml#_idTextAnchor162)，*在使用PHP 8扩展时避免陷阱*，在*PHP
    8扩展资源到对象迁移*部分，您了解到PHP中存在一种从资源到对象的普遍趋势。您可能还记得，这种趋势本身并不构成任何BC破坏的威胁。然而，如果您的代码在确认连接已建立时使用了`is_resource()`，就有可能发生BC破坏。
- en: In order to account for this BC break potential, our BC break scan configuration
    file needs to list any of the functions that formerly produced a resource but
    now produce an object. We then need to add a method in the BC break scan class
    (discussed next) that makes use of this list.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了考虑这种BC破坏的潜在性，我们的BC破坏扫描配置文件需要列出以前产生资源但现在产生对象的任何函数。然后我们需要在BC破坏扫描类中添加一个使用此列表的方法（下面讨论）。
- en: 'This is how the potential configuration key of affected functions might appear:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是受影响函数潜在配置键可能出现的方式：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the break scan class, all we need to do is to first confirm that `is_resource()`
    is called, and then check to see if any of the functions listed under the `BreakScan::KEY_RESOURCE`
    array are present.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在破坏扫描类中，我们只需要首先确认是否调用了`is_resource()`，然后检查`BreakScan::KEY_RESOURCE`数组下列出的任何函数是否存在。
- en: We now turn out attention to **magic method signature** violations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将注意力转向**魔术方法签名**违规。
- en: Detecting magic method signature violations
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测魔术方法签名违规
- en: PHP 8 strictly enforces magic method signatures. If your classes use loose definitions
    where you do not perform method signature data typing, and if you do not define
    a return value data type for magic methods, you are safe from a potential code
    break. On the other hand, if your magic method signatures do contain data types,
    and those data types do not match the strictly defined set enforced in PHP 8,
    you have a potential code break on your hands!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8严格执行魔术方法签名。如果您的类使用宽松的定义，即不对方法签名进行数据类型定义，并且对于魔术方法不定义返回值数据类型，那么您就不会受到潜在代码破坏的威胁。另一方面，如果您的魔术方法签名包含数据类型，并且这些数据类型与PHP
    8中强制执行的严格定义集不匹配，那么您就有可能出现代码破坏！
- en: Accordingly, we need to create a set of regular expressions needed to detect
    magic method signature violations. In addition, our configuration should include
    the correct signature. In this manner, if a violation is detected, we can present
    the correct signature in the resulting message, speeding up the update process.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要创建一组正则表达式，以便检测魔术方法签名违规。此外，我们的配置应包括正确的签名。通过这种方式，如果检测到违规，我们可以在生成的消息中呈现正确的签名，加快更新过程。
- en: 'This is how a magic method signature configuration might appear:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个魔术方法签名配置可能出现的方式：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You might notice that we included an extra option, `types`. This is included
    in order to automatically generate a regular expression. The code that does this
    is not shown. If you are interested, have a look at `/path/to/repo/ch11/php7_build_magic_signature_regex.php`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到我们包含了一个额外的选项`types`。这是为了自动生成一个正则表达式。负责此操作的代码没有显示。如果您感兴趣，可以查看`/path/to/repo/ch11/php7_build_magic_signature_regex.php`。
- en: Let's have a look at how you might handle complex break detection where a simple
    `strpos()` search is not sufficient.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在简单的`strpos()`搜索不足以满足的情况下，您可能如何处理复杂的破坏检测。
- en: Addressing complex BC break detection
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决复杂的BC破坏检测
- en: In the case where a simple `strpos()` search proves insufficient, we can develop
    another set of key/value pairs where the value is a callback. As an example, take
    the potential BC break where a class defines a `__destruct()` method, but also
    uses `die()` or `exit()` in the `__construct()` method. In PHP 8 it's possible
    the `__destruct()` method might not get called under these circumstances.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的`strpos()`搜索不足以证明的情况下，我们可以开发另一组键/值对，其中值是一个回调函数。举个例子，考虑一个可能的BC破坏，一个类定义了一个`__destruct()`方法，但也在`__construct()`方法中使用了`die()`或`exit()`。在PHP
    8中，可能在这些情况下`__destruct()`方法不会被调用。
- en: 'In such a situation, a simple `strpos()` search is insufficient. Instead, we
    must develop logic that does the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，简单的`strpos()`搜索是不够的。相反，我们必须开发逻辑来执行以下操作：
- en: Checks to see if a `__destruct()` method is defined. If so, no need to continue
    further as there is no danger of a break in PHP 8.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否定义了`__destruct()`方法。如果是，则无需继续，因为在PHP 8中不会出现破坏的危险。
- en: Checks to see if `die()` or `exit()` is used in the `__construct()` method.
    If so, issue a warning of a potential BC break.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否在`__construct()`方法中使用了`die()`或`exit()`。如果是，则发出潜在BC破坏的警告。
- en: 'In our BC break scan configuration array, the callback takes the form of an
    anonymous function. It accepts the file contents as an argument. We then assign
    the callback to an array configuration key and include the warning message to
    be delivered if the callback returns `TRUE`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的BC断点扫描配置数组中，回调采用匿名函数的形式。它接受文件内容作为参数。然后我们将回调分配给数组配置键，并包括如果回调返回`TRUE`时要传递的警告消息：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In our BC break scanner class (discussed next), the logic needed to invoke
    the callbacks might appear as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的BC断点扫描器类（下面讨论）中，调用回调所需的逻辑可能如下所示：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the requirements to detect additional potential BC breaks are beyond the
    capabilities of a callback, we would then define a separate method directly inside
    the BC break scan class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检测到额外的潜在BC断点的要求超出了回调的能力，那么我们将在BC断点扫描类中定义一个单独的方法。
- en: As you can see, it's possible to develop a configuration array that supports
    not only simple `strpos()` searches, but also searches of greater complexity using
    an array of callbacks.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们可以开发一个支持不仅简单的`strpos()`搜索，还支持使用回调数组进行更复杂搜索的配置数组。
- en: Now that you have an idea of what would go into a configuration array, it's
    time to define the main class that performs the break scanning.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对配置数组中会包含什么有了一个概念，是时候定义执行断点扫描的主要类了。
- en: Developing a BC break scan class
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发BC断点扫描类
- en: The `BreakScan` class is oriented toward a single file. In this class, we define
    methods that utilize the various break scan configuration just covered. If we
    need to scan multiple files, the calling program produces a list of files and
    passes them to `BreakScan` one at a time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`BreakScan`类是针对单个文件的。在这个类中，我们定义了利用刚刚覆盖的各种断点扫描配置的方法。如果我们需要扫描多个文件，调用程序会生成一个文件列表，并将它们逐个传递给`BreakScan`。'
- en: 'The `BreakScan` class can be broken down into two main parts: methods that
    define infrastructure, and methods that define how to conduct given scans. The
    latter is primarily dictated by the structure of the configuration file. For each
    configuration file section, we''ll need a `BreakScan` class method.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`BreakScan`类可以分为两个主要部分：定义基础设施的方法和定义如何进行给定扫描的方法。后者主要由配置文件的结构来决定。对于每个配置文件部分，我们将需要一个`BreakScan`类方法。'
- en: Let's have a look at the infrastructural methods first.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看基础方法。
- en: Defining BreakScan class infrastructural methods
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义BreakScan类基础方法
- en: 'In this section, we have a look at the initial part of the `BreakScan` class.
    We also cover methods that perform infrastructure-related activities:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们看一下`BreakScan`类的初始部分。我们还涵盖了执行基础相关活动的方法：
- en: 'First, we set up the class infrastructure, placing it in the `/repo/src/Php8/Migration`
    directory:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们设置类基础设施，将其放在`/repo/src/Php8/Migration`目录中：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we define a set of class constants to render messages indicating the
    nature of any given post-scan failure:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一组类常量，用于表示任何给定的后扫描失败的性质的消息：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also define a set of constants that represent configuration array keys.
    We do this to maintain consistency between key definitions in the configuration
    file and calling program (discussed later):'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还定义了一组表示配置数组键的常量。我们这样做是为了在配置文件和调用程序中保持键定义的一致性（稍后讨论）：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then initialize key properties, representing the configuration, the contents
    of the file to be scanned, and any messages:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们初始化关键属性，表示配置，要扫描的文件的内容和任何消息：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `__construct()` method accepts our break scan configuration file as an
    argument, and cycles through all of the keys to ensure they exist:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__construct()`方法接受我们的断点扫描配置文件作为参数，并循环遍历所有键以确保它们存在：'
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We then define a method that reads in the contents of the file to be scanned.
    Note that we remove carriage returns (`"\r"`) and linefeeds (`"\n"`) in order
    to make scanning via regular expression easier to process:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个方法，读取要扫描的文件的内容。请注意，我们删除回车（`"\r"`)和换行符（`"\n"`)，以便通过正则表达式更容易处理扫描：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Some of the callbacks need a way to extract just the class name, or just the
    namespace. For that purpose, we define the static `getKeyValue()` method:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些回调需要一种方法来提取类名或命名空间。为此，我们定义了静态的`getKeyValue()`方法：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This method looks for the keyword (for example, `class`). It then finds whatever
    follows the keyword up to the delimiter (for example, `'';''`). So, if you want
    to get the class name, you would execute the following: `$name = BreakScan::geyKeyValue($contents,''class'','';'')`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法寻找关键字（例如，`class`）。然后找到关键字后面的内容，直到分隔符（例如，`';'）。所以，如果你想要获取类名，你可以执行以下操作：`$name
    = BreakScan::geyKeyValue($contents,'class',';')`。
- en: 'We also need a way to retrieve and reset `$this->messages`. Here are the two
    methods to do that:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一种方法来检索和重置`$this->messages`。以下是这两种方法：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We then define a method that runs all scans (covered in the next section).
    This method also collects the number of potential BC breaks detected and reports
    back the total:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个运行所有扫描的方法（在下一节中涵盖）。这个方法还会收集检测到的潜在BC断点的数量并报告总数：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that you have an idea of how the basic `BreakScan` class infrastructure
    might appear, let's have a look at the individual scan methods.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对基本的`BreakScan`类基础设施可能是什么有了一个概念，让我们来看看单独的扫描方法。
- en: Examining individual scan methods
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查单独的扫描方法
- en: The four individual scan methods correspond directly to the top-level keys in
    the break scan configuration file. Each method is expected to accumulate messages
    about potential BC breaks in `$this->messages`. In addition, each method is expected
    to return an integer representing the total number of potential BC breaks detected.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 四个单独的扫描方法直接对应于断点扫描配置文件中的顶级键。每个方法都应该累积关于潜在BC断点的消息在`$this->messages`中。此外，每个方法都应该返回一个表示检测到的潜在BC断点总数的整数。
- en: 'Let''s now examine these methods in order:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按顺序检查这些方法：
- en: 'The first method we examine is `scanRemovedFunctions()`. In this method, we
    search for the function name followed either directly by an open parenthesis,
    `''(''`, or by a space and open parenthesis, `'' (''`. If the function is found,
    we increment `$found`, and add the appropriate warning and suggested replacement
    to `$this-> messages`. If no potential breaks are found, we add a success message
    and return `0`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先检查的方法是`scanRemovedFunctions()`。在这个方法中，我们搜索函数名称，后面直接跟着开括号`'('`，或者是空格和开括号`'
    ('`。如果找到函数，我们递增`$found`，并将适当的警告和建议的替换添加到`$this-> messages`中。如果没有发现潜在的破坏，我们添加一个成功消息并返回`0`：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The main problem with this approach is that if the function is not preceded
    by a space, its use would not be detected. However, if we do not include the leading
    space in the search, we could end up with a false positive. For example, without
    the leading space, every single instance of `foreach()` would trigger a warning
    by the break scanner when looking for `each()`!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要问题是，如果函数没有在空格之前，则不会检测到其使用。但是，如果我们在搜索中不包括前导空格，我们可能会得到错误的结果。例如，没有前导空格，每个`foreach()`的实例在寻找`each()`时都会触发破坏扫描器的警告！
- en: 'Next we have a look at a method that scans for `is_resource()` usage. If a
    reference is located, this method runs through the list of functions that no longer
    produce a resource. If both `is_resource()` and one of these methods is located,
    a potential BC break is flagged:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们看一下扫描`is_resource()`使用的方法。如果找到引用，此方法将遍历不再生成资源的函数列表。如果同时找到`is_resource()`和其中一个这些方法，将标记潜在的BC破坏：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We then have a look at what''s required to go through our list of callbacks.
    As you recall, we need to employ callbacks in situations where a simple `strpos()`
    is insufficient. Accordingly, we first collect all the callback subkeys and loop
    through each one in turn. If there is no bottom-level key *callback*, we throw
    an `Exception`. Otherwise, we run the callback, supplying `$this->contents` as
    an argument. If any potential BC breaks are found, we add the appropriate error
    message, and increment `$found`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们看一下需要通过我们的回调列表的内容。您还记得，我们需要在简单的`strpos()`无法满足的情况下使用回调。因此，我们首先收集所有回调子键并依次循环遍历每个子键。如果没有底层键*callback*，我们会抛出一个`Exception`。否则，我们运行回调，提供`$this->contents`作为参数。如果发现任何潜在的BC破坏，我们添加适当的错误消息，并递增`$found`：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, we turn to by far the most complex method, which scans for invalid
    magic method signatures. The primary problem is that the method signatures vary
    widely, thus we need to build separate regular expressions to properly test validity.
    The regular expressions are stored in the BC break configuration file. If a magic
    method is detected, we retrieve its correct signature and add that to `$this->messages`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们转向迄今为止最复杂的方法，该方法扫描无效的魔术方法签名。主要问题是方法签名差异很大，因此我们需要构建单独的正则表达式来正确测试有效性。正则表达式存储在BC破坏配置文件中。如果检测到魔术方法，我们检索其正确的签名并将其添加到`$this->messages`中。
- en: 'First, we check to see if there are any magic methods by looking for anything
    that matches `function __`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查是否有任何魔术方法，通过查找与`function __`匹配的内容：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the array of matches is not empty, we loop through the set of matches and
    assign to `$key` the magic method name:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果匹配数组不为空，我们循环遍历匹配集并将魔术方法名称分配给`$key`：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the configuration key matching this presumed magic method is not set, we
    assume it''s either not a magic method, or is a method not in the configuration
    file, and thus nothing to worry about. Otherwise, if a key is present, we extract
    a substring representing the method call that is assigned to `$sub`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果未设置与假定魔术方法匹配的配置键，我们假设它既不是魔术方法，也不在配置文件中，因此无需担心。否则，如果存在键，我们提取表示分配给`$sub`的方法调用的子字符串：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then pull the regular expression from the configuration and match it against
    the substring. The pattern represents a proper signature for that particular magic
    method. If `preg_match()` returns `FALSE`, we know the actual signature is incorrect
    and flag it as a potential BC break. We retrieve and store the warning message
    and increment `$found`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从配置中提取正则表达式并将其与子字符串匹配。该模式表示该特定魔术方法的正确签名。如果`preg_match()`返回`FALSE`，我们知道实际签名不正确，并将其标记为潜在的BC破坏。我们检索并存储警告消息并递增`$found`：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This concludes our examination of the `BreakScan` class. Now we turn our attention
    to defining the calling program needed to run the scans programmed into the `BreakScan`
    class.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对`BreakScan`类的审查。现在我们将注意力转向定义调用程序，该程序需要运行`BreakScan`类中编程的扫描。
- en: Building a BreakScan class calling program
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建一个调用程序的BreakScan类
- en: The main job of the program that calls the `BreakScan` class is to accept a
    path argument and to recursively build a list of PHP files located in that path.
    We then loop through the list, extracting the contents of each file in turn, and
    run BC break scans. At the end, we present a report that can be either sparse
    or verbose, depending on the verbosity level selected.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`BreakScan`类的程序的主要工作是接受一个路径参数，并递归构建该路径中的PHP文件列表。然后，我们循环遍历列表，依次提取每个文件的内容，并运行BC破坏扫描。最后，我们提供一个报告，可以是简洁的或详细的，取决于所选的详细级别。
- en: 'Bear in mind that both the `BreakScan` class and the calling program we are
    about to discuss are designed to run under PHP 7\. The reason we do not use PHP
    8 is because we assume that a developer would wish to run the BC break scanner
    *before* they do a PHP 8 update:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`BreakScan`类和我们即将讨论的调用程序都是设计用于在PHP 7下运行。我们不使用PHP 8的原因是因为我们假设开发人员希望在进行PHP
    8更新之前运行BC破坏扫描器：
- en: 'We start by configuring the autoloader and getting the path and verbosity levels
    either from the command line (`$argv`) or from the URL (`$_GET`). In addition,
    we present an option to write the results to a CSV file and accept as a parameter
    the name of such a file. You might note that we also perform a degree of input
    sanitization, although theoretically the BC break scanner will only be used on
    a development server, directly by a developer:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先通过配置自动加载程序并从命令行（`$argv`）或URL（`$_GET`）获取路径和详细级别。此外，我们提供了一个选项，将结果写入CSV文件，并接受此类文件的名称作为参数。您可能注意到我们还进行了一定程度的输入消毒，尽管理论上BC破坏扫描器只会在开发服务器上直接由开发人员使用：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We next confirm the path. If it''s not found, we exit and display usage information
    (`$usage` is not shown):'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们确认路径。如果找不到，我们将退出并显示使用信息（`$usage`未显示）：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We then grab the BC break configuration file and create a `BreakScan` instance:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们抓取BC破坏配置文件并创建`BreakScan`实例：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To build a list of files we use a `RecursiveDirectoryIterator`, wrapped inside
    a `RecursiveIteratorIterator`, starting from the given path. This list is then
    filtered by `FilterIterator`, limiting the scan to PHP files only:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了构建文件列表，我们使用`RecursiveDirectoryIterator`，包装在`RecursiveIteratorIterator`中，从给定路径开始。然后，这个列表通过`FilterIterator`进行过滤，限制扫描仅限于PHP文件：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If the developer chooses the CSV option, an `SplFileObject` instance is created.
    At the same time, we write out an array of headers. Further, we define an anonymous
    function that writes to the CSV file:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果开发人员选择CSV选项，将创建一个`SplFileObject`实例。与此同时，我们还输出了一个标题数组。此外，我们定义了一个写入CSV文件的匿名函数：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We launch the scan by looping through the list of files presented by the `FilterIterator`
    instance. As we are scanning file by file, on each pass `$found` is zeroed out.
    We do maintain `$total`, however, to give a total count of potential BC breaks
    at the end. You might also note that we distinguish files from directories. If
    the directory changes, its name is displayed as a header:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过循环遍历`FilterIterator`实例呈现的文件列表来启动扫描。由于我们是逐个文件扫描，所以在每次通过时`$found`都被清零。但是，我们确实保持`$total`，以便在最后给出潜在BC破坏的总数。您可能还注意到我们区分文件和目录。如果目录发生变化，其名称将显示为标题：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We use `SplFileObject::isDir()` to determine if the item in the file list is
    a directory. If so, we continue with the next item on the list. We then push the
    file contents into `$scanner` and run all scans. Messages are then retrieved in
    the form of a string:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`SplFileObject::isDir()`来确定文件列表中的项目是否是目录。如果是，我们将继续处理列表中的下一个项目。然后我们将文件内容推送到`$scanner`并运行所有扫描。然后以字符串形式检索消息：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We use a `switch()` block to take action based on the display level represented
    by `$show`. Level `0` only shows files where potential BC breaks are found. Level
    `1` shows that plus messages. Level `2` shows all possible output, including success
    messages:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`switch()`块根据`$show`表示的显示级别采取行动。级别`0`仅显示发现潜在BC破坏的文件。级别`1`显示此外还有消息。级别`2`显示所有可能的输出，包括成功消息：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we accumulate the totals and display the final results:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们累积总数并显示最终结果：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that you have an idea how the calling might appear, let's have a look at
    the results of a test scan.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了调用可能的外观，让我们来看一下测试扫描的结果。
- en: Scanning application files
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扫描应用程序文件
- en: 'For demonstration purposes, in the source code associated with this book, we
    have included an older version of **phpLdapAdmin**. You can find the source code
    at `/path/to/repo/sample_data/phpldapadmin-1.2.3`. For this demonstration, we
    opened a shell into the PHP 7 container and ran the following command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，在与本书相关的源代码中，我们包含了一个较旧版本的**phpLdapAdmin**。您可以在`/path/to/repo/sample_data/phpldapadmin-1.2.3`找到源代码。对于此演示，我们打开了PHP
    7容器的shell，并运行了以下命令：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is a partial result from running this command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行此命令的部分结果：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see from the output, although `functions.php` passed the `scanMagicSignatures`
    and `scanIsResource` scans, this code file used three functions that have been
    removed in PHP 8: `__autoload()`, `create_function()`, and `each()`. You''ll also
    note that this file uses the `@` symbol to suppress errors, which is no longer
    effective in PHP 8.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，尽管`functions.php`通过了`scanMagicSignatures`和`scanIsResource`扫描，但这个代码文件使用了在PHP
    8中已删除的三个函数：`__autoload()`，`create_function()`和`each()`。您还会注意到这个文件使用`@`符号来抑制错误，在PHP
    8中不再有效。
- en: 'If you specified the CSV file option, you can open it in any spreadsheet program.
    Here''s how it appears in Libre Office Calc:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您指定了CSV文件选项，您可以在任何电子表格程序中打开它。以下是在Libre Office Calc中的显示方式：
- en: '![Figure 11.1 – CSV file open in Libre Office Calc'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1-在Libre Office Calc中打开的CSV文件'
- en: '](image/Figure_11.1_B16562.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.1_B16562.jpg)'
- en: Figure 11.1 – CSV file open in Libre Office Calc
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1-在Libre Office Calc中打开的CSV文件
- en: You now have an idea of how to create an automated procedure to detect potential
    BC breaks. Please bear in mind that the code is far from perfect and doesn't cover
    every single possible code break. For that, you must rely upon your own judgment
    after having carefully reviewed the material in this book.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何创建自动化程序来检测潜在的BC破坏。请记住，代码远非完美，并不能涵盖每一个可能的代码破坏。为此，您必须在仔细审阅本书材料后依靠自己的判断。
- en: It's now time to turn our attention to the actual migration itself.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的注意力转向实际迁移本身了。
- en: Performing the migration
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行迁移
- en: Performing the actual migration from your current version to PHP version 8 is
    much like the process of deploying a new set of features to an existing application.
    If possible, you might consider running two websites in parallel until such time
    as you are confident the new version works as expected. Many organizations run
    the staging environment in parallel with the production environment for this purpose.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 执行从当前版本到PHP 8版本的实际迁移，就像部署新功能集到现有应用程序的过程一样。如果可能的话，您可以考虑并行运行两个网站，直到您确信新版本按预期工作为止。许多组织为此目的并行运行暂存环境和生产环境。
- en: In this section, we present a **twelve-step guide** to perform a successful
    migration. Although we are focused on migrating to PHP 8, these twelve steps can
    apply to any PHP update you may wish to perform. Understanding and following these
    steps carefully is critical to the success of your production website. Included
    in the twelve steps are plenty of places where you can revert to an earlier version
    if you encounter problems.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们提供了一个**十二步指南**来执行成功的迁移。虽然我们专注于迁移到PHP 8，但这十二个步骤可以适用于您可能希望执行的任何PHP更新。仔细理解并遵循这些步骤对于您的生产网站的成功至关重要。在这十二个步骤中，有很多地方可以在遇到问题时恢复到早期版本。
- en: 'Before we get into details, here is a general overview of a twelve-step migration
    process going from an older version of PHP to PHP 8:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从旧版本的PHP迁移到PHP 8的十二步迁移过程中，这是一个概述：
- en: Carefully review the appropriate migration guide located in the PHP documentation
    appendices. In our case, we choose *Migrating from PHP 7.4x to PHP 8.0x*. ([https://www.php.net/manual/en/appendices.php](https://www.php.net/manual/en/appendices.php)).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细阅读PHP文档附录中的适当迁移指南。在我们的情况下，我们选择*Migrating from PHP 7.4x to PHP 8.0x*。([https://www.php.net/manual/en/appendices.php](https://www.php.net/manual/en/appendices.php))。
- en: Make sure your current code works on the current version of PHP.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您当前的代码在当前版本的PHP上运行正常。
- en: Back up the database (if any), all source code, and any associated files and
    assets (for example, CSS, JavaScript, or graphics images).
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 备份数据库（如果有），所有源代码和任何相关的文件和资产（例如，CSS，JavaScript或图形图像）。
- en: Create a new branch for the soon-to-be-updated application code in your version
    control software.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的版本控制软件中为即将更新的应用程序代码创建一个新分支。
- en: Scan for BC breaks (possibly using the `BreakScan` class discussed in the previous
    section).
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扫描BC中断（可能使用前一节中讨论的`BreakScan`类）。
- en: Update any incompatible code.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新任何不兼容的代码。
- en: Repeat *steps 5* and *6* as needed.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要重复*步骤5*和*6*。
- en: Upload your source code to the repository.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的源代码上传到存储库。
- en: Test the source code in a virtual environment updated to PHP 8 that closely
    simulates the production server.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在尽可能模拟生产服务器的虚拟环境中测试源代码。
- en: If the virtualized simulation is not successful, return to *step 5*.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果虚拟化模拟不成功，请返回到*步骤5*。
- en: Update the staging server (or equivalent virtual environment) to PHP 8, making
    sure you can switch back to the old version.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将暂存服务器（或等效的虚拟环境）更新到PHP 8，确保可以切换回旧版本。
- en: Run every test you can imagine. If not successful, switch back to the master
    branch and return to *step 5*. If successful, clone the staging environment to
    production.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您能想象到的每一个测试。如果不成功，请切换回主分支并返回到*步骤5*。如果成功，克隆暂存环境到生产环境。
- en: Let's now look at each step in turn.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们依次看看每一步。
- en: Step 1 – Review the migration guide
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1步 - 查看迁移指南
- en: 'With every major release of PHP, the PHP core team posts a **migration guide**.
    The guide we are mainly concerned with in this book is *Migrating from PHP 7.4.x
    to PHP 8.0.x*, located at [https://www.php.net/manual/en/migration80.php](https://www.php.net/manual/en/migration80.php).
    This migration guide is broken down into four sections:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每个PHP的主要发布，PHP核心团队都会发布一个**迁移指南**。我们在本书中主要关注的指南是*Migrating from PHP 7.4.x to
    PHP 8.0.x*，位于[https://www.php.net/manual/en/migration80.php](https://www.php.net/manual/en/migration80.php)。这个迁移指南分为四个部分：
- en: New Features
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新功能
- en: Backward Incompatible Changes
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向后不兼容的更改
- en: Deprecated Features
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弃用功能
- en: Other Changes
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他更改
- en: If you are migrating to PHP 8.0 from a version other than PHP 7.4, you should
    also review all of the past migration guides from your current PHP version, up
    to PHP 8\. We'll now have a look at other recommended steps in the migration process.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在从PHP 7.4以外的版本迁移到PHP 8.0，您还应该查看您当前PHP版本的所有过去迁移指南，直到PHP 8。我们现在将看看迁移过程中的其他推荐步骤。
- en: Step 2 – Make sure the current code works
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2步 - 确保当前代码正常工作
- en: Before you start to make changes to the current code base to ensure it works
    in PHP 8, it's absolutely critical for you to make sure it's working. If the code
    isn't working now, it surely will not work once you migrate to PHP 8! Run any
    unit tests along with any **black-box tests** to ensure the code is functioning
    correctly in the current version of PHP.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始对当前代码进行更改以确保其在PHP 8中正常工作之前，确保它绝对正常工作是非常关键的。如果现在代码不起作用，那么一旦迁移到PHP 8，它肯定也不会起作用！运行任何单元测试以及任何**黑盒测试**，以确保代码在当前版本的PHP中正常运行。
- en: If you make any changes to the current code before migration, be sure these
    changes are reflected in the main branch (often called the **master branch**)
    of your version control software.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在迁移之前对当前代码进行了任何更改，请确保这些更改反映在您版本控制软件的主分支（通常称为**主分支**）中。
- en: Step 3 – Back up everything
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3步 - 备份所有内容
- en: The next step is to back up everything. This includes the database, source code,
    JavaScript, CSS, images, and so forth. Also, please do not forget to back up important
    configuration files such as the `php.ini` file, the webserver configuration, and
    any other configuration file associated with PHP and web communications.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是备份所有内容。这包括数据库、源代码、JavaScript、CSS、图像等。还请不要忘记备份重要的配置文件，如`php.ini`文件、web服务器配置和与PHP和web通信相关的任何其他配置文件。
- en: Step 4 – Create a version control branch
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4步 - 创建版本控制分支
- en: In this step, you should create a new branch in your version control system
    and check out that branch. In the main branch, you should only have code that
    currently works.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，您应该在您的版本控制系统中创建一个新的分支并检出该分支。在主分支中，您应该只有当前有效的代码。
- en: 'This is how such a command might work using Git:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用Git进行此类命令的方式：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first command shown creates a branch called `php8_migration`. The second
    command causes `git` to switch to the new branch. In the process, all of your
    existing code gets ported to the new branch. The main branch is now safe and preserved
    from any changes made while in the new branch.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的第一条命令创建了一个名为`php8_migration`的分支。第二条命令使`git`切换到新分支。在这个过程中，所有现有的代码都被移植到了新分支。主分支现在是安全的，并且在新分支中进行任何更改都得到了保留。
- en: 'For more information on version control using Git, have a look here: [https://git-scm.com/](https://git-scm.com/).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用Git进行版本控制的更多信息，请查看这里：[https://git-scm.com/](https://git-scm.com/)。
- en: Step 5 – Scan for BC breaks
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5步 - 扫描BC破坏
- en: Now it's time to put the `BreakScan` class to good use. Run the calling program
    and supply as arguments the starting directory path for your project as well as
    a verbosity level (`0`, `1`, or `2`). You can also specify a CSV file as a third
    option, as shown earlier in *Figure 11.1*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候充分利用`BreakScan`类了。运行调用程序，并作为参数提供项目的起始目录路径以及详细级别（`0`，`1`或`2`）。您还可以指定一个CSV文件作为第三个选项，就像*图11.1*中早些时候所示的那样。
- en: Step 6 – Fix incompatibilities
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6步 - 修复不兼容性
- en: In this step, knowing where the breaks reside, you can proceed to fix the incompatibilities.
    You should be able to do so in such a way that the code continues to run in the
    current version of PHP but can also run in PHP 8\. As we've pointed out consistently
    throughout this book, BC breaks, for the most part, stem from bad coding practices.
    By fixing the incompatibilities, you improve your code at the same time.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，知道破坏的位置，您可以继续修复不兼容性。您应该能够以这样的方式进行修复，使得代码在当前版本的PHP中继续运行，同时也可以在PHP 8中运行。正如我们在整本书中一直指出的那样，BC破坏在很大程度上源自糟糕的编码实践。通过修复不兼容性，您同时改进了您的代码。
- en: Step 7 – Repeat steps 5 and 6 as needed
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7步 - 根据需要重复步骤5和6
- en: There's a famous line, repeated in many Hollywood movies, where the doctor says
    to the anxious patient, *take two aspirin and call me in the morning*. The same
    advice applies to the process of addressing BC breaks. You must be patient, and
    continue to fix and scan, fix and scan. Keep on doing this until the scan reveals
    no more potential BC breaks.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有一句名言在许多好莱坞电影中反复出现，医生对焦虑的病人说，“服用两片阿司匹林，明天早上给我打电话”。同样的建议也适用于解决BC破坏的过程。您必须要有耐心，继续修复和扫描，修复和扫描。一直这样做，直到扫描不再显示潜在的BC破坏为止。
- en: Step 8 – Commit changes to the repository
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8步 - 将更改提交到存储库
- en: Once you are relatively confident there are no further BC breaks, it's time
    to commit changes to the new PHP 8 migration branch you created in your version
    control software. Go ahead and push the changes at this point. You are then in
    a position to retrieve the updated code from this branch once you've sorted out
    the PHP update on the production server.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您相对确信没有进一步的BC破坏，就是时候将更改提交到您在版本控制软件中创建的新PHP 8迁移分支。现在可以推送更改。然后，您可以在生产服务器上解决PHP更新后，从该分支检索更新的代码。
- en: 'Remember this important point: your current working code is safely stored in
    the main branch. You are only saving to the PHP 8 migration branch at this stage,
    so you can always switch back.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住这一重要点：您当前的工作代码安全地存储在主分支中。您只是在这个阶段保存到PHP 8迁移分支，所以您随时可以切换回去。
- en: Step 9 – Test in a simulated virtual environment
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9步 - 在模拟虚拟环境中进行测试
- en: Think of this step as a dress rehearsal for the real thing. In this step, you
    create a virtual environment (for example, using a Docker container) that most
    closely simulates the production server. In this virtual environment, you then
    install PHP 8\. Once the virtual environment has been created, you can open a
    command shell into it, and download your source code from the PHP 8 migration
    branch.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将这一步看作是真正事情的彩排。在这一步中，您创建一个虚拟环境（例如，使用Docker容器），最接近模拟生产服务器。在这个虚拟环境中，然后安装PHP 8。一旦创建了虚拟环境，您可以打开一个命令行进入其中，并从PHP
    8迁移分支下载您的源代码。
- en: You can then run unit tests, and any other tests you deem necessary in order
    to test the updated code. Hopefully, this is where you'll trap any additional
    errors.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以运行单元测试和任何其他您认为必要的测试，以测试更新后的代码。希望在这一步中能够捕获任何额外的错误。
- en: Step 10 – Return to step 5 if the test is unsuccessful
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10步 - 如果测试不成功，则返回第5步
- en: If the unit tests, black-box tests, or other testing performed in the virtual
    environment show that your application code fails, you must return to *step 5*.
    To proceed to the live production site in the face of certain failure would be
    extremely ill-advised!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在虚拟环境中进行的单元测试、黑盒测试或其他测试显示您的应用程序代码失败，您必须返回到*第5步*。在面对明显的失败时继续前往实际生产站点将是极不明智的！
- en: Step 11 – Install PHP 8 on the staging environment
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11步 - 在暂存环境中安装PHP 8
- en: The next step is to install PHP 8 in the staging environment. As you might recall
    from our discussion in the first part of this chapter, the traditional flow is
    from the development environment, to staging, and then on to production. Once
    all testing has been completed on the staging environment, you can then clone
    staging to production.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在暂存环境中安装PHP 8。您可能还记得我们在本章第一部分讨论中提到的，传统流程是从开发环境到暂存环境，然后再到生产环境。一旦在暂存环境上完成了所有测试，您就可以将暂存克隆到生产环境。
- en: PHP installation is well documented on the main [php.net](http://php.net) website,
    so there is no need for further detail here. Instead, in this section we give
    you a light overview of PHP installation, with a focus on the ability to switch
    between PHP 8 and your current PHP version.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的安装在主[php.net](http://php.net)网站上有详细的文档，因此这里不需要进一步的细节。相反，在本节中，我们为您提供了PHP安装的简要概述，重点是能够在PHP
    8和当前PHP版本之间切换的能力。
- en: Tip
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For information on installing PHP in various environments, consult this documentation
    page: [https://www.php.net/manual/en/install.php](https://www.php.net/manual/en/install.php).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在各种环境中安装PHP的信息，请参阅此文档页面：[https://www.php.net/manual/en/install.php](https://www.php.net/manual/en/install.php)。
- en: 'For the purpose of illustration, we choose to discuss PHP 8 installation on
    two of the main branches of Linux: Debian/Ubuntu and Red Hat/CentOS/Fedora. Let''s
    start with Debian/Ubuntu Linux.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，我们选择讨论两个主要Linux分支上的PHP 8安装：Debian/Ubuntu和Red Hat/CentOS/Fedora。让我们从Debian/Ubuntu
    Linux开始。
- en: Installing PHP 8 on Debian/Ubuntu Linux
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Debian/Ubuntu Linux上安装PHP 8
- en: The best way to install PHP 8 is via the available set of pre-compiled binaries.
    Newer PHP versions tend to be made available much later than their release date,
    and PHP 8 is no exception. In this case, it's recommended that you resort to using
    a (**Personal Package Archive(PPA**). The PPA hosted at [https://launchpad.net/~ondrej](https://launchpad.net/~ondrej)
    is the most extensive and widely used.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 安装PHP 8的最佳方法是使用现有的一组预编译的二进制文件。较新的PHP版本往往比发布日期晚得多，并且PHP 8也不例外。在这种情况下，建议您使用（**Personal
    Package Archive(PPA**）。托管在[https://launchpad.net/~ondrej](https://launchpad.net/~ondrej)的PPA是最全面和广泛使用的。
- en: 'If you want to simulate the following steps on your own computer, run an Ubuntu
    Docker image with PHP 7.4 pre-installed using this command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在自己的计算机上模拟以下步骤，请使用以下命令运行一个预先安装了PHP 7.4的Ubuntu Docker镜像：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In order to install PHP 8 on Debian or Ubuntu Linux, open a command shell onto
    the production server (or demo container), and, as the *root* user, proceed as
    follows. Alternatively, if *root* user access isn't available, preface each command
    shown with `sudo`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Debian或Ubuntu Linux上安装PHP 8，打开一个命令行到生产服务器（或演示容器）上，并以*root*用户的身份进行如下操作。或者，如果没有*root*用户访问权限，可以在每个显示的命令前加上`sudo`。
- en: 'From the command shell, to install PHP 8, proceed as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行安装PHP 8，请按照以下步骤进行：
- en: 'Update and upgrade the current set of packages using the **apt** utility. Any
    package manager can be used; however, we show the use of `apt` to maintain consistency
    between the installation steps covered here:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**apt**实用程序更新和升级当前的软件包集。可以使用任何软件包管理器；但是，我们展示了使用`apt`来保持这里涵盖的安装步骤之间的一致性：
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the `Ondrej PPA` repository to your `apt` sources:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Ondrej PPA`存储库添加到您的`apt`源中：
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Install PHP 8\. This installs only the PHP 8 core and basic extensions:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装PHP 8。这只安装了PHP 8核心和基本扩展：
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Use the following command to scan the repository for additional extensions
    and use `apt` to install them as needed:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令扫描存储库以获取额外的扩展，并使用`apt`根据需要安装它们：
- en: '[PRE38]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Do a PHP version check to ensure you''re now running PHP 8:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行PHP版本检查，以确保您现在正在运行PHP 8：
- en: '[PRE39]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here is the version check output:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是版本检查输出：
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now that you have a basic idea of how a PHP 8 installation might proceed, let's
    have a look at how to switch between the current version and PHP 8\. For the purposes
    of illustration, we assume that PHP 7.4 is the current PHP version prior to the
    PHP 8 installation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对PHP 8安装可能进行的基本步骤有了基本的了解，让我们看看如何在当前版本和PHP 8之间切换。为了举例说明，我们假设在安装PHP 8之前，PHP
    7.4是当前的PHP版本。
- en: Switching between PHP versions in Debian and Ubuntu Linux
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Debian和Ubuntu Linux之间切换PHP版本
- en: 'If you check to see where PHP is located, you will note that PHP 7.4, the earlier
    version, still exists following the PHP 8 installation. You can use `whereis php`
    for this purpose. The output on our simulation Docker Ubuntu container appears
    as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查PHP的位置，您会注意到在PHP 8安装后，较早的版本PHP 7.4仍然存在。您可以使用`whereis php`来实现这一目的。我们模拟的Ubuntu
    Docker容器上的输出如下：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see, we now have both the 7.4 and 8.0 versions of PHP installed.
    To switch between the two, use this command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在安装了7.4和8.0版本的PHP。要在两者之间切换，请使用此命令：
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You are then presented with an option screen allowing you to choose which PHP
    version should be active. Here is how the output screen appears on the Ubuntu
    Docker image:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后会出现一个选项屏幕，让您选择哪个PHP版本应该处于活动状态。以下是Ubuntu Docker镜像上输出屏幕的样子：
- en: '[PRE43]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: After switching, you can execute `php --version` again to confirm that the other
    version of PHP is active.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 切换后，您可以再次执行`php --version`来确认另一个PHP版本是否处于活动状态。
- en: Let's now turn our attention to PHP 8 installation on Red Hat Linux and its
    derivatives.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把注意力转向Red Hat Linux及其衍生产品上的PHP 8安装。
- en: Installing PHP 8 on Red Hat, CentOS, or Fedora Linux
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Red Hat、CentOS或Fedora Linux上安装PHP 8
- en: PHP installation on Red Hat, CentOS, or Fedora Linux follows a sequence of commands
    that are similar to the Debian/Ubuntu installation procedure. The main difference
    is that you would most likely use a combination of `dnf` and `yum` to install
    the pre-compiled PHP binaries.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat、CentOS或Fedora Linux上的PHP安装遵循一系列与Debian/Ubuntu安装过程相似的命令。主要区别在于，您很可能会使用`dnf`和`yum`的组合来安装预编译的PHP二进制文件。
- en: 'If you care to follow along with the installation we outline in this section,
    you can use a Fedora Docker container with PHP 7.4 already installed. Here is
    the command to run the simulation:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想跟随本节中我们概述的安装步骤，可以使用一个已经安装了PHP 7.4的Fedora Docker容器进行模拟。以下是运行模拟的命令：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Much like the PPA environment described in the previous section, in the Red
    Hat world, the **Remi's RPM Repository** project ([http://rpms.remirepo.net/](http://rpms.remirepo.net/))
    provides pre-compiled binaries in **Red Hat Package Management** (**RPM**) format.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一节描述的PPA环境非常相似，在Red Hat世界中，**Remi's RPM Repository**项目（[http://rpms.remirepo.net/](http://rpms.remirepo.net/)）以**Red
    Hat Package Management**（**RPM**）格式提供预编译的二进制文件。
- en: 'To install PHP 8 on Red Hat, CentOS, or Fedora, open a command shell onto the
    production server (or demo environment) and, as the *root* user, and proceed as
    follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Red Hat、CentOS或Fedora上安装PHP 8，请打开一个命令行到生产服务器（或演示环境）上，并以*root*用户的身份进行如下操作：
- en: 'First of all, it''s a good idea to confirm the OS version and release you''re
    using. For that purpose, the `uname` command is used, along with a simple `cat`
    command to view the release (stored as a text file in the `/etc` directory):'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确认您正在使用的操作系统版本和发行版是一个好主意。为此，使用`uname`命令，以及一个简单的`cat`命令来查看发行版（存储在`/etc`目录中的文本文件）：
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Before getting started, be sure to update `dnf` and install the configuration
    manager:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始之前，请确保更新`dnf`并安装配置管理器：
- en: '[PRE46]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You would then add Remi''s repository to your package sources, using the version
    number you prefer in place of `NN`:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以将Remi的存储库添加到您的软件包源中，使用您喜欢的版本号替换`NN`：
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'At this point, you can confirm the versions of PHP installed using `dnf module
    list`. We also use `grep` to limit the list of modules shown to PHP only. The
    `[e]` designation indicates *enabled*:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，您可以使用`dnf module list`确认已安装的PHP版本。我们还使用`grep`来限制显示的模块列表仅为PHP。`[e]`表示*已启用*：
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We then check the current version of PHP:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们检查当前的PHP版本：
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we reset the PHP module, and install PHP 8:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们重置PHP模块，并安装PHP 8：
- en: '[PRE50]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Another quick PHP version check shows us that we are now using PHP 8 instead
    of PHP 7:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个快速的PHP版本检查显示我们现在使用的是PHP 8而不是PHP 7：
- en: '[PRE51]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To switch back to the earlier version of PHP, proceed as follows, where `X.Y`
    is the version you plan to use:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要切换回较早版本的PHP，请按照以下步骤进行，其中`X.Y`是您打算使用的版本：
- en: '[PRE52]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This completes the PHP installation instructions for Red Hat, CentOS, or Fedora.
    For this demonstration, we only showed you the PHP command-line installation.
    If you plan to use PHP with a web server, you also need to install either the
    appropriate PHP web server package, and/or install the PHP-FPM (FastCGI Processing
    Module) package.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了Red Hat、CentOS或Fedora的PHP安装说明。在本演示中，我们只向您展示了PHP命令行安装。如果您计划与Web服务器一起使用PHP，还需要安装适当的PHP
    Web服务器包和/或安装PHP-FPM（FastCGI处理模块）包。
- en: Let's now have a look at the last step.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看最后一步。
- en: Step 12 – Test and clone the staging environment to production
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12步 – 测试并将暂存环境克隆到生产环境
- en: In the last step, you download the source code from your PHP 8 migration branch
    onto the staging environment and run every imaginable test to make sure everything's
    working. Once you are assured of success, you then clone the staging environment
    onto the production environment.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中，您将从PHP 8迁移分支下载源代码到暂存环境，并运行各种测试以确保一切正常。一旦您确保成功，然后将暂存环境克隆到生产环境。
- en: If you are using virtualization, the clone procedure might simply involve creating
    an identical Docker container or virtual disk file. Otherwise, if actual hardware
    is involved, you will probably end up cloning the hard drive, or whatever method
    is appropriate for your setup.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用虚拟化，克隆过程可能只涉及创建一个相同的Docker容器或虚拟磁盘文件。否则，如果涉及实际硬件，您可能最终会克隆硬盘，或者根据您的设置选择适当的方法。
- en: This concludes our discussion of how to perform the migration. Let's now have
    a look at testing and troubleshooting.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们关于如何执行迁移的讨论。现在让我们来看看测试和故障排除。
- en: Testing and troubleshooting the migration
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和故障排除迁移
- en: In an ideal world, the migration troubleshooting will take place on the staging
    server, or simulated virtual environment, well before the actual move to production.
    However, as the seasoned developer well knows, we need to hope for the best, but
    prepare for the worst! In this section, we cover additional aspects of testing
    and troubleshooting that can be easily overlooked.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的情况下，迁移故障排除将在上线服务器或模拟的虚拟环境上进行，远在实际上线之前。然而，正如经验丰富的开发人员所知，我们需要抱最好的希望，但做最坏的准备！在本节中，我们将涵盖一些可能被轻易忽视的测试和故障排除的其他方面。
- en: For the purposes of this section, you can exit the temporary shell if you were
    following the Debian/Ubuntu or the Red Hat/CentOS/Fedora installation process.
    Return to the Docker container used for this course and open a command shell into
    the PHP 8 container. Please refer to the *Technical requirements* section of [*Chapter
    1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013), *Introducing New PHP 8 OOP
    Features*, for more information on how to do this if you are unsure.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，如果您正在遵循Debian/Ubuntu或Red Hat/CentOS/Fedora安装过程，可以退出临时shell。返回用于本课程的Docker容器，并打开PHP
    8容器的命令shell。如果您不确定如何操作，请参阅[*第1章*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013)的*技术要求*部分，了解更多信息。
- en: Testing and troubleshooting tools
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试和故障排除工具
- en: There are too many fine testing and troubleshooting tools available to document
    here, so we focus on a few open source tools to help with testing and troubleshooting.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有太多优秀的测试和故障排除工具可用，无法在此处一一列举，因此我们将重点放在一些开源工具上，以帮助测试和故障排除。
- en: Working with Xdebug
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Xdebug
- en: '**Xdebug** is a tool that provides diagnostics, profiling, tracing, and step-debugging,
    among other features. It''s a PHP extension, and is thus able to give you detailed
    information in case you run into problems that you cannot easily solve. The main
    website is [https://xdebug.org/](https://xdebug.org/).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Xdebug是一个工具，提供诊断、分析、跟踪和逐步调试等功能。它是一个PHP扩展，因此能够在您遇到无法轻松解决的问题时提供详细信息。主要网站是[https://xdebug.org/](https://xdebug.org/)。
- en: 'To enable the Xdebug extension, you can install it just as you would any other
    PHP extension: using the `pecl` command, or by downloading and compiling the source
    code from [https://pecl.php.net/package/xdebug](https://pecl.php.net/package/xdebug).'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用Xdebug扩展，您可以像安装任何其他PHP扩展一样安装它：使用`pecl`命令，或者从[https://pecl.php.net/package/xdebug](https://pecl.php.net/package/xdebug)下载并编译源代码。
- en: 'Also, the following `/etc/php.ini` settings should be set, at a minimum:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，至少应设置以下`/etc/php.ini`设置：
- en: '[PRE53]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '*Figure 11.2* shows the output using the `xdebug_info()` command called from
    `/repo/ch11/php8_xdebug.php`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.2*显示了从`/repo/ch11/php8_xdebug.php`调用的`xdebug_info()`命令的输出：'
- en: '![Figure 11.2 – xdebug_info() output'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2 – xdebug_info()输出'
- en: '](image/Figure_11.2_B16562.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.2_B16562.jpg)'
- en: Figure 11.2 – xdebug_info() output
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – xdebug_info()输出
- en: Let's now have a look at another tool that checks your application from an outside
    perspective.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看另一个从外部视角检查您的应用程序的工具。
- en: Using Apache JMeter
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Apache JMeter
- en: An extremely useful open source tool for testing web applications is **Apache
    JMeter** ([https://jmeter.apache.org/](https://jmeter.apache.org/)). It allows
    you to develop a series of test plans that simulate requests from a browser. You
    can simulate hundreds of user requests, each with their own cookies and session.
    Although mainly designed for HTTP or HTTPS, it's also capable of a dozen other
    protocols as well. In addition to an excellent graphical UI, it also has a command-line
    mode that makes it possible to incorporate JMeter in an automated deployment process.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 用于测试Web应用程序的一个非常有用的开源工具是**Apache JMeter**([https://jmeter.apache.org/](https://jmeter.apache.org/))。它允许您开发一系列测试计划，模拟来自浏览器的请求。您可以模拟数百个用户请求，每个请求都有自己的cookie和会话。尽管主要设计用于HTTP或HTTPS，但它还能够处理其他十几种协议。除了出色的图形用户界面外，它还有一个命令行模式，可以将JMeter纳入自动部署过程中。
- en: Installation is quite simple, involving a single download from [https://jmeter.apache.org/download_jmeter.cgi](https://jmeter.apache.org/download_jmeter.cgi).
    You must have the **Java Virtual Machine** (**JVM**) installed before JMeter will
    run. Test plan execution is beyond the scope of this book, but the documentation
    is quite extensive. Also, please bear in mind that JMeter is designed to be run
    from a client, not on the server. Accordingly, if you wish to test the website
    in the Docker container for this book, you'll need to install Apache JMeter on
    your local computer, and then build a test plan that points to the Docker container.
    Normally the IP address for the PHP 8 container is `172.16.0.88`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 安装非常简单，只需从[https://jmeter.apache.org/download_jmeter.cgi](https://jmeter.apache.org/download_jmeter.cgi)下载一个文件。在运行JMeter之前，您必须安装**Java虚拟机**（**JVM**）。测试计划的执行超出了本书的范围，但文档非常详尽。另外，请记住，JMeter设计为在客户端上运行，而不是在服务器上运行。因此，如果您希望在本书的Docker容器中测试网站，您需要在本地计算机上安装Apache
    JMeter，然后构建一个指向Docker容器的测试计划。通常，PHP 8容器的IP地址是`172.16.0.88`。
- en: '*Figure 11.3* shows the opening screen for Apache JMeter running on a local
    computer:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.3*显示了在本地计算机上运行的Apache JMeter的开屏幕：'
- en: '![Figure 11.3 – Apache JMeter'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3 – Apache JMeter'
- en: '](image/Figure_11.3_B16562.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.3_B16562.jpg)'
- en: Figure 11.3 – Apache JMeter
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – Apache JMeter
- en: From this screen you can develop one or more test plans, indicating the URL(s)
    to access, simulate `GET` and `POST` requests, set the number of users, and so
    forth.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个屏幕上，您可以开发一个或多个测试计划，指示要访问的URL，模拟`GET`和`POST`请求，设置用户数量等。
- en: Tip
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you encounter this error while trying to run `jmeter`: `Can''t load library:
    /usr/lib/jvm/java-11-openjdk-amd64/lib/ libawt_xawt.so`, try installing *OpenJDK
    8*. You can then use the techniques mentioned in the earlier section to switch
    between versions of Java.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在尝试运行`jmeter`时遇到此错误：“无法加载库：/usr/lib/jvm/java-11-openjdk-amd64/lib/ libawt_xawt.so”，请尝试安装*OpenJDK
    8*。然后，您可以使用前面部分提到的技术来在不同版本的Java之间切换。
- en: Let's now have a look at potential issues with Composer following a PHP 8 upgrade.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看在PHP 8升级后可能出现的Composer问题。
- en: Handling issues with Composer
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理Composer的问题
- en: One common issue developers face after the migration to PHP 8 has concluded
    is with third-party software. In this section, we discuss potential issues surrounding
    the use of the popular *Composer* package manager for PHP.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移到PHP 8后，开发人员可能面临的一个常见问题是与第三方软件有关。在本节中，我们讨论了使用流行的*Composer*包管理器为PHP可能遇到的潜在问题。
- en: 'The first issue you might encounter has to do with versions of Composer itself.
    In the year 2020, Composer version 2 was released. Not all of the 300,000+ packages
    residing on the main packaging website ([https://packagist.org/](https://packagist.org/))
    have been updated to version 2, however. Accordingly, in order to install a given
    package, you might find yourself having to switch between Composer 2 and Composer
    1\. The latest releases of each version are available here:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会遇到的第一个问题与Composer本身的版本有关。在2020年，Composer 2版本发布了。然而，并非所有驻留在主要打包网站([https://packagist.org/](https://packagist.org/))上的30万多个软件包都已更新到版本2。因此，为了安装特定软件包，您可能需要在Composer
    2和Composer 1之间切换。每个版本的最新发布都在这里：
- en: 'Version 1: [https://getcomposer.org/download/latest-1.x/composer.phar](https://getcomposer.org/download/latest-1.x/composer.phar)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本1：[https://getcomposer.org/download/latest-1.x/composer.phar](https://getcomposer.org/download/latest-1.x/composer.phar)
- en: 'Version 2: [https://getcomposer.org/download/latest-2.x/composer.phar](https://getcomposer.org/download/latest-2.x/composer.phar)'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本2：[https://getcomposer.org/download/latest-2.x/composer.phar](https://getcomposer.org/download/latest-2.x/composer.phar)
- en: Another, more serious, issue has to do with platform requirements of the various
    Composer packages you might be using. Each package has its own `composer.json`
    file, with its own requirements. In many cases, the package provider might add
    a PHP version requirement.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更严重的问题与您可能使用的各种Composer软件包的平台要求有关。每个软件包都有自己的`composer.json`文件，具有自己的要求。在许多情况下，软件包提供者可能会添加PHP版本要求。
- en: The problem is that while most Composer packages now work on PHP 7, the requirements
    were specified in such a manner as to exclude PHP 8\. After a PHP 8 update, when
    you use Composer to update your third-party packages, an error occurs and the
    update fails. Ironically, most PHP 7 packages will also work on PHP 8!
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，虽然大多数Composer软件包现在在PHP 7上运行，但要求是以一种排除PHP 8的方式指定的。在PHP 8更新后，当您使用Composer更新第三方软件包时，会出现错误并且更新失败。具有讽刺意味的是，大多数PHP
    7软件包也可以在PHP 8上运行！
- en: 'As an example, we install a Composer project called `laminas-api-tools`. At
    the time of writing, although the package itself is ready for PHP 8, a number
    of its dependent packages are not. When running the command to install the API
    tools, the following error is encountered:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们安装了一个名为`laminas-api-tools`的Composer项目。在撰写本文时，尽管软件包本身已准备好用于PHP 8，但其许多依赖软件包尚未准备好。在运行安装API工具的命令时，会遇到以下错误：
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The core problem, highlighted in the last portion of the output just shown,
    is that one of the dependent packages requires PHP `^7.0`. In the `composer.json`
    file, this indicates a range of versions from PHP 7.0 through to and including
    PHP 8.0\. In this particular example, the Docker container used runs PHP 8.1,
    so we have a problem.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚显示的输出的最后部分突出显示的核心问题是，其中一个依赖包需要 PHP `^7.0`。在 `composer.json` 文件中，这表示从 PHP 7.0
    到 PHP 8.0 的一系列版本。在这个特定的例子中，使用的 Docker 容器运行的是 PHP 8.1，所以我们有问题。
- en: 'Fortunately, in such cases, we are confident that if this package runs in PHP
    8.0, it should also run in PHP 8.1\. Accordingly, all we need to do is to add
    the `--ignore-platform-reqs` flag. When we retry the installation, as you can
    see from the following output, it is successful:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在这种情况下，我们有信心，如果这个包在 PHP 8.0 中运行，它也应该在 PHP 8.1 中运行。因此，我们只需要添加 `--ignore-platform-reqs`
    标志。当我们重新尝试安装时，如下输出所示，安装成功了：
- en: '[PRE55]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the output just shown, no platform requirement errors appear and we are able
    to continue working with the application.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚显示的输出中，没有出现平台要求错误，我们可以继续使用应用程序。
- en: Let's now turn our attention to unit testing.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把注意力转向单元测试。
- en: Working with unit tests
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用单元测试
- en: Unit testing using **PHPUnit** is a critical factor in the process of ensuring
    that an application will run after a new feature has been added, or after a PHP
    update. Most developers create a set of unit tests to at least perform the bare
    minimum required to prove that an application performs as expected. Tests are
    methods in a class that extends `PHPUnit\Framework\TestCase`. The core of the
    test is what is referred to as an **assertion**.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PHPUnit 进行单元测试是确保应用程序在添加新功能或进行 PHP 更新后能够运行的关键因素。大多数开发人员至少创建一组单元测试，以至少执行最低要求，以证明应用程序的预期性能。测试是一个类中的方法，该类扩展了
    `PHPUnit\Framework\TestCase`。测试的核心是所谓的“断言”。
- en: Tip
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Instructions on how to create and run tests are beyond the scope of this book.
    However, you can go through the excellent documentation with plenty of examples
    at the main PHPUnit website: [https://phpunit.de/](https://phpunit.de/).'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不涵盖如何创建和运行测试的说明。但是，您可以在主要 PHPUnit 网站的出色文档中找到大量示例：[https://phpunit.de/](https://phpunit.de/)。
- en: The problem you might encounter after a PHP migration is that **PHPUnit** ([https://phpunit.de/](https://phpunit.de/))
    itself might fail! The reason for this is because PHPUnit has a new release each
    year that corresponds to the version of PHP that is current for that year. The
    older versions of PHPUnit are based upon what versions of PHP are officially supported.
    Accordingly, it's entirely possible that the version of PHPUnit currently installed
    for your application is an older version that doesn't support PHP 8\. The simplest
    solution is to use Composer to perform an update.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行 PHP 迁移后，您可能会遇到的问题是 PHPUnit（[https://phpunit.de/](https://phpunit.de/)）本身可能会失败！原因是因为
    PHPUnit 每年都会发布一个新版本，对应于当年的 PHP 版本。较旧的 PHPUnit 版本是基于官方支持的 PHP 版本。因此，您的应用程序当前安装的
    PHPUnit 版本可能是不支持 PHP 8 的较旧版本。最简单的解决方案是使用 Composer 进行更新。
- en: 'To illustrate the possible problem, let''s assume that the testing directory
    for an application currently includes PHP unit 5\. If we run a test in the Docker
    container that runs PHP 7.1, everything works as expected. Here is the output:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明可能的问题，让我们假设应用程序的测试目录当前包括 PHP unit 5。如果我们在运行 PHP 7.1 的 Docker 容器中运行测试，一切都按预期工作。以下是输出：
- en: '[PRE56]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'However, if we run the same version but in the Docker container that''s running
    PHP 8, the results are quite different:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们在运行 PHP 8 的 Docker 容器中运行相同的版本，结果会大不相同：
- en: '[PRE57]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see from the output, PHPUnit itself reports an error. The simple
    solution, of course, is that after a PHP 8 upgrade, you also need to re-run Composer
    and update all third-party packages you use along with your application.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，PHPUnit 本身报告了一个错误。当然，简单的解决方案是，在 PHP 8 升级后，您还需要重新运行 Composer，并更新您的应用程序及其使用的所有第三方包。
- en: This concludes our discussion of testing and troubleshooting. You now have an
    idea of what additional tools can be brought to bear to assist you in testing
    and troubleshooting. Please note, however, that this is by no means a comprehensive
    list of all testing and troubleshooting tools. There are many many more, some
    free and open source, others that offer a free trial period, and still more that
    are only available by purchase.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对测试和故障排除的讨论。您现在知道可以使用哪些额外工具来帮助您进行测试和故障排除。请注意，这绝不是所有测试和故障排除工具的全面列表。还有许多其他工具，有些是免费开源的，有些提供免费试用期，还有一些只能通过购买获得。
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned how the term *environment* is used rather than
    *server* because many websites these days use virtualized services. You then learned
    about three distinct environments used during the deployment phase: development,
    staging, and production.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解到术语“环境”是指“服务器”，因为如今许多网站使用虚拟化服务。然后，您了解到在部署阶段使用了三种不同的环境：开发、暂存和生产。
- en: An automated tool that is able to scan your application code for potential code
    breaks was introduced next. As you learned in that section, a break-scanning application
    might consist of a configuration file that addresses removed functionality, changes
    to method signatures, functions that no longer produce resources, and a set of
    callbacks for complex usage detection, a scanning class, and a calling program
    that gathers filenames.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍了一种自动化工具，能够扫描您的应用程序代码，以寻找潜在的代码错误。正如您在该部分学到的那样，一个扫描应用程序可能包括一个配置文件，用于处理已删除的功能、方法签名的更改、不再生成资源的函数，以及用于复杂用法检测的一组回调，一个扫描类，以及一个收集文件名的调用程序。
- en: Next, you were shown a typical twelve-step PHP 8 migration procedure that ensures
    a greater chance of success when you are finally ready to upgrade the production
    environment. Each step is designed to spot potential code breaks, with fallback
    procedures in case something goes wrong. You also learned how to install PHP 8
    on two common platforms as well as how to easily revert to the older version.
    Finally, you learned about a number of free open source tools that can assist
    in testing and troubleshooting.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将看到一个典型的十二步 PHP 8 迁移过程，确保在最终准备升级生产环境时成功的机会更大。每个步骤都旨在发现潜在的代码错误，并在出现问题时有备用程序。您还学会了如何在两个常见平台上安装
    PHP 8，以及如何轻松地恢复到旧版本。最后，您了解了一些可以帮助测试和故障排除的免费开源工具。
- en: All in all, after carefully reading this chapter and studying the examples,
    you are now in a position to not only use existing testing and troubleshooting
    tools, but now have an idea of how to develop your own scanning tool that greatly
    reduces the risk of a potential code break after a PHP 8 migration. You also now
    have an excellent idea what is involved in a migration to PHP 8, and can carry
    out smoother transitions without fear of failure. Your new ability to anticipate
    and fix migration problems will ease any anxiety you might otherwise have experienced.
    You can also look forward to having happy and satisfied customers.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，仔细阅读本章并学习示例后，您现在不仅可以使用现有的测试和故障排除工具，还可以想到如何开发自己的扫描工具，大大降低 PHP 8 迁移后潜在代码错误的风险。您现在也对
    PHP 8 迁移涉及的内容有了很好的了解，并且可以进行更顺畅的过渡，而不必担心失败。您新的预期和解决迁移问题的能力将减轻您可能会遇到的任何焦虑。您还可以期待拥有快乐和满意的客户。
- en: The next chapter introduces you to new and exciting trends in PHP programming
    that can improve performance even further.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍 PHP 编程中的新潮流和令人兴奋的趋势，可以进一步提高性能。
