- en: Chapter 12. What Are We Talking about When We Talk about Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。当我们谈论函数式编程时，我们在谈论什么
- en: 'Functional programming has gained a lot of traction in the last few years.
    Various big tech companies have started using functional languages:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程在过去几年中获得了很多关注。各大科技公司已经开始使用函数式语言：
- en: 'Twitter on Scala: [http://www.artima.com/scalazine/articles/twitter_on_scala.html](http://www.artima.com/scalazine/articles/twitter_on_scala.html)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter使用Scala：[http://www.artima.com/scalazine/articles/twitter_on_scala.html](http://www.artima.com/scalazine/articles/twitter_on_scala.html)
- en: 'WhatsApp being written in Erlang: [http://www.fastcompany.com/3026758/inside-erlang-the-rare-programming-language-behind-whatsapps-success](http://www.fastcompany.com/3026758/inside-erlang-the-rare-programming-language-behind-whatsapps-success)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WhatsApp使用Erlang编写：[http://www.fastcompany.com/3026758/inside-erlang-the-rare-programming-language-behind-whatsapps-success](http://www.fastcompany.com/3026758/inside-erlang-the-rare-programming-language-behind-whatsapps-success)
- en: 'Facebook using Haskell: [https://code.facebook.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/1](https://code.facebook.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/1)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Facebook使用Haskell：[https://code.facebook.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/1](https://code.facebook.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/1)
- en: 'There has been some really wonderful and successful work done on functional
    languages that compile to JavaScript: the **Elm** and **PureScript** languages,
    to name a couple. There are efforts to create new languages that either extend
    or compile to some more traditional languages; we can cite the **Hy** and **Coconut**
    languages for Python.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译为JavaScript的函数式语言上已经做了一些非常出色和成功的工作：**Elm**和**PureScript**语言，这只是其中的一部分。有人正在努力创建新的语言，这些语言要么扩展，要么编译为一些更传统的语言；我们可以引用**Hy**和**Coconut**语言用于Python。
- en: Even Apple's new language for iOS development, **Swift**, has multiple concepts
    from functional programming integrated into its core.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至苹果的iOS开发新语言**Swift**中也集成了多个函数式编程概念。
- en: However, this book is not about using a new language, it is about benefiting
    from functional techniques without having to change our whole stack or learn a
    whole new technology. By just applying some principles to our everyday PHP, we
    can greatly improve the quality of our life and our code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本书不是关于使用新语言，而是关于在不必改变整个堆栈或学习全新技术的情况下从函数式技术中获益。通过将一些原则应用到我们日常的PHP中，我们可以极大地改善我们的生活和代码质量。
- en: But before going further, let's start with a gentle introduction to what the
    functional paradigm really is and explain where it comes from.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但在进一步之前，让我们从一个对函数式范式的温和介绍开始，解释它到底是什么以及它来自哪里。
- en: What is functional programming all about?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程到底是什么？
- en: 'If you try searching the Internet for a definition of functional programming,
    chances are you will at some point find the Wikipedia article ([https://en.wikipedia.org/wiki/Functional_programming](https://en.wikipedia.org/wiki/Functional_programming)).
    Among other things, functional programming is described as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在互联网上搜索函数式编程的定义，很有可能你会在某个时候找到维基百科的文章([https://en.wikipedia.org/wiki/Functional_programming](https://en.wikipedia.org/wiki/Functional_programming))。除其他事项外，函数式编程被描述如下：
- en: '*In computer science, functional programming is a programming paradigm-a style
    of building the structure and elements of computer programs-that treats computation
    as the evaluation of mathematical functions and avoids changing-state and mutable
    data.*'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在计算机科学中，函数式编程是一种编程范式-一种构建计算机程序的结构和元素的风格，它将计算视为数学函数的评估，并避免改变状态和可变数据。*'
- en: 'The Haskell wiki ([https://wiki.haskell.org/Functional_programming](https://wiki.haskell.org/Functional_programming))
    describes it like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell维基([https://wiki.haskell.org/Functional_programming](https://wiki.haskell.org/Functional_programming))这样描述：
- en: '*In functional programming, programs are executed by evaluating expressions,
    in contrast with imperative programming where programs are composed of statements
    which change global state when executed. Functional programming typically avoids
    using mutable state.*'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在函数式编程中，程序通过评估表达式来执行，与命令式编程相反，在命令式编程中，程序由改变全局状态的语句组成。函数式编程通常避免使用可变状态。*'
- en: 'Although our take might be a bit different, we can outline some key definitions
    of functional programming from them:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的看法可能有些不同，但我们可以从中概述一些函数式编程的关键定义：
- en: Evaluation of mathematical functions or expressions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估数学函数或表达式
- en: Avoiding mutable states
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免可变状态
- en: From those two core ideas, we can derive a lot of interesting properties and
    benefits, which you will discover in this book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从这两个核心思想中，我们可以得出许多有趣的属性和好处，这些你将在本书中发现。
- en: Functions
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: You're probably aware of what a function is in a programming language, but how
    it is different from a mathematical function, or as Haskell calls it, an expression?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能知道编程语言中的函数是什么，但它与数学函数有何不同，或者像Haskell称之为表达式有何不同？ '
- en: A mathematical function does not care about the outside world, or the state
    of the program. For a given set of inputs, the outputs will always be exactly
    the same. To avoid confusion, developers often use the terms **pure functions**
    in this case. We discussed this in [Chapter 2](ch02.html "Chapter 2.  Pure Functions,
    Referential Transparency, and Immutability"), *Pure Functions, Referential Transparency
    and Immutability*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数学函数不关心外部世界或程序的状态。对于给定的输入集，输出将始终完全相同。为了避免混淆，开发人员通常在这种情况下使用术语**纯函数**。我们在[第2章](ch02.html
    "第2章。纯函数，引用透明度和不可变性")中讨论了这一点，*纯函数，引用透明度和不可变性*。
- en: Declarative programming
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明式编程
- en: Another difference is that functional programming is also sometimes called **declarative
    programming**, in contrast to imperative programming. These are called **programming
    paradigms**. Object-oriented programming is also a paradigm, but one that is strongly
    tied to the imperative one.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，函数式编程有时也被称为**声明式编程**，与命令式编程相对。这些被称为**编程范式**。面向对象编程也是一种范式，但它与命令式编程紧密相连。
- en: 'Instead of explaining the difference at length, let''s demonstrate it with
    an example. First an imperative one using PHP:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不必冗长解释差异，让我们通过一个例子来演示。首先是使用PHP的命令式方法：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now let''s see how you can do the same with SQL, which is, among other things,
    a declarative language:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用SQL来完成相同的操作，它是除其他外，还是一种声明性语言：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice the difference? In the first example, you tell the computer what to do
    step by step, taking care of storing intermediary results yourselves. The second
    example only describes what you want; it will then be the role of the database
    engine to return the results.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到区别了吗？在第一个例子中，您逐步告诉计算机要做什么，自己负责存储中间结果。第二个例子只描述您想要的内容；然后，数据库引擎将返回结果。
- en: In a way, functional programming looks a lot more like SQL than it does the
    PHP code we just saw.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，函数式编程看起来更像SQL，而不像我们刚才看到的PHP代码。
- en: 'Without any explanation, here is how you could do it with PHP in a more functional
    approach:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何解释，以下是您可以使用PHP以更加函数式的方式完成的方法：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I'll readily admit that this code might not be really clearer than the first
    one. This can be improved by using dedicated libraries. We will also see in detail
    the advantages of such an approach.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我很乐意承认，这段代码可能并不比第一段更清晰。通过使用专用库，可以改进这一点。我们还将详细了解这种方法的优势。
- en: Avoiding mutable state
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免可变状态
- en: As the name itself implies, functions are the most important building block
    of functional programming. The purest of functional languages will only allow
    you to use functions, no variables at all, thus avoiding any problems with state
    and mutating it, and at the same time making any kind of imperative programming
    impossible.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称本身所暗示的那样，函数是函数式编程的最重要的构建模块。最纯粹的函数式语言只允许您使用函数，根本不允许使用变量，因此避免了任何与状态和其变异有关的问题，同时也使任何一种命令式编程都变得不可能。
- en: Although nice, the idea is not practical; this is why most functional languages
    allow you to have some kind of variable. However, those are often immutable, meaning
    that, once assigned, their value can't change.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个想法很好，但并不实际；这就是为什么大多数函数式语言允许您拥有某种类型的变量。然而，这些变量通常是不可变的，意味着一旦分配了值，它们的值就不能改变。
- en: Why is functional programming the future of software development?
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么函数式编程是软件开发的未来？
- en: As we just saw, the functional world is moving, its adoption by the enterprise
    world is growing, and even new imperative languages take inspiration from functional
    languages. But why it is so?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，函数式世界正在发展，企业界对其采用正在增长，甚至新的命令式语言也从函数式语言中汲取灵感。但为什么呢？
- en: Reducing the cognitive burden on developers
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减轻开发人员的认知负担
- en: 'You''ve probably often read or heard that a programmer should not be interrupted
    because even a small interruption can lead to literally tens of minutes being
    lost. One of my favorite illustrations of this is the following comic:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能经常读到或听到程序员不应该被打断，因为即使是小的打断也会导致失去几十分钟。其中我最喜欢的一个例子是下面的漫画：
- en: '![Reducing the cognitive burden on developers](graphics/image_00_001.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![减轻开发人员的认知负担](graphics/image_00_001.jpg)'
- en: This is partly due to the cognitive burden, or in other words, the amount of
    information you have to keep in memory in order to understand the problem or function
    at hand.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这在一定程度上是由于认知负担，或者换句话说，您必须记住的信息量，以便理解手头的问题或函数。
- en: 'If we were able to reduce this issue, the benefits would be huge:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够减少这个问题，那么好处将是巨大的：
- en: Code will take less time to understand and will be easier to reason about
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码理解所需的时间将更少，更容易推理
- en: Interruption will lead to less disruption in the mental process
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打断将导致思维过程中的干扰减少
- en: Fewer errors will be introduced due to forgetting a piece of information
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于遗忘了一些信息而引入的错误将更少
- en: Small learning curve for newcomers on the project
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于项目新手来说，学习曲线较小
- en: I posit that functional programming can greatly help.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为函数式编程可以极大地帮助。
- en: Keeping the state away
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持状态远离
- en: One of the main contenders when it comes to the cognitive burden, as is depicted
    very well in the comic shown previously, is keeping all these little bits of state
    information in mind when trying to understand what a piece of code does.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在认知负担方面的主要竞争者之一，正如之前所展示的漫画中所描述的那样，是在试图理解代码的一部分时，记住所有这些小的状态信息。
- en: Each time you access a variable or call a method on an object, you have to ask
    yourself what its value would be and keep that in mind until you reach the end
    of the piece of code you're currently reading.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每次访问变量或在对象上调用方法时，您都必须问自己它的值是什么，并将其记住，直到您达到当前正在阅读的代码段的末尾。
- en: By using pure functions, nearly all of this goes away. All your parameters are
    right there, in the function signature. Moreover, you have the absolute certainty that
    any subsequent call with the same parameters will have exactly the same outcome,
    because your function doesn't rely on external data or any object state.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用纯函数，几乎所有这些问题都会消失。所有参数都在函数签名中。此外，您可以绝对确定，任何使用相同参数的后续调用都会产生完全相同的结果，因为您的函数不依赖于外部数据或任何对象状态。
- en: 'To drive the nail further, let''s cite *Out of the Tar Pit* by Ben Moseley
    and Peter Marks:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步强调这一点，让我们引用本·莫斯利和彼得·马克斯的《Out of the Tar Pit》：
- en: '*[...] it is our belief that the single biggest remaining cause of complexity
    in most contemporary large systems is state, and the more we can do to limit and
    manage state, the better.*'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*[...] 我们相信，当今大多数大型系统中复杂性的最大原因是状态，我们能够限制和管理状态的越多，就越好。*'
- en: You can read the whole paper at [http://shaffner.us/cs/papers/tarpit.pdf](http://shaffner.us/cs/papers/tarpit.pdf).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://shaffner.us/cs/papers/tarpit.pdf](http://shaffner.us/cs/papers/tarpit.pdf)上阅读整篇论文。
- en: Small building blocks
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小的构建模块
- en: When you do functional programming, you usually create a lot of small functions.
    You can then compose them like Lego blocks. Each of those small pieces of code
    is often easier to understand than this big messy method that tries to do a lot
    of things.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当您进行函数式编程时，通常会创建许多小函数。然后您可以像积木一样组合它们。这些小代码片段通常比试图做很多事情的大杂乱方法更容易理解。
- en: I am not saying that all imperative code is a big mess, just that having a functional
    mindset really encourages writing small and concise functions that are easier
    to work with.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是说所有的命令式代码都是一团糟，只是函数式思维真的鼓励编写更小、更简洁的函数，更容易处理。
- en: Locality of concerns
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关注点的局部性
- en: 'Let''s have a look at the two following examples:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下两个例子：
- en: '![Locality of concerns](graphics/image_00_002-1.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![关注点的局部性](graphics/image_00_002-1.jpg)'
- en: Imperative versus functional-separation of concerns
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式与函数式-关注点的分离
- en: 'As illustrated previously in both fictional code snippets, functional techniques
    help you organize your code in a way that encourages locality of concerns. In
    the snippets, we can separate the concerns as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面在两个虚构的代码片段中所示，函数式技术有助于以鼓励关注的方式组织代码。在这些片段中，我们可以将关注点分开如下：
- en: Creating a list
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个列表
- en: Getting data from a file
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件中获取数据
- en: Filtering all lines starting with **ERROR** text
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤所有以**ERROR**文本开头的行
- en: Taking the first 40 errors
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取前40个错误
- en: The second snippet clearly has a better locality for each of those concerns;
    they are not spread out in the code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个片段明显对每个关注点有更好的局部性；它们没有分散在代码中。
- en: One can argue that the first code is not optimal and could be rewritten to achieve
    the same results. Yes, it's probably true. But as for the previous point, a functional
    mindset encourages this kind of architecture from the get-go.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有人可能会说第一个代码不够优化，可以重写以达到相同的结果。是的，这可能是真的。但就像前面提到的，函数式思维从一开始就鼓励这种架构。
- en: Declarative programming
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明式编程
- en: We saw that declarative programming is about the *what* instead of the *how*.
    This helps understanding new code a lot, because our minds have a much easier
    time thinking about what we want instead of how to do it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，声明式编程关注的是“做什么”而不是“怎么做”。这有助于更好地理解新代码，因为我们的大脑更容易思考我们想要的东西，而不是如何去做。
- en: When you order something online or at a restaurant, you don't imagine how, what
    you want will be created or delivered, you just think of what you want. Functional
    programming is the same-you start with some data and you tell the language what
    you want done with it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在线或在餐厅订购东西时，您不会想象您想要的东西将如何被创建或交付，您只会考虑您想要什么。函数式编程也是一样-您从一些数据开始，然后告诉语言您想要对其进行什么操作。
- en: 'This kind of code is also often easier to understand for non-programmers or
    people with less experience in the language, because we can visualize what will
    happen to the data. Here is another citation from *Out of the Tar Pit* illustrating
    this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码对非程序员或语言经验较少的人来说通常也更容易理解，因为我们可以可视化数据将会发生什么。以下是《Out of the Tar Pit》中的另一段引文，说明了这一点：
- en: '*When a programmer is forced (through use of a language with implicit control
    flow) to specify the control, he or she is being forced to specify an aspect of
    how the system should work rather than simply what is desired. Effectively they
    are being forced to over-specify the problem*'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*当程序员被迫（通过使用具有隐式控制流的语言）指定控制时，他或她被迫指定系统应该如何工作的一个方面，而不仅仅是所需的内容。实际上，他们被迫过度指定问题*'
- en: Software with fewer bugs
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更少错误的软件
- en: We already saw that functional programming reduces the cognitive burden and
    makes your code easier to reason about. This is already a huge win when it comes
    to bugs, because it will allow you to spot issues quickly as you will spend less
    time understanding how the code works to focus on what it should do.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，函数式编程减少了认知负担，使您的代码更容易理解。这在处理错误时已经是一个巨大的优势，因为它将使您能够快速发现问题，因为您将花费更少的时间理解代码的工作原理，而更多地关注它应该做什么。
- en: But all the benefits we've just seen have another advantage. They make testing
    a lot easier too! If you have a pure function and you test it with a given set
    of values, you have the absolute certainty that it will always return exactly
    the same thing in production.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们刚刚看到的所有好处还有另一个优势。它们也使测试变得更容易！如果您有一个纯函数，并使用一组给定的值进行测试，您可以绝对确定它在生产中总是会返回完全相同的结果。
- en: How many times have you thought your test was fine, only to discover you had
    some kind of hidden dependency to an obscure state deep in your application that
    triggered an issue in some particular circumstances? This ought to happen a lot
    less with pure functions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次认为你的测试没问题，结果发现在应用程序的某些特定情况下触发了一些隐蔽状态的隐藏依赖？使用纯函数，这种情况应该会少得多。
- en: We also learn about property-based testing later in the book. Although the technique
    can be used on any imperative codebase, the idea behind it came from the functional
    world.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在本书的后面学习关于基于属性的测试。尽管这种技术可以用于任何命令式代码库，但其背后的理念来自函数式世界。
- en: Easier refactoring
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更容易的重构
- en: Refactoring is never easy. But since the only inputs of a pure function are
    its parameters and its sole output is the returned value, things are simpler.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重构从来都不容易。但由于纯函数的唯一输入是其参数，唯一输出是返回值，事情变得更简单了。
- en: If your refactored function continues to return the same output for a given
    input, you can have the guarantee that your software will continue to work. You
    cannot forget to set some state somewhere in an object, because your functions
    are side-effect free.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您重构的函数继续为给定输入返回相同的输出，您可以保证您的软件将继续工作。您不会忘记在对象的某个地方设置一些状态，因为您的函数是无副作用的。
- en: Parallel execution
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行执行
- en: Our computers have more and more cores and the cloud has made it a lot easier
    to share work across a bunch of nodes. The challenge, however, is ensuring that
    a computation can be distributed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算机拥有越来越多的核心，云计算使跨多个节点共享工作变得更加容易。然而，挑战在于确保计算可以分布。
- en: Techniques such as mapping and folding, coupled with immutability and the absence
    of state, make this pretty easy.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如映射和折叠等技术，再加上不可变性和状态的缺失，使这变得相当容易。
- en: Sure, you will still have issues related to distributed computing itself, such
    as partitions and failure detection, but splitting the computation into multiple
    workloads will be made a lot easier! If you want to learn more about distributed
    systems, I can recommend this article ([http://videlalvaro.github.io/2015/12/learning-about-distributed-systems.html](http://videlalvaro.github.io/2015/12/learning-about-distributed-systems.html))
    by a former colleague.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你仍然会遇到与分布式计算本身相关的问题，比如分区和故障检测，但将计算分成多个工作负载会变得更加容易！如果你想了解更多关于分布式系统的知识，我可以推荐这篇文章（[http://videlalvaro.github.io/2015/12/learning-about-distributed-systems.html](http://videlalvaro.github.io/2015/12/learning-about-distributed-systems.html)）。
- en: Enforcing good practices
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制执行良好的实践
- en: This book is the proof that functional programming is more about the way we
    do things instead of a particular language. You can use functional techniques
    in nearly any language that has functions. Your language still needs to have certain
    properties, but not that many. I like to talk about having a functional mindset.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书证明了函数式编程更多地关乎我们做事情的方式，而不是特定的语言。你可以在几乎任何具有函数的语言中使用函数式技术。你的语言仍然需要具有某些属性，但不需要太多。我喜欢谈论拥有函数式思维。
- en: If this is so, why do companies move to functional languages? Because those
    languages enforce the best practice we will learn in this book. In PHP, you will
    have to always remember to use functional techniques. In Haskell, you cannot do
    anything else; the language forces you to write pure functions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，为什么公司要转向函数式语言呢？因为这些语言强制执行我们将在本书中学到的最佳实践。在PHP中，你必须始终记住使用函数式技术。在Haskell中，你不能做其他任何事情；语言强制你编写纯函数。
- en: Sure, you can still write bad code in any language, even the purest ones. But
    usually, people, and developers especially, like to take the path of least resistance.
    And if this path is the one that leads to quality code, they will take it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你仍然可以在任何语言中写糟糕的代码，即使是最纯净的代码。但通常，人们，尤其是开发人员，喜欢选择最不费力的路径。如果这条路径是通向高质量代码的路径，他们会选择它。
- en: A quick history of the functional world
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式世界的简史
- en: Historically, functional programming has its roots in the academic world. It's
    only in recent years that more mainstream companies started using it to develop
    consumer-facing applications. Some new research into the field is now even done
    by people outside of universities. But let's begin at the beginning.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，函数式编程起源于学术界。直到最近几年，更多的主流公司才开始使用它来开发面向消费者的应用程序。现在甚至有些人在大学以外进行这个领域的新研究。但让我们从一开始开始。
- en: The first years
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最初的几年
- en: Our story starts in the 1930s when Alonzo Church formalized the Lambda Calculus,
    a way to solve mathematical problems using functions accepting other functions
    as parameters. Although this is the foundation of functional programming, it took
    20 years for the concept to be first used to implement a programming language
    when **Lisp** was released in 1958 by John McCarthy. To be fair, **Fortran**,
    considered the first programming language, was released in 1957.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的故事始于20世纪30年代，当时阿隆佐·丘吉尔正式化了λ演算，这是一种使用接受其他函数作为参数的函数来解决数学问题的方法。尽管这是函数式编程的基础，但直到1958年约翰·麦卡锡发布了**Lisp**，这个概念才首次被用于实现编程语言。公平地说，被认为是第一种编程语言的**Fortran**是在1957年发布的。
- en: Although LISP is considered a multi-paradigm language, it is often cited as
    the first functional language. Quickly, others took the hint and started working
    around the idea of functional programming, leading to the creation of **APL**
    (1964), **Scheme** (1970), **ML** (1973), **FP** (1977), and many others.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管LISP被认为是一种多范式语言，但它经常被引用为第一种函数式语言。很快，其他人也领会了这个暗示，并开始围绕函数式编程的思想进行工作，导致了**APL**（1964）、**Scheme**（1970）、**ML**（1973）、**FP**（1977）等许多其他语言的诞生。
- en: FP in itself is more or less dead right now, but the lecture in which it was
    presented by John Backus was pivotal to the research into the functional paradigm.
    It might not be the easiest read, but it's really interesting nonetheless. I can
    only suggest you give the whole paper a try at [http://worrydream.com/refs/Backus-CanProgrammingBeLiberated.pdf](http://worrydream.com/refs/Backus-CanProgrammingBeLiberated.pdf).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: FP本身现在基本上已经死了，但约翰·巴克斯在演讲中提出的概念对函数式范式的研究至关重要。这可能不是最容易阅读的，但仍然非常有趣。我建议你尝试阅读整篇论文，网址是[http://worrydream.com/refs/Backus-CanProgrammingBeLiberated.pdf](http://worrydream.com/refs/Backus-CanProgrammingBeLiberated.pdf)。
- en: The Lisp family
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lisp家族
- en: 'Scheme, first released in 1970, is an attempt to fix some of the shortcomings
    of Lisp. In the meantime, Lisp gave birth to a programming language family or
    dialects:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme，于1970年首次发布，是试图修复Lisp的一些缺点。与此同时，Lisp诞生了一个编程语言家族或方言：
- en: '**Common Lisp** (1984): an attempt to write a language specification to reunite
    all the Lisp dialects that were being written at the time.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**Common Lisp**（1984年）：试图编写一个语言规范，以重新统一当时正在编写的所有Lisp方言。'
- en: '**Emacs Lisp** (1985): the scripting language used to customize and extend
    the Emacs editor.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**Emacs Lisp**（1985年）：用于定制和扩展Emacs编辑器的脚本语言。'
- en: '**Racket** (1994): first created to be a platform around language design and
    creation, it''s now used in multiple areas such as game scripting, education,
    and research.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**Racket**（1994年）：最初创建为围绕语言设计和创建的平台，现在被用于多个领域，如游戏脚本、教育和研究。'
- en: '**Clojure** (2007): created by Rich Hickey after a lengthy reflection to create
    the perfect language. Clojure targets the **Java Virtual Machine** (**JVM**).
    It is interesting to note that Clojure can also now have other targets, for example,
    JavaScript (ClojureScript) and the .NET virtual machine.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**Clojure**（2007年）：由Rich Hickey在长时间反思后创建的，旨在创建完美语言。Clojure以**Java虚拟机**（**JVM**）为目标。有趣的是，Clojure现在也可以有其他目标，例如JavaScript（ClojureScript）和.NET虚拟机。'
- en: '**Hy** (2013): a dialect that targets the Python runtime, allowing the use
    of all Python libraries.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hy**（2013年）：一个以Python运行时为目标的方言，允许使用所有Python库。'
- en: ML
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ML
- en: ML also spawned some children, most notably **Standard ML** and **OCaml** (1996)
    which are still in use today. It is also often cited as influence in the design
    of a lot of modern languages. To name a few: Go, Rust, Erlang, Haskell, and Scala.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ML也产生了一些后代，最著名的是**Standard ML**和**OCaml**（1996年），至今仍在使用。它也经常被引用为许多现代语言设计的影响。举几个例子：Go、Rust、Erlang、Haskell和Scala。
- en: The rise of Erlang
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 爱尔兰语的崛起
- en: I said earlier that the mainstream use of functional language is something that
    started happening in the last few years. This is not entirely true. Ericsson started
    working on Erlang as soon as 1986, interested in the stability and robustness
    promised by a functional language.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过，函数式语言的主流使用是在最近几年开始发生的。这并不完全正确。爱立信早在1986年就开始研究爱尔兰语，对函数式语言所承诺的稳定性和健壮性感兴趣。
- en: At first, Erlang was implemented on top of **Prolog** and it proved too slow,
    but a rewrite to use a virtual machine compiling Erlang to C in 1992, allowed
    Ericsson to use Erlang on production telephony system as early as 1995\. Since
    then, it has been used worldwide by telecom companies and is considered one of
    the best languages when it comes to high availability.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，爱尔兰语是在**Prolog**之上实现的，但证明速度太慢，1992年改用将Erlang编译为C的虚拟机进行重写，使得爱立信能够在1995年早期在生产电话系统上使用Erlang。自那时起，它已经被全球电信公司使用，并被认为是高可用性时最好的语言之一。
- en: Haskell
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Haskell
- en: The year 1990 marked the first release of Haskell, the result of specification
    work done by academics around the world to create the first open standard around
    lazy purely functional languages. The idea was to consolidate existing functional
    languages into a common one so that it could be the basis for further research
    in functional language design.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 1990年标志着Haskell的首次发布，这是全球学术界进行规范工作的结果，旨在创建第一个围绕惰性纯函数式语言的开放标准。其想法是将现有的函数式语言整合成一个共同的语言，以便成为进一步研究函数式语言设计的基础。
- en: Since then, Haskell has grown from a purely academic language in to one of the
    leading functional languages.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，Haskell已经从纯学术语言发展成为领先的函数式语言之一。
- en: Scala
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala
- en: Scala development was started in 2001 by former Java core developer Martin Odersky.
    The main idea was to make functional programming more approachable by mixing it
    with more traditional imperative concepts. The first public release in 2004 targeted
    both the JVM and the **Common Runtime Language** (**CRM**) used by .NET (this
    second target was later dropped in 2012).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的开发始于2001年，由前Java核心开发人员Martin Odersky发起。主要思想是通过将函数式编程与更传统的命令式概念混合在一起，使函数式编程更易接近。2004年的首次公开发布同时面向JVM和.NET使用的**通用运行时语言**（**CRM**）（第二个目标在2012年后被放弃）。
- en: Scala source code can use its language construct alongside those from the target
    virtual machine. The ability to use existing Java libraries directly and the ability to
    fall back to an imperative style is one of the reasons Scala quickly gained ground
    in the enterprise world.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Scala源代码可以与目标虚拟机的语言结构一起使用。直接使用现有的Java库以及能够回退到命令式风格是Scala迅速在企业界获得地位的原因之一。
- en: Since Android uses a Java-compatible virtual machine, Scala is well suited for
    mobile development and there's also an initiative to compile it to JavaScript,
    meaning you can use it on both the server and the client for web development.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Android使用了与Java兼容的虚拟机，Scala非常适合移动开发，还有一个将其编译成JavaScript的倡议，这意味着你可以在服务器和客户端都使用它进行Web开发。
- en: The newcomers
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新来者
- en: Nowadays, functional programming languages are starting to gain more mainstream
    acceptance and new languages are created outside of the academic world. Here is
    a quick overview of what is being actively worked on by people around the world.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，函数式编程语言开始在主流中获得更多认可，并且新的语言也在学术界之外被创造出来。以下是世界各地人们正在积极开发的一些语言的快速概述。
- en: '**Elm** is a serious attempt to create a functional language compiling to JavaScript
    besides ClojureScript. It is the result of a thesis by Evan Czaplicki trying to
    create a functional reactive language, a concept we will look into in the last
    chapter of the book. It gained some coverage when a time-traveling debugger ([http://debug.elm-lang.org/](http://debug.elm-lang.org/))
    was first presented some years ago, an idea that has since been implemented with
    much more pain in JavaScript frameworks such as **React**. The barrier of entry
    is greatly eased by an online editor, really great tutorials, and the fact that
    you can use **npm** to install it.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**Elm**是一次认真的尝试，旨在创建一个编译成JavaScript的函数式语言，除了ClojureScript之外。这是Evan Czaplicki的论文的结果，试图创建一种函数式响应式语言，这是我们将在本书的最后一章中探讨的概念。几年前首次展示了一个时间旅行调试器（[http://debug.elm-lang.org/](http://debug.elm-lang.org/)），这个想法后来在JavaScript框架如**React**中以更多的痛苦实现。通过在线编辑器、非常好的教程以及可以使用**npm**进行安装，大大降低了入门门槛。'
- en: '**PureScript** is another functional language compiling to JavaScript. It is
    closer to Haskell than Elm is and follows a more mathematical approach. The community
    is smaller, but a lot of work is going on to make the language user-friendly.
    The PureScript compiler was written in Haskell, it''s a bit harder to get started
    but it''s worth it if you want to have robust client-side code.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**PureScript**是另一种编译成JavaScript的函数式语言。它比Elm更接近Haskell，并遵循更数学化的方法。社区规模较小，但正在进行大量工作，使语言更加用户友好。PureScript编译器是用Haskell编写的，开始起步有点困难，但如果你想要健壮的客户端代码，这是值得的。'
- en: '**Idris** is, in my opinion, not really ready to shine in a production environment.
    It has its place in this list, however, as it is one of the more advanced functional
    languages implementing dependent types. A dependent type is an advanced typing
    concept that is mostly seen in purely academic languages. It''s beyond scope of
    this book to explain it in detail, but let''s do a quick example: *a pair of integers*
    is a **type**; *a pair of integers where the second one is greater than the first*
    is a **dependent type** because the type depends on the value of the variable.
    The advantages of such a typing system is that you can prove more thoroughly that
    your data is correct and thus the result of your software is also correct. This
    is, however, a really advanced technique and such languages are rare and hard
    to learn.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**Idris**在我看来，实际上还没有准备好在生产环境中大放异彩。然而，它在这个列表中有它的位置，因为它是实现依赖类型的更先进的函数语言之一。依赖类型是一个高级的类型概念，主要出现在纯学术语言中。这本书的范围超出了详细解释它的范围，但让我们做一个快速的例子：*一对整数*是一个**类型**；*第二个整数大于第一个整数的一对整数*是一个**依赖类型**，因为类型取决于变量的值。这样的类型系统的优势在于您可以更彻底地证明您的数据是正确的，因此您的软件的结果也是正确的。然而，这是一种非常高级的技术，这样的语言很少，而且很难学习。'
- en: Functional jargon
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程术语
- en: Like every other field, functional programming comes with its own jargon. This
    small glossary has the goal to make reading the book easier and also provide you
    with more understanding of the resources you will find online.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他领域一样，函数式编程也有自己的术语。这个小词汇表的目标是使阅读本书更容易，同时为您提供更多对您在网上找到的资源的理解。
- en: '**Arity**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Arity**'
- en: The number of parameters a function takes. The terms nullary, unary, binary,
    and ternary are also used to denote functions that take 0, 1, 2, and 3 parameters
    respectively. See also variadic as follows.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受的参数数量。术语nullary、unary、binary和ternary也用于表示分别接受0、1、2和3个参数的函数。另请参见可变参数。
- en: '**Higher-order functions**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**高阶函数**'
- en: A function that returns another function. [Chapter 1](ch01.html "Chapter 1. Functions
    as First Class Citizens in PHP"), *Functions as First Class Citizens*, further
    explain the concepts of higher-order functions as this is one of the foundations
    of functional programming.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 返回另一个函数的函数。《第1章》*PHP中的函数作为一等公民*进一步解释了高阶函数的概念，因为这是函数式编程的基础之一。
- en: '**Side effects**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**副作用**'
- en: 'Anything that affects the world outside the current function: changing a global
    state, a variable passed by reference, a value in an object, writing to the screen
    or a file, taking user inputs. This concept is an important one and will be explored
    further in multiple chapters of the book.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 任何影响当前函数外部世界的事物：改变全局状态，通过引用传递的变量，对象中的值，写入屏幕或文件，接受用户输入。这个概念是重要的，并将在本书的多个章节中进一步探讨。
- en: '**Purity**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**纯度**'
- en: A function is said to be pure if it only uses the explicit parameters and has
    no side effects. A pure function is a function that will always yield exactly
    the same result when called with the same parameters. A pure language is a language
    allowing only pure functions. This concept is an angular stone of functional programing
    as discussed in [Chapter 2](ch02.html "Chapter 2.  Pure Functions, Referential
    Transparency, and Immutability"), *Pure Functions, Referential Transparency, and
    Immutability*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数只使用显式参数并且没有副作用，则称该函数是纯的。纯函数是一个在使用相同参数调用时总是产生完全相同结果的函数。纯语言是只允许纯函数的语言。这个概念是函数式编程的基石，正如《第2章》*纯函数、引用透明度和不可变性*中所讨论的那样。
- en: '**Function composition**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数组合**'
- en: Composing functions is a useful technique to reuse various functions as building
    blocks to achieve more complex operations. Instead of always calling the function
    `g` on the result of the function `f`, you can compose both functions to create
    a new function `h`. [Chapter 4](ch04.html "Chapter 4. Composing Functions"), *Composing
    Functions*, demonstrates how this idea can be used.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 组合函数是一种有用的技术，可以重用各种函数作为构建块来实现更复杂的操作。您可以组合两个函数来创建一个新函数`h`，而不是总是在函数`f`的结果上调用函数`g`。《第4章》*组合函数*演示了如何使用这个想法。
- en: '**Immutability**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可变性**'
- en: An immutable variable is a variable that cannot be changed once it has been
    assigned a value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦赋值就不能更改的不可变变量。
- en: '**Partial application**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**部分应用**'
- en: The process of assigning a given value to some parameters of a function to create
    a new function of a smaller arity. This is sometimes called fixing or binding
    a value to a parameter. This is a bit difficult to achieve in PHP, but [Chapter
    4](ch04.html "Chapter 4. Composing Functions"), *Composing Functions*, gives some
    idea of how to do it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将给定值分配给函数的某些参数的过程，以创建一个较小arity的新函数。这有时被称为固定或绑定一个值到一个参数。这在PHP中有点难以实现，但《第4章》*组合函数*给出了一些如何做到这一点的想法。
- en: '**Currying**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**柯里化**'
- en: Akin to partial application, currying is the process of transforming a function
    with multiple parameters into multiple unary functions composed to achieve the
    same result. The reason and idea behind currying were presented in [Chapter 4](ch04.html
    "Chapter 4. Composing Functions"), *Composing Functions*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于部分应用，柯里化是将具有多个参数的函数转换为多个一元函数组合以实现相同结果的过程。柯里化的原因和思想在《第4章》*组合函数*中有介绍。
- en: '**Fold/reduce**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**折叠/减少**'
- en: The process of reducing a collection to a *single* value. This is an often-used
    concept in functional programming and was demonstrated at length in [Chapter 3](ch03.html
    "Chapter 3.  Functional Basis in PHP"), *Functional Basis in PHP*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将集合减少到*单个*值的过程。这是函数式编程中经常使用的概念，在《第3章》*PHP中的函数基础*中有详细演示。
- en: '**Map**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射**'
- en: The process of applying a function on all values of a collection. This is an
    often-used concept in functional programming and was demonstrated at length in
    [Chapter 3](ch03.html "Chapter 3.  Functional Basis in PHP"), *Functional Basis
    in PHP*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合的所有值上应用函数的过程。这是函数式编程中经常使用的概念，并且在[第3章](ch03.html "第3章。PHP中的函数基础")，“PHP中的函数基础”中得到了详细展示。
- en: '**Functor**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**函子**'
- en: Any type of value or collection to which you can apply a mapping operation.
    The functor, given a function, is responsible for applying it to its inner value.
    It is said that the functor *wraps* the value. This concept was presented in [Chapter
    5](ch05.html "Chapter 5.  Functors, Applicatives, and Monads"), *Functors, Applicatives,
    and* *Monads*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的值或集合都可以应用映射操作。函子在给定函数时负责将其应用于其内部值。据说函子*包装*值。这个概念在[第5章](ch05.html "第5章。函子、应用程序和单子")，“函子、应用程序和单子”中被提出。
- en: '**Applicative**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序**'
- en: A data structure holding a function inside a context. The applicative, given
    a value, is responsible for applying the "inner" function to it. It is said that
    the functor *wraps* the function. This concept was presented in [Chapter 5](ch05.html
    "Chapter 5.  Functors, Applicatives, and Monads"), *Functors, Applicatives, and* *Monads*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 包含上下文中的函数的数据结构。应用程序在给定值时负责将“内部”函数应用于它。据说函子*包装*函数。这个概念在[第5章](ch05.html "第5章。函子、应用程序和单子")，“函子、应用程序和单子”中被提出。
- en: '**Semigroup**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**半群**'
- en: Any type for which you can associate values two by two. For example, strings
    are a semigroup because you can concatenate them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型，您可以将两个值关联起来。例如，字符串是一个半群，因为您可以将它们连接起来。
- en: 'Integers have multiple semigroups:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 整数有多个半群：
- en: The Addition semigroup, where you add integers together
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法半群，其中将整数相加
- en: The Multiplication semigroup, where you multiply the integers together
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法半群，其中将整数相乘
- en: '**Monoid**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 单子
- en: A monoid is a semigroup that also has an identity value. The identity value
    is a value that when associated with an object of the same type does not change
    its value. The Addition identity for integers is 0 and the identity for strings
    is the empty string.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 单子是一个同时具有标识值的半群。标识值是一个值，当与相同类型的对象关联时不会改变其值。整数的加法标识是0，字符串的标识是空字符串。
- en: A monoid also requires that the order of association to multiple values does
    not change the result, for example, *(1 + 2) + 3 == 1 + (2 + 3)*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 单子还要求多个值的关联顺序不会改变结果，例如，*(1 + 2) + 3 == 1 + (2 + 3)*。
- en: '**Monad**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**单子**'
- en: A monad can act both as a functor or as an applicative; refer to the dedicated
    [Chapter 5](ch05.html "Chapter 5.  Functors, Applicatives, and Monads"), *Functors,
    Applicatives, and Monads*, for more information.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 单子既可以作为函子，也可以作为应用程序；有关更多信息，请参阅专用[第5章](ch05.html "第5章。函子、应用程序和单子")，“函子、应用程序和单子”。
- en: '**Lift/LiftA/LiftM**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lift/LiftA/LiftM**'
- en: The process of taking something and putting it inside a functor, applicative,
    or monad respectively.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将某物放入函子、应用程序或单子的过程。
- en: '**Morphism**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**态射**'
- en: 'A transformation function. We can distinguish multiple kinds of morphisms:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 转换函数。我们可以区分多种形态：
- en: '**Endomorphism**: The type of the input and output stays the same, for example,
    making a string uppercase.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自同态**：输入和输出的类型保持不变，例如，将字符串大写。'
- en: '**Isomorphism**: The type changes, but the data stays the same, for example,
    transforming an array containing coordinates to a Coordinate object.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同构**：类型改变，但数据保持不变，例如，将包含坐标的数组转换为坐标对象。'
- en: '**Algebraic type / union type**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**代数类型/联合类型**'
- en: The combination of two types into a new one. Scala calls those either types.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将两种类型组合成一种新类型。Scala称这些为任一类型。
- en: '**Option type / maybe type**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项类型/可能类型**'
- en: A union type that contains a valid value and the equivalent of null. This kind
    of type is used when a function is not sure to return a valid value. [Chapter
    3](ch03.html "Chapter 3.  Functional Basis in PHP"), *Functional Basis in PHP*,
    explains how to use these to simplify error management.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 包含有效值和等效空值的联合类型。当函数不确定返回有效值时使用这种类型。[第3章](ch03.html "第3章。PHP中的函数基础")，“PHP中的函数基础”解释了如何使用这些简化错误管理。
- en: '**Idempotence**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**幂等性**'
- en: A function is said to be idempotent if reapplying it to its result does not
    produce a different result. If you compose an idempotent function with itself,
    it will still yield the same result.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新应用函数到其结果不会产生不同的结果，则称函数是幂等的。如果将幂等函数与自身组合，它仍将产生相同的结果。
- en: '**Lambda**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lambda**'
- en: A synonym for an anonymous function, that is, a function assigned to a variable.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数的同义词，即分配给变量的函数。
- en: '**Predicate**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**谓词**'
- en: A function that returns either true or false for a given set of parameters.
    Predicates are often used to filter collections.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的一组参数返回true或false的函数。谓词经常用于过滤集合。
- en: '**Referential transparency**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**引用透明性**'
- en: An expression is said to be referentially transparent if it can be replaced
    by its value without changing the outcome of the program. The concept is tightly
    linked to purity. [Chapter 2](ch02.html "Chapter 2.  Pure Functions, Referential
    Transparency, and Immutability"), *Pure functions, Referential Transparency, and
    Immutability*, explores the slight differences between the two.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式可以被其值替换而不改变程序的结果，则称表达式是引用透明的。这个概念与纯度紧密相关。[第2章](ch02.html "第2章。纯函数、引用透明和不可变性")，“纯函数、引用透明和不可变性”探讨了两者之间的细微差别。
- en: '**Lazy evaluations**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**惰性评估**'
- en: A language is said to be lazily evaluated if the result of an expression is
    only computed when it's needed. This allows you to create an infinite list and
    is only possible if an expression is referentially transparent.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式的结果只有在需要时才计算，则称语言是惰性评估的。这允许您创建无限列表，并且只有在表达式是引用透明时才可能。
- en: '**Non-strict language**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**非严格语言**'
- en: A non-strict language is a language where all constructs are lazily evaluated.
    Only a handful of languages are non-strict, mostly due to the fact that the language
    has to be pure in order to be non-strict and it poses non-trivial implementation
    issues. The most well-known non-strict language is probably Haskell.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 非严格语言是一种所有构造都是惰性评估的语言。只有少数语言是非严格的，主要是因为语言必须是纯粹的才能是非严格的，并且它带来了非平凡的实现问题。最著名的非严格语言可能是Haskell。
- en: 'Nearly all commonly seen languages are strict: C, Java, PHP, Ruby, Python,
    and so on.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有常见的语言都是严格的：C、Java、PHP、Ruby、Python等等。
- en: '**Variadic**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**可变元**'
- en: A function with dynamic arity is called **variadic**. This means the function
    accepts a variable number of parameters.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 具有动态元数的函数称为**可变元**。这意味着函数接受可变数量的参数。
