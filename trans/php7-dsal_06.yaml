- en: Understanding and Implementing Trees
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和实现树
- en: 'Our exploration of data structures has so far touched the linear parts only.
    Whether we used arrays, linked lists, stacks, or queues, all are linear data structures.
    We have seen the complexities of linear data structure operations, and most of
    the time, the insertion and deletion can be performed with `O(1)` complexity.
    However, the searching is a little complicated and takes `O(n)` complexity. The
    only exception is a PHP array, which, in fact, works as a hash table and can be
    searched in `O(1)` if the index or keys are managed in such a way. In order to
    solve this problem, we can use a hierarchical data structure instead of the linear
    one. Hierarchical data can solve many issues that a linear data structure cannot
    solve easily. Whenever we are talking about family tree, organization structure,
    and network connectivity diagrams, we are actually talking about hierarchical
    data. Trees are a special **Abstract Data Type** (**ADT** ) that represents hierarchical
    data. Unlike a linked list, which is also an ADT, trees are hierarchical compared
    to the linear nature of linked lists. In this chapter, we will explore the world
    of trees. A perfect example of a tree structure can be a family tree, just like
    the following image:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对数据结构的探索只涉及了线性部分。无论我们使用数组、链表、栈还是队列，所有这些都是线性数据结构。我们已经看到了线性数据结构操作的复杂性，大多数情况下，插入和删除可以以`O(1)`的复杂度执行。然而，搜索有点复杂，并且需要`O(n)`的复杂度。唯一的例外是PHP数组，实际上它的工作原理是哈希表，如果索引或键以这种方式管理，可以在`O(1)`中进行搜索。为了解决这个问题，我们可以使用分层数据结构而不是线性数据结构。分层数据可以解决许多线性数据结构无法轻松解决的问题。每当我们谈论家族谱系、组织结构和网络连接图时，实际上我们在谈论分层数据。树是一种表示分层数据的特殊**抽象数据类型**（**ADT**）。与链表不同，链表也是一种ADT，树是分层的，而链表是线性的。在本章中，我们将探索树的世界。树结构的一个完美例子可以是家族谱系，就像下面的图片：
- en: '![](Image00041.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00041.jpg)'
- en: Tree definition and properties
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树的定义和属性
- en: 'A tree is a hierarchical collection of nodes or vertices connected by edges.
    Trees cannot have cycles, and only edges will exist between a node and its descended
    nodes or child nodes. Two child nodes of a same parent cannot have any edges in
    between them. Each node can have a parent other than the top node, which is also
    known as the root node. There can be only one root node per tree. Each node can
    have zero or more child nodes. In the following diagram, **A** is the root node,
    and **B** , **C** , and **D** are the child nodes of **A** . We can also say that
    A is the parent node of **B** , **C** , and **D** . **B** , **C** , and **D**
    are known as siblings as they are child nodes from the same parent, **A** :'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 树是由边连接的节点或顶点的分层集合。树不能有循环，只有边存在于节点和其后代节点或子节点之间。同一父节点的两个子节点之间不能有任何边。每个节点除了顶节点（也称为根节点）外，还可以有一个父节点。每棵树只能有一个根节点。在下图中，**A**是根节点，**B**，**C**和**D**是**A**的子节点。我们还可以说A是**B**，**C**和**D**的父节点。**B**，**C**和**D**被称为兄弟姐妹，因为它们是来自同一父节点**A**的子节点：
- en: '![](Image00042.gif)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00042.gif)'
- en: 'The node that does not have any children is known as a leaf. In the preceding
    diagram, **K** , **L** , **F** , **G** , **M** , **I** , and **J** are leaf nodes.
    Leaf nodes are also known as external nodes or terminal nodes. A node, other than
    the root, having at least one child, is known as an internal node. Here, **B**
    , **C** , **D** , **E** , and **H** are internal nodes. Here are some other common
    terms we use when describing tree data structure:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何子节点的节点称为叶子。在前面的图表中，**K**，**L**，**F**，**G**，**M**，**I**和**J**都是叶子节点。叶子节点也称为外部节点或终端节点。除了根节点之外，至少有一个子节点的节点称为内部节点。在这里，**B**，**C**，**D**，**E**和**H**是内部节点。在描述树数据结构时，我们使用一些其他常见术语：
- en: '**Descendent** : This is a node that can be reached from a parent node by repeated
    proceedings. For example, **M** is a descendent of **C** in the previous diagram.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后代**：这是一个可以通过重复进行到达父节点的节点。例如，在前面的图表中，**M** 是**C**的后代。'
- en: '**Ancestor** : This is a node that can be reached from a child node to a parent
    node by a repeated way. For example, **B** is the ancestor of **L** .'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**祖先**：这是一个可以通过重复方式从子节点到父节点到达的节点。例如，**B**是**L**的祖先。'
- en: '**Degree** : The total number of child nodes of a particular parent node is
    known as its degree. In our example, **A** has degree 3, **B** has degree 1, **C**
    has degree 3, and **D** has degree 2.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**度**：特定父节点的子节点总数称为其度。在我们的例子中，**A** 的度为3，**B** 的度为1，**C** 的度为3，**D** 的度为2。'
- en: '**Path** : The sequence of nodes and edges from a source node to a target node
    is known as the path between two nodes. The length of the path is the number of
    nodes in the path. In our example, the path between **A** to **M** is **A-C-H-M**
    , and the length of the path is 4:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径**：从源节点到目标节点的节点和边的序列称为两个节点之间的路径。路径的长度是路径中的节点数。在我们的例子中，**A**到**M**的路径是**A-C-H-M**，路径的长度为4：'
- en: '![](Image00043.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00043.jpg)'
- en: '**Height of node** : The height of a node is defined by the number of edges
    between the node and the deepest level of the descendent node. For example, the
    height of node **B** is 2.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点的高度**：节点的高度由节点与后代节点的最深层之间的边的数量定义。例如，节点**B**的高度为2。'
- en: '**Level** : The level represents the generation of nodes. If a parent node
    is in level *n* , its child node will be in the *n+1* level. So, the level is
    defined by 1+ number of edges between the node and the root. Here:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层级**：层级表示节点的代。如果父节点在第*n*层，其子节点将在*n+1*层。因此，层级由节点与根之间的边的数量加1定义。在这里：'
- en: Root **A** is in **Level 0**
  id: totrans-14
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根**A**在**Level 0**
- en: '**B** , **C** , and **D** are in **Level 1**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B**，**C**和**D**在**Level 1**'
- en: '**E** , **F** , **G** , **H** , **I** , and **J** are in **Level 2**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**E**，**F**，**G**，**H**，**I**和**J**在**Level 2**'
- en: '**K** , **L** , and **M** are in **Level 3**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**K**，**L**和**M**在**Level 3**'
- en: '**Height of tree** : The height of a tree is defined by the height of its root
    node. Here, the height of the tree is 3.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树的高度**：树的高度由其根节点的高度定义。在这里，树的高度为3。'
- en: '**Subtree** : In a tree structure, each child forms a subtree recursively.
    In other words, a tree consists of many subtrees. For example, **B** forms a subtree
    with **E** , **K** , and **L** , whereas **E** forms a subtree with **K** and
    **L** . In the preceding example, we have identified each in the left-hand side
    in different shades. We can do the same for **C** and **D** and their subtrees
    as well.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子树**：在树结构中，每个子节点都递归地形成一个子树。换句话说，树由许多子树组成。例如，**B**与**E**，**K**和**L**形成一个子树，而**E**与**K**和**L**形成一个子树。在前面的例子中，我们已经在左侧用不同的颜色标识了每个子树。我们也可以对**C**和**D**及其子树做同样的事情。'
- en: '**Depth** : The depth of a node is determined by the number of edges between
    the node and the root node. For example, in our tree image, the depth of **H**
    is 2 and the depth of **L** is 3.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度**：节点的深度由节点与根节点之间的边的数量确定。例如，在我们的树图中，**H**的深度为2，**L**的深度为3。'
- en: '**Forest** : A forest is a set of zero or more disjoint trees.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**森林**：森林是零个或多个不相交树的集合。'
- en: '**Traverse** : This indicates the process of visiting nodes in a specific order.
    We will use this term often in the upcoming sections.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遍历**：这表示按特定顺序访问节点的过程。我们将在接下来的部分经常使用这个术语。'
- en: '**Keys** : A key is a value from the node that is used for searching purposes.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键**：键是用于搜索目的的节点中的值。'
- en: Implementing a tree using PHP
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP实现树
- en: 'So far, you have learned about different properties of a tree data structure.
    If we compare a tree data structure with a real-life example, we can consider
    our organization structure or family tree to represent the data structure. For
    an organization structure, there is one root node that can be the CEO of the company,
    followed by CXO-level employees, followed by other level employees. Here, we are
    not restricting any degree for a particular node. This means a node can have multiple
    children. So, let''s think of a node structure where we can define the node property,
    its parent node, and its children nodes. It might look something like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解了树数据结构的不同属性。如果我们将树数据结构与现实生活中的例子进行比较，我们可以考虑我们的组织结构或家族谱来表示数据结构。对于组织结构，有一个根节点，可以是公司的CEO，然后是CXO级别的员工，然后是其他级别的员工。在这里，我们不限制特定节点的程度。这意味着一个节点可以有多个子节点。因此，让我们考虑一个节点结构，我们可以定义节点属性、其父节点和其子节点。它可能看起来像这样：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we look at the preceding code, we can see that we have declared two public
    properties for data and children. We also have a method to add children to a particular
    node. Here, we are just appending the new child node at the end of the array.
    This will give us an option to add multiple nodes as children for a particular
    node. As a tree is a recursive structure, it will help us build a tree recursively
    and also traverse the tree in a recursive manner.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下前面的代码，我们可以看到我们为数据和子节点声明了两个公共属性。我们还有一个方法来向特定节点添加子节点。在这里，我们只是将新的子节点追加到数组的末尾。这将使我们有选择地为特定节点添加多个节点作为子节点。由于树是一个递归结构，它将帮助我们递归地构建树，也可以递归地遍历树。
- en: 'Now, we have the node; let''s build a tree structure that will define the root
    node of the tree and also a method to traverse the whole tree. So, the basic tree
    structure will look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了节点，让我们构建一个树结构，定义树的根节点以及遍历整个树的方法。因此，基本的树结构将如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code shows a simple tree class where we can store the root node
    reference and also traverse the tree from any node. In the traverse part, we are
    visiting each child node and then immediately recursively calling the traverse
    method to get the children of the current node. We are passing a level to print
    out a dash (-) at the beginning of the node name so that we can understand the
    child level data easily.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了一个简单的树类，我们可以在其中存储根节点引用，并从任何节点遍历树。在遍历部分，我们正在访问每个子节点，然后立即递归调用遍历方法以获取当前节点的子节点。我们正在传递一个级别，以便在节点名称的开头打印一个破折号（-），这样我们就可以轻松地理解子级数据。
- en: 'Let''s now create the root node and assign it to the tree as a root. The code
    will look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建根节点并将其分配给树作为根。代码将如下所示：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we created the first node as CEO, and then created the tree and assigned
    the CEO node as the root node of the tree. Now, it is time to grow our tree from
    the root node. Since we choose the example of the CEO, we will now add CXOs and
    other employees under the CEO. Here is the code for this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了第一个节点作为CEO，然后创建了树，并将CEO节点分配为树的根节点。现在是时候从根节点开始扩展我们的树了。由于我们选择了CEO的例子，我们现在将在CEO下添加CXO和其他员工。以下是此代码：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here we are creating four new nodes (CTO, CFO, CMO, and COO) at the beginning
    and assigning them as child nodes of the CEO node. Then we are creating Senior
    Architect and here is the Software engineer node followed by the user interface
    designer and Quality assurance engineer. We have assigned the senior software
    engineer node to be a child node of the senior architect node and senior architect
    to be a child node of CTO, along with user interface engineer and quality assurance
    engineer. The last line is to display the tree from the root. This will output
    the following lines in our command line:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在开始时创建了四个新节点（CTO、CFO、CMO和COO），并将它们分配为CEO节点的子节点。然后我们创建了高级架构师，这是软件工程师节点，接着是用户界面设计师和质量保证工程师。我们已经将高级软件工程师节点分配为高级架构师节点的子节点，并将高级架构师分配为CTO的子节点，以及用户界面工程师和质量保证工程师。最后一行是从根节点显示树。这将在我们的命令行中输出以下行：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If we consider the preceding output, we have `CEO` at level 0\. `CTO` , `CFO`
    , `CMO` , and `COO` are at level 1\. `Senior Architect` , `User Interface Designer`
    , and `Quality Assurance Engineer` are at level 2 and `Software Engineer` is at
    level 3.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前面的输出，我们在级别0处有`CEO`。`CTO`，`CFO`，`CMO`和`COO`在级别1处。`Senior Architect`，`User
    Interface Designer`和`Quality Assurance Engineer`在级别2处，`Software Engineer`在级别3处。
- en: We have constructed a basic tree data structure using PHP. Now, we will explore
    the different types of trees we have.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用PHP构建了一个基本的树数据结构。现在，我们将探索我们拥有的不同类型的树。
- en: Different types of tree structures
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的树结构
- en: There are many types of tree data structures present in the programming world.
    We will explore some of the most used tree structures here.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 编程世界中存在许多类型的树数据结构。我们将在这里探讨一些最常用的树结构。
- en: Binary tree
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉树
- en: 'Binary is the most basic form of tree structure where each node has a maximum
    of two child nodes. The child nodes are known as left and right nodes. A binary
    tree will look like the one shown in the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制是树结构的最基本形式，其中每个节点最多有两个子节点。子节点称为左节点和右节点。二叉树将如下图所示：
- en: '![](Image00044.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00044.jpg)'
- en: Binary search tree
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: 'A binary search tree (BST) is a special type of binary tree where the nodes
    are stored in a sorted manner. It is sorted in such a way that at any given point,
    a node value must be greater than or equal to the left child node value and smaller
    than the right child node value. Each node has to satisfy this property to consider
    it as a binary search tree. Since the nodes are sorted in a particular order,
    the binary search algorithm can be applied to search items in a BST in logarithmic
    time. It is always better than linear searching, which takes **O(n)** time, and
    we will explore it in the next chapter. Here is an example of a binary search
    tree:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树（BST）是一种特殊类型的二叉树，其中节点以排序的方式存储。它以这样一种方式排序，即在任何给定点，节点值必须大于或等于左子节点值，并且小于右子节点值。每个节点都必须满足此属性，才能将其视为二叉搜索树。由于节点按特定顺序排序，二叉搜索算法可以应用于以对数时间搜索BST中的项目。这总是优于线性搜索，它需要**O(n)**时间，我们将在下一章中探讨它。以下是一个二叉搜索树的示例：
- en: '![](Image00045.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00045.jpg)'
- en: Self-balanced binary search tree
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自平衡二叉搜索树
- en: 'A self-balanced binary search tree or height-balance binary search tree is
    a special type of binary search tree that attempts to keep the height or number
    of levels of the tree as small as possible all the time by adjusting automatically.
    For example, the following diagram shows a binary search tree on the left and
    a the self-balanced binary search tree on the right:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 自平衡二叉搜索树或高度平衡二叉搜索树是一种特殊类型的二叉搜索树，它试图通过自动调整始终保持树的高度或层级数尽可能小。例如，下图显示了左侧的二叉搜索树和右侧的自平衡二叉搜索树：
- en: '![](Image00046.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00046.jpg)'
- en: 'A height-balanced binary tree is always better as it helps search operations
    faster compared to a regular BST. There are different implementations of self-balanced
    or height-balanced binary search trees. Some of the popular ones are as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 高度平衡的二叉树总是比普通BST更好，因为它可以使搜索操作比普通BST更快。有不同的自平衡或高度平衡二叉搜索树的实现。其中一些流行的如下：
- en: AA tree
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AA树
- en: AVL tree
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AVL树
- en: Red-black tree
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红黑树
- en: Scapegoat tree
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替罪羊树
- en: Splay tree
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伸展树
- en: 2-3 tree
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2-3树
- en: Treap
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Treap
- en: We will discuss few of the height-balanced trees in the following sections.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节讨论一些高度平衡树。
- en: AVL tree
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AVL树
- en: 'An AVL tree is a self-balancing binary search tree where the heights of two
    child subtrees of a node will differ by a maximum of 1\. If the height increases,
    in any case, there will be a rebalance to make the height difference to 1\. This
    gives the AVL tree an added advantage of logarithmic complexity for different
    operations. Here is an example of an AVL tree:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: AVL树是一种自平衡的二叉搜索树，其中一个节点的两个子树的高度最多相差1。如果高度增加，在任何情况下都会重新平衡以使高度差为1。这使AVL树在不同操作的复杂度上具有对数优势。以下是AVL树的示例：
- en: '![](Image00047.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00047.jpg)'
- en: Red-black tree
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 红黑树
- en: 'A red-black tree is a self-balanced binary search tree with some extra properties,
    which is the color. Each node in the binary tree stores one extra bit of information,
    which is known as color and can have either red or black as values. Like an AVL
    tree, a red-black tree is also used for real-time applications as the average
    and worst case complexity is also logarithmic. A sample red-black tree looks like
    this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑树是一种具有额外属性的自平衡二叉搜索树，即颜色。二叉树中的每个节点存储一位额外的信息，即颜色，可以具有红色或黑色的值。与AVL树一样，红黑树也用于实时应用，因为平均和最坏情况的复杂度也是对数的。示例红黑树如下：
- en: '![](Image00048.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00048.jpg)'
- en: B-tree
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: B树
- en: A B-tree is a special type of binary tree, which is self-balanced. This is not
    the same as a self-balanced binary search tree. The key difference is that in
    a B-tree, we can have any number of nodes as child nodes, not just two. A B-tree
    is used for a large set of data and is mainly used in filesystems and databases.
    The complexity of different operations in a B-tree is logarithmic.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: B树是一种特殊类型的二叉树，它是自平衡的。这与自平衡的二叉搜索树不同。关键区别在于，在B树中，我们可以有任意数量的节点作为子节点，而不仅仅是两个。B树用于大量数据，并主要用于文件系统和数据库。B树中不同操作的复杂度是对数的。
- en: N-ary Tree
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: N叉树
- en: An N-ary tree is a special type of tree where a node can have maximum N children.
    This is also known as a k-way tree or M-ary tree. A binary tree is an N-ary tree
    where the value of N is 2.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: N叉树是一种特殊类型的树，其中一个节点最多可以有N个子节点。这也被称为k路树或M路树。二叉树是N叉树，其中N的值为2。
- en: Understanding a binary tree
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解二叉树
- en: We always get confused with binary trees and binary search trees. As we have
    seen in the definition, BST is a sorted binary tree. If it is sorted, then we
    can have the performance improvement compared to a regular binary tree. Each binary
    tree node can have a maximum of two child nodes, which are known as the left child
    node and right child node. However, based on the type of binary tree, there can
    be zero, one, or two child nodes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常会对二叉树和二叉搜索树感到困惑。正如我们在定义中所看到的，BST是一种排序的二叉树。如果它是排序的，那么与普通二叉树相比，我们可以有性能改进。每个二叉树节点最多可以有两个子节点，分别称为左子节点和右子节点。然而，根据二叉树的类型，可以有零个、一个或两个子节点。
- en: 'We can also classify binary trees into different categories:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将二叉树分类为不同的类别：
- en: '**Full binary tree:** A full binary tree is a tree that has either zero or
    two child nodes on each node. A full binary tree is also known as a proper tree
    or a plane binary tree.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**满二叉树：** 满二叉树是一棵树，每个节点上要么没有子节点，要么有两个子节点。满二叉树也被称为完全二叉树或平衡二叉树。'
- en: '**Perfect binary tree** : A perfect binary tree is a binary tree in which all
    internal nodes have exactly two child nodes and all leaves have the same level
    or depth.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完美二叉树：** 完美二叉树是一棵二叉树，其中所有内部节点恰好有两个子节点，所有叶子节点的级别或深度相同。'
- en: '**Complete binary tree:** A complete binary tree is a binary tree in which
    all levels, except the last level, are completely filled and all nodes are as
    far left as possible. The following diagram shows the full binary tree, complete
    binary tree, and perfect binary tree:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全二叉树：** 完全二叉树是一棵二叉树，除了最后一层外，所有层都完全填充，所有节点尽可能地靠左。以下图表显示了满二叉树、完全二叉树和完美二叉树：'
- en: '![](Image00049.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00049.jpg)'
- en: Implementing a binary tree
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现二叉树
- en: 'We will now create a binary tree (not a binary search tree). The key factor
    to have in a binary tree is that we must have two placeholders for the left child
    node and the right child node, along with the data we want to store in the node.
    A simple implementation of a binary node will look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个二叉树（不是二叉搜索树）。二叉树中必须具有的关键因素是，我们必须为左孩子节点和右孩子节点保留两个占位符，以及我们想要存储在节点中的数据。二叉节点的简单实现将如下所示：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code shows that we have a class with tree properties to store
    data, left and right. When we are constructing a new node, we are adding the node
    value to the data property, and left and right is kept `NULL` as we are not sure
    if we need those or not. We also have an `addChildren` method to add left children
    and right children to a particular node.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示，我们有一个带有树属性的类来存储数据，左边和右边。当我们构造一个新节点时，我们将节点值添加到数据属性中，左边和右边保持`NULL`，因为我们不确定是否需要它们。我们还有一个`addChildren`方法来向特定节点添加左孩子和右孩子。
- en: 'Now, we will create a binary tree class where we can define the root node as
    well as the traversal method similar to our basic tree implementation earlier
    in this chapter. The difference between two implementations is the traversal process.
    In our previous example, we used `foreach` to traverse each child node as we did
    not know how many nodes are there. Since each node in the binary tree can have
    a maximum of two nodes and they are named as left and right, we can only traverse
    the left node and then the right node for each particular node visit. The changed
    code will look like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个二叉树类，我们可以在其中定义根节点以及类似于本章早期的基本树实现的遍历方法。两种实现之间的区别在于遍历过程。在我们之前的示例中，我们使用`foreach`来遍历每个子节点，因为我们不知道有多少个节点。由于二叉树中的每个节点最多可以有两个节点，并且它们被命名为左和右，我们只能遍历左节点，然后遍历每个特定节点访问的右节点。更改后的代码将如下所示：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It looks very similar to the basic tree class we had earlier in this chapter.
    Now, let''s fill up the binary tree with some nodes. Usually, in any football
    or cricket tournament, we have knockout rounds where two teams play with each
    other, the winner moves forward, and it continues to the final. We can have a
    similar structure as a binary tree for our example. So, let''s create some binary
    nodes and structure them in a hierarchy:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与本章早期我们所拥有的基本树类非常相似。现在，让我们用一些节点填充二叉树。通常，在任何足球或板球比赛中，我们都有淘汰赛轮次，两支球队互相比赛，赢家继续前进，一直到决赛。我们可以在我们的示例中使用类似的结构作为二叉树。因此，让我们创建一些二叉节点并将它们结构化：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'First, we created a node called final and made it as a root node. Then, we
    created two semifinal nodes and four quarter final nodes. Two semifinal nodes
    each have two quarter final nodes as left and right child nodes. The final node
    has two semifinal nodes as left and right child nodes. The `addChildren` method
    is doing the children assignment job for the nodes. In the last line, we traversed
    the tree and displayed the data hierarchically. If we run this code in the command
    line, we will see the following output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个名为final的节点，并将其作为根节点。然后，我们创建了两个半决赛节点和四个四分之一决赛节点。两个半决赛节点分别有两个四分之一决赛节点作为左右子节点。最终节点有两个半决赛节点作为左右子节点。`addChildren`方法正在为节点执行子节点分配工作。在最后一行，我们遍历了树并按层次显示了数据。如果我们在命令行中运行此代码，我们将看到以下输出：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creating a binary tree using a PHP array
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP数组创建二叉树
- en: 'We can implement a binary tree using a PHP array. Since a binary tree has a
    maximum of zero to two child nodes, we can use the maximum child nodes as 2 and
    construct a formula to find the child nodes of a given node. Let''s number the
    nodes in a binary tree from top to bottom and left to right. So, the root node
    will have number **0** , the left child **1** , and right child **2** , and this
    will follow until each node is numbered, just like the following diagram:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用PHP数组实现二叉树。由于二叉树最多可以有零到两个子节点，我们可以将最大子节点数设为2，并构建一个公式来找到给定节点的子节点。让我们从上到下、从左到右为二叉树中的节点编号。因此，根节点将具有编号**0**，左孩子**1**，右孩子**2**，依此类推，直到为每个节点编号，就像以下图表所示：
- en: '![](Image00050.gif)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00050.gif)'
- en: 'We can easily see that for node **0** , the left child is **1,** and the right
    child **2** . For node **1** , the left child is **3,** and the right child is
    **4** , and it goes on. We can easily put this in a formula:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很容易看到，对于节点**0**，左孩子是**1**，右孩子是**2**。对于节点**1**，左孩子是**3**，右孩子是**4**，依此类推。我们可以很容易地将这个放入一个公式中：
- en: 'If *i* is our node number, then:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*i*是我们的节点编号，那么：
- en: '*Left node = 2 X i + 1*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*左节点= 2 X i + 1*'
- en: '*Right node = 2 X (i + 1)*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*右节点= 2 X (i + 1)*'
- en: 'Let''s now create our example for the match schedule part using a PHP array.
    If we rank it as per our discussion, then it will look like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用PHP数组创建比赛日程的示例。如果按照我们的讨论进行排名，那么它将如下所示：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Basically, we will create an array with auto-indexing, starting from 0\. This
    array will be used as a binary tree representation. Now, we will modify our `BinaryTree`
    class to use this array instead of our node class, with left and right child nodes
    as well as the traversal method. Now, we will traverse based on the node number
    instead of the actual node reference:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们将创建一个带有自动索引的数组，从0开始。这个数组将被用作二叉树的表示。现在，我们将修改我们的`BinaryTree`类，使用这个数组而不是我们的节点类，以及左右子节点以及遍历方法。现在，我们将基于节点编号而不是实际节点引用进行遍历：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we can see from preceding implementation, the traverse part uses the node
    positioning instead of a reference. This node position is nothing but the array
    indexes. So, we can directly access the array index and check whether it''s empty
    or not. If not, we can continue to go deeper using the recursive way. If we want
    to create the binary tree using the array and print the array values, we have
    to write the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的实现中可以看出，遍历部分使用节点位置而不是引用。这个节点位置就是数组索引。因此，我们可以直接访问数组索引并检查它是否为空。如果不为空，我们可以继续使用递归的方式深入。如果我们想使用数组创建二叉树并打印数组值，我们必须编写以下代码：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we run this code in the command line, we will see following output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在命令行中运行此代码，将会看到以下输出：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can use a simple `while` loop to iterate through the array and visit each
    node instead of proceeding recursively. In all our recursive examples, we will
    see that some are more efficient if we use them the iterative way. We can also
    just use them directly instead of creating a class for the binary tree.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个简单的`while`循环来遍历数组并访问每个节点，而不是递归进行。在我们所有的递归示例中，我们会发现如果以迭代的方式使用它们，有些会更有效率。我们也可以直接使用它们，而不是为二叉树创建一个类。
- en: Understanding the binary search tree
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解二叉搜索树
- en: A BST is a binary tree that is built in such way that the tree is always sorted.
    This means the left child node has a value less than or equal to the parent node
    value, and right child node will have the value greater than the parent node value.
    So, whenever we need to search a value, either we will search left or search right.
    As it is sorted, we have to search one part of the tree, not both, and this continues
    recursively. For its dividing nature, the searching becomes very fast, and we
    can achieve logarithmic complexity for the search. For example, if we have *n*
    number of nodes, we will search either the first half or second half of the nodes.
    Once we are in the first or second half, we can divide it again into two halves,
    which means our half now becomes a quarter, and it goes on and on until we reach
    the final node. As we are not moving to each node to search, it is not going to
    take `O(n)` complexity for the operation. In the next chapter, we will do the
    complexity analysis of a binary search and will see why the binary search tree
    has a search complexity of `O(log n)` . Unlike the binary tree, we cannot add
    any node to or remove any node from the tree without reconstructing the BST properties.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: BST是一种二叉树，它是按照树始终排序的方式构建的。这意味着左孩子节点的值小于或等于父节点的值，右孩子节点的值大于父节点的值。因此，每当我们需要搜索一个值时，要么搜索左边，要么搜索右边。由于它是排序的，我们只需要搜索树的一部分，而不是两部分，这种递归持续进行。由于它的分割性质，搜索变得非常快，我们可以实现对搜索的对数复杂度。例如，如果我们有*n*个节点，我们将搜索前半部分或后半部分的节点。一旦我们在前半部分或后半部分，我们可以再次将其分成两半，这意味着我们的一半现在变成了四分之一，如此循环直到达到最终节点。由于我们不是移动到每个节点进行搜索，因此操作不会花费`O(n)`的复杂度。在下一章中，我们将对二分搜索的复杂性进行分析，并看到为什么二叉搜索树的搜索复杂度是`O(log
    n)`。与二叉树不同，我们不能在不重建BST属性的情况下向树中添加任何节点或删除任何节点。
- en: If node **X** has two children, then the successor of node **X** is the smallest
    value that belongs to the tree, which is greater than the value of **X** . In
    other words, the successor is the minimum value of the right subtree. On the other
    hand, the predecessor is the maximum value of the left subtree. Now, we will focus
    more on the different operations of a BST and the steps we need to consider to
    perform those operations correctly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点**X**有两个孩子，则节点**X**的后继是属于树的最小值，大于**X**的值。换句话说，后继是右子树的最小值。另一方面，前驱是左子树的最大值。现在，我们将更多关注BST的不同操作以及执行这些操作时需要考虑的步骤。
- en: Here are the operations of a BST.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是BST的操作。
- en: Inserting a new node
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入一个新节点
- en: 'When we are inserting a new node in the binary search tree, we have to consider
    the following steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在二叉搜索树中插入一个新节点时，我们必须考虑以下步骤：
- en: Create a new node as a leaf (no left child or right child).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新节点作为叶子节点（没有左孩子或右孩子）。
- en: Start with the root node and set it as the current node.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从根节点开始，并将其设置为当前节点。
- en: If the node is empty, make the new node as the root.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果节点为空，则将新节点作为根。
- en: Check whether the new value is less than the current node or more.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查新值是小于当前节点还是大于当前节点。
- en: If less, go to the left and set the left as the current node.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果小于，则转到左侧并将左侧设置为当前节点。
- en: If more, go to the right and set the right as the current node.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果大于，则转到右侧并将右侧设置为当前节点。
- en: Continue to *step 3* until all the nodes are visited and the new node is set.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续*步骤3*，直到所有节点都被访问并设置了新节点。
- en: Searching a node
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索一个节点
- en: 'When we are searching a new node in a binary search tree, we have to consider
    the following steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在二叉搜索树中搜索一个新节点时，我们必须考虑以下步骤：
- en: Start with the root node and set it as the current node.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从根节点开始，并将其设置为当前节点。
- en: If the current node is empty, return false.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前节点为空，则返回false。
- en: If the current node value is the search value, return true.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前节点的值是搜索值，则返回true。
- en: Check whether the searching value is less than the current node or more.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查搜索值是小于当前节点还是大于当前节点。
- en: If less, go to the left and set the left as the current node.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果小于，则转到左侧并将左侧设置为当前节点。
- en: If more, go to the right and set the right as the current node.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果大于，则转到右侧并将右侧设置为当前节点。
- en: Continue to *step 3* until all the nodes are visited.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续*步骤3*，直到所有节点都被访问。
- en: Finding the minimum value
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找最小值
- en: 'As a binary search tree stores data in a sorted way, we can always find the
    smaller data in the left nodes and the bigger ones in the right node. So, finding
    the minimum value will require us to visit all the left nodes from the root node
    until we find the left-most node and its value. Here are the steps for finding
    the minimum value:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二叉搜索树以排序方式存储数据，我们始终可以在左节点中找到较小的数据，在右节点中找到较大的数据。因此，查找最小值将需要我们从根节点开始访问所有左节点，直到找到最左边的节点及其值。以下是查找最小值的步骤：
- en: Start with the root node and set it as the current node.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从根节点开始，并将其设置为当前节点。
- en: If the current node is empty, return false.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前节点为空，则返回false。
- en: Go to the left and set the left as the current node.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到左侧并将左侧设置为当前节点。
- en: If the current node does not have a left node, go to *step 5* ; otherwise, continue
    to *step 4* .
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前节点没有左节点，则转到*步骤5*；否则，继续*步骤4*。
- en: Continue to *step 3* until all the left nodes are visited.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续*步骤3*，直到所有左节点都被访问。
- en: Return the current node.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回当前节点。
- en: Finding the maximum value
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找最大值
- en: 'Here are the steps for finding the maximum value:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是查找最大值的步骤：
- en: Start with the root node and set it as the current node.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从根节点开始，并将其设置为当前节点。
- en: If the current node is empty, return false.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前节点为空，则返回false。
- en: Go to the right and set the right as the current node.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到右侧并将右侧设置为当前节点。
- en: If the current node does not have a right node, go to *step 5* ; otherwise,
    continue to *step 4* .
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前节点没有右节点，则转到*步骤5*；否则，继续*步骤4*。
- en: Continue to *step 3* until all the right nodes are visited.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续*步骤3*，直到所有右节点都被访问。
- en: Return the current node.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回当前节点。
- en: Deleting a node
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除节点
- en: 'When we are deleting a node, we have to consider that the node can be an internal
    node or a leaf. If it''s a leaf, it has zero children. However, if the node is
    internal, it can have one or two children. In such a case, we need to take extra
    steps to make sure the tree is constructed right after the deletion. That is why
    deleting a node from BST is always a challenging job compared to other operations.
    Here are the things to consider for a node deletion:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们删除一个节点时，我们必须考虑节点可以是内部节点或叶子节点。如果它是叶子节点，则它没有子节点。但是，如果节点是内部节点，则它可以有一个或两个子节点。在这种情况下，我们需要采取额外的步骤来确保在删除后树的构造是正确的。这就是为什么从BST中删除节点始终是一项具有挑战性的工作，与其他操作相比。以下是删除节点时要考虑的事项：
- en: If the node has no child, make the node NULL.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果节点没有子节点，则使节点为NULL。
- en: If the node has only one child, make the child take node's place.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果节点只有一个子节点，则使子节点取代节点的位置。
- en: If the node has two children, then find the successor of the node and replace
    it to the current node's place. Remove the successor node.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果节点有两个子节点，则找到节点的后继并将其替换为当前节点的位置。删除后继节点。
- en: We have discussed most of the possible operations for a binary search tree.
    Now, we will implement the binary search tree step-by-step, starting with insert,
    search, finding minimum and maximum, and at the end, the delete operation. Let's
    get started with the implementations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了二叉搜索树的大部分可能操作。现在，我们将逐步实现二叉搜索树，从插入、搜索、查找最小和最大值开始，最后是删除操作。让我们开始实现吧。
- en: Constructing a binary search tree
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建二叉搜索树
- en: 'As we know, a node can have two children and itself can represent a tree in
    a recursive manner. We will define our node class to be more functional and have
    all the required functionalities to find the maximum value, minimum value, predecessors,
    and successors. Later on, we will add the delete functionality as well for a node.
    Let''s check the following code for a node class for a BST:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，一个节点可以有两个子节点，并且本身可以以递归方式表示树。我们将定义我们的节点类更加功能强大，并具有所有必需的功能来查找最大值、最小值、前任和后继。稍后，我们还将为节点添加删除功能。让我们检查BST的节点类的以下代码：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The node class looks straightforward and matches with our steps defined in the
    previous section. Each new node is a leaf and hence, does not have a left or right
    node at the moment of creation. As we know that we can find the smaller value
    at the left of the node to find the minimum, we are reaching to the left-most
    node and right-most node for the maximum value. For a successor, we are finding
    the minimum value of a node from the right subtree of a given node and the maximum
    value of a node from the left subtree for the predecessor part.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 节点类看起来很简单，并且与我们在前一节中定义的步骤相匹配。每个新节点都是叶子节点，因此在创建时没有左节点或右节点。由于我们知道可以在节点的左侧找到较小的值以找到最小值，因此我们正在到达最左边的节点和最右边的节点以获取最大值。对于后继，我们正在从给定节点的右子树中找到节点的最小值，并且对于前任部分，我们正在从左子树中找到节点的最大值。
- en: 'Now, we need a BST structure to add new nodes in the tree so that we can follow
    the insert principle:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个BST结构来在树中添加新节点，以便我们可以遵循插入原则：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we look at the preceding code, we have only one property for the BST class,
    which will mark the root node. During the construction of the BST object, we are
    passing a single value, which will be used as the root of the tree. The `isEmpty`
    method checks whether the tree is empty or not. The `insert` method allows us
    to add a new node in the tree. The logic checks whether the value is greater than
    or less than the root node and follows the principle of the BST to insert the
    new node in the right position. If the value is already inserted, we will ignore
    it and avoid adding to the tree.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看前面的代码，我们只有一个BST类的属性，它将标记根节点。在构建BST对象时，我们传递一个单个值，该值将用作树的根。`isEmpty`方法检查树是否为空。`insert`方法允许我们在树中添加新节点。逻辑检查值是否大于或小于根节点，并遵循BST的原则将新节点插入正确的位置。如果值已经插入，我们将忽略它并避免添加到树中。
- en: 'We also have a `traverse` method to go through the nodes and see the data in
    an ordered format (first left, then the node, and then the right node value).
    It has a designated name, and we will explore that in the next section. For now,
    let''s prepare a sample code to use the BST class and add a few numbers and check
    whether the numbers are stored in a proper way. If the BST is working, then the
    traverse will show a sorted list of numbers, no matter how we insert them:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个`traverse`方法来遍历节点并以有序格式查看数据（首先左侧，然后是节点，然后是右侧节点的值）。它有一个指定的名称，我们将在下一节中探讨。现在，让我们准备一个样本代码来使用BST类，并添加一些数字，然后检查这些数字是否以正确的方式存储。如果BST有效，则遍历将显示一个有序的数字列表，无论我们如何插入它们：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we look at the preceding code, `10` is our root node, and then, we added
    new nodes randomly. At the end, we invoked the traverse method to show the nodes
    and how they are stored in the binary search tree. Here is the output of the preceding
    code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下前面的代码，`10`是我们的根节点，然后我们随机添加了新节点。最后，我们调用了遍历方法来显示节点以及它们在二叉搜索树中的存储方式。以下是前面代码的输出：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The actual tree will look like this visually, which looks exactly like what
    is expected from the BST implementation:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 实际树在视觉上看起来是这样的，与BST实现所期望的完全一样：
- en: '![](Image00051.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00051.jpg)'
- en: 'Now, we will add the search part in our BST class. We want to find whether
    the value exists in the tree or not. If the value is not in our BST, it will return
    false and the node otherwise. Here is the simple search functionality:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在我们的BST类中添加搜索部分。我们想要找出值是否存在于树中。如果值不在我们的BST中，它将返回false，否则返回节点。这是简单的搜索功能：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we can see that we are searching a value in the tree
    from the node and following either left or right of the tree iteratively. If no
    node is found with the value, the leaf of the node is returned, which is `NULL.`
    We can test the code like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们正在从节点中搜索树中的值，并迭代地跟随树的左侧或右侧。如果没有找到具有该值的节点，则返回节点的叶子节点，即`NULL`。我们可以这样测试代码：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will produce the following output. Since `14` is not in our list, it will
    say `Not Found` , and for `36` , it will show `Found` :'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出。由于`14`不在我们的列表中，它将显示`Not Found`，而对于`36`，它将显示`Found`：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we will move to our most complex part of the coding, the deletion of a
    node. We need to implement each of the cases where a node can have zero, one,
    or two child nodes. The following image shows us the three conditions we need
    to satisfy for deleting a node and making sure the binary search tree remains
    a binary search tree after the operation. We have to be careful when we are dealing
    with a node that has two child nodes. Since we need to go back and forth between
    nodes, we need to know which node is the parent node for the current node. As
    a result, we need to add an additional property to track the parent node for any
    node:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进入编码中最复杂的部分，即删除节点。我们需要实现节点可以有零个、一个或两个子节点的每种情况。以下图像显示了我们需要满足的删除节点的三个条件，并确保在操作后二叉搜索树仍然是二叉搜索树。当处理具有两个子节点的节点时，我们需要小心。因为我们需要在节点之间来回移动，我们需要知道当前节点的父节点是哪个节点。因此，我们需要添加一个额外的属性来跟踪任何节点的父节点：
- en: '![](Image00052.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00052.jpg)'
- en: 'Here is the change of code we are adding to our `Node` class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们要添加到`Node`类的代码更改：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code block now also creates a parent relationship with the newly created
    node to its immediate parent. We also want to attach our delete functionality
    with the individual node so that we can find a node and then just remove it using
    the `delete` method. Here is the code for the delete functionality:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码块现在还将新创建的节点与其直接父节点建立父子关系。我们还希望将我们的删除功能与单个节点关联起来，以便我们可以找到一个节点，然后只需使用`delete`方法将其删除。以下是删除功能的代码：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first condition checks whether the node is a leaf or not. If the node is
    a leaf, then we are just making the parent node to remove the reference of the
    child node (either the left or right one). That way, the node will be disconnected
    from the tree, which satisfies our first condition of having zero children.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条件检查节点是否是叶子节点。如果节点是叶子节点，那么我们只需使父节点删除子节点的引用（左侧或右侧）。这样，节点将与树断开连接，满足了我们零个子节点的第一个条件。
- en: The next conditions actually checks our third condition where we are having
    two children of a node. In such a case, we are getting the successor of the node,
    assigning the successor value to the node itself, and removing the successor node.
    It is simply a copy-paste of the data from the successor.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的条件实际上检查了我们的第三个条件，即节点有两个子节点的情况。在这种情况下，我们获取节点的后继节点，将后继节点的值分配给节点本身，并删除后继节点。这只是从后继节点复制数据。
- en: The next two condition check whether the node has a single child, as shown in
    our *Case 2* diagram earlier. Since the node has only one child, it can be either
    the left child or the right child. So, the condition checks whether the single
    child is the left child of the node. If so, we need to point the left child to
    the node's parent left or right reference based on the position of the node itself
    with its parent. The same rule is applied for the right node. Here, the right
    node reference is set to its parent's left or right child, not to a reference
    based on the position of the node.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个条件检查节点是否有单个子节点，就像我们之前的*Case 2*图表所示。由于节点只有一个子节点，它可以是左子节点或右子节点。因此，条件检查单个子节点是否是节点的左子节点。如果是，我们需要根据节点本身与其父节点的位置，将左子节点指向节点的父节点左侧或右侧引用。右子节点也适用相同的规则。在这里，右子节点引用设置为其父节点的左侧或右侧子节点，而不是基于节点位置的引用。
- en: 'As we have updated our node class, we need to make some changes to our BST
    class for insertion and also for removal of a node. The insertion code will look
    like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经更新了我们的节点类，我们需要对我们的BST类进行一些更改，以便插入和删除节点。插入代码将如下所示：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code looks similar to the one we used previously, with one minor change.
    Now, we are sending the current node reference when we are creating a new node.
    This current node will be used as a parent node for the new node. The `new Node($data,
    $node)` code actually does the trick.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来与我们之前使用的代码类似，只有一个小改变。现在，当我们创建一个新节点时，我们会发送当前��点的引用。这个当前节点将被用作新节点的父节点。`new
    Node($data, $node)`代码实际上就是这样做的。
- en: 'For removing a node, we can first do a search and then delete the searched
    node using our `delete` method in the node class. As a result, the `remove` function
    itself is going to be very small, just like the code here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于删除一个节点，我们可以先进行搜索，然后使用节点类中的`delete`方法删除搜索到的节点。因此，`remove`函数本身将会非常小，就像这里的代码一样：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As the code shows, we are first searching the data. If the node exists, we
    are removing it using the `delete` method. Now, let''s run our previous example
    with a `remove` call and see if it works:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，我们首先搜索数据。如果节点存在，我们将使用`delete`方法将其移除。现在，让我们运行我们之前的例子，使用`remove`调用，看看它是否有效：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are just removing `15` from our tree and then traversing the tree from the
    root. We will now see the following output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是从我们的树中移除`15`，然后从根节点遍历树。我们现在将看到以下输出：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can see that 15 is not a part of our BST anymore. In such a way, we can remove
    any node, and if we traverse using the same method, we will see a sorted list.
    If we look at our preceding output, we can see that the output is shown in the
    ascending order. There is a reason behind it, and we will explore it in the next
    topic-different tree traversal way.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到15不再是我们BST的一部分了。这样，我们可以移除任何节点，如果我们使用相同的方法进行遍历，我们将会看到一个排序的列表。如果我们看我们之前的输出，我们可以看到输出是按升序显示的。这其中有一个原因，我们将在下一个主题-不同的树遍历方式中探讨。
- en: You can find a great tool for visualized binary search tree operations at [http://btv.melezinek.cz/binary-search-tree.html](http://btv.melezinek.cz/binary-search-tree.html)
    . It is a good starting for learners to understand the different operations visually.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://btv.melezinek.cz/binary-search-tree.html](http://btv.melezinek.cz/binary-search-tree.html)找到一个用于可视化二叉搜索树操作的好工具。这对于学习者来说是一个很好的开始，可以通过可视化的方式理解不同的操作。
- en: Tree traversal
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树的遍历
- en: Tree traversal refers to the way we visit each node in a given tree. Based on
    how we do the traversing, we can follow three different ways of traversing. These
    traversals are very important in many different ways. Polish notation conversion
    for expression evaluation is one of the most popular examples of using tree traversals.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 树的遍历是指我们访问给定树中的每个节点的方式。根据我们进行遍历的方式，我们可以遵循三种不同的遍历方式。这些遍历在许多不同的方面都非常重要。表达式求值的波兰表示法转换就是使用树遍历的最流行的例子之一。
- en: In-order
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中序
- en: 'In-order tree traversal visits the left node first, then the root node, and
    followed by the right node. This continues recursively for each node. The left
    node stores a smaller value compared to the root node value and right node stores
    a bigger value than the root node. As a result, when we are applying in-order
    traversing, we are obtaining a sorted list. That is why, so far, our binary tree
    traversal was showing a sorted list of numbers. That traversal part is actually
    the example of an in-order tree traversal. The in-order tree traversal follows
    these principles:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 中序树遍历首先访问左节点，然后是根节点，然后是右节点。对于每个节点，这将递归地继续进行。左节点存储的值比根节点值小，右节点存储的值比根节点大。因此，当我们应用中序遍历时，我们得到一个排序的列表。这就是为什么到目前为止，我们的二叉树遍历显示的是一个排序的数字列表。这种遍历部分实际上就是中序树遍历的例子。中序树遍历遵循以下原则：
- en: Traverse the left subtree by recursively calling the in-order function.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过递归调用中序函数来遍历左子树。
- en: Display the data part of the root (or current node).
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示根（或当前节点）的数据部分。
- en: Traverse the right subtree by recursively calling the in-order function.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归调用中序函数来遍历右子树。
- en: '![](Image00053.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00053.jpg)'
- en: The preceding tree will show A, B, C, D, E, F, G, H, and I as output since it
    is being traversed in-order.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的树将显示A、B、C、D、E、F、G、H和I作为输出，因为它是按照中序遍历进行遍历的。
- en: Pre-order
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前序
- en: 'In pre-order traversal, the root node is visited first, followed by the left
    node and then the right node. The principles of pre-order traversal are as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前序遍历中，首先访问根节点，然后是左节点，然后是右节点。前序遍历的原则如下：
- en: Display the data part of the root (or current node).
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示根（或当前节点）的数据部分。
- en: Traverse the left subtree by recursively calling the pre-order function.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过递归调用前序函数来遍历左子树。
- en: Traverse the right subtree by recursively calling the pre-order function.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过递归调用前序函数来遍历右子树。
- en: '![](Image00054.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00054.jpg)'
- en: The preceding tree will have F, B, A, D, C, E, G, I, and H as output as it is
    being traversed in pre-order.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的树将以F、B、A、D、C、E、G、I和H作为输出，因为它是按照前序遍历进行遍历的。
- en: Post-order
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后序
- en: 'In post-order traversal, the root node is visited last. The first left node
    is visited and then the right node. The principles of post-order traversal are
    as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在后序遍历中，最后访问根节点。首先访问左节点，然后是右节点。后序遍历的原则如下：
- en: Traverse the left subtree by recursively calling the post-order function.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过递归调用后序函数来遍历左子树。
- en: Traverse the right subtree by recursively calling the post-order function.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过递归调用后序函数来遍历右子树。
- en: Display the data part of the root (or current node).
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示根（或当前节点）的数据部分。
- en: '![](Image00055.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00055.jpg)'
- en: The preceding tree will have the output A, C, E, D, B, H, I, G, and F since
    it is traversed in a post-order way.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 前序遍历将以A、C、E、D、B、H、I、G和F作为输出，因为它是按照后序遍历进行遍历的。
- en: 'Now, let''s implement the traversal logic in our BST class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的BST类中实现遍历逻辑：
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, if we run the three different traversal methods for our previous binary
    search tree, here is the code to run the traversal part:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们对我们之前的二叉搜索树运行三种不同的遍历方法，这里是运行遍历部分的代码：
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will produce the following output in our command line:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的命令行中产生以下输出：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Complexity of different tree data structures
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同树数据结构的复杂性
- en: 'So far, we have seen different tree types and their operations. It is not possible
    to go through each of the tree types and their different operations, as this will
    be out of the scope of the book. We want to get the minimal idea about the other
    tree structures and their operation complexities. Here is a chart with average
    and worst case complexities of different operations and spaces for different types
    of trees. We might need to choose different tree structures based on our requirements:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了不同的树类型及其操作。不可能逐一介绍每种树类型及其不同的操作，因为这将超出本书的范围。我们希望对其他树结构及其操作复杂性有一个最基本的了解。下面是一个包含不同类型树的平均和最坏情况下操作复杂度以及空间的图表。根据我们的需求，我们可能需要选择不同的树结构：
- en: '![](Image00056.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00056.jpg)'
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the non-linear data structure in detail. You learned
    that trees are hierarchical data structures and that there are different tree
    types, operations, and complexities. We have also seen how to define a binary
    search tree. This will be very useful for implementing different searching techniques
    and data storage. In our next chapter, we will shift our focus from data structures
    to algorithms. We will focus on the first type of algorithm--the sorting algorithms.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细讨论了非线性数据结构。您了解到树是分层数据结构，有不同的树类型、操作和复杂性。我们还看到了如何定义二叉搜索树。这对于实现不同的搜索技术和数据存储将非常有用。在下一章中，我们将把重点从数据结构转移到算法上。我们将专注于第一类算法--排序算法。
