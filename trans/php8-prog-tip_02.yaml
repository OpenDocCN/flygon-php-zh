- en: '*Chapter 1*: Introducing New PHP 8 OOP Features'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第1章*：介绍新的PHP 8 OOP特性'
- en: 'In this chapter, you are introduced to new **PHP: Hypertext Preprocessor 8**
    (**PHP 8**) features specific to **Object-Oriented Programming** (**OOP**). The
    chapter features a set of classes that can be used to generate CAPTCHA images
    (**CAPTCHA** is an acronym for **Completely Automated Public Turing test to tell
    Computers and Humans Apart**), clearly illustrating new PHP 8 features and concepts.
    This chapter is critical in helping you quickly incorporate new PHP 8 features
    into your own practice. In doing so, your code will run faster and more efficiently,
    with fewer bugs.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，您将了解到针对**面向对象编程**（**OOP**）的**PHP: Hypertext Preprocessor 8**（**PHP 8**）的新特性。本章介绍了一组类，可用于生成CAPTCHA图像（**CAPTCHA**是**Completely
    Automated Public Turing test to tell Computers and Humans Apart**的缩写），清晰地说明了新的PHP
    8特性和概念。本章对于帮助您快速将新的PHP 8特性纳入到您自己的实践中至关重要。这样做，您的代码将运行得更快、更高效，bug更少。'
- en: 'The following topics are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Using constructor property promotion
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用构造函数属性提升
- en: Working with attributes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性
- en: Incorporating match expressions into your program code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将匹配表达式纳入您的程序代码
- en: Understanding named arguments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解命名参数
- en: Exploring new data types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索新的数据类型
- en: Improving code using typed properties
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型属性改进代码
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To examine and run the code examples provided in this chapter, the minimum
    recommended hardware is listed here:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查和运行本章提供的代码示例，以下是最低推荐的硬件要求：
- en: x86_64-based desktop PC or laptop
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于x86_64的台式PC或笔记本电脑
- en: 1 gigabyte (**GB**) free disk space
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 GB的可用磁盘空间
- en: 4 GB of **random-access memory** (**RAM**)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 GB的**随机存取存储器**（**RAM**）
- en: 500 **kilobits per second** (**Kbps**) or faster internet connection
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 500 **千位每秒**（**Kbps**）或更快的互联网连接
- en: 'In addition, you will need to install the following software:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您需要安装以下软件：
- en: Docker
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Docker Compose
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: 'This book uses a pre-built Docker image that contains all the needed software
    to create and run the PHP 8 code examples covered in this book. You do not need
    to install PHP, Apache, or MySQL on your computer: just use Docker and the provided
    image.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用一个预构建的Docker镜像，其中包含创建和运行本书中涵盖的PHP 8代码示例所需的所有软件。您不需要在计算机上安装PHP、Apache或MySQL：只需使用Docker和提供的镜像即可。
- en: 'To set up a test environment to run the code examples, proceed as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个用于运行代码示例的测试环境，请按照以下步骤进行：
- en: Install Docker.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Docker。
- en: 'If you are running Windows, start here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行Windows，请从这里开始：
- en: '[https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/
    )'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/
    )'
- en: 'If you are on a Mac, start here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Mac，请从这里开始：
- en: '[https://docs.docker.com/docker-for-mac/install/](https://docs.docker.com/docker-for-mac/install/
    )'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/docker-for-mac/install/](https://docs.docker.com/docker-for-mac/install/
    )'
- en: 'If you are on Linux, have a look here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Linux，请看这里：
- en: '[https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/
    )'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/
    )'
- en: 'Install Docker Compose. For all operating systems, start here:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Docker Compose。对于所有操作系统，请从这里开始：
- en: '[https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/
    )'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/
    )'
- en: Install the source code associated with this book onto your local computer.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将与本书相关的源代码安装到您的本地计算机上。
- en: 'If you have installed Git, use the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已安装Git，请使用以下命令：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Otherwise, you can simply download the source code from this **Uniform Resource
    Locator** (**URL**): [https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices/archive/main.zip](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices/archive/main.zip).
    You can then unzip into a folder you create, which we refer to as `/repo` in this
    book.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您可以直接从以下**统一资源定位器**（**URL**）下载源代码：[https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices/archive/main.zip](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices/archive/main.zip)。然后解压到一个您创建的文件夹中，在本书中我们将其称为`/repo`。
- en: You can now start the Docker daemon running. For Windows or Mac, all you need
    to do is to activate the Docker Desktop app.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以启动Docker守护程序。对于Windows或Mac，您只需要激活Docker Desktop应用程序。
- en: 'If you are running Ubuntu or Debian Linux, issue this command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行Ubuntu或Debian Linux，请发出以下命令：
- en: '`sudo service docker start`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo service docker start`'
- en: 'For Red Hat, Fedora, or CentOS, use this command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Red Hat、Fedora或CentOS，请使用以下命令：
- en: '`sudo systemctl start docker`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sudo systemctl start docker`命令启动Docker。
- en: Build a Docker container associated with this book and bring it online. To do
    so, proceed as follows.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建与本书相关的Docker容器并将其上线。要做到这一点，请按照以下步骤进行。
- en: From your local computer, open Command Prompt (terminal window). Change the
    directory to `/repo`. For the first time only, issue the `docker-compose build`
    command to *build* the environment. Note that you might need `root` (administrator)
    privileges to run Docker commands. If this is the case, either run as administrator
    (for Windows) or preface the command with `sudo`. Depending on your connection
    speed, the initial build might take quite a bit of time to complete!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的本地计算机，打开命令提示符（终端窗口）。将目录更改为`/repo`。仅首次，发出`docker-compose build`命令来*构建*环境。请注意，您可能需要`root`（管理员）权限来运行Docker命令。如果是这种情况，要么以管理员身份运行（对于Windows），要么在命令前加上`sudo`。根据您的连接速度，初始构建可能需要相当长的时间才能完成！
- en: To bring the container up, proceed as follows
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动容器，请按照以下步骤进行
- en: 'From your local computer, open Command Prompt (terminal window). Change the
    directory to `/repo`. Bring the Docker container online in background mode by
    running the following command:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的本地计算机，打开命令提示符（终端窗口）。将目录更改为`/repo`。通过运行以下命令以后台模式启动Docker容器：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that you actually don't need to build the container separately. If the
    container is not built when you issue the `docker-compose up` command, it will
    be built automatically. On the other hand, it might be convenient to build the
    container separately, in which case `docker build` will suffice.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，实际上您不需要单独构建容器。如果在发出`docker-compose up`命令时容器尚未构建，它将自动构建。另一方面，单独构建容器可能很方便，这种情况下只需使用`docker
    build`即可。
- en: 'Here''s a useful command to ensure all containers are running:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个确保所有容器都在运行的有用命令：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To access the running Docker container web server, proceed as follows.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问运行中的Docker容器Web服务器，请按照以下步骤进行。
- en: 'Open the browser on your local computer. Enter this URL to access PHP 8 code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的本地计算机上打开浏览器。输入此URL以访问PHP 8代码：
- en: '`http://localhost:8888`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8888`'
- en: 'Enter this URL to access PHP 7 code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输入此URL以访问PHP 7代码：
- en: '`http://localhost:7777`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:7777`'
- en: To open a command shell into the running Docker container, proceed as follows.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打开运行中的Docker容器的命令行，按照以下步骤进行。
- en: 'From your local computer, open Command Prompt (terminal window). Issue this
    command to access the PHP 8 container:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的本地计算机上，打开命令提示符（终端窗口）。发出此命令以访问PHP 8容器：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Issue this command to access the PHP 7 container:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 发出此命令以访问PHP 7容器：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you are finished working with the container, to take it offline open Command
    Prompt (terminal window) from your local computer and issue this command:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您完成与容器的工作后，要将其脱机，请从您的本地计算机上打开命令提示符（终端窗口）并发出此命令：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The source code for this chapter is located here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于此处：
- en: '[https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices
    )'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices
    )'
- en: Important note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If your host computer uses **Advanced RISC Machines** (**ARM**) architecture
    (for example, Raspberry Pi), you will need to use a modified Dockerfile.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的主机计算机使用**高级精简指令集**（**ARM**）架构（例如，树莓派），您将需要使用修改后的Dockerfile。
- en: Tip
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'It would be an excellent idea to get a quick overview of Docker technology
    and terms by reviewing this article: [https://docs.docker.com/get-started/.](https://docs.docker.com/get-started/
    )'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看这篇文章，快速了解Docker技术和术语是一个很好的主意：[https://docs.docker.com/get-started/.](https://docs.docker.com/get-started/
    )
- en: We can now begin our discussion by having a look at constructor property promotion.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过查看构造函数属性提升来开始我们的讨论。
- en: Using constructor property promotion
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用构造函数属性提升
- en: Aside from the **Just-In-Time** (**JIT**) compiler, one of the greatest new
    features introduced in PHP 8 is **constructor property promotion**. This new feature
    combines property declarations and argument lists in the `__construct()` method
    signature, as well as assigning defaults. In this section, you will learn how
    to substantially reduce the amount of coding required in property declarations
    as well as in the `__construct()` method signature and body.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**即时**（**JIT**）编译器之外，PHP 8中引入的最大的新功能之一是**构造函数属性提升**。这个新功能将属性声明和`__construct()`方法签名中的参数列表以及赋默认值结合在一起。在本节中，您将学习如何大大减少属性声明和`__construct()`方法签名和主体中所需的编码量。
- en: Property promotion syntax
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性提升语法
- en: 'The syntax needed to invoke constructor property promotion is identical to
    that used in PHP 7 and earlier, with the following differences:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 调用构造函数属性提升所需的语法与PHP 7和之前使用的语法相同，有以下区别：
- en: You need to define a **visibility level**
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要定义一个**可见级别**
- en: You do not have to explicitly declare the properties in advance
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不必事先显式声明属性。
- en: You do not need to make assignments in the body of the `__construct()` method
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不需要在`__construct()`方法的主体中进行赋值
- en: 'Here is a bare-bones example of code that uses constructor property promotion:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用构造函数属性提升的代码的简单示例：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When the preceding code block is executed, this is the output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码块时，这是输出：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This shows that an instance of `Test` type has been created using default values.
    Now, let's have a look at how this feature might save a substantial amount of
    coding.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明使用默认值创建了`Test`类型的实例。现在，让我们看看这个功能如何可以节省大量的编码。
- en: Using property promotion for code reduction
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用属性提升来减少代码
- en: 'In a conventional OOP PHP class, the following three things need to be done:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的OOP PHP类中，需要完成以下三件事：
- en: 'Declare the properties, as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明属性，如下所示：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Identify the properties and their data type in the `__construct()` method signature,
    as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__construct()`方法签名中标识属性及其数据类型，如下所示：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the body of the `__construct()` method, assign values to properties, like
    this:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__construct()`方法的主体中，为属性赋值，就像这样：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As the number of constructor arguments increases, the amount of work you need
    to do also increases significantly. When constructor property promotion is applied,
    the amount of code required to do the same as previously shown is reduced to one-third
    of the original.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 随着构造函数参数的增加，您需要做的工作量也会显著增加。当应用构造函数属性提升时，以前所需的相同代码量减少到原来的三分之一。
- en: 'Let''s now have a look at the same block of code as shown previously, but rewritten
    using this powerful new PHP 8 feature:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下之前显示的同一段代码块，但是使用这个强大的新PHP 8功能进行重写：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Amazingly, what took 24 lines of code in PHP 7 and earlier can be collapsed
    into eight lines of code using this new PHP 8 feature!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，在PHP 7和之前的版本中需要24行代码，而使用这个新的PHP 8功能可以缩减为8行代码！
- en: You are completely free to include other code in the constructor. In many cases,
    however, constructor property promotion takes care of everything normally done
    in the `__construct()` method, which means you can literally leave it empty (`{
    }`).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您完全可以在构造函数中包含其他代码。然而，在许多情况下，构造函数属性提升会处理`__construct()`方法中通常完成的所有工作，这意味着您可以将其留空（`{
    }`）。
- en: Now, in the next section, you learn about a new feature called attributes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在下一节中，您将了解一个称为属性的新功能。
- en: Tip
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Have a look at the full SingleChar class for PHP 7 here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里查看PHP 7的完整SingleChar类的更多信息：
- en: '[https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices/tree/main/src/Php7/Image](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices/tree/main/src/Php7/Image
    )'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices/tree/main/src/Php7/Image](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices/tree/main/src/Php7/Image)'
- en: 'Also, the equivalent PHP 8 class is found here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，等效的PHP 8类可以在这里找到：
- en: '[https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices/tree/main/src/Php8/Image](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices/tree/main/src/Php8/Image
    )'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices/tree/main/src/Php8/Image](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices/tree/main/src/Php8/Image)'
- en: 'For more information on this new feature, have a look at the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此新功能的更多信息，请参阅以下内容：
- en: '[https://wiki.php.net/rfc/constructor_promotion](https://wiki.php.net/rfc/constructor_promotion
    )'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.php.net/rfc/constructor_promotion](https://wiki.php.net/rfc/constructor_promotion)'
- en: Working with attributes
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用attributes
- en: Another significant addition to PHP 8 is the addition of a brand-new class and
    language construct known as **attributes**. Simply put, attributes are replacements
    for traditional PHP comment blocks that follow a prescribed syntax. When the PHP
    code is compiled, these attributes are converted internally into `Attribute` class
    instances.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8的另一个重要补充是全新的类和语言构造，称为**attributes**。简而言之，attributes是传统PHP注释块的替代品，遵循规定的语法。当PHP代码编译时，这些attributes会在内部转换为`Attribute`类实例。
- en: This new feature is not going to have an immediate impact on your code today.
    It will start to become more and more influential, however, as the various PHP
    open source vendors start to incorporate attributes into their code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新功能不会立即影响您的代码。然而，随着各种PHP开源供应商开始将attributes纳入其代码中，它将开始变得越来越有影响力。
- en: The `Attribute` class addresses a potentially significant performance issue
    we discuss in this section, pertaining to an abuse of the traditional PHP comment
    block to provide meta-instructions. Before we dive into that issue and how `Attribute`
    class instances address the problem, we first must review PHP comments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Attribute`类解决了我们在本节讨论的一个潜在重要的性能问题，即滥用传统PHP注释块提供元指令。在我们深入讨论这个问题以及`Attribute`类实例如何解决问题之前，我们首先必须回顾一下PHP注释。'
- en: Overview of PHP comments
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP注释概述
- en: 'The need for this form of language construct arose with the increasing use
    (and abuse!) of the plain workhorse PHP comment. As you are aware, comments come
    in many forms, including all of the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语言构造的需求是随着对普通PHP注释的使用（和滥用！）的增加而产生的。正如您所知，注释有许多形式，包括以下所有形式：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The last item, the famous PHP `DocBlock`, is now so widely used it's become
    a de facto standard. The use of DocBlocks is not a bad thing. On the contrary—it's
    often the *only* *way* a developer is able to communicate information about properties,
    classes, and methods. The problem only arises in how it is treated by the PHP
    interpretation process.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一项，著名的PHP `DocBlock`，现在被广泛使用，已成为事实上的标准。使用DocBlocks并不是一件坏事。相反，这往往是开发人员能够传达有关属性、类和方法的信息的*唯一*
    *方式*。问题只在于它在PHP解释过程中的处理方式。
- en: PHP DocBlock considerations
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP DocBlock注意事项
- en: The original intent of the **PHP DocBlock** has been stretched by a number of
    extremely important PHP open-source projects. One striking example is the Doctrine
    **Object-Relational Mapper** (**ORM**) project. Although not mandatory, many developers
    choose to define ORM properties using **annotations** nested inside PHP DocBlocks.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**PHP DocBlock**的原始意图已经被一些非常重要的PHP开源项目所拉伸。一个鲜明的例子是Doctrine **对象关系映射**（**ORM**）项目。虽然不是强制的，但许多开发人员选择使用嵌套在PHP
    DocBlocks中的**annotations**来定义ORM属性。'
- en: 'Have a look at this partial code example, which defines a class interacting
    with a database table called `events`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个部分代码示例，它定义了一个与名为`events`的数据库表交互的类：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you were to use this class as part of a Doctrine ORM implementation, Doctrine
    would open the file and parse the DocBlocks, searching for `@ORM` annotations.
    Despite some concerns over the time and resources needed to parse DocBlocks, this
    is an extremely convenient way to define the relationship between object properties
    and database table columns, and is popular with developers who use Doctrine.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要将此类用作Doctrine ORM实现的一部分，Doctrine将打开文件并解析DocBlocks，搜索`@ORM`注释。尽管对解析DocBlocks所需的时间和资源有一些担忧，但这是一种非常方便的方式来定义对象属性和数据库表列之间的关系，并且受到使用Doctrine的开发人员的欢迎。
- en: Tip
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Doctrine offers a number of alternatives to this form of ORM, including **Extensible
    Markup Language** (**XML**) and native PHP arrays. For more information, see [https://www.doctrine-project.org/projects/doctrine-orm/en/latest/reference/annotations-reference.html#annotations-reference](https://www.doctrine-project.org/projects/doctrine-orm/en/latest/reference/annotations-reference.html#annotations-reference).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine提供了许多替代方案来实现ORM，包括**可扩展标记语言**（**XML**）和本机PHP数组。有关更多信息，请参阅[https://www.doctrine-project.org/projects/doctrine-orm/en/latest/reference/annotations-reference.html#annotations-reference](https://www.doctrine-project.org/projects/doctrine-orm/en/latest/reference/annotations-reference.html#annotations-reference)。
- en: Hidden dangers associated with the misuse of DocBlocks
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与滥用DocBlocks相关的潜在危险
- en: There is yet another danger associated with this abuse of the original purpose
    of a DocBlock. In the `php.ini` file, there is a setting named `opcache.save_comments`.
    If disabled, this would cause the OpCode cache engine (**OPcache**) to *ignore*
    all comments, including DocBlocks. If this setting is in effect, a Doctrine-based
    application using `@ORM` annotations in DocBlocks would malfunction.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与滥用DocBlock的原始目的相关的另一个危险是。在`php.ini`文件中，有一个名为`opcache.save_comments`的设置。如果禁用，这将导致OpCode缓存引擎（**OPcache**）*忽略*所有注释，包括DocBlocks。如果此设置生效，使用`@ORM`注释的基于Doctrine的应用程序将发生故障。
- en: Another problem has to do with how comments are parsed—or, more to the point,
    how comments are *not* parsed. In order to use the contents of a comment, the
    PHP application needs to open the file and parse it line by line. This is an expensive
    process in terms of time and resource utilization.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题与注释的解析有关，或者更准确地说，与注释的*不*解析有关。为了使用注释的内容，PHP应用程序需要逐行打开文件并解析它。这在时间和资源利用方面是一个昂贵的过程。
- en: The Attribute class
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性类
- en: In order to address hidden dangers, in PHP 8 a new `Attribute` class is provided.
    Instead of using DocBlocks with annotations, developers can define the equivalent
    in the form of attributes. An advantage of using attributes rather than DocBlocks
    is that they are a *formal part of the language* and are thus tokenized and compiled
    along with the rest of your code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决隐藏的危险，在PHP 8中提供了一个新的`Attribute`类。开发人员可以定义等效的属性形式，而不是使用带注释的DocBlocks。使用属性而不是DocBlocks的优势在于它们是语言的*正式部分*，因此它们与代码的其余部分一起被标记化和编译。
- en: Important note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In this chapter, and also in the PHP documentation, reference to *attributes*
    refers to instances of the `Attribute` class.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，以及在PHP文档中，*属性*的引用指的是`Attribute`类的实例。
- en: Actual performance metrics are not yet available that compare the loading of
    PHP code containing DocBlocks with the loading of code that contains attributes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 目前尚无实际的性能指标可比较包含DocBlocks的PHP代码的加载与包含属性的代码的加载。
- en: Although the benefits of this approach are not yet seen, as the various open
    source project vendors start to incorporate attributes into their offerings you
    will start to see an improvement in speed and performance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法的好处尚未显现，但随着各种开源项目供应商开始将属性纳入其产品中，您将开始看到速度和性能的提高。
- en: 'Here is the `Attribute` class definition:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Attribute`类的定义：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see from the class definition, the main contribution from this class,
    used internally by PHP 8, is a set of class constants. The constants represent
    bit flags that can be combined using bitwise operators.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从类定义中可以看出，这个类在PHP 8内部使用的主要贡献是一组类常量。这些常量代表可以使用位运算符组合的位标志。
- en: Attribute syntax
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性语法
- en: 'Attributes are enclosed using a special syntax borrowed from the **Rust** programming
    language. What goes inside the square brackets is pretty much left to the developer.
    An example can be seen in the following snippet:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 属性使用了从**Rust**编程语言借鉴的特殊语法。方括号内的内容基本上由开发人员决定。以下代码段中可以看到一个示例：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Returning to our example of the `SingleChar` class, here''s how it might appear
    using traditional DocBlocks:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`SingleChar`类的示例，这是如何在传统的DocBlocks中出现的：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, have a look at the same thing using attributes:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看使用属性的相同内容：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, in addition to providing a more robust compilation and avoiding
    the hidden dangers mentioned, it's also more efficient in terms of space usage.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，除了提供更强大的编译和避免上述隐藏危险之外，它在空间使用方面也更有效。
- en: Tip
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'What goes inside the square brackets does have some restrictions; for example,
    although `#[returns("int")]` is allowed, this is not: `#[return("int")`. The reason
    for this is because `return` is a keyword.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号内的内容确实有一些限制；例如，虽然允许`#[returns("int")]`，但不允许这样做：`#[return("int")`。原因是`return`是一个关键字。
- en: 'Another example has to do with **union types** (explained in the *Exploring
    new data types* section). You can use `#[param("int|array test")]` in an attribute,
    but this is not allowed: `#[int|array("test")]`. Another peculiarity is that class-level
    attributes must be placed *immediately before* the `class` keyword and after any
    `use` statements.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子涉及**联合类型**（在*探索新数据类型*部分中解释）。您可以在属性中使用`#[param("int|array test")]`，但不允许这样做：`#[int|array("test")]`。另一个特殊之处是类级别的属性必须放在`class`关键字之前，并在任何`use`语句之后。
- en: Viewing attributes using Reflection
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Reflection查看属性
- en: If you need to get attribute information from a PHP 8 class, the `Reflection`
    extension has been updated to include attribute support. A new `getAttributes()`
    method that returns an array of `ReflectionAttribute` instances has been added.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要从PHP 8类获取属性信息，`Reflection`扩展已更新以包括属性支持。添加了一个新的`getAttributes()`方法，返回一个`ReflectionAttribute`实例数组。
- en: 'In the following block of code, all the attributes from the `Php8\Image\SingleChar::colorAlloc()`
    method are revealed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，显示了`Php8\Image\SingleChar::colorAlloc()`方法的所有属性：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the output from the code shown in the preceding snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码段中显示的输出：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding output shows that attributes can be detected using the `Reflection`
    extension classes. Finally, the actual method is shown in this code example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示了可以使用`Reflection`扩展类检测属性。最后，这段代码示例展示了实际的方法：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that you have an idea of how attributes can be used, let's continue our
    coverage of new features by discussing `match` expressions, followed by named
    arguments.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经了解了属性的使用方式，让我们继续讨论`match`表达式，然后是命名参数的新功能。
- en: Tip
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on this new feature, have a look at the following web
    page:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此新功能的更多信息，请查看以下网页：
- en: '[https://wiki.php.net/rfc/attributes_v2](https://wiki.php.net/rfc/attributes_v2
    )'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.php.net/rfc/attributes_v2](https://wiki.php.net/rfc/attributes_v2
    )'
- en: 'Also, see this update:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅此更新：
- en: '[https://wiki.php.net/rfc/shorter_attribute_syntax_change](https://wiki.php.net/rfc/shorter_attribute_syntax_change
    )'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.php.net/rfc/shorter_attribute_syntax_change](https://wiki.php.net/rfc/shorter_attribute_syntax_change
    )'
- en: 'Information on PHP DocBlocks can be found here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PHP DocBlocks的信息可以在这里找到：
- en: '[https://phpdoc.org/](https://phpdoc.org/ )'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://phpdoc.org/](https://phpdoc.org/ )'
- en: 'For more information about Doctrine ORM, have a look here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Doctrine ORM的更多信息，请查看这里：
- en: '[https://www.doctrine-project.org/projects/orm.html](https://www.doctrine-project.org/projects/orm.html
    )'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.doctrine-project.org/projects/orm.html](https://www.doctrine-project.org/projects/orm.html
    )'
- en: 'Documentation on `php.ini` file settings can be found here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`php.ini`文件设置的文档可以在这里找到：
- en: '[https://www.php.net/manual/en/ini.list.php](https://www.php.net/manual/en/ini.list.php
    )'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.php.net/manual/en/ini.list.php](https://www.php.net/manual/en/ini.list.php)'
- en: 'Read about PHP Reflection here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里阅读有关PHP反射的信息：
- en: '[https://www.php.net/manual/en/language.attributes.reflection.php](https://www.php.net/manual/en/language.attributes.reflection.php
    )'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.php.net/manual/en/language.attributes.reflection.php](https://www.php.net/manual/en/language.attributes.reflection.php)'
- en: 'Information about the Rust programming language can be found in this book:
    [https://www.packtpub.com/product/mastering-rust-second-edition/9781789346572](https://www.packtpub.com/product/mastering-rust-second-edition/9781789346572)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Rust编程语言的信息可以在这本书中找到：[https://www.packtpub.com/product/mastering-rust-second-edition/9781789346572](https://www.packtpub.com/product/mastering-rust-second-edition/9781789346572)
- en: Incorporating match expressions into your program code
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将match表达式合并到程序代码中
- en: Among the many incredibly useful features introduced in PHP 8, **match expressions**
    definitely stand out. `Match` expressions are a more accurate shorthand syntax
    that can potentially replace the tired old `switch` statement that came directly
    from the C language. In this section, you will learn how to produce cleaner and
    more accurate program code by replacing `switch` statements with `match` expressions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中引入的许多非常有用的功能中，**match表达式**绝对脱颖而出。`Match`表达式是一种更准确的简写语法，可以潜在地取代直接来自C语言的老旧`switch`语句。在本节中，您将学习如何通过用`match`表达式替换`switch`语句来生成更清晰和更准确的程序代码。
- en: Match expression general syntax
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Match表达式的一般语法
- en: '`Match` expression syntax is much like that of an array, where the key is the
    item to match and the value is an expression. Here is the general syntax for `match`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Match`表达式语法非常类似于数组，其中键是要匹配的项，值是一个表达式。以下是`match`的一般语法：'
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The expression must be a valid PHP expression. Examples of expressions could
    include any of the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式必须是有效的PHP表达式。表达式的示例可以包括以下任何一种：
- en: A specific value (for example, `"some text"`)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个特定的值（例如，`"一些文本"`）
- en: An operation (for example, `$a + $b`)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个操作（例如，`$a + $b`）
- en: An anonymous function or class
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数或类
- en: 'The only limitation is that the expression has to be defined in a single line
    of code. Major differences between `match` and `switch` are summarized here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的限制是表达式必须在一行代码中定义。`match`和`switch`之间的主要区别在这里总结：
- en: '![Table 1.1 – Differences between match and switch'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![表1.1 - match和switch之间的区别'
- en: '](image/Table_1.1_B16992.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_1.1_B16992.jpg)'
- en: Table 1.1 – Differences between match and switch
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1 - match和switch之间的区别
- en: Other than the differences noted, `match` and `switch` both allow case aggregation,
    as well as providing support for a *default* case.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述区别之外，`match`和`switch`都允许案例聚合，并提供对*default*案例的支持。
- en: switch and match examples
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: switch和match示例
- en: 'Here is a simple example that renders a currency symbol using `switch`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，使用`switch`来渲染货币符号：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When this code is executed, you see the currency symbols for each of the **International
    Organization for Standardization** (**ISO**) currency codes in the `$test` array.
    The same result as that shown in the preceding code snippet can be obtained in
    PHP 8, using the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此代码时，您会看到`$test`数组中每个**国际标准化组织**（**ISO**）货币代码的货币符号。在PHP 8中可以获得与前面代码片段中显示的相同结果，使用以下代码：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Both examples produce an identical output, as illustrated here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 两个示例产生相同的输出，如下所示：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As mentioned previously, both code examples produce a list of currency symbols
    for the list of ISO currency codes stored in the `$test` array.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这两个代码示例都会为存储在`$test`数组中的ISO货币代码列表产生货币符号列表。
- en: Complex match example
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复杂的match示例
- en: 'Returning to our CAPTCHA project, assume that we wish to introduce distortion
    to make the CAPTCHA characters more difficult to read. To accomplish this goal,
    we introduce a number of **strategy** classes, each producing a different distortion,
    as summarized in this table:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的验证码项目，假设我们希望引入扭曲以使验证码字符更难阅读。为了实现这个目标，我们引入了许多**策略**类，每个类产生不同的扭曲，如下表所总结的：
- en: '![Table 1.2 – CAPTCHA distortion strategy classes'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![表1.2 - 验证码扭曲策略类'
- en: '](image/Table_1.2_B16992.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_1.2_B16992.jpg)'
- en: Table 1.2 – CAPTCHA distortion strategy classes
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.2 - 验证码扭曲策略类
- en: 'After randomizing the list of strategies to be employed, we use a `match` expression
    to execute the results, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在随机排列要使用的策略列表之后，我们使用`match`表达式来执行结果，如下所示：
- en: 'First we define an **autoloader**, import the classes to be used, and list
    potential strategies to employ, as illustrated in the following code snippet:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先我们定义一个**自动加载程序**，导入要使用的类，并列出要使用的潜在策略，如下所示：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we generate the CAPTCHA phrase, as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们生成验证码短语，如下所示：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We then loop through each character in the CAPTCHA phrase and create a `SingleChar`
    instance. The initial call to `writeFill()` creates the white background canvas.
    We also need to call `shuffle()` to randomize the list of distortion strategies.
    The process is illustrated in the following code snippet:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们循环遍历验证码短语中的每个字符，并创建一个`SingleChar`实例。对`writeFill()`的初始调用创建了白色背景画布。我们还需要调用`shuffle()`来随机排列扭曲策略的列表。该过程在以下代码片段中说明：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then loop through the strategies and layer distortions upon the original
    image. This is where the `match` expression comes into play. Notice that one strategy
    needs additional lines of code. Because `match` can only support a single expression,
    we simply wrap the multiple lines of code into an **anonymous function**, as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们循环遍历策略并在原始图像上叠加扭曲。这就是`match`表达式发挥作用的地方。请注意，一个策略需要额外的代码行。因为`match`只能支持单个表达式，所以我们简单地将多行代码包装到一个**匿名函数**中，如下所示：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'All that remains to be done is to overlay the image with the actual CAPTCHA
    phrase by calling `writeText()` with no arguments. After that, we save the distorted
    image as a **Portable Network Graphics** (**PNG**) file for display, as illustrated
    in the following code snippet:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在要做的就是通过不带参数调用`writeText()`来覆盖图像。之后，我们将扭曲的图像保存为**便携式网络图形**（**PNG**）文件以供显示，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is the result, running the preceding example from a browser that points
    to the Docker container associated with this book:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从指向本书关联的Docker容器的浏览器中运行前面示例的结果：
- en: '![Figure 1.1 – Distorted CAPTCHA using match expression'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1 - 使用匹配表达式扭曲的验证码'
- en: '](image/Figure_1.1_B16992.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.1_B16992.jpg)'
- en: Figure 1.1 – Distorted CAPTCHA using match expression
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 - 使用匹配表达式扭曲的验证码
- en: 'Next, we''ll have a look at another really great feature: named arguments.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下另一个非常棒的功能：命名参数。
- en: Tip
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can see the original proposal for `match` expressions here: [https://wiki.php.net/rfc/match_expression_v2](https://wiki.php.net/rfc/match_expression_v2
    )'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到`match`表达式的原始提案：[https://wiki.php.net/rfc/match_expression_v2](https://wiki.php.net/rfc/match_expression_v2)
- en: Understanding named arguments
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解命名参数
- en: '**Named arguments** represent a way to avoid confusion when calling functions
    or methods with a large number of arguments. This not only helps avoid problems
    with arguments being supplied in an incorrect order, but also helps you to skip
    arguments with defaults. In this section, you will learn how to apply named arguments
    to improve the accuracy of your code, reduce confusion during future maintenance
    cycles, and make your method and function calls more concise. We start by examining
    the generic syntax required to use named arguments.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名参数**代表一种避免在调用具有大量参数的函数或方法时产生混淆的方法。这不仅有助于避免参数以不正确的顺序提供的问题，还有助于您跳过具有默认值的参数。在本节中，您将学习如何应用命名参数来提高代码的准确性，减少未来维护周期中的混淆，并使您的方法和函数调用更加简洁。我们首先来看一下使用命名参数所需的通用语法。'
- en: Named argument generic syntax
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名参数通用语法
- en: 'In order to use named arguments, you need to know the names of the variables
    used in the function or method signature. You then specify that name, without
    the dollar sign, followed by a colon and the value to be supplied, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用命名参数，您需要知道函数或方法签名中使用的变量的名称。然后，您可以指定该名称，不带美元符号，后跟冒号和要提供的值，如下所示：
- en: '`$result = function_name( arg1 : <VALUE>, arg2 : <value>);`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`$result = function_name( arg1 : <VALUE>, arg2 : <value>);`'
- en: When the `function_name()` function is invoked, the values are passed to the
    arguments corresponding to `arg1`, `arg2`, and so on.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`function_name()`函数时，值将传递给与`arg1`、`arg2`等对应的参数。
- en: Calling core functions using named arguments
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命名参数调用核心函数
- en: 'One of the most common reasons to use named arguments is when you call a core
    PHP function that has a large number of parameters. As an example, here''s the
    function signature for `setcookie()`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名参数的最常见原因之一是调用具有大量参数的核心PHP函数。例如，这是`setcookie()`的函数签名：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s say that all you really wanted to set were the `name`, `value`, and
    `httponly` arguments. Before PHP 8, you would have had to look up the default
    values and supply them, in order, until you got to the one you wished to override.
    In the following case, we wish to set `httponly` to `TRUE`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您真正想要设置的只是`name`、`value`和`httponly`参数。在PHP 8之前，您需要查找默认值并按顺序提供它们，直到您到达要覆盖的值。在下面的情况下，我们希望将`httponly`设置为`TRUE`：
- en: '`setcookie(''test'',1,0,0,'''','''',FALSE,TRUE);`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`setcookie(''test'',1,0,0,'''','''',FALSE,TRUE);`'
- en: 'Using named arguments, the equivalent in PHP 8 would be as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名参数，在PHP 8中的等效方式如下：
- en: '`setcookie(''test'',1,httponly: TRUE);`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`setcookie(''test'',1,httponly: TRUE);`'
- en: Note that we do not need to name the first two parameters as they are supplied
    in order.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要为前两个参数命名，因为它们是按顺序提供的。
- en: Tip
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: In PHP extensions, named arguments do not always match the names of variables
    you see in the PHP documentation for function or method signatures. As an example,
    the function `imagettftext()` shows a variable `$font_filename` in its function
    signature. If you scroll down a bit further, however, you'll see in the *Parameters*
    section, that the named parameter is `fontfile`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP扩展中，命名参数并不总是与您在PHP文档中看到的函数或方法签名的变量名称匹配。例如，函数`imagettftext()`在其函数签名中显示一个变量`$font_filename`。然而，如果您再往下滚动一点，您会在*参数*部分看到，命名参数是`fontfile`。
- en: 'If you encounter a fatal Error: `Unknown named parameter $NAMED_PARAM`. Always
    use the name as listed in the *Parameters* section of the documentation rather
    than the name of the variable in the function or method signature.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到致命错误：`未知命名参数$NAMED_PARAM`。始终使用文档中*参数*部分列出的名称，而不是函数或方法签名中变量的名称。
- en: Order independence and documentation
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顺序独立和文档
- en: Another use for named arguments is to provide **order independence**. In addition,
    for certain core PHP functions, the sheer number of parameters presents a documentation
    nightmare.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数的另一个用途是提供**顺序独立**。此外，对于某些核心PHP函数来说，参数的数量之多构成了文档的噩梦。
- en: 'As an example, have a look here at the function signature for `imagefttext()`
    (note that this function is central to the chapter project of producing a secure
    CAPTCHA image):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看一下`imagefttext()`的函数签名（请注意，这个函数是生成安全验证码图像的章节项目的核心）：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can imagine, trying to remember the names and order of these parameters
    when reviewing your work 6 months later might be problematic.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以想象的那样，在6个月后回顾你的工作时，试图记住这些参数的名称和顺序可能会有问题。
- en: Important note
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In PHP 8, the image creation functions (for example, `imagecreate()`) now return
    a `GdImage` object instance instead of a resource. All image functions in the
    GD extension have been rewritten to accommodate this change. There's no need to
    rewrite your code!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，图像创建函数（例如`imagecreate()`）现在返回一个`GdImage`对象实例，而不是一个资源。GD扩展中的所有图像函数都已经重写以适应这一变化。没有必要重写您的代码！
- en: 'Accordingly, using named arguments, the following function call would be acceptable
    in PHP 8:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在PHP 8中，使用命名参数，以下函数调用将是可接受的：
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The code example just shown writes out a string of distorted characters as a
    set of PNG image files. Each character is rotated 10 degrees clockwise with respect
    to its neighboring images. Note how named arguments are applied to make arguments
    to the `imagettftext()` function easier to understand.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才显示的代码示例将一串扭曲字符写成一组PNG图像文件。每个字符相对于其相邻图像顺时针旋转10度。请注意，命名参数的应用使`imagettftext()`函数的参数更容易理解。
- en: Named arguments can also be applied to functions and methods of your own creation.
    In the next section, we cover new data types.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数也可以应用于您自己创建的函数和方法。在下一节中，我们将介绍新的数据类型。
- en: Tip
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'A detailed analysis of named arguments can be found here:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 关于命名参数的详细分析可以在这里找到：
- en: '[https://wiki.php.net/rfc/named_params](https://wiki.php.net/rfc/named_params
    )'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.php.net/rfc/named_params](https://wiki.php.net/rfc/named_params
    )'
- en: Exploring new data types
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索新的数据类型
- en: One thing any entry-level PHP developer learns is which **data types** PHP has
    available and how to use them. The basic data types include `int` (integer), `float`,
    `bool` (Boolean), and `string`. Complex data types include `array` and `object`.
    In addition, there are other data types such as `NULL` and `resource`. In this
    section, we discuss a few new data types introduced in PHP 8, including union
    types and mixed types.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 任何初级PHP开发人员学到的一件事是PHP有哪些可用的**数据类型**以及如何使用它们。基本数据类型包括`int`（整数）、`float`、`bool`（布尔值）和`string`。复杂数据类型包括`array`和`object`。此外，还有其他数据类型，如`NULL`和`resource`。在本节中，我们将讨论PHP
    8中引入的一些新数据类型，包括联合类型和混合类型。
- en: Important note
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: It's extremely important not to confuse a **data type** with a **data format**.
    This section describes data types. A data format, on the other hand, would be
    a way of *representing* data used as part of a transmission or for storage. Examples
    of a data format would include XML, **JavaScript Object Notation** (**JSON**),
    and **YAML Ain't Markup Language** (**YAML**).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的一点是不要混淆**数据类型**和**数据格式**。本节描述了数据类型。另一方面，数据格式将是用作传输或存储的数据的*表示*方式。数据格式的示例包括XML，**JavaScript对象表示**（**JSON**）和**YAML不是标记语言**（**YAML**）。
- en: Union types
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合类型
- en: Unlike other data types such as `int` or `string`, it's important to note that
    there is no data type explicitly called *union*. Rather, when you see a reference
    to **union types**, what is meant is that PHP 8 introduces a new syntax that allows
    you to specify a union of types, instead of just one. Let's now have a look at
    the generic syntax for union types.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与`int`或`string`等其他数据类型不同，重要的是要注意，没有一个名为*union*的数据类型。相反，当你看到**联合类型**的引用时，意思是PHP
    8引入了一种新的语法，允许您指定多种类型，而不仅仅是一种。现在让我们来看一下联合类型的通用语法。
- en: Union type syntax
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 联合类型语法
- en: 'The generic syntax for union types is as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型的通用语法如下：
- en: '`function ( type|type|type $var) {}`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`function ( type|type|type $var) {}`'
- en: 'In place of `type`, you would supply any of the existing data types (for example,
    `float` or `string`). There are a few restrictions, however, which for the most
    part make complete sense. This table summarizes the more important restrictions:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在`type`的位置，您可以提供任何现有的数据类型（例如`float`或`string`）。然而，有一些限制，大部分都是完全有道理的。这张表总结了更重要的限制：
- en: '![Table 1.3 – Disallowed union types'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![表1.3 - 不允许的联合类型'
- en: '](image/Table_1.3_B16992.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_1.3_B16992.jpg)'
- en: Table 1.3 – Disallowed union types
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.3 - 不允许的联合类型
- en: As you can see from this list of exceptions, defining a union type is primarily
    a matter of common sense.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例外列表中可以看出，定义联合类型主要是常识问题。
- en: Tip
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**: When using union types, **type coercion** (the process whereby
    PHP converts a data type internally to satisfy the requirements of the function)
    can be an issue if strict type checking is not enforced. Accordingly, it''s a
    best practice to add the following at the top of any file where union types are
    used: `declare(strict_types=1);`.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：在使用联合类型时，如果不强制执行严格类型检查，**类型强制转换**（PHP内部转换数据类型以满足函数要求的过程）可能会成为一个问题。因此，最佳实践是在使用联合类型的任何文件顶部添加以下内容：`declare(strict_types=1);`。'
- en: 'For more information, see the documentation reference here:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅此处的文档参考：
- en: '[https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.strict](https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.strict
    )'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.strict](https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.strict
    )'
- en: Union type example
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 联合类型示例
- en: For a simple illustration, let's return to the `SingleChar` class used as an
    example in this chapter. One of the methods is `colorAlloc()`. This method allocates
    a color from an image, leveraging the `imagecolorallocate()` function. It accepts
    as arguments integer values that represent red, green, and blue.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单说明，让我们回到本章中使用的`SingleChar`类作为示例。其中的一个方法是`colorAlloc()`。该方法从图像中分配颜色，利用了`imagecolorallocate()`函数。它接受表示红色、绿色和蓝色的整数值作为参数。
- en: For the sake of argument, let's say that the first argument could actually be
    an array representing three values—one each for red, green, and blue. In this
    case, the argument type for the first value cannot be `int` otherwise, if an array
    were provided, an error would be thrown if strict type checking were to be turned
    on.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了论证，假设第一个参数实际上可以是表示三个值的数组——分别是红色、绿色和蓝色。在这种情况下，第一个值的参数类型不能是`int`，否则，如果提供了一个数组，并且打开了严格类型检查，将会抛出错误。
- en: 'In earlier versions of PHP, the only solution would be to remove any type check
    from the first argument and to indicate that multiple types are accepted in the
    associated DocBlock. Here''s how the method might appear in PHP 7:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP的早期版本中，唯一的解决方案是从第一个参数中删除任何类型检查，并指示在相关的DocBlock中接受多种类型。以下是在PHP 7中该方法可能的样子：
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The only indication of the data type for the first parameter, `$r`, is the
    `@param array|int $r` DocBlock annotation and the fact that there is no data type
    hint associated with that argument. In PHP 8, taking advantage of union types,
    notice the difference here:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`$r`的数据类型唯一的指示是`@param array|int $r`的DocBlock注释和没有与该参数关联的数据类型提示。在PHP 8中，利用联合类型，注意这里的区别：
- en: '[PRE34]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding example, in addition to the presence of `attribute` that indicates
    the first argument can accept either an `array` or an `int` type, in the method
    signature itself, the `int|array` union type makes this choice clear.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，除了`attribute`的存在表明第一个参数可以接受`array`或`int`类型之外，在方法签名本身中，`int|array`联合类型清楚地说明了这个选择。
- en: mixed type
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合类型
- en: '`mixed` is another new type introduced in PHP 8\. Unlike a union type, `mixed`
    is an actual data type that represents the ultimate union of types. It''s used
    to indicate that any and all data types are accepted. In a certain sense, PHP
    already has this facility: simply omit the data type altogether, and it''s an
    implied `mixed` type!'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`mixed`是PHP 8中引入的另一种新类型。与联合类型不同，`mixed`是一个实际的数据类型，代表了所有类型的最终联合。它用于表示接受任何和所有数据类型。在某种意义上，PHP已经具有了这个功能：简单地省略数据类型，它就是一个隐含的`mixed`类型！'
- en: Tip
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You will see references to a `mixed` type in the PHP documentation. PHP 8 formalizes
    this representation by making it an actual data type.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在PHP文档中看到对`mixed`类型的引用。PHP 8通过将其作为实际数据类型来正式表示这种表示。
- en: Why use a mixed type?
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么使用混合类型？
- en: 'Hold for a second—you might be thinking at this point: why bother using a `mixed`
    type at all? To put your mind at ease, this is an excellent question, and there
    is no compelling reason to use this type.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下——你可能会想到：为什么要使用`mixed`类型呢？放心，这是一个很好的问题，没有强制使用这种类型的理由。
- en: However, by using `mixed` in a function or method signature, you clearly *signal
    your intention* for the use of this parameter. If you were to simply leave the
    data type blank, other developers later using or reviewing your code might think
    that you forgot to add the type. At the very least, they will be uncertain of
    the nature of the untyped argument.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过在函数或方法签名中使用`mixed`，您清楚地*表明了您对该参数的使用意图。如果您只是留空数据类型，其他开发人员在以后使用或审查您的代码时可能会认为您忘记添加类型。至少，他们会对未命名参数的性质感到不确定。
- en: The effect of a mixed type on inheritance
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合类型对继承的影响
- en: 'As a `mixed` type represents the ultimate example of **widening**, it can be
    used to *widen* the data type definition when one class extends from another.
    Here is an example using a `mixed` type, illustrating this principle:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`mixed`类型代表**扩宽**的最终示例，它可以用于在一个类继承另一个类时*扩宽*数据类型定义。以下是使用`mixed`类型的示例，说明了这个原则：
- en: 'First, we define the parent class with the more restrictive data type of `object`,
    as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们用更严格的数据类型`object`定义父类，如下所示：
- en: '[PRE35]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we define a `Low` class that extends `High`, as follows:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`Low`类，它继承自`High`，如下所示：
- en: '[PRE36]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note in the `Low` class that the data type for the `logVar()`method has been
    *widened* into `mixed`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`Low`类中，`logVar()`方法的数据类型已经*扩宽*为`mixed`。
- en: 'Finally, we create an instance of `Low` and execute it with test data. As you
    can see from the results shown in the following code snippet, everything works
    fine:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个`Low`的实例，并用测试数据执行它。从下面的代码片段中显示的结果可以看出，一切都运行正常：
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here is the output from the preceding example:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面示例的输出：
- en: '[PRE38]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code block logs a variety of different data types and then displays
    the contents of the log file. In the process, this shows us there are no inheritance
    issues in PHP 8 when a child class overrides a parent class method and substitutes
    a data type of `mixed` in place of a more restrictive data type, such as `object`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块记录了各种不同的数据类型，然后显示了日志文件的内容。在这个过程中，这向我们展示了在PHP 8中，当子类覆盖父类方法并用`mixed`代替更严格的数据类型，如`object`时，不存在继承问题。
- en: Next, we have a look at using typed properties.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下如何使用有类型的属性。
- en: Tip
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**: Assign specific data types to all arguments when defining
    functions or methods. If a few different data types are acceptable, define a union
    type. Otherwise, if none of this applies, fall back to a `mixed` type.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：在定义函数或方法时，为所有参数分配特定的数据类型。如果接受几种不同的数据类型，定义一个联合类型。否则，如果没有适用上述情况，退而使用`mixed`类型。'
- en: 'For information on union types, see this documentation page:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 关于联合类型的信息，请参阅此文档页面：
- en: '[https://wiki.php.net/rfc/union_types_v2](https://wiki.php.net/rfc/union_types_v2
    )'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.php.net/rfc/union_types_v2](https://wiki.php.net/rfc/union_types_v2
    )'
- en: 'For more information on a `mixed` type, have a look here: [https://wiki.php.net/rfc/mixed_type_v2.](https://wiki.php.net/rfc/mixed_type_v2
    )'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`mixed`类型的更多信息，请查看这里：[https://wiki.php.net/rfc/mixed_type_v2.](https://wiki.php.net/rfc/mixed_type_v2
    )
- en: Improving code using typed properties
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进使用有类型属性的代码
- en: In the first section of this chapter, *Using constructor property promotion*,
    we discussed how data types can be used to control the type of data supplied as
    arguments to functions or class methods. What this approach fails to do, however,
    is guarantee that the data type never changes. In this section, you will learn
    how assigning a data type at the property level provides stricter control over
    the use of variables in PHP 8.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，*使用构造函数属性提升*，我们讨论了如何使用数据类型来控制提供给函数或类方法的参数的数据类型。然而，这种方法未能保证数据类型永远不会改变。在本节中，您将学习如何在属性级别分配数据类型，从而更严格地控制PHP
    8中变量的使用。
- en: What are typed properties?
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有类型属性是什么？
- en: 'This extremely important feature was introduced in PHP 7.4 and continues in
    PHP 8\. Simply put, a **typed property** is a class property with a data type
    preassigned. Here is a simple example:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常重要的特性是在PHP 7.4中引入的，并在PHP 8中继续。简而言之，**有类型属性**是一个预先分配数据类型的类属性。以下是一个简单的例子：
- en: '[PRE39]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this example, if we attempt to assign a value representing a data type other
    than `int` to `$test->id`, a `Fatal error` is thrown. Here is the output:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果我们尝试将代表`int`以外的数据类型的值分配给`$test->id`，将会抛出`Fatal error`。以下是输出：
- en: '[PRE40]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see from the preceding output, a `Fatal error` is thrown when the
    wrong data type is assigned to a typed property.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从上面的输出中所见，当错误的数据类型分配给类型化属性时，将会抛出`Fatal error`。
- en: 'You have already been exposed to one form of property typing: **constructor
    property promotion**. All properties defined using constructor property promotion
    are automatically property typed!'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经接触过一种属性类型化的形式：**构造函数属性提升**。使用构造函数属性提升定义的所有属性都会自动进行属性类型化！
- en: Why is property typing important?
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么属性类型化很重要？
- en: Typed properties is part of a general trend in PHP first seen in PHP 7\. The
    trend is toward making language refinements that restrict and tighten the use
    of your code. This leads to better code, which means fewer bugs.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 类型化属性是PHP中首次出现的一般趋势的一部分，该趋势是朝着限制和加强代码使用的语言细化发展。这导致更好的代码，意味着更少的错误。
- en: 'The following example illustrates the danger of relying solely upon property-type
    hinting to control the data type of properties:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了仅依赖属性类型提示来控制属性数据类型的危险：
- en: '[PRE41]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding example, notice in the `__construct()` method that the `$token`
    property is accidentally converted to a string. Here is the output:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，注意在`__construct()`方法中，`$token`属性被意外转换为字符串。以下是输出：
- en: '[PRE42]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Any subsequent code expecting `$token` to be an integer might either fail or
    produce unexpected results. Now, have a look at the same thing in PHP 8 using
    typed properties:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 任何后续的代码如果期望`$token`是一个整数，可能会失败或产生意外的结果。现在，让我们看一下在PHP 8中使用类型化属性的相同情况：
- en: '[PRE43]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Property typing prevents any change to the preassigned data type from occurring,
    as you can see from the output shown here:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 属性类型化可以防止预分配的数据类型发生任何更改，如您在此处所见的输出所示：
- en: '[PRE44]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see from the preceding output, a `Fatal error` is thrown when the
    wrong data type is assigned to a typed property. This example demonstrates that
    not only does assigning a data type to a property prevent misuse when making direct
    assignments, but it also prevents misuse of the property inside class methods
    as well!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从上面的输出中所见，当错误的数据类型分配给类型化属性时，将会抛出`Fatal error`。这个例子表明，不仅将数据类型分配给属性可以防止在进行直接赋值时的误用，而且还可以防止在类方法中误用属性！
- en: Property typing can lead to a reduction in code
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性类型化可以导致代码量的减少
- en: Another beneficial side effect of introducing property typing to your code is
    a potential reduction in the amount of code needed. As an example, consider the
    current practice of marking properties with a visibility of `private` or `protected`,
    and then creating a series of `get` and `set` methods to control access (also
    called *getters* and *setters*).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 引入属性类型化到您的代码中的另一个有益的副作用是可能减少所需的代码量。例如，考虑当前的做法，即将属性标记为`private`或`protected`的可见性，然后创建一系列用于控制访问的`get`和`set`方法（也称为*getters*和*setters*）。
- en: 'Here is how that might appear:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能如下所示：
- en: 'First, we define a `Test` class with protected properties, as follows:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个带有受保护属性的`Test`类，如下所示：
- en: '[PRE45]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we define a series of `get` and `set` methods to control access to the
    protected properties, as follows:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一系列用于控制对受保护属性的访问的`get`和`set`方法，如下所示：
- en: '[PRE46]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We then use the `set` methods to assign values, as follows:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`set`方法来分配值，如下所示：
- en: '[PRE47]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we display the results in a table, using the `get` methods to retrieve
    property values, as follows:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`get`方法以表格形式显示结果，如下所示：
- en: '[PRE48]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here is how that might appear:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能如下所示：
- en: '![Table 1.4 – Output using Get methods'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![表1.4 - 使用Get方法输出'
- en: '](image/Figure_1.2_B16992.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.2_B16992.jpg)'
- en: Table 1.4 – Output using Get methods
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.4 - 使用Get方法输出
- en: The main purpose achieved by marking properties as `protected` (or `private`)
    and by defining *getters* and *setters* is to control access. Often, this translates
    into a desire to prevent the property data type from changing. If this is the
    case, the entire infrastructure can be replaced by assigning property types.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将属性标记为`protected`（或`private`）并定义*getters*和*setters*来实现的主要目的是控制访问。通常，这意味着希望阻止属性数据类型的更改。如果是这种情况，整个基础设施可以通过分配属性类型来替换。
- en: 'Simply changing the visibility to `public` alleviates the need for `get` and
    `set` methods; however, it does not prevent the property data from being changed!
    Using PHP 8 property types achieves both goals: it eliminates the need for `get`
    and `set` methods and also prevents the data type from being accidentally changed.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 将可见性简单地更改为`public`可以减轻对`get`和`set`方法的需求；但是，它并不能防止属性数据被更改！使用PHP 8属性类型既实现了这两个目标：它消除了`get`和`set`方法的需求，也防止了数据类型被意外更改。
- en: 'Notice here how much less code is needed to achieve the same results in PHP
    8 using property typing:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在PHP 8中使用属性类型化实现相同结果所需的代码量大大减少了：
- en: '[PRE49]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding code example shown produces exactly the same output as the previous
    example and also achieves even better control over property data types. Using
    typed properties, in this example, we achieved a *50% reduction* in the amount
    of code needed to produce the same result!
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 上面显示的代码示例产生了与前一个示例完全相同的输出，并且还实现了对属性数据类型的更好控制。在这个例子中，使用类型化属性，我们实现了*50%的代码减少*来产生相同的结果！
- en: Tip
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**: Use typed properties whenever possible, except in situations
    where you explicitly want to allow the data type to change.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：尽可能在可能的情况下使用类型化属性，除非您明确希望允许数据类型更改。'
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned how to write better code using the new PHP 8 data
    types: mixed and union types. You also learned about how using named arguments
    can not only improve the readability of your code but can also help prevent accidental
    misuse of class methods and PHP functions, as well as providing a great way to
    skip over default arguments.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用新的PHP 8数据类型：混合类型和联合类型来编写更好的代码。您还了解到使用命名参数不仅可以提高代码的可读性，还可以帮助防止意外误用类方法和PHP函数，同时提供了一个很好的方法来跳过默认参数。
- en: This chapter also taught you how the new `Attribute` class can be used as an
    eventual replacement for PHP DocBlocks, serving to improve the overall performance
    of your code while providing a solid means of documenting classes, methods, and
    functions.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还教会了您如何使用新的`Attribute`类作为PHP DocBlocks的潜在替代品，以改善代码的整体性能，同时提供了一种可靠的方式来记录类、方法和函数。
- en: In addition, we looked at how PHP 8 can greatly reduce the amount of code needed
    by earlier PHP versions by taking advantage of constructor argument promotion
    and typed properties.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还看到PHP 8如何通过利用构造函数参数提升和类型化属性大大减少了早期PHP版本所需的代码量。
- en: In the next chapter, you will learn about new PHP 8 features at the functional
    and procedural level.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习有关功能和过程级别的新PHP 8功能。
