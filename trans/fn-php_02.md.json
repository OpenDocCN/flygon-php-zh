["```php\n<?php \n\nfunction add(int $a, int $b): int \n{ \n    return $a + $b; \n} \n```", "```php\n<?php \n\nfunction nextMessage(): string \n{ \n    return array_pop($_SESSION['message']); \n} \n\n// A simple score updating method for a game \nfunction updateScore(Player $player, int $points) \n{ \n    $score = $player->getScore(); \n    $player->setScore($score + $points); \n} \n```", "```php\n<?php \n\nfunction getCurrentTvProgram(Channel $channel ): string \n\n{ \n    // let's assume that getProgramAt is a pure method. return $channel->getProgramAt(time()); \n} \n```", "```php\n<?php \n\nfunctiongetTvProgram(Channel $channel, int $when): string \n{ \n    return $channel->getProgramAt($when); \n} \n```", "```php\n<?php \n\n$counter = 0; \n\nfunction increment() \n{ \n    global $counter; \n    return ++$counter; \n} \n\nfunction increment2() \n{ \n    static $counter = 0;\n    return ++$counter; \n} \n\nfunction get_administrators(EntityManager $em) \n{ \n    // Let's assume $em is a Doctrine EntityManager allowing \n    // to perform DB queries \n    return $em->createQueryBuilder() \n              ->select('u') \n              ->from('User', 'u') \n              ->where('u.admin = 1') \n              ->getQuery()->getArrayResult(); \n} \n\nfunction get_roles(User $u) \n{ \n    return array_merge($u->getRoles(), $u->getGroup()->getRoles()); \n} \n```", "```php\n<?php \n\n$counter = 0; \n\nfunction increment() \n{ \n    global $counter; \n    return ++$counter; \n} \n\nfunction increment2() \n{ \n    static $counter = 0; \n    return ++$counter; \n} \n```", "```php\n<?php \n\nfunction set_administrator(EntityManager $em, User $u) \n{ \n    $em->createQueryBuilder() \n       ->update('models\\User', 'u') \n       ->set('u.admin', 1) \n       ->where('u.id = ?1') \n       ->setParameter(1, $u->id) \n       ->getQuery()->execute(); \n} \n\nfunction log_message($message) \n{ \n    echo $message.\"\\n\"; \n} \n\nfunction updatePlayers(Player $winner, Player $loser, int $score) \n{ \n    $winner->updateScore($score); \n    $loser->updateScore(-$score); \n} \n```", "```php\n<?php \nclass Test \n{ \n    private $value; \n    public function __construct($v) \n    { \n        $this->set($v); \n    } \n\n    public function set($v) { \n        $this->value = $v; \n    } \n} \n\nfunction compare($a, $b) \n{ \n    echo ($a == $b ? 'identical' : 'different').\"\\n\"; \n} \n\n$a = new Test(2); \n$b = new Test(2); \n\ncompare($a, $b); \n// identical \n\n$b->set(10); \ncompare($a, $b); \n// different \n\n$c = clone $a; \n$c->set(5); \ncompare($a, $c); \n```", "```php\n<?php \n\n//let's assume we have some big array of data \n$array= ['one', 'two', 'three', '...']; \n\n$filtered = array_filter($array, function($i) { /* [...] */ }); \n$beginning = array_slice($array, 0, 10); \n$final = array_map(function($i) { /* [...] */ }, $array); \n```", "```php\n<?php \n\ndefine('FOO', 'something'); \nconst BAR=42; \n\n//this only works since PHP 5.6 \nconst BAZ = ['one', 'two', 'three']; \n\n// the 'define' syntax for array work since PHP 7 \ndefine('BAZ7', ['one', 'two', 'three']); \n\n// names starting and ending with underscores are discouraged \ndefine('__FOO__', 'possible clash'); \n```", "```php\n<?php \n\ndefine('UPPERCASE', strtoupper('Hello World !')); \n```", "```php\n<?php \n\necho UPPERCASE; \n//display 'HELLO WORLD !' echo I_DONT_EXISTS; \n//PHPNotice:  Use of undefined constant \n\nI_DONT_EXISTS\n//- assumed'I_DONT_EXISTS' \n//display 'I_DONT_EXISTS'anyway \n```", "```php\n<?php \n\necho constant('UPPERCASE'); \n// display 'HELLO WORLD !' echo defined('UPPERCASE') ? 'true' : 'false'; \n// display 'true' \n\necho constant('I_DONT_EXISTS'); \n// PHP Warning:  constant(): Couldn't find constant I_DONT_EXISTS \n// display nothings as 'constant' returns 'null' in this case \n\necho defined('I_DONT_EXISTS') ? 'true' : 'false'; \n// display 'false' \n```", "```php\n<?php \n\nclass A \n{ \n    const FOO='some value'; \n\n    public static function bar() \n    { \n        echo self::FOO; \n    } \n} \n\necho A::FOO; \n// display 'some value' \n\necho constant('A::FOO'); \n// display 'some value' \n\necho defined('A::FOO') ? 'true' : 'false'; \n// display 'true' \n\nA::bar(); \n// display 'some value' \n```", "```php\n<?php \n\nclass A \n{ \n    const FOO=uppercase('Hello World !'); \n} \n\n// This will generate an error when parsing the file : \n// PHP Fatal error:  Constant expression contains invalid operations \n```", "```php\n<?php \n\nconst FOO=6; \n\nclass B \n{ \n    const BAR=FOO*7; \n    const BAZ=\"The answer is \": self::BAR; \n} \n```", "```php\n<?php \n\nconst FOO='foo'; \n$bar='bar'; \n\nfunction test() \n{ \n    // here FOO is accessible \n    echo FOO; \n\n    // however, if you want to access $bar, you have to use \n    // the 'global' keyword. global $bar; \n    echo $bar; \n}\n```", "```php\n<?php \n\nclass A \n{ \n    public const FOO='public const'; \n    protected const BAR='protected const'; \n    private const BAZ='private const'; \n} \n\n// public constants are accessible as always \necho A::FOO; \n\n// this will however generate an error \necho A::BAZ; \n// PHP Fatal error: Uncaught Error: Cannot access private const A::BAR \n```", "```php\n<?php \n\nclass Message \n{ \n    private $message; \n    private $status; \n\n    public function __construct(string $message, string $status) \n    { \n        $this->status = $status; \n        $this->message = $message; \n    } \n\n    public function getMessage() \n    { \n        return $this->message; \n    } \n\n    public function getStatus() \n    { \n        return $this->status; \n    } \n\n    public function equals($m) \n    { \n        return $m->status === $this->status && \n               $m->message === $this->message; \n    } \n\n    public function withStatus($status): Message \n    { \n        $new = clone $this; \n        $new->status = $status; \n        return $new; \n    } \n} \n```", "```php\n<?php \n\n// The Player implementation is voluntarily simple for brevity. // Obviously you would use immutable.php in a real project. class Player \n{ \n    public $hp; \n    public $x; \n    public $y; \n\n    public function __construct(int $x, int $y, int $hp) { \n        $this->x = $x; \n        $this->y = $y; \n        $this->hp = $hp; \n    } \n} \n\nfunction isCloseEnough(Player $one, Player $two): boolean \n{ \n    return abs($one->x - $two->x) < 2 && \n           abs($one->y - $two->y) < 2; \n} \n\nfunction loseHitpoint(Player $p): Player \n{ \n    return new Player($p->x, $p->y, $p->hp - 1); \n} \n\nfunction hit(Player $p, Player $target): Player \n{ \n    return isCloseEnough($p, $target) ? loseHitpoint($target) : \n        $target; \n} \n```", "```php\n<?php \n\n$john=newPlayer(8, 8, 10); \n$ted =newPlayer(7, 9, 10); \n\n$ted=hit($john, $ted); \n```", "```php\n<?php \n\nreturn abs($p->x - $target->x) < 2 && abs($p->y - $target->y) < 2 ? loseHitpoint($target) : \n    $target; \n```", "```php\n<?php \n\nreturn abs(8 - 7) < 2 && abs(8 - 8) < 2 ? loseHitpoint($target) : \n    $target; \n```", "```php\n<?php \n\nreturn 1<2 && 0<2 ? loseHitpoint($target) : \n    $target; \n```", "```php\n<?php \n\nreturn loseHitpoint($target); \n```", "```php\n<?php \n\nreturn newPlayer($target->x, $target->y, $target->hp-1); \n```", "```php\n<?php \n\nreturn newPlayer(8, 7, 10-1); \n```", "```php\n<?php \n\n$ted = newPlayer(8, 7, 9); \n```", "```php\n<?php \n\nfunction wait(int $value): int \n{ \n    // let's imagine this is a function taking a while \n    // to compute a value \n    sleep(10); \n    return $value; \n} \n\nfunction do_something(bool $a, int $b, int $c): int \n{ \n    if($a) { \n        return $b; \n    } else { \n        return $c; \n    } \n} \n\ndo_something(true, sleep(10), sleep(8)); \n```", "```php\n<?php \n\n// 'wait' will never get called as those operators are short- circuited \n\n$a= (false && sleep(10));   \n$b = (true  || sleep(10)); \n$c = (false and sleep(10)); \n$d = (true  or  sleep(10)); \n```", "```php\n<?php \n\n($a && sleep(10)) || sleep(8); \n```", "```php\n<?php \n\n// let's imagine $blogs is a lazily evaluated collection \n// containing all the blog posts of your application order by date \n$posts = [ /* ... */ ]; \n\n// last 10 posts for the homepage \nreturn $posts->reverse()->take(10); \n\n// posts with tag 'functional php' \nreturn $posts->filter(function($b) { \n    return $b->tags->contains('functional-php'); \n})->all(); \n\n// title of the first post from 2014 in the category 'life' \nreturn $posts->filter(function($b) { \n    return $b->year == 2014; \n})->filter(function($b) { \n    return $b->category == 'life'; \n})->pluck('title')->first(); \n```", "```php\n<?php \n\nfunction integers() \n{ \n    $i=0; \n    while(true) yield $i++; \n} \n```", "```php\n<?php \n\n$array= [1, 2, 3, 4, 5, 6 /* ... */]; \n\n// version 1 \nfor($i = 0; $i < count($array); ++$i) { \n    // do something with the array values \n} \n\n// version 2 \n$length = count($array); \nfor($i = 0; $i < $length; ++$i) { \n    // do something with the array values \n} \n```", "```php\n<?php \n\n$a= $foo * $bar + $u; \n$b = $foo * $bar * $v; \n```", "```php\n<?php \n\n$tmp= $foo * $bar; \n$a = $tmp + $u; \n$b = $tmp * $v; \n```"]