- en: Chapter 10. Building, Compiling, and Testing with Elixir
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。使用Elixir构建、编译和测试
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Installing Node.js, Gulp, and Elixir
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Node.js，Gulp和Elixir
- en: Running Elixir
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Elixir
- en: Combining CSS and JavaScript files using Elixir
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Elixir合并CSS和JavaScript文件
- en: Setting up notifications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置通知
- en: Running tests with Elixir
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Elixir运行测试
- en: Extending Elixir
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展Elixir
- en: Automating Laravel
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化Laravel
- en: Throughout the book, many parts of an example application have been built. We
    discussed the steps involved in creating an application. However, there is more
    information available about tools to help with scaffolding, boilerplate templates,
    and building up a RESTful API for a CRUD application. Until recently, not much
    was written about automating some parts of the development process and deployment
    process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，已经构建了示例应用程序的许多部分。我们讨论了创建应用程序涉及的步骤。然而，关于帮助搭建、样板模板和为CRUD应用程序构建RESTful API的工具还有更多信息可用。直到最近，关于自动化开发过程和部署过程的一些部分并没有太多的资料。
- en: A newer area that has emerged in the last few years in the PHP field is the
    concept of continuous integration and build tools. The popularity of continuous
    integration and continuous delivery enables teams of developers to constantly
    release many small improvements to their application many times a day. In this
    chapter, you will learn how Laravel has a new toolset to empower teams to rapidly
    and effortlessly deploy versions of their software and build, and combine many
    of the software's components automatically.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP领域，近年来出现了一个新的领域，即持续集成和构建工具的概念。持续集成和持续交付的流行使开发团队能够不断发布许多小的改进，每天多次发布他们的应用程序。在本章中，您将了解到Laravel具有一套新的工具集，可以使团队快速轻松地部署他们的软件版本，并自动构建和组合软件的许多组件。
- en: Continuous integration and continuous delivery has caused quite an evolution
    in the development process, which has drastically changed the way in which software
    is built. It was not too long ago, however, when the standard deployment process
    involved simply placing the code on the server. A majority of the early adopters
    of PHP were simply web designers with a need to add functionality such as a *forum*
    or *contact us* form. Since most of them were not programmers, most of the practices
    used in web design and graphic design in general made their way into PHP deployment
    as well. These practices often involved using an application such as FileZilla
    to drag-and-drop files from the left-hand side panel (the user's computer) to
    the right (the server's directories). For the more experienced, performing what
    was then cryptic UNIX commands using a terminal emulator such as PuTTY.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成和持续交付在开发过程中引起了相当大的变革，大大改变了软件构建的方式。然而，不久之前，标准的部署过程只涉及将代码放在服务器上。大多数早期采用PHP的人只是需要添加功能，比如*论坛*或*联系我们*表单的网页设计师。由于他们大多不是程序员，因此网页设计和图形设计中使用的大多数实践也被用于PHP部署。这些实践通常涉及使用诸如FileZilla之类的应用程序，将文件从左侧面板（用户的计算机）拖放到右侧（服务器的目录）。对于更有经验的人来说，使用终端仿真器（如PuTTY）执行当时晦涩的UNIX命令。
- en: The insecure file transfer port 21 was used, and everything was sent uncompressed
    and simply copied to the server. Usually, all of the files were overwritten and
    often the deployment took almost an hour for a large site with many images and
    files.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不安全的文件传输端口21，并且所有内容都未经压缩，只是简单地复制到服务器上。通常，所有文件都会被覆盖，而且部署大型网站的过程通常需要将近一个小时，因为有很多图片和文件。
- en: Eventually, source code control systems became pervasive. In the most recent
    years, SVN and Git have become the industry standard for most software projects.
    These tools allowed for deployment directly from a code repository.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，源代码控制系统变得普遍。在最近几年，SVN和Git已成为大多数软件项目的行业标准。这些工具允许直接从代码仓库部署。
- en: Most recently, the arrival of composer has created an easy way to simply include
    entire software packages to add functionality to software applications. The ease
    with which a developer simply needs to add a single line to the configuration
    file is exhilarating!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，composer的到来为简单地将整个软件包包含到软件应用程序中添加功能创造了一种简单的方式。开发人员只需向配置文件添加一行代码即可轻松实现！
- en: Automating both the development and deployment processes may involve many steps,
    some of which are listed next.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化开发和部署过程可能涉及许多步骤，以下是其中一些。
- en: Deployment
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署
- en: 'Here are some of the functions of the deployment process:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是部署过程的一些功能：
- en: Copying certain configuration settings that are relevant to the production environment
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制与生产环境相关的某些配置设置
- en: Processing or compiling any **cascading style sheets** (**CSS**) or JavaScript
    files that were written using a shortcut syntax or preprocessor
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理或编译使用快捷语法或预处理器编写的任何**层叠样式表**（**CSS**）或JavaScript文件
- en: Copying the various assets (source code or images) to mirrors, cluster servers,
    or content delivery networks
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将各种资产（源代码或图像）复制到镜像、集群服务器或内容交付网络中
- en: Modifying the read/write/execute permissions and/or ownership of certain files
    or directories
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改某些文件或目录的读/写/执行权限和/或所有权
- en: Combining several files into one to reduce the overhead required to perform
    multiple HTTP calls
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个文件合并为一个文件，以减少执行多个HTTP调用所需的开销
- en: Reducing useless white space and comments (minifying and/or uglifying) in files
    to reduce their size
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少文件中的无用空格和注释（缩小和/或混淆）以减小文件大小
- en: Comparing existing files on the server with the files from our local environment
    to determine whether or not to overwrite them
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将服务器上的现有文件与本地环境中的文件进行比较，以确定是否覆盖它们
- en: Tagging and/or versioning the source code to allow for possible code rollbacks
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对源代码进行标记和/或版本控制，以便可能进行代码回滚
- en: Development or deployment
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发或部署
- en: 'Here are some of the functions of the development or deployment process:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是开发或部署过程的一些功能：
- en: Verifying that code passed all of the unit, functional, and acceptance tests
    written to guarantee its quality
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证代码是否通过了编写的所有单元、功能和验收测试，以确保其质量
- en: Running scripts that perform various operations
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行执行各种操作的脚本
- en: Performing any migrations, seeding, or other modifications to the database tables
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行任何迁移、种子播种或对数据库表的其他修改
- en: Obtaining source code control from a hosted source code control system such
    as GitHub
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从托管的源代码控制系统（如GitHub）获取源代码控制
- en: It is clear that modern development is very complex. An even more difficult
    aspect of software development is continually recreating the production or final
    environment while developing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，现代开发非常复杂。软件开发的更加困难的方面是在开发过程中不断重新创建生产或最终环境。
- en: Towards automation
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 朝着自动化的方向
- en: Tools such as file watchers can run scripts or perform operations every time
    a file is modified. Additionally, IDEs such as PHPStorm will recognize file extensions
    and offer to watch the file for changes and allow the developer to perform certain
    operations. While this approach is acceptable, it is not very portable and each
    developer would have to create and share a configuration file with the various
    watchers within the IDE or text editor. This creates a dependency, relying on
    one single IDE for the entire team.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如文件监视器之类的工具可以在每次文件被修改时运行脚本或执行操作。此外，诸如PHPStorm之类的IDE将识别文件扩展名，并提供监视文件更改并允许开发人员执行某些操作的选项。虽然这种方法是可以接受的，但它并不是非常便携，每个开发人员都必须创建和共享一个包含IDE或文本编辑器中各种监视器的配置文件。这会产生依赖性，依赖于整个团队的一个单一IDE。
- en: Also, other approaches such as Bash-shell scripts could be created that run
    at certain intervals. However, using these scripts requires UNIX-shell coding
    knowledge. As has been previously demonstrated, tools like artisan help automate
    many manual tasks. However, most of the default artisan commands were and are
    still designed to be executed manually.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以创建其他方法，例如Bash-shell脚本，以在特定时间间隔运行。但是，使用这些脚本需要UNIX-shell编码知识。正如先前所示，像artisan这样的工具有助于自动化许多手动任务。但是，大多数默认的artisan命令是设计为手动执行的。
- en: 'Luckily, two tools that use the Node.js JavaScript platform have emerged: *Grunt*
    and *gulp*. Both Grunt and gulp have had a considerable amount of success, but
    gulp has recently become more popular. However, learning to quickly write tasks
    using gulp is not very easy, especially for a PHP developer who may not be familiar
    with JavaScript syntax.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，出现了两个使用Node.js JavaScript平台的工具：*Grunt*和*gulp*。Grunt和gulp都取得了相当大的成功，但gulp最近变得更加流行。然而，对于可能不熟悉JavaScript语法的PHP开发人员来说，学习如何快速编写gulp任务并不容易。
- en: 'Consider the following example code taken from the documentation of gulp:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例代码，摘自gulp的文档：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From Gulp to Elixir
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Gulp到Elixir
- en: 'Luckily, the Laravel community is always forward thinking and focuses on reducing
    complexity. An official community tool named **Elixir** has emerged to facilitate
    the use of gulp. Gulp is built on top of Node.js, and Elixir is built on top of
    gulp, creating a wrapper:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Laravel社区一直秉承着前瞻性思维，专注于减少复杂性。一个名为**Elixir**的官方社区工具已经出现，以便于使用gulp。Gulp是建立在Node.js之上的，而Elixir是建立在gulp之上的，创建了一个包装器：
- en: '![From Gulp to Elixir](graphics/B04559_10_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![从Gulp到Elixir](graphics/B04559_10_01.jpg)'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Laravel Elixir is not to be confused with the dynamic, functional language with
    the same name. The other Elixir uses the Erlang virtual machine, while Laravel
    Elixir uses gulp and Node.js
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel Elixir不应与同名的动态功能语言混淆。另一个Elixir使用Erlang虚拟机，而Laravel Elixir使用gulp和Node.js
- en: Getting started
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: The first step is to install Node.js if it is not already installed on the development
    computer.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在开发计算机上安装Node.js（如果尚未安装）。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Instructions can be found at the following URL:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下网址找到说明：
- en: '[https://nodejs.org](https://nodejs.org)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://nodejs.org](https://nodejs.org)'
- en: Installing Node.js
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Node.js
- en: 'With a Debian-based operative system such as Ubuntu, installing Node.js could
    be as simple as using the `apt` package manager. From the command line, use the
    following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像Ubuntu这样的基于Debian的操作系统，安装Node.js可能就像使用`apt`软件包管理器一样简单。从命令行使用以下命令：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Please refer to the installation instructions for the correct operating system
    from the Node.js website ([https://nodejs.org](https://nodejs.org)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考Node.js网站（[https://nodejs.org](https://nodejs.org)）上的正确操作系统的安装说明。
- en: Installing the Node.js package manager
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Node.js包管理器
- en: 'The next step involves installing gulp, which Elixir will use to run its tasks.
    For this step, the **Node.js package manager** (**npm**) is required. If `npm`
    is not already installed, then the `apt` package installer is to be use. The following
    command will be used to install `npm`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步涉及安装gulp，Elixir将使用它来运行其任务。对于这一步，需要**Node.js包管理器**（**npm**）。如果尚未安装`npm`，则应使用`apt`软件包安装程序。以下命令将用于安装`npm`：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The npm uses a `json` file to manage the project''s dependencies: `package.json`.
    This file is found in the root of the Laravel project directory and has the following
    format:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: npm使用一个`json`文件来管理项目的依赖关系：`package.json`。该文件位于Laravel项目目录的根目录中，格式如下：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Gulp and Laravel Elixir are installed as dependencies.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 安装gulp和Laravel Elixir作为依赖项。
- en: Installing Gulp
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Gulp
- en: 'The following command is used to install `gulp`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令用于安装`gulp`：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Installing Elixir
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Elixir
- en: 'Once Node.js, npm, and gulp are installed, the next step is to install Laravel
    Elixir. By running `npm` install without any arguments, `npm` will read its configuration
    file and Laravel Elixir will be installed:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了Node.js、npm和gulp，下一步是安装Laravel Elixir。通过运行`npm` install而不带任何参数，`npm`将读取其配置文件并安装Laravel
    Elixir：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Running Elixir
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Elixir
- en: 'By default, Laravel contains a `gulpfile.js` file that is used by gulp to run
    its tasks. The file contains a `require` method that includes everything needed
    for the tasks to run:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Laravel包含一个`gulpfile.js`文件，该文件由gulp用于运行其任务。该文件包含一个`require`方法，用于包含运行任务所需的一切：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first mix is shown as an example: `app.less`. To run gulp, simply type
    `gulp` at the command line as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个混合示例显示为：`app.less`。要运行gulp，只需在命令行中输入`gulp`，如下所示：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first line indicates that the gulp file was loaded. The following lines
    show each task running. The `less` job deals with the cascading style sheet preprocessor
    `Less`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行表示已加载gulp文件。接下来的行显示每个任务的运行情况。`less`任务处理层叠样式表预处理器`Less`。
- en: Setting up notifications
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置通知
- en: 'If your development environment is a Vagrant Box, installing `vagrant-notify`
    will allow Laravel Elixir to interact directly with the host and display native
    messages directly in the operating system. To install it, the following command
    should be run from the host operating system:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的开发环境是Vagrant Box，则安装`vagrant-notify`将允许Laravel Elixir直接与主机交互，并在操作系统中直接显示本机消息。要安装它，应从主机操作系统运行以下命令：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here''s the screenshot of a notification showing that PHPUnit tests have failed:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通知的截图，显示PHPUnit测试失败了：
- en: '![Setting up notifications](graphics/B04559_10_02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![设置通知](graphics/B04559_10_02.jpg)'
- en: The installation instructions depend on each operating system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 安装说明取决于每个操作系统。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information, visit [https://github.com/fgrehm/vagrant-notify](https://github.com/fgrehm/vagrant-notify).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请访问[https://github.com/fgrehm/vagrant-notify](https://github.com/fgrehm/vagrant-notify)。
- en: Combining CSS and JavaScript files with Elixir
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Elixir合并CSS和JavaScript文件
- en: Possibly, the single most important step of the deployment process is to combine
    and minify CSS and JavaScript files. Minifying and combining five JavaScript files
    and three CSS files means that instead of eight HTTP requests, there will be only
    one. Also, by minifying the files by removing white space, line breaks, comments,
    and other techniques, such as shortening variable names, the file size will be
    reduced to a fraction of its original size. Despite the advantage, there are still
    many websites that continue to use unminified and uncombined CSS and JavaScript
    files.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可能，部署过程中最重要的一步是合并和缩小CSS和JavaScript文件。缩小和合并五个JavaScript文件和三个CSS文件意味着不再有八个HTTP请求，而只有一个。此外，通过去除空格、换行符、注释和其他技术（例如缩短变量名）来缩小文件大小，文件大小将减少到原始大小的一小部分。尽管有这些优势，仍然有许多网站继续使用未缩小和未合并的CSS和JavaScript文件。
- en: 'Elixir provides a simple means to easily combine and minify files. The following
    code illustrates this example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Elixir提供了一种简单的方法来轻松合并和缩小文件。以下代码说明了这个示例：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The two methods, `scripts()` and `styles()`, will combine all of the JavaScript
    and CSS files into single files, `all.js` and `all.css`, respectively. By default,
    the two functions expect the files to be located at `/resources/assets/js` and
    `/resources/assets/css`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`scripts()`和`styles()`两种方法将所有JavaScript和CSS文件合并为单个文件，分别为`all.js`和`all.css`。默认情况下，这两个函数期望文件位于`/resources/assets/js`和`/resources/assets/css`。'
- en: 'When the gulp command has finished, the output will be like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当gulp命令完成时，输出将如下所示：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice how the output conveniently states which directories were scanned. The
    contents are combined, referred to as merged in this context, but not minified.
    This is because, during development, debugging is too difficult on minified files.
    If only a certain file is to be merged, then the name of the file may be passed
    into the function as the first parameter:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意输出方便地说明了扫描了哪些目录。内容被合并，但没有被缩小。这是因为在开发过程中，在缩小文件上进行调试太困难。如果只有某个文件需要合并，则可以将文件名作为第一个参数传递给函数：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If multiple files are to be merged, then an array of filenames may be passed
    into the function as a first parameter:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要合并多个文件，则可以将文件名数组作为第一个参数传递给函数：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In a production environment, having minified files is desirable. To have Elixir
    minify both the CSS and JavaScript, add the `--production` option to the gulp
    command as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，希望有缩小的文件。要让Elixir缩小CSS和JavaScript，只需在gulp命令中添加`--production`选项，如下所示：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will produce the desired minified output. The default output directory
    is located at:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生所需的缩小输出。默认输出目录位于：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Compiling with Laravel Elixir
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Laravel Elixir编译
- en: Laravel Elixir is great at performing routine tasks that would otherwise require
    learning scripting languages. The following sections will demonstrate each of
    the various types of compiling that Elixir can perform.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel Elixir非常擅长执行通常需要学习脚本语言的例行任务。以下各节将演示Elixir可以执行的各种编译类型。
- en: Compiling Sass and Less
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译Sass和Less
- en: 'Cascading style sheet preprocessors `Less` and `Sass` emerged from the need
    to enhance the capabilities of CSS. It does not contain any variables for example.
    `Less` and `Sass` allow frontend developers take advantage of variables and other
    features that are syntactically familiar. The following code is an example of
    standard CSS. The DOM elements `p` and `li` (paragraph and list item respectively),
    and any element with a `post` class will have a `font-family` Arial, with sans-serif
    as a fallback and black as its color:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 层叠样式表预处理器`Less`和`Sass`出现是为了增强CSS的功能。例如，它不包含任何变量。`Less`和`Sass`允许前端开发人员利用变量和其他熟悉的语法特性。以下代码是标准CSS的示例。DOM元素`p`和`li`（分别表示段落和列表项），以及具有`post`类的任何元素将具有`font-family`
    Arial，sans-serif作为回退，并且颜色为黑色：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, using the `Sass` CSS pre-processor, both the font-family and text color
    will be substituted with two variables: `$text-font` and `$text-color`. This allows
    easy maintenance when changes are needed. Also, the variables may be shared. The
    code is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`Sass` CSS预处理器，将字体族和文本颜色替换为两个变量：`$text-font`和`$text-color`。这样在需要更改时可以轻松维护。而且，这些变量可以共享。代码如下：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Less` preprocessor uses `@` instead of `$`; therefore, its syntax looks
    more like an annotation than a `php` variable:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Less`预处理器使用`@`而不是`$`；因此，它的语法看起来更像是注释而不是`php`变量：'
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There is an extra step that needs to be performed, since it will not be interpreted
    by a browser engine. The added step is to compile the `Less` or `Sass` code into
    real CSS. This introduces extra time in the development phase; thus, Elixir helps
    by automating the process.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要执行一个额外的步骤，因为它不会被浏览器引擎解释。增加的步骤是将`Less`或`Sass`代码编译成真正的CSS。这在开发阶段会增加额外的时间；因此，Elixir通过自动化流程来帮助。
- en: In the previous Laravel Elixir example, the `less` function took only the filename,
    `app.less`, as its sole argument. Now, the example should be a bit clearer. Also,
    `less` may take an array of arguments that will be compiled.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的Laravel Elixir示例中，`less`函数只接受文件名`app.less`作为其唯一参数。现在，示例应该更清晰一些。此外，`less`可以接受一个将被编译的参数数组。
- en: 'The `less` method searches in `/resources/assets/less` and the output will
    be placed in `public/css/` by default:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`less`方法在`/resources/assets/less`中搜索，默认情况下输出将放在`public/css/`中：'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Compiling CoffeeScript
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译CoffeeScript
- en: 'CoffeeScript is a programming language that compiles into JavaScript. Like
    Less and Sass, its goal is to simplify or extend the functionality of the language
    that it compiles to. In the case of CoffeeScript, it simplifies Javascript by
    requiring less keystrokes. In the following JavaScript code, two variables—an
    array and an object—are created:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript是一种编译成JavaScript的编程语言。与Less和Sass一样，它的目标是简化或扩展它所编译的语言的功能。在CoffeeScript的情况下，它通过减少按键次数来简化Javascript。在下面的JavaScript代码中，创建了两个变量——一个数组和一个对象：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the following CoffeeScript code, the syntax is very similar, but there is
    no semicolon required and there is no need for `var` to create a variable. Also,
    indentation is used to define the object''s attributes. The code is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的CoffeeScript代码中，语法非常相似，但不需要分号，也不需要`var`来创建变量。此外，缩进用于定义对象的属性。代码如下：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this CoffeeScript example, there are only a few less characters; however,
    for a programmer, less keystrokes can help increase speed and efficiency. To add
    the coffee compiler to Elixir, simply use the `coffee` function, as shown in the
    following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个CoffeeScript示例中，字符较少；然而，对于程序员来说，减少按键次数可以帮助提高速度和效率。要将coffee编译器添加到Elixir中，只需使用`coffee`函数，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A summary of compiler commands
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译器命令摘要
- en: The following table shows the mapping between preprocessor, language, function,
    and where each function expects the source to be. The last column on the right
    shows the directory and/or name of the resultant combined file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了预处理器、语言、函数以及每个函数期望源文件的位置。右侧的最后一列显示了结果合并文件的目录和/或名称。
- en: '| processor | Language | function | Source directory | Default Output Location
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| processor | Language | function | Source directory | Default Output Location
    |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Less | CSS | `less()` | `/resources/assets/less/file(s).less` | `/public/css/file(s).css`
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| Less | CSS | `less()` | `/resources/assets/less/file(s).less` | `/public/css/file(s).css`
    |'
- en: '| Sass | CSS | `sass()` | `/resources/assets/sass/file(s).scss` | `/public/css/file(s).css`
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| Sass | CSS | `sass()` | `/resources/assets/sass/file(s).scss` | `/public/css/file(s).css`
    |'
- en: '| N/A | CSS | `styles()` | `/resources/assets/css/` | `/public/css/all.css`
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: N/A | CSS | `styles()` | `/resources/assets/css/` | `/public/css/all.css`
- en: '| N/A | JavaScript | `scripts()` | `/resources/assets/js/` | `/public/js/all.js`
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| N/A | JavaScript | `scripts()` | `/resources/assets/js/` | `/public/js/all.js`
    |'
- en: '| CoffeeScript | JavaScript | `coffee()` | `/resources/assets/coffee/` | `/public/js/app.js`
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| CoffeeScript | JavaScript | `coffee()` | `/resources/assets/coffee/` | `/public/js/app.js`
    |'
- en: Saving with a different name
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用不同的名称保存
- en: 'Optionally, each method takes a second parameter that will override the default
    location. To use a different directory, (in this case, a directory called `app`),
    simply add the directory as a second parameter:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，每个方法都可以接受第二个参数，该参数将覆盖默认位置。要使用不同的目录（在本例中是一个名为`app`的目录），只需将该目录作为第二个参数添加：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, the files will be saved at `public/app/jsand public/app/css`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，文件将保存在`public/app/js`和`public/app/css`。
- en: Putting everything together
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: 'Finally, let''s put everything together to draw an interesting conclusion.
    Since CoffeeScript scripts and `less` and `sass` files are not merged but copied
    into the destination directly, we first save the CoffeeScript, `less`, and `sass`
    files into the directories where Elixir expects the JavaScript and CSS files to
    be. Then, we instruct Elixir to merge and minify all of the JavaScript and CSS
    files into two merged and minified files. The code is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们把所有东西放在一起得出一个有趣的结论。由于CoffeeScript脚本和`less`和`sass`文件不是合并而是直接复制到目标中，我们首先将CoffeeScript、`less`和`sass`文件保存到Elixir期望JavaScript和CSS文件的目录中。然后，我们指示Elixir将所有JavaScript和CSS文件合并和压缩成两个合并和压缩的文件。代码如下：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is extremely important to remember that Elixir overwrites files without verifying
    that the file exists, so a unique name would need to be chosen for each of the
    files. When the command is finished, `all.js` and `all.css` will be merged and
    minified in the `public/js` and `public/css` directories.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的一点是，Elixir会覆盖文件而不验证文件是否存在，因此需要为每个文件选择一个唯一的名称。命令完成后，`all.js`和`all.css`将合并和压缩在`public/js`和`public/css`目录中。
- en: Running tests with Elixir
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Elixir运行测试
- en: In addition to compiling and sending notifications, Elixir may also be used
    to automate the launching of tests. The following sections will discuss how Elixir
    can be used for both PHPSpec and PHPUnit.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编译和发送通知之外，Elixir还可以用于自动化测试的启动。接下来的部分将讨论Elixir如何用于PHPSpec和PHPUnit。
- en: PHPSpec
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHPSpec
- en: 'The first step would be to run the PHPSpec tests to automate code testing.
    By adding `phpSpec()` to our `gulpfile.js` as follows, PHPSpec tests will run:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是运行PHPSpec测试以自动化代码测试。通过将`phpSpec()`添加到我们的`gulpfile.js`中，PHPSpec测试将运行：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is shown in the following screenshot. The PHPSpec output is maintained,
    so the test output is very useful:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出。PHPSpec输出被保留，因此测试输出非常有用：
- en: '![PHPSpec](graphics/B04559_10_03.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![PHPSpec](graphics/B04559_10_03.jpg)'
- en: 'When the PHPSpec tests fail, the results are easily readable:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当PHPSpec测试失败时，结果很容易阅读：
- en: '![PHPSpec](graphics/B04559_10_04.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![PHPSpec](graphics/B04559_10_04.jpg)'
- en: A screenshot of Laravel Elixir's output
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel Elixir输出的截图
- en: In this example, phpspec encountered an error in the **it creates a reservation
    test** line as shown in the preceding screenshot.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，phpspec在**it creates a reservation test**一行遇到了错误，如前面的截图所示。
- en: PHPUnit
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHPUnit
- en: 'Similarly, we may add PHPUnit to our suite of tests by adding `phpUnit` to
    the list of tasks as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以通过将`phpUnit`添加到任务列表中来将PHPUnit添加到我们的测试套件中，如下所示：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Creating custom tasks
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义任务
- en: 'Elixir gives us the ability to create custom tasks to do virtually anything.
    One example of a custom task that we could write is to scan the controllers for
    annotations. All custom tasks require `gulp` and `laravel-elixir`. It is important
    to remember that the programming language used is JavaScript, so the syntax may
    or may not be familiar, but it is easy enough to learn quickly. If commands will
    be executed from the command-line interface, then we shall also import gulp-shell.
    The code is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Elixir使我们能够创建自定义任务来几乎做任何事情。我们可以编写一个扫描控制器注释的自定义任务的一个例子。所有自定义任务都需要`gulp`和`laravel-elixir`。重要的是要记住所使用的编程语言是JavaScript，因此语法可能或可能不熟悉，但很容易快速学习。如果命令将从命令行界面执行，那么我们还将导入gulp-shell。代码如下：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this code, we first extend Elixir and give the method a name, for example,
    `routeScanning`. Then, a gulp task is defined and the first argument to the `task`
    method is the name of the command. The second command is a closure containing
    the code that will be executed and returned.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先扩展Elixir并给方法一个名称，例如`routeScanning`。然后，定义了一个gulp任务，`task`方法的第一个参数是命令的名称。第二个命令是包含将被执行和返回的代码的闭包。
- en: Finally, the task is queued for execution by passing the name of the command
    into the `queueTask` method.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过将命令的名称传递给`queueTask`方法，将任务排队执行。
- en: 'Add this script to our chain as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本添加到我们的链中，如下所示：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output will be like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since the `pipe` function allows chaining of commands, it is easy to add in
    a notification that will alert the notification system, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pipe`函数允许命令链接，很容易添加一个通知，以警报通知系统，如下所示：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, the `Notification` class is pulled in and a new notification is created
    to send the message `Annotations scanned.` to the notification system.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Notification`类被引入，并创建了一个新的通知，以将消息`Annotations scanned.`发送到通知系统。
- en: 'Running the code produces the following output. Notice that the `gulp-notify`
    has been added:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会产生以下输出。请注意，已添加了`gulp-notify`：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Setting up a file watcher
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置文件监视器
- en: 'Obviously, running gulp every time we want to compile the cascading style sheets
    or scan for annotations is tedious. Fortunately, a watcher mechanism is built
    into Elixir. To invoke it, simply run the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，每次我们想要编译层叠样式表或扫描注释时运行gulp是很繁琐的。幸运的是，Elixir内置了一个监视机制。要调用它，只需运行以下命令：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will allow any tasks that have been placed into the `gulpfile.js` chain
    to automatically run when certain changes occur. The code necessary to enable
    this in the annotation task is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许将任务自动运行到`gulpfile.js`链中的任何任务在发生某些更改时。启用此功能的必要代码在注释任务中如下：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code registers a watch. The first argument is the `routeScanning`
    task. The second command is the directory pattern that will be watched for modifications.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码注册了一个监视器。第一个参数是`routeScanning`任务。第二个命令是将被监视以进行修改的目录模式。
- en: Since we know that route annotations will be inside the controllers, we may
    set the path to look only inside the `app/Http/Controllers/` directory. The regex
    style syntax will match on any file with a `php` extension in any one of the directories
    that are located under controllers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道路由注释将在控制器内部，我们可以设置路径仅在`app/Http/Controllers/`目录内查找。正则表达式样式语法将匹配位于控制器下的任何一个目录中具有`php`扩展名的文件。
- en: Now, whenever a file matching the pattern is modified, the `routeScanning` task,
    as well as any other tasks that are watching files that match the same pattern.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当修改与模式匹配的文件时，`routeScanning`任务以及任何其他监视匹配相同模式的文件的任务都将被执行。
- en: Additional Laravel Elixir tasks
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的Laravel Elixir任务
- en: The npm website provides more than 75 tasks that deal with testing, JavaScript,
    CSS, and more. The `npm` website is located at [http://npmjs.com](http://npmjs.com).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: npm网站提供了超过75个任务，涉及测试、JavaScript、CSS等。`npm`网站位于[http://npmjs.com](http://npmjs.com)。
- en: '![Additional Laravel Elixir tasks](graphics/B04559_10_05.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![额外的Laravel Elixir任务](graphics/B04559_10_05.jpg)'
- en: A screenshot of the npm website containing many useful Laravel Elixir tasks
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: npm网站的截图包含了许多有用的Laravel Elixir任务
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how Elixir's growing task list can help both the
    full-stack developer as well as a team of developers. Some of the tasks are related
    to frontend development, such as compiling, combining, and minifying CSS and JavaScript.
    Other tasks are related to backend development, such as behavior-driven development.
    Integrating these tasks into the daily development workflow will make it easy
    for the entire team to understand the steps that are necessary in the continuous
    integration server, where Elixir will execute its tasks, such as testing and compiling,
    to prepare the files for development into production.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了Elixir不断增长的任务列表如何帮助全栈开发人员以及开发团队。一些任务与前端开发相关，例如编译、合并和压缩CSS和JavaScript。其他任务与后端开发相关，例如行为驱动开发。将这些任务集成到日常开发工作流程中，将使整个团队能够理解在持续集成服务器中执行的步骤，其中Elixir将执行其任务，例如测试和编译，以准备将文件从开发转换为生产。
- en: Since Elixir is built upon gulp, the future of the Elixir will continue to be
    enriched as both the gulp and Elixir communities continue to grow and new contributors
    continue contributing to Elixir.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Elixir是建立在gulp之上的，随着gulp和Elixir社区的持续增长和新的贡献者继续为Elixir做出贡献，Elixir的未来将继续丰富。
