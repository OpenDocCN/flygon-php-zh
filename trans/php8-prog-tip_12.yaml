- en: '*Chapter 9*: Mastering PHP 8 Best Practices'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：精通PHP 8最佳实践'
- en: In this chapter, you will be introduced to the best practices that are currently
    enforced in PHP 8\. We will cover several significant method signature changes
    and how their new usage continues the general PHP trend of helping you produce
    better code. We will also have a look at how private methods, interfaces, traits,
    and anonymous class usage has changed. Finally, we will discuss important changes
    in how namespaces are parsed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解到目前在PHP 8中强制执行的最佳实践。我们将涵盖几个重要的方法签名更改，以及它们的新用法如何延续了PHP的一般趋势，帮助您编写更好的代码。我们还将看一下私有方法、接口、特征和匿名类的使用方式发生了什么变化。最后，我们将讨论命名空间解析的重要变化。
- en: Mastering the best practices that will be covered in this chapter will not only
    move you toward writing better code, but how to avoid the potential code breaks
    that might arise if you fail to grasp these new practices. In addition, the techniques
    discussed in this chapter will help you write code that's more efficient than
    was possible in the past.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握本章将涵盖的最佳实践不仅会让您更接近编写更好的代码，还会让您了解如何避免如果未掌握这些新实践可能导致的潜在代码破坏。此外，本章讨论的技术将帮助您编写比过去更高效的代码。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Discovering method signature changes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现方法签名更改
- en: Dealing with private methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理私有方法
- en: Working with interfaces and traits
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口和特征
- en: Controlling anonymous class usage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制匿名类的使用
- en: Understanding changes in namespaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解命名空间的变化
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To examine and run the code examples provided in this chapter, the minimum
    recommended hardware is as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看并运行本章提供的代码示例，建议的最低硬件配置如下：
- en: X86_64-based desktop PC or laptop
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于X86_64的台式PC或笔记本电脑
- en: 1 GB free disk space
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 GB的可用磁盘空间
- en: 4 GB of RAM
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 GB的RAM
- en: 500 Kbps or faster internet connection
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 500 Kbps或更快的互联网连接
- en: 'In addition, you will need to install the following software:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您需要安装以下软件：
- en: Docker
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Docker Compose
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Please refer to the *Technical requirements* section of [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013),
    *Introducing New PHP 8 OOP Features,* for more information on how to install Docker
    and Docker Compose, as well as how to build the Docker container used to demonstrate
    the code in this book. In this book, we will refer to the directory that you restored
    the sample code in as `/repo`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何安装Docker和Docker Compose以及构建用于演示本书中代码的Docker容器的更多信息，请参阅[*第1章*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013)的*技术要求*部分，*介绍新的PHP
    8面向对象编程特性*。在本书中，我们将把您恢复示例代码的目录称为`/repo`。
- en: 'The source code for this chapter is located here: [https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices).
    We will start by examining significant method signature changes.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于此处：[https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices)。我们将首先检查重要的方法签名更改。
- en: Discovering method signature changes
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现方法签名更改
- en: Several **method signature changes** have been introduced in PHP 8\. Understanding
    these signature changes is important if your code extends any of the classes or
    implements any of the methods described in this section. As long as you are aware
    of these changes, your code will function correctly, resulting in fewer bugs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8引入了几个**方法签名更改**。如果您的代码扩展了本节描述的任何类或实现了任何方法，了解这些签名更改是很重要的。只要您了解了这些更改，您的代码将正常运行，从而减少错误。
- en: The signature changes that were introduced in PHP 8 reflect the updated *best
    practices*. Accordingly, if you write code that uses the correct method signatures,
    you are following these best practices. We will begin our discussion by reviewing
    PHP 8 changes to magic method signatures.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8中引入的签名更改反映了更新的*最佳实践*。因此，如果您编写使用正确方法签名的代码，您就是在遵循这些最佳实践。我们将从回顾PHP 8对魔术方法签名的更改开始我们的讨论。
- en: Managing magic method signatures
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理魔术方法签名
- en: In PHP 8, the definition and use of **magic methods** has taken a significant
    step toward standardization. This was accomplished by introducing precise magic
    method signatures in the form of strict argument and return data types. As with
    most of the improvements seen in PHP 8, this update was included to prevent the
    misuse of magic methods. The overall result is better code with fewer bugs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，**魔术方法**的定义和使用已经朝着标准化迈出了重要的一步。这是通过引入严格的参数和返回数据类型的精确魔术方法签名来实现的。与PHP 8中的大多数改进一样，这次更新旨在防止魔术方法的误用。总体结果是更好的代码，更少的错误。
- en: The downside of this enhancement is that if you have code that provides an incorrect
    argument or return value type, an `Error` is thrown. On the other hand, if your
    code does provide the correct argument data type and return value type, or if
    your code does not use argument or return value data types at all, this enhancement
    will have no adverse effects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种增强的缺点是，如果您的代码提供了不正确的参数或返回值类型，将会抛出`Error`。另一方面，如果您的代码提供了正确的参数数据类型和返回值数据类型，或者如果您的代码根本不使用参数或返回值数据类型，这种增强将不会产生不良影响。
- en: 'The following code block summarizes the new argument and return value data
    types for magic methods in PHP 8 and above:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块总结了PHP 8及以上版本中魔术方法的新参数和返回值数据类型：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s have a look at three simple examples that illustrate the impact
    of the magic method signature changes:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下三个简单的例子，说明魔术方法签名更改的影响：
- en: 'The first example involves the `NoTypes` class, which defines `__call()` but
    does not define any data types:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个例子涉及`NoTypes`类，该类定义了`__call()`但没有定义任何数据类型：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following example (in the same file as the preceding example) is of the
    `MixedTypes` class, which defines `__invoke()` but uses an `array` data type rather
    than a `mixed` one:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例（与前面的示例在同一个文件中）是`MixedTypes`类的示例，它定义了`__invoke()`，但使用的是`array`数据类型而不是`mixed`。
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the PHP 7 output for the code sample shown in the preceding steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在前面步骤中显示的代码示例的PHP 7输出：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And here is the same code sample but running under PHP 8:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在PHP 8下运行的相同代码示例：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the two sets of output are identical. The first class shown,
    `NoTypes`, works because no data type hints were defined. Interestingly, the `MixedTypes`
    class works in both PHP 8 and below since the new `mixed` data type is actually
    a union of all types. Accordingly, you are safe to use any specific data type
    in place of `mixed`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这两组输出是相同的。第一个显示的类`NoTypes`之所以有效，是因为没有定义数据类型提示。有趣的是，`MixedTypes`类在PHP
    8及以下版本中都可以工作，因为新的`mixed`数据类型实际上是所有类型的联合。因此，您可以安全地在`mixed`的位置使用任何特定的数据类型。
- en: 'In our final example, we will define the `WrongType` class. In this class,
    we will define a magic method called `__isset()` using a return data type that
    doesn''t match the PHP 8 requirement. Here, we are using `string`, whereas in
    PHP 8, its return type needs to be `bool`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的最后一个例子中，我们将定义`WrongType`类。在这个类中，我们将定义一个名为`__isset()`的魔术方法，使用一个与PHP 8要求不匹配的返回数据类型。在这里，我们使用的是`string`，而在PHP
    8中，它的返回类型需要是`bool`：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This example works in PHP 7 because it relies on the fact that the empty string
    is returned in this example if the variable is not set, and is then interpolated
    as a `FALSE` Boolean. Here is the PHP 7 output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在PHP 7中可以工作，因为它依赖于这样一个事实：如果变量未设置，则在这个例子中返回空字符串，然后被插入为`FALSE`布尔值。这是PHP 7的输出：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In PHP 8, however, because magic method signatures are now standardized, the
    example fails, as shown here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PHP 8中，由于魔术方法签名现在是标准化的，所以这个例子失败了，如下所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, PHP 8 strictly enforces its magic method signatures.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，PHP 8严格执行其魔术方法签名。
- en: Tip
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '*Best Practice*: Revise any code that uses magic methods to follow the new
    strict method signatures. For more information on strict magic method signatures,
    go to [https://wiki.php.net/rfc/magic-methods-signature](https://wiki.php.net/rfc/magic-methods-signature).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*最佳实践*：修改任何使用魔术方法的代码，以遵循新的严格方法签名。有关严格魔术方法签名的更多信息，请访问[https://wiki.php.net/rfc/magic-methods-signature](https://wiki.php.net/rfc/magic-methods-signature)。'
- en: You now have an idea of what to look for and how to correct potential code breaks
    involving magic methods. Now, let's have a look at Reflection extension method
    signature changes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道要查找什么以及如何纠正涉及魔术方法的潜在代码中断。现在，让我们看一下Reflection扩展方法签名的更改。
- en: Examining Reflection method signature changes
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查Reflection方法签名的更改
- en: 'Backward compatible code breaks may occur if your application is using either
    the `invoke()` or `newInstance()` Reflection extension method. In PHP 7 and below,
    all three methods listed next accepted an unlimited number of arguments. However,
    in the method signature, only one argument was listed, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序使用`invoke()`或`newInstance()` Reflection扩展方法，则可能会发生向后兼容的代码中断。在PHP 7及以下版本中，下面列出的三种方法都接受无限数量的参数。但是，在方法签名中，只列出了一个参数，如下所示：
- en: '`ReflectionClass::newInstance($args)`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReflectionClass::newInstance($args)`'
- en: '`ReflectionFunction::invoke($args)`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReflectionFunction::invoke($args)`'
- en: '`ReflectionMethod::invoke($args)`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReflectionMethod::invoke($args)`'
- en: 'In PHP 8, the method signatures accurately reflect reality in that `$args`
    is preceded by the `variadics` operator. Here are the new method signatures:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，方法签名准确地反映了现实，即`$args`之前有`variadics`运算符。以下是新的方法签名：
- en: '`ReflectionClass::newInstance(...$args)`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReflectionClass::newInstance(...$args)`'
- en: '`ReflectionFunction::invoke(...$args)`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReflectionFunction::invoke(...$args)`'
- en: '`ReflectionMethod::invoke($object, ...$args)`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReflectionMethod::invoke($object, ...$args)`'
- en: This change will only break your code if you have a custom class that extends
    any of these three classes, and where your custom class also overrides any of
    the three methods listed in the previous bulleted list.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当您的自定义类扩展了这三个类中的任何一个，并且您的自定义类还覆盖了前面列出的三种方法时，这种更改才会破坏您的代码。
- en: Finally, the `isBuiltin()` method has been moved from `ReflectionType` to `ReflectionNamedType`.
    This presents a potential code break if you are using `ReflectionType::isBuiltIn()`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`isBuiltin()`方法已从`ReflectionType`移动到`ReflectionNamedType`。如果您使用`ReflectionType::isBuiltIn()`，这可能会导致潜在的代码中断。
- en: Now, let's have a look at method signature changes in the PDO extension.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看PDO扩展中的方法签名更改。
- en: Dealing with PDO extension signature changes
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理PDO扩展签名更改
- en: 'The PDO extension has two method signature changes that are of importance.
    These changes are needed to address inconsistencies in method calls when different
    **fetch modes** are applied. Here is the new method signature for `PDO::query()`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: PDO扩展有两个重要的方法签名更改。这些更改是为了解决在应用不同的**获取模式**时方法调用的不一致性。这是`PDO::query()`的新方法签名：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the new signature for `PDOStatement::setFetchMode()`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`PDOStatement::setFetchMode()`的新签名：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The `PDO::query()` method signature changes are referenced in the PHP 7.4 to
    PHP 8 migration guide, here: https://www.php.net/manual/en/ migration80.incompatible.php#migration80.incompatible.pdo.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`PDO::query()`方法签名更改在PHP 7.4到PHP 8迁移指南中有所提及，链接在这里：https://www.php.net/manual/en/migration80.incompatible.php#migration80.incompatible.pdo。'
- en: 'The two new method signatures are much more uniform than the old signatures,
    and they completely cover syntactical differences when you''re using different
    fetch modes. A simple code example that performs `PDO::query()` using two different
    fetch modes illustrates why the method signature needed to be normalized:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个新的方法签名比旧的方法签名更加统一，并且完全涵盖了在使用不同的获取模式时的语法差异。一个简单的代码示例，使用两种不同的获取模式执行`PDO::query()`，说明了为什么需要规范化方法签名：
- en: 'Let''s start by including a configuration file that contains database connection
    parameters. From this, we will create a `PDO` instance:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从包含一个包含数据库连接参数的配置文件开始。从这个文件，我们将创建一个`PDO`实例：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s define a SQL statement and send it so that it can be prepared:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个SQL语句并发送它以便进行准备：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will execute the prepared statement and set the fetch mode to `PDO::FETCH_ASSOC`.
    Notice that when we use this fetch mode, only one argument is provided to the
    `setFetchMode()` method:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将执行准备好的语句，并将获取模式设置为`PDO::FETCH_ASSOC`。请注意，当我们使用此获取模式时，`setFetchMode()`方法只提供一个参数：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we will execute the same prepared statement for a second time. This
    time, we will set the fetch mode to `PDO::FETCH_CLASS`. Notice that when we use
    this fetch mode, two arguments are provided to the `setFetchMode()` method:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将再次执行相同的预处理语句。这次，我们将将获取模式设置为`PDO::FETCH_CLASS`。请注意，当我们使用此获取模式时，`setFetchMode()`方法提供了两个参数：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output in the first query is an associative array. The second query produces
    an `ArrayObject` instance. Here is the output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个查询的输出是一个关联数组。第二个查询产生一个`ArrayObject`实例。以下是输出：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It''s important to observe that even though the method signatures have changed,
    you can keep your existing code as-is: this *does not* present a backward compatible
    code break!'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，即使方法签名已经改变，您可以保持现有的代码不变：这*不会*导致向后兼容的代码中断！
- en: Now, let's have a look at methods that are declared as `static`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下被声明为`static`的方法。
- en: Dealing with newly defined static methods
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理新定义的静态方法
- en: Another potentially significant change seen in PHP 8 is that several methods
    are now declared `static`. If you are already using the classes and methods described
    here as direct object instances, then you do not have a problem.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中看到的另一个可能重大的变化是，现在有几个方法被声明为`static`。如果您已经使用这里描述的类和方法作为直接对象实例，那么您就没有问题。
- en: 'The following methods are now declared as static:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法现在被声明为静态：
- en: '`tidy::repairString()`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tidy::repairString()`'
- en: '`tidy::repairFile()`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tidy::repairFile()`'
- en: '`XMLReader::open()`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XMLReader::open()`'
- en: '`XMLReader::xml()`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XMLReader::xml()`'
- en: 'The potential for a code break my occur if you override one of the classes
    mentioned previously. In this case, you *must* declare the overridden method as
    `static`. Here is a simple example that illustrates the potential problem:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您覆盖了之前提到的类中的一个方法，可能会导致代码中断。在这种情况下，您*必须*将被覆盖的方法声明为`static`。以下是一个简单的示例，说明了可能的问题：
- en: 'First, let''s define a string that has mismatched `<div>` tags:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个具有不匹配的`<div>`标签的字符串：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, define an anonymous class that extends `tidy`, fixes the string, and
    returns the string with all HTML tags in lowercase:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个匿名类，该类扩展了`tidy`，修复了字符串，并返回所有HTML标签都是小写的字符串：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, echo the repaired string:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，输出修复后的字符串：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we run this code example in PHP 7, the output will be as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在PHP 7中运行此代码示例，输出将如下所示：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the mismatched `<div>` tag has been repaired, and a properly
    formatted HTML document has been produced. You'll also note that all the tags
    are in lowercase.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，不匹配的`<div>`标签已经修复，生成了一个格式正确的HTML文档。您还会注意到所有标签都是小写的。
- en: 'In PHP 8, however, a method signature issue arises, as you can see here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PHP 8中，出现了一个方法签名问题，如下所示：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, in PHP 8, the `repairString()` method is now declared as `static`.
    The method signature for `repairString()` in the anonymous class we defined earlier
    needs to be rewritten, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在PHP 8中所看到的，`repairString()`方法现在被声明为`static`。我们之前定义的匿名类中`repairString()`的方法签名需要重写，如下所示：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output (not shown), once rewritten, is the same as the PHP 7 output shown
    earlier. Also, note that the last line can now also be written as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重写后的输出与之前显示的PHP 7输出相同（未显示）。还要注意，最后一行现在也可以写成如下形式：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that you know about the methods that are newly defined as static, let's
    look at a related topic; that is, the static return type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了新定义为静态的方法，让我们来看一个相关主题；即，静态返回类型。
- en: Working with the static return type
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理静态返回类型
- en: The **static** keyword is used in several contexts in PHP. Its basic uses are
    beyond the scope of this discussion. In this section, we will focus on a new usage
    for `static` as a return data type.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，`static`关键字在几个上下文中使用。它的基本用法超出了本讨论的范围。在本节中，我们将重点关注`static`作为返回数据类型的新用法。
- en: Since `static` is considered a subtype of `self`, it can be used to widen the
    narrower return type of `self`. The `static` keyword cannot be used as a type
    hint, however, as it would violate the *Liskov Substitution Principle*. It would
    also confuse developers as `static` is already used in too many other contexts.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`static`被认为是`self`的子类型，它可以用于扩展`self`的较窄返回类型。然而，`static`关键字不能用作类型提示，因为这将违反*Liskov替换原则*。这也会让开发人员感到困惑，因为`static`已经在太多其他上下文中使用了。
- en: Tip
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The following article describes the background discussion that preceded the
    introduction of the static return type: [https://wiki.php.net/rfc/static_return_type](https://wiki.php.net/rfc/static_return_type).
    The following documentation references late static binding: [https://www.php.net/manual/en/language.oop5.late-static-bindings.php](https://www.php.net/manual/en/language.oop5.late-static-bindings.php).
    The *Liskov Substitution Principle* was discussed in [*Chapter 5*](B16992_05_Final_JC_ePub.xhtml#_idTextAnchor104),
    *Discovering Potential OOP Backward-Compatibility Breaks*, in the *Understanding
    expanded PHP 8 variance support* section.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文章描述了在引入静态返回类型之前的背景讨论：[https://wiki.php.net/rfc/static_return_type](https://wiki.php.net/rfc/static_return_type)。以下文档引用了延迟静态绑定：[https://www.php.net/manual/en/language.oop5.late-static-bindings.php](https://www.php.net/manual/en/language.oop5.late-static-bindings.php)。*Liskov替换原则*在[*第5章*](B16992_05_Final_JC_ePub.xhtml#_idTextAnchor104)，*发现潜在的OOP向后兼容性中断*中有讨论，在*理解扩展的PHP
    8方差支持*部分。
- en: 'The most common use for this new return data type would be in classes that
    use the **fluent interface**. The latter is a technique whereby an object method
    returns an instance of the current object state, thus allowing a chain of method
    calls to be used in a *fluent* (readable) manner. In the following example, note
    how the object builds a SQL `SELECT` statement:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的返回数据类型最常见的用法是在使用**流畅接口**的类中。后者是一种技术，其中对象方法返回当前对象状态的实例，从而允许以*流畅*（可读）的方式使用一系列方法调用。在下面的例子中，请注意对象如何构建SQL
    `SELECT`语句：
- en: 'First, we must define a `Where` class that accepts an unlimited number of arguments
    to form a SQL `WHERE` clause. Note the return data type of `static`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须定义一个`Where`类，它接受无限数量的参数来形成SQL `WHERE`子句。注意`static`的返回数据类型：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s define the main class, `Select`, which provides methods for building
    parts of a SQL `SELECT` statement. Again, notice that the methods shown all return
    the current class instance and have a return data type of `static`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义主类`Select`，它提供了构建SQL `SELECT`语句部分的方法。再次注意，所示的方法都返回当前类实例，并且返回数据类型为`static`：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we must define a calling program that provides the values needed to
    build the SQL statement. Note that the `echo` statement uses the fluent interface
    to make programmatically creating the SQL statement much easier to follow:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须定义一个调用程序，提供构建SQL语句所需的值。请注意，`echo`语句使用流畅接口，使得以编程方式创建SQL语句更容易理解：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is the output of the code example running in PHP 8:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在PHP 8中运行代码示例的输出：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This example doesn't work in PHP 7, of course, as the `static` keyword is not
    available as a return data type. Next, let's have a look at the extended use of
    the special `::class` constant.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子在PHP 7中不起作用，因为`static`关键字不可用作返回数据类型。接下来，让我们来看看特殊的`::class`常量的扩展使用。
- en: Extending the use of the ::class constant
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展使用::class常量
- en: The special `::class` constant is an extremely useful construct in that it can
    silently expand into a full namespace, plus a classname string. Understanding
    how it is used, as well as how its use has been extended in PHP 8, can save you
    lots of time. Its use can also make your code much more readable, especially if
    you're dealing with lengthy namespaces and class names.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的`::class`常量是一个非常有用的构造，因为它可以悄悄地扩展为完整的命名空间加类名字符串。了解它的用法，以及它在PHP 8中的扩展用法，可以节省大量时间。它的使用也可以使你的代码更易读，特别是当你处理冗长的命名空间和类名时。
- en: The special `::class` constant is a combination of the **scope resolution operator**
    (`::`) and the `class` keyword. Unlike `::parent`, `::self`, and `::static`, however,
    the `::class` construct can be used outside a class definition. In a sense, the
    `::class` construct is a sort of *magic constant* in that it causes the class
    it's associated with to magically expand into its full namespace, plus class name.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的`::class`常量是**作用域解析操作符**(`::`)和`class`关键字的组合。然而，与`::parent`、`::self`和`::static`不同，`::class`构造可以在类定义之外使用。在某种意义上，`::class`构造是一种*魔术常量*，因为它会导致与其关联的类在编译时魔术般地扩展为完整的命名空间加类名。
- en: Before we get into how its use has been expanded in PHP 8, let's have a look
    at its conventional usage.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨它在PHP 8中的扩展使用之前，让我们先看看它的常规用法。
- en: Conventional ::class constant usage
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常规::class常量使用
- en: The special `::class` constant is frequently used in situations where you have
    a lengthy namespace and wish to not only save yourself a lot of unneeded typing,
    but also preserve the readability of your source code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的`::class`常量经常在你有一个冗长的命名空间并且希望不仅节省大量不必要的输入，而且保持源代码的可读性的情况下使用。
- en: 'In this simple example, using the `Php7\Image\Strategy` namespace, we wish
    to create a list of strategy classes:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，使用`Php7\Image\Strategy`命名空间，我们希望创建一个策略类的列表：
- en: 'First, let''s identify the namespace and set up the autoloader:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们确定命名空间并设置自动加载程序：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Before the special `::class` constant was introduced, to produce a list of
    full namespace class names, you had to write it all out as a string, as shown
    here:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在特殊的`::class`常量被引入之前，要生成完整命名空间类名的列表，你必须将其全部写成字符串，如下所示：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using the special `::class` constant, you can reduce the amount of typing required,
    and you can also make the code more readable, as shown here:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用特殊的`::class`常量，你可以减少所需的输入量，也可以使代码更易读，如下所示：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we run this code example, we''ll see that the two lists are identical in
    both PHP 7 and PHP 8\. Here''s the PHP 7 output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个代码示例，我们会看到两个列表在PHP 7和PHP 8中是相同的。这是PHP 7的输出：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, the special `::class` constant causes class names to be expanded
    into their full namespace, plus class name, at compile time, causing both lists
    to contain identical information.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，特殊的`::class`常量会导致类名在编译时扩展为完整的命名空间加类名，从而使两个列表包含相同的信息。
- en: Now, let's have a look at special `::class` constant usage in PHP 8.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看PHP 8中特殊的`::class`常量的用法。
- en: Expanded special ::class constant usage
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展特殊::class常量的使用
- en: In line with other improvements in syntax uniformity seen in PHP 8, it's now
    possible to use the special `::class` constant on active object instances. Although
    the effect is the same as using `get_class()`, it makes sense to use the special
    `::class` constant as part of the general best practice of moving away from procedural
    and toward OOP.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与PHP 8中看到的其他语法统一改进一致，现在可以在活动对象实例上使用特殊的`::class`常量。虽然效果与使用`get_class()`相同，但使用特殊的`::class`常量作为远离过程化向面向对象编程的一般最佳实践的一部分是有意义的。
- en: 'In this example, the extended `::class` syntax is used to determine the type
    of error that''s thrown:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，扩展的`::class`语法用于确定抛出的错误类型：
- en: 'When an `Error` or `Exception` is thrown, it''s best practice to make an entry
    in the error log. In this example, which works in both PHP 7 and PHP 8, the class
    name of this `Error` or `Exception` is included in the log message:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当抛出`Error`或`Exception`时，最佳实践是在错误日志中记录条目。在这个例子中，在PHP 7和PHP 8中都有效，这个`Error`或`Exception`的类名被包含在日志消息中：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In PHP 8, you can achieve the same result by rewriting the example, as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PHP 8中，您可以通过重新编写示例来实现相同的结果，如下所示：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see from the second block of code, the syntax is more concise and
    avoids the use of a procedural function. We must stress, however, that in this
    example, there is no performance gain.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从第二个代码块中可以看出，语法更加简洁，避免了使用过程函数。然而，我们必须强调，在这个例子中，并没有性能上的提升。
- en: Now that you are aware of changes in special `::class` constant usage, let's
    have a quick look at commas.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了特殊`::class`常量使用的变化，让我们快速看一下逗号。
- en: Taking advantage of trailing commas
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用尾随逗号
- en: 'PHP has long allowed the use of trailing commas when defining arrays. For example,
    the syntax shown here is not uncommon:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，PHP允许在定义数组时使用尾随逗号。例如，下面显示的语法并不罕见：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'However, doing the same thing in a function or method signature is not allowed:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在函数或方法签名中做同样的事情是不允许的：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Although it's not really such a big deal, it's annoying to be able to add a
    trailing comma when defining an array, but not be allowed the same liberty when
    it comes to function or method signatures!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不是什么大不了的事，但在定义数组时能够添加尾随逗号，但在函数或方法签名中却不允许同样的自由，这是令人恼火的！
- en: PHP 8 now allows you to use trailing commas in both function and method signatures.
    The new rule also applies to `use()` statements associated with anonymous functions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8现在允许您在函数和方法签名中都使用尾随逗号。新规则也适用于与匿名函数相关的`use()`语句。
- en: 'To illustrate this change, consider the following example. In this example,
    an anonymous function is defined that renders a full name:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这种变化，考虑以下例子。在这个例子中，定义了一个匿名函数来渲染一个全名：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, there''s a comma following the third argument to the anonymous
    function. Here is the output from PHP 7:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，匿名函数的第三个参数后面有一个逗号。以下是PHP 7的输出：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In PHP 8, the trailing comma is allowed and the expected output appears, as
    shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，允许使用尾随逗号，并且预期的输出如下所示：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Although having a trailing comma in function or method definitions is not necessarily
    a best practice, it does make PHP 8 consistent in its overall treatment of trailing
    commas.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在函数或方法定义中使用尾随逗号不一定是最佳实践，但它确实使PHP 8在对待尾随逗号的整体处理上保持一致。
- en: Now, let's turn our attention to methods that still exist but no longer have
    any use.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把注意力转向仍然存在但不再有任何用处的方法。
- en: Learning about methods that are no longer required
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习不再需要的方法
- en: Primarily as a result of the PHP 8 resource-to-object migration, a number of
    functions and methods are no longer required. They are not deprecated at the time
    of writing, but these functions no longer serve any practical use.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 主要是由于PHP 8资源到对象的迁移，许多函数和方法不再需要。在撰写本文时，它们并没有被弃用，但这些函数不再具有任何实际用途。
- en: As an analogy, in versions of PHP before PHP 8, you would use `fopen()` to open
    a file handle resource. Once you had finished working on the file, you would normally
    use `fclose()` on the file handle resource to close the connection.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 类比一下，在PHP 8之前的版本中，您会使用`fopen()`来打开一个文件句柄资源。完成文件操作后，您通常会使用`fclose()`关闭文件句柄资源的连接。
- en: Now, let's assume that you are using `SplFileObject` instead of `fopen()`. When
    the work with the file has been completed, you can simply unset the object. This
    accomplishes the same thing as using `fclose()`, making `fclose()` redundant.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您使用`SplFileObject`而不是`fopen()`。当文件操作完成后，您可以简单地取消对象。这与使用`fclose()`达到了相同的效果，使`fclose()`变得多余。
- en: 'The following table summarizes functions that exist, and can still be used,
    but no longer have any practical value in PHP 8\. The ones marked with an asterisk
    are also deprecated:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了存在但在PHP 8中不再具有任何实际价值的函数。带有星号标记的函数也已被弃用：
- en: '![Table 9.1 – Functions that are no longer useful'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![表9.1 - 不再有用的函数'
- en: '](image/Figure_9.1_B16992.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.1_B16992.jpg)'
- en: Table 9.1 – Functions that are no longer useful
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1 - 不再有用的函数
- en: Now that you have an idea of what major method signature and usage changes have
    been made in PHP 8, let's have a look at the best practices to take into consideration
    when working with interfaces and traits.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了PHP 8中主要方法签名和用法的变化，让我们来看看在使用接口和特征时需要考虑的最佳实践。
- en: Working with interfaces and traits
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用接口和特征
- en: The PHP 8 trait implementation has been expanded in several ways. There are
    also several new interfaces that can potentially alter how you work with the DOM
    and DateTime extensions. For the most part, the changes improve the abilities
    of these two extensions. However, as method signatures have changed in some cases,
    you may run into a potential code break. Due to this, it's important to pay close
    attention to the discussion presented in this section to ensure that existing
    and future PHP code remains functional.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8特性实现在几个方面得到了扩展。还有一些新的接口可能会改变您使用DOM和DateTime扩展的方式。在大多数情况下，这些变化提高了这两个扩展的功能。然而，由于某些情况下方法签名已经改变，可能会出现潜在的代码中断。因此，重要的是要密切关注本节中提出的讨论，以确保现有和未来的PHP代码保持功能正常。
- en: First, let's have a look at the new DOM extension interfaces.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看看新的DOM扩展接口。
- en: Discovering new DOM extension interfaces
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现新的DOM扩展接口
- en: The *cost of living* economic statistic is issued each year by many world governments.
    It depicts how much it costs an average citizen to live year by year. As web technology
    matures, a similar principal has been applied – first to HTML, and now to DOM.
    The **DOM Living Standard** is maintained by the **Web Hypertext Application Technology
    Working Group** (**WHATWG**) ([https://whatwg.org/](https://whatwg.org/)).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*生活成本*经济统计数据每年由许多世界政府发布。它描述了一个普通公民每年生活的成本。随着网络技术的成熟，类似的原则已被应用 - 首先是HTML，现在是DOM。**DOM
    Living Standard**由**Web Hypertext Application Technology Working Group**（**WHATWG**）维护（[https://whatwg.org/](https://whatwg.org/)）。'
- en: The reason why this information is important to PHP developers is that in PHP
    8, the decision was made to move the PHP DOM extension to the DOM Living Standard.
    Accordingly, starting with PHP 8, a series of incremental and continuous changes
    will be applied to this extension in accordance with changes to the living standard.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息对PHP开发人员重要的原因是，在PHP 8中，决定将PHP DOM扩展移动到DOM Living Standard。因此，从PHP 8开始，将根据最新标准的变化对这个扩展进行一系列增量和持续的更改。
- en: For the most part, the changes are backward compatible. However, since some
    method signatures change to maintain adherence to the standard, you may experience
    code breaks. The most significant change to the DOM extension in PHP 8 is the
    introduction of two new interfaces. Let's examine these interfaces, and then discuss
    their impact on PHP development.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在很大程度上，这些变化是向后兼容的。然而，由于一些方法签名的变化以保持符合标准，可能会导致代码中断。在PHP 8中对DOM扩展最重要的变化是引入了两个新接口。让我们来检查这些接口，然后讨论它们对PHP开发的影响。
- en: Examining the new DOMParentNode interface
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查新的DOMParentNode接口
- en: 'The first of the two new interfaces is **DOMParentNode**. The following classes
    implement this interface in PHP 8:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 两个新接口中的第一个是**DOMParentNode**。以下类在PHP 8中实现了这个接口：
- en: '`DOMDocument`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOMDocument`'
- en: '`DOMElement`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOMElement`'
- en: '`DOMDocumentFragment`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOMDocumentFragment`'
- en: 'Here is the interface definition:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是接口定义：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It's important to note that there is no *readonly* attribute available to PHP
    developers. However, the interface specification shows the properties as read
    only because they are internally generated and cannot be changed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，对于PHP开发人员来说，没有*readonly*属性可用。然而，接口规范将属性显示为只读，因为它们是内部生成的，不能被更改。
- en: Tip
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: There actually was a PHP RFC that was introduced in 2014 that proposed adding
    a *readonly* attribute to class properties. This proposal was withdrawn, however,
    as the same effect can be achieved by defining a constant or simply marking a
    property `private`! For more information on this proposal, see [https://wiki.php.net/rfc/readonly_properties](https://wiki.php.net/rfc/readonly_properties).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，2014年曾提出了一个PHP RFC，建议为类属性添加*readonly*属性。然而，这个提案被撤回，因为可以通过定义常量或简单地将属性标记为`private`来实现相同的效果！有关此提案的更多信息，请参见[https://wiki.php.net/rfc/readonly_properties](https://wiki.php.net/rfc/readonly_properties)。
- en: 'The following table summarizes the properties and methods of the new `DOMParentNode`
    interface:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表总结了新的`DOMParentNode`接口的属性和方法：
- en: '![Table 9.2 – DOMParentNode interface methods and properties'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![表9.2 – DOMParentNode接口方法和属性'
- en: '](image/Figure_9.2_B16992.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.2_B16992.jpg)'
- en: Table 9.2 – DOMParentNode interface methods and properties
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.2 – DOMParentNode接口方法和属性
- en: The functionality represented by the new interface doesn't add anything new
    to the existing DOM capabilities. Its main purpose is to bring the PHP DOM extension
    in line with the living standard.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 新接口所代表的功能并没有为现有的DOM功能增加任何新内容。它的主要目的是使PHP DOM扩展符合最新的标准。
- en: Tip
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'There is another purpose for architecturally renovating the DOM extension in
    the future. In future versions of PHP, the DOM extension will have the capability
    of manipulating an entire branch of the DOM tree. When you issue an `append()`,
    for example, in the future, you will be able to append not only the one node,
    but all its child nodes as well. For more information, see the following RFC:
    [https://wiki.php.net/rfc/dom_living_standard_api](https://wiki.php.net/rfc/dom_living_standard_api).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将来，对DOM扩展进行架构上的改造还有另一个目的。在未来的PHP版本中，DOM扩展将有能力操作整个DOM树的一个分支。例如，在未来，当你发出`append()`时，你将能够附加不仅仅是一个节点，还有它的所有子节点。有关更多信息，请参见以下RFC：[https://wiki.php.net/rfc/dom_living_standard_api](https://wiki.php.net/rfc/dom_living_standard_api)。
- en: Now, let's have a look at the second new interface.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看第二个新接口。
- en: Examining the new DOMChildNode interface
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查新的DOMChildNode接口
- en: The second of the two new interfaces is **DOMChildNode**. The `DOMElement` and
    `DOMCharacterData` classes implement this interface in PHP 8.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 两个新接口中的第二个是**DOMChildNode**。`DOMElement`和`DOMCharacterData`类在PHP 8中实现了这个接口。
- en: 'Here is the interface definition:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是接口定义：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following table summarizes the methods and properties of `DOMChildNode`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表总结了`DOMChildNode`的方法和属性：
- en: '![Table 9.3 – DOMChildNode interface methods and properties'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![表9.3 – DOMChildNode接口方法和属性'
- en: '](image/Figure_9.3_B16992.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.3_B16992.jpg)'
- en: Table 9.3 – DOMChildNode interface methods and properties
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.3 – DOMChildNode接口方法和属性
- en: 'In this case, the functionality departs slightly from the existing DOM capabilities.
    The most significant departure is `DOMChildNode::remove()`. Before PHP 8, to remove
    a node, you had to access its parent. Assuming that `$topic` is a `DOMElement`
    instance, PHP 7 or earlier code may appear as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，功能与现有的DOM功能略有不同。最重要的变化是`DOMChildNode::remove()`。在PHP 8之前，要删除一个节点，你必须访问它的父节点。假设`$topic`是一个`DOMElement`实例，PHP
    7或更早的代码可能如下所示：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In PHP 8, the same code can be written as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，相同的代码可以写成如下形式：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Aside from the new methods mentioned in the two tables shown previously, DOM
    functionality remains the same. Now, let's have a look at how moving a child node
    might be rewritten in PHP 8 to take advantage of the new interfaces.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面显示的两个表中提到的新方法之外，DOM功能保持不变。现在，让我们看看如何在PHP 8中重写移动子节点以利用新接口。
- en: DOM usage example – comparing PHP 7 and PHP 8
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DOM使用示例 – 比较PHP 7和PHP 8
- en: 'To illustrate the use of the new interfaces, let''s have a look at a code example.
    In this section, we will present a block of code that uses the DOM extension to
    move a node that represents `Topic X` from one document to another:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明新接口的使用，让我们看一个代码示例。在本节中，我们将呈现一段使用DOM扩展来将代表`Topic X`的节点从一个文档移动到另一个文档的代码块：
- en: 'Here is an HTML fragment that contains a set of nested `<div>` tags:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个包含一组嵌套的`<div>`标签的HTML片段：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The second HTML fragment includes topics D, E, and F:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个HTML片段包括主题D、E和F：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To create `DOMDocument` instances from each of the two fragments, we can make
    a static call; that is, `loadHTMLFile`. Note that this usage is deprecated in
    PHP 7 and has been removed in PHP 8:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这两个片段中创建`DOMDocument`实例，我们可以进行静态调用；也就是`loadHTMLFile`。请注意，这种用法在PHP 7中已经被弃用，并在PHP
    8中被移除了。
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we can extract `Topic X` into `$topic` and import it into the second
    document as `$new`. Next, retrieve the target node; that is, `content`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以将`Topic X`提取到`$topic`中，并将其导入到第二个文档中作为`$new`。接下来，检索目标节点；也就是`content`：
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here is where PHP 7 and PHP 8 start to differ. In PHP 7, to move the node,
    the code must be as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是PHP 7和PHP 8开始有所不同的地方。在PHP 7中，要移动节点，代码必须如下所示：
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'However, in PHP 8, when using the new interfaces, the code has more of an compact.
    To remove the topic in PHP 8, there''s no need to reference the parent node:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，在PHP 8中，当使用新接口时，代码更加紧凑。在PHP 8中，不需要引用父节点来移除主题。
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For both PHP 7 and PHP 8, we can view the resulting HTML like so:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于PHP 7和PHP 8，我们可以这样查看生成的HTML：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Another difference is how to extract the value of the new last child element
    of `$main`. Here''s how it might appear in PHP 7:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个不同之处是如何提取`$main`的新最后一个子元素的值。在PHP 7中可能如下所示：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And here is the same thing in PHP 8:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PHP 8中也是一样的：
- en: '[PRE49]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'There are slight differences in the output for both code examples. In PHP 7,
    you will see a deprecation notice, as shown here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个代码示例的输出略有不同。在PHP 7中，您将看到一个弃用通知，如下所示：
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we try to run the PHP 7 code in PHP 8, a fatal `Error` will be thrown as
    the `loadHTMLFile()` method''s static usage is no longer allowed. Otherwise, if
    we run the pure PHP 8 example, the output will appear as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在PHP 8中运行PHP 7代码，将会抛出致命的`Error`，因为`loadHTMLFile()`方法的静态使用不再被允许。否则，如果我们运行纯PHP
    8示例，输出将如下所示：
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see, in either case, `Topic X` was moved from the first and into
    the second HTML fragment.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在任何情况下，`Topic X`都从第一个HTML片段移动到了第二个片段中。
- en: In future versions of PHP, expect the DOM extension to continue to grow while
    following the living standard for DOM. Also, its usage continues to get easier,
    with more flexibility and efficiency being provided.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的PHP版本中，预计DOM扩展将继续增长，同时遵循DOM的生存标准。此外，它的使用将变得更加容易，提供更多的灵活性和效率。
- en: Now, let's turn our attention to changes in the `DateTime` extension.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注`DateTime`扩展中的变化。
- en: Using new DateTime methods
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用新的DateTime方法
- en: When working with date and time, it's often useful to create `DateTimeImmutable`
    instances. `DateTimeImmutable` objects are the same as `DateTime` objects, except
    that their property values cannot be altered. Knowing how to switch back and forth
    between `DateTime` and `DateTimeImmutable` is a useful technique and can save
    you from many hidden logic errors.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理日期和时间时，通常很有用创建`DateTimeImmutable`实例。`DateTimeImmutable`对象与`DateTime`对象相同，只是它们的属性值不能被改变。知道如何在`DateTime`和`DateTimeImmutable`之间来回切换是一种有用的技巧，可以避免许多隐藏的逻辑错误。
- en: Before we discuss the improvements that were made in PHP 8, let's have a look
    at the potential problem that `DateTimeImmutable` solves.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论PHP 8中的改进之前，让我们先看看`DateTimeImmutable`解决的潜在问题。
- en: Use case for DateTimeImmutable
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DateTimeImmutable的用例
- en: 'In this simple example, an array of three instances will be created representing
    30, 60, and 90 days from today. These will be used to form the basis of a 30-60-90-day
    accounts receivable aging report:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，将创建一个包含今天之后30、60和90天的三个实例的数组。这些将被用来形成一个30-60-90天应收账款老化报告的基础。
- en: 'First, let''s initialize a few key variables that represent the interval, date
    format, and array to hold the final values:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们初始化一些代表间隔、日期格式和保存最终值的数组的关键变量：
- en: '[PRE52]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, let's define a loop that adds the intervals to a `DateTime` instance to
    produce (hopefully!) an array representing days 0, 30, 60, and 90\. Veteran developers
    have most likely already spotted the problem!
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个循环，将间隔添加到`DateTime`实例中，以产生（希望如此！）表示0、30、60和90天的数组。经验丰富的开发人员很可能已经发现了问题！
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, display the set of dates that have been produced:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，显示已生成的日期集合：
- en: '[PRE54]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output, which is a complete disaster, is shown here:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里显示的输出是一场完全的灾难：
- en: '[PRE55]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As you can see, the problem is that the `DateTime` class is not immutable. Thus,
    every time we add a `DateInterval`, the original value is altered, resulting in
    the inaccurate dates shown.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，问题在于`DateTime`类不是不可变的。因此，每次添加`DateInterval`时，原始值都会被改变，导致显示的日期不准确。
- en: 'By making one simple alteration, however, we can correct this problem. Instead
    of originally creating a `DateTime` instance, all we need to do is create a `DateTimeImmutable`
    instance instead:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，通过进行一个简单的改变，我们可以解决这个问题。我们只需要创建一个`DateTimeImmutable`实例，而不是最初创建一个`DateTime`实例：
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To populate the array with `DateTime` instances, however, we need to convert
    from `DateTimeImmutable` into `DateTime`. In PHP 7.3, the `DateTime::createFromImmutable()`
    method was introduced. Accordingly, when the value is assigned to `$aging`, the
    revised code might appear as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，要用`DateTime`实例填充数组，我们需要将`DateTimeImmutable`转换为`DateTime`。在PHP 7.3中，引入了`DateTime::createFromImmutable()`方法。因此，当值被赋给`$aging`时，修改后的代码可能如下所示：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Otherwise, you''re stuck with creating a new `DateTime` instance, as shown
    here:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，您将被困在创建一个新的`DateTime`实例中，如下所示：
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'With this one change, the correct output will look as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一个改变，正确的输出将如下所示：
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You now know how `DateTimeImmutable` might be used, and you also have an idea
    of how to convert into `DateTime`. You'll be pleased to know that in PHP 8, the
    conversion between the two object types has been made much easier with the introduction
    of the `createFromInterface()` method.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了`DateTimeImmutable`可能如何被使用，也知道了如何转换成`DateTime`。你会高兴地知道，在PHP 8中，通过引入`createFromInterface()`方法，这两种对象类型之间的转换变得更加容易了。
- en: Examining the createFromInterface() method
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查createFromInterface()方法
- en: In PHP 8, it's much easier to convert between `DateTime` and `DateTimeImmutable`,
    and back again. A new method called `createFromInterface()` has been added to
    both classes. The method signature simply calls for a `DateTimeInterface` instance,
    which means that instances of either `DateTime` or `DateTimeImmutable` are acceptable
    arguments for this method.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 8 中，转换 `DateTime` 和 `DateTimeImmutable` 之间变得更加容易。两个类都添加了一个名为 `createFromInterface()`
    的新方法。该方法的签名只是要求一个 `DateTimeInterface` 实例，这意味着 `DateTime` 或 `DateTimeImmutable`
    的实例都是这个方法的可接受参数。
- en: 'The following brief code example demonstrates how easy it is to convert from
    one type into another in PHP 8:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简短的代码示例演示了在 PHP 8 中将一个类型转换为另一个类型是多么容易：
- en: 'First, let''s define a `DateTimeImmutable` instance and `echo` its class and
    date:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，定义一个 `DateTimeImmutable` 实例并 `echo` 其类和日期：
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, create a `DateTime` instance from `$dti` and add an interval of 90 days,
    displaying its class and current date:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从 `$dti` 创建一个 `DateTime` 实例，并添加 90 天的间隔，显示其类和当前日期：
- en: '[PRE61]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, create a `DateTimeImmutable` instance from `$dtt` and display its
    class and date:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从 `$dtt` 创建一个 `DateTimeImmutable` 实例并显示其类和日期：
- en: '[PRE62]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here is the output of this code example, running in PHP 8:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 PHP 8 中运行此代码示例的输出：
- en: '[PRE63]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As you can see, we used the same `createFromInterface()` method to create instances.
    Bear in mind, of course, that we are not actually *converting* the class instance
    into another. Instead, we are creating cloned instances, but of a different class
    type.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用相同的 `createFromInterface()` 方法来创建实例。当然，请记住，我们实际上并没有将类实例*转换*为另一个类实例。相反，我们创建了克隆实例，但是属于不同的类类型。
- en: You now know why you may want `DateTimeImmutable` instead of `DateTime`. You
    also know that in PHP 8, a new method called `createFromInterface()` provides
    a uniform way to create instances of one from the other. Next, we'll have a look
    at how handling traits has been refined in PHP 8.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在知道为什么您可能希望使用 `DateTimeImmutable` 而不是 `DateTime`。您还知道在 PHP 8 中，一个名为 `createFromInterface()`
    的新方法提供了一种统一的方式来创建一个类的实例。接下来，我们将看一下在 PHP 8 中如何改进 traits 的处理方式。
- en: Understanding PHP 8 trait handling refinements
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 PHP 8 中 traits 处理的改进
- en: The implementation of **traits** was first introduced in PHP version 5.4\. Since
    that time, a continuous stream of refinements has been made. PHP 8 continues that
    trend by providing a means to clearly identify which methods are used when multiple
    traits have conflicting methods. Also, in addition to removing inconsistencies
    in visibility declarations, PHP 8 irons out problems in how traits handled (or
    did not handle!) abstract methods.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**Traits** 的实现首次出现在 PHP 版本 5.4 中。从那时起，不断进行了一系列的改进。PHP 8 继续这一趋势，通过提供一种明确识别多个
    traits 具有冲突方法的方法来清楚地标识使用哪些方法。此外，除了消除可见性声明中的不一致性之外，PHP 8 还解决了 traits 处理（或未处理！）抽象方法的问题。'
- en: As a developer, having a complete mastery of the use of traits enables you to
    write code that is both more efficient and easier to maintain. Traits can help
    you avoid producing redundant code. They solve the problem of needing the same
    logic available across namespaces, or across different class inheritance structures.
    The information presented in this section enables you to make proper use of traits
    in code running under PHP 8.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，完全掌握 traits 的使用能力使您能够编写更高效、更易于维护的代码。Traits 可以帮助您避免生成冗余的代码。它们解决了需要在命名空间之间或不同类继承结构之间使用相同逻辑的问题。本节中提供的信息使您能够在
    PHP 8 下正确使用 traits。
- en: First, let's examine how conflicts between traits are resolved in PHP 8.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 PHP 8 中如何解决 traits 之间的冲突。
- en: Resolving method conflicts between traits
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决 traits 之间的方法冲突
- en: 'Multiple traits can be used by simply listing the trait names separated by
    commas. A potential problem can arise, however, if two traits define the same
    method. To resolve such conflicts, PHP offers the `as` keyword. In PHP 7 and below,
    to avoid a conflict between two methods of the same name, you could simply rename
    one of the methods. The code to perform the renaming might appear as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 多个 traits 可以通过简单地用逗号分隔的 trait 名称列表来使用。然而，可能会出现一个问题，如果两个 traits 定义了相同的方法。为了解决这种冲突，PHP
    提供了 `as` 关键字。在 PHP 7 及更低版本中，为了避免两个同名方法之间的冲突，您可以简单地重命名其中一个方法。执行重命名的代码可能如下所示：
- en: '[PRE64]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The problem with this approach, however, is that PHP is making a silent assumption:
    `METHOD` is assumed to come from `Trait1`! In its continuing efforts to enforce
    good coding practices, PHP 8 no longer allows this assumption. The solution in
    PHP 8 is to be more specific by using `insteadof` rather than `as`.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法的问题在于，PHP 做出了一个悄悄的假设：`METHOD` 被假定来自 `Trait1`！为了继续执行良好的编码实践，PHP 8 不再允许这种假设。在
    PHP 8 中的解决方案是更具体地使用 `insteadof` 而不是 `as`。
- en: 'Here is a trivial example that illustrates this problem:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是说明这个问题的一个微不足道的例子：
- en: 'First, let''s define two traits that define the same method, `test()`, but
    return a different result:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们定义两个定义相同方法 `test()` 的 traits，但返回不同的结果：
- en: '[PRE65]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, define an anonymous class that uses both traits and specifies `test()`
    as `otherTest()` to avoid a naming collision:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个匿名类，使用两个 traits 并将 `test()` 指定为 `otherTest()` 以避免命名冲突：
- en: '[PRE66]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, define a block of code to `echo` the return value of both methods:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个代码块来 `echo` 两个方法的返回值：
- en: '[PRE67]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Here is the output in PHP 7:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 PHP 7 中的输出：
- en: '[PRE68]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As you can see, PHP 7 silently assumes that we mean to rename `Trait1::test()`
    as `otherTest()`. From the example code, however, it's not at all clear that this
    is the programmer's intention!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，PHP 7 默默地假设我们的意思是将 `Trait1::test()` 重命名为 `otherTest()`。然而，从示例代码中，程序员的意图并不清楚！
- en: 'Running the same code example in PHP 8, we get a different result:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 8 中运行相同的代码示例，我们得到了不同的结果：
- en: '[PRE69]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Clearly, PHP 8 does not make such silent assumptions as they can easily lead
    to unexpected behavior. In this example, the best practice would be to use the
    scope resolution (`::`) operator. Here is the rewritten code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，PHP 8 不会做出这样的悄悄假设，因为它们很容易导致意外行为。在这个例子中，最佳实践是使用作用域解析 (`::`) 运算符。以下是重写后的代码：
- en: '[PRE70]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If we were to rerun the code in PHP 8, the output would be the same as the output
    shown for PHP 7\. The scope resolution operator affirms that `Trait1` is the source
    trait for the `test()` method, thus avoiding any ambiguity. Now, let's have a
    look at how PHP 8 traits handle abstract method signatures.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在PHP 8中重新运行代码，输出将与PHP 7中显示的输出相同。作用域解析运算符确认`Trait1`是`test()`方法的源trait，从而避免了任何歧义。现在，让我们看看PHP
    8 traits如何处理抽象方法签名。
- en: Working with trait abstract signature checking
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理trait抽象签名检查
- en: As API developers are well aware, marking a method as `abstract` is how you
    can signal to API users that a method is mandatory, but has yet to be defined.
    This technique allows the API developer to dictate not only the method name, but
    its signature as well.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 正如API开发人员所知，将方法标记为`abstract`是向API用户发出方法是必需的信号，但尚未定义。这种技术允许API开发人员不仅规定方法名称，还规定其签名。
- en: In PHP 7 and below, however, abstract methods defined in a trait ignored the
    signature, defeating part of the purpose of using an abstract method in the first
    place! When you use a trait with an abstract method in PHP 8, its signature is
    checked against the implementation in the class using the trait.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PHP 7及更低版本中，在trait中定义的抽象方法会忽略签名，从而打败了使用抽象方法的初衷的一部分！当您在PHP 8中使用带有抽象方法的trait时，其签名将与使用该trait的类中的实现进行检查。
- en: 'The following example works in PHP 7 but fails in PHP 8 as the method signature
    is different:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在PHP 7中有效，但在PHP 8中失败，因为方法签名不同：
- en: 'First, let''s declare strict type checking and define a trait with an abstract
    method; that is, `add()`. Note the method signature calls for integer data types
    all around:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们声明严格类型检查并定义一个带有抽象方法`add()`的trait。请注意，方法签名要求所有数据类型都是整数：
- en: '[PRE71]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, define an anonymous class that uses the trait and defines `add()`. Note
    that the data types for the class are `float` all around:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个使用trait并定义`add()`的匿名类。请注意，类的数据类型都是`float`。
- en: '[PRE72]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then, echo the results of adding `111.111` and `222.222`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，输出添加`111.111`和`222.222`的结果：
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The results of this small code example running in PHP 7 are surprising:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中运行的这个小代码示例的结果令人惊讶：
- en: '[PRE74]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'As you can see from the results, the method signature of the abstract definition
    in the trait is completely ignored! In PHP 8, however, the outcome is much different.
    Here is the code''s output running in PHP 8:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中可以看出，在trait中抽象定义的方法签名完全被忽略了！然而，在PHP 8中，结果大不相同。以下是在PHP 8中运行代码的输出：
- en: '[PRE75]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The preceding PHP 8 output shows us that good coding practices are enforced,
    regardless of the source of the abstract method definition.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的PHP 8输出向我们展示了良好的编码实践是如何被强制执行的，无论抽象方法定义的来源如何。
- en: The last topic in this section will show you how to handle abstract private
    methods in traits.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的最后一个主题将向您展示如何处理trait中的抽象私有方法。
- en: Handling private abstract methods in traits
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理trait中的私有抽象方法
- en: Generally, in PHP, you can't enforce control over an **abstract private method**
    in an abstract super class as it will not be inherited. In PHP 8, however, you
    can define an abstract private method in a trait! This can be used as a use-of-code
    enforcement mechanism when you're doing API development where the `using` class
    is required to define a specified private method.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在PHP中，您无法对抽象私有方法在抽象超类中施加控制，因为它不会被继承。然而，在PHP 8中，您可以在trait中定义一个抽象私有方法！当您进行API开发时，这可以用作代码执行机制，其中`using`类需要定义指定的私有方法。
- en: Please note that although you can designate an abstract method as private in
    a PHP 8 trait, trait method visibility can easily be overridden in the class that
    uses the trait. Accordingly, we will not show any code examples in this section
    as the effect of a private abstract trait method is exactly the same as using
    an abstract trait method at other visibility levels.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管您可以在PHP 8 trait中将抽象方法指定为私有，但trait方法的可见性可以很容易地在使用trait的类中被覆盖。因此，在本节中我们不会展示任何代码示例，因为私有抽象trait方法的效果与在其他可见性级别使用抽象trait方法完全相同。
- en: Tip
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on trait abstract method handling in PHP 8, have a look
    at this RFC: [https://wiki.php.net/rfc/abstract_trait_method_validation](https://wiki.php.net/rfc/abstract_trait_method_validation).'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PHP 8中处理trait抽象方法的更多信息，请查看此RFC：[https://wiki.php.net/rfc/abstract_trait_method_validation](https://wiki.php.net/rfc/abstract_trait_method_validation)。
- en: Now, let's have a look at general usage changes in private methods.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看私有方法的一般用法变化。
- en: Dealing with private methods
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理私有方法
- en: One of the reasons why developers create a super class is to exert a certain
    degree of control over the method signatures of subclasses. During the parsing
    phase, PHP normally confirms that the method signatures match. This leads to proper
    use of your code by other developers.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员创建超类的原因之一是对子类的方法签名施加一定程度的控制。在解析阶段，PHP通常会确认方法签名是否匹配。这导致其他开发人员正确使用您的代码。
- en: In the same vein, it does not make sense to have PHP perform the same rigorous
    method signature check if a method is marked as `private`. The purpose of a private
    method is that it is invisible to the extending class. If you define a method
    of the same name in the extending class, you should be free to define it at will.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，如果将方法标记为`private`，让PHP执行同样严格的方法签名检查是没有意义的。私有方法的目的是对扩展类不可见。如果您在扩展类中定义了同名方法，您应该可以自由定义它。
- en: 'To illustrate this problem, let''s define a class called `Cipher` with a private
    method called `encrypt()`. The `OpenCipher` subclass redefines this method, causing
    a fatal error when running under PHP 7:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个问题，让我们定义一个名为`Cipher`的类，其中包含一个名为`encrypt()`的私有方法。`OpenCipher`子类重新定义了这个方法，在PHP
    7下运行时会导致致命错误：
- en: 'First, let''s define a `Cipher` class whose constructor generates random values
    for `$key` and `$salt`. It also defines a public method called `encode()` that
    makes a call to the private `encrypt()` method:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个`Cipher`类，其构造函数为`$key`和`$salt`生成随机值。它还定义了一个名为`encode()`的公共方法，该方法调用了私有的`encrypt()`方法：
- en: '[PRE76]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, let''s define a private method called `encrypt()` that produces encrypted
    text using `str_rot13()`. Note that the method is marked as `final`. Although
    this does not make any sense, for the purposes of this illustration, assume that
    this is intended:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义一个名为`encrypt()`的私有方法，该方法使用`str_rot13()`生成加密文本。请注意，该方法标记为`final`。尽管这没有任何意义，但为了说明这一点，请假设这是有意的：
- en: '[PRE77]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Finally, let''s define a brief calling program that creates class instances
    and calls the methods that have been defined:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们定义一个简短的调用程序，创建类实例并调用已定义的方法：
- en: '[PRE78]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'If we run the calling program in PHP 7, we''ll get the following output:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在PHP 7中运行调用程序，将得到以下输出：
- en: '[PRE79]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here, you can see that the output from `Cipher` was correctly produced. However,
    a fatal `Error` has been thrown, along with a message stating that we are unable
    to override a `final` method. Theoretically, a private method should be completely
    invisible to the subclass. However, as you can clearly see from the output, this
    is not the case. The method signature of a private method of the `Cipher` superclass
    affects our ability to redefine the same method in the subclass.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到`Cipher`的输出已正确生成。但是，还抛出了一个致命的`Error`，并附带一条消息，说明我们无法覆盖`final`方法。理论上，私有方法应该对子类完全不可见。但是，从输出中可以清楚地看到，情况并非如此。`Cipher`超类的私有方法签名影响了我们在子类中重新定义相同方法的能力。
- en: 'In PHP 8, however, this paradox has been resolved. Here is the output of the
    same code running in PHP 8:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PHP 8中，这个悖论已经得到解决。以下是在PHP 8中运行相同代码的输出：
- en: '[PRE80]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: As you can see from the preceding output, the application succeeded, and output
    from both the parent and child classes is being displayed. We can also see a `Warning`,
    informing us that the private methods cannot be marked as `final`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看到，应用程序成功，并且父类和子类的输出都显示出来。我们还可以看到一个`Warning`，告诉我们私有方法不能标记为`final`。
- en: Tip
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on the background discussion on private method signatures,
    have a look at this documentation reference:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 有关私有方法签名的背景讨论的更多信息，请参阅此文档参考：
- en: '[https://wiki.php.net/rfc/inheritance_private_methods](https://wiki.php.net/rfc/inheritance_private_methods).'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.php.net/rfc/inheritance_private_methods](https://wiki.php.net/rfc/inheritance_private_methods)。'
- en: Now that you have an idea of how PHP 8 prevents subclasses from seeing private
    methods in the superclass, let's turn our attention to differences in anonymous
    classes in PHP 8.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了PHP 8如何阻止子类看到超类中的私有方法，让我们将注意力转向PHP 8中匿名类的差异。
- en: Controlling anonymous class usage
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制匿名类的使用
- en: '**Anonymous classes**, by their very definition, do not have a name. However,
    for the purposes of information, PHP informational functions such as `var_dump()`,
    `var_export()`, `get_class()`, and other classes in the Reflection extension will
    report the anonymous class simply as `class@anonymous`. However, when an anonymous
    class extends another class or implements an interface, it might be of some use
    to have PHP informational functions reflect this fact.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**匿名类**根据其定义，没有名称。但是，为了提供信息，PHP信息函数（如`var_dump()`，`var_export()`，`get_class()`和Reflection扩展中的其他类）将匿名类简单地报告为`class@anonymous`。但是，当匿名类扩展另一个类或实现接口时，让PHP信息函数反映这一事实可能会有所用处。'
- en: 'In PHP 8, anonymous classes that extend a class or implement an interface now
    reflect that fact by changing the label that''s assigned to the anonymous class
    to `Xyz@anonymous`, where `Xyz` is the name of the class or interface. If the
    anonymous class implements more than one interface, only the first interface will
    appear. If the anonymous class extends a class and also implements one or more
    interfaces, the name of the class it extends will appear in its label. The following
    table summarizes these possibilities:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，扩展类或实现接口的匿名类现在通过更改分配给匿名类的标签来反映这一事实，标签为`Xyz@anonymous`，其中`Xyz`是类或接口的名称。如果匿名类实现多个接口，则只会显示第一个接口。如果匿名类扩展了一个类并且还实现了一个或多个接口，则其标签中将显示扩展的类的名称。以下表格总结了这些可能性：
- en: '![Table 9.4 – Anonymous class promotion'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '![表9.4 - 匿名类提升'
- en: '](image/Figure_9.4_B16992.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.4_B16992.jpg)'
- en: Table 9.4 – Anonymous class promotion
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.4 - 匿名类提升
- en: 'Bear in mind that PHP can already test the anonymous class to see if it falls
    under a certain line of inheritance. The `instanceof` operator, for example, can
    be used for this purpose. The following example illustrates how to test the anonymous
    class for inheritance, as well as how to view its new name:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，PHP已经可以测试匿名类是否属于某一继承线。例如，`instanceof`运算符可以用于此目的。以下示例说明了如何测试匿名类的继承关系，以及如何查看其新名称：
- en: 'For this example, we will define a `DirectoryIterator` instance that grabs
    a list of files from the current directory:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将定义一个`DirectoryIterator`实例，从当前目录中获取文件列表：
- en: '[PRE81]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then, we will define an anonymous class that extends `FilterIterator`. In this
    class, we will define the `accept()` method, which produces a Boolean result.
    If the result is `TRUE`, then that item will appear in the final iteration:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将定义一个匿名类，该类扩展了`FilterIterator`。在这个类中，我们将定义`accept()`方法，该方法产生布尔结果。如果结果为`TRUE`，则该项将出现在最终迭代中：
- en: '[PRE82]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Next, we will produce a list of files that contain `bc_break` in their name:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将生成一个包含名称中包含`bc_break`的文件列表：
- en: '[PRE83]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In the next two lines, we will use `instanceof` to test whether the anonymous
    class implements `OuterIterface`:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的两行中，我们将使用`instanceof`来测试匿名类是否实现了`OuterIterface`：
- en: '[PRE84]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Finally, we will simply dump the contents of the anonymous class using `var_dump()`:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用`var_dump()`简单地转储匿名类的内容：
- en: '[PRE85]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here is the output running under PHP 8\. We cannot run this example in PHP 7
    as that version lacks the `str_contains()` function!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在PHP 8下运行的输出。我们无法在PHP 7中运行此示例，因为该版本缺少`str_contains()`函数！
- en: '[PRE86]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As you can see, `instanceof` correctly reports that the anonymous class implements
    `OuterInterface` (because it extends `FilterIterator`, which, in turn, implements
    `OuterInterface`). You can also see that `var_dump()` reports the name of the
    anonymous class as `FilterIterator@anonymous`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`instanceof`正确报告匿名类实现了`OuterInterface`（因为它扩展了`FilterIterator`，而`FilterIterator`又实现了`OuterInterface`）。你还可以看到，`var_dump()`报告了匿名类的名称为`FilterIterator@anonymous`。
- en: Now that you have an idea of how anonymous class naming has changed in PHP 8,
    let's have a look at changes in namespace handling.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了PHP 8中匿名类命名的变化，让我们来看看命名空间处理的变化。
- en: Understanding changes in namespaces
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解命名空间的变化
- en: The concept of a **namespace** was introduced in PHP 5.3 as a means of isolating
    hierarchies of classes. Unfortunately, the original algorithm that was used to
    parse namespace names had several flaws. In addition to being overly complicated,
    the way in which namespace and class names were **tokenized** internally was performed
    in an inconsistent manner, leading to unexpected errors.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名空间**的概念在PHP 5.3中被引入，作为隔离类层次结构的一种手段。不幸的是，用于解析命名空间名称的原始算法存在一些缺陷。除了过于复杂外，命名空间和类名在内部的**标记化**方式也是以一种不一致的方式进行的，导致意外的错误。'
- en: Before we get into the benefits and potential backward compatible breaks, let's
    have a look at how the namespace tokenization process has changed.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论好处和潜在的向后兼容性问题之前，让我们看看命名空间标记化过程发生了什么变化。
- en: Discovering differences in tokenization
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现标记化的差异
- en: The tokenization process is an important part of the interpretation process
    and takes place when your PHP code is executed. In the process of producing byte
    code, the PHP program code is broken down into tokens by the PHP parsing engine.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 标记化过程是解释过程的重要部分，在执行PHP代码时进行。在生成字节码的过程中，PHP程序代码被PHP解析引擎分解成标记。
- en: 'The following table summarizes namespace tokenization changes:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了命名空间标记化的变化：
- en: '![Table 9.5 – Namespace tokenization differences in PHP 8'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '![表9.5 - PHP 8中的命名空间标记化差异'
- en: '](image/Figure_9.5_B16992.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.5_B16992.jpg)'
- en: Table 9.5 – Namespace tokenization differences in PHP 8
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.5 - PHP 8中的命名空间标记化差异
- en: As you can see, PHP 8 namespace tokenization is much simpler and streamlined.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，PHP 8的命名空间标记化要简单得多。
- en: Tip
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on parser tokens, have a look at the following documentation
    reference: [https://www.php.net/manual/en/tokens](https://www.php.net/manual/en/tokens).'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 有关解析器标记的更多信息，请参阅以下文档参考：[https://www.php.net/manual/en/tokens](https://www.php.net/manual/en/tokens)。
- en: The impact of this change produces extremely positive results. For one, you
    can now use reserved key words as part of a namespace. Also, in the future, as
    new keywords are introduced into the language, PHP will not force you to change
    namespaces in your applications. The new tokenization process also facilitates
    the use of `Attributes` with namespaces.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变的影响产生了非常积极的结果。首先，你现在可以在命名空间中使用保留关键字。此外，在将来，当语言引入新关键字时，PHP不会强制你在应用程序中更改命名空间。新的标记化过程还促进了在命名空间中使用`Attributes`。
- en: First, let's have a look at using keywords in a namespace.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看在命名空间中使用关键字。
- en: Using reserved keywords in a namespace
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在命名空间中使用保留关键字
- en: The namespace tokenization process in PHP 7 produced a series of string (`T_STRING`)
    and backslash (`T_NS_SEPARATOR`) tokens. The problem with this approach is that
    if one of the strings happened to be a PHP keyword, a syntax error was immediately
    thrown during the parsing process. PHP 8, however, produces just a single token,
    as shown earlier, in *Table 9.5*. Ultimately, this means that you can put pretty
    much anything in a namespace and don't have to worry about reserved keyword conflicts.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中，命名空间标记化过程产生了一系列字符串（`T_STRING`）和反斜杠（`T_NS_SEPARATOR`）标记。这种方法的问题在于，如果其中一个字符串恰好是PHP关键字，解析过程中会立即抛出语法错误。然而，PHP
    8只产生一个单一标记，如前面所示，在*表9.5*中。最终，这意味着你几乎可以在命名空间中放任何东西，而不必担心保留关键字的冲突。
- en: 'The following code example illustrates the difference in namespace handling
    between PHP 8 and earlier versions. In this example, a PHP keyword is being used
    as part of the namespace. In PHP 7, due to its inaccurate tokenization process,
    `List` is seen as a keyword rather than part of the namespace:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了PHP 8和早期版本之间命名空间处理的差异。在这个例子中，一个PHP关键字被用作命名空间的一部分。在PHP 7中，由于其不准确的标记化过程，`List`被视为关键字而不是命名空间的一部分：
- en: '[PRE87]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Here is the output from PHP 7:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是PHP 7的输出：
- en: '[PRE88]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In PHP 8, the program code snippet works as expected, as shown here:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，程序代码片段按预期工作，如下所示：
- en: '[PRE89]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Now that you have an idea of how the tokenization process differs between PHP
    8 and earlier PHP versions, as well as its potential benefits, let's have a look
    at potential backward compatible code breaks.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了PHP 8和早期PHP版本之间标记化过程的差异，以及它的潜在好处，让我们来看看潜在的向后兼容代码中的可能断裂。
- en: Exposing bad namespace naming practices
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴露不良的命名空间命名惯例
- en: The same PHP 8 tokenization process that releases you from having to worry about
    keyword conflicts may also end up exposing bad namespace naming practices. Any
    namespaces with white space in them are now considered invalid. However, it's
    a bad practice to include whitespace in a namespace anyhow!
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8的标记化过程使你不必担心关键字冲突，但也可能暴露不良的命名空间命名惯例。任何包含空格的命名空间现在都被视为无效。然而，在命名空间中包含空格本来就是一种不良习惯！
- en: 'The following simple code example illustrates this principle. In this example,
    you''ll notice that the namespace includes white space:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简单的代码示例说明了这个原则。在这个例子中，你会注意到命名空间包括了空格：
- en: '[PRE90]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'If we run this code in PHP 7, it works OK. Here''s the PHP 7 output:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在PHP 7中运行这段代码，它可以正常工作。以下是PHP 7的输出：
- en: '[PRE91]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'In PHP 8, however, a `ParseError` is thrown, as shown here:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PHP 8中，会抛出一个`ParseError`，如下所示：
- en: '[PRE92]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The space serves as a delimiter that's used by the parser during the tokenization
    process. In this code example, PHP 8 assumes that the namespace is `Doesnt`. The
    next token is `\Work`, which marks a fully qualified class name. However, it's
    not expected at this point, which is why an error was thrown.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 空格在标记化过程中由解析器用作分隔符。在这个代码示例中，PHP 8假定命名空间是`Doesnt`。下一个标记是`\Work`，标志着一个完全限定的类名。然而，在这一点上并不是预期的，这就是为什么会抛出错误。
- en: This concludes our discussion on the changes that have been made to namespace
    handling in PHP 8\. You are now in a better position to create namespace names
    in PHP 8 that not only follow best practices, but also take advantage of its independence
    from keyword naming conflicts.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对PHP 8中命名空间处理变化的讨论。您现在可以更好地创建PHP 8中的命名空间名称，不仅遵循最佳实践，而且还可以利用其独立于关键字命名冲突的优势。
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: PHP 8, as you learned, is much stricter in terms of how it defines magic methods.
    In this chapter, you learned about method signature changes and how to reduce
    potential bugs by using magic methods properly. You also learned about the method
    signature changes in both the Reflection and PDO extensions. With the knowledge
    you've gained in this chapter, you can avoid potential problems when migrating
    to PHP 8\. In addition, you learned about changes in how static methods can be
    called, as well as a new static return type.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所了解的，PHP 8在定义魔术方法方面要严格得多。在本章中，您了解了方法签名的变化以及如何通过正确使用魔术方法来减少潜在的错误。您还了解了Reflection和PDO扩展中的方法签名变化。有了本章中所学到的知识，您可以避免在迁移到PHP
    8时出现潜在问题。此外，您还了解了静态方法调用方式的变化，以及新的静态返回类型。
- en: Then, you learned how to make the best use of private methods, as well as how
    to exert greater control over anonymous classes. You also picked up a few tips
    on new syntax possibilities and which methods are now obsolete due to changes
    in the language.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您学会了如何最好地使用私有方法，以及如何更好地控制匿名类。您还学到了一些关于新语法可能性以及由于语言变化而现在已经过时的方法的技巧。
- en: You also learned how to correctly use interfaces and traits to facilitate efficient
    use of your code. You learned about the new interfaces that were introduced to
    bring the DOM extension up to the new DOM Living Standard. In addition, you gained
    insights into using new methods introduced in the DateTime extension.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学会了如何正确使用接口和特征来促进代码的高效使用。您了解了为了使DOM扩展符合新的DOM Living标准而引入的新接口。此外，您还深入了解了在DateTime扩展中引入的新方法。
- en: Finally, you learned how to clean up namespace usage and produce tighter code.
    You now have a better understanding of how the namespace tokenization process
    was inaccurate and how it's been improved in PHP 8.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您学会了如何清理命名空间的使用并生成更紧凑的代码。您现在对命名空间标记化过程的不准确性有了更好的理解，以及在PHP 8中如何改进。
- en: 'The next chapter will present you with something every developer strives for:
    tips, tricks, and techniques to improve performance.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将为您介绍每个开发人员都在努力追求的内容：改进性能的技巧和技术。
