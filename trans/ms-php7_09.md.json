["```php\n<?php   class UserRegister implements \\SplSubject {\n  protected $user;\n  protected $observers;    public function __construct($user)\n {  $this->user = $user;\n  $this->observers = new \\SplObjectStorage();\n }    public function attach(\\SplObserver $observer)\n {  $this->observers->attach($observer);\n }    public function detach(\\SplObserver $observer)\n {  $this->observers->detach($observer);\n }    public function notify()\n {  foreach ($this->observers as $observer) {\n  $observer->update($this);\n } }    public function getUser()\n {  return $this->user;\n } }   class Mailer implements \\SplObserver {\n  public function update(\\SplSubject $subject)\n {  if ($subject instanceof UserRegister) {\n  echo 'Mailing ', $subject->getUser(), PHP_EOL;\n } } }   class Logger implements \\SplObserver {\n  public function update(\\SplSubject $subject)\n {  if ($subject instanceof UserRegister) {\n  echo 'Logging ', $subject->getUser(), PHP_EOL;\n } } }   $userRegister = new UserRegister('John'); // some code... $userRegister->attach(new Mailer()); // some code... $userRegister->attach(new Logger()); // some code... $userRegister->notify();\n\n```", "```php\ncomposer require reactivex/rxphp\n\n```", "```php\ncomposer require react/event-loop\n\n```", "```php\n<?php   require_once __DIR__ . '/vendor/autoload.php';   use \\Rx\\Observable; use \\Rx\\Observer\\CallbackObserver; use \\React\\EventLoop\\Factory; use \\Rx\\Scheduler;   $loop = Factory::create();   Scheduler::setDefaultFactory(function () use ($loop) {\n  return new Scheduler\\EventLoopScheduler($loop); });   $users = Observable::fromArray(['John', 'Mariya', 'Marc', 'Lucy']);   $logger = new CallbackObserver(\n  function ($user) {\n  echo 'Logging: ', $user, PHP_EOL;\n },  function (\\Throwable $t) {\n  echo $t->getMessage(), PHP_EOL;\n },  function () {\n  echo 'Stream complete!', PHP_EOL;\n } );   $users->subscribe($logger);   $loop->run();\n\n```", "```php\nLogging: John\nLogging: Mariya\nLogging: Marc\nLogging: Lucy\nStream complete!\n\n```", "```php\n<?php   require_once __DIR__ . '/vendor/autoload.php';   use \\Rx\\Observable; use \\Rx\\Observer\\CallbackObserver; use \\React\\EventLoop\\Factory; use \\Rx\\Scheduler;   $loop = Factory::create();   Scheduler::setDefaultFactory(function () use ($loop) {\n  return new Scheduler\\EventLoopScheduler($loop); });   // Generator function, reads CSV file function users($file) {\n  $users = fopen($file, 'r');\n  while (!feof($users)) {\n  yield fgetcsv($users)[0];\n }  fclose($users); }   // The RxPHP Observer $logger = new CallbackObserver(\n  function ($user) {\n  echo $user, PHP_EOL;\n },  function (\\Throwable $t) {\n  echo $t->getMessage(), PHP_EOL;\n },  function () {\n  echo 'stream complete!', PHP_EOL;\n } );   // Dummy map callback function $mapper = function ($value) {\n  return time() . ' | ' . $value; };   // Dummy filter callback function $filter = function ($value) {\n  return strstr($value, 'Ma'); };   // Generator function $users = users(__DIR__ . '/users.csv');   // The RxPHP Observable - from generator Observable::fromIterator($users)\n ->map($mapper)\n ->filter($filter)\n ->subscribe($logger);   $loop->run();\n\n```", "```php\n\"John\"\n\"Mariya\"\n\"Marc\"\n\"Lucy\"\n\n```", "```php\n1487439356 | Mariya\n1487439356 | Marc\nstream complete!\n\n```", "```php\n$mailer = new CallbackObserver(\n  function ($user) {\n    echo 'Mailer: ', $user, PHP_EOL;\n  },\n  function (\\Throwable $t) {\n    echo 'Mailer: ', $t->getMessage(), PHP_EOL;\n  },\n  function () {\n    echo 'Mailer stream complete!', PHP_EOL;\n  }\n);\n\n$logger = new CallbackObserver(\n  function ($user) {\n    echo 'Logger: ', $user, PHP_EOL;\n  },\n  function (\\Throwable $t) {\n    echo 'Logger: ', $t->getMessage(), PHP_EOL;\n  },\n  function () {\n    echo 'Logger stream complete!', PHP_EOL;\n  }\n);\n\n$users = Observable::fromIterator(users(__DIR__ . '/users.csv'));\n\n$users->subscribe($mailer);\n$users->subscribe($logger);\n\n```", "```php\nMailer: John\nLogger: Mariya\nMailer: Marc\nLogger: Lucy\nMailer:\nLogger:\nMailer stream complete!\nLogger stream complete!\n\n```", "```php\nuse \\Rx\\Subject\\Subject;\n\n$mailer  = new class() extends Subject {\n  public function onCompleted()\n {  echo 'mailer.onCompleted', PHP_EOL;\n  parent::onCompleted();\n }    public function onNext($val)\n {  echo 'mailer.onNext: ', $val, PHP_EOL;\n  parent::onNext($val);\n }    public function onError(\\Throwable $error)\n {  echo 'mailer.onError', $error->getMessage(), PHP_EOL;\n  parent::onError($error);\n } };     $logger = new class() extends Subject {\n  public function onCompleted()\n {  echo 'logger.onCompleted', PHP_EOL;\n  parent::onCompleted();\n }    public function onNext($val)\n {  echo 'logger.onNext: ', $val, PHP_EOL;\n  parent::onNext($val);\n }    public function onError(\\Throwable $error)\n {  echo 'logger.onError', $error->getMessage(), PHP_EOL;\n  parent::onError($error);\n } };   $users = Observable::fromIterator(users(__DIR__ . '/users.csv')); $mailer->subscribe($logger); $users->subscribe($mailer);\n\n```", "```php\nmailer.onNext: John\nlogger.onNext: John\nmailer.onNext: Mariya\nlogger.onNext: Mariya\nmailer.onNext: Marc\nlogger.onNext: Marc\nmailer.onNext: Lucy\nlogger.onNext: Lucy\nmailer.onNext:\nlogger.onNext:\nmailer.onCompleted\nlogger.onCompleted\n\n```", "```php\n// ...\n\n$mailer\n ->filter(function ($val) {\n   return strstr($val, 'Marc') == false;\n })\n ->subscribe($logger);\n\n$users->subscribe($mailer);\n\n```", "```php\nmailer.onNext: John\nlogger.onNext: John\nmailer.onNext: Mariya\nlogger.onNext: Mariya\nmailer.onNext: Marc\nmailer.onNext: Lucy\nlogger.onNext: Lucy\nmailer.onNext:\nlogger.onNext:\nmailer.onCompleted\nlogger.onCompleted\n\n```", "```php\n<?php   require_once __DIR__ . '/vendor/autoload.php';   use \\Rx\\Observable; use \\Rx\\Observer\\CallbackObserver; use \\React\\EventLoop\\Factory; use \\Rx\\Scheduler;   $loop = Factory::create();   Scheduler::setDefaultFactory(function () use ($loop) {\n  return new Scheduler\\EventLoopScheduler($loop); });   // Generator function function xrange($start, $end, $step = 1) {\n  for ($i = $start; $i <= $end; $i += $step) {\n  yield $i;\n } }   // Observer $observer = new CallbackObserver(\n  function ($item) {\n  echo $item, PHP_EOL;\n } );   echo 'start', PHP_EOL; // Observable stream, made from iterator/generator Observable::fromIterator(xrange(1, 10, 1))\n ->map(function ($item) {\n  return $item * 2;\n }) ->filter(function ($item) {\n  return $item % 3 == 0;\n }) ->reduce(function ($x, $y) {\n  return $x + $y;\n }) ->subscribe($observer);   echo 'end', PHP_EOL;   $loop->run();\n\n```", "```php\nObservable::fromIterator(xrange(1, 10, 1))\n ->map(function ($item) {\n   return $item * 2;\n })\n// ->filter(function ($item) {\n  // return $item % 3 == 0;\n// })\n// ->reduce(function ($x, $y) {\n  // return $x + $y;\n// })\n ->subscribe($observer);\n\n```", "```php\nstart\n2\n4\n6\n8\n10\n12\n14\n16\n18\n20\nend\n\n```", "```php\nObservable::fromIterator(xrange(1, 10, 1))\n ->map(function ($item) {\n   return $item * 2;\n })\n ->filter(function ($item) {\n   return $item % 3 == 0;\n })\n// ->reduce(function ($x, $y) {\n  // return $x + $y;\n// })\n ->subscribe($observer);\n\n```", "```php\nstart\n6\n12\n18\nend\n\n```", "```php\n ->reduce(function ($x, $y) {\n   $z = $x + $y;\n   echo '$x: ', $x, PHP_EOL;\n   echo '$y: ', $y, PHP_EOL;\n   echo '$z: ', $z, PHP_EOL, PHP_EOL;\n   return $z;\n })\n\n```", "```php\nstart\n$x: 6\n$y: 12\n$z: 18\n\n$x: 18\n$y: 18\n$z: 36\n\n36\nend\n\n```", "```php\n$observable\n ->operator1(function () { /* ...*/ })\n ->operator2(function () { /* ...*/ })\n ->operator3(function () { /* ...*/ })\n // ...\n ->operatorN(function () { /* ...*/ })\n ->subscribe($observer);\n\n```", "```php\n<?php   require_once __DIR__ . '/vendor/autoload.php';   use \\Rx\\Observer\\CallbackObserver; use \\React\\EventLoop\\Factory; use \\Rx\\Scheduler;   $loop = Factory::create();   Scheduler::setDefaultFactory(function () use ($loop) {\n  return new Scheduler\\EventLoopScheduler($loop); });   // correct $users = serialize(['John', 'Mariya', 'Marc', 'Lucy']);   // faulty // $users = str_replace('i:', '', serialize(['John', 'Mariya', 'Marc', 'Lucy']));   $observer = new CallbackObserver(\n  function ($value) {\n  echo 'Observer.$onNext: ', print_r($value, true), PHP_EOL;\n },  function (\\Throwable $t) {\n  echo 'Observer.$onError: ', $t->getMessage(), PHP_EOL;\n },  function () {\n  echo 'Observer.$onCompleted', PHP_EOL;\n } );   Rx\\Observable::just($users)\n ->map(function ($value) {\n  return unserialize($value);\n }) ->subscribe($observer);   $loop->run();\n\n```", "```php\n<?php   declare(strict_types=1);   namespace Rx\\Operator;   use Rx\\DisposableInterface; use Rx\\ObservableInterface; use Rx\\ObserverInterface;   interface OperatorInterface {\n  public function __invoke(\n ObservableInterface $observable,\n ObserverInterface $observer\n  ): DisposableInterface; } \n\n```", "```php\n<?php   use \\Rx\\DisposableInterface; use \\Rx\\ObservableInterface; use \\Rx\\ObserverInterface; use \\Rx\\SchedulerInterface; use \\Rx\\Observer\\CallbackObserver; use \\Rx\\Operator\\OperatorInterface;   class UnserializeOperator implements OperatorInterface {\n  /**\n * @param \\Rx\\ObservableInterface $observable\n * @param \\Rx\\ObserverInterface $observer\n * @param \\Rx\\SchedulerInterface $scheduler  * @return \\Rx\\DisposableInterface\n */  public function __invoke(\n ObservableInterface $observable,\n ObserverInterface $observer,\n SchedulerInterface $scheduler  = null\n  ): DisposableInterface\n {  $callbackObserver = new CallbackObserver(\n  function ($value) use ($observer) {\n  if ($unsValue = unserialize($value)) {\n  $observer->onNext($unsValue);\n } else {\n  $observer->onError(\n  new InvalidArgumentException('Faulty serialized string.')\n ); } },  function ($error) use ($observer) {\n  $observer->onError($error);\n },  function () use ($observer) {\n  $observer->onCompleted();\n } );    // ->subscribe(...) => DisposableInterface\n  return $observable->subscribe($callbackObserver, $scheduler);\n } }\n\n```", "```php\nRx\\Observable::just($users)\n ->lift(function () {\n  return new UnserializeOperator();\n })\n ->subscribe($observer);\n\n```", "```php\n<?php\n\n$now = time();\n\nwhile ($now + $argv[1] > time()) {\n  echo 'signal ', microtime(), PHP_EOL;\n  usleep(200000); // 0.2s\n}\n\n```", "```php\n<?php\n\n// stream_set_blocking(STDIN, 0);\n// stream_set_blocking(STDIN, 1); // default\n\necho 'start', PHP_EOL;\n\nwhile (($line = fgets(STDIN)) !== false) {\n  echo $line;\n}\n\necho 'end', PHP_EOL;\n\n```", "```php\nphp beacon.php 2 | php index.php\n\n```", "```php\nconsole.log('start-time: ' + Date.now());\n\n$.ajax({\n  url: 'http://foggyline.net/',\n  success: function (result) {\n    console.log('result-time: ' + Date.now())\n    console.log(result)\n  }\n});\n\nconsole.log('end-time: ' + Date.now());\n\n```", "```php\n<?php\n\necho 'start', PHP_EOL;\n\n$process = proc_open('php beacon.php 2', [\n  ['pipe', 'r'], // STDIN\n  ['pipe', 'w'], // STDOUT\n  ['file', './signals.log', 'a'] //STDERR\n], $pipes);\n\n//stream_set_blocking($pipes[1], 1); // Blocking I/O\n//stream_set_blocking($pipes[1], 0); // Non-blocking I/O\n\nwhile (proc_get_status($process)['running']) {\n  usleep(100000); // 0.1s\n  if ($signal = fgets($pipes[1])) {\n    echo $signal;\n  } else {\n    echo '--- beacon lost ---', PHP_EOL;\n  }\n}\n\nfclose($pipes[1]);\nproc_close($process);\n\necho 'end', PHP_EOL;\n\n```", "```php\ncomposer require react/react\n\n```", "```php\n<?php   require_once __DIR__ . '/vendor/autoload.php';   use \\React\\EventLoop\\Factory; use \\Rx\\Scheduler;   $loop = Factory::create();   Scheduler::setDefaultFactory(function () use ($loop) {\n  return new Scheduler\\EventLoopScheduler($loop); });   // Within the loop   $loop->run();\n\n```", "```php\nclass Factory\n{\n  public static function create()\n  {\n    if (function_exists('event_base_new')) {\n      return new LibEventLoop();\n    } elseif (class_exists('libev\\EventLoop', false)) {\n      return new LibEvLoop;\n    } elseif (class_exists('EventBase', false)) {\n      return new ExtEventLoop;\n    }\n    return new StreamSelectLoop();\n  }\n}\n\n```", "```php\n<?php   require_once __DIR__ . '/vendor/autoload.php';   use \\React\\EventLoop\\Factory; use \\Rx\\Scheduler;   echo 'STEP#1 ', time(), PHP_EOL;   $loop = Factory::create();   Scheduler::setDefaultFactory(function () use ($loop) {\n  return new Scheduler\\EventLoopScheduler($loop); });    echo 'STEP#2 ', time(), PHP_EOL;   $loop->run();   echo 'STEP#3 ', time(), PHP_EOL;\n\n```", "```php\n<?php   require_once __DIR__ . '/vendor/autoload.php';   use \\React\\EventLoop\\Factory; use \\Rx\\Scheduler;   echo 'STEP#1 ', time(), PHP_EOL;   $loop = Factory::create();   Scheduler::setDefaultFactory(function () use ($loop) {\n  return new Scheduler\\EventLoopScheduler($loop); });   echo 'STEP#2 ', PHP_EOL;   $loop->addTimer(2, function () {\n  echo 'timer#1 ', time(), PHP_EOL; });   echo 'STEP#3 ', time(), PHP_EOL;   $loop->addTimer(5, function () {\n  echo 'timer#2 ', time(), PHP_EOL; });   echo 'STEP#4 ', time(), PHP_EOL;   $loop->addTimer(3, function () {\n  echo 'timer#3 ', time(), PHP_EOL; });   echo 'STEP#5 ', time(), PHP_EOL; $loop->run();   echo 'STEP#6 ', time(), PHP_EOL;\n\n```", "```php\n<?php   require_once __DIR__ . '/vendor/autoload.php';   use \\React\\EventLoop\\Factory; use \\Rx\\Scheduler;   echo 'STEP#1 ', time(), PHP_EOL;   $loop = Factory::create();   Scheduler::setDefaultFactory(function () use ($loop) {\n  return new Scheduler\\EventLoopScheduler($loop); });   echo 'STEP#2 ', PHP_EOL;   $loop->addPeriodicTimer(1, function () {\n  echo 'timer ', time(), PHP_EOL; });   echo 'STEP#3 ', time(), PHP_EOL;   $loop->run();   echo 'STEP#4 ', time(), PHP_EOL;\n\n```", "```php\n<?php   require_once __DIR__ . '/vendor/autoload.php';   use \\React\\EventLoop\\Factory; use \\Rx\\Scheduler; use \\Rx\\Observable; use  \\Rx\\Subject\\Subject; use \\Rx\\Scheduler\\EventLoopScheduler;   $loop = Factory::create();   Scheduler::setDefaultFactory(function () use ($loop) {\n  return new Scheduler\\EventLoopScheduler($loop); });   $stdin = fopen('php://stdin', 'r');   stream_set_blocking($stdin, 0);   $observer = new class() extends Subject  {\n  public function onCompleted()\n {  echo '$observer.onCompleted: ', PHP_EOL;\n  parent::onCompleted();\n }    public function onNext($val)\n {  echo '$observer.onNext: ', $val, PHP_EOL;\n  parent::onNext($val);\n }    public function onError(\\Throwable $error)\n {  echo '$observer.onError: ', $error->getMessage(), PHP_EOL;\n  parent::onError($error);\n } };   $loop = Factory::create();   $scheduler = new EventLoopScheduler($loop);   $disposable = Observable::interval(500, $scheduler)\n ->map(function () use ($stdin) {\n  return trim(fread($stdin, 1024));\n }) ->filter(function ($str) {\n  return strlen($str) > 0;\n }) ->subscribe($observer);   $observer->filter(function ($value) {\n  return $value == 'quit'; })->subscribeCallback(function ($value) use ($disposable) {\n  echo 'disposed!', PHP_EOL;\n  $disposable->dispose(); });   $loop->run(); \n\n```"]