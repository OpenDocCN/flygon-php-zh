- en: Chapter 8. Ajax Mashups
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。Ajax混搭
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Web services
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络服务
- en: XML-RPC
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML-RPC
- en: Creating and consuming web services using PHP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PHP创建和使用网络服务
- en: Using Flickr API with Ajax
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flickr API与Ajax
- en: Using Twitter API with Ajax
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Twitter API与Ajax
- en: Translating text using Google Ajax API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google Ajax API翻译文本
- en: Using Google Maps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google地图
- en: Searching for a location within a Google Maps
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Google地图中搜索位置
- en: Searching within XX km. radius of Google Map with markers and Info window
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Google地图上搜索XX公里半径内的位置，带有标记和信息窗口
- en: Maps with markers and Info window
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带标记和信息窗口的地图
- en: Finding a city/country using IP address
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用IP地址查找城市/国家
- en: Converting currencies using Ajax and PHP
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ajax和PHP转换货币
- en: Knowledge of web services is one of the important qualities of the web developer
    these days. In this chapter, we first go through consuming the web services provided
    by the popular websites.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，对网络服务的了解是Web开发人员的重要素质之一。在本章中，我们首先介绍了如何使用流行网站提供的网络服务。
- en: First of all, we will be learning about the introduction of popular web services
    formats like SOAP, REST, and XML-RPC. After that section, we will learn how to
    interact with the API of various popular web applications like Flickr, Twitter,
    Google Translate, Google Maps, and a Currency Convertor using foxrate.org's XML-RPC
    API.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将学习SOAP、REST和XML-RPC等流行网络服务格式的介绍。在该部分之后，我们将学习如何与各种流行的Web应用程序的API进行交互，如Flickr、Twitter、Google翻译、Google地图和使用foxrate.org的XML-RPC
    API的货币转换器。
- en: Web services
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络服务
- en: In a typical web-based application, a web client (usually a browser) sends an
    HTTP request to a web server and the web server sends the response via the HTTP
    protocol to the client.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的基于Web的应用程序中，Web客户端（通常是浏览器）向Web服务器发送HTTP请求，Web服务器通过HTTP协议将响应发送给客户端。
- en: For example, let's suppose you want to get the weather report of a particular
    city. In this scenario, you visit a news portal and search for your city's weather
    report via HTML in that news portal.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您想获取特定城市的天气报告。在这种情况下，您可以访问新闻门户网站，并通过HTML搜索您城市的天气报告。
- en: But, web services act in a different manner. Rather than allowing access to
    the information via HTML pages as we mentioned above, web services cause a server
    to expose application logic, which the client can use programmatically. In simple
    words, it means that the server exposes a set of APIs (that is, functions) that
    a client can call. Thus, a web service is an exposed application on a server,
    which a client can access using the Internet.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，网络服务的工作方式不同。与上面提到的通过HTML页面访问信息不同，网络服务会导致服务器公开应用程序逻辑，客户端可以以编程方式使用。简单来说，这意味着服务器公开了一组客户端可以调用的API（即函数）。因此，网络服务是服务器上公开的应用程序，客户端可以通过互联网访问。
- en: Since the API exposed using web services should be platform independent, XML,
    as well as JSON, is used for the communication between the client and the server.
    The set of functions that a server exposes is usually described using a language
    called Web Services Description Language (WSDL).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用网络服务公开的API应该是平台无关的，因此在客户端和服务器之间的通信中通常使用XML和JSON。服务器公开的一组函数通常使用一种称为Web服务描述语言（WSDL）的语言来描述。
- en: '**Web services** are a set of tools that can be used in a number of ways. The
    three most common styles of using them are REST, XML-RPC, and SOAP.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络服务**是一组可以以多种方式使用的工具。最常见的三种使用方式是REST、XML-RPC和SOAP。'
- en: While creating web widgets, we may have to use various standards of web services
    and let's glance through these technologies.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Web小部件时，我们可能需要使用各种网络服务标准，让我们浏览一下这些技术。
- en: SOAP
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOAP
- en: SOAP, formerly defined as **Simple Object Access Protocol**, is one of the most
    popular methods of accessing remote procedures on the Internet. It is a protocol
    for exchanging XML-based messages from client to server normally using HTTP and
    HTTPS protocol. SOAP procedures that are exposed in the XML format can be used
    from a client using SOAP protocol.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP，以前定义为**简单对象访问协议**，是访问Internet上远程过程的最流行方法之一。它是一种使用HTTP和HTTPS协议通常从客户端到服务器交换基于XML的消息的协议。以XML格式公开的SOAP过程可以使用SOAP协议从客户端使用。
- en: 'SOAP is an XML-based messaging-protocol. A SOAP request in XML format contains
    the following main parts:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP是一种基于XML的消息传递协议。XML格式的SOAP请求包含以下主要部分：
- en: An Envelope This defines the document as a SOAP request.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个信封，它将文档定义为SOAP请求。
- en: A Body Element This contains the information about the procedure call with parameters
    and expected response.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Body元素，其中包含有关过程调用的信息，包括参数和预期响应。
- en: Optional headers and fault element These contain supplementary information about
    the SOAP request.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选头和故障元素，这些元素包含有关SOAP请求的补充信息。
- en: A typical example of how a SOAP procedure can be used is a website exposing
    a function called `addTwoNumbers()` to add two numbers and send the response to
    the SOAP client. Since SOAP's request and response are sent using XML format they
    are platform independent and can be called from the remote server.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP过程的典型示例是一个网站公开一个名为`addTwoNumbers()`的函数，用于添加两个数字并将响应发送给SOAP客户端。由于SOAP的请求和响应使用XML格式发送，它们是平台无关的，并且可以从远程服务器调用。
- en: SOAP is criticized for its substantial complexity, with the necessity to serialize
    the remote call and then construct a SOAP envelope to contain it. Due to this
    complexity, the REST way is becoming popula for using web services.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP因其复杂性而受到批评，需要对远程调用进行序列化，然后构造一个SOAP信封来包含它。由于这种复杂性，REST方式正在成为使用网络服务的流行方式。
- en: REST
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST
- en: REST stands for *Representational State Transfer*, and probably the most popular
    way to create and utilize web services these days. It is a simple yet powerful
    method of creating and consuming web services. REST is sometime known as **RESTful
    Web Services**. RESTful web services uses HTTP or a similar protocol by constraining
    the interface to the standard operations like GET, POST, and PUT methods. REST
    focuses on interacting with stateful resources rather than messages or operations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: REST代表*表现状态转移*，可能是创建和利用Web服务的最流行的方式。这是一种简单而强大的创建和消费Web服务的方法。REST有时被称为**RESTful
    Web服务**。RESTful Web服务使用HTTP或类似的协议，通过将接口限制为标准操作（如GET、POST和PUT方法）来进行交互。REST侧重于与有状态资源交互，而不是消息或操作。
- en: 'The two main principles of RESTful web services are:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web服务的两个主要原则是：
- en: Resources are represented by URL. Resources can be thought of as an entity that
    a user can access as an API of a web service. Each resource in a REST application
    has a unique URL.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源由URL表示。资源可以被视为用户可以作为Web服务的API访问的实体。REST应用程序中的每个资源都有一个唯一的URL。
- en: Operations in RESTful Web Services are carried out by standard HTTP operations
    such GET, POST, and PUT.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful Web服务中的操作是通过标准的HTTP操作进行的，例如GET、POST和PUT。
- en: Let's look at an example to understand the REST principle. Suppose that we've
    a marketplace website where merchants can upload, view, and delete the products.
    Let's look at the RESTful interface of web services of the preceding example.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子来理解REST原则。假设我们有一个市场网站，商家可以上传、查看和删除产品。让我们看一下前面示例的Web服务的RESTful接口。
- en: Each Product detail can be accessed from a unique URL. Let's suppose it is [http://marketplace-website.com/product/123](http://marketplace-website.com/product/123)
    and the HTTP GET method can be used to get the details of the product from the
    preceding URL.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以从唯一的URL访问每个产品的详细信息。假设它是[http://marketplace-website.com/product/123](http://marketplace-website.com/product/123)，可以使用HTTP
    GET方法从前面的URL获取产品的详细信息。
- en: The HTTP POST method can be used to post a new product to the website with the
    details specified by the server in a particular URL specified by the server and
    the server responses with information regarding the product upload.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用HTTP POST方法将新产品发布到网站，服务器在特定URL指定的服务器响应中提供有关产品上传的信息。
- en: The HTTP DELETE method can be used to delete the particular product from the
    website using a unique URL for this operation.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用HTTP DELETE方法来删除网站上的特定产品，使用唯一的URL进行此操作。
- en: XML-RPC
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML-RPC
- en: XML-Remote Procedure call is another way of providing and consuming web services.
    XML-RPC uses XML to encode the request and response of the services and HTTP as
    a transport medium for them.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: XML-远程过程调用是提供和消费Web服务的另一种方式。 XML-RPC使用XML来编码服务的请求和响应，使用HTTP作为它们的传输介质。
- en: XML-RPC is a very simple protocol for using and consuming web services. It has
    a definite set of XML formats for defining the procedure, the data type, and commands.
    XML-RPC is designed to be as simple as possible. It allows complex data structures
    to be transmitted, processed, and returned using its procedures. Let's look at
    an XML request format for calling a remote procedure using XML-RPC and then look
    at the response returned by the server in XML-RPC format.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: XML-RPC是一种非常简单的协议，用于使用和消费Web服务。它有一套明确定义过程、数据类型和命令的XML格式。XML-RPC旨在尽可能简单。它允许使用其过程传输、处理和返回复杂的数据结构。让我们看一下使用XML-RPC调用远程过程的XML请求格式，然后看一下服务器以XML-RPC格式返回的响应。
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, XML format for sending requests is fairly simple and even the
    data types of the parameters are defined in the procedure call. Now, let''s look
    at the response to the preceding call in XML format:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，用于发送请求的XML格式非常简单，甚至参数的数据类型也在过程调用中定义。现在，让我们看一下以XML格式返回前面调用的响应：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you see, the XML response is very simple to understand. That's why XML-RPC
    is also used in many websites providing web-services.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，XML响应非常简单易懂。这就是为什么XML-RPC也用于许多提供Web服务的网站。
- en: Creating and consuming web services using PHP
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP创建和消费Web服务
- en: PHP can be used for creating and consuming web services. PHP has powerful libraries
    for creating and consuming web services that use SOAP or XML-RPC or REST.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: PHP可以用于创建和消费Web服务。PHP具有强大的库，用于创建和消费使用SOAP或XML-RPC或REST的Web服务。
- en: Let's try to understand how to consume web services in PHP using a simple example.
    In this example, we're going to get the details of a phrase from the API of Wikipedia.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过一个简单的例子来理解如何在PHP中消费Web服务。在这个例子中，我们将从维基百科的API中获取一个短语的详细信息。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Wikipedia ([http://www.wikipedia.org](http://www.wikipedia.org)) is a free web-based
    multilingual encyclopedia. Almost all of its articles can be edited by anyone
    if they have more information about the subjects. It is probably the largest and
    most popular website where people find information about general knowledge or
    specific topics. Currently, Wikipedia has articles in 282 languages.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科（[http://www.wikipedia.org](http://www.wikipedia.org)）是一个免费的基于Web的多语言百科全书。几乎所有的文章都可以由任何人编辑，如果他们对主题有更多的信息。它可能是人们查找一般知识或特定主题信息的最大和最受欢迎的网站。目前，维基百科有282种语言的文章。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Wikipedia has an API at [http://en.wikipedia.org/w/api.php](http://en.wikipedia.org/w/api.php),
    which can be used for various purposes to access and modify the information at
    Wikipedia.org. In our example, we're just getting an explanation of a term using
    Wikipedia.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科在[http://en.wikipedia.org/w/api.php](http://en.wikipedia.org/w/api.php)上有一个API，可用于各种目的，以访问和修改Wikipedia.org上的信息。在我们的示例中，我们只是使用维基百科来获取一个术语的解释。
- en: 'To invoke the API call, we need to access the following URL of the Wikipedia
    API:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用API调用，我们需要访问维基百科API的以下URL：
- en: '[http://en.wikipedia.org/w/api.php?format=xml&action=opensearch&search=PHP&limit=1](http://en.wikipedia.org/w/api.php?format=xml&action=opensearch&search=PHP&limit=1)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/w/api.php?format=xml&action=opensearch&search=PHP&limit=1](http://en.wikipedia.org/w/api.php?format=xml&action=opensearch&search=PHP&limit=1)'
- en: As you can see in the preceding URL, the parameter of the API call is self explanatory.
    We're accessing the action called opensearch of API with the search keyword PHP.
    We're limiting the result to 1 and the output we're getting is in XML format.
    Now, let's look at the XML output the preceding API call.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的URL中所看到的，API调用的参数是不言自明的。我们正在访问名为opensearch的API的操作，搜索关键字是PHP。我们将结果限制为1，我们得到的输出格式是XML。现在，让我们看看前面API调用的XML输出。
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see in the preceding code, we get an XML result containing a definition
    of the keyword PHP.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中看到的，我们得到了一个包含关键字PHP定义的XML结果。
- en: 'Now, let''s try to look at an example PHP code to call the Wickipedia API:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试看一个调用Wickipedia API的PHP代码示例：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Example of a Wikipedia API call using PHP**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: PHP调用维基百科API的示例
- en: 'Now, let''s try to understand the preceding code line by line. The first two
    lines of the code are initialization of the variables with the search keyword
    and forming the URL for the API call. Now, let''s try to understand the other
    lines of the code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐行理解前面的代码。代码的前两行是使用搜索关键字初始化变量并形成API调用的URL。现在，让我们试着理解代码的其他行：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding line initializes the new session of CURL. The CURL library is
    used for transferring data using various protocols over the Internet.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行初始化了CURL的新会话。CURL库用于通过互联网传输数据使用各种协议。
- en: To use the CURL function, make sure that your PHP is compiled with CURL library
    support otherwise you'll end up having a Fatal Eorror while trying to execute
    the preceding code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用CURL函数，请确保你的PHP编译时支持CURL库，否则在尝试执行前面的代码时会出现致命错误。
- en: 'Now let''s look at other lines:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看其他行：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `curl_setopt()` function is used to set the different options of the CURL
    execution. The `CURLOPT_URL` option is used for setting the URL of the call. `CURLOPT_RETURNTRANSFER`
    is set to 1, which means that the response received by executing `curl_exec()`
    is not output directly but returned as a string. Furthermore, `CURLOPT_USERAGENT`
    is used to set the User Agent of the call to a meaningful one.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl_setopt()`函数用于设置CURL执行的不同选项。`CURLOPT_URL`选项用于设置调用的URL。`CURLOPT_RETURNTRANSFER`设置为1，这意味着通过执行`curl_exec()`接收到的响应不会直接输出，而是作为字符串返回。此外，`CURLOPT_USERAGENT`用于将调用的用户代理设置为有意义的值。'
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's very important to set the proper User Agent while making API calls in some
    cases; otherwise the API server might reject your call.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，在进行API调用时设置正确的用户代理非常重要；否则API服务器可能会拒绝你的调用。
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After that, the CURL call is executed with the `curl_exec()` function. The XML
    response is saved in the `$xml_reponse` variable. The `$xml_reponse` variable
    is parsed using the **Simplexml** parser of PHP. And, if it is a valid response
    then the XML node Description exists, which is sent as output to the browser using
    the `echo` statement in the last line.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，使用`curl_exec()`函数执行CURL调用。XML响应保存在`$xml_reponse`变量中。`$xml_reponse`变量使用PHP的**Simplexml**解析器进行解析。如果它是一个有效的响应，那么XML节点Description存在，这将作为输出通过`echo`语句发送到浏览器的最后一行。
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After executing the preceding code, you'll see the following output in the browser,
    which is just the description of Facebook you got form the API response.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码后，你将在浏览器中看到以下输出，这只是你从API响应中得到的Facebook的描述。
- en: '**Facebook (stylized facebook) is a social networking service and website launched
    in February 2004, operated and privately owned by Facebook, Inc**.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**Facebook（标志性的facebook）是一个社交网络服务和网站，于2004年2月推出，由Facebook，Inc运营和私人拥有**。'
- en: Using Flickr API with Ajax
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flickr API与Ajax
- en: In this section, we will look at using Flickr API to retrieve images from Flickr.com
    with the specified search tag that is input from the textbox. In this section,
    we will see how to use the JSONP web services provided by Flickr using jQuery
    to get the response directly in JavaScript itself and parse it and display it.
    We're not using PHP in this example.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Flickr API从Flickr.com检索图像，指定搜索标签是从文本框中输入的。在本节中，我们将看到如何使用Flickr提供的JSONP
    Web服务，使用jQuery直接在JavaScript中获取响应并解析并显示它。在这个例子中，我们不使用PHP。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: '**JSONP**, JSON with padding, is an enhanced format of JSON data in which JSON
    data is wrapped inside function calls, which allows a page to access the data
    from a different domain. JSONP allows us cross-domain communication with the help
    of the`<script>` element. The `XMLHttpRequest` object of JavaScript, which is
    widely used in Ajax applications, is not capable of cross-domain communication
    due to restrictions of modern browsers. JSONP comes in handy to overcome such
    situations.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSONP**，带填充的JSON，是JSON数据的增强格式，其中JSON数据被包装在函数调用中，这允许页面从不同的域访问数据。JSONP允许我们使用`<script>`元素进行跨域通信。JavaScript的`XMLHttpRequest`对象，在Ajax应用程序中广泛使用，由于现代浏览器的限制，无法进行跨域通信。JSONP很方便地克服了这种情况。'
- en: 'Now, let''s try to understand how JSONP works. JSONP is nothing more than arbitrary
    JavaScript code that is executed as a function call. Let''s try to understand
    with an example. First let''s look at a simple JSON data of item:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们试着理解JSONP是如何工作的。JSONP只不过是作为函数调用执行的任意JavaScript代码。让我们通过一个例子来理解。首先让我们看一个简单的JSON数据项：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, this data can be easily passed to a function as parameter too, like the
    following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些数据也可以很容易地作为参数传递给函数，就像下面这样：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's suppose the preceding code is the response from the `product.php` from
    a domain called `example.com`; then the preceding code can be executed from any
    other domain with the help of a `script` tag.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '假设前面的代码是来自名为`example.com`的域的`product.php`的响应；那么前面的代码可以在任何其他域中通过`script`标签的帮助执行。 '
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Whichever page uses the preceding script tag, the code `itemsDetails({'name':'iphone'
    , 'model':'3GS' })`; is executed, which is just a function call.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪个页面使用前面的脚本标签，都会执行`itemsDetails({'name':'iphone'，'model':'3GS'})`; 这只是一个函数调用。
- en: So in conclusion, JSONP is padded or prefixed JSON data that is wrapped inside
    a function call to make cross-domain communication possible.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总之，JSONP是填充或前缀JSON数据，包装在函数调用中，以实现跨域通信的可能性。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Now, let''s look at what our Flickr search with tags application looks like:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下我们的带标签的Flickr搜索应用程序是什么样子的：
- en: '![How to do it...](graphics/3081_08_01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/3081_08_01.jpg)'
- en: It is just a simple application where you will enter the keyword and our application
    will search for photos containing the tag and display them. We will use the Flickr's
    public photo feed available at [http://www.flickr.com/services/feeds/docs/photos_public/](http://www.flickr.com/services/feeds/docs/photos_public/).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的应用程序，您将输入关键字，我们的应用程序将搜索包含该标签的照片并显示它们。我们将使用Flickr的公共照片源，网址为[http://www.flickr.com/services/feeds/docs/photos_public/](http://www.flickr.com/services/feeds/docs/photos_public/)。
- en: The sample URL of the feed to find the photos containing the tag sky and get
    an API response in JSON format can be invoked like the following with the parameters
    **tags** and **format:**
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像以下这样调用示例URL来查找包含标签sky的照片并以JSON格式获取API响应：
- en: '`http://api.flickr.com/services/feeds/photos_public. gne?tags=sky&format=json.`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://api.flickr.com/services/feeds/photos_public. gne?tags=sky&format=json.`'
- en: Now, let's look at the code of the application that uses JSONP web services
    form Flickr API to search for images by tags and show them. The source code of
    this example can be found on the `example-2.html` file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下使用JSONP web服务从Flickr API搜索标签并显示图像的应用程序的代码。此示例的源代码可以在`example-2.html`文件中找到。
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: You might have had a good look at the preceding code already. Even so, let's
    try to understand the main part of the preceding code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经仔细查看了前面的代码。即便如此，让我们尝试理解前面代码的主要部分。
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we're just defining CSS styles to elements. The first declaration with
    `#photos` sets that the top margin of the element will be 20 pixels. Another CSS
    declaration, `#photos img` is applied to all the`<img>` elements inside the element
    with ID `photos`. In the second declaration, we've set the height of the image
    elements to 140 pixels along with a margin of 10 pixel at the right and bottom.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是为元素定义CSS样式。第一个声明中，`#photos`设置元素的顶部边距为20像素。另一个CSS声明，`#photos img`应用于`#photos`元素内的所有`<img>`元素。在第二个声明中，我们将图像元素的高度设置为140像素，并在右侧和底部设置10像素的边距。
- en: The jQuery library for the application is hosted in Google. We can use it directly
    in our application to save the bandwidth.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的jQuery库托管在Google上。我们可以直接在应用程序中使用它以节省带宽。
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We're using version 1.4.2 of jQuery here. Now, let's look at the actual jQuery
    function for handling the submission of the form while searching for a photo using
    a tag.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的是jQuery 1.4.2版本。现在，让我们看一下处理表单提交并搜索标签的照片的实际jQuery函数。
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we've attached an event handler to a form with ID **photoform** to the
    submit event. This function is called whenever the form is submitted. The first
    line stores the value of the textbox, which has ID keyword, to a JavaScript variable
    called `keyword`. The next line shows the **Please wait.**. message in the photo
    container element.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将事件处理程序附加到ID为**photoform**的表单的提交事件上。每当表单提交时，都会调用此函数。第一行将文本框的值（ID为keyword）存储到名为`keyword`的JavaScript变量中。接下来的行在照片容器元素中显示**请等待。**的消息。
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, after that we're using jQuery's powerful `getJSON` function to get the
    JSONP data of from the remote domain. Remember that the variable `data` in the
    callback function holds the JSON data returned from the JSONP API call.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在此之后，我们使用jQuery强大的`getJSON`函数从远程域获取JSONP数据。请记住，回调函数中的变量`data`保存了从JSONP API调用返回的JSON数据。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding API call, we've specified the `jsoncallback` parameter, which
    is set to `?`. This means that jQuery automatically replaces `?` with a correct
    method name, automatically calling our specific callback.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的API调用中，我们指定了`jsoncallback`参数，设置为`?`。这意味着jQuery会自动用正确的方法名替换`?`，自动调用我们指定的回调函数。
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code removes the elements that are child nodes of the photo container
    that is, `#photo`. Before looking at how JSON data is parsed and displayed using
    jQuery, let's first look at the sample JSON response sent by the Flickr feed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码删除了照片容器的子节点元素，即`#photo`。在查看如何使用jQuery解析和显示JSON数据之前，让我们先看一下Flickr源发送的示例JSON响应。
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After looking at the preceding response format, now let's look at how preceding
    JSON response is parsed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了前面的响应格式之后，现在让我们看看如何解析前面的JSON响应。
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you know `data` is a variable that holds the JSON data. The `data.items`
    array holds individual items of the response. This data is looped over using the
    `each()` function of jQuery. The callback function of the `each()` function accepts
    two arguments; the first one is the index and the second one is the value itself.
    As you can see above in the JSON response format response, the image URL of Flickr
    can be accessed from the loop using the `item.media.m` variable. The `append()`
    function of jQuery is used to append the images to the photo container element.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，`data`是一个保存JSON数据的变量。`data.items`数组保存了响应的各个项目。使用jQuery的`each()`函数循环遍历这些数据。`each()`函数的回调函数接受两个参数；第一个是索引，第二个是值本身。如您在上面的JSON响应格式中所见，可以使用`item.media.m`变量从循环中访问Flickr的图像URL。使用jQuery的`append()`函数将图像附加到照片容器元素。
- en: And there is a `return false`; statement at the end of the callback of the form
    `submit()` function to prevent the form from submitting, which leads to reloading
    the page.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`submit()`函数的回调结束处有一个`return false`;语句，以防止表单提交，导致页面重新加载。
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There's more...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Apart from JSON, Flickr provides feeds in many different formats like RSS, Atom,
    SQL, YAML, and so on. You can use these formats of feeds according to your application
    needs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了JSON之外，Flickr还提供许多不同格式的源，如RSS、Atom、SQL、YAML等。您可以根据应用程序的需要使用这些源的格式。
- en: If you need more functions of the Flickr API, like uploading photos, getting
    friend's photos, and so on, then you can look at Flickr's API in detail at [http://www.flickr.com/services/api/](http://www.flickr.com/services/api/).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要Flickr API的更多功能，比如上传照片、获取朋友的照片等，那么您可以在[http://www.flickr.com/services/api/](http://www.flickr.com/services/api/)上详细了解Flickr的API。
- en: Using Twitter API with Ajax
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ajax调用Twitter API
- en: In this section, we will see how to create a tool using PHP and Ajax that uses
    Twitter search API to retrieve the tweets from the user containing the searched
    for keyword. We will use Ajax, PHP, and Twitter API to make this tool.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何使用PHP和Ajax创建一个工具，该工具使用Twitter搜索API从用户那里检索包含搜索关键字的推文。我们将使用Ajax、PHP和Twitter
    API来制作这个工具。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'You can call the Twitter search API as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式调用Twitter搜索API：
- en: '[http://search.twitter.com/search.format?q=your_query_string](http://search.twitter.com/search.format?q=your_query_string)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://search.twitter.com/search.format?q=your_query_string](http://search.twitter.com/search.format?q=your_query_string)'
- en: In the previous call, the `format` can be replaced with `json` or `atom`. Furthermore,
    we can make a JSONP call with the extra `callback` parameter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的调用中，`format`可以替换为`json`或`atom`。此外，我们可以使用额外的`callback`参数进行JSONP调用。
- en: '[http://search.twitter.com/search.format?q=your_query_string&callback=?](http://search.twitter.com/search.format?q=your_query_string&callback=?)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://search.twitter.com/search.format?q=your_query_string&callback=?](http://search.twitter.com/search.format?q=your_query_string&callback=?)'
- en: 'Let''s suppose we want to search tweets with **php** in the search keyword
    and have the response in JSON format; then we can call the Twitter API like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要搜索包含**php**的推文，并以JSON格式获取响应；那么我们可以这样调用Twitter API：
- en: '[http://search.twitter.com/search.json?q=php](http://search.twitter.com/search.json?q=php)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://search.twitter.com/search.json?q=php](http://search.twitter.com/search.json?q=php)'
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Here you can see the interface of the Twitter search application using Ajax.
    This is a very simple interface with minimal CSS. There is a textbox where user
    the enters the search keyword and hits the **Search** button. This search keyword
    is passed to the PHP script via Ajax and the PHP script gets the result from Twitter
    by calling the Twitter API.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到Twitter搜索应用程序的接口，使用Ajax。这是一个非常简单的界面，只有最少的CSS。有一个文本框，用户输入搜索关键字并点击“搜索”按钮。这个搜索关键字通过Ajax传递给PHP脚本，PHP脚本通过调用Twitter
    API获取结果。
- en: '![How to do it...](graphics/3081_08_02.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/3081_08_02.jpg)'
- en: Now, let's look at the code of this application. There are two files associated
    with this example. One file is `example-3.html` which has the JavaScript, CSS,
    and HTML code for the front-end operations. The other is the `twitter.php` file
    that is called via Ajax to fetch the result from Twitter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下这个应用程序的代码。与此示例相关联的有两个文件。一个文件是`example-3.html`，其中包含用于前端操作的JavaScript、CSS和HTML代码。另一个是`twitter.php`文件，通过Ajax调用以从Twitter获取结果。
- en: First, let's look at the code of `example-3.html:`
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下`example-3.html`的代码：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we can see in the preceding code, there is an Ajax call to the `twitter.php`
    file. Let''s see the code of the `twitter.php` file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中看到的，有一个Ajax调用`twitter.php`文件。让我们看一下`twitter.php`文件的代码：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After looking at the code and its interface, now let's look at how it really
    works in detail.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看代码及其界面之后，现在让我们详细了解它是如何工作的。
- en: First, let's look at the `example-1.html` file. It has CSS styles at the top
    that we don't need much explanation about.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下`example-1.html`文件。它在顶部有CSS样式，我们不需要太多解释。
- en: Furthermore, the HTML code is also self-explanatory; I think you will not have
    a hard time trying to understand it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，HTML代码也是不言自明的；我认为你不会在尝试理解它时遇到太多困难。
- en: 'Let''s jump to the jQuery code and understand it:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳转到jQuery代码并理解它：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we've assigned the value of the textbox with ID `keyword` to the JavaScript
    variable called `keyword`. After that, we've put the informative message to the
    element with ID `tweets` to show it until the response is received from Ajax.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将ID为`keyword`的文本框的值分配给名为`keyword`的JavaScript变量。之后，我们将信息性消息放到ID为`tweets`的元素中，以显示它，直到从Ajax接收到响应为止。
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, in the preceding code, we''re calling the Ajax function of jQuery with
    a parameter query that has the value of the text entered in the textbox. Once
    the Ajax request is completed, the successful response is inserted into the #tweets.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在前面的代码中，我们使用了jQuery的Ajax函数调用，并传递了一个参数查询，该参数具有文本框中输入的值。一旦Ajax请求完成，成功的响应将插入到#tweets中。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the type of request is not specified in jQuery's Ajax function, the default
    request type will be GET.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在jQuery的Ajax函数中未指定请求类型，则默认请求类型将为GET。
- en: 'As we''ve seen in the preceding code, there is an Ajax call to `twitter.php`.
    Now, lets'' go through the code of the `twitter.php` script:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中看到的，有一个Ajax调用`twitter.php`。现在，让我们看一下`twitter.php`脚本的代码：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: These first two lines are the key lines of the code. In the first line, we're
    getting the content of the search result from Twitter using the `file_get_contents()`
    function of PHP. The response is then stored in the `$raw_data` variable. In the
    second line, the JSON data is converted into PHP variables using the `json_decode()`
    function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这前两行是代码的关键部分。在第一行中，我们使用PHP的`file_get_contents()`函数从Twitter获取搜索结果的内容。然后将响应存储在`$raw_data`变量中。在第二行中，使用`json_decode()`函数将JSON数据转换为PHP变量。
- en: 'Before looking at the remaining part, let''s look at the JSON response we get
    from Twitter API with the search API call:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看剩余部分之前，让我们看一下我们从Twitter API获得的JSON响应，使用搜索API调用：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see the sample JSON response from Twitter in the preceding code snippet,
    the response is available in the results variable in the form of an array. Now,
    let's look at the PHP code that is used to parse the preceding response.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码片段中看到的，来自Twitter的示例JSON响应，响应以数组形式在results变量中可用。现在，让我们看一下用于解析前面响应的PHP代码。
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see in the previous code, first we're counting of the number of tweets
    returned as JSON data. If there are more than zero results then we're parsing
    each individual tweets and displaying them on `li` elements.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，首先我们计算返回的JSON数据中的推文数量。如果结果大于零，则我们解析每条推文并在`li`元素上显示它们。
- en: Translating text using Google Ajax API
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Google Ajax API翻译文本
- en: In this section, we will look at the Google Ajax API to translate text from
    one language to other languages. Google provides Ajax APIs for a large set of
    operations, like for Google Map, language translation, charts, and so on. In this
    part, we will look at how to use Google translate Ajax API to translate text from
    one language to another language.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下Google Ajax API，将文本从一种语言翻译成其他语言。Google为一系列操作提供了Ajax API，例如Google地图、语言翻译、图表等。在本部分中，我们将看一下如何使用Google翻译Ajax
    API将文本从一种语言翻译成另一种语言。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To use the Google Ajax API, we first need to sign up the key for your particular
    domain. You can get the API key for Google Ajax API form this URL: [http://code.google.com/apis/loader/signup.html](http://code.google.com/apis/loader/signup.html).
    After getting the API key, you can insert the Google API with the following URL:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Google Ajax API，我们首先需要为您的特定域名注册密钥。您可以从以下URL获取Google Ajax API的API密钥：[http://code.google.com/apis/loader/signup.html](http://code.google.com/apis/loader/signup.html)。获得API密钥后，您可以使用以下URL插入Google
    API：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, after calling the URL, we can load the particular module for the application.
    Let''s say we''re going to use the Ajax language API; then we can load it like
    this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在调用URL之后，我们可以为应用程序加载特定的模块。假设我们要使用Ajax语言API；那么我们可以这样加载它：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: where the first parameter is the module you want to use on your page. Here,
    we're using the language module. The second argument is the version of the particular
    module, which is 1 here in the preceding example.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是您想要在页面上使用的模块。在这里，我们使用的是语言模块。第二个参数是特定模块的版本，在前面的示例中是1。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is also a third parameter in the `load()` function, which is `packages`.
    This is optional and can be used when required. For example, to load Google visualization
    module with the corechart package we use the following code: `google.load(''visualization'',
    ''1'', {''packages'':[''corechart'']})`;'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()`函数中还有第三个参数，即`packages`。这是可选的，可以根据需要使用。例如，要加载带有corechart包的Google可视化模块，我们使用以下代码：`google.load(''visualization'',
    ''1'', {''packages'':[''corechart'']})`；'
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, let's take a look at the interface of the language translation tool that
    we have built using the help of the Google translate API.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一下我们使用Google翻译API构建的语言翻译工具的界面。
- en: '![How to do it...](graphics/3081_08_03.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/3081_08_03.jpg)'
- en: As you can see in the preceding screenshot, the interface is simple and minimal.
    There is a text area where you can enter the text to be translated. Below that,
    there is select dropdown where you can select the language to which the preceding
    text needs to be translated. For the example, in this application we've added
    just 5 popular languages in the dropdown.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一个屏幕截图中所看到的，界面简单而简洁。有一个文本区域，您可以在其中输入要翻译的文本。在下面，有一个下拉选择框，您可以选择要将前面的文本翻译成的语言。在这个应用程序中，我们只在下拉菜单中添加了5种流行的语言。
- en: 'There are more languages that Google supports in the translation API. Google
    keeps on adding more language support so for the latest language support, please
    look at the URL for the latest list of languages supported: [http://code.google.com/apis/language/translate/v1/getting_started.html#translatableLanguages](http://code.google.com/apis/language/translate/v1/getting_started.html#translatableLanguages).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Google支持更多的语言在翻译API中。Google不断添加更多的语言支持，因此对于最新的语言支持，请查看支持的最新语言列表的URL：[http://code.google.com/apis/language/translate/v1/getting_started.html#translatableLanguages](http://code.google.com/apis/language/translate/v1/getting_started.html#translatableLanguages)。
- en: After looking at this tool's interface, now let's look at its code to explore
    how it actually works.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了这个工具的界面之后，现在让我们来看一下它的代码，探索它是如何实际工作的。
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After looking at the code, let's look at the details of the main part of the
    code to see how it works.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了代码之后，让我们来看一下代码的主要部分的详细信息，看看它是如何工作的。
- en: 'First, let''s look at how the JavaScript API is loaded:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一下JavaScript API是如何加载的：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We're calling the JavaScript API of Google with our API key. After that, in
    the next line of code, we're loading the language module of Google API.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们的API密钥调用Google的JavaScript API。之后，在代码的下一行，我们加载了Google API的语言模块。
- en: 'Now, let''s look at the definition of the form:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下表单的定义：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see in the preceding, we're calling the `translate_text()` function
    on the submit action of the form. And also remember that the `onsubmit` event
    is expecting a return type. If the return type is `true` the form gets submitted
    otherwise the submit event is not fired.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面所看到的，我们在表单的提交操作上调用了`translate_text()`函数。还要记住`onsubmit`事件需要一个返回类型。如果返回类型是`true`，则表单被提交，否则提交事件不会被触发。
- en: Now, let's look at the `translate_text()` function of JavaScript.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下JavaScript的`translate_text()`函数。
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the first two lines of the preceding listing, we're assigning the values
    to the variables `text` and `lang`, which hold the content to be translated and
    language to which that content needs to be translated.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表的前两行中，我们为变量`text`和`lang`分配了值，它们保存了要翻译的内容和需要将该内容翻译成的语言。
- en: Then, in the next 4 lines of the listing, we're just validating whether the
    `text` variable is empty or not. If the content to translate passed is empty,
    `false` is returned to the calling function.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在列表的接下来的4行中，我们只是验证`text`变量是否为空。如果要翻译的内容为空，则返回`false`给调用函数。
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The user can simply put a space in the textarea to bypass the preceding validation.
    JavaScript doesn't have a built-in `trim()` function like PHP. You can write your
    own or if you're already using a JavaScript library like jQuery in your application
    those libraries usually provide the `trim()` function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以简单地在文本框中输入空格以绕过前面的验证。JavaScript没有像PHP那样内置的`trim()`函数。您可以编写自己的函数，或者如果您已经在应用程序中使用了JavaScript库，如jQuery，这些库通常提供`trim()`函数。
- en: 'Now, let''s look at the main part of the Google translate API code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下谷歌翻译API代码的主要部分：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see in the preceding code, the API has a `translate()` function
    with 4 parameters. Let''s look at each of them:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码中所示，API具有带有4个参数的`translate()`函数。让我们逐个来看：
- en: Text - This parameter contains the text or content that needs to be translated.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本 - 此参数包含需要翻译的文本或内容。
- en: Source language - This parameter is the source language of the text or content
    provided. As you can see in the preceding listing it's blank. If blank, we ask
    the function to auto-detect the source language.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源语言 - 此参数是提供的文本或内容的源语言。如前面的清单中所示，它是空白的。如果为空白，我们要求函数自动检测源语言。
- en: Destination language - This parameter is the destination language to which the
    text needs to be translated. In our case, this variable is the value of the selected
    language from the dropdown.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标语言 - 此参数是需要翻译的文本的目标语言。在我们的情况下，此变量是从下拉菜单中选择的语言的值。
- en: Callback function - The fourth parameter is the callback function that receives
    the result of the translation.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数 - 第四个参数是接收翻译结果的回调函数。
- en: On the callback function, we're checking first if the result of the translation
    is empty or not. If it is not empty, we're displaying the translated text on the`<div>`
    element with ID `translated_text`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调函数中，我们首先检查翻译结果是否为空。如果不为空，我们将在ID为`translated_text`的`<div>`元素上显示翻译后的文本。
- en: Using Google Maps
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用谷歌地图
- en: Google Maps, probably the most popular mapping service on the Web, is the mapping
    application provided by Google free of cost. Google Maps contains a powerful API,
    by using which Google Maps can be used by different third-party websites for various
    purposes like route planning, finding driving directions and distance, and so
    on.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌地图可能是网络上最受欢迎的地图服务，是谷歌免费提供的地图应用程序。谷歌地图包含强大的API，通过使用这些API，不同的第三方网站可以用于各种目的，如路线规划、查找驾驶路线和距离等。
- en: Google Maps is becoming a very powerful and useful tool day by day as it's been
    widely used by many review-based service applications and many popular mobile
    applications.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌地图正在变得越来越强大和有用，因为它被许多基于评论的服务应用程序和许多流行的移动应用程序广泛使用。
- en: In this section, we will learn how to embed a Google map to a web page.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何将谷歌地图嵌入到网页中。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: A Google Map can be embedded in a website using a simple`<Iframe>` code that
    is basically used for displaying the map of a particular location or highlighting
    the landmarks of the location. It can't be used for Google Map API interactions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用简单的`<Iframe>`代码将谷歌地图嵌入网站，该代码基本上用于显示特定位置的地图或突出显示该位置的地标。它不能用于谷歌地图API交互。
- en: '![Getting ready](graphics/3081_08_04.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: 准备就绪
- en: As you can see the previous image, you can get the Iframe code of the particular
    location from the Google map by clicking the **Link** tab.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的图像所示，您可以通过单击**链接**选项卡从谷歌地图中获取特定位置的Iframe代码。
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: But rather than using`<iframe>`, we're more interested in using the JavaScript
    API on the Google Map. So, let's look at an example of using the JavaScript API
    to use the Google Map in a web page.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们更感兴趣的是使用谷歌地图的JavaScript API，而不是使用`<iframe>`。因此，让我们看一个在网页中使用JavaScript API使用谷歌地图的示例。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, we're using the Google Map JavaScript API version 3.0. The code
    of the other versions of Google Map API might differ. Furthermore, version 3 doesn't
    need an API key to make the call to Google Map API.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用的是谷歌地图JavaScript API版本3.0。其他版本的谷歌地图API的代码可能有所不同。此外，版本3不需要API密钥来调用谷歌地图API。
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, let's try to understand the preceding code in detail.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细了解前面的代码。
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is the container where the map is shown. You can see in the CSS styling
    that defines this container defined with the width of 500 pixels and height of
    500 pixels. You can also see that the `showmap()` function is called when a page
    is fully loaded on the `onload()` event.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是地图显示的容器。您可以在CSS样式中看到，该容器定义为宽度为500像素，高度为500像素。您还可以看到在`onload()`事件上完全加载页面时调用`showmap()`函数。
- en: Now, Google Map JavaScript API can be used in a web page by including the JavaScript
    file of the following URL in a web page.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以通过在网页中包含以下URL的JavaScript文件来使用谷歌地图JavaScript API。
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can see there is a `sensor` parameter specified to `false`. You must specify
    this parameter explicitly. This parameter specifies whether our map-based application
    is using a sensor to determine the user's location or not.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`sensor`参数被指定为`false`。您必须明确指定此参数。此参数指定我们的基于地图的应用程序是否使用传感器来确定用户的位置。
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sensor is usually set to `true` on applications like the GPS locators that are
    widely used on mobile phones.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器通常在诸如广泛用于手机的GPS定位器之类的应用程序上设置为`true`。
- en: 'Now let''s look at the code of the `showmap()` function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`showmap()`函数的代码：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the first line, we're creating the object `Lat_lng` of `latLng` class and
    there are two parameters passed to the constructor. The first parameter is latitude
    and the second parameter is longitude. The latitude and longitude values given
    in the above examples are of Kathmandu, Nepal.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们创建了`latLng`类的`Lat_lng`对象，并向构造函数传递了两个参数。第一个参数是纬度，第二个参数是经度。上面示例中给出的纬度和经度值是尼泊尔加德满都的。
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the other line we''re creating the `map_options` object for setting different
    options of the map. The center of the map is specified with the `lat_lng` object.
    The zoom level of the map is set to 18\. The third setting is `mapTypeId`, which
    is set to `google.maps.MapTypeId.SATELLITE` for a photographic satellite map.
    Other than this, there are three other map types that are supported:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一行中，我们创建了`map_options`对象来设置地图的不同选项。地图的中心由`lat_lng`对象指定。地图的缩放级别设置为18。第三个设置是`mapTypeId`，设置为`google.maps.MapTypeId.SATELLITE`以获取卫星地图。除此之外，还支持其他三种地图类型：
- en: '`google.maps.MapTypeId.ROADMAP` this is the default 2D tile you see on Google
    Maps.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google.maps.MapTypeId.ROADMAP` 这是您在Google地图上看到的默认2D瓦片。'
- en: '`google.maps.MapTypeId.HYBRID` this is a kind of satellite map with the feature
    of showing prominent landmarks.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google.maps.MapTypeId.HYBRID` 这是一种带有显示显著地标的卫星地图。'
- en: '`google.maps.MapTypeId.TERRAIN` this type is used for displaying a physical
    map based on terrain information.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google.maps.MapTypeId.TERRAIN` 这种类型用于显示基于地形信息的物理地图。'
- en: And finally, using the elementary `google.maps.Map` object we'll display the
    map in the specified container.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用基本的`google.maps.Map`对象，我们将在指定的容器中显示地图。
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first parameter of this object is the DOM object of the container to show
    the map and the second parameter is the options of the map that we've earlier
    defined in the `map_options` object.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '该对象的第一个参数是要显示地图的容器的DOM对象，第二个参数是我们之前在`map_options`对象中定义的地图选项。 '
- en: How it works...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Now let's look at how the Google map looks after it's on the web page with the
    above code. This is the satellite map of the center point of Kathmandu, Nepal.
    This is just a simple Google map where you can use functionalities like zooming
    the map, dragging the map to see other places, and viewing different types of
    Map like Satellite, Roadmap or Terrain.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看上述代码在网页上的Google地图是什么样子。这是尼泊尔加德满都中心点的卫星地图。这只是一个简单的Google地图，您可以使用缩放地图、拖动地图查看其他地方以及查看卫星、路线图或地形等不同类型的地图功能。
- en: '![How it works...](graphics/3081_08_05.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/3081_08_05.jpg)'
- en: Searching a location within a Google Map
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Google地图中搜索位置
- en: After looking at how to use the Google Map JavaScript API to embed a map in
    a web page, now let's look at a simple application to search the location within
    the Google Map using Google Map API's `GeoCoder()` class.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解如何使用Google地图JavaScript API在网页中嵌入地图之后，现在让我们看一个简单的应用程序，使用Google地图API的`GeoCoder()`类在Google地图中搜索位置。
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This tool has a very simple application with a simple interface. You can view
    its interface in the following image. It has a simple textbox where you can enter
    the values. The value can be any location, city, or landmark in the world. Then,
    the Google API's *geocoder* will find the location and point to it. The map will
    be centered to the location we're searching for, if that location is found. A
    red marker, which is the default marker provided by Google Map API, will be placed
    on the found location on the map.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具有一个非常简单的应用程序和一个简单的界面。您可以在以下图像中查看其界面。它有一个简单的文本框，您可以在其中输入值。该值可以是世界上的任何位置、城市或地标。然后，Google
    API的*geocoder*将找到该位置并指向它。如果找到该位置，地图将以我们搜索的位置为中心。在地图上找到的位置上会放置一个红色标记，这是Google地图API提供的默认标记。
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Geocoding is the process of converting an address like "619 Escuela Ave, Mountain
    View, CA" to a geographical coordinate system (37.394011, -122.095528) that is,
    into latitude and longitude.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 地理编码是将地址（如"619 Escuela Ave, Mountain View, CA"）转换为地理坐标系（37.394011，-122.095528）的过程，即纬度和经度。
- en: When you click on the red marker, a small information window opens that shows
    the full address location returned by Google Map API of the place we're searching
    for.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当您单击红色标记时，会打开一个小信息窗口，显示Google地图API返回的完整地址位置，这是我们正在搜索的地方。
- en: '![Getting ready](graphics/3081_08_06.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](graphics/3081_08_06.jpg)'
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: After looking at how this application's interface works, let's look at the code
    for it. We're using different classes of Google Map API here in this tool. Here
    is the code of the listing that you can find in `example-6.html` in the source
    code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了该应用程序的界面工作原理之后，让我们看看它的代码。我们在这个工具中使用了Google地图API的不同类。以下是您可以在源代码中的`example-6.html`中找到的列表的代码。
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After looking at the code, now let's have a look at the details of how the code
    of this application really works.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看代码之后，现在让我们看看这个应用程序的代码是如何真正工作的。
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There are four global JavaScript variables defined in this application. One
    is for the map object, another for the geocoder object of the API, the next one
    is a temporary variable for storing a marker to clear later on—the `temp_mark`
    variable is tricky here and you'll see how it is used for clearing the marker
    from the map because Google MAP v3 doesn't have any predefined function to clear
    markers form the map. The fourth global variable defined in our application is
    for storing the information window object. After looking at the global JavaScript
    variables, let's now look at the different JavaScript functions that are called
    from different events.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在该应用程序中定义了四个全局JavaScript变量。一个是地图对象，另一个是API的地理编码器对象，下一个是一个临时变量，用于存储稍后清除的标记——`temp_mark`变量在这里有点棘手，您将看到它是如何用于从地图上清除标记的，因为Google
    MAP v3没有任何预定义的函数来清除地图上的标记。我们应用程序中定义的第四个全局变量用于存储信息窗口对象。在查看全局JavaScript变量之后，现在让我们看看从不同事件中调用的不同JavaScript函数。
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see in the preceding snippet clearly, the `showmap()` function is
    called when the page is loaded.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的片段中清楚地看到的，当页面加载时调用`showmap()`函数。
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There is another function `show_address_in_map()`, which is called when we try
    to submit a form and this function returns the `false` value to prevent the form
    from being submitted, which would lead to reloading the page.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个函数`show_address_in_map()`，当我们尝试提交表单时调用该函数，并且该函数返回`false`值以防止提交表单，这将导致重新加载页面。
- en: Now first, let's have a look at the details of the `show_map()` function; it
    is very similar to the `show_map()` function defined in the last recipe using
    Google Maps. A few differences are that we've moved the `map_obj` variable from
    a local variable to a global variable. Furthermore, the map type we're using here
    in this application is `ROADMAP`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在首先让我们看一下`show_map()`函数的细节；它与上一个使用Google Maps定义的`show_map()`函数非常相似。一些不同之处在于我们将`map_obj`变量从局部变量移动到全局变量。此外，我们在此应用程序中使用的地图类型是`ROADMAP`。
- en: Now, let's go through the code of another function called `show_address_in_map()`,
    which is called when a form is submitted.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下另一个名为`show_address_in_map()`的函数的代码，当表单提交时调用该函数。
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the first line of the code, we're declaring a object of the `Geocoder()`
    class. This is one of the main classes of this application; the object of this
    class sends the geocode request to the server. In another line, we're assigning
    the value of the searched address to the `address` variable.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第一行，我们声明了`Geocoder()`类的对象。这是该应用程序的主要类之一；这个类的对象向服务器发送地理编码请求。在另一行中，我们将搜索地址的值分配给`address`变量。
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here, we''re sending `geocode` the request to the server with the address parameter
    assigned to the `address` variable. When there is a result, it calls the callback
    function. This function has two parameters:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`geocode`向服务器发送带有地址参数分配给`address`变量的请求。当有结果时，调用回调函数。这个函数有两个参数：
- en: The first one is the result array of the `GeocoderResult` object.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是`GeocoderResult`对象的结果数组。
- en: The second parameter is an object of the `GeocoderStatus` class.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是`GeocoderStatus`类的对象。
- en: You can read more details of the Geocoder class from the Google Map API's page
    at [http://code.google.com/apis/maps/documentation/javascript/reference.html#Geocoder](http://code.google.com/apis/maps/documentation/javascript/reference.html#Geocoder).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Google地图API页面[http://code.google.com/apis/maps/documentation/javascript/reference.html#Geocoder](http://code.google.com/apis/maps/documentation/javascript/reference.html#Geocoder)了解Geocoder类的更多细节。
- en: On the callback function, we're checking the status of the result by comparing
    it with the variable `google.maps.GeocoderStatus.OK`, which means that the results
    variable contains a valid geocoder reponse.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调函数中，我们通过将其与变量`google.maps.GeocoderStatus.OK`进行比较来检查结果的状态，这意味着结果变量包含有效的地理编码器响应。
- en: On the next line, we're using the `setCenter()` method of `google.maps.Map`
    class to center the map to the location of the first result returned by the `getcode()`
    method.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们使用`google.maps.Map`类的`setCenter()`方法将地图居中到`getcode()`方法返回的第一个结果的位置。
- en: Now let's have look at the response format, that is, the format of the results
    variable to understand the remaining part of the code. This format gives a clear
    understanding of the response object.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下响应格式，即结果变量的格式，以了解代码的其余部分。这个格式清楚地解释了响应对象。
- en: '[PRE45]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `results[0].geometry.location` variable is an object of the `google.maps.LatLng`
    type and this is the latitude and longitude together. We're using the `results[0]`
    variable here because the first result returned by the geocoder is the most relevant
    result for the searched address.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`results[0].geometry.location`变量是`google.maps.LatLng`类型的对象，这是纬度和经度的组合。我们在这里使用`results[0]`变量，因为地理编码器返回的第一个结果是搜索地址的最相关结果。'
- en: 'Now, let''s proceed further to the other part of the code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进一步进行代码的另一部分：
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the above listing of the code, we're first checking whether the `temp_marker`
    variable is empty or not. If this variable is not set or empty, then no action
    is taken. But if it contains a marker object, then the marker is removed from
    map using the `setMap()` function. The `setMap()` function is basically used for
    assigning a marker to the map object but when it is set to `null`, it removes
    the marker from the map.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码清单中，我们首先检查`temp_marker`变量是否为空。如果此变量未设置或为空，则不采取任何操作。但如果它包含一个标记对象，则使用`setMap()`函数从地图中移除标记。`setMap()`函数基本上用于将标记分配给地图对象，但当它设置为`null`时，它会从地图中移除标记。
- en: On the next line, we're creating the marker object on the `map_obj` map object
    and the position of the marker will be the first result of the position returned
    by the geocoding service.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们在`map_obj`地图对象上创建标记对象，标记的位置将是地理编码服务返回的位置的第一个结果。
- en: And on the next line, the `temp_mark` variable is assigned with the marker object
    that is created for clearing the marker later on for the new search result—which
    avoids showing more than one marker on the map.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`temp_mark`变量被分配为为新的搜索结果清除标记而创建的标记对象，这样可以避免在地图上显示多个标记。
- en: 'After creating the marker, now let''s attach the information window to the
    marker:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 创建标记后，现在让我们将信息窗口附加到标记上：
- en: '[PRE47]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The above code creates the information window. The content of the information
    window is set to the formatted result we got as the response of the geocoding
    service.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码创建了信息窗口。信息窗口的内容设置为我们作为地理编码服务响应的格式化结果。
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the above code, we''re attaching the click event to the marker. When it
    is clicked, the information window is opened using the `open()` function. This
    function accepts two arguments: the first one is a map object and the second one
    is an anchor object, and in our case the anchor object is the marker object.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们将点击事件附加到标记上。当点击时，使用`open()`函数打开信息窗口。这个函数接受两个参数：第一个是地图对象，第二个是锚点对象，在我们的例子中，锚点对象是标记对象。
- en: 'The following line is used to alert a popup to display the information and
    status of the address:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行用于警报弹出窗口，显示地址的信息和状态：
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Searching within XX km. radius of Google Maps with markers and Info window
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Google地图上搜索XX公里半径内的标记和信息窗口
- en: 'After looking at how to find the location within a Google Map using a textbox,
    now, let''s move on to a slightly more complex application called a "Resturant
    finder application". This application is a simple but a powerful one. When the
    user enters a place in the textbox, the application looks for the restaurants
    within the radius of the specified number of kilometers from the searched location.
    We will use the Haversine formula to find the circular distance. You can read
    more about it from here: [http://en.wikipedia.org/wiki/Haversine_formula](http://en.wikipedia.org/wiki/Haversine_formula).'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解如何使用文本框在Google地图中找到位置后，现在让我们转向一个稍微复杂的应用程序，称为“餐厅查找应用程序”。这个应用程序简单但功能强大。当用户在文本框中输入一个地点时，应用程序会查找距离搜索位置指定公里数范围内的餐厅。我们将使用Haversine公式来计算圆形距离。您可以从这里了解更多信息：[http://en.wikipedia.org/wiki/Haversine_formula](http://en.wikipedia.org/wiki/Haversine_formula)。
- en: Now, let's have a look at the details of how this application looks and how
    to create it.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下这个应用程序的细节以及如何创建它。
- en: Getting ready
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: After looking at what the application looks like, now let's look at the background
    knowledge required like the Haversine formula and database structure and data
    required for this application.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解应用程序的外观之后，现在让我们看看所需的背景知识，比如Haversine公式和数据库结构以及这个应用程序所需的数据。
- en: Haversine formula for calculating circular distance
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于计算圆形距离的Haversine公式
- en: 'Before getting into the code, first let''s try to understand how to use the
    Haversine formula to calculate the circular distance from one place to another
    place when we''ve longitude and latitude of both places. If you''re good in math,
    the URL [http://en.wikipedia.org/wiki/Haversine_formula](http://en.wikipedia.org/wiki/Haversine_formula)
    in Wikipedia has the in-depth detail about it. For clear understanding of Haversine
    formula, please look at the URL: [http://www.movable-type.co.uk/scripts/latlong.html](http://www.movable-type.co.uk/scripts/latlong.html).
    It has example code in JavaScript as well as a formula in Excel. Referring to
    the above URL, let''s have a look at the Excel formula to calculate the distance
    between two locations which is:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码之前，让我们首先尝试了解如何使用Haversine公式来计算从一个地方到另一个地方的圆形距离，当我们有两个地方的经度和纬度时。如果您擅长数学，维基百科的URL
    [http://en.wikipedia.org/wiki/Haversine_formula](http://en.wikipedia.org/wiki/Haversine_formula)
    中有关于它的深入细节。为了更清楚地理解Haversine公式，请查看URL：[http://www.movable-type.co.uk/scripts/latlong.html](http://www.movable-type.co.uk/scripts/latlong.html)。它还有JavaScript中的示例代码以及Excel中的公式。参考上述URL，让我们看一下用于计算两个位置之间距离的Excel公式：
- en: =6371*ACOS(SIN(RADIANS(lat1))*SIN(RADIANS(lat2))+COS(RADIANS(lat1))*COS(RADIANS(lat2))*COS(RADIANS(lon2)-
    RADIANS(lon1)))
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: =6371*ACOS(SIN(RADIANS(lat1))*SIN(RADIANS(lat2))+COS(RADIANS(lat1))*COS(RADIANS(lat2))*COS(RADIANS(lon2)-
    RADIANS(lon1)))
- en: Note
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the above, 6371 is the radius of the Earth in kilometers. If you want to
    find distance in miles, please replace 6371 with 3959\. Please also note that
    the trigonometry functions accept the angle in radians and not in degrees, so
    angles are converted into radians before passing them.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的公式中，6371是地球的半径（以公里为单位）。如果要以英里为单位计算距离，请将6371替换为3959。还请注意，三角函数接受弧度而不是角度，因此在传递之前将角度转换为弧度。
- en: Now, let's try to convert it into SQL query because that is how we are going
    to use it in this application for finding the distance between two places.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试将其转换为SQL查询，因为这是我们将在这个应用程序中使用它来查找两个地方之间的距离的方式。
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this formula `(lat1, lon1)` is the geographical coordinates of one place
    while `(lat2, lon2)` is the coordinates of another place.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，`(lat1, lon1)`是一个地方的地理坐标，而`(lat2, lon2)`是另一个地方的坐标。
- en: Creating the table
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建表
- en: 'Since this application is based on a database table, now, let''s create the
    table structure for this application. The following is the SQL code to create
    the table that is used for this application:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个应用程序是基于数据库表的，现在让我们为这个应用程序创建表结构。以下是用于此应用程序的表的SQL代码：
- en: '[PRE51]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s try to see the details of the different fields we''ve used for this
    table:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着看一下我们为这个表使用的不同字段的细节：
- en: id - this is the primary key field for this table. The data type of this field
    is integer with a maximum of 11 digits. The `AUTO_INCREMENT` property specifies
    that the value of this field is auto-incremented with 1 (with the previous highest
    value) if this field's value is not specified in the INSERT statement or query.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: id - 这是该表的主键字段。该字段的数据类型为整数，最大为11位数。`AUTO_INCREMENT`属性指定，如果在INSERT语句或查询中未指定该字段的值，则该字段的值将自动递增1（与先前的最高值）。
- en: name - this is a varchar field with a length of 60\. This field holds the name
    of the restaurant in our application. Please increase the size from 60 to more
    if you feel that it's not enough for your application.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: name - 这是一个长度为60的varchar字段。该字段保存我们应用程序中餐厅的名称。如果您觉得60不够，请增加大小。
- en: address - this field is a varchar field with a length of 90\. This field holds
    the address of the restaurant.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: address - 这个字段是一个长度为90的varchar字段。该字段保存餐厅的地址。
- en: lat - This fields holds the latitude value for the location of the particular
    restaurant. We've specified the data type of this field as the float type with
    length of (9,6), which means that it can hold 9 digits with 6 digits of precision
    after the decimal. So, the range of the values this fields falls from 999.999999
    to 999.999999\. Because of the current Google MAP API's zoom level capabilities,
    we don't require more than 6 digits of precision after the decimal.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lat - 这个字段保存特定餐厅位置的纬度值。我们已将该字段的数据类型指定为浮点类型，长度为（9,6），这意味着它可以保存小数点后6位精度的9位数字。因此，该字段的值范围从999.999999到999.999999。由于当前Google地图API的缩放级别功能，我们不需要小数点后超过6位的精度。
- en: lon - this field holds the longitude value of the location of the restaurant.
    The field type and length of field is same as for the lat, which is float and
    (9,6) respectively.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lon - 这个字段保存餐厅位置的经度值。字段类型和字段长度与纬度相同，即浮点型和（9,6）。
- en: 'After looking at the table we''ve used for the application, let''s look at
    the sample data we''re using for this application. We are using very few data
    as it''s just for testing purposes. The following are the SQL statements to create
    the sample data of restaurants:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看我们用于应用程序的表之后，让我们看一下我们用于此应用程序的样本数据。我们只使用了很少的数据，因为这只是用于测试目的。以下是创建餐馆样本数据的SQL语句：
- en: '[PRE52]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You can execute the above SQL code to insert the data in your favorite MySQL
    editor.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在您喜欢的MySQL编辑器中执行上述SQL代码以插入数据。
- en: In this application, we used location data for sample purposes and it has been
    made available for testing. If you want to test the example with more data and
    you know the location of the place but you don't have the geographical coordinate
    data of a location, you can take the help of Google Geocoding API.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们使用了用于示例目的的位置数据，并且已经提供了用于测试。如果您想使用更多数据测试示例，并且您知道地点但没有该地点的地理坐标数据，您可以借助Google地理编码API的帮助。
- en: 'Let''s suppose we want to know the latitude and longitude of the location of
    the place called "Thapathali, Kathmandu"; then we can send the request to Google
    Geocoding API with the following Request URL:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想知道名为“Thapathali, Kathmandu”的地点的纬度和经度；然后我们可以向Google地理编码API发送请求，请求URL如下：
- en: '[http://maps.googleapis.com/maps/api/geocode/json?address=thapathali,kathmandu,Nepal&sensor=false](http://maps.googleapis.com/maps/api/geocode/json?address=thapathali,kathmandu,Nepal&sensor=false)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://maps.googleapis.com/maps/api/geocode/json?address=thapathali,kathmandu,Nepal&sensor=false](http://maps.googleapis.com/maps/api/geocode/json?address=thapathali,kathmandu,Nepal&sensor=false)'
- en: 'where:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '`json` in the URL is the format of the response; if you want the response in
    XML then you can replace `json` by `XML`.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL中的`json`是响应的格式；如果您希望以XML格式获得响应，则可以将`json`替换为`XML`。
- en: The `address` parameter contains the address of the location that you want to
    geocode into latitude and longitude.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address`参数包含您要将地理编码为纬度和经度的位置的地址。'
- en: The response will be in JSON format and you can easily parse it and use it.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将以JSON格式返回，您可以轻松解析并使用它。
- en: How to do it...
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First of all, let's have a look at the interface of this application. There
    is a textbox where users enter the location. Then, using the Google Map API's
    geocoding service and data stored in PHP, we will find the distance within the
    radius of 10 kilometers of the searched place in our example.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下这个应用程序的界面。有一个文本框，用户输入位置。然后，使用Google地图API的地理编码服务和存储在PHP中的数据，我们将在我们的示例中找到搜索地点10公里半径内的距离。
- en: '![How to do it...](graphics/3081_08_07.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/3081_08_07.jpg)'
- en: After looking at some background knowledge required to make the application,
    now, let's look at the code that builds this application.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了制作应用程序所需的一些背景知识之后，现在让我们看一下构建此应用程序的代码。
- en: First, let's look at the code of the `example-7.html` file.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下`example-7.html`文件的代码。
- en: '[PRE53]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After looking at this example, let''s now look at the code of the `restaurant-result.php`
    file that is called from Ajax when the latitude and longitude are submitted from
    the `search_near_by()` function:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了这个示例之后，现在让我们看一下从`search_near_by()`函数提交纬度和经度时从Ajax调用的`restaurant-result.php`文件的代码：
- en: '[PRE54]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After looking at the code, let's try to understand how this application's code
    works. First, let's try to understand the code of the `restaurant-result.php`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看代码之后，让我们试着理解这个应用程序的代码是如何工作的。首先，让我们试着理解`restaurant-result.php`的代码。
- en: '[PRE55]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the above line the RADIUS variable is defined to 10, which means that we're
    searching the region within the radius of 10 kilometers of the location. You can
    change the value here according to your need.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述行中，RADIUS变量定义为10，这意味着我们正在搜索半径为10公里的区域内的位置。您可以根据需要在这里更改值。
- en: '[PRE56]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the first two lines of the preceding code, we're get the values of the latitude
    and longitude from the Ajax call. After that we create the SQL query to find the
    locations within the radius of 10 kilometer distance from the searched location.
    Also note that we're getting the first 10 results from the SQL query.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码的前两行中，我们从Ajax调用中获取纬度和经度的值。之后，我们创建SQL查询，以查找距离搜索位置10公里范围内的位置。还要注意，我们从SQL查询中获取前10个结果。
- en: Now, let's see how to create the XML format that we're using later on to create
    markers.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下如何创建XML格式，以便稍后用于创建标记。
- en: '[PRE57]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: While creating the XML, we're using the `htmlentities()` function to convert
    the special characters like`<, >` into HTML entities like`&gt, &lt`, and so on
    to avoid malformation of the XML data because of these special characters.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建XML时，我们使用`htmlentities()`函数将特殊字符如`<, >`转换为HTML实体，如`&gt, &lt`等，以避免XML数据因这些特殊字符而变形。
- en: 'Let''s have a look at the XML output generated by the `restaurant-result.php`
    script by calling this function on a browser like `restaurant-result.php?lat=27.6862181&lng=85.31491419999998`
    where this specified latitude and longitude belong to the location ''Kupondole,
    Lalitpur, Nepal'':'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在浏览器上调用此函数来查看`restaurant-result.php`脚本生成的XML输出，如`restaurant-result.php?lat=27.6862181&lng=85.31491419999998`，其中指定的纬度和经度属于位置'Kupondole,
    Lalitpur, Nepal'：
- en: '[PRE58]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: After looking at the PHP code and the XML output of the closed restaurants,
    now let's have a look at the JavaScript code in the `example-7.html` file.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了PHP代码和已关闭餐馆的XML输出之后，现在让我们看一下`example-7.html`文件中的JavaScript代码。
- en: First, let's look at the code of the `search_map()` function first.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们先看一下`search_map()`函数的代码。
- en: '[PRE59]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this function `search_map()`, we're using the geocoding functionality of
    the Google Map API to convert the address into latitude and longitude using the
    `geocode()` function. If the address is found and the geocoding result is returned
    successfully, the map is centered to the first location found using `setCenter()`
    function. Then, the `search_near_by()` function is called with the parameter `results[0].geometry.location`,
    which is the object holding latitude and longitude value of the closet matched
    location from the searched address.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`search_map()`函数中，我们使用Google Map API的地理编码功能，使用`geocode()`函数将地址转换为纬度和经度。如果找到地址并且地理编码结果成功返回，地图将使用`setCenter()`函数居中到找到的第一个位置。然后，使用参数`results[0].geometry.location`调用`search_near_by()`函数，这个对象保存了从搜索地址中最接近的位置的纬度和经度值。
- en: 'Now, first let''s look at the first two lines of the `search_near_by()` function:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，首先让我们看一下`search_near_by()`函数的前两行：
- en: '[PRE60]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see clearly, we're making an Ajax request to the the PHP file `restaurant-result.php`
    using jQuery's `get` function that sends the Ajax request with the `get` method.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你清楚地看到的，我们正在使用jQuery的`get`函数向`restaurant-result.php`发送Ajax请求，使用`get`方法发送Ajax请求。
- en: The `data` variable contains the XML response containing the information of
    the closest restaurants found returned from the server-side response.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`变量包含了从服务器端响应返回的最近找到的餐馆信息的XML响应。'
- en: Now, let's look how at the XML response is parsed in the `search_near_by()`
    function in JavaScript.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看JavaScript中`search_near_by()`函数中如何解析XML响应。
- en: '[PRE61]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the above, the `data.documentElement` refers to the root node of the data
    object. The `markers` variable contains nodes with the name marker as it gets
    returned by the `getElemementByTagName()` DOM function.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`data.documentElement`指的是数据对象的根节点。`markers`变量包含了通过`getElemementByTagName()`
    DOM函数返回的名为marker的节点。
- en: After that going through the each XML nodes in the loop, we've called the function
    called `create_marker()` to create the marker of each location returned from XML.
    Please note the `point` variable is an object of `LatLng` class as the `marker`
    class requires it to create the marker.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中遍历每个XML节点之后，我们调用了`create_marker()`函数来创建从XML返回的每个位置的标记。请注意，`point`变量是`LatLng`类的对象，因为`marker`类需要它来创建标记。
- en: 'Now, let''s look at the create marker function that creates the markers and
    information window:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下创建标记的函数，它创建标记和信息窗口：
- en: '[PRE62]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this function, first we're creating an HTML format to show on the information
    window. After that we're creating a marker object and pushing this marker object
    into the `markers_arr` variable. We will use the `markers_arr` to store the `marker`
    object temporarily so it can be cleared from the map later on the next location
    search. Thus, we're attaching a click event to the marker for showing an information
    window with the provided content.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，首先我们创建一个HTML格式来显示在信息窗口上。之后我们创建一个标记对象，并将这个标记对象推入`markers_arr`变量中。我们将使用`markers_arr`临时存储`marker`对象，以便在下一个位置搜索时从地图上清除。因此，我们为标记附加了一个点击事件，以显示提供的内容的信息窗口。
- en: Now, let's have a closer look at the `clear_marker()` function that is called
    from the `search_map()`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看一下从`search_map()`中调用的`clear_marker()`函数。
- en: '[PRE63]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the above function, `markers_arr` is a global array variable and it contains
    the `marker` object stored from the statement `markers_arr.push(marker)`; in the
    `create_markers()` function. Each marker is removed from the map using the `setMap()`
    function with the null parameter. And finally, the global variable `markers_arr`
    is assigned to an empty array to save some memory.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的函数中，`markers_arr`是一个全局数组变量，它包含了从`create_markers()`函数中的语句`markers_arr.push(marker)`存储的`marker`对象。每个标记都使用`setMap()`函数和空参数从地图上移除。最后，全局变量`markers_arr`被赋予一个空数组，以节省一些内存。
- en: Finding a city/country using IP address
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IP地址查找城市/国家
- en: In this section, we will convert an IP address into city and country name. We
    will use the API from [http://www.ipinfodb.com/](http://www.ipinfodb.com/) to
    get the name of the city and country from the IP Address.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将把IP地址转换成城市和国家名称。我们将使用[http://www.ipinfodb.com/](http://www.ipinfodb.com/)的API来从IP地址获取城市和国家的名称。
- en: Getting ready
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: IpInfodb.com is one of the popular web services for providing IP to country
    and city information using its RESTful API.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: IpInfodb.com是一个流行的网络服务，使用其RESTful API提供IP到国家和城市信息。
- en: 'To use this, first you need to get the access key by registering on the website.
    Once you''ve got the API key then you can make the call. Now, let''s understand
    how to make the API call to the website. The API can be called using the following
    Restful API call:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个功能，首先需要在网站上注册并获取访问密钥。一旦获得了API密钥，就可以进行调用。现在，让我们了解如何调用网站的API。可以使用以下Restful
    API调用API：
- en: '[http://api.ipinfodb.com/v3/ip-city/?format=xml&key=<yourkey>&ip=<your ip>](http://api.ipinfodb.com/v3/ip-city/?format=xml&key=<yourkey>&ip=<your)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://api.ipinfodb.com/v3/ip-city/?format=xml&key=<yourkey>&ip=<your ip>](http://api.ipinfodb.com/v3/ip-city/?format=xml&key=<yourkey>&ip=<your)'
- en: where the format value can be XML or JSON.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 其中格式值可以是XML或JSON。
- en: Now, after looking at the request API call, let's look at the response to the
    API call for the IP address of 128.88.69.78.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在查看请求API调用之后，让我们看一下对IP地址128.88.69.78的API调用的响应。
- en: '**<Response>**'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**<Response>**'
- en: '**<statusCode>OK</statusCode>**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**<statusCode>OK</statusCode>**'
- en: '**<statusMessage/>**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**<statusMessage/>**'
- en: '**<ipAddress>128.88.69.78</ipAddress>**'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**<ipAddress>128.88.69.78</ipAddress>**'
- en: '**<countryCode>US</countryCode>**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**<countryCode>US</countryCode>**'
- en: '**<countryName>UNITED STATES</countryName>**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**<countryName>UNITED STATES</countryName>**'
- en: '**<regionName>CALIFORNIA</regionName>**'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**<regionName>加利福尼亚</regionName>**'
- en: '**<cityName>PALO ALTO</cityName>**'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**<cityName>帕洛阿尔托</cityName>**'
- en: '**<zipCode>94304</zipCode>**'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**<zipCode>94304</zipCode>**'
- en: '**<latitude>37.4404</latitude>**'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**<latitude>37.4404</latitude>**'
- en: '**<longitude>-122.14</longitude>**'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**<longitude>-122.14</longitude>**'
- en: '**<timeZone>-08:00</timeZone>**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**<timeZone>-08:00</timeZone>**'
- en: '**</Response>**'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**</Response>**'
- en: The response contains the geographical information about the IP address to which
    it belongs.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 响应包含有关IP地址所属的地理信息。
- en: Note
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Due to the factors like the IP address being looked up from an existing database,
    the response of the API might not be 100% accurate. Furthermore, the response
    for a reserved IP like 127.0.0.1 might not lead to any specific result.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IP地址是从现有数据库中查找的等因素，API的响应可能不会100%准确。此外，保留IP的响应，如127.0.0.1，可能不会导致任何特定结果。
- en: How to do it...
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'After looking at the information about the API of IpInfodb, now let''s look
    at the interface of our application. It has a textbox where you can enter the
    IP address, and the geographic location of the IP address is shown in the following
    format:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了IpInfodb的API信息之后，现在让我们看一下我们应用的界面。它有一个文本框，您可以在其中输入IP地址，并以以下格式显示IP地址的地理位置：
- en: City Name, Region/State/Province Name, Country Name
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 城市名称，地区/州/省名称，国家名称
- en: '![How to do it...](graphics/3081_08_08.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/3081_08_08.jpg)'
- en: Now, let's look at the code that built this application to find the location
    from the IP address.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下构建此应用程序的代码，以查找IP地址的位置。
- en: First, let's have a look at the code of the `example-8.html` file.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下`example-8.html`文件的代码。
- en: '[PRE64]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As you can see in the above code, there is an Ajax call to `ip.php`. Let''s
    look at the PHP code of the `ip.php` file:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示的代码中，有一个对`ip.php`的Ajax调用。让我们来看一下`ip.php`文件的PHP代码：
- en: '[PRE65]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How it works...
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'After looking at the code of the two files `example-8.html` and `ip.php`, now,
    let''s dig through the code of the first. Let''s go through the PHP code of `ip.php`,
    which is called from Ajax:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了两个文件`example-8.html`和`ip.php`的代码之后，现在让我们深入了解第一个文件的代码。让我们看一下从Ajax调用的`ip.php`的PHP代码：
- en: '[PRE66]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As you see above, we''ve used the `filter_var()` along with the `FILTER_VALIDATEIP`
    constant to validate whether the IP address value of the variable `$ip` is a valid
    IP address format or not. This function, introduced in PHP 5.2, is one of the
    powerful validation functions. You can find more about the other filter constants
    that can be used with this function from this URL: [http://www.php.net/manual/en/filter.filters.php](http://www.php.net/manual/en/filter.filters.php).
    If the IP address is not a valid IP address, then we''re assigning the error message
    to the `errormsg` key of the return array.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，我们使用`filter_var()`与`FILTER_VALIDATEIP`常量一起验证变量`$ip`的IP地址值是否为有效的IP地址格式。这个函数是在PHP
    5.2中引入的，是一个强大的验证函数之一。您可以从此URL找到更多关于此函数可用的其他过滤器常量的信息：[http://www.php.net/manual/en/filter.filters.php](http://www.php.net/manual/en/filter.filters.php)。如果IP地址不是有效的IP地址，则将错误消息分配给返回数组的`errormsg`键。
- en: 'Now, let''s look at the API call when the IP address is valid:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下IP地址有效时的API调用：
- en: '[PRE67]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the preceding code, first we're making the string to form the request that
    is then called with `file_get_contents()`. The XML response is then passed to
    the `simplexml_load_string()` function for parsing, it parses the XML data into
    the SimpleXML object of PHP.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，首先我们正在构建字符串以形成请求，然后使用`file_get_contents()`进行调用。然后将XML响应传递给`simplexml_load_string()`函数进行解析，它将XML数据解析为PHP的SimpleXML对象。
- en: Note
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The SimpleXML parser was introduced in PHP 5 and to use functions like `simplexml_load_string()`,
    you need to have the SimpleXML extension installed in PHP.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleXML解析器是在PHP 5中引入的，要使用`simplexml_load_string()`之类的函数，需要在PHP中安装SimpleXML扩展。
- en: '[PRE68]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now here, we're checking the response value `statusCode` node and depending
    upon the value of this we're forming the Ajax response in the `$return_array`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这里，我们正在检查响应值`statusCode`节点，并根据其值形成`$return_array`中的Ajax响应。
- en: Now, we can't pass the `$return_array` directly to JavaScript, as it is an array
    in PHP. It should be converted into a JSON object so it can be accessed easily
    by JavaScript so in the last line, we've used the `json_encode()` function of
    PHP to encode this array to JSON.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不能直接将`$return_array`传递给JavaScript，因为它是PHP中的一个数组。它应该转换为JSON对象，以便JavaScript可以轻松访问，因此在最后一行，我们使用了PHP的`json_encode()`函数将此数组编码为JSON。
- en: '[PRE69]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, let's call `ip.php` with a valid IP address and see the response. For example,
    call
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用有效的IP地址调用`ip.php`并查看响应。例如，调用
- en: '`ip.php?ip=78.41.205.188` and you''ll get the JSON response as shown:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip.php?ip=78.41.205.188`，您将获得如下所示的JSON响应：'
- en: '**{"errormsg":"","city":"AMSTERDAM","country":"NETHERLANDS","region":"NOORD-HOLLAND"}**'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**{"errormsg":"","city":"AMSTERDAM","country":"NETHERLANDS","region":"NOORD-HOLLAND"}**'
- en: Now, let's look at the Ajax call we've used in `example-8.php`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下我们在`example-8.php`中使用的Ajax调用。
- en: '[PRE70]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: As you can see in the above Ajax function, we're looking at the JSON response,
    which is there in the `data` variable. First, we're checking whether there is
    an error message or not by checking the `data.errormsg` variable. If there is
    an error, we're displaying it directly in the div with the ID `result`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在上述Ajax函数中所见，我们正在查看JSON响应，该响应在`data`变量中。首先，我们通过检查`data.errormsg`变量来检查是否有错误消息。如果有错误，我们将直接在ID为`result`的div中显示它。
- en: If there is no error message, then there are values in the `data.city, data.region`,
    and `data.country` variables and the string is formed to show the location information
    on the div with ID `result`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误消息，则`data.city, data.region`和`data.country`变量中有值，并形成字符串以在ID为`result`的div中显示位置信息。
- en: Converting currencies using Ajax and PHP
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ajax和PHP转换货币
- en: In this recipe, we will see how to convert currencies using Ajax and PHP. In
    this example, we will use the API provided by foxrate.org. Forxrate.org has provided
    the web services in the XML-RPC format. We consumed an XML-RPC web service in
    this example.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将看到如何使用Ajax和PHP转换货币。在本示例中，我们将使用foxrate.org提供的API。Forxrate.org以XML-RPC格式提供了Web服务。我们在本示例中使用了XML-RPC
    Web服务。
- en: Getting started
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: 'Foxrate.org''s currency convertor API is located at: [http://foxrate.org/rpc/](http://foxrate.org/rpc/).
    The method name for the XML-RPC call is *foxrate.currencyConvert*. The parameters
    that can be passed to this function are:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: Foxrate.org的货币转换API位于：[http://foxrate.org/rpc/](http://foxrate.org/rpc/)。XML-RPC调用的方法名是*foxrate.currencyConvert*。可以传递给此函数的参数是：
- en: 'From currency This is the code of the currency in which original currency amount
    is in. Examples can be USD or GBP. The list of currency codes of currencies can
    be found here: [http://en.wikipedia.org/wiki/ISO_4217](http://en.wikipedia.org/wiki/ISO_4217).'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从货币这是原始货币金额所在的货币代码。示例可以是美元或英镑。货币代码列表可以在这里找到：[http://en.wikipedia.org/wiki/ISO_4217](http://en.wikipedia.org/wiki/ISO_4217)。
- en: Targetted currency This is the currency code of the targeted currency to which
    the amount needs to be converted.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标货币这是需要将金额转换为的目标货币的货币代码。
- en: Amount The third parameter to the method call is the amount that needs to be
    converted from the original currency to the targeted currency.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金额方法调用的第三个参数是需要从原始货币转换为目标货币的金额。
- en: 'Now, let''s look at what the response of XML-RPC call to `foxrate.currencyConvert`
    looks like:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看对`foxrate.currencyConvert`的XML-RPC调用的响应是什么样的：
- en: '**<methodResponse>**'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**<methodResponse>**'
- en: '**<params>**'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '**<params>**'
- en: '**<param>**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**<param>**'
- en: '**<value>**'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '**<value>**'
- en: '**<struct>**'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**<struct>**'
- en: '**<member><name>flerror</name><value><int>0</int></value></member>**'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '**<member><name>flerror</name><value><int>0</int></value></member>**'
- en: '**<member><name>amount</name><value><double>33.016</double></value></member>**'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**<member><name>amount</name><value><double>33.016</double></value></member>**'
- en: '**<member><name>message</name><value><string>cached</string></value></member>**'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**<member><name>message</name><value><string>cached</string></value></member>**'
- en: '**</struct>**'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '**</struct>**'
- en: '**</value>**'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '**</value>**'
- en: '**</param>**'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**</param>**'
- en: '**</params>**'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '**</params>**'
- en: '**</methodResponse>**'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**</methodResponse>**'
- en: As you can see, its XML-RPC response format has three parameters *flerror, amount*,
    and *message*. The *flerror* contains value 1 if there is error in the call and
    0 if the call is successful. The *amount* is the converted amount and *message*
    contains the error message or other useful messages relating to the call.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它的XML-RPC响应格式有三个参数*flerror, amount*和*message*。*flerror*包含值1，如果调用中有错误，如果调用成功，则为0。*amount*是转换后的金额，*message*包含错误消息或与调用相关的其他有用消息。
- en: How to do it...
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Now, let's look at the interface of this tool. There is a textbox where you
    can enter the amount that needs to be converted into USD. The second one is the
    select dropdown in which you can select the currency from which the amount is
    to be converted into United States dollars. For demonstration purposes, we've
    used only a few popular currencies here in our example.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个工具的界面。有一个文本框，你可以在里面输入需要转换成美元的金额。第二个是下拉选择框，你可以从中选择要将金额从哪种货币转换为美元。为了演示目的，在我们的示例中，我们只使用了一些流行的货币。
- en: '![How to do it...](graphics/3081_08_09.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/3081_08_09.jpg)'
- en: Let's have a look at the code that creates this tool to convert the currency
    using foxrate.org's API. First, let's have a look at the `example-9.html` file.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看创建这个使用foxrate.org的API转换货币的工具的代码。首先，让我们来看看`example-9.html`文件。
- en: '[PRE71]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As you can see in this code, there is an Ajax call to `convert-currency.php`
    using the `load()` function of jQuery. Let's look at the code of `convert-currency.php`,
    which uses the `xml-rpc` function of PHP to call foxrate.org's API.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这段代码中看到的，有一个Ajax调用到`convert-currency.php`，使用jQuery的`load()`函数。让我们看看`convert-currency.php`的代码，它使用PHP的`xml-rpc`函数调用foxrate.org的API。
- en: '[PRE72]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How it works...
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Starting from `example-9.html`, when you click the "Convert to USD" button,
    it will call the event handler of this button at:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 从`example-9.html`开始，当你点击“转换为美元”按钮时，它将调用这个按钮的事件处理程序：
- en: '[PRE73]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In this function, we're validating the amount first as to whether it's a valid
    number or not. For this purpose, there is a function called `isNaN()` in JavaScript
    that checks whether the value is a legal number or not a number. That means *isNan*
    refers to is-Not-a-Number.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先验证金额是否是有效的数字。为此，JavaScript中有一个名为`isNaN()`的函数，用于检查值是否是合法数字或非数字。这意味着*isNan*指的是非数字。
- en: '[PRE74]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now, let's look at the way of using Ajax using the `load()` function of jQuery.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用jQuery的`load()`函数来使用Ajax。
- en: '[PRE75]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The above code makes the Ajax call to the URL in the parenthesis of the `load()`
    function and the response will be injected to the div with ID `output` that is,
    to `#output`.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码通过`load()`函数的括号中的URL进行Ajax调用，响应将被注入到ID为`output`的div中，即`#output`。
- en: Now, let's try to understand the code of the `convert-currency.php` file.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们试着理解`convert-currency.php`文件的代码。
- en: '[PRE76]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This line calls the user-defined function called `convert_currency()`. This
    function accepts three argument, the first one, `$from_curr`, is the currency
    that needs to be converted. `TO_CURRRNCY` is the constant defined as the *USD*
    value and `$amount` is the amount that needs to be converted. Now, let's look
    at the `convert_currency()` function.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行调用了一个名为`convert_currency()`的用户定义函数。这个函数接受三个参数，第一个`$from_curr`是需要转换的货币。`TO_CURRRNCY`是定义为*USD*值的常量，`$amount`是需要转换的金额。现在，让我们看看`convert_currency()`函数。
- en: To encode the XML-RPC request to XML-RPC format, we use the `xmlrpc_encode_request()`
    function generally with two parameters. The first one is the name of the method
    to be called and the second one is the parameter of the XML-RPC call.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将XML-RPC请求编码为XML-RPC格式，我们通常使用`xmlrpc_encode_request()`函数，它有两个参数。第一个是要调用的方法的名称，第二个是XML-RPC调用的参数。
- en: '[PRE77]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Now, the next part is to create the stream context with the request method specifying
    POST as specified by foxrate.org.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，下一步是创建流上下文，请求方法指定为foxrate.org指定的POST。
- en: '[PRE78]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'After creating the content, we''ve the context resource in the `$context` variable
    that can be used with the `file_get_contents()` function:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 创建内容后，我们在`$context`变量中有上下文资源，可以与`file_get_contents()`函数一起使用：
- en: '[PRE79]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: where the second parameter of `file_get_contents()` is to specify the use whether
    to `include_path` value set in `php.ini` or not. We've passed it as a `false`
    here. The `$file` variable contains the XML response in XML-RPC format. Now, we
    need to decode it into native PHP types and `xmlrpc_decode()` decodes the XML-RPC
    response to PHP type variables.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`file_get_contents()`的第二个参数是指定是否在`php.ini`中设置了`include_path`值。我们在这里将其传递为`false`。`$file`变量包含XML-RPC格式的XML响应。现在，我们需要将其解码为本机PHP类型，`xmlrpc_decode()`将XML-RPC响应解码为PHP类型变量。'
- en: '[PRE80]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'After decoding the response to PHP, `var_dump($response)` gives the following
    sample output:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在将响应解码为PHP之后，`var_dump($response)`给出以下示例输出：
- en: '**array(3) {**'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**array(3) {**'
- en: '**["flerror"]=>**'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '["flerror"]=>**'
- en: '**int(0)**'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '**int(0)**'
- en: '**["amount"]=>**'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**["amount"]=>**'
- en: '**float(33.016)**'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**float(33.016)**'
- en: '**["message"]=>**'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '**["message"]=>**'
- en: '**string(6) "cached**"'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '**string(6) "cached**"'
- en: '**}**'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: where you can see that the response is converted into PHP native type variables.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到响应被转换为PHP本机类型变量。
- en: Finally, this `$response` variable is returned from this function and printed
    in the desired output using the `echo` statement.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个`$response`变量从这个函数返回，并使用`echo`语句在所需的输出中打印出来。
