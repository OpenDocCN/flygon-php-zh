- en: Improving RESTful Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进RESTful Web服务
- en: In the previous chapter, we created RESTful web services in Lumen, and we identified
    some missing elements or improvements required. In this chapter, we will work
    on improving that and completing some missing elements. We will improve certain
    elements with respect to fulfilling loopholes and code quality.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在Lumen中创建了RESTful web服务，并且确定了一些缺失的元素或需要改进的地方。在本章中，我们将致力于改进并完成一些缺失的元素。我们将改进某些元素，以满足漏洞和代码质量的要求。
- en: 'We will cover the following topics in this chapter to improve our RESTful web
    service:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题，以改进我们的RESTful web服务：
- en: 'Dingo, simplifying RESTful API development:'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dingo，简化RESTful API开发：
- en: Installing and configuring Dingo API package
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置Dingo API软件包
- en: Simplifying routes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化路由
- en: API versioning
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API版本控制
- en: Rate limiting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制
- en: Internal requests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部请求
- en: Authentication and middleware
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证和中间件
- en: Transformers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换器
- en: 'Need of encryption:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密的需求：
- en: SSL, different options
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSL，不同的选项
- en: Summary
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结
- en: Dingo, simplifying RESTful API development
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dingo，简化RESTful API开发
- en: Yes, you heard it right. I didn't say bingo. It's Dingo. Actually, Dingo API
    is a package for Laravel and Lumen that makes it a lot simpler to develop RESTful
    web services. It provides many features out of the box and many are what we saw
    in the previous chapter. Many of these features will make our existing code better
    and easier to understand and maintain. You can check out the Dingo API package
    at [https://github.com/dingo/api](https://github.com/dingo/api).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你没听错。我没说bingo。是Dingo。实际上，Dingo API是Laravel和Lumen的一个软件包，它使开发RESTful web服务变得更简单。它提供了许多开箱即用的功能，其中许多是我们在上一章中看到的。这些功能中的许多将使我们现有的代码更好，更容易理解和维护。您可以在[https://github.com/dingo/api](https://github.com/dingo/api)上查看Dingo
    API软件包。
- en: Let's first install it, and we will keep looking at its benefits and features
    side by side while using them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先安装它，然后在使用它的同时，我们将继续查看其好处和特性。
- en: Installation and configuration
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置
- en: 'Simply install it through composer:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 只需通过composer安装它：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Probably, you are wondering what this `@dev` is. So, here is what the Dingo
    documentation says:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您想知道这个`@dev`是什么。因此，这是Dingo文档中的内容：
- en: At this time, the package is still in a developmental stage and as such, does
    not have a stable release. You may need to set your minimum stability to dev.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，该软件包仍处于开发阶段，因此没有稳定版本。您可能需要将最低稳定性设置为dev。
- en: If you are still not sure about why we need to set minimum stability, then it
    is because of the default minimum stability for every package that is set to `stable`.
    So, if you rely on the `dev` package, then it should be explicitly specified,
    or it probably will not install it as minimum stability will not match with the
    package's actual stability status.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍然不确定为什么需要设置最低稳定性，那是因为每个软件包的默认最低稳定性设置为`stable`。因此，如果您依赖于`dev`软件包，则应明确指定，否则它可能不会安装，因为最低稳定性与软件包的实际稳定性状态不匹配。
- en: 'Once it is installed, you need to register it. Go to `bootstrap/app.php` and
    put this statement in this file somewhere before `return $app;`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您需要注册它。转到`bootstrap/app.php`并在`return $app;`之前的某个地方放入此语句：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After doing this, there are a few variables you need to set in your `.env`
    file. Add them at the end of the `.env` file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您需要在`.env`文件的末尾设置一些变量。在`.env`文件的末尾添加它们：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Configuration is self-explanatory. Now, let's move forward.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 配置是不言自明的。现在，让我们继续。
- en: Simplifying routes
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化路由
- en: 'If you look at the `routes/web.php` file where we put our routes, you can see
    that we wrote 54 lines of code for post and comment endpoints. With Dingo API,
    we can replace those 54 lines with just 10 lines of code, and it will be even
    more cleaner. So let''s do that. Here is how your `routes/web.php` file should
    look:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看我们放置路由的`routes/web.php`文件，您会发现我们为帖子和评论端点编写了54行代码。使用Dingo API，我们可以用只有10行代码来替换这54行代码，而且它会更加简洁。所以让我们这样做。您的`routes/web.php`文件应该如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we just got the object of the router in `$api`. However, this
    is Dingo API router, not Lumen's default router. As you can see, it has the `resource()`
    method available as we wanted, and we can mention unwanted methods in the `except`
    array. So overall, our routes are now very much simplified.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们刚刚在`$api`中得到了路由的对象。但是，这是Dingo API路由，而不是Lumen的默认路由。正如您所见，它具有我们想要的`resource()`方法，并且我们可以在`except`数组中提及不需要的方法。因此，总的来说，我们的路由现在变得非常简化。
- en: 'To see the exact routes for your application, run the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看应用程序的确切路由，请运行以下命令：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: API versioning
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API版本控制
- en: Probably, you have noticed that in the preceding code example in our route file,
    we already mentioned the API version as `v1`. It is because API versioning is
    important and Dingo provides us the facility to do so. It is useful to serve different
    endpoints from different versions. You can have another version group and can
    serve the same endpoint with different content. If there is the same endpoint
    under different versions, then it will pick the version that is mentioned in your
    `.env` file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您已经注意到，在我们的路由文件中的上一个代码示例中，我们已经将API版本指定为`v1`。这是因为API版本控制很重要，而Dingo为我们提供了这样的功能。它有助于从不同版本提供不同的端点。您可以有另一个版本组，并且可以提供相同端点的不同内容。如果在不同版本下有相同的端点，则它将选择在您的`.env`文件中提到的版本。
- en: 'However, it is better to have version in URI. To do so, we can simply use the
    following prefix:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在URI中包含版本号会更好。为此，我们可以简单地使用以下前缀：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With that now, our routes will include version information in URI. This is
    a recommended approach. Because if someone is working with version 1 and we are
    going to change something in version 2, then the client using version 1 will not
    be affected if they are specifying the version number explicitly in their requests.
    So, our endpoint URLs will be something like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的路由将在URI中包含版本信息。这是一种推荐的方法。因为如果有人正在使用版本1，并且我们将在版本2中进行更改，那么使用版本1的客户端在其请求中明确指定版本号时将不受影响。因此，我们的端点URL将如下所示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, note that if we are having versions in our URI and routes, then it
    is better to keep that version actually applicable in our controllers as well.
    Without that, version implementation will be very limited. To do so, we should
    have a version-based namespace for controllers. In our controllers (both `PostController`
    and `CommentController`), namespace will be changed to the following line of code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，如果我们的URI和路由中有版本，那么最好在我们的控制器中实际应用该版本。如果没有，版本实现将非常有限。为此，我们应该为控制器设置基于版本的命名空间。在我们的控制器（`PostController`和`CommentController`）中，命名空间将更改为以下代码行：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, the controllers directory structure should match the namespace as well.
    So, let's create a directory named `V1` in the `Controllers` directory and move
    our controllers inside the `app\Http\Controllers**\V1**` directory. When we will
    have the next version, we will make another directory named `V2` in `app\Http\Controllers`
    and add new controllers in it. It will also result in a new namespace `App\Http\Controllers**\V2**`.
    With a namespace and directory change, controller's paths in `routes/web.php`
    will also need to be changed accordingly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，控制器目录结构也应该与命名空间匹配。因此，让我们在`Controllers`目录中创建一个名为`V1`的目录，并将我们的控制器移动到`app\Http\Controllers**\V1**`目录中。当我们有下一个版本时，我们将在`app\Http\Controllers`中创建另一个名为`V2`的目录，并在其中添加新的控制器。这也将导致一个新的命名空间`App\Http\Controllers**\V2**`。随着命名空间和目录的更改，`routes/web.php`中的控制器路径也需要相应地进行更改。
- en: 'With this change, you will most probably see the following error:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个改变，你很可能会看到以下错误：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So, either move `Controller.php` in the controllers directory to the `V1` directory
    or simply access it with a complete namespace such as `\App\Http\Controllers\Controller`
    as shown here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要么将`Controller.php`从controllers目录移动到`V1`目录，要么像这样使用完整的命名空间访问它：`\App\Http\Controllers\Controller`
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is up to you how you do it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于你如何做。
- en: Rate limiting
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速率限制
- en: 'Rate limiting is also known as throttling. It means that there should be a
    limit on how much time a particular client is able to hit the API endpoint in
    a specific time interval. To enable it, we must enable the `api.throttling` middleware.
    You can apply throttling on all routes or on specific routes. You will just apply
    middleware on that particular route as shown here. In our case, we want to enable
    it for all endpoints, so let''s put it in a version group:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 速率限制也被称为节流。这意味着应该限制特定客户端在特定时间间隔内能够访问API端点的次数。要启用它，我们必须启用`api.throttling`中间件。您可以在所有路由或特定路由上应用节流。您只需在特定路由上应用中间件，如下所示。在我们的情况下，我们希望为所有端点启用它，所以让我们将其放在一个版本组中：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Just for the sake of simplicity, let''s make a change in routes. Instead of
    specifying namespace with every controller''s name, we can simply use namespace
    in a version group as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，让我们在路由中进行一些更改。我们可以在版本组中使用命名空间，而不是在每个控制器的名称中指定命名空间，如下所示：
- en: '`$api->version(''v1'', [''middleware'' => ''api.throttle'', ''prefix'' => ''api/v1'',
    **namespace => "App\HttpControllers\V1"** **]**`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`$api->version(''v1'', [''middleware'' => ''api.throttle'', ''prefix'' => ''api/v1'',
    **namespace => "App\HttpControllers\V1"** **]**`'
- en: Now, we can simply remove it from the controller path.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以简单地从控制器路径中删除它。
- en: 'You can also mention the limit and time interval in minutes:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在分钟内提及限制和时间间隔：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `expires` is the time interval, while `limit` is the number of times a
    route can be accessed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`expires`是时间间隔，而`limit`是路由可以被访问的次数。
- en: Internal requests
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部请求
- en: We are mostly making an API to be accessed as a web service from the outside
    by an external client, not from the same application. However, sometimes, we are
    in a situation where we need to make internal requests within the same application
    and want data in the same format as it is being returned to external clients.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数情况下是制作一个API，由外部客户端作为Web服务访问，而不是从同一应用程序访问。但是，有时我们处于需要在同一应用程序内进行内部请求并希望以与返回给外部客户端相同的格式返回数据的情况。
- en: 'Let''s say now you want comments data in `PostController` from the API as it
    returns a response instead of an internal function call. We want the same data
    that the `/api/posts/{postId}/comments` endpoint returns when hit from Postman
    or another client. In that case, the Dingo API package helps us. Here is how simple
    it is:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在您希望从API中的`PostController`获取评论数据，因为它返回一个响应而不是内部函数调用。我们希望在Postman或其他客户端访问时，获得与`/api/posts/{postId}/comments`端点返回的相同数据。在这种情况下，Dingo
    API包可以帮助我们。以下是它的简单用法：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Bold statements in the preceding code snippet is what is different, and it
    contributes in making an internal request. As you can say, we have made a `GET`-based
    request to the endpoint:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，加粗的语句是不同的，它有助于进行内部请求。正如您所看到的，我们已经对端点进行了`GET`请求：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also make it a `POST`-based request by just using a different method
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用不同的方法使其成为基于`POST`的请求，如下所示：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Responses
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应
- en: The Dingo API package provides a lot more support for different types of responses.
    As we will not go in to the detail of each and every thing Dingo API provides,
    you can review it in its documentation at [https://github.com/dingo/api/wiki/Responses](https://github.com/dingo/api/wiki/Responses).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Dingo API包为不同类型的响应提供了更多的支持。由于我们不会详细介绍Dingo API提供的每一件事情，您可以在其文档中查看：[https://github.com/dingo/api/wiki/Responses](https://github.com/dingo/api/wiki/Responses)。
- en: However, later in this chapter, we will look at responses and formats in detail.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章的后面，我们将详细了解响应和格式。
- en: We will use the Dingo API package for other things as well, but for now, let's
    move towards other concepts and we will keep using the Dingo API package side
    by side.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在其他方面使用Dingo API包，但现在让我们转向其他概念，我们将继续同时使用Dingo API包。
- en: Authentication and middleware
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证和中间件
- en: We have already discussed several times that for a RESTful web service, a session
    is maintained through an authentication token stored on the client side. So, the
    server can look for the authentication token and can find that user's session
    stored on the server.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次讨论过，对于RESTful Web服务，会话是通过存储在客户端的身份验证令牌来维护的。因此，服务器可以查找身份验证令牌，并且可以在服务器上找到用户的会话。
- en: 'There are several ways to generate a token. In our case, we will use **JWT**
    (**JSON Web Tokens**). As told on `jwt.io`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种生成令牌的方式。在我们的情况下，我们将使用**JWT**（**JSON Web Tokens**）。如在`jwt.io`上所述：
- en: JSON Web Tokens are an open, industry standard RFC 7519 method for representing
    claims securely between two parties.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Web Tokens是一种开放的、行业标准的RFC 7519方法，用于在两个方之间安全地表示声明。
- en: We will not go into complete detail about JWT as JWT is a way to transfer information
    between two parties (in our case, client and server) as JWT can be used for many
    purposes. Instead, we will use it for access/authentication tokens to maintain
    stateless sessions. So, we will stick with what we need from JWT. We need it for
    maintaining sessions for authentication purposes, and this is something the Dingo
    API package will also help us with.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细讨论JWT，因为JWT是在两个方之间传输信息的一种方式（在我们的情况下是客户端和服务器），因为JWT可以用于许多目的。相反，我们将使用它来进行访问/身份验证令牌以维护无状态会话。因此，我们将坚持从JWT中获取我们需要的内容。我们需要它来维护身份验证目的的会话，并且这也是Dingo
    API包将帮助我们解决的问题。
- en: In fact, Dingo API supports three authentication providers at the time of writing
    this book. By default, HTTP Basic Authentication is enabled. The other two are
    JWT Auth and OAuth 2.0\. We will use JWT Auth.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Dingo API在撰写本书时支持三种身份验证提供者。默认情况下启用了HTTP基本身份验证。另外两种是JWT Auth和OAuth 2.0。我们将使用JWT
    Auth。
- en: JWT Auth setup
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JWT Auth设置
- en: The package that Dingo API uses to integrate JWT authentication can be found
    at [https://github.com/tymondesigns/jwt-auth.](https://github.com/tymondesigns/jwt-auth)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Dingo API用于集成JWT身份验证的包可以在[https://github.com/tymondesigns/jwt-auth](https://github.com/tymondesigns/jwt-auth)找到。
- en: "[\uFEFF](https://github.com/tymondesigns/jwt-auth)"
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: "[\uFEFF](https://github.com/tymondesigns/jwt-auth)"
- en: 'There are two ways to set up JWT Auth:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种设置JWT Auth的方式：
- en: We can simply follow instructions for the JWT Auth package and configure it
    to use with Dingo manually and fix problems one by one manually.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以简单地按照JWT Auth包的说明进行配置，并手动修复一个接一个的问题。
- en: We can simply install another package that helps us install and set up Dingo
    API and JWT Auth together with some basic configurations.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以简单地安装另一个包，帮助我们安装和设置Dingo API和JWT Auth，并进行一些基本配置。
- en: Here, we will see both ways. However, with the manual way, it can be ambiguous
    because of different versions of different packages and Lumen itself. So, although
    I am going to show the manual way, I would recommend that you use an integration
    package so that you don't need to deal with every thing at a low level manually.
    I will show you the manual way just to give you some idea of what is included
    underneath.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到两种方式。然而，使用手动方式可能会因不同包的不同版本和Lumen本身而变得模糊。因此，尽管我将展示手动方式，但我建议您使用集成包，这样您就不需要手动处理每个低级别的事情。我将向您展示手动方式，只是为了让您对底层包含的内容有一些了解。
- en: The Manual way
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动方式
- en: Let's install the package as mentioned on the installation page at [https://github.com/tymondesigns/jwt-auth/wiki/Installation.](https://github.com/tymondesigns/jwt-auth/wiki/Installation)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照[https://github.com/tymondesigns/jwt-auth/wiki/Installation](https://github.com/tymondesigns/jwt-auth/wiki/Installation)安装页面上提到的包进行安装。
- en: 'First of all, we need to install the JWT Auth package:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装JWT Auth包：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that this version is for Laravel 5.3\. For older versions, you might need
    to use a different version of the JWT Auth package, most probably version 0.5.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此版本适用于Laravel 5.3。对于旧版本，您可能需要使用不同版本的JWT Auth包，很可能是版本0.5。
- en: 'To register the service provider in the `bootstrap/app.php` file, add this
    line of code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`bootstrap/app.php`文件中注册服务提供者，请添加以下代码行：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, add these two class aliases in the same `bootstrap/app.php` file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在同一个`bootstrap/app.php`文件中添加这两个类别名：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, you need to generate a random key that will be used to sign our tokens.
    To do so, run this command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要生成一个用于签署我们令牌的随机密钥。要这样做，请运行此命令：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will generate a random key.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个随机密钥。
- en: 'You might see some error as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会看到一些错误，如下所示：
- en: '`[Illuminate\Contracts\Container\BindingResolutionException] Unresolvable dependency
    resolving [Parameter #0 [ <required> $app ]] in class Illuminate\Cache\CacheManager`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Illuminate\Contracts\Container\BindingResolutionException] Unresolvable dependency
    resolving [Parameter #0 [ <required> $app ]] in class Illuminate\Cache\CacheManager`'
- en: 'In this case, add the following lines in `bootstrap/app.php` right after `$app->withEloquent();`.
    So, it will fix the problem and you can try generating a random key:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在`bootstrap/app.php`中的`$app->withEloquent();`之后添加以下行。这样就可以解决问题，您可以尝试生成一个随机密钥：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However, you are probably wondering where this random key will be set. Actually,
    some packages were not built for Lumen and require a structure more like Laravel.
    The `tymondesigns/jwt-auth` package is one of them. What it needs is a way to
    publish configurations. While Lumen does not have separate configuration files
    for different packages, as we need it, we can simply let Lumen have such a `config`
    file for this package. To do so, if you don''t have `helpers.php` under `app/`
    directory, then create it and add the following content:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可能想知道这个随机密钥将在哪里设置。实际上，有些包并不是为Lumen构建的，而是需要更像Laravel的结构。`tymondesigns/jwt-auth`包就是其中之一。它需要一种发布配置的方式。虽然Lumen没有为不同的包单独的配置文件，但我们需要它，我们可以让Lumen为这个包拥有这样一个`config`文件。要这样做，如果您在`app/`目录下没有`helpers.php`，那么创建它并添加以下内容：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, add `helpers.php` to `composer.json` in the auto-load array:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在自动加载数组的`composer.json`中添加`helpers.php`：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once you have it, run the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拥有了它，运行以下命令：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At this point, you will get another error saying:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您将收到另一个错误消息：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Don''t worry; it is all expected. It is because Lumen does not have the `vendor:publish`
    command out of the box. So, we need to install a small package for this command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心，这是正常的。这是因为Lumen没有`vendor:publish`命令。所以，我们需要安装一个小包来执行这个命令：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As this command is going to have a new command, in order to use that command,
    we need to put the following in the `$commands` array in `app/Console/Kernel.php`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个命令将有一个新的命令，为了使用该命令，我们需要在`app/Console/Kernel.php`的`$commands`数组中放入以下内容。
- en: 'Now, try running the same command again as shown here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试再次运行相同的命令，如下所示：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This time, you will see something like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，你会看到类似这样的东西：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, we have `blog/config/jwt.php` and we can store the `jwt-auth` package-related
    configurations in this file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有`blog/config/jwt.php`，我们可以在这个文件中存储与`jwt-auth`包相关的配置。
- en: 'The first thing we need to do is to rerun this command to set random key sign
    signatures:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是重新运行这个命令来设置随机密钥签名：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This time, you can see this key set in the `config/jwt.php` file in the return
    array:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，你可以在`config/jwt.php`文件的返回数组中看到这个密钥设置：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The next, you need to do configurations as shown in [https://github.com/tymondesigns/jwt-auth/wiki/Configuration](https://github.com/tymondesigns/jwt-auth/wiki/Configuration).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要按照[https://github.com/tymondesigns/jwt-auth/wiki/Configuration](https://github.com/tymondesigns/jwt-auth/wiki/Configuration)中所示的进行配置。
- en: However, you can also keep other settings in `config/jwt.php` as default.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你也可以将`config/jwt.php`中的其他设置保持为默认。
- en: 'Next thing will be to tell Dingo API to use JWT as the authentication method.
    So add this in `bootstrap/app.php`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的事情是告诉Dingo API使用JWT作为认证方法。所以在`bootstrap/app.php`中添加这个：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As per the JWT Auth documentation, we are mostly done with configurations, but
    note that you may face small issues related to versions. If you are using a version
    older than Lumen 5.3, then note that a different version of JWT Auth is required
    based on the different Laravel version. For version 5.2, you should use JWT Auth
    Version 0.5\. So, if you still get any errors in the version older than Laravel
    5.2, then note that it is possible that the error is because of version difference,
    so you have to search on the Internet.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 根据JWT Auth文档，我们大部分配置都已经完成了，但请注意，你可能会遇到与版本相关的小问题。如果你使用的版本早于Lumen 5.3，那么请注意，基于不同的Laravel版本，需要使用不同版本的JWT
    Auth。对于版本5.2，你应该使用JWT Auth版本0.5。所以，如果你在低于Laravel 5.2的版本中仍然遇到任何错误，那么请注意，可能是因为版本差异导致的错误，所以你需要在互联网上搜索。
- en: As you can see, just to use two packages together to achieve some functionality,
    we have to spend some time on configurations, as suggested in the last few steps.
    Even then, there is a chance of errors because of version differences. So, an
    easy and simple way is to not install the Dingo API package and JWT Auth package
    manually. There is another package, installing which will install the Dingo API
    package, Lumen generators, **CORS** (**Cross Origin Resource Sharing**) support,
    and JWTAuth and make it available to use without that much configuration. Now,
    let's look at that.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，为了同时使用两个包来实现一些功能，我们必须花费一些时间进行配置，就像最近的几个步骤建议的那样。即使这样，由于版本差异，仍然有可能出现错误。因此，一个简单的方法是不要手动安装Dingo
    API包和JWT Auth包。还有另一个包，安装它将安装Dingo API包、Lumen生成器、CORS（跨域资源共享）支持、JWTAuth，并使其可用，而不需要那么多的配置。现在，让我们来看看。
- en: Simpler way through Lumen JWT authentication integration package
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Lumen JWT认证集成包的更简单方式
- en: An easier way is to install both Dingo API package and JWT Auth yourself is
    to simply install [https://packagist.org/packages/krisanalfa/lumen-dingo-adapter.](https://packagist.org/packages/krisanalfa/lumen-dingo-adapter)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单的方法是自己安装Dingo API包和JWT Auth，只需安装[https://packagist.org/packages/krisanalfa/lumen-dingo-adapter.](https://packagist.org/packages/krisanalfa/lumen-dingo-adapter)
- en: 'It will add Dingo and JWT in your Lumen-based application. Simply install this
    package:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在你的基于Lumen的应用程序中添加Dingo和JWT。只需安装这个包：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, in `bootstrap/app.php`, add the following lines of code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`bootstrap/app.php`中，添加以下代码行：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, this way, we are using this `LumenDingoAdapter` package, so here is the
    `bootstrap/app.php` file that we will use so that you can compare it with yours:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正在使用`LumenDingoAdapter`包，所以这是我们将使用的`bootstrap/app.php`文件，这样你就可以与你的文件进行比较：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you are wondering what exactly this `$app->withFacades()` do then note that
    this enables facades in application. Facades is a design pattern which is used
    to make complex things abstract while providing simplified interface to interact
    with. In Lumen, as told by Laravel documentation: <q>Facades provide a "static"
    interface to classes that are available in the application''s service container.</q>'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道`$app->withFacades()`到底是做什么的，那么请注意，这将在应用程序中启用门面。门面是一种设计模式，用于将复杂的事物抽象化，同时提供简化的接口进行交互。在Lumen中，正如Laravel文档所述：<q>门面为应用程序服务容器中可用的类提供了一个“静态”接口。</q>
- en: Benefit of using facades is that it provides memorable syntax. We are not going
    to use Facades frequently, and will try to avoid using it because we will favor
    dependency injection over it. However, some packages will may be using facades
    so to let them work, we have enabled facades.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用门面的好处是它提供了易记的语法。我们不会经常使用门面，并且会尽量避免使用它，因为我们更倾向于使用依赖注入。然而，一些包可能会使用门面，所以为了让它们工作，我们已经启用了门面。
- en: Authentication
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: Now, we can protect our endpoints using the `api.auth` middleware. This middleware
    checks for user authentication and gets user from JWT. However, the first thing
    is to make the user log in, create a token based on that user information, and
    return the signed token to the client.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`api.auth`中间件来保护我们的端点。这个中间件检查用户认证并从JWT中获取用户。然而，首先要做的是让用户登录，根据用户信息创建一个令牌，并将签名令牌返回给客户端。
- en: In order to have authentication working, we first need to create an authentication-related
    controller. That controller will not only do token creation based on user login,
    it will also make the user token expire and refresh the token. In order to do
    this, we can put this open source `AuthController` in the `app/Http/Controllers/Auth/`
    directory at
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使认证工作，我们首先需要创建一个与认证相关的控制器。这个控制器不仅会根据用户登录创建令牌，还会使用户令牌过期并刷新令牌。为了做到这一点，我们可以将这个开源的`AuthController`放在`app/Http/Controllers/Auth/`目录下
- en: '[https://github.com/Haafiz/REST-API-for-basic-RPG/blob/master/app/Http/Controllers/Auth/AuthController.php.](https://github.com/Haafiz/REST-API-for-basic-RPG/blob/master/app/Http/Controllers/Auth/AuthController.php)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/Haafiz/REST-API-for-basic-RPG/blob/master/app/Http/Controllers/Auth/AuthController.php.](https://github.com/Haafiz/REST-API-for-basic-RPG/blob/master/app/Http/Controllers/Auth/AuthController.php)'
- en: Just to give credit, I want to tell you that the version we are using for `AuthController`
    is a modified version of [https://github.com/krisanalfa/lumen-jwt/blob/develop/app/Http/Controllers/Auth/AuthController.php](https://github.com/krisanalfa/lumen-jwt/blob/develop/app/Http/Controllers/Auth/AuthController.php).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给予信用，我想告诉你，我们使用的`AuthController`版本是[https://github.com/krisanalfa/lumen-jwt/blob/develop/app/Http/Controllers/Auth/AuthController.php](https://github.com/krisanalfa/lumen-jwt/blob/develop/app/Http/Controllers/Auth/AuthController.php)的修改版本。
- en: 'Anyway, in case you don''t see `AuthController` available online while reading
    the book, here is the content of `AuthController`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，如果你在阅读本书时没有看到`AuthController`在线上可用，这里是`AuthController`的内容：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This controller does three major tasks:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器有三个主要任务：
- en: Login in `login()` method
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录`login()`方法
- en: Invalidate token
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使令牌失效
- en: Refresh token
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新令牌
- en: Log in
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录
- en: 'Log in is being done in the `login()` method, and it tries to log in using
    `JWTAuth::attempt($this->getCredentials($request))` . If credentials are not valid
    or if there is some other problem, it will just return an error. However, to access
    this `login()` method, we need to add a route for it. Here is what we will add
    in `routes/web.php`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 登录是在`login()`方法中完成的，并且它尝试使用`JWTAuth::attempt($this->getCredentials($request))`进行登录。如果凭据无效或者出现其他问题，它将返回一个错误。然而，要访问这个`login()`方法，我们需要为它添加一个路由。这是我们将在`routes/web.php`中添加的内容：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Invalidate token
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使令牌失效
- en: 'To invalidate token, in other words, to log out user, the `invalidateToken()`
    method will be used. This method will be called through a route. We will add the
    following route with the delete request method, which will call `AuthController::invalidateToken()`
    from the routed file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使令牌失效，换句话说，注销用户，将使用`invalidateToken()`方法。这个方法将通过一个路由来调用。我们将添加以下路由，使用删除请求方法，它将从路由文件中调用`AuthController::invalidateToken()`：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Refresh token
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刷新令牌
- en: 'Refresh token is called when the token has expired based on the expiry time.
    In order to refresh the token, we also need to add the following route:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当令牌根据到期时间过期时，将调用刷新令牌。为了刷新令牌，我们还需要添加以下路由：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that all these endpoints will be added under version v1.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有这些端点都将添加在版本v1下。
- en: 'Once we have this `AuthController` there and routes are set up, the user can
    log in using the following endpoint:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`AuthController`并且路由设置好了，用户可以使用以下端点进行登录：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Try this and you will get a JWT-based access token.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下，你将获得基于JWT的访问令牌。
- en: '**Lumen, Dingo, JWT Auth, and CORS boilerplate**:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lumen、Dingo、JWT Auth和CORS样板**：'
- en: If you face difficulty in configuring Lumen with Dingo and JWT, then you can
    simply use the repository at [https://github.com/krisanalfa/lumen-jwt.](https://github.com/Haafiz/lumen-jwt)
    This repository will provide you with boilerplate code for setting up your Lumen
    for API development using Dingo API and JWT. You can clone this and simply start
    using it. It is nothing other than a Lumen integration with JWT, Dingo API, and
    CORS support. So, if you are starting a new RESTful web services project, you
    can simply start with this boiler plate code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在配置Lumen与Dingo和JWT时遇到困难，那么你可以简单地使用[https://github.com/krisanalfa/lumen-jwt.](https://github.com/Haafiz/lumen-jwt)这个存储库将为你提供使用Dingo
    API和JWT设置你的Lumen进行API开发的样板代码。你可以克隆它并开始使用。这只是一个Lumen与JWT、Dingo API和CORS支持的集成。因此，如果你要开始一个新的RESTful
    web服务项目，你可以直接使用这个样板代码开始。
- en: 'Before proceeding, let''s look at our routes file to make sure we are on the
    same page:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们看一下我们的路由文件，确保我们在同一个页面上：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, we have made a route group. A route group is just a way to group
    similar routes in which we can apply the same middleware or namespace or prefix
    and so on, just like we did in the `v1` group.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经创建了一个路由组。路由组只是一种将相似的路由分组的方式，我们可以在其中应用相同的中间件、命名空间或前缀等，就像我们在`v1`组中所做的那样。
- en: Here, we made another route group so that we can add the `api.auth` middleware
    on it. Another thing to note is that we have split some posts routes from post
    resource route to separate routes just to have some routes available without login.
    We did the same for comments routes as well.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了另一个路由组，以便我们可以在其中添加`api.auth`中间件。还要注意的一点是，我们已经将一些帖子路由从帖子资源路由中拆分出来，以便在没有登录的情况下有一些可用的路由。我们也对评论路由做了同样的处理。
- en: Note that if you don't want to split some routes from the resource route, then
    you can do that as well. You will just add the `api.auth` middleware in controllers
    instead of routes file. Both ways are correct; it is just a matter of preference.
    I did it this way because I find it easier to know which routes are protected
    from the same routes file instead of constructors of different controllers. But
    again, it is up to you.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你不想将一些路由从资源路由中拆分出来，那么你也可以这样做。你只需在控制器中添加`api.auth`中间件，而不是在路由文件中。两种方式都是正确的；这只是一个偏好问题。我之所以这样做，是因为我发现从相同的路由文件而不是不同控制器的构造函数中知道哪些路由受保护更容易。但再次强调，这取决于你。
- en: We are letting only logged in users create, update, and delete posts. However,
    we need to make sure that the user that is logged in can only update or delete
    their own posts. Although this thing can also be done by creating another middleware,
    it will be simpler to do it in controller.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只允许已登录的用户创建、更新和删除帖子。但是，我们需要确保已登录的用户只能更新或删除自己的帖子。虽然这也可以通过创建另一个中间件来实现，但在控制器中实现会更简单。
- en: 'This is how we do it in `PostController`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在 `PostController` 中的做法：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, there are three places where I have highlighted code. In the
    `store()` method, we got the user ID from it and put it in the input array so
    that the `user_id` of post will be based on the token. Similarly, for `update()`
    and `delete()`, we used that user's ID and placed a check to make sure that Post
    owner is deleting or updating post records. You are probably wondering that when
    we haven't defined the `$this->user` property anywhere, how are we accessing it?
    Actually, we are using the Helpers trait, so `$this->user` is coming from that
    trait.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我在三个地方都突出显示了代码。在 `store()` 方法中，我们从中获取了用户 ID，并将其放入输入数组中，以便帖子的 `user_id`
    基于令牌。同样，在 `update()` 和 `delete()` 中，我们使用了该用户的 ID，并放置了一个检查，以确保帖子所有者正在删除或更新帖子记录。您可能会想知道，当我们没有在任何地方定义
    `$this->user` 属性时，我们是如何访问它的？实际上，我们正在使用 Helpers trait，所以 `$this->user` 来自该 trait。
- en: 'Note that in order to access protected resources, you should grab the token
    from the login endpoint and put it in your header as follows: `Authentication:
    bearer <token grabbed from login>`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，为了访问受保护的资源，您应该从登录端点获取令牌，并将其放在标头中，如下所示：`Authentication: bearer <token grabbed
    from login>`'
- en: In the same way, `CommentController` will have checks to make sure that comments
    modification will be limited to the comment owner only and deletion will be limited
    to the comment or post owner. It will have similar checks and user ID through
    token in the same way. So, I will leave that to you to implement comment controller
    to have those checks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`CommentController` 将进行检查，以确保评论修改将仅限于评论所有者，并且删除将仅限于评论或帖子所有者。它将具有类似的检查和用户
    ID 通过令牌的方式。因此，我将留给您实现评论控制器以进行这些检查。
- en: Transformers
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换器
- en: In full-stack MVC framework, we have Model View Controller. In Lumen or in API,
    we don't have Views because we just return some data. However, we may want to
    show data in a different way than usual. We may want to use a different format,
    or we may want to restrict an object with a specific format. In all such cases,
    we need a place where formatting-related tasks will be done, a place where we
    can have different format-related content. We can have it in controller. However,
    we will need to define the same format at different places. In that case, we can
    add a method in model. For example, post model can have a specific way to format
    a post object. So, we can define another method in Post Model.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在全栈 MVC 框架中，我们有模型视图控制器。在 Lumen 或 API 中，我们没有视图，因为我们只返回一些数据。但是，我们可能希望以与通常不同的方式显示数据。我们可能希望使用不同的格式，或者我们可能希望限制具有特定格式的对象。在所有这些情况下，我们需要一个处理格式相关任务的地方，一个可以包含不同格式相关内容的地方。我们可以在控制器中实现。但是，我们需要在不同的地方定义相同的格式。在这种情况下，我们可以在模型中添加一个方法。例如，帖子模型可以有一种特定的方式来格式化帖子对象。因此，我们可以在帖子模型中定义另一个方法。
- en: It will work fine, but if you look at it closely, it is related to formatting,
    not model. So, we have another layer called serializes or transformers. Also,
    sometimes, we need nested objects, so we will not want to do the same nesting
    again and again.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它会很好地工作，但是如果你仔细看，它与格式有关，而不是模型。因此，我们有另一层叫做序列化或转换器。有时，我们需要嵌套对象，所以我们不希望一遍又一遍地做同样的嵌套。
- en: Lumen provides a way to serialize data to JSON. In Eloquent object, there is
    a method named `toJson()`; this method can be overridden to serve the purpose.
    However, it is better to have a separate layer for formatting and serializing
    data than having just a method to do so in the same class. Then comes transformers;
    a transformer is just another layer. You can think of a transformer as the View
    layer of an API or web service.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Lumen 提供了一种将数据序列化为 JSON 的方法。在 Eloquent 对象中，有一个名为 `toJson()` 的方法；这个方法可以被重写以达到目的。但是，最好有一个单独的层用于格式化和序列化数据，而不是在同一个类中只有一个方法来实现。然后就是转换器；转换器只是另一层。您可以将转换器视为
    API 或 web 服务的视图层。
- en: Understanding and setting transformers
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和设置转换器
- en: Actually, the package we used, named, Dingo API, contains a lot of stuff that
    we need to create a RESTful web service. The same Dingo API package provides support
    for transformers as well.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们使用的包名为 Dingo API 包含了创建 RESTful web 服务所需的许多内容。同样，Dingo API 包还提供了对转换器的支持。
- en: Before doing anything, we need to understand that the transformer layer consists
    of transformers. A transformer is a class responsible for data presentation. Dingo
    API transformers support transformers, and for transformers, the API depends on
    another library responsible for transformer functionality. It is up to us which
    transformation layer or library we use. By default, it comes with Fractal, a default
    transformation layer.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在做任何事情之前，我们需要了解转换器层由转换器组成。转换器是负责数据呈现的类。Dingo API 转换器支持转换器，对于转换器，API 依赖于另一个负责转换器功能的库。由我们决定使用哪个转换层或库。默认情况下，它使用
    Fractal，一个默认的转换层。
- en: We don't need to do anything else related to setup. Let's move towards using
    transformer for our objects. However, before that, make yourself comfortable with
    Fractal. We need to at least know what Fractal is and what it provides. The documentation
    for Fractal can be found at [http://fractal.thephpleague.com/](http://fractal.thephpleague.com/).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要做任何其他与设置相关的事情。让我们开始使用转换器来处理我们的对象。但是，在那之前，让自己熟悉 Fractal。我们至少需要知道 Fractal
    是什么以及它提供了什么。Fractal 的文档可以在 [http://fractal.thephpleague.com/](http://fractal.thephpleague.com/)
    找到。
- en: Using transformers
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用转换器
- en: 'There are two ways to tell Lumen which transformer class has to be used. For
    that, we need to create a transformer class. Let''s first make a transformer for
    our `Post` object and name it `PostTransformer`. First, create a directory named
    `app/Transformers` and in that directory, create a class `PostTransformer` with
    the following content:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以告诉Lumen要使用哪个转换器类。为此，我们需要创建一个转换器类。让我们首先为我们的`Post`对象创建一个转换器，并将其命名为`PostTransformer`。首先，创建一个名为`app/Transformers`的目录，在该目录中，创建一个名为`PostTransformer`的类，内容如下：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can do whatever you want to do with the Post response in the `transform()`
    method. Note that we are not optionally overriding the `transform()` method here,
    but we are providing an implementation of `transform()`. You always need to add
    that method in the transformer class. However, this class is of no use if it is
    not used from anywhere. So, let''s use it from our `PostController`. Let''s do
    it in the `index()` method:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`transform()`方法中对Post响应进行任何想要的操作。请注意，我们在这里不是可选地重写`transform()`方法，而是提供了`transform()`的实现。您始终需要在转换器类中添加该方法。但是，如果没有从任何地方使用该类，则该类将毫无用处。因此，让我们在我们的`PostController`中使用它。让我们在`index()`方法中使用它：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As you can see, we have injected the `PostTransformer` object to the `$this->response->paginator()`
    method. The first thing we need to note here is the `$this->response->paginator()`
    method and the `$this->response` object. We now need to know from where the `$this->response`
    object came from in the first place. We got it because we used the `Helpers` trait
    in `PostController`. Anyway, now, let''s see how it works. Hit the `PostController`
    `index()` method with the following endpoint:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已经将`PostTransformer`对象注入到`$this->response->paginator()`方法中。这里我们需要注意的第一件事是`$this->response->paginator()`方法和`$this->response`对象。我们现在需要知道`$this->response`对象最初是从哪里来的。我们得到它是因为我们在`PostController`中使用了`Helpers`
    trait。无论如何，现在让我们看看它是如何工作的。使用以下端点击中`PostController`的`index()`方法：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It will return something like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 它会返回类似这样的东西：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you look at it, you will see a separate meta section having pagination-related
    content. This is a small thing that Fractal transformer provides by itself. Actually,
    there is a lot more that Fractal can do for us.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察，您会看到一个单独的元数据部分，其中包含与分页相关的内容。这是Fractal转换器本身提供的一个小功能。实际上，Fractal可以为我们提供更多。
- en: We can include nested objects. For example, if we have `user_id` in `Post` and
    we want the `User` object nested inside the same `Post` object, then it can provide
    an easier way to do that as well. Although the transformer layer is just like
    the view layer for API response data, it provides a lot more than that. Right
    now, I will show you how our `PostController` method will look after returning
    with `PostTransformer` from `show()` and other methods. For details of Fractal,
    I would recommend that you look at the Fractal documentation, so that you can
    take full advantage of it, at [http://fractal.thephpleague.com/](http://fractal.thephpleague.com/).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以包含嵌套对象。例如，如果我们在`Post`中有`user_id`，并且我们希望`User`对象嵌套在同一个`Post`对象中，那么它也可以提供更简单的方法来实现。尽管转换器层就像API响应数据的视图层一样，但它提供的远不止于此。现在，我将向您展示当我们从`show()`和其他方法中返回`PostTransformer`后，我们的`PostController`方法将会是什么样子。有关Fractal的详细信息，我建议您查看Fractal文档，以便充分利用它，网址为[http://fractal.thephpleague.com/](http://fractal.thephpleague.com/)。
- en: 'Here is how our `PostController` method will look:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的`PostController`方法的样子：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: From the highlighted lines in the preceding code snippet, you can see that we
    have added the `PostTransformer` object in constructor and placed it in `$this->transformer`
    that we used in other methods. Another thing you can see is that at one place,
    we used the `$this->response->paginator()` method in the `index()` method, while
    we used `$this->response->item()` in others. It is because `$this->response->item()`
    method is used when there is one object, while `paginator` is used when we have
    the `paginator` object in the `index()` method. Note that if you have a collection
    and do not have the `paginator` object, you should use `$this->response->collection()`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中突出显示的行中，您可以看到我们在构造函数中添加了`PostTransformer`对象，并将其放置在`$this->transformer`中，我们在其他方法中使用了它。您还可以看到，在一个地方，我们在`index()`方法中使用了`$this->response->paginator()`方法，而在其他方法中我们使用了`$this->response->item()`。这是因为当有一个对象时，我们使用`$this->response->item()`方法，而在`index()`方法中有`paginator`对象时，我们使用`paginator`。请注意，如果您有一个集合并且没有`paginator`对象，则应该使用`$this->response->collection()`。
- en: As mentioned earlier, Fractal has more features and those are in its documentation.
    So, you need to take a pause and explore its documentation at [http://fractal.thephpleague.com/.](http://fractal.thephpleague.com/)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Fractal具有更多功能，这些功能在其文档中有所介绍。因此，您需要暂停一下，并在[http://fractal.thephpleague.com/](http://fractal.thephpleague.com/)上探索其文档。
- en: Encryption
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密
- en: The next thing that we are missing is encryption of communication between client
    and server so that nobody can sniff and read data over the network. For this purpose,
    we will use **SSL** (**Secure Socket Layer**). As this book is not about encryption
    or cryptography or server setup, we will not go into the details of these concepts,
    but it is important that we talk about encryption here. If someone is able to
    sniff data over the network, then our website or web service is not secure.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们缺少的下一件事是加密客户端和服务器之间的通信，以便没有人可以在网络上嗅探和读取数据。为此，我们将使用**SSL**（**安全套接字层**）。由于本书不涉及加密、密码学或服务器设置，我们不会详细介绍这些概念，但重要的是我们在这里谈论加密。如果有人能够在网络上嗅探数据，那么我们的网站或网络服务就不安全。
- en: In order to secure our web service, we will use HTTPS instead of HTTP. The "S"
    in HTTPS stands for Secure. Now, the question is how we can make it secure. Probably,
    you would say that we will use SSL as we said earlier. So what is SSL? SSL is
    Secure Socket Layer, a standard way to secure communication between server and
    browser. SSL refers to a security protocol. Actually SSL protocol had three versions,
    and they were insecure against some attacks. So what we actually use is **TLS**
    (**Transport Layer Security**). However, we still use SSL term when we are referring
    to TLS. If you want to use SSL certificate and SSL to make HTTP secure, actually
    what is used underneath is TLS which is better than original SSL protocols.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护我们的Web服务，我们将使用HTTPS而不是HTTP。HTTPS中的“S”代表安全。现在，问题是我们如何使它安全。你可能会说我们将使用SSL，就像我们之前说的那样。那么SSL是什么？SSL是安全套接字层，是服务器和浏览器之间安全通信的标准方式。SSL指的是安全协议。实际上SSL协议有三个版本，它们对一些攻击是不安全的。所以我们实际使用的是TLS（传输层安全）。然而，当我们提到TLS时，我们仍然使用SSL术语。如果你想使用SSL证书和SSL来使HTTP安全，实际上底层使用的是比原始SSL协议更好的TLS。
- en: What happens is that when a connection is made, the server sends the SSL certificate's
    copy to the browser with the public key as well so that the browser can also encode
    or decode what is communicated to and from the server. We will not go into encryption
    details; however, we need to know how to get the SSL certificate.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当建立连接时，服务器会将SSL证书的副本与公钥一起发送给浏览器，以便浏览器也可以对与服务器之间的通信进行编码或解码。我们不会深入讨论加密细节；然而，我们需要知道如何获得SSL证书。
- en: SSL certificate, different options
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSL证书，不同的选项
- en: Normally, the SSL certificate is bought from certificate providers. However,
    you can also get a free certificate from [letsencrypt.org](http://letsencrypt.org).
    So, if a free certificate is available, then why are certificates still bought?
    Actually, sometimes, buying it from some authorities is more about insurance than
    security. If you are making an e-commerce site or something that is accepting
    payment or very critical data such as financial information, then you need someone
    to take responsibility in front of your site's user.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，SSL证书是从证书提供商那里购买的。然而，你也可以从[letsencrypt.org](http://letsencrypt.org)获得免费证书。所以，如果有免费证书可用，那为什么还要购买证书呢？实际上，有时从某些机构购买证书更多的是为了保险而不是安全。如果你正在建立一个电子商务网站或者接受付款或者非常关键的金融信息等非常重要的数据，那么你需要有人在你的网站用户面前承担责任。
- en: Probably there is some minor difference (that I am unaware of) between a certificate
    from [letsencrypt.org](http://letsencrypt.org) and from providers who sell for
    good prices, but normally, it is bought for insurance instead of security.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 也许从[letsencrypt.org](http://letsencrypt.org)获得的证书与以较低价格出售的提供商的证书之间存在一些微小的差异（我不知道），但通常，购买证书更多的是为了保险而不是安全。
- en: You will get installation instructions from whoever you get certificates from.
    If you prefer to go with [letsencrypt.org](https://letsencrypt.org/) , then I
    would recommend that you use certbot. Follow the instructions at [https://certbot.eff.org/](https://certbot.eff.org/).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从你获得证书的地方得到安装说明。如果你选择使用[letsencrypt.org](https://letsencrypt.org/)，那么我建议你使用certbot。请按照[https://certbot.eff.org/](https://certbot.eff.org/)上的说明进行操作。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed what we were missing in the previous chapter where
    we implemented RESTful web service endpoints in Lumen. We discussed throttling
    (Request Rate Limiting) to prevent DoS or brute force. We also implemented token-based
    authentication using some packages. Note that we only secured endpoints here,
    which we didn't want to leave accessible without user login. If there are other
    endpoints that you don't want to have public access to but they don't need users
    to log in, then you can use either some sort of key or basic authentication on
    those endpoints.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在上一章中我们在Lumen中实现RESTful Web服务端点时所缺少的内容。我们讨论了限流（请求速率限制）以防止DoS或暴力破解。我们还使用了一些软件包实现了基于令牌的身份验证。请注意，我们只在这里保护了端点，我们不希望在用户未登录的情况下留下可访问的端点。如果有其他端点，你不希望公开访问，但它们不需要用户登录，那么你可以在这些端点上使用某种密钥或基本身份验证。
- en: Other than that, we discussed and used transformers that are a sort of view
    layer for web services. Then, we briefly discussed encryption and SSL importance
    and then discussed the available options for SSL certificates.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们讨论并使用了一些用于Web服务的视图层的转换器。然后，我们简要讨论了加密和SSL的重要性，然后讨论了SSL证书的可用选项。
- en: In this chapter, I will not give you a list or URLs for more resources because
    we discussed a lot of different things in this chapter, so we were not able to
    go into the details of each and every thing. To completely absorb it, you should
    first look at the documentation of every thing that we discussed here, and then,
    you should practice. You will actually learn when you face problems during practice
    and when you attempt to solve them.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我不会给你更多资源的URL列表，因为我们在本章中讨论了很多不同的事情，所以我们无法深入了解每一件事的细节。要完全吸收它，你应该首先查看我们在这里讨论的每一件事的文档，然后进行实践。当你在实践中遇到问题并尝试解决它们时，你才会真正学到东西。
- en: In the next chapter, we will talk about testing and write test cases for our
    endpoints and our code using automated testing tools.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论测试，并使用自动化测试工具为我们的端点和代码编写测试用例。
