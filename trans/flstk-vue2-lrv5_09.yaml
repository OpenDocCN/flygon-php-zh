- en: Adding a User Login and API Authentication with Passport
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Passport添加用户登录和API身份验证
- en: In the last chapter, we allowed the user to save their favorite Vuebnb listings.
    This feature was only implemented in the frontend app though, so if the user reloaded
    the page their selections would be lost.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们允许用户保存他们喜欢的Vuebnb列表。但是，这个功能只在前端应用中实现，所以如果用户重新加载页面，他们的选择将会丢失。
- en: In this chapter, we'll create a user login system and persist saved items to
    the database so they can be retrieved after a page refresh.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个用户登录系统，并将保存的项目持久化到数据库中，以便在页面刷新后检索。
- en: 'Topics covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题：
- en: Setting up a user login system utilizing Laravel's built-in authentication features
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Laravel内置的身份验证功能设置用户登录系统
- en: Creating a login form with CSRF protection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有CSRF保护的登录表单
- en: Using Vuex actions for asynchronous operations in the store
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存储中使用Vuex操作进行异步操作
- en: A brief introduction to the OAuth protocol for API authentication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth协议的简要介绍，用于API身份验证
- en: Setting up Laravel Passport to allow authenticated AJAX requests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Laravel Passport允许经过身份验证的AJAX请求
- en: User model
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户模型
- en: In order to save listing items to the database, we first need a user model,
    as we want each user to have their own unique list. Adding a user model means
    we'll also need an authentication system so that users can sign in and out. Fortunately,
    Laravel provides a full-featured user model and authentication system out-of-the-box.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将列表项保存到数据库中，我们首先需要一个用户模型，因为我们希望每个用户都有自己独特的列表。添加用户模型意味着我们还需要一个身份验证系统，以便用户可以登录和退出。幸运的是，Laravel提供了一个功能齐全的用户模型和身份验证系统。
- en: Let's now take a look at the user model boilerplate files to see what modifications
    will be needed to fit them for our purposes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看用户模型样板文件，看看需要对其进行哪些修改以适应我们的目的。
- en: Migration
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移
- en: Looking first at the database migration, the user table schema already includes
    ID, name, email, and password columns.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先看一下数据库迁移，用户表模式已经包括ID、名称、电子邮件和密码列。
- en: '`database/migrations/2014_10_12_000000_create_users_table.php`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`database/migrations/2014_10_12_000000_create_users_table.php`：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This schema will be sufficient for our needs if we add an additional column
    for storing the saved listing IDs. Ideally, we'd store these in an array, but
    since relational databases don't have an array column type, we will instead store
    them as a serialized string, for example, [1, 5, 10] within a `text` column.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加一个额外的列来存储保存的列表ID，那么这个模式对我们的需求就足够了。理想情况下，我们会将它们存储在一个数组中，但是由于关系数据库没有数组列类型，我们将把它们存储为一个序列化的字符串，例如，在`text`列中`[1,
    5, 10]`。
- en: '`database/migrations/2014_10_12_000000_create_users_table.php`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`database/migrations/2014_10_12_000000_create_users_table.php`：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Model
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: Let's now take a look now at the `User` model class that Laravel provides.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看Laravel提供的`User`模型类。
- en: '`app/User.php`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/User.php`：'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The default configuration is fine, but let's allow the `saved` attribute to
    be mass assignable by adding it to the `$fillable` array.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 默认配置是可以的，但让我们通过将其添加到`$fillable`数组中，允许`saved`属性进行批量赋值。
- en: We'll also get our model to serialize and deserialize the `saved` text when
    we read it or write it. To do this we can add a `$casts`attribute to the model
    and cast `saved` as an array.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们读取或写入时，我们还将使我们的模型序列化和反序列化`saved`文本。为此，我们可以向模型添加一个`$casts`属性，并将`saved`转换为数组。
- en: '`app/User.php`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/User.php`：'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we can treat the `saved` attribute as an array, even though it''s stored
    as a string in the database:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`saved`属性视为数组，即使它在数据库中存储为字符串：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Seeder
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Seeder
- en: 'In a normal web app with a login system, you''d have a registration page so
    users can create their own accounts. To ensure this book doesn''t get too long,
    we''ll skip that feature and instead generate user accounts with a database seeder:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个普通的带有登录系统的Web应用中，您会有一个注册页面，让用户创建自己的帐户。为了确保本书不会变得太长，我们将跳过该功能，而是使用数据库seeder生成用户帐户：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can implement a registration page for Vuebnb yourself if you want. The Laravel
    documentation covers it quite thoroughly at [https://laravel.com/docs/5.5/authentication](https://laravel.com/docs/5.5/authentication).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以为Vuebnb自己实现一个注册页面。Laravel文档在[https://laravel.com/docs/5.5/authentication](https://laravel.com/docs/5.5/authentication)中对此进行了详细介绍。
- en: Let's create at least one account with a name, email, password, and an array
    of saved listings. Note that I've used the `make` method of the `Hash` facade
    to hash the password rather than storing it as plain-text. Laravel's default `LoginController`
    will automatically verify plain-text passwords against the hash during the login
    process.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们至少创建一个帐户，其中包括名称、电子邮件、密码和一个保存列表的数组。请注意，我使用了`Hash`外观的`make`方法来对密码进行哈希处理，而不是将其存储为纯文本。Laravel的默认`LoginController`在登录过程中将自动对纯文本密码进行哈希处理。
- en: '`database/seeds/UsersTableSeeder.php`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`database/seeds/UsersTableSeeder.php`：'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To run the seeder we need to call it from the main `DatabaseSeeder` class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行seeder，我们需要从主`DatabaseSeeder`类中调用它。
- en: '`database/seeds/DatabaseSeeder.php`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`database/seeds/DatabaseSeeder.php`：'
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s now rerun our migrations and seeder to install the user table and data
    with the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重新运行我们的迁移和seeder，以安装用户表和数据，使用以下命令：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To confirm that our user table and data were created correctly, we''ll use
    Tinker to query the table. You should get an output similar to the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认我们的用户表和数据是否正确创建，我们将使用Tinker来查询表。您应该会得到类似以下的输出：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Login system
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录系统
- en: Now that we have our user model created, we can implement the rest of the login
    system. Again, Laravel includes this as an out-of-the-box feature, so there is
    only a small amount of configuration for us to do.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了用户模型，我们可以实现登录系统的其余部分。同样，Laravel将其作为一个开箱即用的功能包含在内，所以我们只需要进行少量配置。
- en: 'Here''s an overview of how the login system works:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是登录系统的概述：
- en: The user provides their email and password in a login form. We'll create this
    form with Vue
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户在登录表单中提供他们的电子邮件和密码。我们将使用Vue创建这个表单
- en: The form is submitted to the `/login` POST route
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表单提交到`/login` POST路由
- en: The `LoginController` will then verify the user's credentials against the database
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LoginController`然后将验证用户的凭据与数据库匹配'
- en: If the login is successful, the user is redirected to the home page. A session
    cookie is attached to the response, which is then passed to all outgoing requests
    to verify the user
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果登录成功，用户将被重定向到主页。会话cookie附加到响应中，然后传递给所有外发请求以验证用户
- en: 'Here''s a diagrammatic representation of the login system for further clarity:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是登录系统的图解表示，以便更清晰地理解：
- en: '![](assets/d2939bb2-239e-4662-839b-ed986a6a665b.png)Figure 9.1\. Login flow'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/d2939bb2-239e-4662-839b-ed986a6a665b.png)图9.1\. 登录流程'
- en: LoginPage component
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LoginPage组件
- en: 'We will need a login page for our app, so let''s create a new page component:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要一个登录页面，所以让我们创建一个新的页面组件：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We'll begin by defining the template markup, which includes a form with fields
    for email and password, and a submit button. The form uses the HTTP POST method
    and is sent to the `/login`path. I've wrapped the form elements in a `div` with
    the `.form-controller` class to help with styling.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义模板标记，其中包括一个带有电子邮件和密码字段以及提交按钮的表单。表单使用HTTP POST方法，并发送到`/login`路径。我将表单元素包装在一个带有`.form-controller`类的`div`中，以帮助进行样式设置。
- en: '`resources/assets/components/LoginPage.vue`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/LoginPage.vue`:'
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We don't need any JavaScript functionality just yet, so let's add our CSS rules
    now.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在还不需要任何JavaScript功能，所以让我们现在添加我们的CSS规则。
- en: '`resources/assets/components/LoginPage.vue`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/LoginPage.vue`:'
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We'll add a `login-container` class to our global CSS file so the footer for
    this page aligns correctly. We'll also add a CSS rule to ensure text inputs display
    correctly on iPhone. The login page will be the only place we'll have a text input,
    but let's add it as a global rule in case you decide to add other forms later.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在全局CSS文件中添加一个`login-container`类，以便该页面的页脚正确对齐。我们还将添加一个CSS规则，以确保文本输入在iPhone上正确显示。登录页面将是我们唯一需要文本输入的地方，但为了以防以后决定添加其他表单，让我们将其作为全局规则添加。
- en: '`resources/assets/css/style.css`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/css/style.css`:'
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, let's add this new page component to our router. We'll first import
    the component then add it to our `routes` array in the router configuration.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将这个新的页面组件添加到我们的路由器中。我们首先导入组件，然后将其添加到路由器配置中的`routes`数组中。
- en: Note that the login page does not require any data from the server like the
    other pages of Vuebnb do. This means that we can skip the data-fetching step by
    modifying the logic of the first `if` statement in the navigation guard. It should
    now resolve straightaway if the name of the route is `login`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，登录页面不需要来自服务器的任何数据，就像Vuebnb的其他页面一样。这意味着我们可以通过修改导航守卫中第一个`if`语句的逻辑来跳过数据获取步骤。如果路由的名称是`login`，它现在应该立即解析。
- en: '`resources/assets/js/router.js`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/router.js`:'
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Server routes
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器路由
- en: Now that we've added a login page at the `/login` route, we will need to create
    a matching server-side route. We will also need a route for the login form that
    posts to the same `/login` path.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`/login`路由添加了一个登录页面，我们需要创建一个匹配的服务器端路由。我们还需要一个用于提交到相同`/login`路径的登录表单的路由。
- en: In fact, both of these routes are provided out-of-the-box by Laravel as part
    of its default login system. All we have to do to activate the routes is add the
    following line to the bottom of our web route file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这两个路由都是Laravel的默认登录系统提供的。要激活这些路由，我们只需在我们的web路由文件的底部添加以下行。
- en: '`routes/web.php`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes/web.php`:'
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To see the effect of this code, we can use Artisan to show a list of the routes
    in our app:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此代码的效果，我们可以使用Artisan来显示应用程序中的路由列表：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '![](assets/a6f43ce1-9bb9-41e4-bf13-9f4f04b0ae0a.png)Figure 9.2\. Terminal output
    showing routes list'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a6f43ce1-9bb9-41e4-bf13-9f4f04b0ae0a.png)图9.2\. 终端输出显示路由列表'
- en: You'll see all the routes that we've manually created, plus a few that we didn't,
    for example, *login*, *logout*, and *register*. These are the routes used by Laravel's
    authentication system that we just activated.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到我们手动创建的所有路由，以及一些我们没有创建的路由，例如*登录*、*注销*和*注册*。这些是Laravel身份验证系统使用的路由，我们刚刚激活了它们。
- en: Looking at the GET/HEAD `/login`route, you'll see that it points to the `LoginController`controller.
    Let's take a look at that file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 查看GET/HEAD `/login`路由，您将看到它指向`LoginController`控制器。让我们来看看那个文件。
- en: '`App\Http\Controllers\Auth\LoginController.php`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`App\Http\Controllers\Auth\LoginController.php`:'
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This class uses an  `AuthenticatesUsers` trait thatdefines the `showLoginForm`
    method that the `/login` route handler refers to. Let's overwrite that method
    so it simply returns our app view. Since this instance of the view doesn't need
    any data to be inlined in the head (the login form has no state), we will pass
    an empty array to the `data` template variable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类使用了一个`AuthenticatesUsers`特性，定义了`showLoginForm`方法，`/login`路由处理程序引用了这个方法。让我们重写该方法，使其简单地返回我们的应用视图。由于这个视图实例不需要在头部内联任何数据（登录表单没有状态），我们将向`data`模板变量传递一个空数组。
- en: '`App\Http\Controllers\Auth\LoginController.php`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`App\Http\Controllers\Auth\LoginController.php`:'
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With that done, we can now see our complete login page by navigating the browser
    to `/login`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，通过将浏览器导航到`/login`，我们现在可以看到完整的登录页面：
- en: '![](assets/bb73b6fd-67d9-479c-82da-240cb763fd71.png)Figure 9.3\. Login page'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/bb73b6fd-67d9-479c-82da-240cb763fd71.png)图9.3\. 登录页面'
- en: CSRF protection
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSRF 保护
- en: CSRF (cross-site request forgery) is a type of malicious exploit where an attacker
    gets a user to unknowingly perform an action on a server that they're currently
    logged in to. This action will change something on the server that is advantageous
    to the attacker, for example, transfer money, change the password to one the attacker
    knows, and so on.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF（跨站请求伪造）是一种恶意利用，攻击者让用户在当前登录的服务器上执行一个不知情的操作。这个操作将改变服务器上对攻击者有利的东西，例如转账、更改攻击者知道的密码等。
- en: For example, an attacker might hide a script in a web page or email and direct
    the user to it somehow. When it executes, this script could make a POST request
    to `importantwebsite.com/updateEmailAndPassword`. If the user is logged in to
    this site, the request may be successful.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，攻击者可能会在网页或电子邮件中隐藏一个脚本，并以某种方式引导用户访问它。当执行时，此脚本可以向`importantwebsite.com/updateEmailAndPassword`发出POST请求。如果用户已登录到此站点，则请求可能成功。
- en: One way to prevent this kind of attack is to embed a special token, essentially
    a random string, in any form that a user might submit. When the form is submitted,
    the token is checked against the user's session to make sure it matches. An attacker
    won't be able to forge this token in their script and should, therefore, be thwarted
    by this feature.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 防止这种攻击的一种方法是在用户可能提交的任何表单中嵌入一个特殊令牌，实质上是一个随机字符串。当提交表单时，检查令牌是否与用户的会话匹配。攻击者将无法伪造此令牌，并因此受到此功能的阻碍。
- en: 'In Laravel, CSRF token creation and verification is managed by the `VerifyCsrfToken`
    middleware that is added to the web routes by default:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Laravel中，CSRF令牌的创建和验证由默认添加到web路由的`VerifyCsrfToken`中间件管理：
- en: '![](assets/48ea4473-071f-4ed7-bafe-d910cdeec8e5.png)Figure 9.4\. CSRF prevention
    process'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/48ea4473-071f-4ed7-bafe-d910cdeec8e5.png)图9.4 CSRF预防过程'
- en: 'To include the CSRF token in a form you can simply add `{{ csrf_field() }}`
    within the `form` tag. This will generate a hidden input field containing a valid
    CSRF token, for example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要在表单中包含CSRF令牌，只需在`form`标记中添加`{{ csrf_field() }}`。这将生成一个包含有效CSRF令牌的隐藏输入字段，例如：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This won't work in our scenario, though, as our form is not inside a Blade view
    but inside a single-file component that will not get processed by Blade. As an
    alternative, we can add the CSRF token to the head of the page and assign it to
    the `window` object.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的情况下，这不起作用，因为我们的表单不在Blade视图中，而是在一个不会被Blade处理的单文件组件中。作为替代方案，我们可以将CSRF令牌添加到页面的头部，并将其分配给`window`对象。
- en: '`resources/views/app.blade.php`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`:'
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can now retrieve this from within our Vue.js app and manually add it to the
    login form. Let's modify `LoginPage` to include a hidden `input` field in the
    form. We'll add some state to this component now, in which the token is included
    as a data property and bound to the hidden field.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从Vue.js应用程序中检索到这个，并手动将其添加到登录表单中。让我们修改`LoginPage`，在表单中包含一个隐藏的`input`字段。我们现在将一些状态添加到这个组件中，其中令牌被包含为数据属性并绑定到隐藏字段中。
- en: '`resources/assets/js/components/LoginPage.vue`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/components/LoginPage.vue`:'
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we now try to log in to our app using the credentials of the user we created
    in the seeder, we''ll get served this error page. Looking in the address bar,
    you''ll see that the route we''re on is `/home`, which is not a valid route within
    our app, hence the `NotFoundHttpException`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试使用我们在seeder中创建的用户的凭据登录到我们的应用程序，我们将收到此错误页面。查看地址栏，您会看到我们所在的路由是`/home`，这不是我们应用程序中的有效路由，因此会出现`NotFoundHttpException`：
- en: '![](assets/99d47c43-15ff-4837-b68a-36b6f618ced3.png)Figure 9.5\. Invalid route'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/99d47c43-15ff-4837-b68a-36b6f618ced3.png)图9.5 无效路由'
- en: Post-login redirection
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录后重定向
- en: When a user logs in, Laravel will redirect them to a page defined by the `$redirectTo`attribute
    in the login controller. Let's change this from `/home` to `/`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登录时，Laravel会将他们重定向到登录控制器中`$redirectTo`属性定义的页面。让我们将其从`/home`更改为`/`。
- en: '`app/Http/Auth/Controllers/LoginController.php`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/Http/Auth/Controllers/LoginController.php`:'
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let's also update the `RedirectIfAuthenticated` middleware class so that if
    a logged-in user attempts to view the login page, they're redirect to `/` (instead
    of the default `/home` value.)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也更新`RedirectIfAuthenticated`中间件类，以便如果已登录用户尝试查看登录页面，则将其重定向到`/`（而不是默认的`/home`值）。
- en: '`app/Http/Middleware/RedirectIfAuthenticated.php`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/Http/Middleware/RedirectIfAuthenticated.php`:'
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With that done, our login process will now work correctly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们的登录流程现在将正常工作。
- en: Adding authentication links to the toolbar
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在工具栏中添加身份验证链接
- en: Let's now add login and logout links in the toolbar so Vuebnb users can easily
    access these features.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在工具栏中添加登录和注销链接，以便Vuebnb用户可以轻松访问这些功能。
- en: The login link is simply a `RouterLink` pointing to the `login` route.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 登录链接只是一个指向`login`路由的`RouterLink`。
- en: 'The logout link is a bit more interesting: we capture the click event from
    this link and trigger the submission of a hidden form. This form sends a POST
    request to the `/logout` server route, which logs the user out and redirects them
    back to the home page. Note that we must include the CSRF token as a hidden input
    for this to work.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 登出链接更有趣：我们捕获此链接的点击事件，并触发隐藏表单的提交。此表单向`/logout`服务器路由发送POST请求，将用户注销并将其重定向回主页。请注意，为使此工作，我们必须将CSRF令牌作为隐藏输入包含在内。
- en: '`resources/assets/components/App.vue`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/App.vue`:'
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Protecting the saved route
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护保存的路由
- en: We can use our login system now to protect certain routes from guests, that
    is, unauthenticated users. Laravel provides the `auth` middleware, which can be
    applied to any route and will redirect a guest user to the login page if they
    attempt to access it. Let's apply this to our saved page route.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用我们的登录系统来保护某些路由免受未经身份验证的用户的访问。Laravel提供了`auth`中间件，可以应用于任何路由，并且如果访客用户尝试访问它，将会将其重定向到登录页面。让我们将其应用于我们保存的页面路由。
- en: '`routes/web.php`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes/web.php`:'
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you log out of the application and attempt to access this route from the
    navigation bar of your browser, you'll find it redirects you back to `/login`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从应用程序注销并尝试从浏览器的导航栏访问此路由，您会发现它会将您重定向回`/login`。
- en: Passing authentication state to the frontend
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将身份验证状态传递给前端
- en: We now have a complete mechanism for logging users in and out of Vuebnb. However,
    the frontend app is not yet aware of the user's authentication state. Let's remedy
    that now so we can add authentication-based features to the frontend.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个完整的登录和注销Vuebnb的机制。然而，前端应用程序还不知道用户的身份验证状态。让我们现在解决这个问题，这样我们就可以向前端添加基于身份验证的功能。
- en: auth meta property
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: auth元属性
- en: We'll begin by adding the authentication state to the meta information we pass
    through in the head of each page. We'll utilize the `Auth` facade `check` method,
    which returns `true` if the user is authenticated, and assign this to a new `auth` property.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将身份验证状态添加到我们通过每个页面头部传递的元信息中。我们将利用`Auth`外观的`check`方法，如果用户已经验证，它将返回`true`，并将其分配给一个新的`auth`属性。
- en: '`app/Http/Controllers/ListingController.php`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/Http/Controllers/ListingController.php`:'
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We'll also add an `auth` property to our Vuex store. We'll mutate it from the `addData` method
    which, as you'll recall from the previous chapter, is where we retrieve data from
    the document head or API. Since the API does not include meta data, we'll conditionally
    mutate the `auth` property to avoid accessing a potentially undefined object property.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在我们的Vuex存储中添加一个`auth`属性。我们将从`addData`方法中对其进行变化，正如您从上一章中记得的那样，这是我们从文档头部或API中检索数据的地方。由于API不包括元数据，我们将有条件地改变`auth`属性，以避免访问可能未定义的对象属性。
- en: '`resources/assets/js/store.js`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/store.js`:'
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With that done, Vuex is now tracking the authentication state of the user.
    Be sure to test this out by logging in and out and noticing the value of `auth` in
    the Vuex tab of Vue Devtools:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Vuex已经在跟踪用户的身份验证状态。一定要通过登录和注销来测试这一点，并注意Vue Devtools的Vuex选项卡中的`auth`的值：
- en: '![](assets/a51dc23b-ea82-4394-b040-bc876b474174.png)Figure 9.6\. Value of auth in
    Vue Devtools'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a51dc23b-ea82-4394-b040-bc876b474174.png)图9.6。Vue Devtools中`auth`的值'
- en: Responding to authenticated state
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应身份验证状态
- en: Now that we're tracking the authentication state of the user, we can get Vuebnb
    to respond to it. For one, let's make it so that a user can't save a listing unless
    they're logged in. To do this, we'll modify the behavior of the `toggleSaved`
    mutator method so that if the user is logged in they can save an item, but if
    not they are redirected to the login page via the `push` method of Vue Router.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在跟踪用户的身份验证状态，我们可以让Vuebnb对其做出响应。首先，让我们使用户在未登录时无法保存列表。为此，我们将修改`toggleSaved`变化器方法的行为，以便如果用户已登录，则可以保存项目，但如果没有，则通过Vue
    Router的`push`方法重定向到登录页面。
- en: Note that we'll have to import our router module at the top of the file to access
    its features.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将不得不在文件顶部导入我们的路由模块，以便访问其功能。
- en: '`resources/assets/js/store.js`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/store.js`:'
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We'll also make it so that either the login link or the logout link is shown
    in the toolbar, never both. This can be achieved by using `v-if` and `v-else` directives
    in the toolbar that depend on the `$store.state.auth` value.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使工具栏中显示登录链接或注销链接，而不会同时显示两者。这可以通过工具栏中依赖于`$store.state.auth`值的`v-if`和`v-else`指令来实现。
- en: It would also make sense to hide the saved page link unless the user is logged
    in, so let's do that as well.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除非用户已登录，否则隐藏保存页面链接也是有道理的，因此我们也要这样做。
- en: '`resources/assets/components/App.vue`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/App.vue`:'
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is how the toolbar will look now, depending on whether the user is logged
    in or out:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，工具栏的外观将取决于用户是否已登录或注销：
- en: '![](assets/0c0883d4-739c-4010-a983-62e5d8b00ef4.png)Figure 9.8\. Comparison
    of the logged in and logged out state in toolbar'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/0c0883d4-739c-4010-a983-62e5d8b00ef4.png)图9.8。工具栏中已登录和已注销状态的比较'
- en: Retrieving saved items from the database
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据库中检索保存的项目
- en: Let's now work on retrieving the saved items from the database and displaying
    them in the frontend. To begin with, we'll add a new `saved` property to the metadata
    we put in the document head. This will be an empty array if the user is logged
    out, or the array of saved listing IDs associated with that user, if they're logged
    in.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始从数据库中检索保存的项目并在前端显示它们。首先，我们将在文档头部放置的元数据中添加一个新的`saved`属性。如果用户已注销，这将是一个空数组，或者如果他们已登录，则是与该用户关联的保存列表ID数组。
- en: '`app/Http/Controllers/ListingController.php`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/Http/Controllers/ListingController.php`:'
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Back in the frontend, we'll put the logic for retrieving the saved items in
    the `beforeEach` router navigation guard. The reason we put it here and not in
    the `addData` mutation is that we don't want to directly assign the data to the
    store state, but instead call the `toggleSaved` mutation for each of the listings.
    You can't commit a mutation from another mutation, so this must be done outside
    the store.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端，我们将把检索保存项目的逻辑放在`beforeEach`路由导航守卫中。我们将其放在这里而不是在`addData`变化中的原因是，我们不希望直接将数据分配给存储状态，而是对每个列表调用`toggleSaved`变化。您不能从另一个变化中提交变化，因此必须在存储之外完成此操作。
- en: '`resources/assets/js/router.js`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/router.js`:'
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let's also remove the placeholder listing IDs we added to `saved` in the previous
    chapter so the store is empty upon initialization.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还删除我们在上一章中添加到`saved`中的占位符列表ID，以便存储在初始化时为空。
- en: '`resources/assets/js/store.js`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/store.js`:'
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With that done, we should find that the saved listings in the database now
    match those in the frontend if we check with Vue Devtools:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，我们应该发现，如果使用Vue Devtools检查，数据库中的保存列表现在与前端中的列表匹配：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![](assets/331bfe47-6056-44d8-a730-a77832088b03.png)Figure 9.8\. Vuex tab of
    Vue Devtools shows saved listings match database'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/331bfe47-6056-44d8-a730-a77832088b03.png)图9.8。Vue Devtools的Vuex选项卡显示保存的列表与数据库匹配'
- en: Persisting saved listings
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久保存列表
- en: 'The mechanism for persisting saved listings is as follows: when a listing is
    toggled in the frontend app, we trigger an AJAX request that POSTs the ID to a
    route on the backend. This route calls a controller that will update the model:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 持久保存列表的机制如下：当在前端应用中切换列表时，我们触发一个AJAX请求，将ID POST到后端的一个路由。这个路由调用一个控制器，将更新模型。
- en: '![](assets/5d82c6ee-a246-4db9-8fbf-4d2056374558.png)Figure 9.9\. Persisting
    saved listings'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5d82c6ee-a246-4db9-8fbf-4d2056374558.png)图9.9。持久保存列表'
- en: Let's now implement this mechanism.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现这个机制。
- en: Creating an API route
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建API路由
- en: We'll begin on the server side and add a route for the frontend to POST listing
    IDS to. We'll need to add the `auth` middleware so that only authenticated users
    can access this route (we'll discuss the meaning of `:api` shortly).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从服务器端开始，并为前端添加一个路由来POST listing IDS。我们需要添加`auth`中间件，以便只有经过身份验证的用户才能访问这个路由（我们将很快讨论`:api`的含义）。
- en: '`routes/api.php`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes/api.php`:'
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Since this is an API route, its full path will be `/api/user/toggle_saved`.
    We haven''t yet created the controller that this route calls, `UserController`,
    so let''s do that now:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个API路由，它的完整路径将是`/api/user/toggle_saved`。我们还没有创建这个路由调用的控制器`UserController`，所以现在让我们来做这个。
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this new controller, we'll add the `toggled_saved` handling method. Since
    this is an HTTP POST route, this method will have access to the form data. We'll
    make it so that the frontend AJAX call to this route includes an `id` field, which
    will be the listing ID we want to toggle. To access this field, we can use the `Input` facade,
    that is, `Input::get('id');`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的控制器中，我们将添加`toggled_saved`处理方法。由于这是一个HTTP POST路由，这个方法将可以访问表单数据。我们将使前端对这个路由的AJAX调用包含一个`id`字段，这将是我们想要切换的listing的ID。要访问这个字段，我们可以使用`Input`外观，即`Input::get('id');`。
- en: Since we're using the `auth` middleware on this route, we can retrieve the user
    model associated with the request by using the `Auth::user()` method. We can then
    either add or remove the ID from the user's `saved` listings, just as we do in
    the `toggledSaved` method in our Vuex store.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这个路由上使用了`auth`中间件，我们可以通过使用`Auth::user()`方法来检索与请求相关联的用户模型。然后我们可以像在我们的Vuex
    store的`toggledSaved`方法中那样，要么添加要么删除用户的`saved`列表中的ID。
- en: Once the ID is toggled, we can then use the model's `save` method to persist
    the update to the database.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦ID被切换，我们就可以使用模型的`save`方法将更新持久化到数据库中。
- en: '`app/Http/Controllers/UserController.php`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/Http/Controllers/UserController.php`:'
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Vuex actions
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vuex actions
- en: In [Chapter 8](a05bfc41-f7fe-471f-a964-205c36fe528d.xhtml), *Managing Your Application
    State With Vuex*, we discussed the key principles of the Flux pattern, including
    the principle that mutations must be synchronous to avoid race conditions that
    make our application data unpredictable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](a05bfc41-f7fe-471f-a964-205c36fe528d.xhtml)中，*使用Vuex管理应用程序状态*，我们讨论了Flux模式的关键原则，包括mutations必须是同步的，以避免使我们的应用程序数据不可预测的竞争条件。
- en: 'If you have a need to include asynchronous code in a mutator method, you should
    instead create an *action*. Actions are like mutations, but instead of mutating
    the state, they commit mutations. For example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在一个mutator方法中包含异步代码，您应该创建一个*action*。Actions类似于mutations，但是不是直接改变状态，而是提交mutations。例如：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: By abstracting asynchronous code into actions we can still centralize any state-altering
    logic in the store without tainting our application data through race conditions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将异步代码抽象成actions，我们仍然可以将任何改变状态的逻辑集中在store中，而不会通过竞争条件来污染我们的应用程序数据。
- en: AJAX request
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AJAX请求
- en: Let's now use AJAX to make the request to `/api/user/toggle_saved` when a listing
    is saved. We'll put this logic into a Vuex action so that the `toggleSaved` mutation
    is not committed until the AJAX call resolves. We'll import the Axios HTTP library
    into the store to facilitate this.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用AJAX来发起对`/api/user/toggle_saved`的请求当一个listing被保存时。我们将把这个逻辑放到一个Vuex action中，这样当AJAX调用解析时，`toggleSaved`mutation就不会被提交。我们将在store中导入Axios
    HTTP库来实现这一点。
- en: Also, let's move the authentication check from the mutation to the action, as
    it makes sense to do this check before the AJAX call is initiated.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，让我们将认证检查从mutation移到action中，因为在发起AJAX调用之前进行这个检查是有意义的。
- en: '`resources/assets/js/store.js`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/store.js`:'
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We now need to call the `toggledSaved` action, not the mutation, from our `ListingSave` component.
    Calling an action is done in exactly the same way as a mutation, only the terminology
    changes from `commit` to `dispatch`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要从我们的`ListingSave`组件中调用`toggledSaved`action，而不是mutation。调用一个action的方式与mutation完全相同，只是术语从`commit`变为`dispatch`。
- en: '`resources/assets/components/ListingSave.vue`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ListingSave.vue`:'
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The code for this feature in the frontend is correct, but if we test it out
    and try and save an item we get a *401 Unauthenticated* error from the server:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前端的这个功能代码是正确的，但是如果我们测试并尝试保存一个项目，我们会从服务器得到一个*401未认证*的错误：
- en: '![](assets/41cc0829-043d-44ae-ac6c-f008896dd103.png)Figure 9.10\. AJAX call
    results in a 401 Unauthenticated error'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/41cc0829-043d-44ae-ac6c-f008896dd103.png)图9.10. AJAX调用导致401未认证错误'
- en: API authentication
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API认证
- en: We added the `auth` middleware to our `/api/user/toggle_saved` route to protect
    it from guest users. We also specified the `api` guard for this middleware, that
    is, `auth:api`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`/api/user/toggle_saved`路由中添加了`auth`中间件，以保护它免受访客用户的攻击。我们还为这个中间件指定了`api`守卫，即`auth:api`。
- en: '*Guards* define how users are authenticated and are configured in the following
    file.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*守卫*定义了用户如何进行认证，并在以下文件中进行配置。'
- en: '`config/auth.php`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`config/auth.php`:'
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Our web routes use the *session* driver which maintains authentication state
    using session cookies. The session driver ships with Laravel and works out-of-the-box.
    API routes, though, use the *token* guard by default. We have not yet implemented
    this driver, hence our AJAX calls are unauthorized.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的web路由使用*session*驱动程序，它使用会话cookie来维护认证状态。会话驱动程序随Laravel一起提供，并且可以直接使用。但是，默认情况下，API路由使用*token*守卫。我们还没有实现这个驱动程序，因此我们的AJAX调用未经授权。
- en: We could use the session driver for API routes as well, but this is not recommended,
    as session authentication is not sufficient for AJAX requests. We're instead going
    to use the `passport` guard, which implements the OAuth protocol.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在API路由中使用会话驱动程序，但这并不推荐，因为会话认证对于AJAX请求来说是不够的。相反，我们将使用`passport`守卫，它实现了OAuth协议。
- en: You may see `auth` used as a shorthand for `auth:web`, as the web guard is the
    default.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会看到`auth`用作`auth:web`的简写，因为web守卫是默认的。
- en: OAuth
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth
- en: OAuth is an authorization protocol that allows third-party applications to access
    a user's data on a server without exposing their password. Access to this protected
    data is given in exchange for a special token that is granted to the application
    once it, and the user, have identified themselves to the server. A typical use
    case for OAuth is *social login*, for example,when you utilize a Facebook or Google
    login for your own website.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth是一种授权协议，允许第三方应用程序访问服务器上用户的数据，而不暴露其密码。对受保护数据的访问是以特殊令牌的形式给予的，一旦第三方应用程序和用户向服务器确认了身份，该令牌就会被授予。OAuth的一个典型用例是*社交登录*，例如，当您为自己的网站使用Facebook或Google登录时。
- en: One challenge of making secure AJAX requests is that you can't store any credentials
    in the frontend source code, as it's trivial for an attacker to find these. A
    simple implementation of OAuth, where the third-party application is actually
    your own frontend app, is a good solution to the issue. This is the approach we'll
    be taking now for Vuebnb.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 进行安全的AJAX请求的一个挑战是，您不能将任何凭据存储在前端源代码中，因为攻击者可以轻松找到这些凭据。OAuth的一个简单实现，其中第三方应用实际上是您自己的前端应用，是解决这个问题的一个很好的解决方案。这是我们现在将要采取的方法，用于Vuebnb。
- en: While OAuth is a great solution for API authentication, it is also quite an
    in-depth topic that I can't fully cover in this book. I recommend you read this
    guide to get a better understanding: [https://www.oauth.com/](https://www.oauth.com/).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然OAuth是API身份验证的一个很好的解决方案，但它也是一个我无法在本书中完全涵盖的深入主题。我建议您阅读这篇指南以获得更好的理解：[https://www.oauth.com/](https://www.oauth.com/)。
- en: Laravel Passport
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Laravel Passport
- en: Laravel Passport is an implementation of OAuth that can easily be set up in
    a Laravel application. Let's install it now for use in Vuebnb.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel Passport是OAuth在Laravel应用程序中可以轻松设置的实现。让我们现在安装它以在Vuebnb中使用。
- en: 'First, install Passport with Composer:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用Composer安装Passport：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Passport includes new database migrations that generate the tables needed to
    store OAuth tokens. Let''s run the migration:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Passport包括生成存储OAuth令牌所需的表的新数据库迁移。让我们运行迁移：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following command will install the encryption keys needed to generate secure
    tokens:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将安装生成安全令牌所需的加密密钥：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: After running this command, add the `Laravel\Passport\HasApiTokens` trait to
    the user model.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，将`Laravel\Passport\HasApiTokens`特性添加到用户模型。
- en: '`app/User.php`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/User.php`：'
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Finally, in the `config/auth.php` configuration file, let's set the driver option
    of the API guard to `passport`. This ensures the `auth` middleware will use Passport
    as a guard for API routes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`config/auth.php`配置文件中，让我们将API守卫的驱动程序选项设置为`passport`。这确保`auth`中间件将使用Passport作为API路由的守卫。
- en: '`config/auth.php`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`config/auth.php`：'
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Attaching tokens
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加令牌
- en: OAuth requires an access token to be sent to the frontend app when the user
    logs in. Passport includes a middleware that can handle this for you. Add the `CreateFreshApiToken` middleware
    to the web middleware group and the `laravel_token` cookie will be attached to
    outgoing responses.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth要求在用户登录时将访问令牌发送到前端应用程序。Passport包括一个中间件，可以为您处理这个问题。将`CreateFreshApiToken`中间件添加到web中间件组，`laravel_token`
    cookie将附加到出站响应。
- en: '`app/Http/Kernel.php`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/Http/Kernel.php`：'
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For outgoing requests, we need to add some headers to our AJAX calls. We can
    make it so Axios automatically attaches these by default. `''X-Requested-With'':
    ''XMLHttpRequest''` ensures that Laravel knows the request was from AJAX, while `''X-CSRF-TOKEN'':
    window.csrf_token` attaches the CSRF token.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '对于出站请求，我们需要在AJAX调用中添加一些标头。我们可以使Axios默认自动附加这些。`''X-Requested-With'': ''XMLHttpRequest''`确保Laravel知道请求来自AJAX，而`''X-CSRF-TOKEN'':
    window.csrf_token`附加CSRF令牌。'
- en: '`resources/assets/js/store.js`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/store.js`：'
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'With that done, our API requests should now be properly authenticated. To test
    this, let''s use Tinker to see which items we have saved for our first seeded
    user:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们的API请求现在应该得到适当的身份验证。为了测试这一点，让我们使用Tinker来查看我们为我们的第一个种子用户保存了哪些项目：
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Make sure you're logged in as that user and load Vuebnb in the browser. Toggle
    a few of your saved listing selections and rerun the query above. You should find
    that the database is now persisting the saved listing IDs.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您以该用户的身份登录并在浏览器中加载Vuebnb。切换一些已保存的列表选择并重新运行上面的查询。您应该发现数据库现在正在持久保存已保存的列表ID。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about authentication in full-stack Vue/Laravel apps,
    including session-based authentication for web routes, and token-based authentication
    for API routes using Laravel Passport.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于全栈Vue/Laravel应用程序中的身份验证，包括基于会话的Web路由身份验证，以及使用Laravel Passport的API路由的基于令牌的身份验证。
- en: We used this knowledge to set up a login system for Vuebnb, and to allow saved
    room listings to be persisted to the database.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用这些知识为Vuebnb设置了登录系统，并允许将保存的房间列表持久保存到数据库中。
- en: Along the way, we also learned how to utilize CSRF tokens for securing forms,
    and about Vuex actions for adding asynchronous code to the store.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们还学习了如何利用CSRF令牌来保护表单，以及关于Vuex操作用于向存储添加异步代码的知识。
- en: In the next, and final, chapter, we will learn how to deploy a full-stack Vue
    and Laravel app to production by deploying Vuebnb to a free Heroku PHP server.
    We will also begin serving images and other static content from a free CDN.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，也是最后一章中，我们将学习如何通过将Vuebnb部署到免费的Heroku PHP服务器来将全栈Vue和Laravel应用程序部署到生产环境。我们还将开始从免费CDN提供图像和其他静态内容。
