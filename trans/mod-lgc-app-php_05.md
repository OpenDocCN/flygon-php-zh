# 第五章。用依赖注入替换全局变量

到目前为止，我们所有的类和函数都已经整合到一个中心位置，并且所有相关的`include`语句都已经被移除。我们更希望开始为我们的类编写测试，但很可能我们的类中有很多嵌入的`global`变量。这些可能会导致很多麻烦，因为在一个地方修改`global`会改变另一个地方的值。接下来的步骤是从我们的类中移除所有`global`关键字的使用，而是注入必要的依赖关系。

### 注意

**什么是依赖注入？**

依赖注入意味着我们从外部将我们的依赖关系推入一个类，而不是在类内部将它们拉入一个类。（使用`global`从全局范围将变量拉入当前范围，因此它与注入相反。）依赖注入实际上是一个非常简单的概念，但有时很难作为一种纪律坚持。

# 全局依赖

以一个天真的例子开始，假设一个`Example`类需要一个数据库连接。在这里，我们在一个类方法中创建连接：

```php
**classes/Example.php**
1 <?php
2 class Example
3 {
4 public function fetch()
5 {
6 $db = new Db('hostname', 'username', 'password');
7 return $db->query(...);
8 }
9 }
10 ?>
```

我们在需要它的方法中创建了`Db`依赖。这样做有几个问题。其中一些是：

+   每次调用这个方法时，我们都会创建一个新的数据库连接，这可能会耗尽我们的资源。

+   如果我们需要更改连接参数，我们需要在每个创建连接的地方进行修改。

+   很难从这个类的外部看出它的依赖关系是什么。

写完这样的代码后，许多开发人员发现了`global`关键字，并意识到他们可以在设置文件中创建一次连接，然后从全局范围中拉入它：

```php
**setup.php**
1 <?php
2 // some setup code, then:
3 $db = new Db('hostname', 'username', 'password');
4 ?>
```

```php
**classes/Example.php**
1 <?php
2 class Example
3 {
4 public function fetch()
5 {
6 global $db;
7 return $db->query(...);
8 }
9 }
10 ?>
```

即使我们仍然拉入依赖，这种技术解决了多个数据库连接使用有限资源的问题，因为相同的数据库连接在整个代码库中被重复使用。这种技术还使得我们可以在一个地方，即`setup.php`文件中，更改我们的连接参数，而不是在几个地方。然而，仍然存在一个问题，并且增加了一个问题：

+   我们仍然无法从类的外部看出它的依赖关系。

+   如果`$db`变量被调用代码中的任何地方更改，那么这个更改将在整个代码库中反映出来，导致调试麻烦。

最后一点是致命的。如果一个方法将`$db = 'busted';`，那么`$db`的值现在是一个字符串，而不是整个代码库中的数据库连接对象。同样，如果`$db`对象被修改，那么它将在整个代码库中被修改。这可能导致非常困难的调试会话。

## 替换过程

因此，我们希望从代码库中移除所有的`global`调用，以便更容易进行故障排除，并揭示我们类的依赖关系。以下是我们将使用的一般过程来用依赖注入替换`global`调用：

1.  在我们的类中找到一个`global`变量。

1.  将该类中的所有`global`变量移到构造函数中，并将它们的值保留为属性，并使用属性而不是全局变量。

1.  抽查类是否仍然有效。

1.  将构造函数中的`global`调用转换为构造函数参数。

1.  将类的所有实例化转换为传递依赖关系。

1.  抽查，提交，推送，并通知 QA。

1.  重复处理我们类文件中的下一个`global`调用，直到没有剩余。

### 注意

在这个过程中，我们*一次处理一个类*而不是*一次处理一个变量*。前者比后者耗时少，更注重单元。

## 找到一个全局变量

这很容易通过项目范围的搜索功能实现。我们在中心类目录位置搜索`global`，然后得到一个包含该关键字的类文件列表。

## 将全局变量转换为属性

假设我们的搜索发现了一个名为`Example`的类，其代码如下：

```php
**classes/Example.php**
1 <?php
2 class Example
3 {
4 public function fetch()
5 {
6 global $db;
7 return $db->query(...);
8 }
9 }
10 ?>
```

现在我们将全局变量移动到在构造函数中设置的属性，并将“fetch（）”方法转换为使用该属性：

```php
**classes/Example.php**
1 <?php
2 class Example
3 {
4 protected $db;
5
6 public function __construct()
7 {
8 global $db;
9 $this->db = $db;
10 }
11
12 public function fetch()
13 {
14 return $this->db->query(...);
15 }
16 }
17 ?>
```

### 提示

如果在同一个类中有多个“全局”调用，我们应该将它们全部转换为该类中的属性。我们希望*一次只处理一个类*，因为这样可以使后续过程更容易进行。

## 抽查类

现在我们已经将“全局”调用转换为此一个类中的属性，我们需要测试应用程序以确保它仍然可以正常工作。然而，由于尚未建立正式的测试系统，我们通过浏览或调用使用修改后的类的文件来进行伪测试或抽查。

如果愿意，我们可以在确定应用程序仍然正常工作后进行临时提交。我们暂时不会推送到中央仓库或通知 QA；我们只是想要一个可以回滚的点，以便在以后需要撤销更改时使用。

## 将全局属性转换为构造函数参数

一旦我们确定类在属性放置的情况下可以正常工作，我们需要将构造函数中的“全局”调用转换为使用传递的参数。鉴于我们上面的“示例”类，转换后的版本可能如下所示：

```php
**classes/Example.php**
1 <?php
2 class Example
3 {
4 protected $db;
5
6 public function __construct(Db $db)
7 {
8 $this->db = $db;
9 }
10
11 public function fetch()
12 {
13 return $this->db->query(...);
14 }
15 }
16 ?>
```

我们所做的只是移除“全局”调用，并添加构造函数参数。我们需要对构造函数中的每个“全局”都这样做。

由于“全局”是针对特定类的对象，我们将参数类型提示为该类（在本例中为`Db`）。如果可能的话，我们应该将参数类型提示为接口，因此如果`Db`对象实现了*DbInterface*，我们应该将类型提示为*DbInterface*。这将有助于测试和以后的重构。我们也可以根据需要将参数类型提示为`array`或`callable`。并非所有的“全局”调用都是针对有类型的值，因此并非所有的参数都需要类型提示（例如，当预期参数是字符串时）。

### 将实例化转换为使用参数

在将“全局”变量转换为构造函数参数后，我们会发现遗留应用程序中类的每个实例化现在都已经失效。这是因为构造函数签名已经改变。考虑到这一点，我们现在需要搜索*整个代码库*（不仅仅是类）以查找类的实例化，并将实例化更改为新的签名。

为了搜索实例化，我们使用项目范围的搜索工具，使用正则表达式查找使用我们类名的`new`关键字：

```php
**new\s+Example\W**

```

该表达式搜索`new`关键字，后面至少有一个空白字符，然后是终止的非单词字符（例如括号、空格或分号）。

### 注意

**格式问题**

遗留代码库以格式混乱而闻名，这意味着在某些情况下，这个表达式并不完美。这里给出的表达式可能无法找到实例化，例如，当`new`关键字在一行上，类名紧随其后，但在下一行而不是同一行上时。

**使用 use 的类别名**

在 PHP 5.3 及更高版本中，类可以使用 use 语句别名为另一个类名，如下所示：

```php
1 <?php
2 use Example as Foobar;
3 // ...
4 $foo = new Foobar;
5 ?>
```

在这种情况下，我们需要进行两次搜索：一次使用`\s+Example\s+as`来发现各种别名，另一次搜索新的关键字和别名。

当我们在代码库中发现类的实例化时，我们修改它们以根据需要传递参数。例如，如果一个页面脚本看起来像这样：

```php
**page_script.php**
1 <?php
2 // a setup file that creates a $db variable
3 require 'includes/setup.php';
4 // ...
5 $example = new Example;
6 ?>
```

我们需要将参数添加到实例化中：

```php
**page_script.php**
1 <?php
2 // a setup file that creates a $db variable
3 require 'includes/setup.php';
4 // ...
5 $example = new Example($db);
6 ?>
```

新的实例化需要与新的构造函数签名匹配，因此如果构造函数需要多个参数，我们需要传递所有参数。

## 抽查，提交，推送，通知 QA

我们已经完成了这个类的转换过程。现在我们需要抽查转换后的实例化，但是（一如既往）这不是一个自动化的过程，因此我们需要运行或以其他方式调用具有更改代码的文件。如果出现问题，就返回并修复它们。

一旦我们这样做了，并确保没有错误，我们可以提交更改后的代码，将其推送到我们的中央存储库，并通知 QA 需要对传统应用程序运行其测试套件。

## 做...直到

这是将单个类从使用`global`调用转换为使用依赖注入的过程。回到类文件，找到下一个具有`global`调用的类，并重新开始该过程。继续这样做，直到类中没有更多的`global`调用为止。

# 常见问题

## 如果我们在静态方法中找到全局变量怎么办？

有时我们会发现静态类方法使用`global`变量，如下所示：

```php
1 <?php
2 class Foo
3 {
4 static public function doSomething($baz)
5 {
6 global $bar;
7 // ... do something with $bar ...
8 }
9 }
10 ?>
```

这是一个问题，因为没有构造函数可以将`global`变量移动为属性。这里有两个选择。

第一个选择是在静态方法本身上将所有需要的全局变量作为参数传递，从而改变方法的签名：

```php
1 <?php
2 class Foo
3 {
4 static public function doSomething($bar, $baz)
5 {
6 // ... do something with $bar ...
7 }
8 }
9 ?>
```

然后，我们将在整个代码库中搜索`Foo::doSomething(`的所有用法，并每次传递`$bar`值。因此，我建议将新参数添加到*签名的*开头，而不是结尾，因为这样做可以更轻松地进行搜索和替换。例如：

搜索：

```php
Foo::doSomething\(
```

替换为：

```php
Foo::doSomething\($bar,
```

第二个选择是更改类，使其必须被实例化，并使所有方法成为实例方法。转换后，类可能看起来像这样：

```php
1 <?php
2 class Foo
3 {
4 protected $bar;
5
6 public function __construct($bar)
7 {
8 $this->bar = $bar;
9 }
10
11 public function doSomething($baz)
12 {
13 // ... do something with $this->bar ...
14 }
15 }
16 ?>
```

之后，我们需要：

1.  搜索所有`Foo::`静态调用的代码库；

1.  在进行静态调用之前创建`Foo`的实例及其`$bar`依赖项（例如，`$foo = new Foo($bar);`），并

1.  用`$foo->doSomething()`替换`Foo::doSomething()`的调用。

## 是否有替代的转换过程？

上述描述的过程是一个逐个类的过程，我们首先将单个类中的全局变量移动到构造函数中，然后在该类中将全局属性更改为实例属性，最后更改该类的实例化。

或者，我们可以选择一个修改过的过程：

1.  将所有全局变量更改为所有类中的属性，然后进行测试/提交/推送/QA。

1.  将所有类中的全局属性更改为构造函数参数，并更改*所有类*的实例化，然后进行测试/提交/推送/QA。

这可能是较小代码库的一个合理替代方案，但它也带来了一些问题，比如：

1.  在将全局变量转换为属性时，搜索`global`调用变得更加困难，因为我们将在转换和未转换的类中看到`global`关键字。

1.  每个主要步骤的提交将更大，更难阅读。

因为这些原因和其他原因，我认为最好按照描述的过程进行。它适用于大型和小型代码库，并将增量更改保持在更小、更易阅读的部分中。

## 变量中的类名呢？

有时我们会发现类是基于变量值实例化的。例如，这将根据`$class`变量的值创建一个对象：

```php
**page_script.php**
1 <?php
2 // $type is defined earlier in the file, and then:
3 $class = $type . '_Record';
4 $record = new $class;
5 ?>
```

如果`$type`是`Blog`，那么`$record`对象将是`Blog_Record`类的对象。

当搜索要转换为使用构造函数参数的类实例化时，这种情况很难发现。很抱歉，我没有自动找到这些类型实例化的好建议。我们能做的最好的事情就是搜索`new\s+\$`而没有任何类名，并逐个手动修改调用。

## 超级全局变量呢？

超级全局变量在删除全局变量时代表一个具有挑战性的特殊情况。它们在每个范围内都是自动全局的，因此它们具有全局变量的所有缺点。我们不会通过搜索`global`关键字找到它们（尽管我们可以按名称搜索它们）。因为它们确实是全局的，所以我们需要从我们的类中删除它们，就像我们需要删除`global`关键字一样。

当我们需要时，我们可以将每个超全局变量的副本传递给类。在只需要一个的情况下，这可能没问题，但通常我们需要两个或三个或更多的超全局变量。此外，传递`$_SESSION`的副本将不会按预期工作；PHP 使用实际的`$_SESSION`超全局变量来写入会话数据，因此对副本的更改将不会被接受。

作为解决方案，我们可以使用一个`Request`数据结构类。`Request`封装了每个非`$_SESSION`超全局变量的副本。同时，`Request`保持对`$_SESSION`的引用，以便对象属性的更改被真正的`$_SESSION`超全局变量所接受。

### 注意

请注意，`Request`并不是一个 HTTP 请求对象本身。它只是 PHP 请求环境的表示，包括服务器、环境和会话值，其中许多在 HTTP 消息中找不到。

例如，假设我们有一个类使用`$_POST`、`$_SERVER`和`$_SESSION`：

```php
1 <?php
2 class PostTracker
3 {
4 public function incrementPostCount()
5 {
6 if ($_SERVER['REQUEST_METHOD'] != 'POST') {
7 return;
8 }
9
10 if (isset($_POST['increment_count'])) {
11 $_SESSION['post_count'] ++;
12 }
13 }
14 }
15 ?>
```

为了替换这些调用，我们首先在设置代码中创建一个共享的`Request`对象。

```php
**includes/setup.php**
1 <?php
2 // ...
3 $request = new \Mlaphp\Request($GLOBALS);
4 // ...
5 ?>
```

然后，我们可以通过将共享的`Request`对象注入到任何需要它的类中，从超全局变量中解耦，并使用`Request`属性代替超全局变量。

```php
1 <?php
2 use Mlaphp\Request;
3
4 class PostTracker
5 {
6 public function __construct(Request $request)
7 {
8 $this->request = $request;
9 }
10
11 public function incrementPostCount()
12 {
13 if ($this->request->server['REQUEST_METHOD'] != 'POST') {
14 return;
15 }
16
17 if (isset($this->request->post['increment_count'])) {
18 $this->request->session['post_count'] ++;
19 }
20 }
21 }
22 ?>
```

### 提示

如果在不同范围内保持对超全局值的更改很重要，请确保在整个应用程序中使用相同的`Request`对象。对一个`Request`对象中的值的修改不会反映在不同的`Request`对象中，除了`$session`值（因为它们都是对`$_SESSION`的引用）。

## 那么`$GLOBALS`呢？

PHP 还提供了一个超全局变量`$GLOBALS`。在我们的类和方法中使用这个超全局变量应该被视为使用`global`关键字。例如，`$GLOBALS['foo']`等同于`global $foo`。我们应该像处理`global`一样从我们的类中移除它。

# 回顾和下一步

在这一点上，我们已经从我们的类中移除了所有的`global`调用，以及所有对超全局变量的使用。这是我们代码质量的又一个重大改进。我们知道变量可以在本地修改，而不影响代码库的其他部分。

然而，我们的类可能仍然在其中有隐藏的依赖关系。为了使我们的类更具可测试性，我们需要发现并揭示这些依赖关系。这是下一章的主题。
