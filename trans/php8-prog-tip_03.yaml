- en: '*Chapter 2*: Learning about PHP 8''s Functional Additions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：学习PHP 8的功能增强'
- en: This chapter walks you through important additions and enhancements introduced
    to **PHP 8** at the procedural level. The code examples used show new PHP 8 features
    and techniques to facilitate procedural programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带您了解在程序级别引入的**PHP 8**的重要增强和改进。使用的代码示例展示了新的PHP 8功能和技术，以便促进程序化编程。
- en: Mastering the use of the new functions and techniques in this chapter will help
    you to write faster and cleaner applications. Even though this chapter focuses
    on commands and functions, all of the techniques are also useful when developing
    class methods as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握本章中新函数和技术的使用将帮助您编写更快、更干净的应用程序。尽管本章重点介绍命令和函数，但在开发类方法时，所有这些技术也很有用。
- en: 'The following topics are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Working with new PHP 8 operators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的PHP 8操作符
- en: Using arrow functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用箭头函数
- en: Understanding uniform variable syntax
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解统一变量语法
- en: Learning new array- and string-handling techniques
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习新的数组和字符串处理技术
- en: Securing SQLite databases with the authorizer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用authorizer保护SQLite数据库
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To examine and run the code examples provided in this chapter, the minimum
    recommended hardware is listed here:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查和运行本章提供的代码示例，以下是最低推荐的硬件要求：
- en: x86_64-based desktop PC or laptop
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于x86_64的台式机或笔记本电脑
- en: 1 gigabyte (GB) free disk space
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1千兆字节（GB）的可用磁盘空间
- en: 4 GB of random-access memory (RAM)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 GB的随机存取存储器（RAM）
- en: 500 kilobits per second (Kbps) or faster internet connection
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每秒500千位（Kbps）或更快的互联网连接
- en: 'In addition, you need to install the following software:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另外，您需要安装以下软件：
- en: Docker
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Docker Compose
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Please refer to the *Technical requirements* section of [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013),
    *Introducing New PHP 8 OOP Features,* for more information on Docker and Docker
    Compose installation, as well as how to build the Docker container used to demonstrate
    code explained in this book. Throughout, we refer to the directory in which you
    restored the sample code for this book as `/repo`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Docker和Docker Compose安装的更多信息，请参阅[*第1章*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013)的*技术要求*部分，介绍了如何构建用于演示本书中代码的Docker容器。在整个过程中，我们将参考您恢复本书示例代码的目录为`/repo`。
- en: 'The source code for this chapter is located here: [https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于此处：[https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices)。
- en: We can now begin our discussion by examining new PHP 8 operators.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始讨论新的PHP 8操作符了。
- en: Working with new PHP 8 operators
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的PHP 8操作符
- en: 'A number of new **operators** have been introduced with PHP 8\. In addition,
    PHP 8 generally introduces a uniform and consistent manner in which these operators
    can be used. In this section, we examine the following operators:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8引入了许多新的**操作符**。此外，PHP 8通常引入了一种统一和一致的方式来使用这些操作符。在本节中，我们将讨论以下操作符：
- en: Variadics operator
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: variadics操作符
- en: Nullsafe operator
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nullsafe操作符
- en: Concatenate operator
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接操作符
- en: Ternary operator
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三元操作符
- en: Let's start with a discussion of the variadics operator.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论variadics操作符开始。
- en: Using the variadics operator
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用variadics操作符
- en: 'The **variadics** operator consists of three leading dots (`...`) preceding
    a normal PHP variable (or object property). This operator has actually been with
    the language since PHP 5.6\. It''s also referred to as the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**variadics**操作符由三个前导点（`...`）组成，位于普通PHP变量（或对象属性）之前。这个操作符实际上从PHP 5.6版本开始就存在了。它也被称为以下内容：'
- en: Splat operator
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Splat操作符
- en: Scatter operator
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散列操作符
- en: Spread operator
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展操作符
- en: Before we dive into the improvements PHP 8 has made using this operator, let's
    have a quick look at how the operator is normally used.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究PHP 8使用这个操作符的改进之前，让我们快速看一下这个操作符通常的用法。
- en: Unknown number of arguments
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未知数量的参数
- en: One of the most common uses for the variadics operator is in a situation where
    you define a function with an unknown number of arguments.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: variadics操作符最常见的用途之一是在定义具有未知数量参数的函数的情况下。
- en: 'In the following code example, the `multiVardump()` function is able to accept
    any number of variables. It then concatenates the `var_export()` output and returns
    a string:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，`multiVardump()`函数能够接受任意数量的变量。然后连接`var_export()`的输出并返回一个字符串：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first time the function is called, we provide three arguments. The second
    time it's called, we only provide a single argument. Because we used a variadics
    operator, there's no need to rewrite the function to accommodate more or fewer
    arguments.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用函数时，我们提供了三个参数。第二次调用时，我们只提供了一个参数。由于我们使用了variadics操作符，所以无需重写函数来适应更多或更少的参数。
- en: Tip
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: There is a `func_get_args()` PHP function that gathers all function arguments
    into an array. The variadics operator is preferred, however, as it must be stated
    in the function signature, and thus makes the intentions of the program developer
    much clearer. For more information, see [https://php.net/func_get_args](https://php.net/func_get_args).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`func_get_args()` PHP函数，可以将所有函数参数收集到一个数组中。但是，variadics操作符更受青睐，因为它必须在函数签名中声明，从而使程序开发人员的意图更加清晰。更多信息，请参阅[https://php.net/func_get_args](https://php.net/func_get_args)。
- en: Vacuuming up remaining arguments
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 吸入剩余参数
- en: Another use for the variadics operator is to **vacuum up** any remaining arguments.
    This technique allows you to mix mandatory parameters with an unknown number of
    optional parameters.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: variadics操作符的另一个用途是**吸入**任何剩余参数。这种技术允许您将强制参数与未知数量的可选参数混合使用。
- en: 'In this example, a `where()` function produces a `WHERE` clause to be added
    to a **Structured Query Language** (**SQL**) `SELECT` statement. The first two
    arguments are mandatory: it''s not reasonable to produce a `WHERE` clause with
    no arguments! Have a look at the code here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`where()`函数生成一个要添加到**结构化查询语言**（**SQL**）`SELECT`语句中的`WHERE`子句。前两个参数是必需的：没有理由生成没有参数的`WHERE`子句！看一下这里的代码：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The calling code using this function might look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数的调用代码可能如下所示：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You might have noted that `where()` has to be called multiple times as the
    number of arguments is limited. This is a perfect candidate for the variadics
    operator! Here is how the rewritten `where()` function might look:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，由于参数数量有限，必须多次调用`where()`。这是可变参数运算符的一个完美应用场景！以下是重写的`where()`函数可能会看起来：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Because `...$args` is always returned as an array, to ensure any additional
    calls to the function do not lose clauses we need to perform an `array_merge()`
    operation. Here is the rewritten calling program:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`...$args`始终作为数组返回，为了确保对函数的任何额外调用不会丢失子句，我们需要执行一个`array_merge()`操作。以下是重写的调用程序：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The resultant SQL statement is shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的SQL语句如下所示：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding output shows that our SQL generation logic produces a valid statement.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示了我们的SQL生成逻辑生成了一个有效的语句。
- en: Using variadics operator as a replacement
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用可变参数运算符作为替代
- en: So far, none of this is foreign to an experienced PHP developer. What's different
    in PHP 8 is that the variadics operator can now be used in situations where *widening*
    might come into play.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，对于有经验的PHP开发人员来说，这些都不是陌生的。在PHP 8中的不同之处在于，可变参数运算符现在可以在可能涉及*扩展*的情况下使用。
- en: 'To properly describe the difference in how the variadics operator can be used,
    we''ll need to briefly return to **Object-Oriented Programming** (**OOP**). If
    we rewrite the `where()` function described just now into a class method, it might
    look like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确描述可变参数运算符的使用方式的不同之处，我们需要简要回顾一下**面向对象编程**（**OOP**）。如果我们将刚才描述的`where()`函数重写为类方法，它可能会像这样：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s say we have a `Select` class that extends `Where` but redefines
    the method signature using a variadics operator. This is how it might look:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个`Select`类，它扩展了`Where`，但使用可变参数运算符重新定义了方法签名。它可能如下所示：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It''s reasonable to use a variadics operator, as the number of arguments provided
    to formulate a `WHERE` clause is unknown. Here is the rewritten calling program
    using OOP:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可变参数运算符是合理的，因为提供给`WHERE`子句的参数数量是未知的。以下是使用面向对象编程重写的调用程序：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, when you try to run this example under PHP 7, the following warning
    appears:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当您尝试在PHP 7下运行此示例时，会出现以下警告：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that the code still works; however, the variadics operator is not seen
    by PHP 7 as a viable replacement. Here''s the same code running under PHP 8 (using
    `/repo/ch02/php8_variadics_no_problem.php`):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码仍然有效；但是，PHP 7不认为可变参数运算符是一个可行的替代方案。以下是在PHP 8下运行相同代码的情况（使用`/repo/ch02/php8_variadics_no_problem.php`）：
- en: '![Figure 2.1 – Variadics operator acceptable in extending class'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1-可接受扩展类中的可变参数运算符'
- en: '](image/Figure_2.1_B16992.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.1_B16992.jpg)'
- en: Figure 2.1 – Variadics operator acceptable in extending class
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1-可接受扩展类中的可变参数运算符
- en: Tip
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Here are two PHP documentation references that explain the reasoning behind
    the PHP variadics operator:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两个PHP文档引用，解释了PHP可变参数运算符背后的原因：
- en: '[https://wiki.php.net/rfc/variadics](https://wiki.php.net/rfc/variadics)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.php.net/rfc/variadics](https://wiki.php.net/rfc/variadics)'
- en: '[https://wiki.php.net/rfc/argument_unpacking](https://wiki.php.net/rfc/argument_unpacking)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.php.net/rfc/argument_unpacking](https://wiki.php.net/rfc/argument_unpacking)'
- en: Let's now have a look at the nullsafe operator.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看nullsafe运算符。
- en: Using the nullsafe operator
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用nullsafe运算符
- en: The **nullsafe** operator is used in a chain of object property references.
    If one of the properties in the chain does not exist (in other words, it is considered
    `NULL`), the operator returns a value of `NULL` safely, without issuing a warning.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: nullsafe运算符用于对象属性引用链。如果链中的某个属性不存在（换句话说，它被视为`NULL`），该运算符会安全地返回一个`NULL`值，而不会发出警告。
- en: 'As an example, let''s assume we have the following **Extended Markup Language**
    (**XML**) file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们有以下**扩展标记语言**（**XML**）文件：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is a code snippet that scans through the XML document and displays quantities:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个扫描XML文档并显示数量的代码片段：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We also need to define a `getQuantity()` function that first checks to see
    if that property is not empty before proceeding to the next level, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要定义一个`getQuantity()`函数，首先检查该属性是否不为空，然后再进行下一级的操作，如下所示：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you start dealing with deeper nesting levels, the function needed to check
    for the existence of a property grows in complexity. This is exactly where the
    nullsafe operator can be employed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始处理更深层次的嵌套级别时，需要检查属性是否存在的函数变得更加复杂。这正是nullsafe运算符可以发挥作用的地方。
- en: 'Have a look at the same program code, but without the need for the `getQuantity()`
    function, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下相同的程序代码，但不需要`getQuantity()`函数，如下所示：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let's now have a look at another use for the nullsafe operator.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看nullsafe运算符的另一个用途。
- en: Using the nullsafe operator to short-circuit a chain
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用nullsafe运算符来短路链
- en: The nullsafe operator is also useful when used in a chain of connected operations
    including references to object properties, array-element method calls, and static
    references.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: nullsafe运算符在连接的操作链中也很有用，包括对对象属性的引用、数组元素方法调用和静态引用。
- en: 'By way of illustration, here is a configuration file that returns an anonymous
    class. It defines different methods of extracting data depending on the type of
    file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，这里有一个配置文件，返回一个匿名类。它定义了根据文件类型提取数据的不同方法：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This class also includes a method to display the data, as illustrated in the
    following code snippet:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还包括一个显示数据的方法，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the calling program, in order to safely execute the `display()` method we
    need to add an `is_object()`extra safety check and also `method_exists()` before
    executing the callback, as illustrated in the following code snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用程序中，为了安全地执行 `display()` 方法，我们需要在执行回调之前添加一个 `is_object()` 的额外安全检查，以及 `method_exists()`，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As with the previous example, the nullsafe operator can be used to confirm the
    existence of `$config` as an object. By simply using the nullsafe operator in
    the first object reference, if the object or methods do not exist, the operator
    *short-circuits* the entire chain and returns `NULL`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，空安全运算符可以用来确认 `$config` 是否为对象。通过简单地在第一个对象引用中使用空安全运算符，如果对象或方法不存在，运算符将
    *短路* 整个链并返回 `NULL`。
- en: 'Here is the rewritten code using the PHP 8 nullsafe operator:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 PHP 8 空安全运算符重写的代码：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If `$config` comes back as `NULL`, the entire chain of operations is cancelled,
    no warning or notice is generated, and the return value (if any) is `NULL`. The
    net result is that we saved having to write three additional `if()` statements!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `$config` 返回为 `NULL`，则整个操作链将被取消，不会生成任何警告或通知，并且返回值（如果有）为 `NULL`。最终结果是我们省去了编写三个额外的
    `if()` 语句！
- en: Tip
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on other considerations when using this operator, please
    have a look here: [https://wiki.php.net/rfc/nullsafe_operator](https://wiki.php.net/rfc/nullsafe_operator).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用此运算符时的其他注意事项，请查看这里：[https://wiki.php.net/rfc/nullsafe_operator](https://wiki.php.net/rfc/nullsafe_operator)。
- en: Important note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'In order to pass the format parameter to the sample code file, you need to
    run the code from your browser as follows: `http://localhost:8888/ch02/php7_nullsafe_short.php?format=json`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将格式参数传递给示例代码文件，您需要从浏览器中运行以下代码：`http://localhost:8888/ch02/php7_nullsafe_short.php?format=json`。
- en: Next, we look at changes to the concatenation operator.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看连接运算符的更改。
- en: The concatenation operator has been demoted
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接运算符已经被降级
- en: 'Although the precise usage of the **concatenation** operator (for example,
    the period (.) has not changed in PHP 8, an extremely important change has been
    made in its relative position in the **order of precedence**. In earlier versions
    of PHP, the concatenation operator was considered equal to the lower-order arithmetic
    operators plus (`+`) and minus (`-`) in terms of precedence. Next, let''s look
    at a potential problem with the traditional order of precedence: counter-intuitive
    results.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 **连接** 运算符的精确用法（例如，句号（.）在 PHP 8 中没有改变，但在其 **优先级顺序** 中发生了极其重要的变化。在早期版本的 PHP
    中，连接运算符在优先级方面被认为与较低级别的算术运算符加号（`+`）和减号（`-`）相等。接下来，让我们看看传统优先级顺序可能出现的问题：令人费解的结果。
- en: Dealing with counter-intuitive results
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理令人费解的结果
- en: 'Unfortunately, this arrangement produces unexpected results. The following
    code snippet presents a counter-intuitive output when executed using PHP 7:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种安排会产生意想不到的结果。以下代码片段在使用 PHP 7 时执行时呈现出令人费解的输出：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Just looking at the code, you would expect output something along the lines
    of `"Sum:33"`. That''s not the case! Have a look at the following output when
    running on PHP 7.1:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅看代码，您可能期望输出类似于 `"Sum:33"`。但事实并非如此！在 PHP 7.1 上运行时，请查看以下输出：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At this point, you're probably wondering, *as the code never lies* where does
    the sum of `11` + `22` come out to `22`, as we see in the preceding output (last
    line)?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能会想，*因为代码从不说谎*，那么 `11` + `22` 的和为 `22`，正如我们在前面的输出（最后一行）中看到的那样？
- en: 'The answer involves order of precedence: starting with PHP 7, it''s consistently
    left-to-right. So, if we use parentheses to make the order of operations clearer,
    this is what actually happens:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 答案涉及优先级顺序：从 PHP 7 开始，它始终是从左到右。因此，如果我们使用括号来使操作顺序更清晰，实际发生的情况是这样的：
- en: '`echo ("Sum: " . $a) + $b;`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo ("Sum: " . $a) + $b;`'
- en: '`11` gets concatenated to `"Sum: "`, resulting in `"Sum: 11"` . as a string.
    The string is then type-juggled to an integer, resulting in a `0` + `22` expression,
    which gives us our result.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`11` 被连接到 `"Sum: "`，结果为 `"Sum: 11"`。作为字符串。然后将字符串转换为整数，得到 `0` + `22` 表达式，这给我们了结果。'
- en: 'If you run the same code in PHP 8, notice the difference here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 PHP 8 中运行相同的代码，请注意这里的区别：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see, the arithmetic operator took precedence over the concatenate
    operator. Using parentheses, this is effectively how the code was processed in
    PHP 8:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，算术运算符优先于连接运算符。使用括号，这实际上是 PHP 8 中代码的处理方式：
- en: '`echo "Sum: " . ($a + $b);`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo "Sum: " . ($a + $b);`'
- en: Tip
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**: Use parentheses to avoid complications arising from reliance
    upon order of precedence. For more information on the reasoning behind demoting
    the order of precedence of the concatenate operator, have a look here: [https://wiki.php.net/rfc/concatenation_precedence](https://wiki.php.net/rfc/concatenation_precedence).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：使用括号来避免依赖优先级顺序而产生的复杂性。有关降低连接运算符优先级背后的原因的更多信息，请查看这里：[https://wiki.php.net/rfc/concatenation_precedence](https://wiki.php.net/rfc/concatenation_precedence)。'
- en: We now turn our attention to the ternary operator.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将注意力转向三元运算符。
- en: Using nested ternary operators
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用嵌套的三元运算符
- en: '**Ternary operators** are not new to the PHP language. There is, however, a
    major difference in how they are interpreted in PHP 8\. This change has to do
    with the traditional **left-associative behavior** of this operator. To illustrate,
    let''s have a look at a simple example, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**三元运算符** 对于 PHP 语言来说并不新鲜。然而，在 PHP 8 中，它们的解释方式有一个重大的不同。这种变化与该运算符的传统 **左关联行为**
    有关。为了说明这一点，让我们看一个简单的例子，如下所示：'
- en: 'In this example, let''s say that we are using a `RecursiveDirectoryIterator`
    class in conjunction with a `RecursiveIteratorIterator` class to scan a directory
    structure. The starting code might look like this:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，假设我们正在使用 `RecursiveDirectoryIterator` 类与 `RecursiveIteratorIterator`
    类结合扫描目录结构。起始代码可能如下所示：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We then define a function that matches those files containing the `$searchPath`
    search path and ending with the `$searchExt` extension, as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个函数，匹配包含`$searchPath`搜索路径并以`$searchExt`扩展名结尾的文件，如下所示：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Instead of using `if / elseif / else`, however, some developers might be tempted
    to refactor this function using nested ternary operators instead. Here is how
    the same code used in the preceding step might look:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，一些开发人员可能会诱惑重构此函数，而不是使用`if / elseif / else`，而是使用嵌套三元运算符。以下是在前一步骤中使用的相同代码可能的样子：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output from both functions produces identical results in PHP 7, as illustrated
    in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数的输出在PHP 7中产生相同的结果，如下截图所示：
- en: '![Figure 2.2 – Nested ternary output using PHP 7'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 - 使用PHP 7进行嵌套三元输出'
- en: '](image/Figure_2.2_B16992.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.2_B16992.jpg)'
- en: Figure 2.2 – Nested ternary output using PHP 7
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 - 使用PHP 7进行嵌套三元输出
- en: 'In PHP 8, however, the use of nested ternary operations without parentheses
    is no longer allowed. Here is the output when running the same block of code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PHP 8中，不再允许使用没有括号的嵌套三元操作。运行相同代码块时的输出如下：
- en: '![Figure 2.3 – Nested ternary output using PHP 8'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 - 使用PHP 8进行嵌套三元输出'
- en: '](image/Figure_2.3_B16992.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.3_B16992.jpg)'
- en: Figure 2.3 – Nested ternary output using PHP 8
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 - 使用PHP 8进行嵌套三元输出
- en: Tip
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**: Use parentheses to avoid issues with nested ternary operations.
    For more information on the differences in ternary operator nesting, have a look
    at this article: [https://wiki.php.net/rfc/ternary_associativity](https://wiki.php.net/rfc/ternary_associativity).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：使用括号避免嵌套三元操作的问题。有关三元运算符嵌套差异的更多信息，请参阅此文章：[https://wiki.php.net/rfc/ternary_associativity](https://wiki.php.net/rfc/ternary_associativity)。'
- en: You now have an idea of the new nullsafe operator. You have also learned how
    three existing operators—the variadics, concatenation, and ternary operators—have
    had their functionality slightly modified. You are now in a good position to avoid
    potential hazards when upgrading to PHP 8\. Let's now have a look at another new
    feature, *arrow functions*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在对新的nullsafe运算符有了一个概念。您还学习了三个现有运算符——可变参数、连接和三元运算符——它们的功能略有修改。您现在可以避免升级到PHP
    8时可能出现的潜在危险。现在让我们来看看另一个新功能，*箭头函数*。
- en: Using arrow functions
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用箭头函数
- en: '**Arrow functions** were actually first introduced in PHP 7.4\. However, as
    many developers do not follow every single release update, it''s important to
    include coverage of this excellent new feature in this book.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**箭头函数**实际上是在PHP 7.4中首次引入的。然而，由于许多开发人员并不关注每个发布更新，因此在本书中包含这一出色的新功能是很重要的。'
- en: In this section, you will learn about arrow functions and their syntax, as well
    as advantages and disadvantages compared with anonymous functions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解箭头函数及其语法，以及与匿名函数相比的优缺点。
- en: Generic syntax
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用语法
- en: 'Simply put, an *arrow function* is a shorthand syntax for the traditional **anonymous
    function**, much like the ternary operator is a shorthand syntax for `if () {}
    else {}`. The generic syntax for an arrow function is shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数是传统匿名函数的简写语法，就像三元运算符是`if(){} else{}`的简写语法一样。箭头函数的通用语法如下：
- en: '`fn(<ARGS>) => <EXPRESSION>`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`fn(<ARGS>) => <EXPRESSION>`'
- en: '`<ARGS>` is optional and include anything seen in any other user-defined PHP
    function. `<EXPRESSION>` can include any standard PHP expression such as function
    calls, arithmetic operations, and so forth.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ARGS>`是可选的，包括任何其他用户定义的PHP函数中看到的内容。`<EXPRESSION>`可以包括任何标准的PHP表达式，如函数调用、算术运算等。'
- en: Let's now have a look at the differences between arrow functions and anonymous
    functions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看箭头函数和匿名函数之间的区别。
- en: Arrow functions versus anonymous functions
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头函数与匿名函数
- en: In this subsection, you will learn the differences between **arrow functions**
    and **anonymous functions**. In order to become an effective PHP 8 developer,
    it's important to gain an understanding of where and when arrow functions might
    replace anonymous functions and improve code performance.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，您将学习**箭头函数**和**匿名函数**之间的区别。为了成为一个有效的PHP 8开发人员，了解箭头函数何时何地可能取代匿名函数并提高代码性能是很重要的。
- en: 'Before getting into arrow functions, let''s look at a simple anonymous function.
    In the following example, the anonymous function assigned to `$addOld` produces
    the sum of the two arguments:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入箭头函数之前，让我们看一个简单的匿名函数。在下面的示例中，分配给`$addOld`的匿名函数产生了两个参数的和：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In PHP 8, you can produce exactly the same result, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，您可以产生完全相同的结果，如下所示：
- en: '`$addNew = fn($a, $b) => $a + $b;`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`$addNew = fn($a, $b) => $a + $b;`'
- en: 'Although the code is much more readable, there are advantages and disadvantages
    to this new feature, summarized in this table:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码更易读，但这一新功能有其优点和缺点，总结如下表所示：
- en: '![Table 2.1 – Anonymous functions versus arrow functions'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![表2.1 - 匿名函数与箭头函数'
- en: '](image/Table_2.1_B16992.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_2.1_B16992.jpg)'
- en: Table 2.1 – Anonymous functions versus arrow functions
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 - 匿名函数与箭头函数
- en: As you can see from the preceding table, arrow functions are more efficient
    than anonymous functions. However, the lack of indirection and lack of support
    for multiple lines means that you still need to use anonymous functions on occasion.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从上表中可以看出，箭头函数比匿名函数更高效。然而，缺乏间接性和不支持多行意味着您仍然需要偶尔使用匿名函数。
- en: Variable inheritance
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量继承
- en: Anonymous functions, much like any standard PHP function, only recognize variables
    outside their scope if you pass the value as a parameter, use a global keyword,
    or add a `use()` modifier.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数，就像任何标准的PHP函数一样，只有在将值作为参数传递、使用全局关键字或添加`use()`修饰符时，才能识别其范围外的变量。
- en: 'Here is an example of where a `DateTime` instance is inherited into an anonymous
    function by way of `use()`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`DateTime`实例通过`use()`方式继承到匿名函数中的示例：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is exactly the same thing using an arrow function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用箭头函数完全相同的东西：
- en: '`$new = fn($today) => $today->format($format);`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`$new = fn($today) => $today->format($format);`'
- en: As you can see, the syntax is extremely readable and concise. Let's now examine
    a practical example that incorporates arrow functions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，语法非常易读和简洁。现在让我们来看一个结合箭头函数的实际例子。
- en: 'Practical example: Using arrow functions'
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际例子：使用箭头函数
- en: 'Returning to the idea of producing a difficult-to-read CAPTCHA (first presented
    in [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013), *Introducing
    New PHP 8 OOP Features*), let''s have a look at how incorporating arrow functions
    might improve efficiency and reduce the amount of coding required. We now examine
    a script that produces a text-based CAPTCHA, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 回到生成难以阅读的CAPTCHA的想法（首次在[*第1章*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013)中介绍，*介绍新的PHP
    8 OOP功能*），让我们看看如何结合箭头函数可能提高效率并减少所需的编码量。现在我们来看一个生成基于文本的CAPTCHA的脚本，如下所示：
- en: 'First, we define a function that generates a string consisting of a random
    selection of letters, numbers, and special characters. Note in the following code
    snippet the use of the new PHP 8 `match` expression combined with arrow functions
    (highlighted):'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个生成由字母、数字和特殊字符随机选择组成的字符串的函数。请注意在以下代码片段中，使用了新的PHP 8 `match`表达式结合箭头函数（高亮显示）：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We then define a `textCaptcha()` function to produce the text CAPTCHA. We first
    define two arrays representing algorithms and colors. These are then *shuffled*
    to further the randomization. We also define **HyperText Markup Language** (**HTML**)
    `<span>` elements to produce large and small characters, as illustrated in the
    following code snippet:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个`textCaptcha()`函数来生成文本CAPTCHA。我们首先定义代表算法和颜色的两个数组。然后对它们进行*洗牌*以进一步随机化。我们还定义**超文本标记语言**（**HTML**）`<span>`元素来产生大写和小写字符，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we define a series of `InfiniteIterator` instances. This is a useful
    **Standard PHP Library** (**SPL**) class that allows you to continue to call `next()`
    without having to check to see if you''re at the end of the iteration. What this
    iterator class does is automatically move the pointer back to the top of the array,
    allowing you to iterate infinitely. The code can be seen in the following snippet:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一系列“InfiniteIterator”实例。这是一个有用的**标准PHP库**（**SPL**）类，允许您继续调用`next()`，而无需检查您是否已经到达迭代的末尾。这个迭代器类的作用是自动将指针移回数组的顶部，允许您无限迭代。代码可以在以下片段中看到：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then build the text CAPTCHA one character at a time, applying the appropriate
    algorithm and background color, as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们逐个字符构建文本CAPTCHA，应用适当的算法和背景颜色，如下所示：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Again, note the mix of `match` and `arrow` functions to achieve the desired
    result.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意混合使用`match`和`arrow`函数以实现期望的结果。
- en: 'The remainder of the script simply calls the two functions, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的其余部分只是调用这两个函数，如下所示：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is how the output from `/repo/ch02/php8_arrow_func_3.php` might look from
    a browser:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从浏览器中`/repo/ch02/php8_arrow_func_3.php`输出的样子：
- en: '![Figure 2.4 – Output from php8_arrow_func_3.php'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 - 来自php8_arrow_func_3.php的输出'
- en: '](image/Figure_2.4_B16992.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.4_B16992.jpg)'
- en: Figure 2.4 – Output from php8_arrow_func_3.php
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 - 来自php8_arrow_func_3.php的输出
- en: Tip
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more background information on arrow functions, have a look here: [https://wiki.php.net/rfc/arrow_functions_v2](https://wiki.php.net/rfc/arrow_functions_v2).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有关箭头函数的更多背景信息，请查看这里：[https://wiki.php.net/rfc/arrow_functions_v2](https://wiki.php.net/rfc/arrow_functions_v2)。
- en: 'For information on `InfiniteIterator`, have a look at the PHP documentation
    here: [https://www.php.net/InfiniteIterator](https://www.php.net/InfiniteIterator).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`InfiniteIterator`的信息，请查看PHP文档：[https://www.php.net/InfiniteIterator](https://www.php.net/InfiniteIterator)。
- en: Let's now have a look at *uniform variable syntax*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下*统一变量语法*。
- en: Understanding uniform variable syntax
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解统一变量语法
- en: One of the most radical initiatives introduced in PHP 7.0 was an effort at normalizing
    PHP syntax. The problem with earlier versions of PHP was that in some cases operations
    were parsed from left to right, whereas in other cases this was done from right
    to left. This inconsistency was the root cause of any of a number of programming
    vulnerabilities and difficulties. As a result, an initiative known as **uniform
    variable syntax** was launched by the PHP core development team. But first, let's
    define key points that form the uniform variable syntax initiative.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7.0中引入的最激进的举措之一是努力规范化PHP语法。早期版本的PHP存在的问题是，在某些情况下，操作是从左到右解析的，而在其他情况下是从右到左解析的。这种不一致性是许多编程漏洞和困难的根本原因。因此，PHP核心开发团队发起了一项名为**统一变量语法**的举措。但首先，让我们定义形成统一变量语法举措的关键要点。
- en: Defining uniform variable syntax
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义统一变量语法
- en: Uniform variable syntax is neither a protocol nor a formal language construct.
    Rather, it is a guiding principle that strives to ensure all operations are performed
    in a uniform and consistent manner.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 统一变量语法既不是协议也不是正式的语言构造。相反，它是一个指导原则，旨在确保所有操作以统一和一致的方式执行。
- en: 'Here are some key points from this initiative:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这项举措的一些关键要点：
- en: Uniformity in the order and referencing of variables
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的顺序和引用的统一性
- en: Uniformity in function calls
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用的统一性
- en: Straightening out problems with array de-referencing
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决数组解引用问题
- en: Providing the ability to mix function calls and array de-referencing in a single
    command
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供在单个命令中混合函数调用和数组解引用的能力
- en: Tip
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on the original proposal for PHP 7 uniform variable syntax,
    have a look here: [https://wiki.php.net/rfc/uniform_variable_syntax](https://wiki.php.net/rfc/uniform_variable_syntax).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PHP 7统一变量语法的原始提案的更多信息，请查看这里：[https://wiki.php.net/rfc/uniform_variable_syntax](https://wiki.php.net/rfc/uniform_variable_syntax)。
- en: Let's now examine how the uniform variable syntax initiative affects PHP 8.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下统一变量语法举措如何影响PHP 8。
- en: How does uniform variable syntax affect PHP 8?
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统一变量语法如何影响PHP 8？
- en: 'The uniform variable syntax initiative was extremely successful in all versions
    of PHP 7, and the transition was relatively smooth. There were a few areas not
    upgraded to this standard, however. Accordingly, a new proposal was introduced
    to address these holdouts. Uniformity has been introduced to the following in
    PHP 8:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 统一变量语法倡议在所有PHP 7的版本中都取得了极大的成功，过渡相对顺利。然而，有一些领域没有升级到这个标准。因此，提出了一个新的提案来解决这些问题。在PHP
    8中，以下内容已经实现了统一性：
- en: De-referencing interpolated strings
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解引用插入字符串
- en: Inconsistent de-referencing of magic constants
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 魔术常量的不一致解引用
- en: Consistency in class-constant dereferencing
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类常量解引用的一致性
- en: Enhanced expression support for `new` and `instanceof`
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强了`new`和`instanceof`的表达式支持
- en: Before getting into examples of each of these areas, we must first define what
    is meant by *de-referencing*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入每个这些领域的示例之前，我们必须首先定义*解引用*的含义。
- en: Defining de-referencing
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义解引用
- en: '**De-referencing** is the process of extracting the value of an array element
    or object property. It also refers to the process of obtaining the return value
    for an object method or function call. Here''s a simple example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**解引用**是提取数组元素或对象属性的值的过程。它还指获取对象方法或函数调用的返回值的过程。这里有一个简单的例子：'
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `$alpha` alpha contains 26 elements representing the letters `A` through
    `Z`. This example de-references the array, extracting the 7th and 15th elements,
    producing an output of `PHP`. De-referencing a function or method call simply
    means executing the function or method and accessing the results.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`$alpha`包含26个元素，代表字母`A`到`Z`。这个例子解引用了数组，提取了第7和第15个元素，产生了`PHP`的输出。解引用函数或方法调用简单地意味着执行函数或方法并访问结果。'
- en: De-referencing interpolated strings
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解引用插入字符串
- en: 'The next example is a bit crazy, so please follow closely. The following example
    works in PHP 8, but does not work in PHP 7 or earlier versions:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子有点疯狂，请仔细跟随。以下示例在PHP 8中有效，但在PHP 7或之前的版本中无效：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this example, two strings, `$alpha` and `$num`, are interpolated using double
    quotes inside a `foreach()` loop. Here is the output from PHP 7:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，两个字符串`$alpha`和`$num`在`foreach()`循环内使用双引号进行插值。以下是PHP 7的输出：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The same code in PHP 8 produces the following output:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中相同的代码产生以下输出：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The conclusion is that PHP 7 is not consistent in how it de-references interpolated
    strings, whereas PHP 8 demonstrates improved consistency.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，PHP 7在解引用插入字符串方面不一致，而PHP 8展现了改进的一致性。
- en: Inconsistent de-referencing of magic constants
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 魔术常量的不一致解引用
- en: 'In PHP 7 and earlier versions, constants can be de-referenced whereas magic
    constants cannot. Here is a simple example that produces the last three letters
    of the current file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7和之前的版本中，常量可以被解引用，而魔术常量则不行。下面是一个简单的例子，它产生了当前文件的最后三个字母：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here is the result in PHP 7:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是PHP 7的结果：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And here is the result in PHP 8:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是PHP 8的结果：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Again, the point here is that de-referencing operations in PHP 8 are applied
    consistently (which is a good thing!).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调的是，PHP 8中的解引用操作是一致的（这是一件好事！）。
- en: Consistency in class-constant de-referencing
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类常量解引用的一致性
- en: 'A related issue arises when attempting to de-reference class constants. To
    best illustrate the problem, imagine that we have three classes. The first class,
    `JsonResponse`, produces the data in **JavaScript Object Notation** (**JSON**)
    format, as illustrated in the following code snippet:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试解引用类常量时会出现相关问题。为了最好地说明问题，想象一下我们有三个类。第一个类`JsonResponse`以**JavaScript对象表示法**（**JSON**）格式产生数据，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The second class, `SerialResponse`, produces a response using the built-in
    PHP `serialize()` function, as illustrated in the following code snippet:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个类`SerialResponse`使用内置的PHP `serialize()`函数产生响应，如下面的代码片段所示：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, a `Test` class is able to produce either response, as illustrated
    in the following code snippet:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个`Test`类能够产生任何一个响应，如下面的代码片段所示：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As you''ve seen in earlier examples in this section, results in earlier versions
    of PHP are inconsistent. A call to `Test::getJson($data)` works fine. However,
    a call to `Test::getText($data)` produces this error:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本节的早期示例中所看到的，PHP早期版本的结果是不一致的。调用`Test::getJson($data)`可以正常工作。然而，调用`Test::getText($data)`会产生错误：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Exactly the same code under PHP 8 produces consistent results for both method
    calls defined in the class shown previously, as illustrated here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8下，与之前显示的类中定义的方法调用产生了一致的结果，如下所示：
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To summarize, in PHP 8, class constants are now de-referenced in a uniform manner,
    allowing you to produce cleaner code. Now, let's have a look at how PHP 8 allows
    you to use expressions in more places than before.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在PHP 8中，类常量现在以统一的方式进行解引用，使您能够产生更清晰的代码。现在，让我们看看PHP 8如何允许您在更多地方使用表达式。
- en: Enhanced expression support for new and instanceof
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强了`new`和`instanceof`的表达式支持
- en: 'One of the joys associated with PHP 7 programming is the ability to use arbitrary
    PHP expressions just about anywhere. In this simple example, note the use of a
    `$_GET[''page''] ?? ''home''` arbitrary expression inside the square brackets
    referencing the `$nav` array:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 与PHP 7编程相关的乐趣之一是能够在几乎任何地方使用任意PHP表达式。在这个简单的例子中，注意在引用`$nav`数组的方括号内使用了一个`$_GET['page']
    ?? 'home'`任意表达式：
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In PHP 7 and earlier versions, however, the same thing is not possible if the
    expression involves the `new` or `instanceof` keyword. As you may have guessed,
    this inconsistency has been addressed in PHP 8\. The following is now possible:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7和之前的版本中，如果表达式涉及`new`或`instanceof`关键字，则不可能做到这一点。正如你可能已经猜到的那样，这种不一致性已经在PHP
    8中得到解决。现在可以实现以下操作：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This code example shows the use of an arbitrary expression inside the array
    reference, used in conjunction with the `new` keyword.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例展示了在数组引用内使用任意表达式，与`new`关键字一起使用。
- en: Tip
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information on uniform variable syntax updates in PHP 8, see this
    article: [https://wiki.php.net/rfc/variable_syntax_tweaks](https://wiki.php.net/rfc/variable_syntax_tweaks).'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 PHP 8 中统一变量语法更新的更多信息，请参阅此文章：[https://wiki.php.net/rfc/variable_syntax_tweaks](https://wiki.php.net/rfc/variable_syntax_tweaks)。
- en: Let's now have a look at new techniques available for string and array handling
    in PHP 8.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看 PHP 8 中可用的新的字符串和数组处理技术。
- en: Learning new array- and string-handling techniques
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习新的数组和字符串处理技术
- en: There have been a number of improvements in PHP 8 array- and string-handling
    techniques. Although there is insufficient space in this book to cover every single
    enhancement, we will examine the more significant improvements in this section.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8 中的数组和字符串处理技术有许多改进。虽然本书中没有足够的空间来涵盖每一个增强功能，但我们将在本节中检查更重要的改进。
- en: Working with array_splice()
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `array_splice()`
- en: 'The `array_splice()` function is a cross between `substr()` and `str_replace()`:
    it lets you replace a subset of one array with another. Its use gets awkward,
    however, when all you need to do is replace the last part of the array with something
    different. A quick look at the syntax reveals where it starts to get inconvenient—the
    `replacement` parameter is preceded by the `length` parameter, as illustrated
    here:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_splice()` 函数是 `substr()` 和 `str_replace()` 的混合体：它允许您用另一个数组替换一个数组的子集。然而，当您只需要用不同的内容替换数组的最后部分时，它的使用会变得麻烦。快速查看语法会让人觉得开始变得不方便——`replacement`
    参数在 `length` 参数之前，如下所示：'
- en: '`array_splice(&$input,$offset[,$length[,$replacement]]):array`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_splice(&$input,$offset[,$length[,$replacement]]):array`'
- en: 'Traditionally, developers first run `count()` on the original array and use
    that for the `length` argument, as shown here:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，开发人员首先在原始数组上运行 `count()`，然后将其用作 `length` 参数，如下所示：
- en: '`array_splice($arr, 3, count($arr), $repl);`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_splice($arr, 3, count($arr), $repl);`'
- en: 'In PHP 8, the third argument can be `NULL`, saving an extra call to `count()`.
    If you take advantage of the **named arguments** feature of PHP 8, the code becomes
    even more concise. Here''s the same code snippet written for PHP 8:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 8 中，第三个参数可以是 `NULL`，省去了对 `count()` 的额外调用。如果您利用 PHP 8 的**命名参数**特性，代码会变得更加简洁。下面是为
    PHP 8 编写的相同代码片段：
- en: '`array_splice($arr, 3, replacement: $repl);`'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_splice($arr, 3, replacement: $repl);`'
- en: 'Here''s another example that clearly demonstrates the difference between PHP
    7 and PHP 8:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一个例子清楚地展示了 PHP 7 和 PHP 8 之间的差异：
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you run the code in PHP 7, note the result of the last `var_dump()` instance,
    as illustrated here:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 PHP 7 中运行代码，请注意最后一个 `var_dump()` 实例的结果，如下所示：
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In PHP 7, providing a `NULL` value to the third argument of `array_splice()`
    causes the two arrays to be simply merged, which is not the desired result!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 7 中，将 `NULL` 值提供给 `array_splice()` 的第三个参数会导致两个数组简单合并，这不是期望的结果！
- en: 'Now, have a look here at the output from the last `var_dump()`, but this time
    running under PHP 8:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下最后一个 `var_dump()` 的输出，但这次是在 PHP 8 下运行的：
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, having the third parameter as `NULL` has the same functionality
    as providing an array `count()` for the third argument to `array_splice()` when
    running under PHP 8\. You will also note that the total number of array elements
    is `5` in PHP 8, whereas the total was `7` from the same code running in PHP 7.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在 PHP 8 下，将第三个参数设为 `NULL` 与在运行时将数组 `count()` 作为第三个参数提供给 `array_splice()`
    具有相同的功能。您还会注意到在 PHP 8 中，数组元素的总数为 `5`，而在 PHP 7 中，相同代码的运行结果为 `7`。
- en: Using array_slice()
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `array_slice()`
- en: The `array_slice()` function operates on arrays as much as `substr()` does on
    strings. The big problem with earlier versions of PHP is that internally, the
    PHP engine iterated through the *entire array sequentially* until the desired
    offset was reached. If the offset is large, performance suffers in direct correlation
    to the size of the array.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_slice()` 函数在数组上的操作与 `substr()` 在字符串上的操作一样。PHP 早期版本的一个大问题是，在内部，PHP 引擎会顺序地遍历整个数组，直到达到所需的偏移量。如果偏移量很大，性能会直接与数组大小成正比地受到影响。'
- en: In PHP 8, a different algorithm is used that does not require sequential array
    iteration. As the size of the array increases, performance improvement becomes
    increasingly evident.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 8 中，使用了一种不需要顺序数组迭代的不同算法。随着数组大小的增加，性能改进变得越来越明显。
- en: 'In the example shown here, we first build a massive array of approximately
    6 million entries:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先构建了一个大约有 600 万条目的大数组：
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we iterate through the array, taking random offsets all greater than
    `999,999`. This forces `array_slice()` to work hard, and shows a significant performance
    difference between PHP 7 and 8, as illustrated in the following code snippet:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们遍历数组，取大于 `999,999` 的随机偏移量。这会迫使 `array_slice()` 艰苦工作，并显示出 PHP 7 和 8 之间的显著性能差异，如下面的代码片段所示：
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here is the output when running the code under PHP 7:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 7 下运行代码时的输出如下：
- en: '![Figure 2.5 – array_slice() example using PHP 7'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.5 – 使用 PHP 7 的 array_slice() 示例'
- en: '](image/Figure_2.5_B16992.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.5_B16992.jpg)'
- en: Figure 2.5 – array_slice() example using PHP 7
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 使用 PHP 7 的 array_slice() 示例
- en: 'Notice here the massive performance difference when running the same code under
    PHP 8:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 PHP 8 下运行相同代码时的显著性能差异：
- en: '![Figure 2.6 – array_slice() example using PHP 8'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.6 – 使用 PHP 8 的 array_slice() 示例'
- en: '](image/Figure_2.6_B16992.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.6_B16992.jpg)'
- en: Figure 2.6 – array_slice() example using PHP 8
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 使用 PHP 8 的 array_slice() 示例
- en: Important note
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The new algorithm is only effective if the array does not contain elements with
    a `NULL` value. If the array contains `NULL` elements, the old algorithm is triggered,
    and a sequential iteration occurs.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 新算法只在数组不包含 `NULL` 值的情况下有效。如果数组包含 `NULL` 元素，则会触发旧算法，并进行顺序迭代。
- en: Let's now turn our attention to some excellent new string functions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '现在让我们转向一些出色的新字符串函数。 '
- en: Detecting string beginning, middle, and end
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测字符串的开头、中间和结尾
- en: Something PHP developers deal with on a constant basis is having to check for
    sets of characters that appear at the beginning, middle, or end of a string. The
    problem with the current set of string functions is that they are *not designed*
    to deal with the presence or absence of a substring. Rather, the current set of
    functions is designed to determine the *position* of a substring. This, in turn,
    can then be interpolated in a Boolean manner to determine the presence or absence
    of a substring.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: PHP开发人员经常需要处理的一个问题是检查字符串的开头、中间或结尾是否出现一组字符。当前一组字符串函数的问题在于它们*不是设计*来处理子字符串的存在或不存在。相反，当前一组函数是设计来确定子字符串的*位置*。然后，可以以布尔方式插值来确定子字符串的存在或不存在。
- en: 'The problem with this approach is summarized in a famous quote attributed to
    Sir Winston Churchill:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '这种方法的问题可以用温斯顿·丘吉尔爵士的一句著名的引语来概括： '
- en: '"Golf is a game whose aim is to hit a very small ball into an ever smaller
    hole, with weapons singularly ill-designed for the purpose."'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: “高尔夫是一个旨在用极不适合这一目的的武器将一个非常小的球打入一个更小的洞的游戏。”
- en: – *Winston S. Churchill*
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: – *温斯顿·丘吉尔*
- en: Let's now have a look at three incredibly useful new string functions that address
    this issue.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看三个非常有用的新字符串函数，它们解决了这个问题。
- en: str_starts_with()
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: str_starts_with()
- en: 'The first function we examine is `str_starts_with()`. To illustrate its use,
    consider a code example where we''re looking for `https` at the beginning and
    `login` at the end, as illustrated in the following code snippet:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要检查的第一个函数是`str_starts_with()`。为了说明它的用法，考虑一个代码示例，我们要在开头找到`https`，在结尾找到`login`，如下面的代码片段所示：
- en: '[PRE50]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As we mentioned in the introduction to this section, in order to determine if
    a string starts with `https`, we need to invoke both `substr()` and `strlen()`.
    Neither function is designed to give us the desired answer. Further, having to
    use both functions introduces inefficiency in our code and results in a needless
    resource utilization increase.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节的介绍中提到的，为了确定一个字符串是否以`https`开头，我们需要调用`substr()`和`strlen()`。这两个函数都不是设计来给我们想要的答案的。而且，使用这两个函数会在我们的代码中引入低效，并导致不必要的资源利用增加。
- en: 'The same code can be written in PHP 8, as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的代码可以在PHP 8中编写如下：
- en: '[PRE51]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: str_ends_with()
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: str_ends_with()
- en: 'In a similar vein to `str_starts_with()`, PHP 8 has introduced a new function,
    `str_ends_with()`, that can be used to determine if the end of a string matches
    some value. To illustrate the usefulness of this new function, consider old PHP
    code using `strrev()` and `strpos()`, which might appear as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 与`str_starts_with()`类似，PHP 8引入了一个新函数`str_ends_with()`，用于确定字符串的结尾是否与某个值匹配。为了说明这个新函数的用处，考虑使用`strrev()`和`strpos()`的旧PHP代码，可能如下所示：
- en: '[PRE52]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In an operation, both `$url` and `$end` need to be reversed, a process that
    can gets progressively more expensive in direct proportion to the length of the
    string. Also, as mentioned earlier, the purpose of `strpos()` is to return the
    *position* of a substring, not to determine its presence or absence.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个操作中，`$url`和`$end`都需要被反转，这个过程会随着字符串长度的增加而变得越来越昂贵。而且，正如前面提到的，`strpos()`的目的是返回子字符串的*位置*，而不是确定其存在与否。
- en: 'The same functionality is achieved as follows in PHP 8:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，可以通过以下方式实现相同的功能：
- en: '[PRE53]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: str_contains()
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: str_contains()
- en: The last function in this context is `str_contains()`. As we've discussed, in
    PHP 7 and earlier there was no specific PHP function that tells you whether or
    not a substring exists within a string, aside from `preg_match()`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中的最后一个函数是`str_contains()`。正如我们讨论过的，在PHP 7及更早版本中，除了`preg_match()`之外，没有特定的PHP函数告诉你一个子字符串是否存在于一个字符串中。
- en: The problem with using `preg_match()`, as we've all been warned time and again,
    is performance degradation. In order to process a *regular expression*, `preg_match()`
    needs to first analyze the pattern. It then has to perform a second pass in order
    to determine which part of the string matches the pattern. This is an enormously
    expensive operation in terms of time and resource utilization.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`preg_match()`的问题，正如我们一再被警告的那样，是性能下降。为了处理*正则表达式*，`preg_match()`首先需要分析模式。然后，它必须执行第二次扫描，以确定字符串的哪个部分与模式匹配。这在时间和资源利用方面是一个极其昂贵的操作。
- en: Important note
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When we mention that an operation is *expensive* in terms of time and resources,
    please bear in mind that if your script only consists of a few dozen lines of
    code and/or you are not repeating the operation thousands of times in a loop,
    chances are that you will not see any significant performance gains using the
    new functions and techniques described in this section.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到一个操作在时间和资源方面是*昂贵*时，请记住，如果您的脚本只包含几十行代码和/或您在循环中没有重复操作数千次，那么使用本节中描述的新函数和技术可能不会带来显著的性能提升。
- en: 'In the following example, a PHP script uses `preg_match()` to search the *GeoNames*
    project database of cities greater than `15,000` in population for any listing
    containing a reference to `London`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，一个PHP脚本使用`preg_match()`来搜索*GeoNames*项目数据库中人口超过`15,000`的城市，以查找包含对`London`的引用的任何列表：
- en: '[PRE54]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here is the output when running in PHP 7:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7中运行时的输出如下：
- en: '![Figure 2.7 – Scanning GeoNames file using preg_match()'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7 - 使用preg_match()扫描GeoNames文件'
- en: '](image/Figure_2.7_B16992.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.7_B16992.jpg)'
- en: Figure 2.7 – Scanning GeoNames file using preg_match()
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 - 使用preg_match()扫描GeoNames文件
- en: 'The same output can be achieved in PHP 8 by replacing the `if` statement with
    the following code:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 8中，可以通过用以下代码替换`if`语句来实现相同的输出：
- en: '[PRE55]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here is the output from PHP 8:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自PHP 8的输出：
- en: '![Figure 2.8 – Scanning GeoNames file using str_contains()'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8 - 使用str_contains()扫描GeoNames文件'
- en: '](image/Figure_2.8_B16992.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.8_B16992.jpg)'
- en: Figure 2.8 – Scanning GeoNames file using str_contains()
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 - 使用str_contains()扫描GeoNames文件
- en: As you can see from the two different output screens, the PHP 8 code runs for
    approximately `0.14` microseconds compared with `0.19` microseconds in PHP 7\.
    This by itself is not a massive performance gain but, as was mentioned earlier
    in this section, more data, longer strings, and more iterations magnify any small
    performance gain you achieve.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 从两个不同的输出屏幕可以看出，PHP 8代码运行大约需要`0.14`微秒，而PHP 7需要`0.19`微秒。这本身并不是一个巨大的性能提升，但正如本节前面提到的，更多的数据、更长的字符串和更多的迭代会放大你所获得的任何小的性能提升。
- en: Tip
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**: Small code modifications that achieve small performance
    gains eventually add up to a large overall performance gain!'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：实现小的代码修改可以带来小的性能提升，最终积少成多，带来整体性能的大幅提升！'
- en: 'For more information on the *GeoNames* open source project, go to their website
    here: [https://www.geonames.org/](https://www.geonames.org/).'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 有关*GeoNames*开源项目的更多信息，请访问他们的网站：[https://www.geonames.org/](https://www.geonames.org/)。
- en: You now have an idea how and where to use three new string functions. You are
    also able to write more efficient code, using functions specifically designed
    to detect the presence or absence of substrings at the beginning, middle, or end
    of target strings.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了如何以及在哪里使用三个新的字符串函数。你还可以编写更高效的代码，使用专门设计用于检测目标字符串开头、中间或结尾的子字符串存在与否的函数。
- en: Finally, we end this chapter with a little bit of fun by having a look at the
    new SQLite3 authorizer.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们以查看新的SQLite3授权回调结束本章。
- en: Securing SQLite databases with the authorizer
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用授权回调保护SQLite数据库
- en: 'Many PHP developers prefer to use **SQLite** as their database engine rather
    than a separate database server such as PostgreSQL, MySQL, Oracle, or MongoDB.
    The reasons for using SQLite are many, but often come down to the following:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 许多PHP开发人员更喜欢使用**SQLite**作为他们的数据库引擎，而不是像PostgreSQL、MySQL、Oracle或MongoDB这样的独立数据库服务器。使用SQLite的原因有很多，但通常归结为以下几点：
- en: '**SQLite is a file-based database**: You don''t have to install a separate
    database server.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLite是基于文件的数据库**：你不需要安装单独的数据库服务器。'
- en: '**It''s easy to distribute**: The only requirement is that the target server
    needs to have the `SQLite` executable installed.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于分发**：唯一的要求是目标服务器需要安装`SQLite`可执行文件。'
- en: '**SQLite is lightweight**: Since there''s no constantly running server, it
    takes fewer resources.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLite轻量级**：由于没有不断运行的服务器，所需资源更少。'
- en: That said, the downside is that it's not very scalable. If you have a fairly
    substantial amount of data to deal with, it's probably better to install a more
    powerful database server. The other potentially major drawback is that SQLite
    has no security, covered in the next subsection.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，缺点是它的可扩展性不是很好。如果你有相当大量的数据要处理，最好安装一个更强大的数据库服务器。另一个潜在的主要缺点是SQLite没有安全性，下一小节将介绍。
- en: Tip
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For more information about SQLite, please have a look at their main web page:
    [https://sqlite.org/index.html](https://sqlite.org/index.html).'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 有关SQLite的更多信息，请访问他们的主要网页：[https://sqlite.org/index.html](https://sqlite.org/index.html)。
- en: Wait a minute... no security?
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等等...没有安全性？
- en: '*Yes, you heard correctly*: by default, by its very design, SQLite has no security.
    That, of course, is the reason many developers like to use it: having no security
    makes it super-easy to work with!'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你听对了：默认情况下，按照其设计，SQLite没有安全性。当然，这就是许多开发人员喜欢使用它的原因：没有安全性使得它非常容易使用！
- en: 'Here''s a sample block of code that connects to a SQLite database and conducts
    a simple query of the `geonames` table. It returns a list of cities in India where
    the population is greater than 2 million:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个连接到SQLite数据库并对`geonames`表进行简单查询的示例代码块。它返回了印度人口超过200万的城市列表：
- en: '[PRE56]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Most other database extensions require at least a username and password when
    establishing a connection. As you can see in the preceding code snippet, the `$sqlite`
    instance is created with absolutely no security involved: no username or password.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数其他数据库扩展在建立连接时至少需要用户名和密码。如前面的代码片段所示，`$sqlite`实例是完全没有安全性的：没有用户名或密码。
- en: What's a SQLite authorization callback?
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是SQLite授权回调？
- en: 'The SQLite3 engine now allows you to register an **authorization callback**
    to your SQLite database connection. The callback routine is invoked when sending
    a **prepared statement** to the database for compilation. Here is the generic
    syntax to set an authorization callback on a `SQLite3` instance:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite3引擎现在允许你向SQLite数据库连接注册一个**授权回调**。当向数据库发送**预编译语句**进行编译时，将调用回调例程。以下是在`SQLite3`实例上设置授权回调的通用语法：
- en: '`$sqlite3->setAuthorizer(callable $callback);`'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`$sqlite3->setAuthorizer(callable $callback);`'
- en: 'The callback is expected to return one of three `SQLite3` class constants,
    each of which represents an integer value. If the callback returns anything other
    than one of these three values, `SQLite3::DENY` is assumed and the operation does
    not proceed. The table shown next lists the three expected return values:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数应该返回三个`SQLite3`类常量中的一个，每个代表一个整数值。如果回调函数返回除这三个值之外的任何值，就假定为`SQLite3::DENY`，操作将不会继续进行。下表列出了三个期望的返回值：
- en: '![Table 2.2 – Valid SQLite authorization callback return values'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '![表2.2 - 有效的SQLite授权回调返回值'
- en: '](image/Table_2.2_B16992.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_2.2_B16992.jpg)'
- en: Table 2.2 – Valid SQLite authorization callback return values
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2 - 有效的SQLite授权回调返回值
- en: Now that you've got an idea about the callback, let's have a look at how it
    gets invoked.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对回调有了一些了解，让我们看看它是如何被调用的。
- en: What gets sent to the callback?
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调函数会接收到什么？
- en: 'The callback is invoked when you execute `$sqlite->prepare($sql)`. At that
    time, the SQLite3 engine passes between one to five parameters to the callback.
    The first argument is an **action code** that determines the nature of the remaining
    arguments. Accordingly, the following might be an appropriate generic function
    signature for the callback that you ultimately define:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行`$sqlite->prepare($sql)`时，回调被调用。在那时，SQLite3引擎将在回调中传递一个到五个参数。第一个参数是一个**操作代码**，确定剩余参数的性质。因此，以下可能是您最终定义的回调的适当通用函数签名：
- en: '[PRE57]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The action codes for the most part mirror the SQL statement to be prepared.
    The following table summarizes a number of more common action codes:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分情况下，操作代码与要准备的SQL语句相对应。以下表总结了一些更常见的操作代码：
- en: '![Table 2.3 – Common action codes sent to callback'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '![表2.3 – 发送到回调的常见操作代码'
- en: '](image/Table_2.3_B16992.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_2.3_B16992.jpg)'
- en: Table 2.3 – Common action codes sent to callback
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.3 – 发送到回调的常见操作代码
- en: It's now time to have a look at a usage example.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看一个使用示例了。
- en: Authorizer usage example
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权使用示例
- en: 'In the following example, we''re allowed to read from the SQLite `geonames`
    table, but not to insert, delete, or update:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们被允许从SQLite `geonames`表中读取，但不能插入、删除或更新：
- en: 'We start by defining an `auth_callback.php` include file in the `/repo/ch02/includes/`
    directory. In the `include` file, we first define constants that are used in the
    callback, as illustrated in the following code snippet:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先在`/repo/ch02/includes/`目录中定义一个`auth_callback.php`包含文件。在`include`文件中，我们首先定义在回调中使用的常量，如下面的代码片段所示：
- en: '[PRE58]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The way the **access control list** (**ACL**) works is that the primary outer
    key is the user (for example, `admin` or `guest`); the secondary key is the table
    (for example, `users` or `geonames`); and the value is an array of `SQLite3` action
    codes allowed for this user and table.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问控制列表**（**ACL**）的工作方式是，主要外键是用户（例如`admin`或`guest`）；次要键是表（例如`users`或`geonames`）；值是允许该用户和表的`SQLite3`操作代码的数组。'
- en: In the example shown previously, the `admin` user has all rights to both tables,
    whereas the `guest` user can only read from the `geonames` table.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前显示的示例中，`admin`用户对两个表都有所有权限，而`guest`用户只能从`geonames`表中读取。
- en: 'Next, we define the actual authorization callback function. The first thing
    in the function we need to do is set the default return value to `SQLite3::DENY`.
    We also check to see if the action code is `SQLite3::SELECT`, in which case we
    simply return `OK`. This action code is issued when a `SELECT` statement is first
    processed and does not provide any information on tables or columns. The code
    can be seen in the following snippet:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义实际的授权回调函数。函数中我们需要做的第一件事是将默认返回值设置为`SQLite3::DENY`。我们还检查操作代码是否为`SQLite3::SELECT`，如果是，则简单地返回`OK`。当首次处理`SELECT`语句并且不提供有关表或列的任何信息时，将发出此操作代码。代码可以在以下片段中看到：
- en: '[PRE59]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If the action code is anything other than `SQLite3::SELECT`, we need to first
    determine which table is involved before we can make a decision to allow or deny
    the action. The table name is reported as the second argument provided to our
    callback.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果操作代码不是`SQLite3::SELECT`，我们需要首先确定涉及哪个表，然后才能决定允许还是拒绝该操作。表名作为提供给我们回调的第二个参数报告。
- en: Here is the perfect time to use a *variadics operator* as we are unsure exactly
    how many parameters might be passed. However, for the major operations of concern
    (for example, `INSERT`, `UPDATE`, or `DELETE`), what is placed into the first
    position in `$args` is the table name. Otherwise, we get the table name from the
    session.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是使用*variadics operator*的绝佳时机，因为我们不确定可能传递多少参数。但是，对于关注的主要操作（例如`INSERT`、`UPDATE`或`DELETE`），放入`$args`的第一个位置的是表名。否则，我们从会话中获取表名。
- en: 'The code is illustrated in the following snippet:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 代码显示在以下片段中：
- en: '[PRE60]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In a like manner, we retrieve the username from the session, as follows:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，我们从会话中检索用户名，如下所示：
- en: '[PRE61]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Next, we check to see if the user is defined in the ACL, and after that, if
    the table is assigned rights for this user. If the action code given is in the
    array associated with the user and table combination, `SQLite3::OK` is returned.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查用户是否在ACL中定义，然后检查表是否为该用户分配了权限。如果给定的操作代码在与用户和表组合关联的数组中，返回`SQLite3::OK`。
- en: 'The code is shown in the following snippet:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 代码显示在以下片段中：
- en: '[PRE62]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We then store the table name in the session and return the status code, as
    illustrated in the following code snippet:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将表名存储在会话中并返回状态代码，如下面的代码片段所示：
- en: '[PRE63]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We now turn our attention to the calling program.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向调用程序。
- en: 'After including the PHP file defining the authorization callback, we simulate
    acquiring the username by accepting a command-line parameter, a **Uniform Resource
    Locator** (**URL**) parameter, or simply assigning `admin`, as illustrated in
    the following code snippet:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含定义授权回调的PHP文件之后，我们通过接受命令行参数、**统一资源定位符**（**URL**）参数或简单地分配`admin`来模拟获取用户名，如下面的代码片段所示：
- en: '[PRE64]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we create two arrays and use `shuffle()` to make their order random.
    We build the username, email, and ID values from the randomized arrays, as illustrated
    in the following code snippet:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建两个数组并使用`shuffle()`使它们的顺序随机。我们从随机数组中构建用户名、电子邮件和ID值，如下面的代码片段所示：
- en: '[PRE65]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We then create the `SQLite3` instance and assign the authorization callback,
    as follows:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建`SQLite3`实例并分配授权回调，如下所示：
- en: '[PRE66]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The SQL `INSERT` statement is now defined and sent to SQLite to be prepared.
    Note that this is when the authorization callback is invoked.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在SQL `INSERT`语句已经定义并发送到SQLite进行准备。请注意，这是调用授权回调的时候。
- en: 'The code is shown in the following snippet:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 代码显示在以下片段中：
- en: '[PRE67]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If the authorization callback denies the action, the statement object is `NULL`,
    so it''s best to use an `if()` statement to test its presence. If so, we then
    proceed to bind the value and execute the statement, as illustrated in the following
    code snippet:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果授权回调拒绝操作，则语句对象为`NULL`，因此最好使用`if()`语句来测试其存在。如果是这样，我们然后继续绑定值并执行语句，如下面的代码片段所示：
- en: '[PRE68]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To confirm the results, we define a SQL `SELECT` statement to display the contents
    of the `users` table, as follows:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确认结果，我们定义了一个SQL `SELECT`语句，以显示`users`表的内容，如下所示：
- en: '[PRE69]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Important note
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Not all code is shown here. For complete code, please refer to `/repo/ch02/php8_sqlite_auth_admin.php`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有显示所有代码。有关完整代码，请参考`/repo/ch02/php8_sqlite_auth_admin.php`。
- en: 'Here is the result if we run the calling program, setting the user to `admin`:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行调用程序，并将用户设置为`admin`，则结果如下：
- en: '![Figure 2.9 – SQLite3 authorization callback: admin user'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9 – SQLite3授权回调：admin用户'
- en: '](image/Figure_2.9_B16992.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.9_B16992.jpg)'
- en: 'Figure 2.9 – SQLite3 authorization callback: admin user'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – SQLite3授权回调：admin用户
- en: 'The output from the preceding screenshot shows us that the operation is successful
    as we are running as the `admin` user, with sufficient authorization privileges.
    Here is the output when the user is set to `guest`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 前面截图的输出显示，由于我们以`admin`用户身份运行，并具有足够的授权权限，操作成功。当用户设置为`guest`时，输出如下：
- en: '![Figure 2.10 – SQLite3 authorization callback: guest user'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.10 – SQLite3授权回调：guest用户'
- en: '](image/Figure_2.10_B16992.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.10_B16992.jpg)'
- en: 'Figure 2.10 – SQLite3 authorization callback: guest user'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – SQLite3授权回调：guest用户
- en: The output shows us that the attempt to run `prepare()` is unsuccessful as we
    are running as a user who lacks sufficient authorization.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，由于我们以权限不足的用户身份运行，尝试运行`prepare()`是不成功的。
- en: This concludes our discussion of this long-awaited feature. You now know how
    to add authorization to an otherwise insecure database technology.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对这一期待已久的功能的讨论。您现在知道如何向一个否则不安全的数据库技术添加授权。
- en: Tip
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Original pull request describing the addition of the SQLite authorizer: [https://github.com/php/php-src/pull/4797](https://github.com/php/php-src/pull/4797)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 描述添加SQLite授权回调的原始拉取请求：[https://github.com/php/php-src/pull/4797](https://github.com/php/php-src/pull/4797)
- en: 'Official SQLite documentation on the authorizer callback: [https://www.sqlite.org/c3ref/set_authorizer.html](https://www.sqlite.org/c3ref/set_authorizer.html)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 有关官方SQLite文档的授权回调：[https://www.sqlite.org/c3ref/set_authorizer.html](https://www.sqlite.org/c3ref/set_authorizer.html)
- en: 'Action codes passed to the callback: [https://www.sqlite.org/c3ref/c_alter_table.html](https://www.sqlite.org/c3ref/c_alter_table.html)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给回调函数的操作代码：[https://www.sqlite.org/c3ref/c_alter_table.html](https://www.sqlite.org/c3ref/c_alter_table.html)
- en: 'Full list of result codes: [https://www.sqlite.org/rescode.html](https://www.sqlite.org/rescode.html)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 结果代码的完整列表：[https://www.sqlite.org/rescode.html](https://www.sqlite.org/rescode.html)
- en: 'Documentation on the `SQLite3` class: [https://www.php.net/sqlite3](https://www.php.net/sqlite3)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`SQLite3`类的文档：[https://www.php.net/sqlite3](https://www.php.net/sqlite3)'
- en: Summary
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about a number of changes introduced by PHP 8 at
    the procedural level. You first learned about the new nullsafe operator, which
    allows you to considerably shorten any code in which a chain of object references
    might fail. You also learned how usage of the ternary operator and the variadics
    operator has been tightened and improved, and that the concatenate operator has
    been demoted in the order of precedence. This chapter also covered advantages
    and disadvantages of arrow functions, as well as how they can be used as a clean
    and concise alternative to anonymous functions.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了PHP 8在过程级别引入的一些更改。您首先了解了新的nullsafe运算符，它允许您大大缩短可能失败的对象引用链的任何代码。您还了解了三元运算符和可变参数运算符的使用已经得到了加强和改进，以及连接运算符在优先级顺序中已经降级。本章还涵盖了箭头函数的优缺点，以及它们如何作为匿名函数的清晰简洁的替代方案。
- en: Later sections in this chapter showed you how PHP 8 continues the trend toward
    uniform variable syntax first introduced in PHP 7\. You learned how remaining
    inconsistencies have been addressed in PHP 8, including interpolated string and
    magic constant de-referencing, as well as improvements in array and string handling
    that promise to make your PHP 8 cleaner, more concise, and more highly performant.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的后续部分向您展示了PHP 8如何继续沿着在PHP 7中首次引入的统一变量语法的趋势发展。您了解了PHP 8中如何解决剩余的不一致之处，包括插值字符串和魔术常量的解引用，以及在数组和字符串处理方面的改进，这些改进承诺使您的PHP
    8更清洁、更简洁和更高性能。
- en: Finally, in the last section, you learned about a new feature that provides
    support for a SQLite authorization callback, allowing you to finally provide a
    degree of security when using SQLite as your database.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在最后一节中，您了解了一个新功能，它提供了对SQLite授权回调的支持，允许您在使用SQLite作为数据库时最终提供一定程度的安全性。
- en: In the next chapter, you will learn about PHP 8 error-handling enhancements.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解PHP 8的错误处理增强功能。
