- en: Chapter 11. Implementing Software Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。实施软件设计模式
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating an array to object hydrator
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数组到对象的水合物
- en: Building an object to array hydrator
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建对象到数组的水合物
- en: Implementing a strategy pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施策略模式
- en: Defining a mapper
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义映射器
- en: Implementing object-relational mapping
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施对象关系映射
- en: Implementing the Pub/Sub design pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施发布/订阅设计模式
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'The idea of incorporating **software design patterns** into **object-oriented
    programming** (**OOP**) code was first discussed in a seminal work entitled *Design
    Patterns: Elements of Reusable Object-Oriented Software*, authored by the famous
    Gang of Four (E. Gamma, R. Helm, R. Johnson, and J. Vlissides) in 1994\. Defining
    neither standards nor protocols, this work identified common generic software
    designs that have proven useful over the years. The patterns discussed in this
    book are generally thought to fall into three categories: creational, structural,
    and behavioral.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将**软件设计模式**融入**面向对象编程**（**OOP**）代码的想法首次在一部名为《设计模式：可复用面向对象软件的基本元素》的重要著作中讨论，该著作由著名的四人组（E.
    Gamma，R. Helm，R. Johnson和J. Vlissides）于1994年撰写。这项工作既没有定义标准也没有协议，而是确定了多年来被证明有用的常见通用软件设计。本书讨论的模式通常被认为属于三类：创建型、结构型和行为型。
- en: 'Examples of many of these patterns have already been presented in this book.
    Here is a brief summary:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中已经介绍了许多这些模式的例子。以下是一个简要总结：
- en: '| Design pattern | Chapter | Recipe |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 设计模式 | 章节 | 食谱 |'
- en: '| --- | --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Singleton | 2 | Defining visibility |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 单例 | 2 | 定义可见性 |'
- en: '| Factory | 6 | Implementing a form factory |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 工厂 | 6 | 实施表单工厂 |'
- en: '| Adapter | 8 | Handling translation without `gettext()` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 适配器 | 8 | 处理没有`gettext（）`的翻译 |'
- en: '| Proxy | 7 | Creating a simple REST clientCreating a simple SOAP client |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 代理 | 7 | 创建一个简单的REST客户端创建一个简单的SOAP客户端 |'
- en: '| Iterator | 23 | Recursive directory iteratorUsing iterators |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 迭代器 | 23 | 递归目录迭代器使用迭代器 |'
- en: In this chapter, we will examine a number of additional design patterns, focusing
    primarily on Concurrency and Architectural patterns.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究一些额外的设计模式，主要关注并发和架构模式。
- en: Creating an array to object hydrator
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数组到对象的水合物
- en: 'The **Hydrator** pattern is a variation of the **Data Transfer Object** design
    pattern. Its design principle is quite simple: moving data from one place to another.
    In this illustration, we will define classes to move data from an array to an
    object.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**水合物**模式是**数据传输对象**设计模式的一种变体。它的设计原则非常简单：将数据从一个地方移动到另一个地方。在这个示例中，我们将定义类来将数据从数组移动到对象。'
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we define a `Hydrator` class that is able to use getters and setters.
    For this illustration we will use `Application\Generic\Hydrator\GetSet`:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '首先，我们定义一个能够使用getter和setter的`Hydrator`类。为了说明这一点，我们将使用`Application\Generic\Hydrator\GetSet`： '
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we define a `hydrate()` method, which takes both an array and an object
    as arguments. It then calls the `setXXX()` methods on the object to populate it
    with values from the array. We use `get_class()` to determine the object''s class,
    and then `get_class_methods()` to get a list of all methods. `preg_match()` is
    used to match the method prefix and its suffix, which is subsequently assumed
    to be the array key:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个“hydrate（）”方法，它接受数组和对象作为参数。然后调用对象上的“setXXX（）”方法，以从数组中填充它的值。我们使用“get_class（）”来确定对象的类，然后使用“get_class_methods（）”来获取所有方法的列表。“preg_match（）”用于匹配方法前缀及其后缀，随后假定为数组键：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'To demonstrate how the array to hydrator object is used, first define the `Application\Generic\Hydrator\GetSet`
    class as described in the *How to do it...* section. Next, define an entity class
    that can be used to test the concept. For the purposes of this illustration, create
    a `Application\Entity\Person` class, with the appropriate properties and methods.
    Be sure to define getters and setters for all properties. Not all such methods
    are shown here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用数组到水合物对象，首先按照*如何做...*部分中的说明定义`Application\Generic\Hydrator\GetSet`类。接下来，定义一个实体类，用于测试这个概念。为了本示例，创建一个`Application\Entity\Person`类，具有适当的属性和方法。确保为所有属性定义getter和setter。这里没有显示所有这样的方法：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can now create a calling program called `chap_11_array_to_object.php`,
    which sets up autoloading, and uses the appropriate classes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以创建一个名为`chap_11_array_to_object.php`的调用程序，设置自动加载，并使用适当的类：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, you can define a test array with values that will be added to a new `Person`
    instance:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以定义一个测试数组，其中包含将添加到新的“Person”实例中的值：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can now call `hydrate()` and `extract()` in a static manner:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以以静态方式调用`hydrate（）`和`extract（）`：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The results are shown in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在以下屏幕截图中：
- en: '![How it works...](graphics/B05314_11_01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_11_01.jpg)'
- en: Building an object to array hydrator
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建对象到数组的水合物
- en: This recipe is the converse of the *Creating an array to object hydrator* recipe.
    In this case, we need to pull values from object properties and return an associative
    array where the key will be the column name.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱是*创建数组到对象的水合物*食谱的相反。在这种情况下，我们需要从对象属性中提取值，并返回一个关联数组，其中键将是列名。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this illustration we will build upon the `Application\Generic\Hydrator\GetSet`
    class defined in the previous recipe:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们将在前一篇中定义的`Application\Generic\Hydrator\GetSet`类的基础上进行构建：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After the `hydrate()` method defined in the previous recipe, we define an `extract()`
    method, which takes an object as an argument. The logic is similar to that used
    with `hydrate()`, except this time we''re searching for `getXXX()` methods. Again,
    `preg_match()` is used to match the method prefix and its suffix, which is subsequently
    assumed to be the array key:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前一篇中定义的`hydrate（）`方法之后，我们定义了一个`extract（）`方法，它以对象作为参数。逻辑与`hydrate（）`使用的逻辑类似，只是这次我们要搜索`getXXX（）`方法。同样，使用`preg_match（）`来匹配方法前缀及其后缀，随后假定为数组键：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we have defined `hydrate()` and `extract()` as static methods for
    convenience.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 棘手的部分是弄清楚选择哪种填充策略。为此，我们定义了`chooseStrategy()`，它以对象作为参数。我们首先通过获取类方法列表来进行一些侦探工作。然后我们扫描列表，看看是否有任何`getXXX()`或`setXXX()`方法。如果有，我们选择`GetSet`填充器作为我们选择的策略：
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Define a calling program called `chap_11_object_to_array.php`, which sets up
    autoloading, and uses the appropriate classes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为`chap_11_object_to_array.php`的调用程序，设置自动加载，并使用适当的类：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, define an instance of `Person`, setting values for its properties:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个`addStrategy()`方法，允许我们覆盖或添加新的策略，而无需重新编写类：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, call the new `extract()` method in a static manner:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，运行时条件会迫使开发人员定义多种解决同一问题的方式。传统上，这涉及到一个庞大的`if/elseif/else`命令块。然后，您要么必须在`if`语句内定义大块逻辑，要么创建一系列函数或方法来实现不同的方法。策略模式试图通过使主类封装一系列代表解决同一问题的不同方法的子类来规范化这个过程。
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is shown in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![How it works...](graphics/B05314_11_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: 请注意，我们已将`hydrate()`和`extract()`定义为静态方法，以方便使用。
- en: Implementing a strategy pattern
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施策略模式
- en: It is often the case that runtime conditions force the developer to define several
    ways of doing the same thing. Traditionally, this involved a massive `if/elseif/else`
    block of commands. You would then either have to define large blocks of logic
    inside the `if` statement, or create a series of functions or methods to enable
    the different approaches. The strategy pattern attempts to formalize this process
    by having the primary class encapsulate a series of sub-classes that represent
    different approaches to solve the same problem.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义反映可用内置策略的类常量：
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来，定义一个`Person`的实例，为其属性设置值：
- en: In this illustration, we will use the `GetSet` hydrator class defined previously
    as a strategy. We will define a primary `Application\Generic\Hydrator\Any` class,
    which will then consume strategy classes in the `Application\Generic\Hydrator\Strategy`
    namespace, including `GetSet`, `PublicProps`, and `Extending`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用之前定义的`GetSet`填充器类作为策略。我们将定义一个主要的`Application\Generic\Hydrator\Any`类，然后在`Application\Generic\Hydrator\Strategy`命名空间中使用策略类，包括`GetSet`、`PublicProps`和`Extending`。
- en: 'We first define class constants that reflect the built-in strategies that are
    available:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是输出的截图：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then define a constructor that adds all built-in strategies to the `$strategies`
    property:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的命名空间中，我们定义一个接口，允许我们识别任何可以被`Application\Generic\Hydrator\Any`消耗的策略：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We also add an `addStrategy()` method that allows us to overwrite or add new
    strategies without having to recode the class:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hydrate()`方法是最困难的，因为我们假设没有定义getter或setter，也没有使用`public`可见级别定义属性。因此，我们需要定义一个扩展要被填充的对象类的类。我们首先定义一个字符串，将用作构建新类的模板：'
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `hydrate()` and `extract()` methods simply call those of the chosen strategy:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hydrate()`和`extract()`方法只是调用所选择策略的方法：'
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The tricky bit is figuring out which hydration strategy to choose. For this
    purpose we define `chooseStrategy()`, which takes an object as an argument. We
    first perform some detective work by way of getting a list of class methods. We
    then scan through the list to see if we have any `getXXX()` or `setXXX()` methods.
    If so, we choose the `GetSet` hydrator as our chosen strategy:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将注意力转向策略本身。首先，我们定义一个新的`Application\Generic\Hydrator\Strategy`命名空间。
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Still within our `chooseStrategy()` method, if there are no getters or setters,
    we next use `get_class_vars()` to determine if there are any available properties.
    If so, we choose `PublicProps` as our hydrator:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`chooseStrategy()`方法中，如果没有getter或setter，我们接下来使用`get_class_vars()`来确定是否有任何可用的属性。如果有，我们选择`PublicProps`作为我们的填充器：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If all else fails, we fall back to the `Extending` hydrator, which returns
    a new class that simply extends the object class, thus making any `public` or
    `protected` properties available:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切都失败了，我们将退回到`Extending`填充器，它返回一个简单地扩展对象类的新类，从而使任何`public`或`protected`属性可用：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now we turn our attention to the strategies themselves. First, we define a new
    `Application\Generic\Hydrator\Strategy` namespace.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个构造函数，将所有内置策略添加到`$strategies`属性中：
- en: 'In the new namespace, we define an interface that allows us to identify any
    strategies that can be consumed by `Application\Generic\Hydrator\Any`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何做...
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `GetSet` hydrator is exactly as defined in the previous two recipes, with
    the only addition being that it will implement the new interface:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetSet`填充器与前两个示例中定义的完全相同，唯一的添加是它将实现新的接口：'
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The next hydrator simply reads and writes public properties:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个填充器只是读取和写入公共属性：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, `Extending`, the Swiss Army knife of hydrators, extends the object
    class, thus providing direct access to properties. We further define magic getters
    and setters to provide access to properties.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`Extending`，填充器的瑞士军刀，扩展了对象类，从而直接访问属性。我们进一步定义了魔术getter和setter，以提供对属性的访问。
- en: 'The `hydrate()` method is the most difficult as we are assuming no getters
    or setters are defined, nor are the properties defined with a visibility level
    of `public`. Accordingly, we need to define a class that extends the class of
    the object to be hydrated. We do this by first defining a string that will be
    used as a template to build the new class:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，以静态方式调用新的`extract()`方法：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Continuing in the `hydrate()` method, we define a `$values` property, and a
    constructor that assigns the array to be hydrated into the object as an argument.
    We loop through the array of values, assigning values to properties. We also define
    a useful `getArrayCopy()` method, which returns these values if needed, as well
    as a magic `__get()` method to simulate direct property access:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`hydrate()`方法中，我们定义了一个`$values`属性和一个将要被填充到对象中的数组的构造函数。我们循环遍历值数组，将值分配给属性。我们还定义了一个有用的`getArrayCopy()`方法，如果需要，返回这些值，以及一个模拟直接属性访问的魔术`__get()`方法：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For convenience we define a magic `__get()` method, which simulates direct
    variable access as if they were public:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为方便起见，我们定义了一个魔术`__get()`方法，模拟直接变量访问，就像它们是公共的一样：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Still in the template for the new class, we define also a magic `__call()`
    method, which simulates getters and setters:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新类的模板中，我们还定义了一个魔术`__call()`方法，模拟getter和setter：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, still in the template for the new class, we add a function, in the
    global namespace, that builds and returns the class instance:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在新类的模板中，我们添加一个函数，在全局命名空间中构建并返回类实例：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Still in the `hydrate()` method, we execute the completed template using `eval()`.
    We then run the `build()` method defined just at the end of the template. Note
    that as we are unsure of the namespace of the class to be populated, we define
    and call `build()` from the global namespace:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`hydrate()`方法中，我们使用`eval()`执行完成的模板。然后运行刚在模板末尾定义的`build()`方法。请注意，由于我们不确定要填充的类的命名空间，我们从全局命名空间中定义和调用`build()`：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `extract()` method is much easier to define as our choices are extremely
    limited. Extending a class and populating it from an array using magic methods
    is easily accomplished. The reverse is not the case. If we were to extend the
    class, we would lose all the property values, as we are extending the class, not
    the object instance. Accordingly, our only option is to use a combination of getters
    and public properties:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`extract()`方法更容易定义，因为我们的选择非常有限。通过魔术方法扩展类并从数组中填充它很容易实现。反之则不然。如果我们扩展类，我们将丢失所有属性值，因为我们扩展的是类，而不是对象实例。因此，我们唯一的选择是使用getter和公共属性的组合：'
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You can begin by defining three test classes with identical properties: `firstName`,
    `lastName`, and so on. The first, `Person`, should have protected properties along
    with getters and setters. The second, `PublicPerson`, will have public properties.
    The third, `ProtectedPerson`, has protected properties but no getters nor setters:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以首先定义三个具有相同属性的测试类：`firstName`，`lastName`等。第一个`Person`应该有受保护的属性以及getter和setter。第二个`PublicPerson`将具有公共属性。第三个`ProtectedPerson`具有受保护的属性，但没有getter或setter：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can now define a calling program called `chap_11_strategy_pattern.php`,
    which sets up autoloading and uses the appropriate classes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以定义一个名为`chap_11_strategy_pattern.php`的调用程序，该程序设置自动加载并使用适当的类：
- en: '[PRE29]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, create an instance of `Person` and run the setters to define values for
    properties:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个`Person`的实例，并运行setter来定义属性的值：
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, create an instance of the `Any` hydrator, call `extract()`, and use `var_dump()`
    to view the results:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`Any`水合剂的实例，调用`extract()`，并使用`var_dump()`查看结果：
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Observe, in the following output, that the `GetSet` strategy was chosen:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在以下输出中，选择了`GetSet`策略：
- en: '![How it works...](graphics/B05314_11_03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_11_03.jpg)'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `id` property is not set as its visibility level is `private`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`id`属性未设置，因为它的可见性级别是`private`。
- en: 'Next, you can define an array with the same values. Call `hydrate()` on the
    `Any` instance, and supply a new `PublicPerson` instance as an argument:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以定义一个具有相同值的数组。在`Any`实例上调用`hydrate()`，并提供一个新的`PublicPerson`实例作为参数：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is the result. Note that the `PublicProps` strategy was chosen in this
    case:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果。请注意，这种情况下选择了`PublicProps`策略：
- en: '![How it works...](graphics/B05314_11_04.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_11_04.jpg)'
- en: 'Finally, call `hydrate()` again, but this time supply an instance of `ProtectedPerson`
    as the object argument. We then call `getFirstName()` and `getLastName()` to test
    the magic getters. We also access first and last names as direct variable access:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，再次调用`hydrate()`，但这次提供一个`ProtectedPerson`的实例作为对象参数。然后我们调用`getFirstName()`和`getLastName()`来测试魔术getter。我们还以直接变量访问的方式访问名字和姓氏：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here is the last output, showing that the `Extending` strategy was chosen.
    You''ll also note that the instance is a new `ProtectedPerson_TEMP` class, and
    that the protected properties are fully populated:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后的输出，显示选择了`Extending`策略。您还会注意到实例是一个新的`ProtectedPerson_TEMP`类，并且受保护的属性已完全填充：
- en: '![How it works...](graphics/B05314_11_05.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_11_05.jpg)'
- en: Defining a mapper
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个映射器
- en: 'A **mapper** or **data mapper** works in much the same manner as a hydrator:
    converting data from one model, be it array or object, into another. A critical
    difference is that the hydrator is generic and does not need to have object property
    names pre-programmed, whereas the mapper is the opposite: it needs precise information
    on property names for both models. In this recipe we will demonstrate the use
    of a mapper to convert data from one database table into another.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射器**或**数据映射器**的工作方式与水合剂类似：将数据从一个模型（数组或对象）转换为另一个模型。一个关键的区别是，水合剂是通用的，不需要预先编程对象属性名称，而映射器则相反：它需要精确的属性名称信息来定义两个模型。在这个示例中，我们将演示使用映射器将数据从一个数据库表转换为另一个数据库表。'
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We first define a `Application\Database\Mapper\FieldConfig` class, which contains
    mapping instructions for individual fields. We also define appropriate class constants:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个`Application\Database\Mapper\FieldConfig`类，其中包含单个字段的映射指令。我们还定义适当的类常量：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Key properties are defined along with the appropriate class constants. `$key`
    is used to identify the object. `$source` represents the column from the source
    database table. `$destTable` and `$destCol` represent the target database table
    and column. `$default`, if defined, contains a default value or a callback that
    produces the appropriate value:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关键属性与适当的类常量一起定义。`$key`用于标识对象。`$source`表示源数据库表中的列。`$destTable`和`$destCol`表示目标数据库表和列。如果定义了`$default`，则包含默认值或产生适当值的回调：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We now turn our attention to the constructor, which assigns default values,
    builds the key, and checks to see that either or both `$source` or `$destTable`
    and `$destCol` are defined:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们转向构造函数，它分配默认值，构建密钥，并检查`$source`或`$destTable`和`$destCol`是否已定义：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we allow source and destination columns to be `NULL`. The reason for
    this is that we might have a source column that has no place in the destination
    table. Likewise, there might be mandatory columns in the destination table that
    are not represented in the source table.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们允许源列和目标列为空。这是因为我们可能有一个源列在目标表中没有位置。同样，目标表中可能有强制列，在源表中没有表示。
- en: 'In the case of defaults, we need to check to see if the value is a callback.
    If so, we run the callback; otherwise, we return the direct value. Note that the
    callbacks should be defined so that they accept a database table row as an argument:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在默认值的情况下，我们需要检查值是否是一个回调。如果是，我们运行回调；否则，我们返回直接值。请注意，回调应该被定义为接受数据库表行作为参数：
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, to wrap up this class, we define getters and setters for each of the
    five properties:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了完成这个类，我们为这五个属性定义了getter和setter：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we define a `Application\Database\Mapper\Mapping` mapping class, which
    accepts the name of the source and destination tables as well as an array of `FieldConfig`
    objects as an argument. You will see later that we allow the destination table
    property to be an array, as the mapping might be to two or more destination tables:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`Application\Database\Mapper\Mapping`映射类，它接受源表和目标表的名称，以及一个`FieldConfig`对象数组作为参数。您将看到我们允许目标表属性为数组，因为映射可能是到两个或更多目标表：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We then define getters and setters for these properties:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们为这些属性定义getter和setter：
- en: '[PRE40]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For field configuration, we also need to provide the ability to add an individual
    field. There is no need to supply the key as a separate argument as this can be
    obtained from the `FieldConfig` instance:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于字段配置，我们还需要提供添加单个字段的能力。无需提供键作为单独的参数，因为这可以从`FieldConfig`实例中获取：
- en: '[PRE41]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It is extremely important to obtain an array of source column names. The problem
    is that the source column name is a property buried in a `FieldConfig` object.
    Accordingly, when this method is called, we loop through the array of `FieldConfig`
    objects and invoke `getSource()` on each one to obtain the source column name:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取源列名的数组非常重要。问题在于源列名是`FieldConfig`对象中的一个属性。因此，当调用这个方法时，我们循环遍历`FieldConfig`对象数组，并在每个对象上调用`getSource()`来获取源列名：
- en: '[PRE42]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We use a similar approach for `getDestColumns()`. The big difference compared
    to getting a list of source columns is that we only want the columns for one specific
    destination table, which is critical if there''s more than one such table is defined.
    We do not need to check to see if `$destCol` is set as this is already taken care
    of in the constructor for `FieldConfig`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对`getDestColumns()`使用了类似的方法。与获取源列列表相比的一个重大区别是，我们只想要一个特定目标表的列，如果定义了多个这样的表，这一点至关重要。我们不需要检查`$destCol`是否设置，因为这已经在`FieldConfig`的构造函数中处理了：
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Finally, we define a method that accepts as a first argument an array representing
    one row of data from the source table. The second argument is the name of the
    destination table. The method produces an array of data ready to be inserted into
    the destination table.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义一个方法，它的第一个参数是表示来自源表的一行数据的数组。第二个参数是目标表的名称。该方法生成一个准备插入到目标表中的数据数组。
- en: 'We had to make a decision as to which would take precedence: the default value
    (which could be provided by a callback), or data from the source table. We decided
    to test for a default value first. If the default comes back `NULL`, data from
    the source is used. Note that if further processing is required, the default should
    be defined as a callback.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须做出一个决定，哪个优先级更高：默认值（可以由回调提供）还是来自源表的数据。我们决定首先测试默认值。如果默认值返回`NULL`，则使用来自源表的数据。请注意，如果需要进一步处理，默认值应该被定义为回调。
- en: '[PRE44]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that some columns will appear in the destination insert that are not present
    in the source row. In this case, the `$source` property of the `FieldConfig` object
    is left as `NULL`, and a default value is supplied, either as a scalar value or
    as a callback.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目标插入中会出现一些在源行中不存在的列。在这种情况下，`FieldConfig`对象的`$source`属性被留空，然后提供一个默认值，可以是标量值或回调函数。
- en: 'We are now ready to define two methods that will generate SQL. The first such
    method will generate an SQL statement to read from the source table. The statement
    will include placeholders to be prepared (for example, using `PDO::prepare()`):'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备定义两个方法来生成SQL。第一个方法将生成一个SQL语句，用于从源表中读取数据。该语句将包括要准备的占位符（例如，使用`PDO::prepare()`）：
- en: '[PRE45]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The other SQL generation method produces a statement to be prepared for a specific
    destination table. Notice that the placeholders are the same as the column names
    preceded by "`:`":'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个SQL生成方法生成一个要为特定目标表准备的语句。请注意，占位符与列名相同，前面加上“`:`”：
- en: '[PRE46]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Use the code shown in steps 1 to 5 to produce an `Application\Database\Mapper\FieldConfig`
    class. Place the code shown in steps 6 to 14 into a second `Application\Database\Mapper\Mapping`
    class.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用步骤1到5中显示的代码生成一个`Application\Database\Mapper\FieldConfig`类。将步骤6到14中显示的代码放入第二个`Application\Database\Mapper\Mapping`类中。
- en: 'Before defining a calling program that performs mapping, it''s important to
    consider the source and destination database tables. The definition for the source
    table, `prospects_11`, is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义执行映射的调用程序之前，重要的是考虑源和目标数据库表。源表`prospects_11`的定义如下：
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In this example, you can use two destination tables, `customer_11` and `profile_11`,
    between which there is a 1:1 relationship:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您可以使用两个目标表，`customer_11`和`profile_11`，它们之间存在1:1的关系：
- en: '[PRE48]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can now define a calling program called `chap_11_mapper.php`, which sets
    up autoloading and uses the two classes mentioned previously. You can also use
    the `Connection` class defined in [Chapter 5](ch05.html "Chapter 5. Interacting
    with a Database"), *Interacting with a Database*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以定义一个名为`chap_11_mapper.php`的调用程序，设置自动加载并使用前面提到的两个类。还可以使用[第5章](ch05.html "第5章。与数据库交互")中定义的`Connection`类，*与数据库交互*：
- en: '[PRE49]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For demonstration purposes, after having made sure the two destination tables
    exist, you can truncate both tables so that any data that appears is clean:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，在确保两个目标表存在后，可以清空这两个表，以确保显示的任何数据都是干净的：
- en: '[PRE50]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You are now ready to build the `Mapping` instance and populate it with `FieldConfig`
    objects. Each `FieldConfig` object represents a mapping between source and destination.
    In the constructor, supply the name of the source table and the two destination
    tables in the form of an array:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以构建`Mapping`实例并用`FieldConfig`对象填充它。每个`FieldConfig`对象表示源和目标之间的映射。在构造函数中，以数组形式提供源表的名称和两个目标表的名称：
- en: '[PRE51]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can start simply by mapping fields between `prospects_11` and `customer_11`
    where there are no defaults:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从`prospects_11`到`customer_11`之间简单地进行字段映射，其中没有默认值：
- en: '[PRE52]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that `addField()` returns the current mapping instance so there is no need
    to keep specifying `$mapper->addField()`. This technique is referred to as the
    **fluent interface**.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`addField()`返回当前的映射实例，因此无需不断指定`$mapper->addField()`。这种技术被称为**流畅接口**。
- en: 'The name field is tricky, as in the `prospects_11` table it''s represented
    by two columns, but only one column in the `customer_11` table. Accordingly, you
    can add a callback as default for `first_name` to combine the two fields into
    one. You will also need to define an entry for `last_name` but where there is
    no destination mapping:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 名称字段比较棘手，在`prospects_11`表中由两列表示，但在`customer_11`表中只有一列。因此，您可以添加一个回调作为`first_name`的默认值，将这两个字段合并为一个。您还需要为`last_name`定义一个条目，但没有目标映射：
- en: '[PRE53]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `customer_11::status` field can use the null coalesce operator (`??`) to
    determine if it''s set or not:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`customer_11::status`字段可以使用空值合并运算符(`??`)来确定是否已设置：'
- en: '[PRE54]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `customer_11::level` field is not represented in the source table, thus
    you can make a `NULL` entry for the source field, but make sure the destination
    table and column are set. Likewise, `customer_11::password` is not present in
    the source table. In this case, the callback uses the phone number as a temporary
    password:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`customer_11::level`字段在源表中没有表示，因此可以为源字段创建一个`NULL`条目，但确保设置了目标表和列。同样，`customer_11::password`在源表中也不存在。在这种情况下，回调使用电话号码作为临时密码：'
- en: '[PRE55]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can also set mappings from `prospects_11` to `profile_11` as follows. Note
    that as the source photo and date of birth columns are not present in `prospects_11`,
    you can set any appropriate default:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将`prospects_11`到`profile_11`的映射设置如下。请注意，由于源照片和出生日期列在`prospects_11`中不存在，因此可以设置任何适当的默认值：
- en: '[PRE56]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In order to establish the 1:1 relationship between the `profile_11` and `customer_11`
    tables, we set the values of `customer_11::id`, `customer_11::profile_id` and
    `profile_11::id` to the value of `$row[''id'']` using a callback:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立`profile_11`和`customer_11`表之间的1:1关系，我们使用回调将`customer_11::id`、`customer_11::profile_id`和`profile_11::id`的值设置为`$row['id']`的值：
- en: '[PRE57]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can now call the appropriate methods to generate three SQL statements,
    one to read from the source table, and two to insert into the two destination
    tables:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以调用适当的方法生成三个SQL语句，一个用于从源表中读取数据，另外两个用于插入到两个目标表中：
- en: '[PRE58]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'These three statements can immediately be prepared for later execution:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个语句可以立即准备好以供以后执行：
- en: '[PRE59]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We then execute the `SELECT` statement, which produces rows from the source
    table. In a loop we then generate `INSERT` data for each destination table, and
    execute the appropriate prepared statements:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行`SELECT`语句，从源表中生成行。然后在循环中为每个目标表生成`INSERT`数据，并执行适当的预处理语句：
- en: '[PRE60]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here are the three SQL statements produced:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生成的三个SQL语句：
- en: '![How it works...](graphics/B05314_11_06.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_11_06.jpg)'
- en: 'We can then view the data directly from the database using SQL `JOIN` to ensure
    the relationship has been maintained:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用SQL `JOIN`直接从数据库中查看数据，以确保关系已经保持：
- en: '![How it works...](graphics/B05314_11_07.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_11_07.jpg)'
- en: Implementing object-relational mapping
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现对象关系映射
- en: There are two primary techniques to achieve a relational mapping between objects.
    The first technique involves pre-loading the related child objects into the parent
    object. The advantage to this approach is that it is easy to implement, and all
    parent-child information is immediately available. The disadvantage is that large
    amounts of memory are potentially consumed, and the performance curve is skewed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要技术可以实现对象之间的关系映射。第一种技术涉及将相关的子对象预先加载到父对象中。这种方法的优势在于易于实现，并且所有父子信息都可以立即使用。缺点是可能会消耗大量内存，并且性能曲线会被扭曲。
- en: The second technique is to embed a secondary lookup into the parent object.
    In this latter approach, when you need to access the child objects, you would
    run a getter that would perform the secondary lookup. The advantage of this approach
    is that performance demands are spread out throughout the request cycle, and memory
    usage is (or can be) more easily managed. The disadvantage of this approach is
    that there are more queries generated, which means more work for the database
    server.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种技术是将次要查找嵌入到父对象中。在后一种方法中，当需要访问子对象时，可以运行一个getter来执行次要查找。这种方法的优势在于性能需求在请求周期内得到了分散，并且内存使用更容易管理。这种方法的缺点是会生成更多的查询，这意味着对数据库服务器的更多工作。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请注意
- en: Please note, however, that we will show how the use of **prepared statements**
    can be used to greatly offset this disadvantage.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，我们将展示如何使用**预处理语句**来大大抵消这种劣势。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Let's have a look at two techniques to implement object-relational mapping.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下实现对象关系映射的两种技术。
- en: 'Technique #1 - pre-loading all child information'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 技术＃1-预加载所有子信息
- en: 'First, we will discuss how to implement object relational mapping by pre-loading
    all child information into the parent class. For this illustration, we will use
    three related database tables, `customer`, `purchases`, and `products`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论如何通过预加载所有子信息到父类中来实现对象关系映射。对于此示例，我们将使用与三个相关数据库表`customer`，`purchases`和`products`对应的实体类定义：
- en: 'We will use the existing `Application\Entity\Customer` class (defined in [Chapter
    5](ch05.html "Chapter 5. Interacting with a Database"), *Interacting with a Database*,
    in the *Defining entity classes to match database tables recipe*) as a model to
    develop an `Application\Entity\Purchase` class. As before, we will use the database
    definition as the basis of the entity class definition. Here is the database definition
    for the `purchases` table:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用现有的`Application\Entity\Customer`类（在[第5章](ch05.html "第5章。与数据库交互")中定义，*与数据库交互*，在*定义实体类以匹配数据库表的方法*中）作为开发`Application\Entity\Purchase`类的模型。与以前一样，我们将使用数据库定义作为实体类定义的基础。以下是`purchases`表的数据库定义：
- en: '[PRE61]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Based on the customer entity class, here is how `Application\Entity\Purchase`
    might look. Note that not all getters and setters are shown:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据客户实体类，`Application\Entity\Purchase`可能如下所示。请注意，未显示所有的getter和setter：
- en: '[PRE62]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We are now ready to define `Application\Entity\Product`. Here is the database
    definition for the `products` table:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备定义`Application\Entity\Product`。以下是`products`表的数据库定义：
- en: '[PRE63]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Based on the customer entity class, here is how `Application\Entity\Product`
    might look:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据客户实体类，`Application\Entity\Product`可能如下所示：
- en: '[PRE64]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we need to implement a way to embed related objects. We will start with
    the `Application\Entity\Customer` parent class. For this section, we will assume
    the following relationships, illustrated in the following diagram:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现一种嵌入相关对象的方法。我们将从`Application\Entity\Customer`父类开始。在本节中，我们将假设以下关系，如下图所示：
- en: One customer, many purchases
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个客户，多个购买
- en: One purchase, one product
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个购买，一个产品
- en: '![Technique #1 - pre-loading all child information](graphics/B05314_11_08.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![技术＃1-预加载所有子信息](graphics/B05314_11_08.jpg)'
- en: 'Accordingly, we define a getter and setter that process purchases in the form
    of an array of objects:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们定义了一个处理购买的getter和setter，以对象数组的形式进行处理：
- en: '[PRE65]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now we turn our attention to `Application\Entity\Purchase`. In this case, there
    is a 1:1 relationship between a purchase and a product, so there''s no need to
    process an array:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将注意力转向`Application\Entity\Purchase`。在这种情况下，购买和产品之间存在1：1的关系，因此无需处理数组：
- en: '[PRE66]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that in both entity classes, we do not alter the `$mapping` array. This
    is because implementing object relational mapping has no bearing on the mapping
    between entity property names and database column names.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在两个实体类中，我们不会更改`$mapping`数组。这是因为实现对象关系映射对实体属性名称和数据库列名称之间的映射没有影响。
- en: 'Since the core functionality of obtaining basic customer information is still
    needed, all we need to do is to extend the `Application\Database\CustomerService`
    class described in [Chapter 5](ch05.html "Chapter 5. Interacting with a Database"),
    *Interacting with a Database*, in the *Tying entity classes to RDBMS queries*
    recipe. We can create a new `Application\Database\CustomerOrmService_1` class,
    which extends `Application\Database\CustomerService`:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于仍然需要获取基本客户信息的核心功能，我们只需要扩展[第5章](ch05.html "第5章。与数据库交互")中描述的`Application\Database\CustomerService`类，*与数据库交互*，在*将实体类与RDBMS查询绑定*中。我们可以创建一个新的`Application\Database\CustomerOrmService_1`类，它扩展了`Application\Database\CustomerService`：
- en: '[PRE67]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We then add a method to the new service class that performs a lookup and embeds
    the results, in the form of `Product` and `Purchase` entities, into the core customer
    entity. This method performs a lookup in the form of a `JOIN`. This is possible
    because there is a 1:1 relationship between purchase and product. Because the
    `id` column has the same name in both tables, we need to add the purchase ID column
    as an alias. We then loop through the results, creating `Product` and `Purchase`
    entities. After overriding the ID, we can then embed the `Product` entity into
    the `Purchase` entity, and then add the `Purchase` entity to the array in the
    `Customer` entity:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们向新的服务类添加一个方法，该方法执行查找并将结果嵌入到核心客户实体中，以`Product`和`Purchase`实体的形式。此方法执行`JOIN`形式的查找。这是可能的，因为购买和产品之间存在1：1的关系。因为`id`列在两个表中的名称相同，所以我们需要将购买ID列添加为别名。然后，我们遍历结果，创建`Product`和`Purchase`实体。在覆盖ID之后，我们可以将`Product`实体嵌入`Purchase`实体中，然后将`Purchase`实体添加到`Customer`实体中的数组中：
- en: '[PRE68]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, we provide a wrapper for the original `fetchById()` method. This block
    of code needs to not only get the original `Customer` entity, but needs to look
    up and embed `Product and Purchase` entities. We can call the new `fetchByIdAndEmbedPurchases()`
    method and accept a customer ID as an argument:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们提供原始`fetchById()`方法的包装器。这段代码块不仅需要获取原始的`Customer`实体，还需要查找并嵌入`Product和Purchase`实体。我们可以调用新的`fetchByIdAndEmbedPurchases()`方法，并接受客户ID作为参数：
- en: '[PRE69]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Technique #2 - embedding secondary lookups'
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 技术＃2-嵌入次要查找
- en: 'Now we will cover embedding secondary lookups into the related entity classes.
    We will continue to use the same illustration as above, using the entity classes
    defined that correspond to three related database tables, `customer`, `purchases`,
    and `products`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍将次要查找嵌入到相关实体类中的方法。我们将继续使用与上述相同的示例，使用与三个相关数据库表`customer`，`purchases`和`products`对应的实体类定义：
- en: The mechanics of this approach are quite similar to those described in the preceding
    section. The main difference is that instead of doing the database lookup, and
    producing entity classes right away, we will embed a series of anonymous functions
    that will do the same thing, but called from the view logic.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种方法的机制与前一节中描述的方法非常相似。主要区别在于，我们不会立即进行数据库查找和生成实体类，而是嵌入一系列匿名函数，这些函数将从视图逻辑中调用相同的操作。
- en: 'We need to add a new method to the `Application\Entity\Customer` class that
    adds a single entry to the `purchases` property. Instead of an array of `Purchase`
    entities, we will be supplying an anonymous function:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要向`Application\Entity\Customer`类添加一个新方法，将单个条目添加到`purchases`属性中。我们将提供一个匿名函数，而不是`Purchase`实体数组：
- en: '[PRE70]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we will make a copy of the `Application\Database\CustomerOrmService_1`
    class, and call it `Application\Database\CustomerOrmService_2`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将复制`Application\Database\CustomerOrmService_1`类，并将其命名为`Application\Database\CustomerOrmService_2`：
- en: '[PRE71]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We then define a `fetchPurchaseById()` method, which looks up a single purchase
    based on its ID and produces a `Purchase` entity. Because we will ultimately be
    making a series of repetitive requests for single purchases in this approach,
    we can regain database efficiency by working off the same prepared statement,
    in this case, a property called `$purchPreparedStmt`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个`fetchPurchaseById()`方法，根据其ID查找单个购买并生成一个`Purchase`实体。因为在这种方法中，我们最终将进行一系列重复的请求以获取单个购买，所以我们可以通过使用相同的预处理语句（在本例中称为`$purchPreparedStmt`属性）来恢复数据库效率：
- en: '[PRE72]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'After that, we need a `fetchProductById()` method that looks up a single product
    based on its ID and produces a `Product` entity. Given that a customer may have
    purchased the same product several times, we can introduce an additional level
    of efficiency by storing acquired product entities in a `$products` array. In
    addition, as with purchases, we can perform lookups on the same prepared statement:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们需要一个`fetchProductById()`方法，根据其ID查找单个产品并生成一个`Product`实体。鉴于客户可能多次购买同一产品，我们可以通过在`$products`数组中存储已获取的产品实体来提高效率。此外，与购买一样，我们可以在同一个预处理语句上执行查找：
- en: '[PRE73]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We can now rework the `fetchPurchasesForCustomer()` method to have it embed
    an anonymous function that makes calls to both `fetchPurchaseById()` and `fetchProductById()`,
    and then assigns the resulting product entity to the newly found purchase entity.
    In this example, we do an initial lookup that just returns the IDs of all purchases
    for this customer. We then embed a sequence of anonymous functions in the `Customer::$purchases`
    property, storing the purchase ID as the array key, and the anonymous function
    as its value:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以重新设计`fetchPurchasesForCustomer()`方法，使其嵌入一个匿名函数，该函数调用`fetchPurchaseById()`和`fetchProductById()`，然后将结果的产品实体分配给新找到的购买实体。在本例中，我们进行了一个初始查找，只返回该客户的所有购买的ID。然后，我们在`Customer::$purchases`属性中嵌入了一系列匿名函数，将购买ID作为数组键，匿名函数作为其值：
- en: '[PRE74]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How it works...
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Define the following classes based on the steps from this recipe as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本教程的步骤，定义以下类如下：
- en: '| Class | Technique #1 steps |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 技术#1步骤 |'
- en: '| --- | --- |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Application\Entity\Purchase` | 1 - 2, 7 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Entity\Purchase` | 1 - 2, 7 |'
- en: '| `Application\Entity\Product` | 3 - 4 |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Entity\Product` | 3 - 4 |'
- en: '| `Application\Entity\Customer` | 6, 16, + described in [Chapter 5](ch05.html
    "Chapter 5. Interacting with a Database"), *Interacting with a Database*. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Entity\Customer` | 6, 16, + 在[第5章](ch05.html "第5章。与数据库交互"),
    *与数据库交互*中描述。 |'
- en: '| `Application\Database\CustomerOrmService_1` | 8 - 10 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Database\CustomerOrmService_1` | 8 - 10 |'
- en: 'The second approach to this would be as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的第二种途径如下：
- en: '| Class | Technique #2 steps |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 技术#2步骤 |'
- en: '| --- | --- |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Application\Entity\Customer` | 2 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Entity\Customer` | 2 |'
- en: '| `Application\Database\CustomerOrmService_2` | 3 - 6 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `Application\Database\CustomerOrmService_2` | 3 - 6 |'
- en: 'In order to implement approach #1, where entities are embedded, define a calling
    program called `chap_11_orm_embedded.php,` which sets up autoloading and uses
    the appropriate classes:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现第一种方法，即嵌入实体，定义一个名为`chap_11_orm_embedded.php`的调用程序，设置自动加载并使用适当的类：
- en: '[PRE75]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, create an instance of the service, and look up a customer using a random
    ID:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个服务的实例，并使用随机ID查找一个客户：
- en: '[PRE76]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In the view logic, you will have acquired a fully populated `Customer` entity
    by way of the `fetchByIdAndEmbedPurchases()` method. Now all you need to do is
    to call the right getters to display information:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图逻辑中，您将通过`fetchByIdAndEmbedPurchases()`方法获取一个完全填充的`Customer`实体。现在，您只需要调用正确的getter来显示信息：
- en: '[PRE77]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The logic needed to display purchase information would then look something
    like the following HTML. Notice that `Customer::getPurchases()` returns an array
    of `Purchase` entities. To get product information from the `Purchase` entity,
    inside the loop, call `Purchase::getProduct()`, which produces a `Product` entity.
    You can then call any of the `Product` getters, in this example, `Product::getTitle()`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，显示购买信息所需的逻辑将类似于以下HTML。请注意，`Customer::getPurchases()`返回一个`Purchase`实体数组。要从`Purchase`实体获取产品信息，在循环内调用`Purchase::getProduct()`，这将生成一个`Product`实体。然后可以调用任何`Product`的getter，在本例中为`Product::getTitle()`：
- en: '[PRE78]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Turning your attention to the second approach, which uses secondary lookups,
    define a calling program called `chap_11_orm_secondary_lookups.php`, which sets
    up autoloading and uses the appropriate classes:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 将注意力转向使用辅助查找的第二种方法，定义一个名为`chap_11_orm_secondary_lookups.php`的调用程序，设置自动加载并使用适当的类：
- en: '[PRE79]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next, create an instance of the service, and look up a customer using a random
    ID:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个服务的实例，并使用随机ID查找一个客户：
- en: '[PRE80]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You can now retrieve an `Application\Entity\Customer` instance and call `fetchPurchasesForCustomer()`
    for this customer, which embeds the sequence of anonymous functions:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以检索一个`Application\Entity\Customer`实例，并为该客户调用`fetchPurchasesForCustomer()`，这将嵌入一系列匿名函数：
- en: '[PRE81]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The view logic for displaying core customer information remains the same as
    described previously. The logic needed to display purchase information would then
    look something like the following HTML code snippet. Notice that `Customer::getPurchases()`
    returns an array of anonymous functions. Each function call returns one specific
    purchase and related products:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 显示核心客户信息的视图逻辑与之前描述的相同。然后，显示购买信息所需的逻辑看起来像以下HTML代码片段。请注意，`Customer::getPurchases()`返回一个匿名函数数组。每个函数调用返回一个特定的购买和相关产品：
- en: '[PRE82]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here is an example of the output:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出的示例：
- en: '![How it works...](graphics/B05314_11_09.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B05314_11_09.jpg)'
- en: Tip
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best practice**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: 'Although each iteration of the loop represents two independent database queries
    (one for purchase, one for product), efficiency is retained by the use of *prepared
    statements*. Two statements are prepared in advance: one that looks up a specific
    purchase, and one that looks up a specific product. These prepared statements
    are then executed multiple times. Also, each product retrieval is independently
    stored in an array, resulting in even greater efficiency.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管循环的每次迭代代表两个独立的数据库查询（一个用于购买，一个用于产品），但通过使用*准备好的语句*保留了效率。两个语句提前准备好：一个查找特定的购买，一个查找特定的产品。然后多次执行这些准备好的语句。此外，每个产品检索都独立存储在一个数组中，从而实现了更高的效率。
- en: See also
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Probably the best example of a library that implements object-relational mapping
    is Doctrine. Doctrine uses an embedded approach that its documentation refers
    to as a proxy. For more information, please refer to [http://www.doctrine-project.org/projects/orm.html](http://www.doctrine-project.org/projects/orm.html).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最好的实现对象关系映射的库的例子是Doctrine。Doctrine使用其文档称为代理的嵌入式方法。有关更多信息，请参阅[http://www.doctrine-project.org/projects/orm.html](http://www.doctrine-project.org/projects/orm.html)。
- en: 'You might also consider reviewing a training video on *Learning Doctrine*,
    available from O''Reilly Media at [http://shop.oreilly.com/product/0636920041382.do](http://shop.oreilly.com/product/0636920041382.do).
    (Disclaimer: this is a shameless plug by the author of both this book and this
    video!)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还考虑观看来自O'Reilly Media的*学习Doctrine*的培训视频，网址为[http://shop.oreilly.com/product/0636920041382.do](http://shop.oreilly.com/product/0636920041382.do)。（免责声明：这是本书和本视频的作者的厚颜无耻的宣传！）
- en: Implementing the Pub/Sub design pattern
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施发布/订阅设计模式
- en: The **Publish/Subscribe** (**Pub/Sub**) design pattern often forms the basis
    of software event-driven programming. This methodology allows **asynchronous**
    communications between different software applications, or different software
    modules within a single application. The purpose of the pattern is to allow a
    method or function to publish a signal when an action of significance has taken
    place. One or more classes would then subscribe and take action if a certain signal
    has been published.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布/订阅**（**Pub/Sub**）设计模式通常是软件事件驱动编程的基础。这种方法允许不同软件应用程序之间或单个应用程序中的不同软件模块之间进行**异步**通信。该模式的目的是允许方法或函数在发生重要动作时发布信号。然后一个或多个类将订阅并在特定信号被发布时采取行动。'
- en: Example of such actions are when the database is modified, or when a user has
    logged in. Another common use for this design pattern is when an application delivers
    news feeds. If an urgent news item has been posted, the application would publish
    this fact, allowing client subscribers to refresh their news listings.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的例子是当数据库被修改时，或者用户已登录时。此设计模式的另一个常见用途是应用程序提供新闻订阅。如果发布了紧急新闻项目，应用程序将发布此事实，允许客户端订阅者刷新其新闻列表。
- en: How to do it...
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we define our publisher class, `Application\PubSub\Publisher`. You''ll
    notice that we are making use of two useful **Standard PHP Library** (**SPL**)
    interfaces, `SplSubject` and `SplObserver`:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义我们的发布者类`Application\PubSub\Publisher`。您会注意到我们正在使用两个有用的**标准PHP库**（**SPL**）接口，`SplSubject`和`SplObserver`：
- en: '[PRE83]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Next, we add properties to represent the publisher name, data to be passed
    to subscribers, and an array of subscribers (also referred to as listeners). You
    will also note that we will use a linked list (described in [Chapter 10](ch10.html
    "Chapter 10. Looking at Advanced Algorithms"), *Looking at Advanced Algorithms*)
    to allow for priority:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加属性来表示发布者名称，要传递给订阅者的数据以及订阅者的数组（也称为监听器）。您还会注意到我们将使用链表（在[第10章](ch10.html
    "第10章。查看高级算法")中描述，*查看高级算法*）以允许优先级：
- en: '[PRE84]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The constructor initializes these properties. We also throw in `__toString()`
    in case we need quick access to the name of this publisher:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数初始化这些属性。我们还加入了`__toString()`，以防我们需要快速访问此发布者的名称：
- en: '[PRE85]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'In order to associate a subscriber with this publisher, we define `attach()`,
    which is specified in the `SplSubject` interface. We accept an `SplObserver` instance
    as an argument. Note that we need to add entries to both the `$subscribers` and
    `$linked` properties. `$linked` is then sorted by value, represented by the priority,
    using `arsort()`, which sorts in reverse and maintains the key:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将订阅者与此发布者关联，我们定义`attach()`，它在`SplSubject`接口中指定。我们接受一个`SplObserver`实例作为参数。请注意，我们需要向`$subscribers`和`$linked`属性添加条目。然后使用`arsort()`按优先级对`$linked`进行排序，表示值排序，以维护键：
- en: '[PRE86]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The interface also requires us to define `detach()`, which removes the subscriber
    from the list:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口还要求我们定义`detach()`，它从列表中移除订阅者：
- en: '[PRE87]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Also required by the interface, we define `notify()`, which calls `update()`
    on all the subscribers. Note that we loop through the linked list to ensure the
    subscribers are called in order of priority:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口还要求我们定义`notify()`，它调用所有订阅者的`update()`。请注意，我们循环遍历链接列表以确保按优先级顺序调用订阅者：
- en: '[PRE88]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, we define the appropriate getters and setters. We don''t show them all
    here to conserve space:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义适当的getter和setter。我们这里没有全部显示出来以节省空间：
- en: '[PRE89]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Finally, we need to provide a means of setting data items by key, which will
    then be available to subscribers when `notify()` is invoked:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要提供一种通过键设置数据项的方法，然后在调用`notify()`时这些数据项将对订阅者可用：
- en: '[PRE90]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now we can have a look at `Application\PubSub\Subscriber`. Typically, we would
    define multiple subscribers for each publisher. In this case, we implement the
    `SplObserver` interface:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以看一下`Application\PubSub\Subscriber`。通常，我们会为每个发布者定义多个订阅者。在这种情况下，我们实现了`SplObserver`接口：
- en: '[PRE91]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Each subscriber needs a unique identifier. In this case, we create the key
    using `md5()` and date/time information, combined with a random number. The constructor
    initializes the properties as follows. The actual logical functionality performed
    by the subscriber is in the form of a callback:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个订阅者都需要一个唯一的标识符。在这种情况下，我们使用`md5()`和日期/时间信息以及随机数来创建密钥。构造函数初始化属性如下。订阅者执行的实际逻辑功能以回调的形式进行：
- en: '[PRE92]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The `update()` function is called when `notifiy()` on the publisher is invoked.
    We pass a publisher instance as an argument, and call the callback defined for
    this subscriber:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调用发布者的`notify()`时，将调用`update()`函数。我们将一个发布者实例作为参数传递，并调用为该订阅者定义的回调函数：
- en: '[PRE93]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We also need to define getters and setters for convenience. Not all are shown
    here:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要为方便起见定义getter和setter。这里没有展示所有的内容：
- en: '[PRE94]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: How it works...
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'For the purposes of this illustration, define a calling program called `chap_11_pub_sub_simple_example.php`,
    which sets up autoloading and uses the appropriate classes:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，定义一个名为`chap_11_pub_sub_simple_example.php`的调用程序，设置自动加载并使用适当的类：
- en: '[PRE95]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, create a publisher instance and assign data:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个发布者实例并分配数据：
- en: '[PRE96]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now you can create test subscribers that read data from the publisher and echo
    the results. The first parameter is the name, the second the callback, and the
    last is the priority:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以创建测试订阅者，从发布者那里读取数据并输出结果。第一个参数是名称，第二个是回调，最后一个是优先级：
- en: '[PRE97]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'For test purposes, attach the subscribers out of order, and call `notify()`
    twice:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，以不正确的顺序附加订阅者，并调用`notify()`两次：
- en: '[PRE98]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Next, define and attach another subscriber that looks at the data for subscriber
    1 and exits if it''s not empty:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义并附加另一个订阅者，查看订阅者1的数据，如果不为空则退出：
- en: '[PRE99]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Here is the output. Note that the output is in order of priority (where higher
    priority goes first), and that the second block of output is interrupted:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出。请注意，输出按优先级顺序排列（优先级较高的排在前面），第二个输出块被中断：
- en: '![How it works...](graphics/B05314_11_10.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/B05314_11_10.jpg)'
- en: There's more...
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A closely related software design pattern is **Observer**. The mechanism is
    similar but the generally agreed difference is that Observer operates in a synchronous
    manner, where all observer methods are called when a signal (often also referred
    to as message or event) is received. The Pub/Sub pattern, in contrast, operates
    asynchronously, typically using a message queue. Another difference is that in
    the Pub/Sub pattern, publishers do not need to be aware of subscribers.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 一个密切相关的软件设计模式是**Observer**。机制类似，但普遍认为的区别是Observer以同步方式运行，当接收到信号（通常也称为消息或事件）时，会调用所有观察者方法。相比之下，Pub/Sub模式以异步方式运行，通常使用消息队列。另一个区别是，在Pub/Sub模式中，发布者不需要知道订阅者。
- en: See also
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For a good discussion on the difference between the Observer and Pub/Sub patterns,
    refer to the article at [http://stackoverflow.com/questions/15594905/difference-between-observer-pub-sub-and-data-binding](http://stackoverflow.com/questions/15594905/difference-between-observer-pub-sub-and-data-binding).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 有关观察者和Pub/Sub模式之间的区别的讨论，请参阅[http://stackoverflow.com/questions/15594905/difference-between-observer-pub-sub-and-data-binding](http://stackoverflow.com/questions/15594905/difference-between-observer-pub-sub-and-data-binding)上的文章。
