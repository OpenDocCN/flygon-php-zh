- en: Chapter 5.  Functors, Applicatives, and Monads
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。函子、应用函子和单子
- en: The previous chapter introduced the first real functional techniques, such as
    function composition and currying. In this chapter, we will delve into more theoretical
    concepts again by presenting the concept of monads. There won't be a lot of practical
    application as we have a lot of ground to cover. However, [Chapter 6](ch06.html
    "Chapter 6.  Real-Life Monads"), *Real-life Monads* will use everything we learn
    here to solve real issues.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了第一个真正的函数式技术，比如函数组合和柯里化。在本章中，我们将再次深入介绍更多的理论概念，介绍单子的概念。由于我们有很多内容要涵盖，实际应用将不会很多。然而，[第6章](ch06.html
    "第6章。真实生活中的单子")*真实生活中的单子*将使用我们在这里学到的一切来解决真实问题。
- en: You might already have heard the term **monad**. Usually, it is associated with
    a sense of dread by non functional programmers. Monads are usually described as
    hard to understand despite countless tutorials on the subject. The fact is, they
    are hard to understand and people writing those tutorials often forget how much
    time it took them to understand the idea correctly. This is a common pedagogic
    pitfall, probably much better described in this article at [https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/](https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经听说过**单子**这个术语。通常，它与非函数式程序员的恐惧感联系在一起。单子通常被描述为难以理解，尽管有无数关于这个主题的教程。事实上，它们很难理解，写这些教程的人经常忘记了他们正确理解这个想法花了多少时间。这是一个常见的教学陷阱，可能在这篇文章中更好地描述了[https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/](https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/)。
- en: You will probably not get everything the first time. Monads are a highly abstract
    concept and, even if the topic seems clear to you at the end of the chapter, you
    will probably stumble upon something later on that will baffle your intuition
    of what a monad really is.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不会一次性理解所有内容。单子是一个非常抽象的概念，即使在本章结束时，这个主题对你来说似乎很清楚，你可能在以后遇到一些东西，它会使你对单子的真正理解感到困惑。
- en: 'I will try to do my best to explain things clearly, but if you find my explanations
    lacking, I added references to other material about the topic in the *Further
    reading* section at the end of this chapter. In this chapter, we will cover the
    following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我会尽力清楚地解释事情，但如果你觉得我的解释不够，我在本章末尾的*进一步阅读*部分添加了关于这个主题的其他材料的参考。在本章中，我们将涵盖以下主题：
- en: Functors and related laws
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函子及相关法则
- en: Applicative functors and related laws
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用函子及相关法则
- en: Monoids and related laws
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幺半群及相关法则
- en: Monads and related laws
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单子及相关法则
- en: There will be a lot of theoretical content only with implementation of the concepts.
    Don't expect a lot of examples until [Chapter 6](ch06.html "Chapter 6.  Real-Life
    Monads"), *Real-life Monads*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将会有很多理论内容，只有概念的实现。在[第6章](ch06.html "第6章。真实生活中的单子")*真实生活中的单子*之前，不要期望有很多例子。
- en: Functors
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函子
- en: Before speaking directly of monads, let us start at the beginning. In order
    to understand what a monad is, we need to introduce a few related concepts. The
    first one is functors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在直接讲述单子之前，让我们从头开始。为了理解单子是什么，我们需要介绍一些相关概念。第一个是函子。
- en: To complicate matters a bit, the term **functor** is used in imperative programming
    to describe a function object, which is something totally different. In PHP, an
    object with the `__invoke` method, as we saw in [Chapter 1](ch01.html "Chapter 1. Functions
    as First Class Citizens in PHP"), *Functions as First Class Citizens*, is such
    a function object.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情变得复杂一些，术语**函子**在命令式编程中用来描述函数对象，这是完全不同的东西。在PHP中，一个具有`__invoke`方法的对象，就像我们在[第1章](ch01.html
    "第1章。PHP中的一等公民函数")中看到的那样，*函数作为一等公民*，就是这样一个函数对象。
- en: However, in functional programming, a functor is a concept taken and adapted
    from the mathematical field of category theory. Details aren't that important
    for our purpose; it suffice it to say that a functor is a pattern allowing us
    to map a function to one or more values contained in a context. Also, in order
    for the definition to be as complete as possible, our functor must respect some
    laws, which we will describe and verify later.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在函数式编程中，函子是从范畴论的数学领域中借用并改编的概念。细节对我们的目的并不那么重要；它足以说，函子是一种模式，允许我们将函数映射到一个或多个值所包含的上下文中。此外，为了使定义尽可能完整，我们的函子必须遵守一些法则，我们将在稍后描述和验证。
- en: We have already used map multiple times on collections, which makes them de
    facto functors. But if you remember correctly, we also named our method to apply
    a function to the value contained in Maybe in the same way. The reason is that
    functors can be seen as containers with a means to apply a function to the contained
    value.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次在集合上使用了map，这使它们成为了事实上的函子。但是如果你记得的话，我们也以相同的方式命名了我们的方法来将一个函数应用于Maybe中包含的值。原因是函子可以被看作是具有一种方法来将函数应用于包含的值的容器。
- en: 'In a sense, any class that implements the following interface could be called
    a `Functor`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，任何实现以下接口的类都可以被称为`函子`：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, describing it like that is a bit reductive. A simple PHP array is also
    a functor (because the `array_map` function exists), as is anything implementing
    the `Traversable` interface as soon as you use the `functional-php` library and
    its map function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样描述有点简化了。一个简单的PHP数组也是一个函子（因为存在`array_map`函数），只要你使用`functional-php`库和它的map函数，任何实现`Traversable`接口的东西也是一个函子。
- en: Why such a fuss for such a simple idea? Because, although the idea is simple
    in itself, it allows us to reason about what is happening in a different light
    and possibly helps understand and refactor the code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么对于一个如此简单的想法要大惊小怪？因为，尽管这个想法本身很简单，它使我们能够以不同的方式思考正在发生的事情，并可能有助于理解和重构代码。
- en: Also, the `map` function can do much more than blindly apply the given `callable`
    type, as is the case with an array. If you remember our `Maybe` type implementation,
    in the case of a value `Nothing`, the `map` function simply kept returning the
    `Nothing` value in order to allow for a simpler management of null values.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`map`函数可以做的远不止盲目地应用给定的`callable`类型，就像数组一样。如果你记得我们的`Maybe`类型实现，在值为`Nothing`的情况下，`map`函数只是简单地保持返回`Nothing`值，以便更简单地管理空值。
- en: We could also imagine having much more complicated data structures in our functors,
    such as trees, where the function given to the `map` function is applied to all
    nodes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以想象在我们的函子中有更复杂的数据结构，比如树，其中给`map`函数的函数应用于所有节点。
- en: Functors allow us to share a common interface, our `map` method or function,
    to perform a similar operation on a variety of data types while hiding the complexity
    of the implementation. As often with functional programming, the cognitive burden
    is reduced because you don't have multiple names for an identical operation. Function
    and method names such as "apply", "perform", and "walk" are often seen to describe
    the same thing for example.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 函子允许我们共享一个共同的接口，我们的`map`方法或函数，对各种数据类型执行类似的操作，同时隐藏实现的复杂性。就像函数式编程一样，认知负担减少了，因为你不需要为相同的操作有多个名称。例如，"apply"、"perform"和"walk"等函数和方法名称通常用来描述相同的事情。
- en: Identity function
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恒等函数
- en: 'Our final concern is the two functor laws that come with the concept. But before
    introducing them, we need to take a small detour about the identity function,
    or often `id`. It is a really simple function that simply returns its parameter:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终关注的是与这个概念相关的两个函子定律。但在介绍它们之前，我们需要稍微偏离一下，讨论一下恒等函数，通常是`id`。这是一个非常简单的函数，只是简单地返回它的参数：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Why would anyone need a function doing as little as this? First of all, we will
    need it later to prove the laws of the various abstractions presented in this
    chapter. But real-world applications also exist.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么有人需要一个做得这么少的函数？首先，我们以后会需要它来证明本章中介绍的各种抽象的定律。但现实世界中也存在应用。
- en: For example, when you are doing a fold with numbers, say summing them, you will
    use the initial value `0`. The `id` function will have the same role when folding
    over functions. As a matter of fact, the compose function is implemented using
    the `id` function in the `functional-php` library.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你对数字进行折叠运算，比如求和，你会使用初始值`0`。`id`函数在对函数进行折叠时起着相同的作用。事实上，`functional-php`库中的compose函数是使用`id`函数实现的。
- en: Another use might be some function from another library that performs an operation
    you are interested in, but also calls a callback on the resulting data. If the
    callback is mandatory, but you don't want to do anything else to your data, just
    pass `id` and you will get them unaltered.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用途可能是来自另一个库的某个函数，它执行你感兴趣的操作，但也在结果数据上调用回调。如果回调是必需的，但你不想对数据做其他任何操作，只需传递`id`，你将得到未经改变的数据。
- en: 'Let''s use our new function to declare a property of our `compose` function
    for any function `f`, taking only one argument:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们的新函数来声明我们的`compose`函数的一个属性，对于任何只接受一个参数的函数`f`：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What this basically says is that, if you first apply the argument `id` then
    `f`, you will get the exact same result as when first applying `f` and then `id`.
    At this point, this should be evident to you. If not, I encourage you to revisit
    the last chapter until you clearly understand why this is the case.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是说，如果你先应用参数`id`然后是`f`，你会得到与先应用`f`然后是`id`完全相同的结果。到这一点，这对你来说应该是显而易见的。如果不是，我鼓励你重新阅读上一章，直到你清楚地理解为什么会这样。
- en: Functor laws
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函子定律
- en: 'Now that we have our identity function covered, let''s get back to our laws.
    They are important for two reasons:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了我们的恒等函数，让我们回到我们的定律。它们有两个重要原因：
- en: They give us a set of constraints to guarantee the validity of our functors
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们给了我们一组约束条件，以确保我们的函子的有效性。
- en: They allow us to perform refactoring that is proven correct
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们允许我们进行经过验证的重构
- en: 'Without further ado, here they are:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 话不多说，它们在这里：
- en: '*map(id) == id*'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*map(id) == id*'
- en: '*compose(map(f), map(g)) == map(compose(f, g))*'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*compose(map(f), map(g)) == map(compose(f, g))*'
- en: The first law states that mapping the `id` function on the contained value is
    exactly the same as calling the `id` function directly on the functor itself.
    When this law holds, this guarantees us that our map function only applies the
    given function to the data without performing any other kind of treatment.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一定律规定，将`id`函数映射到包含的值上，与直接在函子本身上调用`id`函数完全相同。当这个定律成立时，这保证了我们的map函数只将给定的函数应用于数据，而不进行任何其他类型的处理。
- en: The second law states that first mapping the `f` function then the g one on
    our value is the same as first composing `f` and `g` together and then mapping
    the resulting function. Knowing this, we can perform all kinds of optimization.
    For example, instead of looping three times over our data for three different
    methods, we can compose them together and perform only one loop.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第二定律规定，首先在我们的值上映射`f`函数，然后是`g`函数，与首先将`f`和`g`组合在一起，然后映射结果函数完全相同。知道这一点，我们可以进行各种优化。例如，我们可以将它们组合在一起，只进行一次循环，而不是对我们的数据进行三种不同方法的三次循环。
- en: 'I can imagine not everything being crystal clear for you right now, so instead
    of wasting time trying to explain them further, let''s verify if they hold for
    the `array_map` method. This will probably help you to get the gist of it; the
    following code expects the `id` function defined previously to be in scope :'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以想象现在对你来说并不是一切都很清楚，所以不要浪费时间试图进一步解释它们，让我们验证它们是否适用于`array_map`方法。这可能会帮助你理解它的要点；以下代码期望之前定义的`id`函数在作用域内：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The composition is performed manually; as in my opinion resorting to currying
    here would only have made things more complicated.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是手动执行的；在我看来，在这里使用柯里化只会使事情变得更加复杂。
- en: As we can see, both laws hold for the `array_map` method, which is a good sign
    because it means there is no hidden data processing done in the shadow and we
    can avoid looping two or more times on our array when only once is enough.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`array_map`方法符合这两个定律，这是一个好迹象，因为这意味着没有隐藏的数据处理在背后进行，我们可以避免在数组上循环两次或更多次，当只需要一次时。
- en: 'Let''s try the same with our `Maybe` type defined earlier:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下我们之前定义的`Maybe`类型：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We had to switch to a non-strict equality for the `$just` case because we would
    have a result of false otherwise as PHP compares object instances and not their
    values. A `Maybe` type wraps the resulting value in a new object and PHP only
    performs internal value comparison in the case of a non-strict equality; the`add2`,
    `times10`, and `composed` functions defined above are expected to be in scope:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不切换到非严格相等的方式来处理`$just`情况，因为否则我们会得到一个错误的结果，因为PHP比较对象实例而不是它们的值。`Maybe`类型将结果值包装在一个新对象中，PHP只在非严格相等的情况下执行内部值比较；上面定义的`add2`、`times10`和`composed`函数预期在范围内。
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Great, our `Maybe` type implementation is a valid functor.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们的`Maybe`类型实现是一个有效的函数器。
- en: Identity functor
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份函数器
- en: 'As we discussed in the section about the identity function, an identity functor
    also exists. It acts as a really simple functor that does nothing to the value
    besides holding it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在关于身份函数的部分讨论的那样，还存在一个身份函数器。它充当一个非常简单的函数器，除了保存值之外不对值进行任何操作：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As with the identity function, the use for such a functor is not immediately
    evident. However, the idea is the same-you can use it when you have some function
    having a functor as a parameter, but you don't want to modify your actual value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与身份函数一样，这种函数器的用途并不立即明显。然而，思想是一样的-当您有一个函数以函数器作为参数时，您可以使用它，但不想修改您的实际值。
- en: This should begin to make more sense in the following chapters of this book.
    In the meantime, we will use the identity functor to explain some more advanced
    concepts.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在本书的后续章节中变得更加清晰。与此同时，我们将使用身份函数器来解释一些更高级的概念。
- en: Closing words
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束语
- en: Let me reiterate again that functors are a really simple abstraction to understand,
    but also a really powerful one. We've seen only two of them, but an infinity of
    data structures that can be transformed to functors really easily.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我再次重申，函数器是一个非常简单的抽象概念，但也是一个非常强大的概念。我们只看到了其中两个，但有无数的数据结构可以非常容易地转换为函数器。
- en: Any function or class that allows you to map a given function to one or more
    values held in a context can be considered a functor. Identity functors or arrays
    are simple example of such a context; other examples would be the `Maybe` and
    `Either` types we discussed earlier or any class having a `map` method that allows
    you to apply a function to the contained valued.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 任何允许您将给定函数映射到上下文中保存的一个或多个值的函数或类都可以被视为函数器。身份函数器或数组是这种上下文的简单示例；其他示例包括我们之前讨论过的`Maybe`和`Either`类型，或者任何具有`map`方法的类，该方法允许您将函数应用于包含的值。
- en: I cannot encourage you enough to try implementing this map pattern and verify
    whether both laws hold wherever you create a new class or data structure. This
    will allow you to have an easier understanding of what your code can perform and
    you will be able to perform optimization using composition with the guarantee
    that your refactoring is correct.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法鼓励您足够尝试实现这种映射模式，并验证无论您创建一个新的类或数据结构，这两个定律是否成立。这将使您更容易理解您的代码可以执行什么，并且您将能够使用组合进行优化，并保证您的重构是正确的。
- en: Applicative functors
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用函数器
- en: 'Let''s take an instance of our identity functor, holding some integer and a
    curryied version of an `add` function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿一个我们的身份函数器的实例，保存一些整数和一个柯里化版本的`add`函数：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, what happens when we try to map the `$add` parameter on our functor? Consider
    the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们尝试在我们的函数器上映射`$add`参数时会发生什么？考虑以下代码：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you may have guessed, our functor now contains a closure representing a partially
    applied `add` parameter with the value `5` as the first parameter. You can use
    the `get` method to retrieve the function and use it, but it is not really that
    useful.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，我们的函数器现在包含一个闭包，代表一个部分应用的`add`参数，其值为`5`作为第一个参数。您可以使用`get`方法检索函数并使用它，但实际上并不是很有用。
- en: 'Another possibility would be to map another function, taking our function as
    a parameter, and doing something with it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是映射另一个函数，以我们的函数作为参数，并对其进行操作：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: But I imagine we can all agree that this is not a really effective way to perform
    such an operation. What would be great is to be able to simply pass the value
    `10` or maybe another functor to `$hum` and achieve the same result.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但我想我们都会同意，这并不是执行这样的操作的一种非常有效的方式。更好的方法是能够简单地将值`10`或者另一个函数器传递给`$hum`并获得相同的结果。
- en: Enters the applicative functor. As the name suggests, the idea is to apply functors.
    More precisely, to apply functors to other functors. In our case, we could apply
    `$hum`, which is a functor containing a function, to another functor containing
    the value `10` and obtain the value `15` we are after.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 进入应用函数器。顾名思义，这个想法是应用函数器。更准确地说，是将函数器应用于其他函数器。在我们的情况下，我们可以将包含函数的函数器`$hum`应用于另一个包含值`10`的函数器，并获得我们想要的值`15`。
- en: 'Let''s create an extended version of our `IdentityFunctor` class to test our
    idea:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个扩展版本的`IdentityFunctor`类来测试我们的想法：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can even create your `Applicative` class containing only your function
    and apply the values afterwards:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以创建一个只包含函数的`Applicative`类，并在之后应用这些值：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The applicative abstraction
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用抽象
- en: We are now able to use our `IdentifyFunctor` class as a curryied function holder.
    What if we could abstract this idea away and create something on top of the `Functor`
    class?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够使用我们的`IdentifyFunctor`类作为柯里化函数的持有者。如果我们能够将这个想法抽象出来，并在`Functor`类的基础上创建一些东西会怎样？
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, we created a new abstract class instead of an interface. The
    reason is because we can implement the `map` function using the `pure` and `apply`
    methods so it makes no sense to force everyone wanting to create an `Applicative` class
    to implement it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们创建了一个新的抽象类而不是一个接口。原因是因为我们可以使用`pure`和`apply`方法来实现`map`函数，所以强制每个想要创建`Applicative`类的人都要实现它是没有意义的。
- en: The `pure` function is called so because anything stored inside an `Applicative`class
    is considered pure as there is no way to modify it directly. The term is taken
    from the Haskell implementation. Other implementations sometimes use the name
    *unit* instead. pure is used to create a new applicative from any `callable`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`pure`函数之所以被称为如此，是因为`Applicative`类中存储的任何东西都被认为是纯的，因为没有办法直接修改它。这个术语来自Haskell实现。其他实现有时使用名称*unit*。pure用于从任何`callable`创建一个新的applicative。'
- en: The `apply` function applies the stored function to the given parameter. The
    parameter must be of the same type so that the implementation knows how to access
    the inner value. Sadly, the PHP type system does not allow us to enforce this
    rule and we must resign ourselves to defaulting to `Applicative`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`函数将存储的函数应用于给定的参数。参数必须是相同类型的，以便实现知道如何访问内部值。遗憾的是，PHP类型系统不允许我们强制执行这个规则，我们必须默认为`Applicative`。'
- en: We have the same issue for the definition of map that has to keep the return
    type as `Functor`. We need to do this as the PHP type engine does not support
    a feature called **return type covariance**. If it did, we could specify a more
    specialized type (that is a child type) as a return value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对map的定义也有同样的问题，必须将返回类型保持为`Functor`。我们需要这样做，因为PHP类型引擎不支持一种称为**返回类型协变**的特性。如果支持的话，我们可以指定一个更专门的类型（即子类型）作为返回值。
- en: The `map` function is implemented using the aforementioned functions. First
    we encapsulate our `callable` using the `pure` method and we apply this new applicative
    on the actual value. Nothing really fancy.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`函数是使用上述函数实现的。首先我们使用`pure`方法封装我们的`callable`，然后将这个新的applicative应用于实际值。没有什么特别的。'
- en: 'Let''s test our implementation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试我们的实现：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Everything seems to work fine. We were even able to verify that our map implementation
    seems to be correct.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一切似乎都运行正常。我们甚至能够验证我们的map实现似乎是正确的。
- en: 'As with the functor, we can create the simplest of the `Applicative` class
    abstraction:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与functor一样，我们可以创建最简单的`Applicative`类抽象：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Applicative laws
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Applicative法则
- en: The first important property of applicative is that they are *closed under composition*,
    meaning an applicative will return a new applicative of the same type. Also, the
    apply method takes an applicative of its own type. We cannot enforce this using
    the PHP type system, so you will need to be careful otherwise something might
    break at some point.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: applicative的第一个重要属性是它们是*封闭的组合*，意味着applicative将返回相同类型的新applicative。此外，apply方法接受自己类型的applicative。我们无法使用PHP类型系统来强制执行这一点，所以你需要小心，否则可能会在某个时候出现问题。
- en: The following rules also need to be respected to have a proper applicative functor.
    We will first present them all in detail and then verify that they hold for our
    `IdentityApplicative` class later.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要遵守以下规则才能拥有一个正确的applicative functor。我们将首先详细介绍它们，然后稍后验证它们对我们的`IdentityApplicative`类是否成立。
- en: Map
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射
- en: '*pure(f)->apply == map(f)*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*纯（f）->应用 == map（f）*'
- en: Applying a function using an applicatives is the same as mapping this function
    over. This law simply tells us that we can use an applicative anywhere we used
    a functor before. We lose no power by switching to an applicative.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用applicative应用函数与对其进行映射是相同的。这个法则简单地告诉我们，我们可以在以前使用functor的任何地方使用applicative。切换到applicative不会使我们失去任何权力。
- en: In fact, this is not really a law as it can be inferred from the following four
    laws. But as it is not at all evident, and in order to make things clearer, let's
    state it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这并不是一个法则，因为它可以从以下四个法则中推导出来。但由于这并不明显，为了让事情更清晰，让我们来陈述一下。
- en: Identity
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 身份
- en: '*pure(id)->apply($x) == id($x)*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*纯（id）->应用（$x）== id（$x）*'
- en: Applying the identity function results in no change to the value. As with the
    identity law for functors, this ensure that the `apply` method does nothing but
    apply the function. No hidden transformation is happening behind our backs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 应用恒等函数不会改变值。与functor的身份法则一样，这确保`apply`方法除了应用函数之外不会发生任何隐藏的转换。
- en: Homomorphism
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同态
- en: '*pure(f)->apply($x) == pure(f($x))*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*纯（f）->应用（$x）==纯（f（$x））*'
- en: Creating an applicative functor and applying it to a value has the same effect
    as first calling the function on the value and boxing it inside the functor afterwards.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个applicative functor并将其应用于一个值与首先在值上调用函数，然后在functor中封装它具有相同的效果。
- en: This is an important law because our first motivation to dive into applicative
    is usage of the curryied function instead of unary functions. This law ensures
    that we can create our applicative at any stage instead of needing to box our
    function right away.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的法则，因为我们深入研究applicative的第一个动机是使用柯里化函数而不是一元函数。这个法则确保我们可以在任何阶段创建我们的applicative，而不需要立即封装我们的函数。
- en: Interchange
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交换
- en: '*pure(f)->apply($x) == pure(function($f) { $f($x); })->apply(f)*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*纯（f）->应用（$x）==纯（function（$f）{ $f（$x）; }）->应用（f）*'
- en: This one is a bit tricky. It states that applying a function on a value is the
    same as creating an applicative functor with a lifted value and applying it to
    the function. In this case, a lifted value is a closure around the value that
    will call the given function on it. The law guarantees that the pure function
    performs no modification besides boxing the given value.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有点棘手。它声明对值应用函数与创建一个提升值的applicative functor并将其应用于函数是相同的。在这种情况下，提升值是围绕该值的闭包，它将在其上调用给定的函数。该法则确保纯函数除了封装给定值之外不执行任何修改。
- en: Composition
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合
- en: '*pure(compose)->apply(f1)->apply(f2)->apply($x) == pure(f1)->apply(pure(f2)->apply($x))*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*纯（组合）->应用（f1）->应用（f2）->应用（$x）==纯（f1）->应用（纯（f2）->应用（$x））*'
- en: A simpler version of this law could be written with *pure(compose(f1, f2))->apply($x)*
    on the left-hand side. It simply states, as the composition law for functors,
    that you can apply a composed version of two functions to your value or call them
    separately. This ensures that you can perform the same optimizations for functors.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种法律的简化版本可以用*pure(compose(f1, f2))->apply($x)*来写在左边。它简单地陈述了functors的组合法则，即你可以将两个函数的组合版本应用到你的值上，或者分别调用它们。这确保你可以对functors执行相同的优化。
- en: Verifying that the laws hold
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证法律是否成立
- en: 'As we saw for functors, it is more than recommended to test whether your implementations
    hold for all laws. This can be a really tedious process, especially if you have
    four of them. So instead of performing the check manually, let''s write a helper:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们对functors所看到的，强烈建议测试你的实现是否符合所有法律。这可能是一个非常乏味的过程，特别是如果你有四个。因此，我们不要手动执行检查，让我们写一个辅助程序：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `identity` and `compose` functions are declared inside the helper so that
    it is completely self-contained and you can use it in a variety of situations.
    Also the `compose` function from the `functional-php` library is not adapted as
    it is not curryied and it takes a variable number of arguments.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`identity`和`compose`函数在辅助程序中声明，因此它是完全自包含的，你可以在各种情况下使用它。此外，`functional-php`库中的`compose`函数不适用，因为它不是柯里化的，它接受可变数量的参数。'
- en: Also, in order to avoid having a lot of arguments, we take an instance of the
    `Applicative`class so we can have a first function and the type to check and then
    a `callable` and a value that will be lifted to the applicative and used whenever
    necessary.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了避免有很多争论，我们使用`Applicative`类的一个实例，这样我们就可以有一个第一个函数和要检查的类型，然后是一个`callable`和一个将被提升到applicative并在必要时使用的值。
- en: This choice limits the functions we can use as the value must match the type
    of the parameter for both functions; the first function must also return a parameter
    of the same type. If this is too constraining for you, you can decide to extend
    the helper to take two more arguments, a second applicative and a lifted value,
    and use those when necessary.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这种选择限制了我们可以使用的函数，因为值必须与两个函数的参数类型匹配；第一个函数还必须返回相同类型的参数。如果这对你来说太过约束，你可以决定扩展辅助程序，以接受另外两个参数，第二个applicative和一个提升的值，并在必要时使用它们。
- en: 'Let''s verify our `IdentityApplicative` class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证我们的`IdentityApplicative`类：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Great, everything seems to be fine. If you want to use this helper, you need
    to choose functions that are compatible as you might encounter some error messages
    that lack clarity as we cannot ensure that the type of the return value for the
    first function matches the type of the first parameter for the second function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，一切似乎都很好。如果你想使用这个辅助程序，你需要选择兼容的函数，因为你可能会遇到一些缺乏清晰度的错误消息，因为我们无法确保第一个函数的返回值类型与第二个函数的第一个参数类型匹配。
- en: 'Since this kind of automatic checking can greatly help, let us quickly write
    the same kind of function for functors:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种自动检查可以极大地帮助，让我们迅速地为functors编写相同类型的函数：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And check our never tested `IdentityFunctor` with it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 并检查我们从未测试过的`IdentityFunctor`：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Good, everything is fine.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，一切都很好。
- en: Using applicatives
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用applicatives
- en: 'As we already saw, arrays are functors, because they have a `map` function.
    But a collection can also easily be an applicative. Let''s implement a `CollectionApplicative`
    class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，数组是functors，因为它们有一个`map`函数。但是一个集合也很容易成为applicative。让我们实现一个`CollectionApplicative`类：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, this is all fairly easy. To simplify our life we just wrap
    anything that is not a collection inside an array and we transform instances of
    the `Traversable` interface to a real array. This code would obviously need some
    improvement to be used in production, but it will suffice for our little demonstration:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这一切都相当容易。为了简化我们的生活，我们只需将不是集合的任何东西包装在一个数组中，并将`Traversable`接口的实例转换为真正的数组。这段代码显然需要一些改进才能用于生产，但对于我们的小演示来说已经足够了：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: What is happening here? We have a list of functions in our applicative and we
    apply that to a list of numbers. The result is a new list with each function applied
    to each number.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？我们的applicative中有一个函数列表，我们将其应用到一个数字列表。结果是一个新的列表，每个函数都应用到每个数字上。
- en: 'This small example is not really useful, but the idea can be applied to anything.
    Imagine you have some kind of image gallery application where the user can upload
    some images. You also have various  processing you want to make on those images:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小例子并不是真正有用的，但这个想法可以应用到任何事情上。想象一下，你有一种图库应用，用户可以上传一些图像。你还有各种处理你想对这些图像进行的处理：
- en: Limiting the size of the final image as the user tends to upload them too big
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制最终图像的大小，因为用户倾向于上传过大的图像
- en: Creating a thumbnail for the index page
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为索引页面创建一个缩略图
- en: Creating a small version for mobile devices
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为移动设备创建一个小版本
- en: 'The only thing you need to do is create an array of all your functions, an
    array of the uploaded images, and apply the same pattern we just did to our numbers.
    You can then use the group function from the `functional-php` library to regroup
    your images together:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你唯一需要做的就是创建一个包含所有函数的数组，一个包含上传图像的数组，并将我们刚刚对数字做的相同模式应用到它们。然后你可以使用`functional-php`库中的group函数将你的图像重新分组在一起：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We use the index in the transformed array to regroup the images together. Every
    third image is the limited one, every fourth the thumbnail, and finally we have
    the mobile version. The result can be seen as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用转换后的数组中的索引来将图像重新分组。每三个图像是限制的，每四个是缩略图，最后是移动版本。结果如下所示：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You might be hungry for more at this stage, but you will need to be patient.
    Let's finish first with the theory in this chapter and we will soon see more potent
    examples in the next.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能会渴望更多，但你需要耐心。让我们先完成本章的理论，我们很快就会在下一章看到更有力的例子。
- en: Monoids
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单子
- en: Now that we have an understanding of applicative functors, we need to add one
    last piece to the puzzle before speaking about monads, the monoid. Once again,
    the concept is taken from the mathematical field of category theory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对应用函子有了一定的了解，在谈论单子之前，我们需要在这个谜题中增加最后一块，即单子。再次，这个概念来自范畴论的数学领域。
- en: 'A **monoid** is a combination of any type and a binary operation on this type
    with an associated identity element. For example, here are some combinations that
    you probably never expected were monoids:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**单子**是任何类型和该类型上的二元操作的组合，具有关联的身份元素。例如，以下是一些组合，您可能从未预料到它们是单子：'
- en: Integer number and the addition operation, the identity being 0 because*$i +
    0 == $i*
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数和加法操作，其身份是0，因为*$i + 0 == $i*
- en: Integer number and the multiplication operation, the identity being 1 because*$i
    * 1 == $i*
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数和乘法操作，其身份是1，因为*$i * 1 == $i*
- en: Arrays and the merge operation, the identity being the empty array because *array_merge($a,
    []) == $a*
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和合并操作，其身份是空数组，因为*array_merge($a, []) == $a*
- en: String and the concatenate operation, the identity being the empty string because
    *$s . '' == $s*
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串和连接操作，其身份是空字符串，因为*$s . '' == $s*
- en: For the remainder of the chapter, let's call our operation *op* and the identity
    element *id*. The `op`call comes from operation or operator and is used in some
    `Monoid` implementation across multiple languages. Haskell uses the terms **mempty**
    and **mappend** to avoid clashes with other function names. Sometimes zero is
    used instead of *id* or identity.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，让我们称我们的操作为*op*，身份元素为*id*。`op`调用来自操作或操作员，并在多种语言的`Monoid`实现中使用。Haskell使用术语**mempty**和**mappend**以避免与其他函数名称冲突。有时使用零代替*id*或身份。
- en: A monoid must also respect a certain number of laws, two to be precise.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 单子还必须遵守一定数量的法则，确切地说是两个。
- en: Identity law
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份法则
- en: '*$a op id == id op $a == $a*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*$a op id == id op $a == $a*'
- en: The first law ensures that the identity can be used on both sides of the operator.
    An identity element can work only when applied as the right-hand or left-hand
    side of the operator. This is, for example, the case for operations on matrices.
    In this case, we speak of left and right identity elements. In the case of a `Monoid`,
    we need a two-sided identity, or simply identity.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个法则确保了身份可以在操作符的两侧使用。身份元素只有在作为操作符的右手或左手侧应用时才能起作用。例如，对矩阵的操作就是这种情况。在这种情况下，我们谈论左和右身份元素。在`Monoid`的情况下，我们需要一个双侧身份，或者简单地说是身份。
- en: As for most identity laws, verifying it for a `Monoid` implementation ensures
    that we correctly apply the operator with no other side-effects.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数身份法则，验证`Monoid`实现可以确保我们正确应用操作符而没有其他副作用。
- en: Associativity law
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合律
- en: '*($a op $b) op $c == $a op ($b op $c)*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*($a op $b) op $c == $a op ($b op $c)*'
- en: This law guarantees that we can regroup our call to the operator in any order
    we want, as long as some other operations are not interleaved. This is important
    because it allows us to reason about possible optimization with the insurance
    that the result will be the same.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这项法律保证了我们可以按任何顺序重新组合我们对操作员的呼叫，只要其他一些操作没有交错。这很重要，因为它允许我们推理可能的优化，并确保结果是相同的。
- en: Knowing that a sequence of operations is associative; you can also separate
    the sequence into multiple parts, distribute the computation across multiple threads,
    cores, or computers, and when all the intermediary results come in, apply the
    operation between them to get the final result.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 知道一系列操作是可结合的；您还可以将序列分成多个部分，将计算分布到多个线程、核心或计算机上，当所有中间结果出现时，将它们之间的操作应用以获得最终结果。
- en: Verifying that the laws hold
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证法则
- en: 'Let''s verify those laws for the monoids we spoke about earlier. First, the
    integer addition:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证一下我们之前谈到的单子的法则。首先是整数加法：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, the integer multiplication:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，整数乘法：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then the array merge as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后数组合并如下：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And finally, the string concatenation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，字符串连接：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Great, all our monoids respect both laws.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们所有的单子都遵守这两个法则。
- en: What about subtraction or division? Are they also a monoid? It's pretty obvious
    that 0 is the identity of subtraction and 1 is the identity for division, but
    what about associativity?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 减法或除法呢？它们也是单子吗？很明显，0是减法的身份，1是除法的身份，但结合性呢？
- en: 'Consider the following for checking the associativity of subtraction or division:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下检查减法或除法的结合性：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We clearly see that neither subtraction nor division is associative. When working
    with such abstraction, it is always important to test our assumption using the
    law. Otherwise a refactoring or calling some function expecting a `Monoid` could
    go really wrong. Obviously, the same applies for functors and applicatives.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们清楚地看到，减法和除法都不是可结合的。在处理这种抽象时，始终重要的是使用法则来测试我们的假设。否则，重构或调用某个期望`Monoid`的函数可能会出现严重问题。显然，对于函子和应用函子也是如此。
- en: What are monoids useful for?
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单子有什么用？
- en: Honestly, monoids themselves are not really useful, especially in PHP. Eventually,
    in a language where you can either declare new operators or redefine existing
    ones, you could ensure their associativity and the existence of an identity using
    monoids. But even so, there would be no real advantages.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，单子本身并不是真正有用的，特别是在PHP中。最终，在一种语言中，您可以声明新的操作符或重新定义现有的操作符，您可以确保它们的结合性和存在单子。但即使如此，也没有真正的优势。
- en: Also, if the language could automatically distribute work done with operators
    that are part of a `Monoid`, it would be a great way to speed up lengthy computation.
    But I am not aware of any language, even academic ones, that are currently capable
    of doing so. Some languages perform operation reordering to improve efficiency,
    but that's about it. Obviously, PHP can't do any of that since the concept of
    monoid is not in the core.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果语言可以自动分配使用`Monoid`的运算，那将是加快漫长计算的一个很好的方法。但我不知道任何语言，即使是学术语言，目前都能做到这一点。一些语言执行操作重新排序以提高效率，但仅此而已。显然，PHP不能做任何这些，因为幺半群的概念不在核心中。
- en: Why bother then? Because monoids can be used with higher-order functions and
    some constructs that we will discover later can take full advantage of their laws.
    Also, since PHP does not allow us to use existing operators as functions, as is
    the case with Haskell, for example, we've had to define functions such as `add`
    before. Instead, we can define a `Monoid` class. It would have the same utility
    as our simple function with some nice properties added.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么要费心呢？因为幺半群可以与高阶函数和一些我们将在后面发现的构造一起使用，以充分利用它们的法律。此外，由于PHP不允许我们像Haskell那样使用现有的运算符作为函数，例如，我们之前不得不定义`add`之类的函数。相反，我们可以定义一个`Monoid`类。它将具有与我们的简单函数相同的效用，并添加一些很好的属性。
- en: At the risk of sounding like a broken record, explicitly stating that an operation
    is a monoid reduces cognitive burden. When using a monoid, you have the assurance
    that the operation is associative and that it respects a two-sided identity.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 冒昧地说，明确声明一个操作是幺半群可以减轻认知负担。使用幺半群时，您可以确保操作是可结合的，并且遵守双边单位。
- en: A monoid implementation
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个幺半群的实现
- en: PHP does not support generics, so we have no way to encode the type information
    of our `Monoid` formally. You will have to choose a self-explanatory name or document
    that is the type clearly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: PHP不支持泛型，因此我们无法正式地编码我们的`Monoid`的类型信息。您将不得不选择一个不言自明的名称或者清楚地记录这是什么类型。
- en: 'Also, as we want our implementation to replace functions such as `add`, we
    need some additional methods on our class to allow for this usage. Let''s see
    what we can do:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，由于我们希望我们的实现能够替换诸如`add`之类的函数，我们需要在我们的类上添加一些额外的方法来允许这种用法。让我们看看我们能做些什么：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Obviously, we have our `id` and `op` functions declared abstract as those will
    be the specific parts for each of our monoids.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们的`id`和`op`函数声明为抽象，因为它们将是我们每个幺半群的特定部分。
- en: One of the main advantages of having a `Monoid` is easily being able to fold
    a collection of values having the type of the `Monoid` class. This is why we create
    the `concat` method as a helper to do exactly that.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有`Monoid`的一个主要优势是可以轻松地折叠具有`Monoid`类类型的值的集合。这就是为什么我们创建`concat`方法作为一个辅助方法来做到这一点。
- en: Finally, we have an `__invoke` function so that our `Monoid` can be used like
    a normal function. The function is curryied in a specific way. If you pass more
    than one parameter on the first call, the `concat` method will be used to return
    a result immediately. Otherwise, with exactly one parameter, you will get a new
    function waiting for a second parameter.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个`__invoke`函数，以便我们的`Monoid`可以像普通函数一样使用。该函数以一种特定的方式进行柯里化。如果您在第一次调用时传递了多个参数，`concat`方法将被用于立即返回结果。否则，只有一个参数，您将得到一个等待第二个参数的新函数。
- en: 'Since we are at it, let''s write a function to check the laws:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在这里，让我们编写一个检查法律的函数：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our first monoids
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个幺半群
- en: 'Let''s create monoids for the cases we''ve seen previously and demonstrate
    how we can use them:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们之前看到的情况创建幺半群，并演示我们如何使用它们：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s validate the laws on them:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证它们的法律：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For the example, let''s try to create a monoid for subtraction and check the
    laws:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们尝试创建一个减法的幺半群并检查法律：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As expected, the associativity laws fail. We also have an issue with the left
    identity because of *0 - $a == -$a*. So let's not forget to test our monoids regarding
    the laws to ensure that they are correct.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，结合律失败了。我们还有一个左单位的问题，因为 *0 - $a == -$a*。所以让我们不要忘记测试我们的幺半群，以确保它们是正确的。
- en: 'Two interesting monoids can be created regarding the Boolean type:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 关于布尔类型，可以创建两个有趣的幺半群：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'These two monoids allow us to verify whether at least one or all conditions
    are met. These are the monoidic versions of the every and some functions in the
    `functional-php` library. These two monoids serve the same purpose as the sum
    and product ones since PHP does not allow us to use Boolean operators as functions:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个幺半群使我们能够验证是否至少满足一个条件或所有条件。这些是`functional-php`库中`every`和`some`函数的幺半群版本。这两个幺半群与求和和乘积的作用相同，因为PHP不允许我们将布尔运算符用作函数：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: They can prove useful when you need to create a series of conditions programmatically.
    Instead of iterating over all of them to generate results, just feed them to the
    `Monoid`. You can also write a *none* monoid as an exercise to see if you understood
    the concept well.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要以编程方式创建一系列条件时，它们可能会很有用。只需将它们提供给`Monoid`，而不是迭代所有条件来生成结果。您还可以编写一个*none*幺半群作为练习，以查看您是否理解了这个概念。
- en: Using monoids
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用幺半群
- en: 'One of the most obvious ways to use our new monoids is to fold a collection
    of values:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的新幺半群最明显的方法之一是折叠一组值：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This property is so interesting that most functional programming languages implement
    the idea of a `Foldable` type. Such a type needs to have an associated monoid.
    With the help of the property we have just seen, the type can then be easily folded.
    However, the idea is difficult to port to PHP as we will miss the syntactic sugar
    needed to improve over using the `concat` method like we just did.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性非常有趣，以至于大多数函数式编程语言都实现了`Foldable`类型的想法。这样的类型需要有一个关联的幺半群。借助我们刚刚看到的属性，该类型可以很容易地折叠。然而，将这个想法移植到PHP是困难的，因为我们将缺少改进使用`concat`方法所需的语法糖。
- en: 'You can also use them as the `callable` type and pass them to higher order
    functions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将它们用作`callable`类型，并将它们传递给高阶函数：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Obviously, this is not limited to the compose function. You could rewrite all
    of the previous examples from this book that used an `add` function and use our
    new `Monoid` instead.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这不仅限于compose函数。您可以重写本书中使用`add`函数的所有先前示例，并使用我们的新`Monoid`代替。
- en: As we progress in this book, we will see more ways to use monoids associated
    with functional techniques that we have yet to discover.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本书中的进展，我们将看到更多与我们尚未发现的功能技术相关联的单子的使用方式。
- en: Monads
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单子
- en: We started learning about functors, which are a collection of values that can
    be mapped over. We then introduced the idea of applicative functors, which allow
    us to put those values in a certain context and apply functions to them while
    preserving the context. We also made a quick detour to talk about monoids and
    their properties.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始学习函子，它是一组可以映射的值。然后我们介绍了应用函子的概念，它允许我们将这些值放入特定的上下文并对它们应用函数，同时保留上下文。我们还快速讨论了幺半群及其属性。
- en: 'With all this prior knowledge, we are finally ready to start with the idea
    of monads. As James Iry humorously noted in *A Brief, Incomplete, and Mostly Wrong
    History of Programming Languages*:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些先前的知识，我们终于准备好开始单子的概念了。正如James Iry在*编程语言简史*中幽默地指出的那样：
- en: '*A monad is a monoid in the category of endofunctors, what''s the problem?*'
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*单子是自函子范畴中的幺半群，有什么问题吗？*'
- en: This fictional quote, attributed to Philip Wadler, one of the original people
    involved in the Haskell specification and a proponent of the use of monads, can
    be found in context at [http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html](http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这句虚构的引语归功于Philip Wadler，他是Haskell规范的最初参与者之一，也是单子使用的倡导者，可以在[http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html](http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html)找到其上下文。
- en: Without some knowledge of category theory, it would be hard to clearly explain
    what the quote is all about, especially since it is fictional and voluntarily
    vague enough to be funny. Suffice to say that monads are akin to monoids as they
    share roughly the same set of laws. Also, they are directly linked to the concept
    of functors and applicative.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有一些范畴论的知识，很难清楚地解释这句话到底是什么意思，特别是因为它是虚构的，故意模糊以至于有趣。可以说，单子类似于幺半群，因为它们大致共享相同的法则集。此外，它们直接与函子和应用相关联。
- en: 'A monad, like a functor, acts as some kind of container for a value. Also,
    like for applicative, you can apply functions to the encapsulated values. All
    three patterns are a way to put some data inside a context. However, there are
    a few differences between the two:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 单子，就像函子一样，充当某种值的容器。此外，就像应用程序一样，您可以将函数应用于封装的值。这三种模式都是将一些数据放入上下文的一种方式。但是，两者之间有一些区别：
- en: The applicative encapsulates a function. The monad, and the functor, encapsulate
    a value.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用封装了一个函数。单子和函子封装了一个值。
- en: The applicative uses functions that return non-lifted values. The monad uses
    functions that return a monad of the same type.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序使用返回非提升值的函数。单子使用返回相同类型的单子的函数。
- en: 'As functions are also valid values, this doesn''t mean both are incompatible,
    it only means we will need to define a new API for our monad type. However, we
    can freely extend Applicative as it contains totally valid methods in a monadic
    context:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数也是有效值，这并不意味着两者不兼容，只是意味着我们需要为我们的单子类型定义一个新的API。但是，我们可以自由地扩展Applicative，因为它在单子上下文中包含完全有效的方法：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Our implementation is pretty simple. We alias pure with return as Haskell uses
    this term in monads so that people don't get lost. Be aware that it has nothing
    to do with the return keyword you are accustomed to; it's really just to put the
    value inside the context of the monad. We also define a new bind function that
    takes a `callable` type as parameter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现非常简单。我们将pure与Haskell中的return别名，这样人们就不会迷失。请注意，它与您习惯的return关键字无关；它只是将值放入单子的上下文中。我们还定义了一个新的绑定函数，它以`callable`类型作为参数。
- en: 'As we don''t know how the internal value will be stored and because of the
    limitations of the PHP type system, we cannot implement neither the `apply` nor
    the `bind` function although they should be pretty similar:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不知道内部值将如何存储，并且由于PHP类型系统的限制，我们无法实现`apply`或`bind`函数，尽管它们应该是非常相似的：
- en: The `apply`method takes a value wrapped in the `Applicative` class and applies
    the stored function to it
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply`方法接受一个包装在`Applicative`类中的值，并将存储的函数应用于它'
- en: The `bind` method takes a function and applies it to the stored value
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bind`方法接受一个函数并将其应用于存储的值'
- en: The difference between the two is that the `bind`method needs to return the
    value directly, whereas the `apply` method first wraps the value again using the
    `pure` or `return` functions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的区别在于`bind`方法需要直接返回值，而`apply`方法首先再次使用`pure`或`return`函数包装值。
- en: As you may have come to understand, people using different languages tend to
    name things a bit differently. This is why you will sometimes see the `bind` method
    called **chain** or **flatMap**, depending on the implementation that you are
    looking at.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经了解的那样，使用不同语言的人倾向于以稍有不同的方式命名事物。这就是为什么有时您会看到`bind`方法被称为**chain**或**flatMap**，这取决于您正在查看的实现。
- en: Monad laws
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单子定律
- en: You know the drill by now; there are also some laws a monad must respect to
    be called a monad. The laws are the same as for a monoid-identity and associativity.
    So all the same useful properties of a monoid are also true for a monad.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道了；单子必须遵守一些法则才能被称为单子。这些法则与幺半群的法则相同-单位元和结合律。因此，单子的所有有用属性也适用于单子。
- en: However, as you will see, the laws we will describe seem to have nothing in
    common with the identity and associativity laws we've seen for monoids. This is
    linked to the way we defined the `bind` and `return` functions. Using something
    called the **Kleisli** composition operator we can transform the laws so that
    they read a bit like the ones we saw before. However, this is a bit complicated
    and not at all useful for our purpose. If you want to read more about it, I can
    direct you to [https://wiki.haskell.org/Monad_laws](https://wiki.haskell.org/Monad_laws).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你将看到的，我们将描述的法则似乎与我们之前为单子看到的幂等性和结合性法则没有任何共同之处。这与我们定义的`bind`和`return`函数的方式有关。使用一种叫做**Kleisli**组合操作符，我们可以转换这些法则，使它们看起来有点像我们之前看到的那些。然而，这有点复杂，对我们的目的毫无用处。如果你想了解更多，我可以引导你到[https://wiki.haskell.org/Monad_laws](https://wiki.haskell.org/Monad_laws)。
- en: Left identity
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 左单位元
- en: '*return(x)->bind(f) == f(x)*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*return(x)->bind(f) == f(x)*'
- en: The law states that, if you take a value, wrap it in the context of the monad,
    and bind it to *f*, the result has to be the same as if you call the function
    directly on the value. It ensures that the `bind` method has no side effects on
    the function and the value besides applying it.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个法则规定，如果你取一个值，将其包装在单子的上下文中，并将其绑定到*f*，结果必须与直接在值上调用函数的结果相同。它确保`bind`方法对函数和值除了应用之外没有任何副作用。
- en: This can only be true because, contrary to the `apply` method, the `bind`method
    does not wrap the return value of the function inside the monad again. This is
    the work of the function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这只有在`bind`方法不像`apply`方法那样再次将函数的返回值包装在单子内时才成立。这是函数的工作。
- en: Right identity
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 右单位元
- en: '*m->bind(return) == m*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*m->bind(return) == m*'
- en: This law states that, if you bind the returned value to a monad, you will get
    your monad back. It ensures that return has no effect than putting the value inside
    the context of the monad.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个法则规定，如果你将返回的值绑定到一个单子，你将得到你的单子。它确保`return`除了将值放入单子的上下文之外没有其他影响。
- en: Associativity
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结合性
- en: '*m->bind(f)->bind(g) == m->bind((function($x) { f($x)->bind(g); })*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*m->bind(f)->bind(g) == m->bind((function($x) { f($x)->bind(g); })*'
- en: This laws states that you can either bind the value inside the monad first to
    *f* then to *g* or you can bind it to the composition of the first function with
    the second. We need an intermediary function to simulate this like we needed one
    in the interchange law for applicatives.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这些法则规定，你可以先将单子内的值绑定到*f*，然后再绑定到*g*，或者你可以将其绑定到第一个函数与第二个函数的组合。我们需要一个中间函数来模拟这一点，就像我们在applicatives的交换法则中需要一个中间函数一样。
- en: This law allows us the same benefits as previous associative and composition
    laws. The form is a bit strange because the monad holds the value and not the
    function or operator.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个法则允许我们获得与之前的结合性和组合性法则相同的好处。这种形式有点奇怪，因为单子保存的是值，而不是函数或操作符。
- en: Validating our monads
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证我们的单子
- en: 'Let''s write a function to check a monad validity:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个函数来检查单子的有效性：
- en: '[PRE38]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We also need an identity monad:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个单位单子：
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And we can finally verify that everything holds:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后我们可以验证一切是否成立：
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Why monads?
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要使用单子？
- en: The first reason is a practical one. When you apply a function using an applicative,
    the result is automatically put inside the context of the applicative. This means
    that, if you have a function returning an applicative and you apply it, the result
    will be an applicative inside an applicative. Anyone who has seen the film *Inception*
    knows it is not always a great idea to put something, inside something, inside
    something.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个原因是实际的。当你使用applicative应用一个函数时，结果会自动放入applicative的上下文中。这意味着，如果你有一个返回applicative的函数，并应用它，结果将是一个applicative内部的applicative。任何看过电影《盗梦空间》的人都知道，把东西放在东西里面并不总是一个好主意。
- en: Monads are a way to avoid this unnecessary nesting. The `bind` function delegates
    the task of encapsulating the return value to the function, meaning you will only
    have one level of depth.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 单子是一种避免这种不必要嵌套的方式。`bind`函数将封装返回值的任务委托给函数，这意味着你只会有一层深度。
- en: Monads are also a way to perform flow control. As we've seen, functional programmers
    tend to avoid using loops or any other kind of control flow, such as the `if`
    conditions that make your code harder to reason upon. Monads are a powerful way
    to sequence transformation in a really expressive way while keeping your code
    clean.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 单子也是一种执行流程控制的方式。正如我们所见，函数式程序员倾向于避免使用循环或任何其他类型的控制流，比如使你的代码更难以理解的`if`条件。单子是一种强大的方式，以一种非常表达性的方式来顺序转换，同时保持你的代码整洁。
- en: Languages such as Haskell also have specific syntactic sugar to work with monads,
    such as the `do` notation, which makes your code even easier to read. Some people
    have tried implementing such a thing in PHP without much success in my opinion.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 像Haskell这样的语言还有特定的语法糖来处理单子，比如`do`符号，这使得你的代码更容易阅读。一些人尝试在PHP中实现这样的东西，但在我看来并没有取得太大的成功。
- en: However, to truly understand the power of the monad abstraction you have to
    look at some specific implementations, as we will do in the next chapter. They
    will allow us to perform *IO* operation in a purely functional way, pass log messages
    from one function to another, and even compute random numbers with a pure function.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要真正理解单子抽象的力量，你必须看一些具体的实现，就像我们将在下一章中所做的那样。它们将允许我们以纯函数的方式执行*IO*操作，将日志消息从一个函数传递到另一个函数，甚至使用纯函数计算随机数。
- en: Another take on monads
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于单子的另一种看法
- en: We decided to implement our `Monad` class leaving both the `apply` and `bind`
    methods abstract. We had no other choice as the way the value is stored inside
    the `Monad` class will only be decided in the `child` class.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定实现我们的`Monad`类，将`apply`和`bind`方法都留为抽象的。我们别无选择，因为值在`Monad`类内部的存储方式将只在`child`类中决定。
- en: However, as we already said, The `bind` method is sometimes called flatMap in
    Scala, for example. As the name implies, this is nothing but the combination of
    a map and a function called `flatten`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们已经说过的，`bind`方法有时在Scala中被称为flatMap。顾名思义，这只是map和一个叫做`flatten`的函数的组合。
- en: Do you get where I am going with this? Remember the issue with nested applicatives?
    We could add a `flatten` function, or join as Haskell calls it, method to our
    `Monad` class, and instead of having `bind` as an abstract method, we could implement
    it using `map` and our new method.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你明白我要说什么了吗？还记得嵌套应用的问题吗？我们可以添加一个`flatten`函数，或者像Haskell称呼的那样，将它作为`Monad`类的方法，而不是将`bind`作为一个抽象方法，我们可以使用`map`和我们的新方法来实现它。
- en: We will still have two methods to implement, but instead of both doing roughly
    the same job, calling a function with a value, one will continue to do that and
    the other one will be in charge of un-nesting the `Monad` instances.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要实现两种方法，但是两者不再做大致相同的工作，调用一个带有值的函数，一个将继续执行，另一个将负责解除`Monad`实例的嵌套。
- en: As such a function has only limited use for the outside world, I decided to
    go with the presented implementation. Doing it with the `flatten` function instead
    is a nice exercise that you can try to solve to get a better understanding of
    how monad works.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这样的函数对外部世界的用途有限，我决定使用所提供的实现。使用`flatten`函数进行实现是一个不错的练习，您可以尝试解决以更好地理解单子的工作原理。
- en: A quick monad example
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个快速的单子示例
- en: 'Imagine that we need to read the content of a file using the `read_file` function
    and then send it to a **webservice** using the post function. We will create two
    versions, as follows, of the upload function to do just that:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们需要使用`read_file`函数读取文件的内容，然后使用`post`函数将其发送到**webservice**。我们将创建两个版本的上传函数来实现这一点：
- en: The first version will use traditional functions, returning a Boolean `false`
    in case of an error.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个版本将使用传统函数，在出现错误的情况下返回布尔值`false`。
- en: The functional version will assume curryied functions returning an instance
    of the `Either` monad. We will describe this monad further in the next chapter;
    let's just assume it works like the `Either` type we already saw earlier.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能版本将假定返回`Either`单子实例的柯里化函数。我们将在下一章中进一步描述这个单子；让我们假设它的工作原理与我们之前看到的`Either`类型相同。
- en: 'In the case of success, the given callback must be called with the status code
    returned by the `post` method:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的情况下，必须调用给定的回调函数，并返回`post`方法返回的状态码：
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And now the functional version, as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是功能版本，如下所示：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: I don't know which one you prefer, but my choice is clear. The choice of using
    `Either` instead of `Maybe` is also not innocent. It means the functional version
    can also return a detailed error message instead of just `false` in case of error.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你更喜欢哪一个，但我的选择很明确。使用`Either`而不是`Maybe`的选择也不是无辜的。这意味着在出现错误的情况下，功能版本还可以返回详细的错误消息，而不仅仅是`false`。
- en: Further reading
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If after completing this chapter you still find yourself a bit lost, as this
    is such an important topic, don''t hesitate to read one of the following articles
    or some others you found yourself:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在完成本章后，您仍然感到有些迷茫，因为这是一个如此重要的话题，不要犹豫阅读以下文章或您自己找到的其他文章：
- en: A small introduction to monads in PHP also with a related library at [http://blog.ircmaxell.com/2013/07/taking-monads-to-oop-php.html](http://blog.ircmaxell.com/2013/07/taking-monads-to-oop-php.html).
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP中关于单子的简要介绍，还有一个相关的库，网址是[http://blog.ircmaxell.com/2013/07/taking-monads-to-oop-php.html](http://blog.ircmaxell.com/2013/07/taking-monads-to-oop-php.html)。
- en: A good introduction to Scala, which anyone who has written some Java should
    understand, at [https://medium.com/@sinisalouc/demystifying-the-monad-in-scala-cc716bb6f534](https://medium.com/@sinisalouc/demystifying-the-monad-in-scala-cc716bb6f534).
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala的一个很好的介绍，任何写过一些Java的人都应该能理解，网址是[https://medium.com/@sinisalouc/demystifying-the-monad-in-scala-cc716bb6f534](https://medium.com/@sinisalouc/demystifying-the-monad-in-scala-cc716bb6f534)。
- en: A video with a more mathematical approach at [https://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads](https://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads).
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更数学化的视频，网址是[https://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads](https://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads)。
- en: 'A humorous JavaScript tutorial on monads. You either love or hate the style.
    If you are fluent with JavaScript, I can only recommend you read the whole book:
    [https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch9.html](https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch9.html).'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个关于单子的幽默JavaScript教程。你可能会喜欢也可能会讨厌这种风格。如果你精通JavaScript，我只能建议你阅读整本书：[https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch9.html](https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch9.html)。
- en: A really complete, if somewhat difficult, introduction to monads. Some basic
    Haskell knowledge is needed to understand the explanations at [https://wiki.haskell.org/All_About_Monads](https://wiki.haskell.org/All_About_Monads).
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个关于单子的非常完整，尽管有些困难的介绍。需要一些基本的Haskell知识才能理解[https://wiki.haskell.org/All_About_Monads](https://wiki.haskell.org/All_About_Monads)中的解释。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was certainly a mouthful, but fear not, it was the last of its
    kind. From now on, we will tackle more practical topics with real-life applications.
    [Chapter 6](ch06.html "Chapter 6.  Real-Life Monads"), *Real life monads* will
    present some useful uses of the abstractions we just learned about.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章肯定是一个艰深的话题，但不要害怕，这是最后一个。从现在开始，我们将处理更多实际的主题和真实的应用。[第6章](ch06.html "第6章。真实的单子")，“真实的单子”将介绍我们刚刚学到的抽象的一些有用用途。
- en: Abstractions, such as functors, applicative, and monads, are the design patterns
    of the functional world. They are high-level abstractions that can be found in
    a lot of different places and you will need some time to be able to discern them.
    However, once you will get the feel for them, you will probably realize that they
    are everywhere and it will greatly help you to think in terms of manipulating
    data.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象，如函子，应用和单子，是函数世界的设计模式。它们是高级抽象，可以在许多不同的地方找到，您需要一些时间才能辨别它们。但是，一旦您对它们有了感觉，您可能会意识到它们无处不在，并且这将极大地帮助您思考如何操纵数据。
- en: The laws that preside over our abstractions are really prevalent. You probably
    assume them already when writing code without noticing it. Being able to recognize
    the patterns we've learned about will bring you more confidence when doing refactoring
    or writing algorithms because what your instinct always suspected will be backed
    up by facts.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们抽象的法则确实很普遍。在编写代码时，您可能已经在不知不觉中假设了它们。能够识别我们学到的模式将使您在重构或编写算法时更加自信，因为您的直觉总是会得到事实的支持。
- en: If you want to play around with this chapter's concepts, I can only recommend
    you start playing with the `functional-php` library we presented in [Chapter 3](ch03.html
    "Chapter 3.  Functional Basis in PHP"), *Functional basis in PHP*. It contains
    a lot of interfaces defining various algebraic structures, the fancy name given
    by mathematicians to functors, monads, and such. Some of the method names will
    not be exactly the ones we used, but you should be well equipped to understand
    the idea behind them. As the library name makes it a bit hard to find, here is
    the link once more, [https://github.com/widmogrod/php-functional](https://github.com/widmogrod/php-functional).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想玩玩本章的概念，我只能建议您开始使用我们在[第3章](ch03.html "第3章。PHP中的功能基础")中介绍的`functional-php`库进行实验。它包含许多定义各种代数结构的接口，这是数学家给予函子、单子等的花哨名称。一些方法名称可能不完全与我们使用的名称相同，但您应该能够理解它们背后的思想。由于库的名称有点难以找到，这里再次提供链接，[https://github.com/widmogrod/php-functional](https://github.com/widmogrod/php-functional)。
