- en: Composing Widgets with Vue.js Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vue.js组件组合小部件
- en: Components are becoming an essential aspect of frontend development, and are
    a feature in most modern frontend frameworks, including Vue, React, Angular, Polymer,
    and so on. Components are even becoming native to the web through a new standard
    called **Web Components**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 组件正在成为前端开发的一个重要方面，并且是大多数现代前端框架的一个特性，包括Vue、React、Angular、Polymer等。组件甚至通过一个称为**Web
    Components**的新标准成为Web的本地特性。
- en: In this chapter, we will use components to create an image carousel for Vuebnb,
    which allows users to peruse the different photos of a room listing. We'll also
    refactor Vuebnb to conform to a component-based architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用组件为Vuebnb创建一个图像轮播，允许用户查看房间列表的不同照片。我们还将重构Vuebnb以符合基于组件的架构。
- en: 'Topics covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题：
- en: What components are and how to create them with Vue.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件是什么以及如何使用Vue.js创建它们
- en: Component communication through props and events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过props和events进行组件通信
- en: Single-file components-one of Vue's most useful features
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单文件组件- Vue中最有用的功能之一
- en: Adding custom content to a component with slots
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用插槽向组件添加自定义内容
- en: The benefit of architecting apps entirely from components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全从组件构建应用程序的好处
- en: How render functions can be used to skip the template compiler
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用渲染函数跳过模板编译器
- en: Using the runtime-only build of Vue to lighten the bundle size
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vue的仅运行时构建来减小捆绑包大小
- en: Components
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: When we're constructing a template for a web app, we can use HTML elements such
    as `div`, `table`, and `span`. This variety of elements makes it easy to create
    whatever structures we need for organizing content on the page.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建Web应用程序的模板时，我们可以使用HTML元素，如`div`，`table`和`span`。这种各种元素使得我们可以轻松创建页面上所需的任何结构。
- en: What if we could create our own custom elements, through, for example, `my-element`?
    This would allow us to create reusable structures specifically designed for our
    app.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以通过例如`my-element`创建自定义元素，那该多好？这将允许我们创建专门为我们的应用程序设计的可重用结构。
- en: '*Components* are a tool for creating custom elements in Vue.js. When we register
    a component, we define a template which renders as one or more standard HTML elements:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*组件*是在Vue.js中创建自定义元素的工具。当我们注册一个组件时，我们定义一个模板，它呈现为一个或多个标准HTML元素：'
- en: '![](assets/6e6ef921-1671-4a44-8e89-91c53b8bc046.png)Figure 6.1\. Components
    facilitate reusable markup and render as standard HTML'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6e6ef921-1671-4a44-8e89-91c53b8bc046.png)图6.1。组件促进可重用的标记，并呈现为标准HTML'
- en: Registration
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册
- en: 'There are many ways to register a component, but the easiest is to use the `component` API
    method. The first argument is the name you want to give the component, the second
    is the configuration object. The configuration object will often include a `template` property
    to declare the component''s markup using a string:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多注册组件的方法，但最简单的方法是使用`component` API方法。第一个参数是您要给组件的名称，第二个是配置对象。配置对象通常会包括一个`template`属性，以使用字符串声明组件的标记：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we''ve registered a component like this, we can use it within our project:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注册了这样一个组件后，我们可以在项目中使用它：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Data
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据
- en: In addition to reusable markup, components allow us to reuse JavaScript functionality.
    The configuration object can not only include a template but can also include
    its own state, just like the Vue instance. In fact, each component can be thought
    of as a mini-instance of Vue with its own data, methods, lifecycle hooks, and
    so on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可重用的标记之外，组件还允许我们重用JavaScript功能。配置对象不仅可以包括一个模板，还可以包括自己的状态，就像Vue实例一样。实际上，每个组件都可以被视为Vue的迷你实例，具有自己的数据、方法、生命周期钩子等。
- en: 'We treat component data slightly differently to the Vue instance though, as
    components are meant to be reusable. For example, we might create a bank of `check-box` components
    like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对待组件数据的方式与Vue实例略有不同，因为组件是可重用的。例如，我们可以像这样创建一个`check-box`组件库：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As it is, if a user clicks a checkbox `div`, the `checked` state toggles from
    true to false for every checkbox simultaneously! This is not what we want, but
    it is what will happen, as all instances of the component refer to the same `data` object
    and therefore have the same state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果用户点击复选框`div`，则`checked`状态会同时从true切换到false！这不是我们想要的，但这将会发生，因为组件的所有实例都引用相同的`data`对象，因此具有相同的状态。
- en: 'To give each instance its own unique state, the `data` property shouldn''t
    be an object, but a factory function that returns an object. That way, every time
    the component is instantiated, it links to a fresh data object. Implementing this
    is as simple as:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使每个实例具有自己的唯一状态，`data`属性不应该是一个对象，而应该是一个返回对象的工厂函数。这样，每次组件被实例化时，它都链接到一个新的数据对象。实现这一点就像这样简单：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Image carousel
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像轮播
- en: Let's build a new feature for the Vuebnb frontend app using components. As you'll
    recall from previous chapters, each of our mock data listings has four different
    images, and we're passing the URLs to the frontend app.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用组件为Vuebnb前端应用程序构建一个新功能。正如您从之前的章节中记得的那样，我们的模拟数据列表中有四个不同的图像，并且我们正在将URL传递给前端应用程序。
- en: To allow the user to peruse these images, we're going to create an image carousel.
    This carousel will replace the static image that currently occupies the modal
    window that pops up when you click the header of a listing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户查看这些图像，我们将创建一个图像轮播。这个轮播将取代当前在单击列表标题时弹出的模态窗口中的静态图像。
- en: Begin by opening the app view. Remove the static image and replace it with a
    custom HTML element `image-carousel`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先打开应用视图。删除静态图像，并将其替换为自定义HTML元素`image-carousel`。
- en: '`resources/views/app.blade.php`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A component can be referred to in your code by a kebab-case name such as `my-component`,
    a PascalCase name such as `MyComponent`, or a camelCase name such as `myComponent`.
    Vue sees these all as the same component. However, in a DOM or string template,
    the component should always be kebab-cased. Vue doesn't enforce this, but markup
    in the page gets parsed by the browser before Vue gets to work with it, so it
    should conform to W3C naming conventions or the parser may strip it out.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以在您的代码中通过kebab-case名称（如`my-component`）、PascalCase名称（如`MyComponent`）或camelCase名称（如`myComponent`）来引用。Vue将这些视为相同的组件。然而，在DOM或字符串模板中，组件应始终使用kebab-case。Vue不强制执行这一点，但页面中的标记在Vue开始处理之前会被浏览器解析，因此应符合W3C命名约定，否则解析器可能会将其删除。
- en: Let's now register the component in our entry file. The template of this new
    component will simply be the image tag we removed from the view, wrapped in a `div`.
    We add this wrapping element, as component templates must have a single root element,
    and we'll soon be adding more elements inside it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在入口文件中注册组件。这个新组件的模板将简单地是我们从视图中移除的图像标签，包裹在一个`div`中。我们添加这个包装元素，因为组件模板必须有一个单一的根元素，并且我们很快将在其中添加更多元素。
- en: As a proof of concept, the component data will include an array of hard-coded
    image URLs. Once we learn how to pass data into a component, we will remove these
    hard-coded URLs and replace them with dynamic ones from our model.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 作为概念验证，组件数据将包括一个硬编码的图像URL数组。一旦我们学会如何将数据传递给组件，我们将删除这些硬编码的URL，并用来自我们模型的动态URL替换它们。
- en: '`resources/assets/js/app.js`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`:'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Before we test this component, let's make an adjustment to our CSS. We previously
    had a rule to ensure the image inside the modal window stretched to full width
    by using the `.modal-content img `selector. Let's instead use the `.image-carousel` selector for
    this rule, as we're decoupling the image from the modal window.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试这个组件之前，让我们对CSS进行调整。我们之前有一个规则，确保模态窗口内的图像通过`.modal-content img`选择器拉伸到全宽。让我们改用`.image-carousel`选择器，因为我们正在将图像与模态窗口解耦。
- en: '`resources/assets/css/style.css`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/css/style.css`:'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After your code has rebuilt, navigate the browser to `/listing/1` and you should
    see no difference, as the component should render in almost exactly the same way
    as the previous markup did.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码重建后，将浏览器导航到`/listing/1`，你应该看不到任何区别，因为组件应该以几乎与之前标记完全相同的方式呈现。
- en: 'If we check Vue Devtools, however, and open up to the Components tab, you''ll
    see that we now have the `ImageCarousel` component nested below the `Root` instance.
    Selecting `ImageCarousel`, we can even inspect its state:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们检查Vue Devtools，并打开到“组件”选项卡，你会看到我们现在在“Root”实例下嵌套了“ImageCarousel”组件。选择“ImageCarousel”，甚至可以检查它的状态：
- en: '![](assets/76c74b58-9265-42c3-9131-918c8cb0861d.png)Figure 6.2\. Vue Devtools
    showing ImageCarousel component'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/76c74b58-9265-42c3-9131-918c8cb0861d.png)图6.2。Vue Devtools显示ImageCarousel组件'
- en: Changing images
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改图像
- en: The point of a carousel is to allow the user to peruse a collection of images
    without having to scroll the page. To permit this functionality, we'll need to
    create some UI controls.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 轮播图的目的是允许用户浏览一系列图像，而无需滚动页面。为了实现这一功能，我们需要创建一些UI控件。
- en: But first, let's add a new data property, `index`, to our component, which will
    dictate the current image being displayed. It will be initialized at 0 and the
    UI controls will later be able to increment or decrement the value.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们向我们的组件添加一个新的数据属性`index`，它将决定当前显示的图像。它将被初始化为0，UI控件稍后将能够增加或减少该值。
- en: We will bind the image source to the array item at position `index`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把图像源绑定到位置为`index`的数组项。
- en: '`resources/assets/js/app.js`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`:'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A page refresh should, again, reveal no change to what you see on screen. However,
    if you initialize the value of `index` to `1`, `2`, or `3`, you will find a different
    image is shown when you re-open the modal window:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 页面刷新后，屏幕上看到的内容应该没有变化。但是，如果你将`index`的值初始化为`1`、`2`或`3`，当你重新打开模态窗口时，你会发现显示的是不同的图像：
- en: '![](assets/17bc76a6-6066-4702-8d8e-6beab3b10cde.png)Figure 6.3\. Setting index to
    2 selects a different URL and a different image is shown'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/17bc76a6-6066-4702-8d8e-6beab3b10cde.png)图6.3。将`index`设置为2会选择不同的URL，显示不同的图像'
- en: Computed properties
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算属性
- en: It's convenient to write logic straight into our template as an expression,
    for example, `v-if="myExpression"`. But what about more complex logic that can't
    be defined as an expression, or simply becomes too verbose for the template?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将逻辑写入我们的模板作为一个表达式是很方便的，例如`v-if="myExpression"`。但是对于无法定义为表达式的更复杂的逻辑，或者对于模板来说变得太冗长的情况怎么办呢？
- en: For this scenario, we use **computed properties**. These are properties we add
    to our Vue configuration that can be thought of as reactive methods which are
    rerun whenever a dependent value is changed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用**计算属性**。这些属性是我们添加到Vue配置中的，可以被视为响应式方法，当依赖值发生变化时会重新运行。
- en: In the following example, we've declared a computed property, `message`, under
    the `computed` configuration section. Note the function is dependent on `val`,
    that is, the returned value of of `message` will be different as `val` changes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们在`computed`配置部分下声明了一个计算属性`message`。请注意，该函数依赖于`val`，也就是说，`message`的返回值将随着`val`的变化而不同。
- en: 'When this script runs, Vue will note any dependencies of `message` and will
    set up reactive binding so that, unlike a regular method, the function will be
    rerun whenever the dependencies change:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个脚本运行时，Vue将注意到`message`的任何依赖关系，并建立响应式绑定，这样，与普通方法不同，函数将在依赖关系发生变化时重新运行：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Going back to the image carousel, let's make the template terser by abstracting
    the expression bound to the image `src` into a computed property.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 回到图像轮播，让我们通过将绑定到图像`src`的表达式抽象为计算属性，使模板更加简洁。
- en: '`resources/assets/js/app.js`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`:'
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Composing with components
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合组件
- en: 'Components can be nested in other components in the same way that standard
    HTML elements can be nested. For example, `component B` can be a child of `component
    A`, if `component A` declares `component B` in its template:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以像标准HTML元素一样嵌套在其他组件中。例如，如果`component A`在其模板中声明`component B`，则`component B`可以是`component
    A`的子级：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This renders as:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将呈现为：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Registration scope
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册范围
- en: While some components are designed for use anywhere in an app, other components
    may be designed with a more specific purpose. When we register a component using
    the API, that is, `Vue.component`, that component is *globally *registered and
    can be used within any other component or instance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些组件设计用于在应用程序的任何地方使用，但其他组件可能具有更具体的目的。当我们使用API注册组件，即`Vue.component`时，该组件是*全局*注册的，并且可以在任何其他组件或实例中使用。
- en: 'We can also *locally* register a component by declaring it in the `components` option
    in the root instance, or in another component:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在根实例或另一个组件的`components`选项中声明来*本地*注册组件：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Carousel controls
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮播控件
- en: To allow a user to change the currently shown image in the carousel, let's create
    a new component, `CarouselControl`. This component will be presented as an arrowhead
    that floats over the carousel and will respond to a user's click. We'll use two
    instances, as there will be a left and right arrow for either decrementing or
    incrementing the image index.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许用户更改轮播中当前显示的图像，让我们创建一个新的组件`CarouselControl`。该组件将呈现为一个浮动在轮播上的箭头，并将响应用户的点击。我们将使用两个实例，因为将有一个左箭头和一个右箭头，用于减少或增加图像索引。
- en: We'll register `CarouselControl` locally for the `ImageCarousel` component.
    The `CarouselControl` template will render as an `i` tag, which is often used
    for displaying icons. A good icon for carousels is the Font Awesome *chevron *icon,
    which is an elegantly shaped arrowhead. Currently, we don't have a way to distinguish
    between the left and right, so for now, both instances will have a left-facing
    icon.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`ImageCarousel`组件中本地注册`CarouselControl`。`CarouselControl`模板将呈现为一个`i`标签，通常用于显示图标。轮播图标的一个很好的图标是Font
    Awesome的*chevron*图标，它是一个优雅的箭头形状。目前，我们还没有办法区分左右，所以现在，两个实例都将有一个朝左的图标。
- en: '`resources/assets/js/app.js`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To have these controls float nicely over our image carousel, we'll add some
    new rules to our CSS file as well.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这些控件在我们的图像轮播上漂亮地浮动，我们还会在我们的CSS文件中添加一些新的规则。
- en: '`resources/assets/css/style.css`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/css/style.css`：'
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With that code added, open the modal window to see our handywork so far:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了该代码后，打开模态窗口查看我们迄今为止的工作成果：
- en: '![](assets/dbcc4ccc-a1b8-424e-81df-c859ebe02e2f.png)Figure 6.4\. Carousel controls
    added to the image carousel'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/dbcc4ccc-a1b8-424e-81df-c859ebe02e2f.png)图6.4。添加到图像轮播的轮播控件'
- en: Communicating with components
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与组件通信
- en: A key aspect of components is that they are reusable, which is why we give them
    their own state to keep them independent from the rest of the app. However, we
    may still want to send in data, or send it out. Components have an interface for
    communicating with other parts of the app, which we will now explore.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的一个关键方面是它们是可重用的，这就是为什么我们给它们自己的状态以使它们独立于应用程序的其余部分。但是，我们可能仍然希望发送数据，或者将其发送出去。组件有一个用于与应用程序的其他部分通信的接口，我们现在将进行探讨。
- en: Props
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'We can send data to a component through a custom HTML property know as a *prop*.
    We must also register this custom property in an array, `props`, in the component''s
    configuration. In the following example, we''ve created a prop, `title`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过自定义HTML属性*prop*向组件发送数据。我们还必须在组件的配置中的数组`props`中注册此自定义属性。在下面的示例中，我们创建了一个prop，`title`：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A prop can be used just like any data property of the component: you can interpolate
    it in the template, use it in methods and computed properties, and so on. However,
    you should not mutate prop data. Think of prop data as being *borrowed* from another
    component or instance - only the owner should change it.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: prop可以像组件的任何数据属性一样使用：您可以在模板中插值，将其用于方法和计算属性等。但是，您不应该改变prop数据。将prop数据视为从另一个组件或实例*借用*的数据-只有所有者应该更改它。
- en: Props are proxied to the instance just like data properties, meaning you can
    refer to a prop as `this.myprop` within that component's code. Be sure to name
    your props uniquely to your data properties to avoid a clash!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 属性被代理到实例中，就像数据属性一样，这意味着你可以在组件的代码中将属性称为`this.myprop`。一定要将您的属性名称设置为与数据属性不同，以避免冲突！
- en: One-way data flow
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单向数据流
- en: Since props must be declared in the template where the component is used, prop
    data can only pass from a parent to a child. This is why you shouldn't mutate
    a prop - since data flows down, the change will not be reflected in the parent,
    and therefore you will have different versions of what is meant to be the same
    bit of state.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于prop必须在使用组件的模板中声明，因此prop数据只能从父级传递到子级。这就是为什么您不应该改变prop的原因-因为数据是向下流动的，更改不会反映在父级中，因此您将拥有不同版本的应该是相同状态的内容。
- en: If you do need to tell the owner to change the data, there is a separate interface
    for passing data from a child to a parent, which we'll see later.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实需要告诉所有者更改数据，那么有一个单独的接口用于从子级向父级传递数据，我们稍后会看到。
- en: Dynamic props
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态prop
- en: We can reactively bind data to a component using the `v-bind` directive. When
    the data changes in the parent, it will automatically flow down to the child.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`v-bind`指令将数据动态绑定到组件。当父级数据发生变化时，它将自动流向子级。
- en: 'In the following example, the value of `title` in the root instance gets programmatically
    updated after two seconds. This change will automatically flow down to `MyComponent`,
    which will reactively re-render to display the new value:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，根实例中`title`的值在两秒后以编程方式更新。此更改将自动流向`MyComponent`，后者将以响应方式重新呈现以显示新值：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since the `v-bind` directive is used so commonly in templates, you can omit
    the directive name as a shorthand: `<div v-bind:title="title">` can be shortened
    to `<div :title="title">`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在模板中经常使用`v-bind`指令，您可以省略指令名称作为简写：`<div v-bind:title="title">`可以缩写为`<div :title="title">`。
- en: Image URLs
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图片URL
- en: When we created `ImageCarousel`, we hard-coded the image URLs. With props, we
    now have a mechanism for sending dynamic data from the root instance down to a
    component. Let's bind the root instance data property `images` to a prop, also
    called `images`, in our `ImageCarousel` declaration.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`ImageCarousel`时，我们硬编码了图像URL。通过props，我们现在有了一种机制，可以从根实例向组件发送动态数据。让我们将根实例数据属性`images`绑定到一个prop，也叫`images`，在我们的`ImageCarousel`声明中。
- en: '`resources/views/app.blade.php`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, delete the data property `images` in the `ImageCarousel` component, and
    instead declare `images` as a prop.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，删除`ImageCarousel`组件中的数据属性`images`，并将`images`声明为prop。
- en: '`resources/assets/js/app.js`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The root instance will now be responsible for the state of the image URLs, and
    the image carousel component will just be responsible for displaying them.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 根实例现在将负责图像URL的状态，图像轮播组件将负责显示它们。
- en: 'Using Vue Devtools, we can inspect the state of the image carousel component,
    which now includes `images` as a prop value instead of a data value:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vue Devtools，我们可以检查图像轮播组件的状态，现在包括`images`作为prop值而不是数据值：
- en: '![](assets/f4733eab-446b-46cd-a129-5fb17c0adf3b.png)Figure 6.5\. Image URLs
    are props sent to the ImageCarousel component'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/f4733eab-446b-46cd-a129-5fb17c0adf3b.png)图6.5。图像URL是发送到ImageCarousel组件的props'
- en: Now that the image URLs are coming from the model, we can access other listing
    routes, such as `/listing/2`, and see the correct image displaying in the modal
    window again.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在图像URL来自模型，我们可以访问其他列表路由，比如`/listing/2`，并再次在模态窗口中看到正确的图像显示。
- en: Distinguishing carousel controls
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分轮播控件
- en: 'The `CarouselControl` component should have two possible states: either left-pointing
    or right-pointing. When clicked by the user, the former will ascend through the
    available images, the latter will descend.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`CarouselControl`组件应该有两种可能的状态：要么指向左，要么指向右。当用户点击时，前者将上升到可用图像，后者将下降。'
- en: This state should not be internally determined, but instead passed down from `ImageCarousel`.
    To do so, let's add a prop `dir` to `CarouselControl` that will take a string
    value, and should be either `left` or `right`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这种状态不应该由内部确定，而应该从`ImageCarousel`传递下来。为此，让我们向`CarouselControl`添加一个prop`dir`，它将采用一个字符串值，应该是`left`或`right`。
- en: With the `dir` prop, we can now bind the correct icon to the `i` element. This
    is done with a computed property which appends the prop's value to the string
    `fa-chevron-`, resulting in either `fa-chevron-left`or `fa-chevron-right`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`dir`prop，我们现在可以将正确的图标绑定到`i`元素。这是通过一个计算属性完成的，它将prop的值附加到字符串`fa-chevron-`，结果要么是`fa-chevron-left`要么是`fa-chevron-right`。
- en: '`resources/assets/js/app.js`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can see the carousel control icons correctly directed:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到轮播控制图标正确指向：
- en: '![](assets/a890fe8a-97f2-4cd0-87f5-c056108af4a1.png)Figure 6.6\. Carousel control
    icons are now correctly directed'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a890fe8a-97f2-4cd0-87f5-c056108af4a1.png)图6.6。轮播控制图标现在正确指向'
- en: Custom events
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义事件
- en: Our carousel controls are displaying nicely, but they still don't do anything!
    When they're clicked, we need them to tell `ImageCarousel` to either increment
    or decrement its `index` value, which will result in the image being changed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的轮播控件显示得很好，但它们还没有做任何事情！当它们被点击时，我们需要它们告诉`ImageCarousel`要么增加要么减少它的`index`值，这将导致图像被更改。
- en: Dynamic props won't work for this task, as props can only send data down from
    a parent to a child. What do we do when the child needs to send data up to the
    parent?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 动态props对于这个任务不起作用，因为props只能从父组件向子组件发送数据。当子组件需要向父组件发送数据时，我们该怎么办？
- en: '*Custom events* can be emitted from a child component and listened to by its
    parent. To implement this, we use the `$emit` instance method in the child, which
    takes the event name as the first argument and an arbitrary number of additional
    arguments for any data to be sent along with the event, such as `this.$emit(''my-event'',
    ''My event payload'');`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*自定义事件*可以从子组件发出，并由其父组件监听。为了实现这一点，我们在子组件中使用`$emit`实例方法，它将事件名称作为第一个参数，并为任何要随事件发送的数据附加任意数量的额外参数，例如`this.$emit(''my-event'',
    ''My event payload'');`。'
- en: The parent can listen to this event using the `v-on` directive in the template
    where the component is declared. If you handle the event with a method, any arguments
    sent with the event will be passed to this method as parameters.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件可以在声明组件的模板中使用`v-on`指令来监听此事件。如果您使用方法处理事件，那么随事件发送的任何参数都将作为参数传递给此方法。
- en: 'Consider this example, where a child component, `MyComponent`, emits an event
    called `toggle` to tell the parent, the root instance, to change the value of
    a data property, `toggle`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子，一个子组件`MyComponent`发出一个名为`toggle`的事件，告诉父组件，根实例，改变一个数据属性`toggle`的值：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Changing carousel images
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改轮播图像
- en: Returning to `CarouselControl`, let's respond to a user's click by using the `v-on` directive
    and triggering a method, `clicked`. This method will, in turn, emit a custom event, `change-image`, which
    will include a payload of either `-1` or `1`, depending on whether the state of
    the component is `left` or `right`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`CarouselControl`，让我们通过使用`v-on`指令和触发一个方法`clicked`来响应用户的点击。这个方法将反过来发出一个自定义事件`change-image`，其中将包括一个`-1`或`1`的有效负载，具体取决于组件的状态是`left`还是`right`。
- en: Just like with `v-bind`, there is a shorthand for `v-on` as well. Simply replace `v-on:` with `@`;
    for instance, `<div @click="handler"></div>` is the equivalent of `<div v-on:click="handler"></div>`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`v-bind`一样，`v-on`也有一个简写。只需用`@`替换`v-on:`；例如，`<div @click="handler"></div>`相当于`<div
    v-on:click="handler"></div>`。
- en: '`resources/assets/js/app.js`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Open Vue Devtools to the Events tab, and, at the same time, click on the carousel
    controls. Custom events are logged here, so we can verify `change-image` is being
    emitted:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Vue Devtools到`Events`选项卡，并同时点击轮播控件。自定义事件将在此处记录，因此我们可以验证`change-image`是否被发出：
- en: '![](assets/c2505411-760b-4363-a19d-8f6938340b2b.png)Figure 6.7\. Screenshot
    showing a custom event and its payload'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c2505411-760b-4363-a19d-8f6938340b2b.png)图6.7。屏幕截图显示自定义事件及其有效负载'
- en: '`ImageCarousel` will now need to listen for the `change-image` event via the `v-on` directive.
    The event will be handled by a method `changeImage` which will have a single parameter, `val`,
    reflecting the payload being sent in the event. The method will then use `val` to
    step the value of `index`, ensuring it loops to the start or end if it exceeds
    the bounds of the array it indexes.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageCarousel`现在需要通过`v-on`指令监听`change-image`事件。该事件将由一个名为`changeImage`的方法处理，该方法将具有一个参数`val`，反映事件中发送的有效负载。然后，该方法将使用`val`来调整`index`的值，确保它在超出数组索引范围时循环到开始或结束。'
- en: '`resources/assets/js/app.js`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With this done, the image carousel will now work perfectly:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，图像轮播将正常工作：
- en: '![](assets/a6a518db-81ab-4501-9a2e-355fff9be282.png)Figure 6.8\. The state
    of the image carousel after the image has been changed'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a6a518db-81ab-4501-9a2e-355fff9be282.png)图6.8。图像轮播在更改图像后的状态'
- en: Single-file components
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单文件组件
- en: '**Single-File Components** (**SFCs**) are files with a `.vue` extension that
    contain the complete definition of a single component and can be imported into
    your Vue.js app. SFCs make it simple to create and use components, and come with
    a variety of other benefits which we''ll soon explore.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**单文件组件**（**SFCs**）是具有`.vue`扩展名的文件，包含单个组件的完整定义，并可以导入到您的Vue.js应用程序中。SFC使创建和使用组件变得简单，并带有各种其他好处，我们很快会探讨。'
- en: 'SFCs are similar to HTML files but have (at most) three root elements:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: SFC类似于HTML文件，但最多有三个根元素：
- en: '`template`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`'
- en: '`script`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`script`'
- en: '`style`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`style`'
- en: 'The component definition goes inside the `script` tag and will be exactly like
    any other component definition except:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 组件定义放在`script`标签内，除了以下内容，其余与任何其他组件定义完全相同：
- en: It will export an ES module
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将导出一个ES模块
- en: It will not need a `template` property (or a `render` function; more on that
    later)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将不需要`template`属性（或`render`函数；稍后会详细介绍）
- en: The component's template will be declared as HTML markup inside the `template` tag.
    This should be a welcome relief from writing cumbersome template strings!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的模板将在`template`标签内声明为HTML标记。这应该是一个从编写繁琐的模板字符串中解脱出来的好消息！
- en: The `style` tag is a feature unique to SFCs and can contain any CSS rules you
    need for the component. This mostly just helps with the organization of your CSS.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`style`标签是SFC独有的功能，可以包含组件所需的任何CSS规则。这主要有助于组织CSS。'
- en: Here's an example of the declaration and usage of a single-file component.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是声明和使用单文件组件的示例。
- en: '`MyComponent.vue`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyComponent.vue`：'
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`app.js`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`：'
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Transformation
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: To use a single-file component in your app, you simply `import` it like it were
    an ES module. The *.vue* file is not a valid JavaScript module file, however.
    Just like we use the Webpack Babel plugin to transpile our ES2015 code into ES5
    code, we must use *Vue Loader* to transform *.vue* files into JavaScript modules.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中使用单文件组件，只需像使用ES模块一样导入它。*.vue*文件不是有效的JavaScript模块文件。就像我们使用Webpack Babel插件将ES2015代码转译为ES5代码一样，我们必须使用*Vue
    Loader*将*.vue*文件转换为JavaScript模块。
- en: Vue Loader is already configured by default with Laravel Mix, so there's nothing
    further we need to do in this project; any SFCs we import will just work!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Vue Loader已经默认配置了Laravel Mix，因此在这个项目中我们无需做其他操作；我们导入的任何SFC都会正常工作！
- en: To learn more about Vue Loader, check out the documentation at [https://vue-loader.vuejs.org/](https://vue-loader.vuejs.org/).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关Vue Loader的更多信息，请查看[https://vue-loader.vuejs.org/](https://vue-loader.vuejs.org/)上的文档。
- en: Refactoring components to SFCs
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将组件重构为SFC
- en: Our `resource/assets/js/app.js` file is almost 100 lines long now. If we keep
    adding components, it will start to get unmanageable, so it's time to think about
    splitting it up.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`resource/assets/js/app.js`文件现在几乎有100行。如果我们继续添加组件，它将变得难以管理，因此现在是时候考虑拆分它了。
- en: 'Let''s begin by refactoring our existing components to be SFCs. First, we''ll
    create a new directory, then we will create the `.vue` files:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从重构现有组件为SFC开始。首先，我们将创建一个新目录，然后创建`.vue`文件：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Starting with `ImageCarousel.vue`, the first step is to create the three root
    elements.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ImageCarousel.vue`开始，第一步是创建三个根元素。
- en: '`resources/assets/components/ImageCarousel.vue`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ImageCarousel.vue`：'
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, we move the `template` string into the `template `tag, and the component
    definition into the `script` tag. The component definition must be exported as
    a module.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将`template`字符串移入`template`标签中，将组件定义移入`script`标签中。组件定义必须导出为模块。
- en: '`resources/assets/components/ImageCarousel.vue`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ImageCarousel.vue`：'
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we can import this file into our app and register it locally in the root
    instance. As mentioned, Vue is able to automatically switch between kebab-case
    component names and Pascal-case ones. This means we can use the object shorthand
    syntax inside the `component` configuration and Vue will correctly resolve it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将此文件导入到我们的应用程序中，并在根实例中本地注册它。如前所述，Vue能够自动在kebab-case组件名称和Pascal-case组件名称之间切换。这意味着我们可以在`component`配置中使用对象简写语法，Vue将正确解析它。
- en: '`resources/assets/js/app.js`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Be sure to delete any remaining code from the original `ImageCarousel` component
    definition in `app.js` before moving on.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保删除`app.js`中原始`ImageCarousel`组件定义的任何剩余代码。
- en: CSS
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS
- en: 'SFCs allow us to add style to a component, helping to better organize our CSS
    code. Let''s move the CSS rules we created for the image carousel into this new
    SFC''s `style` tag:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: SFC允许我们向组件添加样式，有助于更好地组织我们的CSS代码。让我们将为图像轮播创建的CSS规则移入这个新SFC的`style`标签中：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When the project builds, you should find it still appears the same. The interesting
    thing, though, is where the CSS has ended up in the build. If you check `public/css/style.css`,
    you'll find it's not there.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 项目构建完成后，你应该发现它仍然是一样的。然而，有趣的是，CSS最终出现在了构建中的位置。如果你检查`public/css/style.css`，你会发现它不在那里。
- en: 'It''s actually included in the JavaScript bundle as a string:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上包含在JavaScript捆绑包中作为一个字符串：
- en: '![](assets/9a6e3bbf-577a-4800-b4bc-c5c0fe1243b2.png)Figure 6.9\. CSS stored
    as a string in the JavaScript bundle file'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/9a6e3bbf-577a-4800-b4bc-c5c0fe1243b2.png)图6.9. CSS存储为JavaScript捆绑文件中的字符串'
- en: 'To use it, Webpack''s bootstrapping code will inline this CSS string into the
    head of the document when the app runs:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，Webpack的引导代码将在应用程序运行时将此CSS字符串内联到文档的头部：
- en: '![](assets/4260368f-354f-4695-8013-8ca5a8a38001.png)Figure 6.10\. Inlined CSS
    in document head'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/4260368f-354f-4695-8013-8ca5a8a38001.png)图6.10. 文档头中的内联CSS'
- en: Inlining CSS is actually the default behavior of Vue Loader. However, we can
    override this and get Webpack to write SFC styles to their own file. Add the following
    to the bottom of the Mix configuration.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 内联CSS实际上是Vue Loader的默认行为。但是，我们可以覆盖这一行为，让Webpack将SFC样式写入它们自己的文件中。在Mix配置的底部添加以下内容。
- en: '`webpack.mix.js`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack.mix.js`：'
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now an additional file, `public/css/vue-style.css`, will be outputted in the
    build:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个额外的文件`public/css/vue-style.css`将被输出到构建中：
- en: '![](assets/45e46db4-744d-462d-ba87-afe089b1541a.png)Figure 6.11\. Webpack output
    including single-file component styles'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/45e46db4-744d-462d-ba87-afe089b1541a.png)图6.11. 包括单文件组件样式的Webpack输出'
- en: We'll need to load this new file in our view, after the main style sheet.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在主样式表之后在视图中加载这个新文件。
- en: '`resources/views/app.blade.php`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: CarouselControl
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CarouselControl
- en: Let's now abstract our `CarouselControl` component into an SFC, and move any
    relevant CSS rules from `resources/assets/css/style.css` as well.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将`CarouselControl`组件抽象成一个SFC，并将`resources/assets/css/style.css`中的任何相关CSS规则移动过来。
- en: '`resources/assets/components/CarouselControl.vue`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/CarouselControl.vue`：'
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This file can now be imported by the `ImageCarousel` component.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个文件可以被`ImageCarousel`组件导入。
- en: '`resources/assets/components/ImageCarousel.vue`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ImageCarousel.vue`：'
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With that done, our existing components have been refactored to SFCs. This has
    not made any obvious difference to the functionality of our app (although it is
    slightly faster, as I'll explain later), but it will make development easier as
    we continue.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们现有的组件已经重构为SFC。这并没有对我们应用程序的功能产生明显的影响（尽管稍微快一点，我稍后会解释），但随着我们的开发继续，这将使开发变得更容易。
- en: Content distribution
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容分发
- en: 'Imagine you''re going to build a component-based Vue.js app that resembles
    the following structure:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你将要构建一个基于组件的Vue.js应用程序，它的结构类似于以下结构：
- en: '![](assets/62c38159-a04a-4e5c-8993-6a17f3a97de1.png)Figure 6.12\. Component-based
    Vue.js app'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/62c38159-a04a-4e5c-8993-6a17f3a97de1.png)图6.12. 基于组件的Vue.js应用程序'
- en: Notice that in the left-branch of the above diagram, `ComponentC` is declared
    by `ComponentB`. However, in the right branch, `ComponentD` is declared by a different
    instance of `ComponentB`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上图的左分支中，`ComponentC`由`ComponentB`声明。然而，在右分支中，`ComponentD`由`ComponentB`的另一个实例声明。
- en: With what you know about components so far, how would you make the template
    for `ComponentB`, given that it has to declare two different components? Perhaps
    it would include a `v-if` directive to use either `ComponentC` or `ComponentD`
    depending on some variable passed down as a prop from `ComponentA`. This approach
    would work, however, it makes `ComponentB` very inflexible, limiting its reusability
    in other parts of the app.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你目前对组件的了解，如果`ComponentB`必须声明两个不同的组件，你会如何制作`ComponentB`的模板？也许它会包括一个`v-if`指令，根据从`ComponentA`传递下来的某个变量来使用`ComponentC`或`ComponentD`。这种方法可以工作，但是它会使`ComponentB`非常不灵活，在应用程序的其他部分限制了它的可重用性。
- en: Slots
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插槽
- en: 'We''ve learned so far that the content of a component is defined by its own
    template, not by its parent, so we wouldn''t expect the following to work:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学到了组件的内容是由它自己的模板定义的，而不是由它的父级定义的，所以我们不会期望以下内容能够工作：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'But it will work if `MyComponent` has a *slot*. Slots are distribution outlets
    inside a component, defined with the special `slot` element:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果`MyComponent`在它的模板中有一个*插槽*，它将起作用。插槽是组件内的分发出口，使用特殊的`slot`元素定义：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This renders as:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将呈现为：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If `ComponentB` has a slot in its template, like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ComponentB`在它的模板中有一个插槽，就像这样：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can solve the problem just stated without having to use a cumbersome `v-for`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以解决刚才提到的问题，而不必使用繁琐的`v-for`：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It''s important to note that content declared inside a component in the parent
    template is compiled in the scope of the parent. Although it is rendered inside
    the child, it cannot access any of the child''s data. The following example should
    distinguish this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在父模板中声明的组件内的内容是在父模板的范围内编译的。尽管它在子组件内呈现，但它无法访问子组件的任何数据。以下示例应该能够区分这一点：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Modal window
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模态窗口
- en: 'A lot of the functionality left in our root Vue instance concerns the modal
    window. Let''s abstract this into a separate component. First, we''ll create the
    new component file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根Vue实例中剩下的大部分功能都涉及模态窗口。让我们将这些抽象成一个单独的组件。首先，我们将创建新的组件文件：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, we'll transplant the markup from the view to the component. To ensure the
    carousel stays decoupled from the modal window, we'll replace the `ImageCarousel` declaration
    in the markup with a slot.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把视图中的标记移到组件中。为了确保轮播图与模态窗口保持解耦，我们将在标记中的`ImageCarousel`声明替换为一个插槽。
- en: '`resources/assets/components/ModalWindow.vue`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ModalWindow.vue`：'
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can now declare a `ModalWindow` element in the hole we just created in the
    view, with an `ImageCarousel` as content for the slot.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在视图中刚刚创建的洞中声明一个`ModalWindow`元素，并将`ImageCarousel`作为插槽的内容。
- en: '`resources/views/app.blade.php`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We will now move the needed functionality from the root instance and place it
    inside the `script` tag.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将从根实例中移动所需的功能，并将其放置在`script`标签内。
- en: '`resources/assets/components/ModalWindow.vue`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ModalWindow.vue`：'
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Next we import `ModalWindow` in the entry file.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来在入口文件中导入`ModalWindow`。
- en: '`resources/assets/js/app.js`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, let''s move any modal-related CSS rules into the SFC as well:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将任何与模态相关的CSS规则也移入SFC中：
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: After the project builds, you'll notice the modal window won't open. We'll fix
    that in the next section.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 项目构建完成后，您会注意到模态窗口不会打开。我们将在下一节中修复这个问题。
- en: 'If you check Vue Devtools, you''ll see a `ModalWindow` component in the hierarchy
    of components now:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查Vue Devtools，您会看到现在组件层次结构中有一个`ModalWindow`组件：
- en: '![](assets/aa3d425e-e848-4b0a-87fa-a45c5e02f7a7.png)Figure 6.13\. Vue Devtools
    showing hierarchy of componentsThe representation of our app in Vue Devtools is
    slightly misleading. It makes it seem as though `ImageCarousel` is a child of `ModalWindow`.
    Even though `ImageCarousel` renders within `ModalWindow` due to the slot, these
    components are actually siblings!'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/aa3d425e-e848-4b0a-87fa-a45c5e02f7a7.png)图6.13。Vue Devtools显示组件层次结构我们在Vue
    Devtools中的应用程序表示略有误导。它使得`ImageCarousel`看起来是`ModalWindow`的子组件。即使`ImageCarousel`由于插槽而在`ModalWindow`内部呈现，但这些组件实际上是同级的！'
- en: Refs
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Refs
- en: 'In its initial state, the modal window is hidden with a `display: none` CSS
    rule. To open the modal, the user must click the header image. A click event listener
    will then set the root instance data property `modelOpen` to true, which will,
    in turn, add a class to the modal to overwrite the `display: none` to `display:
    block`.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '在初始状态下，模态窗口使用`display: none` CSS规则隐藏。要打开模态窗口，用户必须点击标题图像。然后，点击事件侦听器将设置根实例数据属性`modelOpen`为true，这将反过来向模态窗口添加一个类，以覆盖`display:
    none`为`display: block`。'
- en: After refactoring, however, `modalOpen` has been moved into the `ModalWindow` component along
    with the rest of the modal logic, and hence the modal opening functionality is
    currently broken. One possible way to fix this is to let the root instance manage
    the opened/closed state of the modal by moving the logic back into the root instance.
    We could then use a prop to inform the modal when it needs to open. When the modal
    is closed (this happens in the scope of the modal component, where the close button
    is) it would send an event to the root instance to update the state.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在重构之后，`modalOpen`已经移动到`ModalWindow`组件中，连同其余的模态逻辑，因此模态打开功能目前已经失效。修复这个问题的一种可能的方法是让根实例管理模态的打开/关闭状态，将逻辑移回根实例。然后我们可以使用prop来通知模态何时需要打开。当模态关闭时（这发生在模态组件的范围内，关闭按钮所在的地方），它会向根实例发送事件以更新状态。
- en: This approach would work, but it's not in the spirit of making our components
    decoupled and reusable; the modal component should manage its own state. How,
    then, can we allow the modal to keep its state, but let the root instance (the
    parent) change it? An event won't work, as events can only flow up, not down.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以工作，但不符合使我们的组件解耦且可重用的精神；模态组件应该管理自己的状态。那么，我们如何才能让模态保持其状态，但让根实例（父级）改变它？事件不起作用，因为事件只能向上流动，而不能向下流动。
- en: '`ref` is a special property that allows you to directly reference a child component''s
    data. To use it, declare the `ref` property and assign it a unique value, such
    as `imagemodal`.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref`是一个特殊的属性，允许您直接引用子组件的数据。要使用它，声明`ref`属性并为其分配一个唯一值，例如`imagemodal`。'
- en: '`resources/views/app.blade.php`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now the root instance has access to this specific `ModalWindow` component's
    data via the `$refs` object. This means we can change the value of `modalOpen` inside
    a root instance method, just like we could from within `ModalWindow`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在根实例可以通过`$refs`对象访问特定的`ModalWindow`组件数据。这意味着我们可以在根实例方法中更改`modalOpen`的值，就像我们可以从`ModalWindow`内部一样。
- en: '`resources/assets/js/app.js`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now we can call the `openModal` method in the header image's click listener,
    thus restoring the modal opening functionality.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在标题图像的点击侦听器中调用`openModal`方法，从而恢复模态打开功能。
- en: '`resources/views/app.blade.php`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It is an anti-pattern to use `ref` when the normal methods of interacting with
    a component, props and events, are sufficient. `ref` is usually only required
    for communicating with elements that fall outside of the normal flow of a page,
    as a modal window does.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用组件的正常交互方法，即prop和事件，足以满足需求时，使用`ref`是一种反模式。`ref`通常只用于与页面正常流程之外的元素进行通信，就像模态窗口一样。
- en: Header image
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标题图像
- en: 'Let''s now abstract the header image into a component. Firstly, create a new `.vue` file:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将标题图像抽象成一个组件。首先，创建一个新的`.vue`文件：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now move in the markup, data, and CSS. Take note of the following modifications:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在移动到标记、数据和CSS。注意以下修改：
- en: An event `header-clicked` must be emitted. This will be used to open the modal
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须发出事件`header-clicked`。这将用于打开模态窗口
- en: The image URL is passed as a prop, `image-url`, then transformed to be an inline
    style rule via a computed property
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像URL作为prop传递，`image-url`，然后通过计算属性转换为内联样式规则
- en: '`resource/assets/components/HeaderImage.vue`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`resource/assets/components/HeaderImage.vue`：'
- en: '[PRE51]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Once you've imported this component in `resources/assets/js/app.js`, declare
    it in the main template. Be sure to bind the `image-url` prop and handle the click
    event.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在`resources/assets/js/app.js`中导入了这个组件，就在主模板中声明它。确保绑定`image-url`prop并处理点击事件。
- en: '`resources/views/app.blade.php`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE52]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Feature lists
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能列表
- en: Let's continue our process of refactoring Vuebnb into components, and abstract
    the amenities and prices lists. These lists have a similar purpose and structure,
    so it makes sense that we create a single, versatile component for both.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续将Vuebnb重构为组件，并将设施和价格列表抽象出来。这些列表具有类似的目的和结构，因此创建一个单一的通用组件是有意义的。
- en: Let's remind ourselves of how the markup for the lists currently looks.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下当前列表的标记是什么样子的。
- en: '`resources/views/app.blade.php`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE53]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The main difference between the two lists is inside the `<div class="content">...</div>` section,
    as the data being displayed in each list has a slightly different structure. The
    amenities have an icon and a title whereas the prices have a title and a value.
    We'll use a slot in this section to allow the parent to customize the content
    for each.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 两个列表之间的主要区别在于`<div class="content">...</div>`部分，因为在每个列表中显示的数据结构略有不同。设施有一个图标和一个标题，而价格有一个标题和一个值。我们将在这一部分使用插槽，以允许父级自定义每个内容。
- en: 'But first, let''s create the new `FeatureList` component file:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们创建新的`FeatureList`组件文件：
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We'll move the markup for one of the lists in, using a slot to replace the list
    content. We'll also add a prop for the title and move in any list-related CSS.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个列表的标记移到其中，使用插槽替换列表内容。我们还将为标题添加一个prop，并移入任何与列表相关的CSS。
- en: '`resources/assets/components/FeatureList.vue`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/FeatureList.vue`:'
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Go ahead and import `FeatureList` into `resources/assets/js/app.js`, and add
    it to the locally registered components. Now we can use `FeatureList` in our main
    template, with a separate instance for each list.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 继续将`FeatureList`导入`resources/assets/js/app.js`，并将其添加到本地注册的组件中。现在我们可以在主模板中使用`FeatureList`，每个列表都有一个单独的实例。
- en: '`resources/views/app.blade.php`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`:'
- en: '[PRE56]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Scoped slots
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域插槽
- en: The `FeatureList` component works but is quite weak. The majority of the content
    comes through the slot and so it seems like the parent is doing too much work,
    and the child too little. Given that there's repeated code in both declarations
    of the component (`<div class="list-item" v-for="...">`), it'd be good to delegate
    this to the child.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`FeatureList`组件可以工作，但相当薄弱。大部分内容都通过插槽传递，因此似乎父级做了太多的工作，而子级做得太少。鉴于在组件的两个声明中都有重复的代码（`<div
    class="list-item" v-for="...">`），最好将这些代码委托给子级。'
- en: To allow our component template to be more versatile, we can use a *scoped slot* instead
    of a regular slot. Scoped slots allow you to pass a *template* to the slot instead
    of passing a rendered element. When this template is declared in the parent, it
    will have access to any props supplied in the child.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的组件模板更加灵活，我们可以使用*作用域插槽*而不是常规插槽。作用域插槽允许您将*模板*传递给插槽，而不是传递渲染的元素。当这个模板在父级中声明时，它将可以访问子级提供的任何props。
- en: 'For example, a component `child` with a scoped slot might look like the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个带有作用域插槽的组件`child`可能如下所示：
- en: '[PRE57]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A parent that uses this component will declare a `template` element, which
    will have a property `slot-scope` that names an alias object. Any props added
    to the slot in the child template are available as properties of the alias object:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个组件的父级将声明一个`template`元素，其中将有一个命名别名对象的`slot-scope`属性。在子级模板中添加到插槽的任何props都可以作为别名对象的属性使用：
- en: '[PRE58]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This renders as:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这将呈现为：
- en: '[PRE59]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Let's go through the steps of including a scoped slot with our `FeatureList` component.
    The goal is to be able to pass the list items array in as a prop and get the `FeatureList` component
    to iterate them. That way, `FeatureList` is taking ownership of any repeated functionality.
    The parent will then provide a template to define how each list item should display.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过包含一个带有`FeatureList`组件的作用域插槽的步骤。目标是能够将列表项数组作为prop传递，并让`FeatureList`组件对它们进行迭代。这样，`FeatureList`将拥有任何重复的功能。然后父级将提供一个模板来定义每个列表项的显示方式。
- en: '`resources/views/app.blade.php`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`:'
- en: '[PRE60]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Focusing now on the `FeatureList` component, follow these steps:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在专注于`FeatureList`组件，按照以下步骤操作：
- en: Add `items` to the props array in the configuration object
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置对象的props数组中添加`items`
- en: '`items` will be array which we iterate inside the `<div class="content">` section'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`items`将是一个我们在`<div class="content">`部分内部迭代的数组。'
- en: In the loop, `item` is an alias to any particular list item. We can create a
    slot and bind that list item to the slot using `v-bind="item"`. (We haven't used `v-bind` without
    an argument before, but this will bind the properties of an entire object to the
    element. This is useful as the amenities and prices objects have different properties
    and we now don't have to specify them.)
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中，`item`是任何特定列表项的别名。我们可以创建一个插槽，并使用`v-bind="item"`将该列表项绑定到插槽。（我们以前没有使用过没有参数的`v-bind`，但这将整个对象的属性绑定到元素。这对于设施和价格对象具有不同属性的情况很有用，现在我们不必指定它们。）
- en: '`resources/assets/components/FeatureList.vue`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/FeatureList.vue`:'
- en: '[PRE61]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now we''ll return to our view. Let''s work on the amenities list first:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将回到我们的视图。让我们先处理设施列表：
- en: Declare a `template` element inside the `FeatureList` declaration.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FeatureList`声明中声明一个`template`元素。
- en: The template must include the `slot-scope` property to which we assign an alias, `amenity`.
    This alias allows us to access the scoped props.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板必须包含`slot-scope`属性，我们将其分配给一个别名`amenity`。这个别名允许我们访问作用域props。
- en: Inside the template, we can use exactly the same markup we had before to display
    our amenity list items.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中，我们可以使用与以前完全相同的标记来显示我们的设施列表项。
- en: '`resources/views/app.blade.php`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`:'
- en: '[PRE62]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here's the complete main template with prices as well.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含价格的完整主模板。
- en: '`resources/views/app.blade.php`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`:'
- en: '[PRE63]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Although this approach has just as much markup as before, it has delegated more
    common functionality to the component, which makes for a more robust design.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法的标记与以前一样多，但它已经将更常见的功能委托给了组件，这使得设计更加健壮。
- en: Expandable text
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可展开的文本
- en: 'We created functionality back in [Chapter 2](b381aa06-e15c-4cb9-9b8b-4b9421ed73db.xhtml), *Prototyping
    Vuebnb, Your First Vue.js Project*, to allow the About text to be partially contracted
    when the page loads and expanded to its full length by clicking a button. Let''s
    abstract this functionality into a component as well:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](b381aa06-e15c-4cb9-9b8b-4b9421ed73db.xhtml)中创建了功能，*原型Vuebnb，你的第一个Vue.js项目*，允许关于文本在页面加载时部分收缩，并通过点击按钮展开到完整长度。让我们也将这个功能抽象成一个组件：
- en: '[PRE64]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Move all the markup, configuration, and CSS into the new component. Note that
    we use a slot for the text content.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有标记、配置和CSS移入新组件。请注意，我们在文本内容中使用了一个插槽。
- en: '`resources/assets/components/ExpandableText.vue`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/components/ExpandableText.vue`：'
- en: '[PRE65]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Once you've imported this component in `resources/assets/js/app.js`, declare
    it in the main template, remembering to interpolate the `about` data property
    in the slot.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在`resources/assets/js/app.js`中导入了这个组件，在主模板中声明它，记得在插槽中插入`about`数据属性。
- en: '`resource/views/app.blade.php`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`resource/views/app.blade.php`：'
- en: '[PRE66]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: With that done, most of the data and functionality of the Vuebnb client app
    has been abstracted into components. Let's take a look at `resources/assets/js/app.js` and
    see how bare it has become!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 做到这一点后，Vuebnb客户端应用的大部分数据和功能都已经被抽象成了组件。让我们看看`resources/assets/js/app.js`，看看它变得多么简洁！
- en: '`resources/assets/js/app.js`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE67]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Virtual DOM
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟DOM
- en: 'Let''s change tack now and discuss how Vue renders components. Take a look
    at this example:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们改变方向，讨论Vue如何渲染组件。看看这个例子：
- en: '[PRE68]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In order for Vue to be able to render this component to the page, it will first
    transform the template string into a JavaScript object using an internal template
    compiler library:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Vue能够将这个组件渲染到页面上，它将首先使用内部模板编译器库将模板字符串转换为JavaScript对象：
- en: '![](assets/31012e53-0217-44bf-b43c-e5c75c221a59.png)Figure 6.14\. How the template
    compiler turns a template string into an object'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/31012e53-0217-44bf-b43c-e5c75c221a59.png)图6.14。模板编译器如何将模板字符串转换为对象'
- en: Once the template has been compiled, any state or directives can easily be applied.
    For example, if the template includes a `v-for`, a simple for-loop can be used
    to multiply the nodes and interpolate the correct variables.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模板被编译，任何状态或指令都可以很容易地应用。例如，如果模板包括一个`v-for`，可以使用简单的for循环来复制节点并插入正确的变量。
- en: After that, Vue can interface with the DOM API to synchronize the page with
    the state of the component.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，Vue可以与DOM API交互，将页面与组件的状态同步。
- en: Render functions
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染函数
- en: 'Rather than supplying a string template for your component, you can instead
    supply a `render` function. Without understanding the syntax, you can probably
    tell from the following example that the `render` function is generating a semantically
    equivalent template to the string template in the previous example. Both define
    a `div` with an `id` attribute of `my-component` and with inner text of `My component`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 与为组件提供字符串模板不同，你可以提供一个`render`函数。即使不理解语法，你可能也能从以下例子中看出，`render`函数生成了一个与前面例子中的字符串模板在语义上等价的模板。两者都定义了一个带有`id`属性为`my-component`的`div`，并且内部文本为`My
    component`：
- en: '[PRE69]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Render functions are more efficient because they don't require Vue to first
    compile the template string. The downside, though, is that writing a render function
    is not as easy or expressive as markup syntax, and, once you get a large template,
    will be difficult to work with.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染函数更高效，因为它们不需要Vue首先编译模板字符串。不过，缺点是，编写渲染函数不像标记语法那样简单或表达性强，一旦你有了一个大模板，将会很难处理。
- en: Vue Loader
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue Loader
- en: Wouldn't it be great if we could create HTML markup templates in development,
    then get Vue's template compiler to turn them into `render` functions as part
    of the build step? That would be the best of both worlds.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够在开发中创建HTML标记模板，然后让Vue的模板编译器在构建步骤中将它们转换为`render`函数，那将是两全其美的。
- en: 'This is exactly what happens to single-file components when Webpack transforms
    them via *Vue Loader*. Take a look at the following snippet of the JavaScript
    bundle and you can see the `ImageCarousel` component after Webpack has transformed
    and bundled it:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是当Webpack通过*Vue Loader*转换它们时发生在单文件组件中的情况。看一下下面的JavaScript捆绑包片段，你可以看到Webpack在转换和捆绑`ImageCarousel`组件后的情况：
- en: '![](assets/69fddd6b-68ae-49e6-ac7a-940ebb773a41.png)Figure 6.15\. image-carousel
    component in the bundle file'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/69fddd6b-68ae-49e6-ac7a-940ebb773a41.png)图6.15。捆绑文件中的image-carousel组件'
- en: Refactoring the main template as single-file component
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将主模板重构为单文件组件
- en: The template for our app's root instance is the content within the `#app` element
    in the *app* view. A DOM template like this requires the Vue template compiler,
    just like any string template does.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的根实例的模板是*app*视图中`#app`元素内的内容。这样的DOM模板需要Vue模板编译器，就像任何字符串模板一样。
- en: If we were able to abstract this DOM template into an SFC as well, it would
    mean all our frontend app templates would be built as `render` functions and would
    not need to invoke the template compiler at runtime.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够将这个DOM模板抽象成一个SFC，那么我们所有的前端应用模板都将被构建为`render`函数，并且不需要在运行时调用模板编译器。
- en: 'Let''s create a new SFC for the main template and call it `ListingPage`, as
    this part of the app is our listing page:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为主模板创建一个新的SFC，并将其命名为`ListingPage`，因为这部分应用是我们的列表页面：
- en: '[PRE70]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We''ll move the main template, root configuration and any relevant CSS into
    this component. Take note of the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主模板、根配置和任何相关的CSS移到这个组件中。注意以下内容：
- en: We need to put the template inside a wrapping `div` as components must have
    a single root element
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要将模板放在一个包装的`div`中，因为组件必须有一个单一的根元素
- en: We can now remove the `@` escapes as this file won't be processed by Blade
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以删除`@`转义，因为这个文件不会被Blade处理
- en: The component is now adjacent to the other components we created, so be sure
    to change the relative paths of the imports
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在组件与我们创建的其他组件相邻，所以确保更改导入的相对路径
- en: '`resource/assets/components/ListingPage.vue`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`resource/assets/components/ListingPage.vue`：'
- en: '[PRE71]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Mounting the root-level component with a render function
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用渲染函数挂载根级组件
- en: Now the mount element in our main template will be empty. We need to declare
    the `Listing` component, but we don't want to do it in the view.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们主模板中的挂载元素将是空的。我们需要声明`Listing`组件，但我们不想在视图中这样做。
- en: '`resources/views/app.blade.php`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE72]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If we do it like that, we wouldn't fully eliminate all string and DOM templates
    from our app, so we'll keep the mount element empty.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，就无法完全消除应用中的所有字符串和DOM模板，所以我们将保持挂载元素为空。
- en: '`resources/views/app.blade.php`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/views/app.blade.php`：'
- en: '[PRE73]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We can now declare `Listing` with a render function inside our root instance.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在我们的根实例中声明`Listing`并使用渲染函数。
- en: '`resources/assets/js/app.js`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources/assets/js/app.js`：'
- en: '[PRE74]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: To avoid getting side-tracked, I won't explain the syntax of `render` functions
    here, as this is the only one we'll write throughout the book. If you'd like to
    learn more about `render` functions, check out the Vue.js documentation at [https://vuejs.org/](https://vuejs.org/).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免走神，我不会在这里解释`render`函数的语法，因为这是我们在整本书中唯一要编写的函数。如果您想了解更多关于`render`函数的信息，请查看Vue.js文档[https://vuejs.org/](https://vuejs.org/)。
- en: Now that Vuebnb is no longer using string or DOM templates, we don't need the
    template compiler functionality anymore. There's a special build of Vue we can
    use which doesn't include it!
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Vuebnb不再使用字符串或DOM模板，我们不再需要模板编译器功能。有一个特殊的Vue构建可以使用，不包括它！
- en: Vue.js builds
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue.js构建
- en: There are a number of different environments and use cases for running Vue.js.
    In one project, you might load Vue directly in the browser, in another you may
    load it on a Node.js server for the purpose of server rendering. As such, there
    are different *builds* of Vue provided so you can choose the most suitable one.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Vue.js有许多不同的环境和用例。在一个项目中，您可能直接在浏览器中加载Vue，在另一个项目中，您可能在Node.js服务器上加载它，以进行服务器渲染。因此，提供了不同的Vue
    *构建*，以便您可以选择最合适的一个。
- en: 'Looking in the *dist* folder of the Vue NPM package, we can see eight different
    Vue.js builds:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue NPM包的*dist*文件夹中，我们可以看到八个不同的Vue.js构建：
- en: '![](assets/98257a32-3bf0-455f-bd0a-9ebee829d1e9.png)Figure 6.16\. The various
    builds in the node_modules/vue/dist folder'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/98257a32-3bf0-455f-bd0a-9ebee829d1e9.png)图6.16。node_modules/vue/dist文件夹中的各种构建'
- en: 'The Vue.js website provides a table to explain these eight different builds:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js网站提供了一个表格来解释这八个不同的构建：
- en: '|  | UMD | CommonJS | ES Module |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '|  | UMD | CommonJS | ES Module |'
- en: '| --- | --- | --- | --- |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **Full** | vue.js | vue.common.js | vue.esm.js |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| **完整** | vue.js | vue.common.js | vue.esm.js |'
- en: '| **Runtime-only** | vue.runtime.js | vue.runtime.common.js | vue.runtime.esm.js
    |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| **仅运行时** | vue.runtime.js | vue.runtime.common.js | vue.runtime.esm.js |'
- en: '| **Full (production)** | vue.min.js | - | - |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| **完整（生产环境）** | vue.min.js | - | - |'
- en: '| **Runtime-only (production)** | vue.runtime.min.js | - | - |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| **仅运行时（生产环境）** | vue.runtime.min.js | - | - |'
- en: Module system
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块系统
- en: The columns of the table categorize the builds as either *UMD*, *CommonJS*, or *ES
    Module*. We discussed CommonJS and ES modules back in [Chapter 5](f7d2046c-81c6-416b-977e-2f166a911244.xhtml), *Integrating
    Laravel And Vue.js with Webpack*, but we didn't mention **UMD** (**Universal Module
    Definition)**. The main things you need to know about UMD is that it's yet another
    module pattern, and that it works well in a browser. UMD is the choice if you
    are directly linking to Vue in a `script` tag.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的列将构建分类为*UMD*、*CommonJS*或*ES Module*。我们在[第5章](f7d2046c-81c6-416b-977e-2f166a911244.xhtml)中讨论了CommonJS和ES模块，但我们没有提到**UMD**（**通用模块定义**）。关于UMD，您需要知道的主要是它是另一种模块模式，并且在浏览器中运行良好。如果您直接在`script`标签中链接到Vue，UMD就是最佳选择。
- en: Production builds
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产构建
- en: 'The rows of the table are split into two types: full or runtime, and with or
    without production.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的行分为两种类型：完整或运行时，以及带有或不带有生产环境。
- en: A *production* build is used in a deployed app, as opposed to one running in
    development. It has been minified, and any warnings, comments, or other development
    options are turned off or stripped out. The point is to make the build as small
    and secure as possible, which is what you'd want in production.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '*生产*构建用于部署的应用程序，而不是在开发中运行的应用程序。它已经被缩小，并且关闭或剥离了任何警告、注释或其他开发选项。目的是使构建尽可能小和安全，这是您在生产中想要的。'
- en: Note that there is only a UMD version of the production build as only UMD runs
    directly in a browser. CommonJS and ES Module are to be used in conjunction with
    a build tool, like Webpack, which provides its own production processing.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，生产构建只有UMD版本，因为只有UMD可以直接在浏览器中运行。CommonJS和ES模块需要与构建工具一起使用，比如Webpack，它提供了自己的生产处理。
- en: Full build vs runtime-only
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整构建与仅运行时
- en: As we've been discussing, Vue includes a template compiler for converting any
    string or DOM templates to render functions at runtime. The *full* build includes
    the template compiler and is what you would normally use. However, if you've already
    transformed your templates into render functions in development, you can use the *runtime-only* build,
    which drops the compiler and is about 30% smaller!
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，Vue包括一个模板编译器，用于在运行时将任何字符串或DOM模板转换为渲染函数。*完整*构建包括模板编译器，这是您通常会使用的。但是，如果您已经在开发中将模板转换为渲染函数，您可以使用*仅运行时*构建，它不包括编译器，大小约小30％！
- en: Selecting a build
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择构建
- en: A good build for Vuebnb is `vue.runtime.esm.js` since we're using Webpack and
    we don't need the template compiler. We could also use `vue.runtime.common.js`,
    but that wouldn't be consistent with our use of ES modules elsewhere in the project.
    In practice, though, there is no difference as Webpack will process them in the
    same way.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vuebnb来说，一个很好的构建是`vue.runtime.esm.js`，因为我们使用Webpack，不需要模板编译器。我们也可以使用`vue.runtime.common.js`，但这与我们在项目的其他地方使用ES模块不一致。实际上，它们没有区别，因为Webpack会以相同的方式处理它们。
- en: Remember that we include Vue at the top of our entry file with the statement `import
    Vue from 'vue'`. The last `'vue'` is an *alias* to the Vue build that Webpack
    resolves when it runs. Currently, this alias is defined within the default Mix
    configuration and is set to the build `vue.common.js`. We can override that configuration
    by adding the following to the bottom of our `webpack.mix.js` file.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在我们的入口文件顶部包含了Vue的语句`import Vue from 'vue'`。最后的`'vue'`是Webpack运行时解析的Vue构建的*别名*。目前，这个别名在默认的Mix配置中定义，并设置为构建`vue.common.js`。我们可以通过在`webpack.mix.js`文件底部添加以下内容来覆盖该配置。
- en: '`webpack.mix.js`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack.mix.js`：'
- en: '[PRE75]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'After a new build, we should expect to see a smaller bundle size due to the
    template compiler being removed. In the following screenshot, I''ve shown the
    bundle before and after I ran a `dev` build in a separate Terminal tab:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的构建之后，我们应该期望看到由于模板编译器被移除而导致的较小的捆绑包大小。在下面的屏幕截图中，我展示了在单独的终端标签页中运行`dev`构建之前和之后的捆绑包：
- en: '![](assets/21dc9800-03ab-44d0-9134-ac9040b78935.png)Figure 6.17\. The difference
    between bundle sizes after applying the runtime-only build'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17。应用运行时构建后捆绑包大小的差异
- en: Keep in mind that without the template compiler we can no longer provide string
    templates for our components. Doing so will cause an error at runtime. That shouldn't
    be a problem though since we've got the far more powerful option of SFCs.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，没有了模板编译器，我们不能再为我们的组件提供字符串模板。这样做将导致运行时错误。不过，这不应该是一个问题，因为我们有更强大的SFC选项。
- en: Summary
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how components are used to create reusable custom elements.
    We then registered our first Vue.js components, defining them with template strings.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用组件来创建可重用的自定义元素。然后，我们注册了我们的第一个Vue.js组件，并用模板字符串来定义它们。
- en: Next, we looked at component communication with props and custom events. We
    used this knowledge to build an image carousel within the listing page modal window.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用props和自定义事件来进行组件通信。我们利用这些知识在列表页面模态窗口中构建了一个图像轮播。
- en: In the second half of the chapter, we got an introduction to single-file components,
    which we used to refactor Vuebnb into a component-based architecture. We then
    learned how slots can help us make more versatile components by combining parent
    and child content.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下半部分，我们介绍了单文件组件，我们使用它来重构Vuebnb成为基于组件的架构。然后，我们学习了插槽如何帮助我们通过组合父级和子级内容来创建更多功能的组件。
- en: Finally, we saw how the runtime-only build can be used to give a Vue app a smaller
    size.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了如何使用仅运行时构建来使Vue应用程序的大小更小。
- en: In the next chapter, we will make Vuebnb a multi-page app by building a home
    page, and using Vue Router to allow navigation between pages without reloading.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过构建主页并使用Vue Router来实现页面之间的导航而不重新加载，将Vuebnb打造成一个多页面应用程序。
