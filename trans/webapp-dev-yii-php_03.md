# 第三章。TrackStar 应用程序

我们可以继续不断向我们简单的“Hello, World!”应用程序添加 Yii 的功能示例，但这并不会真正帮助理解框架在真实应用程序的上下文中。为了做到这一点，我们需要朝着更接近 Web 开发人员实际需要构建的应用程序类型的方向发展。这正是我们将在本书的其余部分中要做的事情。

在本章中，我们将介绍名为 TrackStar 的项目任务跟踪应用程序。世界上有许多其他项目管理和问题跟踪应用程序，我们的基本功能与许多这些应用程序并无不同。那么，为什么要构建它呢？事实证明，这种基于用户的应用程序具有许多对许多 Web 应用程序都是常见的功能。这将使我们能够实现两个主要目标：

+   展示 Yii 作为我们构建有用功能和征服真实世界 Web 应用程序挑战的不可思议的实用性和功能集

+   提供现实世界的示例和方法，这些方法将立即适用于您的下一个 Web 应用程序项目

# 介绍 TrackStar

TrackStar 是一个软件开发生命周期（SDLC）问题管理应用程序。它的主要目标是帮助跟踪在构建软件应用程序过程中出现的许多问题。它是一个基于用户的应用程序，允许创建用户帐户并在用户经过身份验证和授权后访问应用程序功能。它允许用户添加和管理项目。

项目可以与其关联的用户（通常是项目上工作的团队成员）以及问题相关联。项目问题将是开发任务和应用程序错误等事物。问题可以分配给项目的成员，并且将具有*尚未开始*，*已开始*和*已完成*等状态。通过这种方式，跟踪工具可以准确描述项目的情况，包括已完成的工作，当前正在进行的工作以及尚未开始的工作。

# 创建用户故事

简单的用户故事是识别应用程序必要功能功能的好方法。用户故事以最简单的形式陈述用户可以使用软件做什么。它们应该从简单开始，并随着您深入了解每个功能周围的细节而变得更加复杂。我们的目标是从足够的复杂性开始，以便我们可以开始。如果有必要，我们将稍后添加更多细节。

我们简要介绍了在这个应用程序中扮演重要角色的三个主要实体，即*用户*，*项目*和*问题*。这些是我们的主要领域对象，在这个应用程序中非常重要。所以让我们从它们开始。

## 用户

TrackStar 是一个基于用户的 Web 应用程序。在高层次上，用户可以处于两种用户状态中的一种。

+   匿名

+   经过身份验证

匿名用户是应用程序的任何未经过登录过程认证的用户。匿名用户只能访问注册新帐户或登录。所有其他功能将受限于经过身份验证的用户。

经过身份验证的用户是通过登录过程提供有效身份验证凭据的用户。换句话说，经过身份验证的用户是已登录的用户。经过身份验证的用户将可以访问应用程序的主要功能功能，如创建和管理项目以及项目问题。

## 项目

管理项目是 TrackStar 应用程序的主要目的。项目代表一个由应用程序的一个或多个用户实现的一般高层目标。项目通常被分解为更细粒度的任务或问题，这些任务或问题代表需要采取的更小步骤以实现整体目标。

举个例子，让我们以本书中将要做的事情为例，即构建一个项目和问题跟踪管理应用程序。不幸的是，我们无法使用尚未创建的应用程序来帮助我们跟踪其自身的开发，但如果可以的话，我们可能会创建一个名为“构建 TrackStar 项目/问题管理工具”的项目。该项目将被细分为更详细的项目问题，例如“创建登录界面”，“为问题设计数据库模式”等等。

经过身份验证的用户可以创建新项目。账户内项目的创建者将在该项目中拥有称为**项目所有者**的特殊角色。项目所有者有权编辑和删除这些项目，以及向项目添加新成员。除项目所有者之外与项目相关的其他用户简称为**项目成员**。项目成员将有添加新问题以及编辑现有问题的权限。

## 问题

项目问题将被分类为三个类别之一：

+   **特性**：代表要添加到应用程序中的实际功能的项目。例如，登录功能的实施。

+   **任务**：代表需要完成的工作，但不是软件的实际功能。例如，设置构建和集成服务器。

+   **错误**：代表应用程序行为不如预期工作的项目。例如，账户注册表格未验证输入电子邮件地址的格式。

问题可以处于以下三种状态之一：

+   尚未开始

+   已开始

+   已完成

项目成员可以向项目添加新问题，以及编辑和删除它们。他们可以将问题分配给自己或其他项目成员。

目前，这些三个主要实体的信息足够让我们继续前进。我们可以详细了解“账户注册具体包括什么？”或者“如何向项目添加新任务？”但我们已经概述了足够的规格以开始这些基本功能。随着实施的进行，我们将确定更详细的细节。

但在我们开始之前，我们应该记下一些基本的导航和应用程序工作流程。这将帮助每个人更好地理解我们正在构建的应用程序的一般布局和流程。

# 导航和页面流程

总是很好地概述应用程序中的主要页面，并查看它们如何配合。这将帮助我们快速确定一些需要的 Yii 控制器、操作和视图，以及帮助设定每个人对我们在开发初期将要构建的期望。

以下图表显示了基本的应用程序流程，从登录到项目详情列表：

![导航和页面流程](img/8727_03_01.jpg)

当用户首次进入应用程序时，他们必须先登录并进行身份验证，然后才能继续使用任何功能。成功登录后，他们将看到他们当前项目的列表，以及创建新项目的功能。选择特定项目将带他们进入项目详情页面。项目详情页面将展示按类型列出的问题列表。还可以添加新问题，以及编辑列出的任何问题。

这都是非常基本的功能，但这个图表为我们提供了关于应用程序如何组合在一起的更多信息，并且让我们更好地开始确定我们需要的模型、视图和控制器。它还允许与他人分享一些可视化的东西，以便每个参与者对我们正在努力实现的目标有相同的*理解*。根据我的经验，几乎每个人在首次思考新应用程序时都更喜欢图片而不是书面规格。

# 数据关系

我们在开始朝着这些规格构建之前，仍然需要更多地考虑我们将要处理的数据。如果我们从系统中挑选出所有的主要名词，我们可能会得到一个相当不错的领域对象列表，通过使用活动记录，我们想要建模的数据也会得到延伸。我们之前概述的用户故事确定了以下内容：

+   一个用户

+   一个项目

+   一个问题

基于这一点以及用户故事和应用程序工作流程图中提供的其他细节，我们在以下图表中展示了对必要数据模型的第一次尝试：

![数据关系](img/8727_03_02.jpg)

这是一个非常基本的对象模型，概述了我们的主要数据实体、它们各自的属性以及它们之间的一些关系。在项目和用户对象之间的线的两侧的 1..*和 0..*表示它们之间存在多对多的关系。一个用户可以与零个或多个项目相关联，一个项目可以有一个或多个用户。同样地，我们表示了一个项目可以有零个或多个与之相关的问题，而一个问题只属于一个特定的项目。此外，一个用户可以是许多问题的所有者（或请求者），但一个问题只有一个所有者（也只有一个请求者）。

在这个阶段，我们尽可能地保持属性的简单。用户需要用户名和密码才能通过登录界面。项目只有一个名称属性。

根据我们目前所知的信息，问题具有最多的相关信息。正如在之前定义的用户故事中简要讨论的，问题将具有一个类型属性，用于区分一般类别（错误、功能或任务）。它们还将具有一个状态属性，用于指示正在处理的问题的进展。将有一个已登录的用户最初创建问题；这是请求者。一旦系统中的用户被分配来处理问题，他们将成为问题的所有者。我们还定义了描述属性，以允许输入问题的一些描述性文本。

请注意，我们还没有明确讨论模式或数据库。事实上，直到我们仔细考虑从数据角度真正需要什么，我们才会知道用来存储这些数据的正确工具。文件系统上的平面文件是否和关系数据库一样有效？我们是否需要持久化数据？

在这个早期规划阶段，这些问题的答案并不总是必要的。更好的是，更专注于我们想要的功能以及支持这些功能所需的数据类型。在与其他项目利益相关者讨论这些想法之后，我们可以转向明确的技术实施细节，以确保我们走在正确的道路上。其他项目利益相关者包括所有参与这个开发项目的人。这可能包括客户，如果你为别人构建应用程序，以及其他开发团队成员、产品/项目经理等等。从“团队”中获得一些反馈来帮助验证方法和所做的任何假设总是一个好主意。

在我们的情况下，确实没有其他人参与这个开发工作。因此，我们可以快速得出一些结论来回答我们与数据相关的问题，并继续我们的应用程序开发。

由于这是一个基于 Web 的应用程序，并且考虑到我们需要存储、检索和操作的信息的性质，我们可以得出结论，最好将数据持久化在这个应用程序中。此外，基于我们想要捕获和管理的数据类型之间存在的关系，存储这些数据的一个良好方法是使用关系数据库。基于其易用性、优秀的价格点、在 PHP 应用程序开发人员中的普遍受欢迎程度以及与 Yii 框架的兼容性，我们将使用 MySQL 作为特定的数据库服务器。

现在我们已经了解了我们将要开始构建的内容以及我们将如何开始构建它的足够信息，让我们开始吧。

# 创建新应用程序

首先，让我们先创建初始的 Yii Web 应用程序。我们已经在第二章中看到了这是多么容易实现，*入门*。就像我们在那里所做的那样，我们将假设以下内容：

+   `YiiRoot`是您安装 Yii 的目录

+   `WebRoot`被配置为您的 Web 服务器的文档根目录（即`http://localhost/`解析到的位置）

因此，从命令行，切换到您的`WebRoot`目录并执行以下操作：

```php
**% YiiRoot/framework/yiic webapp trackstar**
**Create a Web application under '/Webroot/trackstar'? [Yes|No] Yes**

```

这为我们提供了我们的骨架目录结构和开箱即用的工作应用程序。您应该能够通过导航到`http://localhost/trackstar/index.php?r=site/index`来查看这个新应用程序的主页。

### 注意

因为我们的默认控制器是 SiteController，该控制器中的默认操作是`actionIndex()`，所以我们也可以在不指定路由的情况下导航到相同的页面。

# 连接到数据库

现在我们的骨架应用程序已经运行起来了，让我们开始着手正确地连接到数据库。事实上，骨架应用程序已自动配置为使用数据库。使用`yiic`工具的副产品是，我们的新应用程序配置为使用 SQLite 数据库。如果您在`protected/config/main.php`中的主应用程序配置文件中查看，您将在文件的中间位置看到以下声明：

```php
'db'=>array('connectionString' => 'sqlite:'.dirname(__FILE__).'/../data/testdrive.db',
    ),
```

您还可以验证`protected/data/testdrive.db`的存在，这是配置要使用的 SQLite 数据库。

由于我们已经决定使用 MySQL，我们需要进行一些配置更改。但是，在我们改变配置以使用 MySQL 数据库服务器之前，让我们简要讨论一下 Yii 和数据库更一般的情况。

## Yii 和数据库

Yii 为数据库编程提供了很好的支持。 Yii 的**数据访问对象**（**DAO**）是建立在**PHP 数据对象**（**PDO**）扩展（[`php.net/pdo`](http://php.net/pdo)）之上的。这是一个数据库抽象层，使应用程序能够通过一个与数据库无关的接口与数据库交互。所有支持的**数据库管理系统**（**DBMS**）都封装在一个统一的接口后面。这样，代码可以保持与数据库无关，使用 Yii DAO 开发的应用程序可以轻松地切换到使用不同的 DBMS，而无需进行修改。

要与支持的 DBMS 建立连接，您可以简单地创建一个新的`CDbConnection`实例：

```php
$connection=new CDbConnection($dsn,$username,$password);
```

这里`$dsn`变量的格式取决于所使用的特定 PDO 数据库驱动程序。一些常见的格式包括：

+   SQLite：`sqlite:/path/to/dbfile`

+   MySQL：`mysql:host=localhost;dbname=testdb`

+   PostgreSQL：`pgsql:host=localhost;port=5432;dbname=testdb`

+   SQL Server：`mssql:host=localhost;dbname=testdb`

+   Oracle：`oci:dbname=//localhost:1521/testdb`

`CDbConnection`还继承自`CApplicationComponent`，这使它可以被配置为应用程序组件。这意味着我们可以将其添加到应用程序的 components 属性中，并在主配置文件中自定义类和属性值。这是我们首选的方法，接下来我们将详细介绍。

#### 将 db 连接添加为应用程序组件

让我们快速回顾一下。当我们创建初始应用程序时，我们指定了应用程序类型为 Web 应用程序。记住我们在命令行上指定了`webapp`。这样做指定了每个请求创建的应用程序单例类的类型为`CWebApplication`。这个 Yii 应用程序单例是所有请求处理运行的执行上下文。它的主要任务是解析用户请求并将其路由到适当的控制器进行进一步处理。这在第一章中使用的图表中表示为 Yii 应用程序路由器，*Meet Yii*，当我们介绍请求路由时。它还作为保存应用程序级配置值的中心位置。

要自定义我们的应用程序配置，通常我们会提供一个配置文件来初始化应用程序实例创建时的属性值。主应用程序配置文件位于`/protected/config/main.php`。这是一个包含键值对数组的 PHP 文件。每个键代表应用程序实例的属性名称，每个值是相应属性的初始值。如果您打开这个文件，您会看到已经为我们配置了几个设置。

向配置中添加应用程序组件很容易。打开文件（`/protected/config/main.php`）并找到组件属性。

我们可以看到已经有条目指定了`log`和`user`应用程序组件。这些将在后续章节中介绍。我们还可以看到（正如我们之前注意到的），还有一个`db`组件，配置为使用 SQLite 连接到位于`protected/data/testdrive.db`的 SQLite 数据库。还有一个被注释掉的部分，定义了这个`db`组件使用 MySQL 数据库。我们所需要做的就是删除 SQLite `db`组件定义，取消注释定义 MySQL 组件的部分，然后进行相应的更改以匹配您的数据库名称、用户名和密码，以便进行连接。以下代码显示了这个更改：

```php
// application components
  'components'=>array(
    …
    //comment out or remove the reference to the sqlite db
/*
'db'=>array(
      'connectionString' => 'sqlite:'.dirname(__FILE__).'/../data/testdrive.db',
    ),
*/
    // uncomment the following to use a MySQL database
        'db'=>array(
      'connectionString' => 'mysql:host=localhost;dbname=trackstar',
      'emulatePrepare' => true,
      'username' => '[your-db-username]',
      'password' => '[your-db-password]',
      'charset' => 'utf8',
    ),
```

这假设已经创建了一个名为`trackstar`的 MySQL 数据库，并且可以使用 localhost 连接。根据您的环境，您可能需要指定`127.0.0.1`而不是`localhost`作为 localhost 的 IP。将其作为应用程序组件的一个巨大好处是，现在在我们的应用程序的任何地方，我们可以简单地将数据库连接引用为主 Yii 应用程序`Yii::app()->db`的属性。同样，我们可以将其用作`config`文件中定义的任何其他组件的引用。

### 注意

当`charset`属性设置为`'utf8'`时，它设置了数据库连接使用的字符集。这个属性只用于 MySQL 和 PostgreSQL 数据库。它将默认为 null，这意味着它将使用默认字符集。我们在这里设置它是为了确保我们的 PHP 应用程序正确支持`utf8` unicode 字符。

`emulatePrepare => true`配置将 PDO 属性（PDO::ATTR_EMULATE_PREPARES）设置为`true`，如果您使用的是 PHP 5.1.3 或更高版本，则建议这样做。这是在 PHP 5.1.3 中添加的，当使用时，会导致使用 PDO 本机查询解析器而不是 MySQL 客户端中的本机准备语句 API。MySQL 客户端中的本机准备语句无法利用查询缓存，因此已知会导致性能不佳。PDO 本机查询解析器可以使用查询缓存，因此建议在可用时使用此选项（PHP 5.1.3 或更高版本）。

因此，我们已指定了一个名为`trackstar`的 MySQL 数据库，以及连接到该数据库所需的用户名和密码。我们没有向您展示如何在 MySQL 中创建这样的数据库。我们假设您了解如何设置 MySQL 数据库以及如何使用它。如果您不确定如何创建名为`trackstar`的新数据库，并为连接配置用户名和密码，请参考您特定的数据库文档。

# 测试数据库连接

在继续之前，我们应该确保我们的数据库连接实际上是有效的。我们可以通过几种方式来做到这一点。我们将看两种方法。在第一种方法中，我们将使用`yiic`命令行工具启动应用程序的交互式 shell，并确保在尝试引用应用程序`db`组件时没有错误。然后我们将提供第二种方法，介绍 Yii 中使用 PHPUnit 进行单元测试。

## 使用交互式 shell

我们将从使用 Yii 交互式 shell 开始进行简单测试。您可能还记得，我们使用`webapp`命令以及`yiic`命令行实用程序来创建我们的新应用程序。与此实用程序一起使用的另一个命令是`shell`。这允许您直接从命令行在 Yii 应用程序的上下文中运行 PHP 命令。

要启动 shell，请导航到应用程序的根目录，即包含`index.php`入口脚本`Webroot/trackstar/`的目录。然后运行`yiic`实用程序，将`shell`作为命令传递（参考以下截图）。

![使用交互式 shell](img/8727_03_03.jpg)

这将启动 shell，并允许您在**>>**提示之后直接输入命令。

我们要做的是测试我们的连接，确保我们的数据库连接应用程序组件是可访问的。我们可以简单地`echo`出连接字符串，并验证它是否返回我们在配置中设置的内容。因此，从 shell 提示符中输入以下内容：

```php
**>> echo Yii::app()->db->connectionString;**

```

它应该回显类似于以下内容：

**mysql:host=localhost;dbname=trackstar**

这表明`db`应用程序组件已正确配置并可供我们的应用程序使用。

## 自动化测试-单元和功能测试

收集反馈对应用程序开发至关重要；来自应用程序用户和其他项目利益相关者的反馈，来自开发团队成员的反馈，以及来自软件本身的直接反馈。以一种允许软件在出现故障时告诉您的方式开发软件，可以将与集成和部署应用程序相关的恐惧转化为无聊。您可以赋予软件这种反馈机制的方法是编写自动化单元和功能测试，然后重复并经常执行它们。

### 单元和功能测试

单元测试是为了向开发人员提供代码是否正确执行的验证。功能测试是为了向开发人员以及其他项目利益相关者提供应用程序是否以正确方式执行的验证。

#### 单元测试

单元测试是专注于软件应用程序中最小单元的测试。在面向对象的应用程序中，比如 Yii web 应用程序，最小的单元是构成类接口的公共方法。单元测试应该专注于一个单一的类，不需要其他类或对象来运行。它们的目的是验证单元代码是否按预期工作。

#### 功能测试

功能测试专注于测试应用程序的端到端功能功能。这些测试存在于比单元测试更高的级别，并且通常需要多个类或对象来运行。它们的目的是验证应用程序的特定功能是否按预期工作。

## 测试的好处

编写单元测试和功能测试有许多好处。首先，它们是提供文档的好方法。单元测试可以快速告诉代码块存在的确切原因。同样，功能测试记录了应用程序中实现的功能。如果您坚持编写这些测试，那么随着应用程序的发展，文档将自然而然地不断发展。

它们还是一种宝贵的反馈机制，不断向开发人员和其他项目利益相关者保证代码和应用程序按预期工作。每次对代码进行更改时都运行测试，并立即获得反馈，告诉您是否无意中更改了系统的预期行为。然后您可以立即解决这些问题。这确实增加了开发人员对应用程序的信心，并转化为更少的错误和更成功的项目。

这种即时反馈也有助于促进变革和改进代码的设计。如果一套测试能够立即提供反馈，告诉开发人员所做的更改是否改变了应用程序的行为，开发人员更有可能对现有代码进行改进。单元测试和功能测试套件提供的信心使开发人员能够编写更好的软件，发布更稳定的应用程序，并交付高质量的产品。

## Yii 中的测试

从 1.1 版本开始，Yii 与 PHPUnit ([`www.phpunit.de/`](http://www.phpunit.de/))和 Selenium Remote Control ([`seleniumhq.org/projects/remote-control/`](http://seleniumhq.org/projects/remote-control/))测试框架紧密集成。您可以使用任何可用的测试框架测试 Yii PHP 代码。但是，Yii 与前述两个框架的紧密集成使事情变得更加容易。使事情变得容易是我们的主要目标之一。

当我们使用`yiic webapp`控制台命令创建新的 Web 应用程序时，我们注意到许多文件和目录会自动为我们创建。其中与编写和执行自动化测试相关的是以下内容：

| 文件/目录 | 包含/存储 |
| --- | --- |
| `trackstar/` | 包含文件/目录列出的所有文件 |
| `protected/` | 受保护的应用程序文件 |
| `tests/` | 应用程序的测试 |
| `fixtures/` | 数据库固定装置 |
| `functional/` | 功能测试 |
| `unit/` | 单元测试 |
| `report/` | 覆盖率报告 |
| `bootstrap.php` | 在测试开始时执行的脚本 |
| `phpunit.xml` | PHPUnit 配置文件 |
| `WebTestCase.php` | 用于基于 Web 的功能测试的基类 |

您可以将测试文件放入三个主要目录，即`fixtures`、`functional`和`unit`。`report`目录用于存储生成的代码覆盖率报告。

### 注意

必须安装 PHP 扩展 XDebug 才能生成报告。有关此安装的详细信息，请参阅[`xdebug.org/docs/install`](http://xdebug.org/docs/install)。此示例不需要此扩展。

## 单元测试

在 Yii 中，单元测试是以扩展自框架类`CTestCase`的 PHP 类编写的。约定规定它的名称应为`AbcTest`，其中`Abc`被要测试的类的名称替换。例如，如果我们要测试第二章中的“Hello, World!”应用程序中的`MessageController`类，我们将命名测试类为`MessageControllerTest`。这个类保存在`protected/tests/unit/`目录下的名为`MessageControllerTest.php`的文件中。

测试类主要有一组名为`testXyz`的测试方法，其中`Xyz`通常与您编写测试的方法名称相同。

继续使用`MessageController`示例，如果我们正在测试`actionHelloworld()`方法，我们将在`MessageControllerTest`类中命名相应的测试方法为`testActionHelloworld()`。

### 安装 PHPUnit

从 1.1 版本开始，Yii 与 PHPUnit（[`www.phpunit.de/`](http://www.phpunit.de/)）测试框架紧密集成。

为了跟随这个示例，您需要安装 PHPUnit。这应该使用 Pear Installer 完成。（有关 Pear 的更多信息，请参阅[`pear.php.net/`](http://pear.php.net/)。）请访问以下网址，了解如何根据您的环境配置安装 PHPUnit 的更多信息：

[`github.com/sebastianbergmann/phpunit/`](https://github.com/sebastianbergmann/phpunit/)

### 注意

本书的范围当然不包括具体介绍 PHPUnit 的测试功能。建议您花些时间阅读文档，了解术语和编写基本单元测试的感觉：[`github.com/sebastianbergmann/phpunit/`](https://github.com/sebastianbergmann/phpunit/)

## 测试连接

假设您已成功安装了 PHPUnit，我们可以在`protected/tests/unit/`下为我们的数据库连接添加一个测试。让我们在这个目录下创建一个名为`DbTest.php`的简单数据库连接性测试文件。添加以下内容的新文件：

```php
<?php
class DbTest extends CTestCase
{  
     public function testConnection()
     {
        $this->assertTrue(true);
     }
}
```

在这里，我们添加了一个相当琐碎的测试。`assertTrue()`方法是 PHPUnit 的一部分，它是一个断言，如果传递给它的参数为`true`，则会通过，如果为`false`，则会失败。在这种情况下，它正在测试`true`是否为`true`。因此，这个测试肯定会通过。我们这样做是为了确保我们的新应用程序按预期工作，用于 PHPUnit 测试。转到 tests 文件夹并执行这个新测试：

```php
**%cd /WebRoot/trackstar/protected/tests**
**%phpunit unit/DbTest.php**

 …
 Time: 0 seconds, Memory: 10.00Mb

 OK (1 test, 1 assertion)
```

### 注意

如果由于某种原因此测试在您的系统上失败，您可能需要更改`protected/tests/bootstrap.php`，以便变量`$yiit`正确指向您的`/YiiRoot/yiit.php`文件。

确信我们的测试框架在新创建的 TrackStar 应用程序中按预期工作，我们可以使用它来为`db`连接编写测试。

将`testConnection()`测试方法中的`assertEquals(true)`语句更改为：

```php
$this->assertNotNull(Yii::app()->db->connectionString); 
```

然后重新运行测试：

```php
**%phpunit unit/DbTest.php**

	 …
	 Time: 0 seconds, Memory: 10.00Mb

	 OK (1 test, 1 assertion)

```

如您所记得的，由于我们将数据库连接配置为名为`db`的应用程序组件，`Yii::app()->db`应返回`CDbConnection`类的实例。如果应用程序未能建立数据库连接，此测试将返回错误。由于测试仍然通过，我们可以放心地继续，确保数据库连接已正确设置。

# 总结

本章介绍了任务跟踪应用程序 TrackStar，我们将在本书的其余部分中开发。我们讨论了应用程序是什么以及它的功能，并以非正式用户故事的形式提供了一些高级需求。然后，我们确定了一些需要创建的主要领域对象，以及解决一些需要存储和管理的数据。

然后，我们迈出了构建 TrackStar 应用程序的第一步。我们创建了一个新的应用程序，其中包含从自动生成的代码中“免费”获得的所有工作功能。我们还配置了我们的应用程序连接到 MySQL 数据库，并演示了测试该连接的两种方法。一种方法演示了 Yii 与 PHPUnit 的集成以及如何为 Yii 应用程序编写自动化测试。

在下一章中，我们将最终开始深入研究更复杂的功能。我们将开始进行一些实际的编码，以实现在应用程序中管理项目实体所需的功能。
