- en: Chapter 6.  Real-Life Monads
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。现实生活中的单子
- en: In the previous chapter, we covered a lot of theoretical ground concerning various
    abstractions, leading us to the concept of monads. It is now time to apply this
    knowledge by presenting a few instances of monads that will prove useful in your
    day-to-day coding.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们涵盖了关于各种抽象的许多理论基础，引导我们到单子的概念。现在是时候应用这些知识，通过介绍一些单子的实例，这些实例将在您日常编码中证明有用。
- en: Each part will start with an introduction to the issue solved by the given monad,
    followed by some examples of usage so that you can gain some practice. As explained
    at the end of this introduction, the implementation itself won't be present in
    the book to concentrate on usage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分都将以解决给定单子的问题的介绍开始，然后是一些用法示例，以便您可以获得一些实践。正如本介绍末尾所解释的那样，书中不会呈现实现本身，而是集中于用法。
- en: As you will see, once you get the theory out of the way, most implementation
    will seem pretty natural to you. Also, the usefulness extends beyond the realm
    of functional programming. Most of what we will learn in this chapter can be applied
    in any development context.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将看到的，一旦理论问题解决了，大多数实现对您来说将会显得非常自然。此外，其实用性不仅限于函数式编程的范围。本章中学到的大部分内容都可以应用于任何开发环境。
- en: Most of the monads that will be presented relate to the management of side effects,
    or rather affects once they are explicitly contained inside a Monad. When doing
    functional programming, a side effect is unwanted. Once contained, we can control
    them so that they are merely effects of our program.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将要介绍的大多数单子都与副作用的管理有关，或者说一旦它们明确包含在单子中就是影响。在进行函数式编程时，副作用是不受欢迎的。一旦包含，我们就可以控制它们，使它们仅仅成为我们程序的影响。
- en: Monads are used for mainly two reasons. The first is that they are great to
    perform flow control, as already explained in the last chapter. The second is
    that their structure allows you to easily encapsulate effects and protect the
    rest of your code from the impurity.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 单子主要用于两个原因。第一个是它们非常适合执行流程控制，正如在上一章中已经解释的那样。第二个是它们的结构允许您轻松地封装效果并保护代码的其余部分免受杂质的影响。
- en: However, let's keep in mind that this is only one of the possible uses of a
    monad. You can do much more with the concept. But let's not get ahead of ourselves;
    we will discover that along the way.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们记住，这只是单子的一个可能用途。您可以用这个概念做更多的事情。但是让我们不要过于急躁；我们将在途中发现这一点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Monadic helper methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单子辅助方法
- en: The Maybe and Either monads
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maybe和Either单子
- en: The List monad
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: List单子
- en: The Writer monad
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Writer单子
- en: The Reader monad
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reader单子
- en: The State monad
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: State单子
- en: The IO monad
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IO单子
- en: 'In order to concentrate on using monads, and since the implementation is often
    not the most important part, we will use the ones provided by the **PHP Functional**
    library. Obviously, important implementation details will be highlighted in the
    book. You can install it in your project using the `composer` invocation:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了专注于使用单子，并且由于实现通常不是最重要的部分，我们将使用**PHP Functional**库提供的单子。显然，重要的实现细节将在书中突出显示。您可以使用“composer”调用在您的项目中安装它。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It is important to note that the `php-functional` library''s author made some
    other choices concerning the naming of the methods and some implementation details:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，“php-functional”库的作者在方法命名和一些实现细节方面做出了其他选择：
- en: The `apply` method is simply `ap`
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “apply”方法简单地是“ap”
- en: The `unit` and `return` keywords are replaced by `of` in the class
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “unit”和“return”关键字在类中被“of”替换
- en: The inheritance tree is a bit different, for example, there are `Pointed` and
    `Chain` interfaces
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承树有点不同，例如，有“Pointed”和“Chain”接口
- en: The library uses traits for shared code
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库使用特征来共享代码
- en: Some helper functions are implemented outside of the class and need to be imported
    separately
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些辅助函数是在类外实现的，需要单独导入
- en: Monadic helper methods
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单子辅助方法
- en: In the previous chapter, we spoke about the `flatten` method and how it can
    be used to compress multiple nested levels of the same monad instance. This function
    is often spoken about because it can be used to rewrite the monad in another light.
    There are, however, other helpful helpers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们谈到了“flatten”方法以及它如何用于压缩相同单子实例的多个嵌套级别。这个函数经常被提及，因为它可以用于以另一种方式重写单子。然而，还有其他有用的辅助函数。
- en: The filterM method
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: filterM方法
- en: 'Filtering is a key concept in functional programming, but what if our filter
    functions return a monad instead of a simple Boolean value? This is what the `filterM`
    method is for. Instead of expecting a predicate that returns a simple Boolean
    value, the `filterM` method will use any predicate that can be converted to a
    Boolean and also wrap the resulting collection in the same monad:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤是函数式编程中的一个关键概念，但是如果我们的过滤函数返回的是一个单子而不是一个简单的布尔值呢？这就是“filterM”方法的用途。该方法不是期望返回一个简单的布尔值的谓词，而是使用任何可以转换为布尔值并且还将结果集合包装在相同单子中的谓词：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The implementation is a bit hard to follow, so I''ll try to explain what is
    going on:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实现有点难以理解，所以我会尝试解释发生了什么：
- en: First, we need to have the information about the monad we are working with,
    so we extract the first element of our collection and get the monad from it by
    applying the callback.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要了解我们正在处理的单子的信息，因此我们提取我们的集合的第一个元素，并通过应用回调函数从中获取单子。
- en: We then declare a closure around the monad and the predicate.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们声明一个围绕单子和谓词的闭包。
- en: The closure first tests whether the collection is empty. If this is the case,
    we return an instance of the monad containing an empty array. Otherwise, we run
    the predicate on the first element of the collection.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 闭包首先测试集合是否为空。如果是这种情况，我们将返回一个包含空数组的单子实例。否则，我们将在集合的第一个元素上运行谓词。
- en: We bind a closure holding the current value to the resulting monad containing
    a Boolean.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将一个包含当前值的闭包绑定到包含布尔值的结果单子上。
- en: The second closure recursively traverses the whole array, if needed.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个闭包递归地遍历整个数组，如果需要的话。
- en: Once we are on the last element, we bind a new closure that will use the Boolean
    to add the value to the accumulator or not.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们到达最后一个元素，我们就会绑定一个新的闭包，它将使用布尔值将值添加到累加器中，或者不添加。
- en: 'This is not easy stuff, but as it is mostly internal plumbing, made more difficult
    by PHP''s lack of syntactic sugar, understanding everything is not necessary at
    all. For comparison, here is the same code implemented using Haskell pattern matching
    and *do notation* features:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不容易，但由于它主要是内部管道工作，再加上PHP缺乏语法糖，理解一切并不是必要的。为了比较，这里是使用Haskell模式匹配和*do notation*功能实现的相同代码：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, this is a bit easier to read. I think anyone would be able to
    understand what is going on. Unfortunately, in PHP, we have to create nested inner
    functions to achieve the same results. This is, however, not really a concern,
    since the resulting function is fairly easy to use. The inner working of some
    functional patterns might, however, sometimes a bit gruesome in PHP and not perfectly
    functional themselves.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这样更容易阅读。我认为任何人都能理解发生了什么。不幸的是，在PHP中，我们必须创建嵌套的内部函数才能实现相同的结果。然而，这并不是真正的问题，因为最终的函数非常容易使用。然而，一些功能模式的内部工作有时在PHP中可能有点令人不快，并且它们本身并不完全功能。
- en: Examples will follow as we discover some monads. An implementation of this helper
    is available in the `php-functional` library.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们发现一些单子，例子将随之而来。这个辅助函数的实现在`php-functional`库中可用。
- en: The foldM method
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: foldM方法
- en: 'The `foldM` method is the monadic version of the `fold` method. It takes a
    function that returns a monad and then produces a value that is also a monad.
    The accumulators and collection are, however, simple values:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`foldM`方法是`fold`方法的单子版本。它接受一个返回单子的函数，然后产生一个也是单子的值。然而，累加器和集合都是简单的值：'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The implementation is a tad smaller than the one for the `filterM` method because
    we only need to recurse; no transformation from Boolean to the value needs to
    happen. Again, we will show a few examples in the following parts of the chapter
    and an implementation is also available in the `php-funcational` library.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现比`filterM`方法的实现要小一点，因为我们只需要递归；不需要从布尔值到值的转换。同样，我们将在本章的后续部分展示一些例子，并且`php-funcational`库中也有实现。
- en: Closing words
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束语
- en: There exist multiple other functions that can be enhanced to be used with monadic
    values. For example, you can have the `zipWithM` method, which merges two collections
    using a merge function returning a monad. The `php-functional`library has an implementation
    of `mcompose` which allows you to compose functions returning the same monad instance.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多个其他函数可以增强为与单子值一起使用。例如，您可以使用`zipWithM`方法，它使用返回单子的合并函数合并两个集合。`php-functional`库有一个`mcompose`的实现，它允许您组合返回相同单子实例的函数。
- en: When you discover some kind of recurring pattern when you are using monads,
    don't hesitate to factor it into a helper function. It will probably come in handy
    more often than not.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在使用单子时发现某种重复模式时，不要犹豫将其因式分解为辅助函数。它可能经常会派上用场。
- en: Maybe and Either monads
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maybe和Either单子
- en: You should already be well aware of the Maybe and Either types we have discussed
    multiple times already. We first defined them, then we learned that they are in
    fact perfect examples of a functor.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经非常清楚我们已经多次讨论过的Maybe和Either类型。我们首先定义了它们，然后我们了解到它们实际上是一个函子的完美例子。
- en: We will now go even further and define them as monads, so we will be able to
    use them in even more situations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将更进一步，将它们定义为单子，这样我们将能够在更多情况下使用它们。
- en: Motivation
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The `Maybe` monad represents the idea that a sequence of computation can, at
    anytime, stop returning a meaningful value using the `Nothing` class we defined
    in an earlier chapter. It's particularly useful when chain of transformations
    depend on one another and where some step may fail to return a value. It allows
    us to avoid the dreaded `null` checks that often come with such a situation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maybe`单子代表了一种计算序列随时可能停止返回有意义值的想法，使用我们在前一章中定义的`Nothing`类。当转换链相互依赖并且某些步骤可能无法返回值时，它特别有用。它允许我们避免通常伴随这种情况的可怕的`null`检查。'
- en: The `Either` monad has mostly the same motivation. The slight difference is
    that the steps usually either throw an exception or return an error instead of
    an empty value. The fact that the operation fails entails that we need to store
    an error message symbolized by the `Left` value instead of the `Nothing` value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either`单子大部分具有相同的动机。微小的区别在于步骤通常要么抛出异常，要么返回错误，而不是空值。操作失败意味着我们需要存储由`Left`值表示的错误消息，而不是`Nothing`值。'
- en: Implementation
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: The code for both Maybe and Either types can be found in `php-functional` library.
    The implementation is pretty straightforward-the major difference from our own
    previous implementation is that methods such as `isJust` and `isNothing` are missing,
    and that instances are constructed using helper functions instead of static factories.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Maybe和Either类型的代码可以在`php-functional`库中找到。实现非常简单-与我们自己先前的实现的主要区别是缺少`isJust`和`isNothing`等方法，并且实例是使用辅助函数构造而不是静态工厂。
- en: It is important to note that the Either monad as implemented in `php-functional`
    library sadly does not take care of catching exceptions itself. The functions
    you are either applying or binding to it must take care to do so correctly themselves.
    You can also use the `tryCatch` helper function to do so for you.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`php-functional`库中实现的Either单子不幸地没有自己处理捕获异常。您要么应用的函数，要么绑定到它的函数必须自行正确处理异常。您还可以使用`tryCatch`辅助函数来为您执行此操作。
- en: Examples
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子
- en: To get a better grasp of how `Maybe` monad works, let's have a look at a few
    examples. `php-functional` library uses helper functions instead of static methods
    on the class to create new instances. They live in the `Widmogrod\Monad\Maybe`
    namespace.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解`Maybe`单子的工作原理，让我们看一些例子。`php-functional`库使用辅助函数而不是类上的静态方法来创建新实例。它们位于`Widmogrod\Monad\Maybe`命名空间中。
- en: 'Another really useful helper is the `maybe` method, which is a curryied with
    the following signature-the `maybe($default, callable $fn, Maybe $maybe)` namespace.
    When called, it will first try to extract the value from `$maybe` variable, defaulting
    to a `$default` variable. It will then be passed as a parameter to `$fn` variable:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的辅助函数是`maybe`方法，它是一个带有以下签名的柯里化函数-`maybe($default, callable $fn, Maybe
    $maybe)`命名空间。当调用时，它将首先尝试从`$maybe`变量中提取值，并默认为`$default`变量。然后将其作为参数传递给`$fn`变量：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that the helpers are out of the way, we will demonstrate how `Maybe` monad
    can be used in combination with the `foldM` method:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 既然辅助函数已经完成，我们将演示如何将`Maybe`单子与`foldM`方法结合使用：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Implementing this using a traditional function and the `array_reduce`method
    would mostly result in something really similar, but it demonstrates nicely how
    the `foldM` method works. Since the folding function is bound to the current monadic
    value on each iteration, as soon as we have a null value, the following steps
    will just continue returning nothing until the end. The same function could be
    used to return some other kind of monad to also hold information about the failure.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统函数和`array_reduce`方法来实现这一点，结果大多会非常相似，但它很好地演示了`foldM`方法的工作原理。由于折叠函数绑定到每次迭代的当前单子值，一旦我们有一个空值，接下来的步骤将继续返回空值，直到结束。同样的函数也可以用来返回其他类型的单子，以便还包含有关失败的信息。
- en: 'We already saw before how the monad type can be used to chain multiple functions
    together on a value that may or may not exist. However, if we need to use this
    value to get another value that could be nothing, we will have nested `Maybe`
    instances:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到单子类型如何用于在可能存在或不存在的值上链接多个函数。然而，如果我们需要使用这个值来获取另一个可能为空的值，我们将有嵌套的`Maybe`实例：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this case, you could use the `flatten` method, or simply the`bind` method
    instead of the `map` method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以使用`flatten`方法，或者简单地使用`bind`方法而不是`map`方法：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I agree that the examples for `Maybe`monad are a bit anticlimactic as most of
    the uses were already described earlier monads are only a pattern, thus creating
    a `Maybe` monad does not add feature in itself, it will only allow us with other
    patterns expecting a monad; the features stay the same as before.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我同意`Maybe`单子的例子有点令人失望，因为大多数用法已经在之前的单子中描述过了，因此创建`Maybe`单子本身并不会增加功能，它只会允许我们使用其他期望单子的模式；功能与以前一样。
- en: A similar case can be made for `Either` monad; this is why there won't be any
    new examples for it here. Just make sure to have a look at the helper functions
    instead of rewriting the plumbing yourself when you want to use the monad.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either`单子也可以做类似的情况；这就是为什么这里不会有新的例子。只需确保查看辅助函数，而不是在想要使用单子时重写管道。'
- en: List monad
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表单子
- en: The List or Collection monad represents the category of all functions taking
    a collection as a parameter and returning zero, one, or several values. The function
    is applied to all possible values in the input list and the results are concatenated
    to product a new collection.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表或集合单子代表了所有以集合作为参数并返回零个、一个或多个值的函数的范畴。该函数应用于输入列表中的所有可能值，并将结果连接起来生成一个新的集合。
- en: An important thing to understand is that a list monad does not really represent
    a simple list of values, but rather a list of all different possible values for
    the monad. This idea is often described a *non-determinism*. As we saw with the
    `CollectionApplicative` function, this can lead to interesting results when you
    apply a collection of functions with a collection of values. We will try to expand
    on this topic in the examples to clarify this.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解列表单子实际上并不代表一个简单的值列表，而是代表单子的所有不同可能值的列表。这个想法通常被描述为*非确定性*。正如我们在`CollectionApplicative`函数中看到的，当您将一组函数应用于一组值时，这可能会导致有趣的结果。我们将尝试在例子中扩展这个主题以澄清这一点。
- en: Motivation
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The List monad embodies the idea that you cannot know the best result until
    the end of the full computation. It allows us to explore all possible solutions
    until we have a final one.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表单子体现了这样一个观念，即在完整计算结束之前，您无法知道最佳结果。它允许我们探索所有可能的解决方案，直到我们有最终的解决方案。
- en: Implementation
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'The monad is implemented in the `php-functional` library under the name the
    `Collection` method. It is done in a pretty straightforward way. Two new methods
    are, however, available in comparison to our own previous implementation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 单子是在`php-functional`库中以`Collection`方法的名称实现的。这是以一种非常直接的方式完成的。然而，与我们自己以前的实现相比，有两种新方法可用：
- en: The `reduce` method will perform a fold operation on the values stored inside
    the monad.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce`方法将对单子内存储的值执行折叠操作。'
- en: The `traverse` method will map a function returning an applicative to all values
    stored inside the monad. The applicative is then applied to the current accumulator.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traverse`方法将一个返回应用程序的函数映射到单子内存储的所有值。然后将应用程序应用于当前累加器。'
- en: Examples
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子
- en: 'Let''s start with something hard, using the `filterM` method that we previously
    discovered. We will create something that is called the `powerset`of a set. The
    `powerset` collection is all possible subsets of a given set, or, if you like,
    all possible combination of its members:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些困难的事情开始，使用我们之前发现的`filterM`方法。我们将创建一个被称为集合的`powerset`。`powerset`集合是给定集合的所有可能子集，或者，如果您愿意，是其成员的所有可能组合：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This currently doesn't work with the actual implementation of Collection/filterM
    due to the fact that the constructor does not wrap an actual array inside another.
    See [https://github.com/widmogrod/php-functional/issues/31](https://github.com/widmogrod/php-functional/issues/31).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构造函数没有在实际数组内包装另一个数组，所以这目前无法使用Collection/filterM的实际实现。请参阅[https://github.com/widmogrod/php-functional/issues/31](https://github.com/widmogrod/php-functional/issues/31)。
- en: 'What is happening here? It may seem as if it is some kind of dark magic. In
    fact, it is pretty simple to explain. Binding a function to a collection results
    in this function being applied to all its members. In this particular case, our
    filtering function returns a collection containing both `true` and `false` values.
    This means the inner closure of the `filterM` method responsible for replacing
    the Boolean with the value is run twice and the result is then appended to all
    previously created collections. Let''s see the first steps to make things clearer:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？这似乎是某种黑魔法。事实上，这很容易解释。将函数绑定到集合会导致该函数应用于其所有成员。在这种特殊情况下，我们的过滤函数返回一个包含`true`和`false`值的集合。这意味着`filterM`方法的内部闭包负责用值替换布尔值被运行两次，然后结果被附加到先前创建的所有集合上。让我们看看第一步以使事情更清晰：
- en: The filter is first applied to the value `1`, creating two collections `[]`
    and `[1]`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤首先应用于值`1`，创建两个集合`[]`和`[1]`。
- en: The filter is now applied to the value `2`, creating two new collections (`[]`
    and `[2]`) that need to be appended to the ones we created earlier, creating four
    collections `[]`, `[1]`, `[2]`, `[1, 2]`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在过滤器应用于值`2`，创建两个新集合（`[]`和`[2]`），需要附加到我们之前创建的集合上，创建四个集合`[]`，`[1]`，`[2]`，`[1,
    2]`。
- en: Each new step creates two collections that are appended to the previous ones,
    making the number of collections grow exponentially.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每一步都会创建两个集合，这些集合将附加到先前创建的集合上，使得集合的数量呈指数级增长。
- en: 'Still not clear? Let''s look at another example. This time, try imagining the
    collection as a tree where each initial value is a branch. When you bind a function,
    it is applied to each branch and, if the result is another collection, it creates
    new branches:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 还不清楚吗？让我们看另一个例子。这一次，试着将集合想象成一棵树，其中每个初始值都是一个分支。当你绑定一个函数时，它被应用于每个分支，如果结果是另一个集合，它就会创建新的分支：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In order to make matters a bit more complicated for you, the second function
    returns a variable number of elements based on the given value. Let''s visualize
    this as a tree:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情对你更加复杂一些，第二个函数根据给定的值返回可变数量的元素。让我们将其可视化为一棵树：
- en: '![Examples](graphics/image_06_001.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![Examples](graphics/image_06_001.jpg)'
- en: Where can the knight go?
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 骑士可以去哪里？
- en: Now that we have a good understanding of how the `Collection` monad works, let's
    tackle a more difficult challenge. Given a starting position on a chessboard,
    we want to know all possible valid positions a knight piece can reach in three
    moves.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对`Collection`单子的工作原理有了很好的理解，让我们来解决一个更困难的挑战。给定国际象棋棋盘上的起始位置，我们想知道骑士棋子在三步内可以到达的所有可能有效位置。
- en: 'I want you to take a moment to imagine how you would implement that. Once you
    are done, let''s try using our monad. We first need a way to encode our knight
    position. A simple class will suffice. Also, a chessboard has eight columns and
    eight rows, so let''s add a method to check whether the position is valid:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你花一点时间想象一下你会如何实现它。一旦你完成了，让我们尝试使用我们的单子。我们首先需要一种方法来编码我们的骑士位置。一个简单的类就足够了。此外，国际象棋棋盘有八列和八行，所以让我们添加一个检查位置是否有效的方法：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we need a function that returns all valid moves for a knight, given a starting
    position:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个函数，给定一个起始位置，返回骑士的所有有效移动：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Nice, it seems to be working well. Now all we need to do is bind this function
    three times in a row. And, while we are at it, we will also create a function
    that checks whether a knight can reach a given position in three steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，看起来工作得很好。现在我们只需要连续三次绑定这个函数。而且，在此过程中，我们还将创建一个函数，检查骑士是否可以在三步内到达给定位置：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The only thing left to do is to check on a real chessboard whether our functions
    work correctly. I don't know how you imagined doing this in an imperative way,
    but my own solution for once was a lot less elegant than the one we've got here.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的事情就是在真正的国际象棋棋盘上检查我们的函数是否正确工作。我不知道你是如何以命令式的方式做到这一点的，但是我的解决方案比我们现在得到的解决方案要不那么优雅。
- en: If you want to play a bit more, you can try to parametrize the number of moves
    or implement this for other chess pieces. As you will see, it requires only minimal
    changes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想再玩一会儿，你可以尝试参数化移动的次数，或者为其他棋子实现这个功能。正如你将看到的，这只需要进行最小的更改。
- en: Writer monad
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写作单子
- en: If you remember, pure functions cannot have any side effects, meaning you cannot
    put a debug statement in them, for example. If you are like me, the `var_dump`
    method is your debugging tool of choice, so you are left with breaking your purity
    rule or using some other debugging techniques. Since all outputs of a function
    must go through its return value, one of the first ideas that comes to mind is
    to return a tuple of values-the original return value and any kind of debug statement
    you need.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得的话，纯函数不能有任何副作用，这意味着你不能在其中放置调试语句，例如。如果你像我一样，`var_dump`方法是你的调试工具，那么你只能违反纯度规则或使用其他调试技术。由于函数的所有输出必须通过其返回值，脑海中首先浮现的一个想法是返回一个值元组-原始返回值和你需要的任何调试语句。
- en: This solution is, however, pretty complex to put in place. Imagine you have
    a function that halves a numerical value which returns the halved value and the
    received input for debugging purposes. Now, if you want to compose this function
    by itself to create a new function that returns the value divided by four, you
    also need to modify the inputs so that they can accept your new return format.
    And this goes on and on until you've modified all your functions accordingly.
    This also poses some issues with currying, as you now have an extraneous parameter
    which is not really useful if you don't care about the debug statements.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个解决方案非常复杂。想象一下，你有一个函数，它可以将一个数值减半，返回减半后的值和接收到的输入，用于调试目的。现在，如果你想将这个函数与自身组合，创建一个新的函数，返回被四除的值，你还需要修改输入，以便它们可以接受你的新返回格式。这一过程一直持续下去，直到你相应地修改了所有的函数。这也会对柯里化造成一些问题，因为现在你有了一个多余的参数，如果你不关心调试语句，这个参数实际上并不实用。
- en: The solution you are looking for is the Writer monad. Sadly, there are no implementations
    in `php-functional` library at the time of writing.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在寻找的解决方案是`Writer`monad。遗憾的是，在撰写本文时，`php-functional`库中还没有实现。
- en: Motivation
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The Writer monad is used to encapsulate some kind of associated statement alongside
    the principal return value of a function. This statement can be anything. It is
    often used to store generated debugging output or tracing information. Doing so
    manually is cumbersome and can lead to complex management code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Writer monad用于封装函数的主要返回值旁边的某种相关语句。这个语句可以是任何东西。它经常用于存储生成的调试输出或跟踪信息。手动这样做是繁琐的，可能会导致复杂的管理代码。
- en: The Writer monad provides a clean way to manage such side output and allows
    you to interleave functions returning such information alongside functions returning
    simple values. At the end of the computation sequence, the supplementary values
    can be either discarded, displayed, or treated in any kind of way depending on
    the mode of operation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Writer` monad提供了一种干净的方式来管理这种副输出，并允许你在返回简单值的函数旁边插入返回这种信息的函数。在计算序列结束时，附加值可以被丢弃、显示或根据操作模式进行任何处理。'
- en: Implementation
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: Since the monad needs to concatenate the output values, any instance of a monoid
    can be used as such. To simplify string-based logging, any string is also managed
    out-of-the-box. Obviously, using a monoid with a slow operation will result in
    a performance cost.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于monad需要连接输出值，任何monoid的实例都可以被用作这样。为了简化基于字符串的日志记录，任何字符串也可以被直接管理。显然，使用一个具有缓慢操作的monoid将导致性能成本。
- en: The `php-functional` library includes an implementation of a `StringMonoid`
    class to which each string will be lifted. However, the `runWriter` method will
    always return a `StringMonoid` class, so there is no surprise for people using
    it. Besides that, the implementation is pretty straightforward.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`php-functional`库包括一个`StringMonoid`类的实现，每个字符串都将被提升到这个类中。然而，`runWriter`方法将始终返回一个`StringMonoid`类，因此对于使用它的人来说并不奇怪。除此之外，这个实现非常简单直接。'
- en: Examples
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'As we just saw, the `Writer` is great for logging. Coupled with the `filter`
    method, this can be leveraged to understand what is happening in a filtering function
    without having to resort to dumping values:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，`Writer`非常适合日志记录。结合`filter`方法，这可以用来理解在过滤函数中发生了什么，而无需倾向于转储值：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see, `Writer` monad allows us to have exact information about why
    certain numbers were filtered out. It may seem like nothing in such a simple example,
    but conditions are not always as easy to understand.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`Writer` monad允许我们准确了解为什么某些数字被过滤掉。在这样一个简单的例子中，这可能看起来不像什么，但条件并不总是那么容易理解。
- en: 'You can also use `Writer` to add more traditional debug information:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`Writer`来添加更传统的调试信息：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This monad is great keeping track of useful information. Also, it often avoids
    leaving some unwanted `var_dump` or `echo` methods in your function and library
    code. Once you are done debugging, leave the messages there-they might prove useful
    to someone else, and just remove the use of the `$log` value returned by the `runWriter`
    method.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个monad非常适合跟踪有用的信息。此外，它经常避免在你的函数和库代码中留下一些不需要的`var_dump`或`echo`方法。一旦调试完成，留下这些消息，它们可能对其他人有用，然后移除`runWriter`方法返回的`$log`值的使用。
- en: Obviously, you can also use `Writer`monad to keep track of any kind of information.
    One good use could be to back profiling right into your function by always returning
    the execution time via a `Writer` instance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你也可以使用`Writer`monad来跟踪任何类型的信息。一个很好的用法是通过`Writer`实例始终返回执行时间，将性能分析直接嵌入到你的函数中。
- en: If you need to store multiple kinds of data, the `Writer` monad is not limited
    to string values, any monoid will do. You can, for example, declare a specific
    monoid containing execution time, stack trace, and debug messages in an array
    and use that with your Writer. This way, each of your functions will be able to
    pass useful information to anyone calling them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要存储多种类型的数据，`Writer` monad不仅限于字符串值，任何monoid都可以。例如，你可以声明一个包含执行时间、堆栈跟踪和调试消息的特定monoid，并将其与你的Writer一起使用。这样，你的每个函数都能向调用它们的人传递有用的信息。
- en: We could argue that it slows your program down always having that kind of information.
    This is probably correct, but I'd imagine that those kind of optimizations are
    not needed in most applications.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，始终具有这种信息会减慢程序的运行速度。这可能是正确的，但我想在大多数应用程序中，这种优化是不需要的。
- en: Reader monad
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reader monad
- en: It so happens that you have a bunch of functions that should all take the same
    parameter, or a subset of a given list of values. For example, you have a configuration
    file and various parts of your application need to have access to values stored
    in it. One solution is to have some kind of global object or singleton to store
    that information, but as we already discussed, this leads to some issues. A more
    common approach in modern PHP frameworks is to use a concept called **Dependency
    Injection** (**DI**). The Reader monad allows you to do exactly that in a purely
    functional way.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 碰巧你有一堆函数，它们都应该接受相同的参数，或者给定值列表的一个子集。例如，你有一个配置文件，你的应用程序的各个部分需要访问其中存储的值。一个解决方案是有一种全局对象或单例来存储这些信息，但正如我们已经讨论过的，这会导致一些问题。在现代PHP框架中更常见的方法是使用一个叫做**依赖注入**（**DI**）的概念。Reader单子允许你以纯函数的方式做到这一点。
- en: Motivation
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: Provide a way to share a common environment, such as configuration information
    or class instances, across multiple functions. This environment is read-only for
    the computation sequence. However, it can be modified or extended for any sub-computation
    local to the current step.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一种共享公共环境的方式，例如配置信息或类实例，跨多个函数进行。这个环境对于计算序列是只读的。然而，它可以被修改或扩展，用于当前步骤的任何子计算。
- en: Implementation
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: The `Reader` class performs function evaluation lazily because the content of
    the environment is not yet known when the function is bound. This means all functions
    are wrapped inside closures inside the monad and everything is run when the `runReader`
    method is called. Besides that, the implementation available in `php-functional`
    library is pretty straightforward.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reader`类执行函数评估是懒惰的，因为当函数绑定时环境的内容还不知道。这意味着所有函数都被包裹在单子内部的闭包中，当调用`runReader`方法时才运行。除此之外，在`php-functional`库中可用的实现非常直接。'
- en: Examples
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子
- en: 'Using the `Reader` monad is a bit different than what we have seen until now.
    The bound function will receive the value from the previous step in the computation
    and must return a new reader that holds a function receiving the environment.
    If you just want to process the current value, it is easier to use the `map` function,
    as it does not require a `Reader` instance to be returned. You will, however,
    not receive the context:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Reader`单子与我们到目前为止所见到的有些不同。绑定的函数将接收计算中前一步的值，并且必须返回一个持有接收环境的函数的新reader。如果你只想处理当前值，使用`map`函数会更容易，因为它不需要返回一个`Reader`实例。然而，你将不会收到上下文：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This not-so-interesting example just poses the basics of what you can do. The
    next example will show how you can perform DI using this monad.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个不太有趣的例子只是提出了你可以做什么的基础知识。下一个例子将展示如何使用这个单子进行DI。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you've used a modern web framework, you probably already know what dependency
    injection, or DI, is. Otherwise, here is a real quick explanation, for which I
    could probably get burned at the stake. DI is a pattern to avoid using singletons
    or globally available instances. Instead, you declare your dependencies as functions
    or constructor parameters and a **Dependency Injection Container** (**DIC**) is
    tasked with providing them to you.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过现代的Web框架，你可能已经知道什么是依赖注入，或者DI。否则，这里是一个真正快速的解释，我可能会因此被烧死。DI是一种模式，用于避免使用单例或全局可用的实例。相反，你声明你的依赖项作为函数或构造函数参数，一个**依赖注入容器**（**DIC**）负责为你提供它们。
- en: Usually, this involves letting the DIC instantiate all your objects instead
    of using the `new` keyword, but the method varies from one framework to another.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这涉及让DIC实例化所有对象，而不是使用`new`关键字，但方法因框架而异。
- en: How do we do that using the `Reader` monad? It's pretty simple. We need to create
    a container that will hold all our services and then we will use our reader to
    pass those around.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用`Reader`单子来做到这一点？很简单。我们需要创建一个容器来保存所有的服务，然后我们将使用我们的reader来传递这些服务。
- en: 'For the sake of the example, let''s say we have an `EntityManager` for our
    users that connects to the database and a service to send e-mails. Also, to keep
    things simple, we won''t do any encapsulation, and we will use simple functions
    instead of classes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，假设我们有一个用于连接数据库的`EntityManager`，以及一个发送电子邮件的服务。另外，为了保持简单，我们不会进行任何封装，而是使用简单的函数而不是类：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we want to write the controller that gets called after a user registers
    on our application. We will need to send them an e-mail and display some kind
    of confirmation. For now, let''s assume the user is already saved in the database
    and that our theoretical framework provides the use of the `POST` method values
    as a parameter:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要编写一个在用户在我们的应用程序上注册后被调用的控制器。我们需要给他们发送一封电子邮件并显示某种确认。现在，让我们假设用户已经保存在数据库中，并且我们的理论框架提供了`POST`方法值作为参数的使用：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'OK, we have everything in place for a quick test. We will create some face
    service classes to see whether the plumbing works correctly:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经准备好进行快速测试。我们将创建一些面向服务的类，以查看管道是否正常工作：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Obviously, we don't have a usable framework yet, but I think this demonstrates
    nicely the possibilities offered by the `Reader` monad when it comes to DI.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们还没有一个可用的框架，但我认为这很好地展示了`Reader`单子在DI方面提供的可能性。
- en: Concerning the IO operations that need to be done to store the newly created
    user in the database and the mail sending, we will see how it can be achieved
    using the IO monad that we will present later.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关于需要执行的IO操作，以将新创建的用户存储到数据库中并发送邮件，我们将看到如何使用稍后将介绍的IO单子来实现。
- en: State monad
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态单子
- en: The State monad is a generalization of the reader monad in the sense that each
    step can modify the current state before the next step is called. As a referentially
    transparent language cannot have a shared global state, the trick is to encapsulate
    the state inside the monad and pass it explicitly to each part of the sequence.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: State单子是读取器单子的一种泛化，因为每个步骤在调用下一步之前都可以修改当前状态。由于引用透明语言不能具有共享的全局状态，技巧是将状态封装在单子内部，并将其显式地传递给序列的每个部分。
- en: Motivation
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: It provides a clean and easy-to-use process to pass a shared state across multiple
    steps in a sequence. This can obviously be done manually but the process is error
    prone and leads to less readable code. The monad hides the complexity so that
    you can simply write functions taking a state as input and returning a new state.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了一个干净且易于使用的过程，可以在序列中的多个步骤之间传递共享状态。这显然可以手动完成，但这个过程容易出错，并且导致代码可读性较差。单子隐藏了复杂性，因此您可以简单地编写以状态作为输入并返回新状态的函数。
- en: Implementation
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: The implementation available in the `php-functional` library is nearly identical
    to the one we just discussed for the `Reader` monad, with just one key difference-the
    state can be updated by each bound function. This leads to a difference in the
    functions that are bound to the monad-instead of returning a value, they need
    to return an array containing the value as first element and the new state as
    second element.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`php-functional`库中提供的实现与我们刚刚讨论的`Reader`单子几乎相同，只有一个关键区别-每个绑定函数都可以更新状态。这导致了与绑定到单子的函数不同的函数-它们需要返回一个包含值作为第一个元素和新状态作为第二个元素的数组，而不是返回一个值。'
- en: Examples
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'As we already discussed, it is impossible for a function to return the current
    time or some kind of random value. The `state` monad can help us do exactly this
    by providing a clean way to pass the `state`variable around, exactly as we did
    with our `Reader` environments earlier:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，函数不可能返回当前时间或某种随机值。`state`单子可以通过提供一种干净的方式来传递`state`变量来帮助我们做到这一点，就像我们之前使用`Reader`环境一样：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Another use of the `state` monad is to implement a caching system:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`state`单子的另一个用途是实现缓存系统：'
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see, the user list contains the `user 1` two times, but the cache
    only once. This is a pretty basic cache mechanism, but it can come in handy.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，用户列表中包含`user 1`两次，但缓存只有一次。这是一个非常基本的缓存机制，但它可能会派上用场。
- en: There are many other uses for the `state` monad, but to be honest, without syntactic
    sugar like the do notation and such, I am not quite sure it is a good fit for
    PHP programming. If you are interested, I am sure you will find many other resources
    online but we will stop there with the examples.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`state`单子还有许多其他用途，但老实说，如果没有像do表示法这样的语法糖，我不太确定它是否适合PHP编程。如果您感兴趣，我相信您会在网上找到许多其他资源，但我们将在这里停止示例。'
- en: IO monad
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IO单子
- en: Inputs and outputs are the quintessence of side effects. There is no way to
    guarantee purity when you get your function output from an external source as
    those change without relation to the inputs. And as soon as you output something,
    be it to the screen, a file, or anywhere else, you changed an external state unrelated
    to your function outputs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输入和输出是副作用的精髓。当您从外部源获取函数输出时，没有办法保证纯度，因为这些输出会随着输入无关地发生变化。并且一旦您输出了某些东西，无论是屏幕、文件还是其他任何地方，您都改变了与函数输出无关的外部状态。
- en: Some people in the functional community argue that, for example, logging outputs
    or debugging statements should not necessarily be considered as side-effects as
    usually they have no consequences on the outcome of running your application.
    The end user doesn't care whether something was written to a log file or not as
    long as it gets the wanted result back and the operation is repeatable at will.
    Truthfully, my opinion on the subject is not quite made, and honestly I don't
    really care as the writer monad lets us take care of logging and debugging statements
    in a clever way.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 函数社区中的一些人认为，例如，日志输出或调试语句不一定应被视为副作用，因为通常它们对于运行应用程序的结果没有影响。最终用户并不在乎是否将某些内容写入日志文件，只要它能得到想要的结果并且操作可以随意重复。说实话，我对这个问题的看法还没有完全形成，而且老实说，我并不在乎，因为写入单子让我们以巧妙的方式处理日志记录和调试语句。
- en: However, there are some times when you need to have information from the outside
    and usually, if your application is doing anything worthy, you need to display
    or write the final result somewhere.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时您需要从外部获取信息，通常，如果您的应用程序值得做任何事情，您需要在某个地方显示或写入最终结果。
- en: We could imagine getting all values before beginning any computation and passing
    them around using some kind of clever data structure. This could work for some
    simpler applications, but as soon as you need to perform database access based
    on some computed values, reality starts to set in and you realize that this isn't
    at all viable in the long term.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象在开始任何计算之前获取所有值，并使用某种巧妙的数据结构传递它们。这对于一些较简单的应用程序可能有效，但是一旦您需要根据一些计算出的值执行数据库访问，现实开始显现，您会意识到这在长期内根本行不通。
- en: The trick proposed by the IO monad is to do what we just proposed but in reverse.
    You start by describing all computational steps needed by your program. You encapsulate
    them in an instance of the IO monad and when everything is cleanly defined in
    terms of referentially transparent function calls, you start the beast which will
    finally perform all needed IO actions, and call each described step.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: IO单子提出的技巧是按照我们刚刚提出的方式进行，但是相反。您首先描述程序所需的所有计算步骤。您将它们封装在IO单子的实例中，当一切都清晰地定义为引用透明的函数调用时，您启动最终执行所有所需IO操作的程序，并调用每个描述的步骤。
- en: 'This way, you have an application composed only of pure functions, which you
    can easily test and understand. All actions related to inputs and outputs are
    performed at the end, the complexity being hidden inside the IO monad. In order
    to enforce this, the IO monad is said to be a one-way monad, meaning there is
    no way to get any value out of it. You have only two options:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您的应用程序只由纯函数组成，您可以轻松测试和理解。与输入和输出相关的所有操作都是在最后执行的，复杂性被隐藏在IO单子内部。为了强制执行这一点，IO单子被称为单向单子，意味着无法从中获取任何值。您只有两个选择：
- en: Binding computations, or actions, to the monad so that they get executed later
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将计算或操作绑定到单子，以便稍后执行它们
- en: Running said computations to get the final result of your application
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行这些计算以获得应用程序的最终结果
- en: I imagine this may be pretty confusing if you have never seen an application
    created like this. The examples will try to give you a first impression of how
    it can be done and we will dive deeper into the topic in [Chapter 11](ch11.html
    "Chapter 11. Designing a Functional Application"), *Designing a Functional Application*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我想如果您从未见过像这样创建的应用程序，可能会感到非常困惑。这些例子将尝试给您第一印象，以及我们将在[第11章](ch11.html "第11章。设计一个功能应用程序")，“设计一个功能应用程序”中深入探讨这个主题。
- en: Motivation
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The IO monad solves the issue of inputs and outputs breaking referential transparency
    and function purity by confining all IO operations within the monad. All computational
    steps needed for the application are first described in a functional way. Once
    this is done, we accept that the final step cannot be side-effect-free and we
    run all the sequences stored inside the monad.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: IO单子通过将所有IO操作限制在单子内部，解决了输入和输出破坏引用透明度和函数纯度的问题。应用程序所需的所有计算步骤首先以功能方式描述。完成这一点后，我们接受最终步骤无法无副作用，并运行存储在单子内部的所有序列。
- en: Implementation
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: The implementation provided by `php-functional` library is pretty simple, as
    there are no real subtleties. There is only one little trick needed as the computation
    needs to be made when `run` method is called and not when the function is bound.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`php-functional`库提供的实现非常简单，因为没有真正的微妙之处。只需要一个小技巧，即在调用`run`方法时进行计算，而不是在函数绑定时进行计算。'
- en: Besides that, the library comes with helper functions under the `Widmogrod\Monad\IO`
    namespace to help you use the monad. You can easily read input from the user on
    the command line, print text on the screen, and read and write files and environment
    variables.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该库还提供了`Widmogrod\Monad\IO`命名空间下的辅助函数，以帮助您使用单子。您可以轻松地从命令行读取用户输入，在屏幕上打印文本，并读取和写入文件和环境变量。
- en: Examples
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子
- en: 'We will take this opportunity to use the `mcompose` method in order to compose
    multiple `IO` operations together:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用`mcompose`方法来组合多个`IO`操作：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So we first create a function that displays the current content of the monad
    using `putStrLn`, ask for some input, and display the result back.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先创建一个使用`putStrLn`显示单子当前内容的函数，要求一些输入，并将结果显示回来。
- en: The `IO` monad needs to wrap the whole computation of your application if you
    want to maintain referential transparency. This is because your inputs need to
    be retrieved through it and any output must also be done through the monad. This
    means we could show a lot of examples without really capturing the real essence
    of its use. This is why we will stop here and wait until [Chapter 11](ch11.html
    "Chapter 11. Designing a Functional Application"), *Designing a Functional Application*,
    to see how it can be achieved.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要保持引用透明度，IO单子需要包装整个应用程序的计算。这是因为您的输入需要通过它来检索，任何输出也必须通过单子完成。这意味着我们可以展示很多例子，而实际上并没有真正抓住其使用的真正本质。这就是为什么我们将在这里停下来，等到[第11章](ch11.html
    "第11章。设计一个功能应用程序")，“设计一个功能应用程序”，看看如何实现它。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have looked at multiple monads and their implementation.
    I hope the examples made it clear how you can use them and what their benefits
    are:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看过多个单子及其实现。我希望这些例子清楚地说明了如何使用它们以及它们的好处是什么：
- en: The Maybe monad can be used when a computation might return nothing
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当计算可能返回空时，可以使用Maybe单子
- en: The Either monad can be used when a computation might error
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Either单子可用于计算可能出错的情况
- en: The List monad can be used when a computation has multiple possible results
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: List单子可用于计算有多个可能结果的情况
- en: The Writer monad can be used when some side information needs to be passed alongside
    the return value
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要在返回值旁边传递一些辅助信息时，可以使用Writer单子
- en: The Reader monad can be used to share a common environment between multiple
    computations
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reader单子可用于在多个计算之间共享一个公共环境
- en: The State monad is a beefed-up version of the Reader monad where the environment
    can be updated between each computation
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: State单子是Reader单子的升级版本，其中环境可以在每次计算之间更新
- en: The IO monad can be used to perform IO operations in a referentially transparent
    way
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IO单子可用于以引用透明的方式执行IO操作
- en: There are, however, multiple other computations that can be simplified using
    monads. When writing code, I encourage you to take a step back and look at the
    structure to see if you recognize a monadic pattern. If so, you should probably
    implement it using our `Monad` class to benefit from what we've learned so far.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有其他多个计算可以使用单子简化。在编写代码时，我鼓励您退后一步，看看结构是否符合单子模式。如果是这样，您可能应该使用我们的`Monad`类来实现它，以从迄今为止学到的知识中受益。
- en: Also, those various monads can be used in combination to achieve complex transformations
    and computations. We will approach this topic in [Chapter 10](ch10.html "Chapter 10. PHP
    Frameworks and FP"), *PHP Frameworks and FP*, where we will discuss monad transformers,
    and [Chapter 11](ch11.html "Chapter 11. Designing a Functional Application"),
    *Designing a Functional Application*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，这些各种单子可以组合使用，实现复杂的转换和计算。我们将在[第10章](ch10.html "第10章 PHP框架和FP")*PHP框架和FP*中讨论这个话题，其中我们将讨论单子变换器，以及[第11章](ch11.html
    "第11章 设计一个函数式应用")*设计一个函数式应用*。
- en: At this point in the book, you are perhaps impressed by some functional techniques
    but I imagine most of the things we've seen so far are a bit awkward and functional
    programming might seem tedious. The feeling is totally normal for two main reasons.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在书的这一部分，你可能会对一些函数式技术印象深刻，但我想我们到目前为止看到的大部分东西都有点尴尬，函数式编程可能看起来很繁琐。这种感觉对于两个主要原因来说是完全正常的。
- en: First, this awkwardness often results from some kind of missing abstraction
    or technique waiting to be discovered. If this were a book about Haskell, you
    would learn about all of these and you would have a handful of other books to
    look them up. However, this book is about PHP; we will learn a few more concepts
    in the later chapters, but after that, you will mostly be on your own, like a
    pioneer.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这种尴尬往往是由于某种缺失的抽象或待发现的技术所致。如果这是一本关于Haskell的书，你会学到所有这些内容，并且你会有一些其他书来查找它们。然而，这本书是关于PHP的；我们将在后面的章节中学习一些更多的概念，但之后，你将大部分时间都是靠自己，就像一个先驱一样。
- en: I can only encourage you to make your way through when you encounter those situations
    and look for patterns and ways to factor out commonalities in your code. Step
    by step, you will forge a great toolbox and things will get easier.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我只能鼓励你在遇到这些情况时坚持下去，寻找代码中的模式和共性因素。一步一步，你将打造一个强大的工具箱，事情会变得更容易。
- en: Second, all of this is probably new to you. Switching programming paradigm is
    really hard and it can be really frustrating. But fear not, with time, practice,
    and experience, you will gain confidence and the benefits will start to outweigh
    the cost. The steeper the learning curve, the greater the reward.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这一切对你来说可能都是新的。转换编程范式真的很难，可能会让人感到沮丧。但不要害怕，随着时间、练习和经验的积累，你会变得更加自信，收获也会开始超过成本。学习曲线越陡峭，回报就越大。
- en: In the next chapter, we will discover some new functional concepts and patterns
    that will permit us to fully use the various techniques we have learned so far.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将发现一些新的函数式概念和模式，这将使我们能够充分利用我们到目前为止学到的各种技术。
