- en: Chapter 2. Entities and Mapping Information
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。实体和映射信息
- en: In the previous chapter, we discovered the concepts behind Doctrine, we learned
    how to use Composer to install it, we set up the Doctrine Command Line Tools and
    we dived into the Entity Manager.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了Doctrine背后的概念，学习了如何使用Composer进行安装，设置了Doctrine命令行工具，并深入了解了实体管理器。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating our first entity class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个实体类
- en: Mapping it to its related database table and columns with annotations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用注释将其映射到相关的数据库表和列
- en: Using a command helper provided by Doctrine to automatically generate the database
    schema
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Doctrine提供的命令助手自动生成数据库模式
- en: Creating some fixtures data and dealing with the Entity Manager to display our
    data in a web user interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一些固定数据，并处理实体管理器以在Web用户界面中显示我们的数据
- en: 'Because we are building a blog, our main entity class will be called `Post`,
    as shown in the following figure:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在构建一个博客，我们的主要实体类将被称为`Post`，如下图所示：
- en: '![Entities and Mapping Information](graphics/4104OS_02_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![实体和映射信息](graphics/4104OS_02_01.jpg)'
- en: 'Our `Post` entity class has the following four properties:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Post`实体类具有以下四个属性：
- en: '`id`: The unique identifier of the post across the database table (and the
    blog)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：跨数据库表（和博客）的帖子的唯一标识符'
- en: '`title`: The post''s title'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：帖子的标题'
- en: '`body`: The post''s body'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`：帖子的正文'
- en: '`publicationDate`: The date of publication of the post'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publicationDate`：帖子的发布日期'
- en: Creating the Entity class
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建实体类
- en: As explained in [Chapter 1](ch01.html "Chapter 1. Getting Started with Doctrine
    2"), *Getting Started with Doctrine 2*, a Doctrine entity is just a PHP object
    that will be saved in the database. Doctrine annotations are added in the PHP
    `DocBlock` comments of the Entity class properties. Annotations are used by Doctrine
    to map the object to the related database's table and properties to columns.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](ch01.html "第1章。开始使用Doctrine 2")*开始使用Doctrine 2*中所述，Doctrine实体只是将保存在数据库中的PHP对象。Doctrine注释添加在实体类属性的PHP
    `DocBlock`注释中。Doctrine使用注释将对象映射到相关的数据库表和属性到列。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The original purpose of **DocBlocks** is integrating technical documentation
    directly in the source code. The most popular documentation generator that parses
    DocBlocks is **phpDocumentator** which is available on this website: [http://www.phpdoc.org](http://www.phpdoc.org).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**DocBlocks**的最初目的是将技术文档直接集成到源代码中。解析DocBlocks的最流行的文档生成器是**phpDocumentator**，可以在此网站上找到：[http://www.phpdoc.org](http://www.phpdoc.org)。'
- en: Each entity, once persisted through Doctrine, will be related to a row of the
    database's table.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实体一旦通过Doctrine持久化，将与数据库表的一行相关联。
- en: 'Create a new file `Post.php` containing our entity class in the `src/Blog/Entity/`
    location with the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/Blog/Entity/`位置创建一个名为`Post.php`的新文件，其中包含以下代码的实体类：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Generating getters and setters
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成getter和setter
- en: Doctrine command-line tools that we configured in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Doctrine 2"), *Getting Started with Doctrine 2*, include a useful
    command that generates getter and setter methods of an Entity class for us. We
    will use it to save us from having to write those of the `Post` class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ch01.html "第1章。开始使用Doctrine 2")*开始使用Doctrine 2*中配置的Doctrine命令行工具包括一个有用的命令，用于为我们生成实体类的getter和setter方法。我们将使用它来避免编写`Post`类的getter和setter方法。
- en: 'Run the following command to generate getters and setters of all entity classes
    of the application:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令，生成应用程序所有实体类的getter和setter：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you have several entities and don't want to generate getters and setters
    for all of them, use the `filter` option with the `orm:generate:entities` command.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个实体，不想为所有实体生成getter和setter，请使用`orm:generate:entities`命令的`filter`选项。
- en: Mapping with Doctrine annotations
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Doctrine注释进行映射
- en: '`Post` is a simple class with four properties. The setter for `$id` isn''t
    actually generated. Doctrine populates the `$id` instance variable directly in
    the entity hydration phase. We will see later how we delegate the ID generation
    to the DBMS.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post`是一个简单的类，有四个属性。`$id`的setter实际上并没有被生成。Doctrine在实体解析阶段直接填充`$id`实例变量。我们稍后会看到如何将ID生成委托给DBMS。'
- en: Doctrine annotations are imported from the `\Doctrine\ORM\Mapping` namespace
    with `use` statements. They are used in DocBlocks to add mapping information to
    the class and its properties. DocBlocks are just a special kind of comment starting
    with `/**`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine注释从`\Doctrine\ORM\Mapping`命名空间导入，使用`use`语句。它们用于在DocBlocks中为类及其属性添加映射信息。DocBlocks只是以`/**`开头的一种特殊的注释。
- en: Knowing about the @Entity annotation
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解`@Entity`注释
- en: The `@Entity` annotation is used in the class-level DocBlock to specify that
    this class is an entity class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Entity`注释用于类级别的DocBlock中，指定此类是实体类。'
- en: The most important attribute of this annotation is `repositoryClass`. It allows
    specifying a custom entity repository class. We will learn about entity repositories,
    including how to make a custom one, in [Chapter 4](ch04.html "Chapter 4. Building
    Queries"), *Building Queries*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此注释的最重要属性是`repositoryClass`。它允许指定自定义实体存储库类。我们将在[第4章](ch04.html "第4章。构建查询")*构建查询*中学习有关实体存储库的知识，包括如何制作自定义存储库。
- en: Understanding the @Table, @Index, and @UniqueConstraint annotations
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`@Table`、`@Index`和`@UniqueConstraint`注释
- en: The `@Table` annotation is optional. It can be used to add some mapping information
    to the table related to the entity class.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Table`注释是可选的。它可用于向与实体类相关的表添加一些映射信息。'
- en: The related database table name is default to the entity class name. Here, it
    is `Post`. It can be changed using the `name` attribute of the annotation. This
    is a good practice to let Doctrine automatically generate the table and column
    names but it can be useful to change them to match a preexisting schema.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的数据库表名默认为实体类名。在这里，它是`Post`。可以使用注释的`name`属性进行更改。让Doctrine自动生成表和列名称是一个好习惯，但更改它们以匹配现有模式可能会很有用。
- en: 'As you can see, we use the `@Table` annotation to create indexes on the underlying
    table. To do that, we use an attribute called `indexes` that contains a list of
    indexes. Each index is defined by an `@Index` annotation. Each `@Index` must contain
    the following two attributes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们使用`@Table`注释在底层表上创建索引。为此，我们使用一个名为`indexes`的属性，其中包含索引列表。每个索引由`@Index`注释定义。每个`@Index`必须包含以下两个属性：
- en: '`name`: The name of the index'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：索引的名称'
- en: '`columns`: The list of indexed columns'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`columns`：索引列的列表'
- en: For the `Post` entity class, we create an index on the `publicationDate` column
    called `publication_date_idx`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Post`实体类，我们在`publicationDate`列上创建一个名为`publication_date_idx`的索引。
- en: The last optional attribute of the `@Table` annotation is `uniqueConstraints`
    (not used here). It allows creating SQL level unique constraints on columns and
    groups of columns. Its syntax is similar to `@Index:name` to name the constraint
    and `columns` to specify the columns on which it applies the constraints.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Table`注释的最后一个可选属性是`uniqueConstraints`（此处未使用）。它允许在列和列组上创建SQL级别的唯一约束。其语法类似于`@Index：name`来命名约束和`columns`来指定应用约束的列。'
- en: This attribute is only used by the schema generator. Even if the `uniqueConstraints`
    attribute is used, Doctrine will not automatically check that a value is unique
    across a table. The underlying DBMS will do this, but it can lead to DBMS level
    SQL errors. If we want to enforce uniqueness of data, we should perform a check
    prior to saving new data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性仅由模式生成器使用。即使使用了`uniqueConstraints`属性，Doctrine也不会自动检查值在整个表中是否唯一。底层的DBMS将会执行此操作，但可能会导致DBMS级别的SQL错误。如果我们想要强制数据的唯一性，我们应该在保存新数据之前执行检查。
- en: Diving into the @Column annotation
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入了解@Column注释
- en: Each property is mapped to a database column thanks to the `@Column` annotation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个属性都通过`@Column`注释映射到数据库列。
- en: The name of the mapped database column defaults to the property name but can
    be changed with the `name` parameter. As for table names, it's better to let Doctrine
    generate names by itself.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 映射的数据库列的名称默认为属性名称，但可以使用`name`参数进行更改。与表名一样，最好让Doctrine自动生成名称。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As in the case of table names, column names will default to entity class property
    names (Camel case if the PSR style is correctly followed).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与表名的情况一样，列名将默认为实体类属性名（如果正确遵循PSR样式，则为驼峰命名法）。
- en: Doctrine also comes with an underscore naming strategy (for instance, the database
    table related to a class called `MyEntity` will be `my_entity`) and it is possible
    to write custom strategies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine还提供了下划线命名策略（例如，与名为`MyEntity`的类相关的数据库表将是`my_entity`），并且可以编写自定义策略。
- en: 'Learn more about this in the Doctrine documentation: [http://docs.doctrine-project.org/en/latest/reference/namingstrategy.html](http://docs.doctrine-project.org/en/latest/reference/namingstrategy.html)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Doctrine文档中了解更多信息：[http://docs.doctrine-project.org/en/latest/reference/namingstrategy.html](http://docs.doctrine-project.org/en/latest/reference/namingstrategy.html)
- en: If a property is not marked with the `@Column` annotation, Doctrine will ignore
    it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性没有标记为`@Column`注释，Doctrine将忽略它。
- en: Its `type` attribute indicates the Doctrine Mapping Type of the column (see
    next section). It is the only required attribute of this annotation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 其`type`属性指示列的Doctrine映射类型（请参阅下一节）。这是此注释的唯一必需属性。
- en: 'This annotation supports some more attributes. Like for every other annotation,
    the full list of supported attributes is available in the Doctrine documentation.
    The most important attributes are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此注释支持一些更多的属性。与其他注释一样，支持的属性的完整列表可在Doctrine文档中找到。最重要的属性如下：
- en: '`unique`: If `true`, the value of this column must be unique across the related
    database table'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique`：如果为`true`，则此列的值必须在相关数据库表中是唯一的'
- en: '`nullable`: If `false`, the value can be `NULL`. By default, columns cannot
    be `NULL`.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullable`：如果为`false`，则值可以是`NULL`。默认情况下，列不能是`NULL`。'
- en: '`length`: The length of the column for values of the `string` type'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`：`string`类型的列的长度'
- en: '`scale`: The scale for columns for values of the `decimal` type'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale`：`decimal`类型的列的比例'
- en: '`precision`: The precision for columns for values of the `decimal` type'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`precision`：`decimal`类型的列的精度'
- en: As for `@Table`, Doctrine does not use attributes of the `@Column` annotation
    to validate data. These attributes are only used for the mapping and to generate
    the database schema. Nothing more. For security and user experience reasons, you
    must validate every piece of data provided by users. This book does not cover
    this topic. If you do not want to handle data validation manually, try the Symfony
    Validator Component from [http://symfony.com/components/Validator](http://symfony.com/components/Validator).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与`@Table`一样，Doctrine不使用`@Column`注释的属性来验证数据。这些属性仅用于映射和生成数据库模式。没有其他用途。出于安全和用户体验的原因，您必须验证用户提供的每一条数据。本书不涵盖此主题。如果您不想手动处理数据验证，请尝试来自[http://symfony.com/components/Validator](http://symfony.com/components/Validator)的Symfony验证器组件。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It''s also possible to use lifecycle events (see [Chapter 5](ch05.html "Chapter 5. Going
    Further"), *Going Further*) to handle data validation: [http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/cookbook/validation-of-entities.html](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/cookbook/validation-of-entities.html)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用生命周期事件（参见[第5章](ch05.html "第5章。进一步")，“进一步”）来处理数据验证：[http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/cookbook/validation-of-entities.html](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/cookbook/validation-of-entities.html)
- en: Knowing about the @Id and @GeneratedValue annotations
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解@Id和@GeneratedValue注释
- en: The `$id` property is a bit special. This is a column mapped to an integer,
    but this is mainly the unique identifier of our object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`$id`属性有点特殊。这是一个映射到整数的列，但这主要是我们对象的唯一标识符。'
- en: Through the `@Id` annotation, this column will be used as the primary key of
    the table.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`@Id`注释，此列将被用作表的主键。
- en: By default, it is the responsibility of the developer to ensure that the value
    of this property is unique across the table. Almost all DBMSs provide mechanisms
    to automatically increment an identifier at the insertion of a new row. The `@GeneratedValue`
    annotation takes advantage of this. When a property is marked with `@GeneratedValue`,
    Doctrine will delegate the generation of the identifier to the underlying DBMS.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，开发人员负责确保此属性的值在整个表中是唯一的。几乎所有的DBMS都提供了在插入新行时自动递增标识符的机制。`@GeneratedValue`注释利用了这一点。当属性标记为`@GeneratedValue`时，Doctrine将把标识符的生成委托给底层的DBMS。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Other ID generation strategies are available at [http://docs.doctrine-project.org/en/latest/reference/basic-mapping.html#identifier-generation-strategies](http://docs.doctrine-project.org/en/latest/reference/basic-mapping.html#identifier-generation-strategies).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 其他ID生成策略可在[http://docs.doctrine-project.org/en/latest/reference/basic-mapping.html#identifier-generation-strategies](http://docs.doctrine-project.org/en/latest/reference/basic-mapping.html#identifier-generation-strategies)找到。
- en: Doctrine also supports composite primary keys. Just add an `@Id` annotation
    to all columns of your composite primary key.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine还支持复合主键。只需在复合主键的所有列上添加`@Id`注释。
- en: We will study another example using a unique string as identifier in [Chapter
    3](ch03.html "Chapter 3. Associations"), *Associations*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](ch03.html "第3章。关联")中学习另一个例子，使用唯一字符串作为标识符，*关联*。
- en: Using other annotations
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用其他注释
- en: A lot of Doctrine mapping annotations exist. We will use some new annotations
    in [Chapter 3](ch03.html "Chapter 3. Associations"), *Associations* to create
    relations between entities.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多Doctrine映射注释。我们将在[第3章](ch03.html "第3章。关联")中使用一些新的注释，*关联*，以创建实体之间的关系。
- en: The full list of available annotation is given in the Doctrine documentation
    at [http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/annotations-reference.html](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/annotations-reference.html).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可在Doctrine文档中找到所有可用注释的完整列表，网址为[http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/annotations-reference.html](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/annotations-reference.html)。
- en: Understanding Doctrine Mapping Types
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Doctrine映射类型
- en: Doctrine Mapping Types used in the `@Column` annotation are neither SQL types
    nor PHP types but they are mapped to both. For instance, the Doctrine `text` type
    will be casted to the `string` PHP type in the entity and stored in a database
    column with the `CLOB` type.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@Column`注释中使用的Doctrine映射类型既不是SQL类型也不是PHP类型，但它们都被映射到。例如，Doctrine的`text`类型将被转换为实体中的`string`
    PHP类型，并存储在具有`CLOB`类型的数据库列中。
- en: 'The following is a correspondence table for Doctrine Mapping Type of PHP type
    and SQL type:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Doctrine映射类型的PHP类型和SQL类型的对应表：
- en: '| Doctrine Mapping Type | PHP Type | SQL Type |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: Doctrine映射类型 | PHP类型 | SQL类型 |
- en: '| --- | --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `string` | `string` | `VARCHAR` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '`string` | `string` | `VARCHAR` |'
- en: '| `integer` | `integer` | `INT` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '`integer` | `integer` | `INT` |'
- en: '| `smallint` | `integer` | `SMALLINT` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '`smallint` | `integer` | `SMALLINT` |'
- en: '| `bigint` | `string` | `BIGINT` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '`bigint` | `string` | `BIGINT` |'
- en: '| `boolean` | `boolean` | `BOOLEAN` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '`boolean` | `boolean` | `BOOLEAN` |'
- en: '| `decimal` | `double` | `DECIMAL` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '`decimal` | `double` | `DECIMAL` |'
- en: '| `date` | `\DateTime` | `DATETIME` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '`date` | `\DateTime` | `DATETIME` |'
- en: '| `time` | `\DateTime` | `TIME` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '`time` | `\DateTime` | `TIME` |'
- en: '| `datetime` | `\DateTime` | `DATETIME` or `TIMESTAMP` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '`datetime` | `\DateTime` | `DATETIME`或`TIMESTAMP` |'
- en: '| `text` | `string` | `CLOB` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '`text` | `string` | `CLOB` |'
- en: '| `object` | object using the `serialize()` and `unserialize()` methods | `CLOB`
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '`object` | 使用`serialize()`和`unserialize()`方法的对象 | `CLOB` |'
- en: '| `array` | `array` using `serialize()` and `unserialize()` methods | `CLOB`
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '`array` | 使用`serialize()`和`unserialize()`方法的`array` | `CLOB` |'
- en: '| `float` | `double` | `FLOAT` (double precision) |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '`float` | `double` | `FLOAT`（双精度） |'
- en: '| `simple_array` | `array` using `implode()` and `explode()`Values cannot contain
    comma. | `CLOB` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '`simple_array` | 使用`implode()`和`explode()`的`array`，值不能包含逗号 | `CLOB` |'
- en: '| `json_array` | `object` using `json_encode()` and `json_decode()` methods
    | `CLOB` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '`json_array` | 使用`json_encode()`和`json_decode()`方法的`object` | `CLOB` |'
- en: '| `guid` | `string` | `GUID` or `UUID` if supported by the DBMS, `VARCHAR`
    either |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '`guid` | `string` | 如果DBMS支持`GUID`或`UUID`，则为`GUID`，否则为`VARCHAR` |'
- en: '| `blob` | `resource stream` (see [http://www.php.net/manual/en/language.types.resource.php](http://www.php.net/manual/en/language.types.resource.php))
    | `BLOB` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '`blob` | `resource stream`（参见[http://www.php.net/manual/en/language.types.resource.php](http://www.php.net/manual/en/language.types.resource.php)）
    | `BLOB` |'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Keep in mind that we can create custom types. To learn more about this, refer
    to: [http://docs.doctrine-project.org/en/latest/cookbook/custom-mapping-types.html](http://docs.doctrine-project.org/en/latest/cookbook/custom-mapping-types.html)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们可以创建自定义类型。要了解更多信息，请参阅：[http://docs.doctrine-project.org/en/latest/cookbook/custom-mapping-types.html](http://docs.doctrine-project.org/en/latest/cookbook/custom-mapping-types.html)
- en: Creating the database schema
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库模式
- en: Doctrine is smart enough to generate the database schema corresponding to the
    entity mapping information.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine足够智能，可以生成与实体映射信息相对应的数据库模式。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's a good practice to always design entities first and to generate the related
    database schema after that.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计相关数据库模式之前，首先设计实体是一个很好的做法。
- en: 'To do this, we will again use Command-Line Tools installed in the first chapter.
    Type this command in the root directory of our project:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将再次使用第一章安装的命令行工具。在项目的根目录中键入以下命令：
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following text must be printed in the terminal:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文本必须在终端中打印：
- en: '**ATTENTION: This operation should not be executed in a production environment.**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：此操作不应在生产环境中执行。**'
- en: '**Creating database schema...**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建数据库模式...**'
- en: '**Database schema created successfully!**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库模式创建成功！**'
- en: 'A new table called `Post` has been created in the database. You can use the
    SQLite client to show the structure of the generated table:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中创建了一个名为`Post`的新表。您可以使用SQLite客户端来显示生成的表的结构：
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It should return the following query:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该返回以下查询：
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following screenshot is the structure of the table Post:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图是表Post的结构：
- en: '![Creating the database schema](graphics/4104OS_02_02.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![创建数据库模式](graphics/4104OS_02_02.jpg)'
- en: 'Doctrine is also able to generate the schema for MySQL and other supported
    DBMS. If we configure our app to use a MySQL server as a DBMS and we run the same
    command, the generated table will look similar to the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine也能够为MySQL和其他支持的DBMS生成模式。如果我们配置我们的应用程序使用MySQL服务器作为DBMS，并运行相同的命令，生成的表将类似于以下屏幕截图：
- en: '![Creating the database schema](graphics/4104OS_02_03.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![创建数据库模式](graphics/4104OS_02_03.jpg)'
- en: Installing Data fixtures
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装数据fixtures
- en: '**Fixtures** are fake data that allow testing of an app without having to do
    the tedious task of manually creating data after each install. They are useful
    for automated testing processes and make it easier for a new developer to start
    working on our projects.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fixtures**是允许在每次安装后无需手动创建数据就可以测试应用程序的虚假数据。它们对自动化测试过程很有用，并且使新开发人员更容易开始在我们的项目上工作。'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Any application should be covered with automated tests. The blog app we are
    building is covered by Behat ([http://behat.org/](http://behat.org/)) tests. They
    are provided in downloads available on the Packt website.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序都应该有自动化测试。我们正在构建的博客应用程序由Behat（[http://behat.org/](http://behat.org/)）测试覆盖。它们可以在Packt网站提供的下载中找到。
- en: Doctrine has an extension called Data Fixtures that ease fixtures creation.
    We will install it and use it to create some fake blog posts.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine有一个名为Data Fixtures的扩展，可以简化fixtures的创建。我们将安装它并使用它来创建一些虚假的博客帖子。
- en: 'Type this command in the root of the project to install Doctrine Data Fixtures
    through Composer:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根目录中键入以下命令，通过Composer安装Doctrine Data Fixtures：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first step to using Doctrine Data Fixtures is to create a fixture class.
    Create a file called `LoadPostData.php` in the `src/Blog/DataFixtures` directory
    as shown in the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Doctrine Data Fixtures的第一步是创建一个fixture类。在`src/Blog/DataFixtures`目录中创建一个名为`LoadPostData.php`的文件，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This `LoadPostData` class contains the logic to create fake data. It creates
    ten blog posts with a generated title, a date of publication, and a text body.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`LoadPostData`类包含创建虚假数据的逻辑。它创建了十篇博客帖子，其中包括生成的标题、发布日期和正文。
- en: 'The `LoadPostData` class implements the `load()`method defined in the `\Doctrine\Common\DataFixtures\FixtureInterface`
    directory. This method takes in parameters for an `EntityManager` instance:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadPostData`类实现了`\Doctrine\Common\DataFixtures\FixtureInterface`目录中定义的`load()`方法。这个方法接受一个`EntityManager`实例的参数：'
- en: 'Some reminders of [Chapter 1](ch01.html "Chapter 1. Getting Started with Doctrine
    2"), *Getting Started with Doctrine 2*: Calls to `EntityManager::persist()` sets
    the state of each new entity to managed'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章。使用Doctrine 2入门")的一些提醒，*使用Doctrine 2入门*：调用`EntityManager::persist()`将每个新实体的状态设置为已管理'
- en: The call to the `flush()` method, at the end of the process, will make Doctrine
    execute `INSERT` queries to effectively save data in the database
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在过程结束时，调用`flush()`方法将使Doctrine执行`INSERT`查询，有效地保存数据到数据库中
- en: 'We still need to create a loader for our fixtures class. Create a file called
    `load-fixtures.php` in the `bin/` directory of your project with the following
    code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要为我们的fixtures类创建一个加载器。在项目的`bin/`目录中创建一个名为`load-fixtures.php`的文件，并使用以下代码：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this utility, we initialize our app and get an Entity Manager as explained
    in [Chapter 1](ch01.html "Chapter 1. Getting Started with Doctrine 2"), *Getting
    Started with Doctrine 2*. Then, we instantiate the fixtures loader provided by
    Doctrine Data Fixtures and tell it where to find our fixtures files.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实用程序中，我们初始化我们的应用程序并按照[第1章](ch01.html "第1章。使用Doctrine 2入门")中的说明获取实体管理器，*使用Doctrine
    2入门*。然后，我们实例化了Doctrine Data Fixtures提供的fixtures加载器，并告诉它在哪里找到我们的fixtures文件。
- en: We only have the `LoadPostData` class for now but we will create additional
    fixtures in the next chapters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只有`LoadPostData`类，但我们将在接下来的章节中创建额外的fixtures。
- en: The `ORMExecutor` method is instanced and executed. It uses `ORMPurger` to erase
    existing data from the database. Then it populates the database with our fixtures.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`ORMExecutor`方法被实例化并执行。它使用`ORMPurger`从数据库中删除现有数据。然后它用我们的fixtures填充数据库。'
- en: 'Run the following command in the root directory of our project to load our
    fixtures:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们项目的根目录中运行以下命令来加载我们的fixtures：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our fixtures have been inserted in the database. Note that every time you run
    this command, all data in the database is permanently deleted.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的fixtures已经插入到数据库中。请注意，每次运行此命令时，数据库中的所有数据都将被永久删除。
- en: 'Check that our database has been populated with the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的数据库是否已经用以下命令填充：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see ten rows similar to the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到十行类似于以下内容的行：
- en: '**1|Blog post number 1|Lorem ipsum dolor sit amet, consectetur adipiscing elit.|2013-11-08
    20:01:13**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**1|博客帖子编号1|Lorem ipsum dolor sit amet，consectetur adipiscing elit。|2013-11-08
    20:01:13**'
- en: '**2|Blog post number 2|Lorem ipsum dolor sit amet, consectetur adipiscing elit.|2013-11-09
    20:01:13**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**2|博客帖子编号2|Lorem ipsum dolor sit amet，consectetur adipiscing elit。|2013-11-09
    20:01:13**'
- en: Creating a simple UI
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的UI
- en: We will create a simple UI to deal with our posts. This interface will let us
    create, retrieve, update, and delete a blog post. You may have already guessed
    that we will use the Entity Manager to do that.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的UI来处理我们的帖子。这个界面将让我们创建、检索、更新和删除博客帖子。你可能已经猜到我们将使用实体管理器来做到这一点。
- en: 'For concision and to focus on the Doctrine part, this UI will have many drawbacks.
    *It should not be used in any kind of production or public server*. The primary
    concerns are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁并专注于Doctrine部分，这个UI将有很多缺点。*它不应该在任何生产或公共服务器上使用*。主要问题如下：
- en: '**Not secure at all**: Everyone can access everything, as there is no authentication
    system, no data validation, and no CSRF protection'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一点也不安全**：每个人都可以访问一切，因为没有认证系统，没有数据验证，也没有CSRF保护'
- en: '**Badly designed**: There is no separation of concerns, no use of an MVC-like
    pattern, no REST architecture, no object-oriented code, and so on.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计不良**：没有关注点分离，没有使用类似MVC的模式，没有REST架构，没有面向对象的代码等等。'
- en: And of course this will be… graphically minimalistic!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这将是…图形上极简主义的！
- en: 'Cross Site Request Forgery (CSRF): [http://en.wikipedia.org/wiki/Cross-site_request_forgery](http://en.wikipedia.org/wiki/Cross-site_request_forgery)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨站点请求伪造（CSRF）：[http://en.wikipedia.org/wiki/Cross-site_request_forgery](http://en.wikipedia.org/wiki/Cross-site_request_forgery)
- en: 'Separation of concerns: [http://en.wikipedia.org/wiki/Separation_of_concerns](http://en.wikipedia.org/wiki/Separation_of_concerns)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点分离：[http://en.wikipedia.org/wiki/Separation_of_concerns](http://en.wikipedia.org/wiki/Separation_of_concerns)
- en: 'Model-View-Controller (MVC) meta-pattern: [http://en.wikipedia.org/wiki/Model-view-controller](http://en.wikipedia.org/wiki/Model-view-controller)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-控制器（MVC）元模式：[http://en.wikipedia.org/wiki/Model-view-controller](http://en.wikipedia.org/wiki/Model-view-controller)
- en: 'Representational state transfer (REST): [http://en.wikipedia.org/wiki/Representational_state_transfer](http://en.wikipedia.org/wiki/Representational_state_transfer)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表述状态转移（REST）：[http://en.wikipedia.org/wiki/Representational_state_transfer](http://en.wikipedia.org/wiki/Representational_state_transfer)
- en: 'For real-world apps, you should take a look at Symfony, a powerful framework
    that includes Doctrine and a ton of features (the validation component already
    presented, a form framework, a template engine, an internationalization system,
    and so on): [http://symfony.com/](http://symfony.com/)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于真实世界的应用程序，您应该看一下Symfony，这是一个强大的框架，包括Doctrine和大量功能（已经介绍了验证组件，表单框架，模板引擎，国际化系统等）：[http://symfony.com/](http://symfony.com/)
- en: Listing posts
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出帖子
- en: 'That being said, create the page that lists posts in the `web/index.php` file
    with the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在`web/index.php`文件中创建列出帖子的页面，代码如下：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This first file is the main page of the blog. It lists all posts and display
    links to pages for creating, updating, or deleting posts.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个文件是博客的主页面。它列出所有帖子，并显示链接到创建、更新或删除帖子的页面。
- en: After the app initialization, we get an `EntityManager` using the code we have
    written to configure Command-Line Tools in the first chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序初始化之后，我们使用我们在第一章中编写的代码来获取`EntityManager`以配置命令行工具。
- en: We use this `EntityManager` to retrieve the repository of our `\Blog\Entity\Post`
    entities. For now, we use the default entity repository provided by Doctrine.
    We will learn more about them in [Chapter 4](ch04.html "Chapter 4. Building Queries"),
    *Building Queries*. This default repository provides a `findAll()` method that
    retrieves a collection of all entities hydrated from the database.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个`EntityManager`来检索我们的`\Blog\Entity\Post`实体的存储库。目前，我们使用Doctrine提供的默认实体存储库。我们将在[第4章](ch04.html
    "Chapter 4. Building Queries")中了解更多关于它们的信息，*构建查询*。这个默认存储库提供了一个`findAll()`方法，用于检索从数据库中获取的所有实体的集合。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A `Collection` interface is similar to a regular PHP array (with some enhancements).
    This class is part of Doctrine Common: [http://www.doctrine-project.org/api/common/2.4/class-Doctrine.Common.Collections.Collection.html](http://www.doctrine-project.org/api/common/2.4/class-Doctrine.Common.Collections.Collection.html)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection`接口类似于常规的PHP数组（带有一些增强功能）。这个类是Doctrine Common的一部分：[http://www.doctrine-project.org/api/common/2.4/class-Doctrine.Common.Collections.Collection.html](http://www.doctrine-project.org/api/common/2.4/class-Doctrine.Common.Collections.Collection.html)'
- en: When calling it, Doctrine will query the database to find all rows of the `Post`
    table and populate a collection of `\Blog\Entity\Post` objects with the retrieved
    data. This collection is assigned to the `$posts` variable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 调用它时，Doctrine将查询数据库以查找`Post`表的所有行，并使用检索到的数据填充`\Blog\Entity\Post`对象的集合。这个集合被分配给`$posts`变量。
- en: 'To browse this page, run the following command in the root directory of your
    project:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要浏览此页面，请在项目的根目录中运行以下命令：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This runs the built-in PHP webserver. Go to `http://localhost:8000` in your
    favorite web browser, and you'll see our ten fake posts.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行内置的PHP Web服务器。在您喜欢的Web浏览器中转到`http://localhost:8000`，您将看到我们的十个虚假帖子。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If it does not work, be sure that your PHP version is at least 5.4.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不起作用，请确保您的PHP版本至少为5.4。
- en: Creating and editing posts
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和编辑帖子
- en: 'It''s time to create a page to add new blog posts. This same page will also
    allow editing an existing post. Put it in the `web/edit-post.php` file as shown
    in the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建一个页面来添加新的博客帖子了。将其放在`web/edit-post.php`文件中，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This page is a bit trickier:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面有点棘手：
- en: When called with an `id` parameter in the URL, it works on the `Post` entity
    with the given ID
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在URL中带有`id`参数时，它会处理具有给定ID的`Post`实体
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A best practice would be to use slugs instead of identifiers. They hide an
    application''s internals, can be memorized by humans, and are better for Search
    Engine Optimization: [http://en.wikipedia.org/wiki/Slug_(publishing)](http://en.wikipedia.org/wiki/Slug_(publishing)).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是使用slug而不是标识符。它们隐藏了应用程序的内部，可以被人类记住，并且对于搜索引擎优化更好：[http://en.wikipedia.org/wiki/Slug_(publishing)](http://en.wikipedia.org/wiki/Slug_(publishing))。
- en: With no `id` parameter, it instantiates a new `Post` entity
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有`id`参数时，它会实例化一个新的`Post`实体
- en: When called with the `GET` HTTP method, it displays a form populated with the
    current data of the `Post` in the case of an edit
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用`GET` HTTP方法调用时，它会显示一个填充有当前`Post`数据的表单，以进行编辑
- en: When called with the `Post` HTTP method (when the form is submitted), it creates
    or updates a `Post` entity, then redirects to the homepage of the blog
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用`Post` HTTP方法（当表单被提交时）时，它会创建或更新`Post`实体，然后重定向到博客的主页
- en: If an ID is provided through the URL, the `find()` method of the Entity Manager
    is used to retrieve the entity stored in the database with this ID. Doctrine queries
    the database and hydrates the entity for us.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过URL提供了ID，则实体管理器的`find()`方法用于检索存储在数据库中的具有此ID的实体。Doctrine查询数据库并为我们填充实体。
- en: If no `Post` with this ID is found, the `NULL` value is assigned to the `$post`
    variable instead of an instance of `\Blog\Entity\Post`. To avoid further errors,
    we throw an exception if this is the case. To find out more about PHP exceptions,
    refer to the website [http://php.net/manual/en/language.exceptions.php](http://php.net/manual/en/language.exceptions.php).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到具有此ID的`Post`，则将`NULL`值分配给`$post`变量，而不是`\Blog\Entity\Post`的实例。为了避免进一步的错误，如果是这种情况，我们会抛出一个异常。要了解更多关于PHP异常的信息，请参考网站[http://php.net/manual/en/language.exceptions.php](http://php.net/manual/en/language.exceptions.php)。
- en: Then, we call the `persist()` method of the Entity Manager with our new entity
    as a parameter. As explained in [Chapter 1](ch01.html "Chapter 1. Getting Started
    with Doctrine 2"), *Getting Started with Doctrine 2*, this call to the `persist()`
    method sets the state of the entity to managed. It is necessary only for new entities
    because entities retrieved through Doctrine already have the managed state.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用我们的新实体作为参数调用实体管理器的`persist()`方法。如[第1章](ch01.html "第1章。使用Doctrine 2入门")*使用Doctrine
    2入门*中所述，对`persist()`方法的调用将实体的状态设置为受管理状态。这仅对新实体是必要的，因为通过Doctrine检索的实体已经具有受管理状态。
- en: Next, we set the publication date of our newly created object. Thanks to the
    Doctrine mapping system, we just need to pass a `\DateTime` instance to the `setPublicationDate()`
    method and the ORM will convert it to the format needed by the DBMS for us (refer
    to the type correspondence table).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置我们新创建对象的发布日期。多亏了Doctrine映射系统，我们只需要将`\DateTime`实例传递给`setPublicationDate()`方法，ORM将为我们将其转换为DBMS所需的格式（参考类型对应表）。
- en: We also set the `$title` and `$body` properties using the fluent interface of
    getters and setters generated previously.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用先前生成的getter和setter的流畅接口设置了`$title`和`$body`属性。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you don''t know about fluent interface, read the following article: [http://martinfowler.com/bliki/FluentInterface.html](http://martinfowler.com/bliki/FluentInterface.html)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不了解流畅接口，请阅读以下文章：[http://martinfowler.com/bliki/FluentInterface.html](http://martinfowler.com/bliki/FluentInterface.html)
- en: When the call to the `flush()` method occurs, the Entity Manager tells Doctrine
    to synchronize all managed entities to the database. In this case, only our `Post`
    entity is managed. If it's a new entity, an `INSERT` SQL statement will be generated.
    If it's an existing entity, an `UPDATE` statement will be sent to the DBMS.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`flush()`方法时，实体管理器告诉Doctrine将所有受管理的实体与数据库同步。在这种情况下，只有我们的`Post`实体是受管理的。如果它是一个新实体，将生成一个`INSERT`
    SQL语句。如果它是一个现有实体，将向DBMS发送一个`UPDATE`语句。
- en: By default, Doctrine automatically wraps all operations done when the `EntityManager::flush()`
    method is called in a transaction. If an error occurs, the database state is restored
    as it was before the flush call (rollback).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Doctrine在调用`EntityManager::flush()`方法时自动将所有操作包装在事务中。如果发生错误，数据库状态将恢复到刷新调用之前的状态（回滚）。
- en: This is usually the best option, but if you have specific needs, this auto-commit
    mode can be deactivated. This can be referred to at [http://docs.doctrine-project.org/en/latest/reference/transactions-and-concurrency.html](http://docs.doctrine-project.org/en/latest/reference/transactions-and-concurrency.html).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是最好的选择，但如果您有特定的需求，可以停用此自动提交模式。可以在[http://docs.doctrine-project.org/en/latest/reference/transactions-and-concurrency.html](http://docs.doctrine-project.org/en/latest/reference/transactions-and-concurrency.html)中找到相关信息。
- en: Deleting posts
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除帖子
- en: 'Let''s create a page to delete posts in the `web/delete-post.php` file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`web/delete-post.php`文件中创建一个删除帖子的页面。
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We retrieve the post we want to delete using the ID parameter in the URL. We
    tell Doctrine to schedule it for removal with the call to the `EntityManager::remove()`
    method. After this call, the state of the entity is removed. When the `flush()`
    method is called, Doctrine executes a `DELETE` SQL query to remove data from the
    database.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用URL中的ID参数检索要删除的帖子。我们告诉Doctrine安排删除它，调用`EntityManager::remove()`方法。在此调用之后，实体的状态被移除。当调用`flush()`方法时，Doctrine执行`DELETE`
    SQL查询以从数据库中删除数据。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that after the call to the `flush()` method and the deletion from the database,
    the entity still exists in memory.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在调用`flush()`方法并从数据库中删除后，实体仍然存在于内存中。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We now have a minimal but working blog app! Thanks to Doctrine, persisting,
    retrieving, and removing data to a database has never been so easy.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个最小但可用的博客应用程序！多亏了Doctrine，将数据持久化、检索和删除到数据库中从未如此简单。
- en: We have learned how to use annotations to map entity classes to database tables
    and rows, we generated a database schema without typing a line of SQL, we created
    fixtures and we used the Entity Manager to synchronize data with the database.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用注释将实体类映射到数据库表和行，我们生成了数据库模式而不需要输入一行SQL，我们创建了固定装置，并且我们使用实体管理器将数据与数据库同步。
- en: In the next chapter, we will learn how to map and manage One-To-One, One-To-Many/Many-To-One,
    and Many-To-Many associations between entities.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在实体之间映射和管理一对一、一对多/多对一和多对多的关联。
