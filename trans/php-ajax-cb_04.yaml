- en: Chapter 4. Advanced Utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章.高级工具
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building an Ajax chat system using the Comet technique
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Comet技术构建Ajax聊天系统
- en: Charting with JavaScript
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript绘制图表
- en: Decoding Captcha through canvas
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过画布解码验证码
- en: Displaying data in a grid
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网格中显示数据
- en: In this chapter, we're going to look at building a simple Ajax chat application
    using the Comet technique. **Comet** is a technique in web applications to push
    data to the client from a web server without the explicit need for a client to
    request it. In this application, we will use this simple Comet technique to push
    the chat message from the server to the browser, without using any special Comet
    server for it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看如何使用Comet技术构建一个简单的Ajax聊天应用程序。**Comet**是Web应用程序中的一种技术，可以在不需要客户端显式请求的情况下从Web服务器向客户端推送数据。在这个应用程序中，我们将使用这种简单的Comet技术，将聊天消息从服务器推送到浏览器，而不使用任何特殊的Comet服务器。
- en: In the *Charting with JavaScript* section, we will look at how to use the Google
    Visualization API to build an interactive chart using JavaScript.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用JavaScript绘制图表*部分，我们将看看如何使用Google Visualization API来使用JavaScript构建交互式图表。
- en: After that, we're going to show you how Ajax programming with canvas can decode
    a simple Captcha on the browser itself, using a Firefox Greasemonkey script.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将展示如何使用Firefox Greasemonkey脚本，通过画布来解码浏览器上的简单验证码。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The chat application used here doesn't use any Comet server such as APE ([http://www.ape-project.org](http://www.ape-project.org)
    ) or Livestreamer ([http://www.livestream.com](http://www.livestream.com)). We're
    just trying here to show how to get information from the server using Ajax with
    long polling, rather than traditional polling.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的聊天应用程序不使用任何Comet服务器，如APE（[http://www.ape-project.org](http://www.ape-project.org)）或Livestreamer（[http://www.livestream.com](http://www.livestream.com)）。我们在这里只是试图展示如何使用Ajax进行长轮询，而不是传统的轮询来从服务器获取信息。
- en: Building an Ajax chat system using the Comet technique
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Comet技术构建Ajax聊天系统
- en: Now, let's look at how to build a simple Ajax chat system using Ajax with the
    long polling technique. We've used the jQuery framework of JavaScript for most
    of the JavaScript code. In the traditional Ajax polling system, a request is sent
    to the server at regular intervals; so, whether there is new data or not, the
    server has to deal with the HTTP request. But in Ajax, with the long polling technique,
    the request is kept open from the server-side script until the server has new
    data to send to the browser.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用长轮询技术构建一个简单的Ajax聊天系统。我们大部分使用了JavaScript的jQuery框架来编写JavaScript代码。在传统的Ajax轮询系统中，会定期向服务器发送请求；因此，无论是否有新数据，服务器都必须处理HTTP请求。但是在Ajax中，使用长轮询技术，请求会一直保持开放，直到服务器有新数据发送到浏览器。
- en: However, in our chat example, we're keeping the Ajax request open for 90 seconds.
    If there is no new chat message received from the server, the connection is closed
    and a new Ajax polling is opened.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的聊天示例中，我们将Ajax请求保持开放90秒。如果服务器没有收到新的聊天消息，连接将被关闭，并打开一个新的Ajax轮询。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First of all, let''s look at what the interface of this application is like:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看这个应用程序的界面是什么样子的：
- en: '![Getting ready](graphics/3081_04_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](graphics/3081_04_01.jpg)'
- en: This chat utility has a very simple interface. You need to set a username to
    send chat messages.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个聊天工具有一个非常简单的界面。您需要设置一个用户名来发送聊天消息。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'There are different types of code associated with this Comet chat system. Let''s
    go through each part:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与这个Comet聊天系统相关的代码有不同类型。让我们逐个部分来看：
- en: 'The following HTML code forms the chat system''s layout:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下HTML代码构成了聊天系统的布局：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now let's look at the PHP code for saving a message to a text file and to keep
    the Ajax request open until a new message is saved in the file. You can find this
    code in the `chat-backend.php` file.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看看保存消息到文本文件并保持Ajax请求开放直到文件中保存了新消息的PHP代码。您可以在`chat-backend.php`文件中找到这段代码。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let's look at the JavaScript code for making the chat functional.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看使聊天功能生效的JavaScript代码。
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now, let''s look at the how this Ajax chat works with the Comet implementation.
    Some aspects of it are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个Ajax聊天是如何与Comet实现一起工作的。它的一些方面如下：
- en: 'Saving a chat message to a file:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将聊天消息保存到文件中：
- en: The chat message is saved to the file in our application. Only the latest chat
    message is saved to the file. The previous chat messages are replaced by the latest
    message.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天消息被保存到文件中。在我们的应用程序中，只有最新的聊天消息被保存到文件中。之前的聊天消息被最新消息替换。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The special characters of the message are converted into HTML entities, to convert
    the HTML special characters and avoid malformation of the HTML in the chat string.
    Then, the message, with username, is stored in the `$file_name` variable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 消息的特殊字符被转换为HTML实体，以转换HTML特殊字符并避免聊天字符串中的格式错误。然后，带有用户名的消息存储在`$file_name`变量中。
- en: 'Implementing Comet with long Ajax polling:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用长Ajax轮询实现Comet：
- en: Now, let's look at the way we've implemented Comet with long Ajax polling.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用长Ajax轮询实现Comet。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the first line of code, we''re storing the entrance time to PHP script in
    the `$entrance_time` variable to prevent execution of script for more than 90
    seconds as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第一行，我们将PHP脚本的进入时间存储在`$entrance_time`变量中，以防止脚本执行超过90秒，如下所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the first line of the code in `chat-backend.php`, we've set the maximum execution
    time of the script to `91` (seconds), so that PHP doesn't throw a Fatal Error
    on the long execution time of script; because, by default, the `max_execution_time`
    of the PHP script is set to `30` in the `php.ini` file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chat-backend.php`代码的第一行中，我们将脚本的最大执行时间设置为`91`（秒），这样PHP在脚本的长时间执行时不会抛出致命错误；因为默认情况下，PHP脚本的`max_execution_time`在`php.ini`文件中设置为`30`。
- en: 'Now, let''s look at the main `while` loop, which blocks the Ajax call until
    a new chat message is received:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看主要的`while`循环，它会阻塞Ajax调用，直到接收到新的聊天消息为止：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''ve stored the last file-modified time value in the `$last_modif` variable
    and current file-modified time in the `$curre_ftime` variable. The `while` loop
    keeps getting executed until two conditions are satisfied: the first one is that
    the last modification time of the text file should be greater than or equal to
    the current file modification time, and the second condition checks whether the
    script execution time so far has reached 90 seconds or not. So, if the file has
    been modified or script execution time is 90 seconds, then the request gets completed
    and response is sent to browser. Otherwise, the request gets blocked for long
    Ajax polling.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将最后一次文件修改时间值存储在`$last_modif`变量中，将当前文件修改时间存储在`$curre_ftime`变量中。`while`循环一直执行，直到满足两个条件：第一个条件是文本文件的最后修改时间应大于或等于当前文件修改时间，第二个条件检查脚本执行时间是否达到90秒。因此，如果文件已被修改或脚本执行时间为90秒，则请求完成并将响应发送到浏览器。否则，请求将被长时间的Ajax轮询阻塞。
- en: 'On the JavaScript side, we call the `Comet.connect()` function when the DOM
    is ready for manipulation. This function makes an Ajax request to the `chat-backend.php`
    file. Now, let''s see how Ajax response is handled here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript端，当DOM准备好进行操作时，我们调用`Comet.connect()`函数。此函数向`chat-backend.php`文件发出Ajax请求。现在，让我们看看这里如何处理Ajax响应：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When we get a successful Ajax response, we check if the file modification time
    is greater than the timestamp sent to the server for checking or not. This condition
    is satisfied if the modification time of the file has been changed. In that case,
    we assign the `ts` variable to the current timestamp of file modification time
    and call the `show_response()` function to show the latest chat message to the
    browser. It then calls the `Comet.function()`, instantly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到成功的Ajax响应时，我们会检查文件修改时间是否大于发送到服务器进行检查的时间戳。如果文件的修改时间已经改变，则满足此条件。在这种情况下，我们将`ts`变量赋值为文件修改时间的当前时间戳，并调用`show_response()`函数将最新的聊天消息显示给浏览器。然后立即调用`Comet.function()`。
- en: If there is error in the Ajax request, it waits for 5 seconds before sending
    another request to the `connect()` function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Ajax请求出现错误，它会在发送另一个请求到`connect()`函数之前等待5秒。
- en: 'Displaying the response:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示响应：
- en: 'Now, let''s look at the how the response is displayed:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下响应是如何显示的：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this function, we're appending the Ajax response to the `div` with the ID
    `chattext`. After that, we set value of `scrollTop` (which means the vertical
    position of the scrollbar, if it exists) to `scrollHeight`. The `ScrollHeight`
    property gives the height of the scroll view of the element.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们将Ajax响应附加到具有ID`chattext`的`div`。之后，我们将`scrollTop`的值（如果存在滚动条，则表示滚动条的垂直位置）设置为`scrollHeight`。`ScrollHeight`属性给出元素的滚动视图的高度。
- en: Charting with JavaScript
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript制作图表
- en: In this section, we will look at an example of how to create interactive charts
    using Google Visualization's JavaScript API. The **Google Visualization API**
    provides a powerful set of functions for creating different kinds of charts, such
    as pie chart, line chart, bar chart, and so on. In this section, we will see,
    in brief, how to create them using this API.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一个示例，演示如何使用Google可视化的JavaScript API创建交互式图表。**Google可视化API**提供了一组强大的函数，用于创建不同类型的图表，如饼图、折线图、条形图等。在本节中，我们将简要地看一下如何使用此API来创建它们。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Now, let's look at the basic steps to follow to use Google Visualization API
    to create different styles of charting. We will be looking at an example where
    we create a bar chart, line chart, and pie chart on the page. Now, let's go through
    the preliminary steps to create the chart using the Visualization API.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下使用Google可视化API创建不同样式的图表的基本步骤。我们将看一个示例，在其中我们在页面上创建条形图、折线图和饼图。现在，让我们通过使用可视化API来创建图表的初步步骤。
- en: 'Placing a chart container:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置图表容器：
- en: 'First of all, we need to place an HTML element in the web page that holds the
    chart. Typically, it should be a block-level element. Let''s start with the popular
    block-level element <div>, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在网页中放置一个包含图表的HTML元素。通常，它应该是一个块级元素。让我们从流行的块级元素<div>开始，如下所示：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Please make sure you assign an ID attribute to this HTML element, as this element's
    reference can be passed using the `document.getElementById()` JavaScript function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保为此HTML元素分配一个ID属性，因为可以使用`document.getElementById()` JavaScript函数传递此元素的引用。
- en: 'Loading Google Visualization API:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载Google可视化API：
- en: 'After creating the container for the chart, let''s try to load the Google Visualization
    API here, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图表容器后，让我们尝试在这里加载Google可视化API，如下所示：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code snippet, we included the Google JavaScript API here in
    our web page. After including the JavaScript file, we now need to load the Google
    API''s visualization module:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在网页中包含了Google JavaScript API。在包含JavaScript文件之后，我们现在需要加载Google API的可视化模块：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `load()` function, the first parameter is the name of the module we wanted
    to load; in our case, the `visualization` module. The second parameter is the
    version of the module; 1 is the latest version here. In the third parameter, we're
    specifying which particular package has to be loaded from the module. In our case,
    it is the `corechart` package. The `corechart` library supports server types of
    common charts, such as bar chart, line chart, and pie chart.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`load()`函数中，第一个参数是我们想要加载的模块的名称；在我们的情况下是`visualization`模块。第二个参数是模块的版本；这里是1是最新版本。在第三个参数中，我们指定了从模块中加载哪个特定的包。在我们的情况下，是`corechart`包。`corechart`库支持常见图表类型，如条形图、折线图和饼图。
- en: 'We need to work with the function of the JavaScript API once the JavaScript
    library is fully loaded. To help with this situation, Google''s JavaScript API
    provides a function called setOnloadCallback(); it allows us to add the `callback`
    function when a particular module is loaded:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦JavaScript库完全加载，我们需要使用JavaScript API的函数。为了帮助解决这种情况，Google的JavaScript API提供了一个名为setOnloadCallback()的函数；它允许我们在特定模块加载时添加回调函数：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, the user-defined function called `draw_line_chart`
    is called when Google Visualization library is loaded.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，当Google Visualization库加载时，会调用名为`draw_line_chart`的用户定义函数。
- en: After learning how to load the Google Visualization API, let's look at the examples
    to draw the bar chart, line chart, and pie chart.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何加载Google Visualization API之后，让我们看一下绘制柱状图、折线图和饼图的示例。
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Now, let''s see how the different charts (which we''re going to creating using
    the visualization API) appear:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用可视化API创建的不同图表的外观：
- en: '![How it works...](graphics/3081_04_02.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/3081_04_02.jpg)'
- en: Drawing a line chart
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制折线图
- en: Now that we know what the created charts look like, let's create the line chart
    first. The line chart can be seen in the preceding image. The full code can be
    found in the `line-chart.html` file, provided in the code bundle. Now, let's go
    through different steps to create the line chart.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道创建的图表是什么样子的，让我们首先创建折线图。可以在上面的图像中看到折线图。完整的代码可以在代码包中提供的`line-chart.html`文件中找到。现在，让我们逐步创建折线图。
- en: In this section, we will see how to create the line graph to show the population
    growth of two major cities in the world, New York and London, and compare them
    with the line graph.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何创建线图，以显示世界上两个主要城市纽约和伦敦的人口增长，并将它们与线图进行比较。
- en: 'Preparing data for the chart:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为图表准备数据：
- en: To prepare data for the chart, we first need to store the data in the object
    of the `DataTable` class available within Google Visualization API to represent
    two-dimensional data for the array.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了为图表准备数据，我们首先需要将数据存储在Google Visualization API中的`DataTable`类的对象中，以表示数组的二维数据。
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, the next step is to add the column for the graph. We''re displaying two
    lines on the graph showing the growth of the population in two cities, New York
    and London, on a decennial basis. For this, we need to create three columns for
    the object `DataTable`, using the `addColumn()` function:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，下一步是为图表添加列。我们在图表上显示两条线，显示纽约和伦敦的人口增长，以十年为单位。为此，我们需要使用`addColumn()`函数为`DataTable`对象创建三列：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, create the three empty rows using the `addRows()` function. You can also
    pass the array to the `addRows()` function to create rows with data. We will see
    how to do that while creating the bar chart.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，使用`addRows()`函数创建三行空行。您还可以将数组传递给`addRows()`函数，以创建带有数据的行。我们将在创建柱状图时看到如何做到这一点。
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After creating the empty rows, let''s set the values on those empty rows using
    the `setValue()` function, as follows:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建空行之后，让我们使用`setValue()`函数在这些空行上设置值，如下所示：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first and second parameters of the `setValue()` function denote the row
    and column of the matrix. For example, the value `1,2` represents the second row
    and third column of the matrix.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`setValue()`函数的第一个和第二个参数表示矩阵的行和列。例如，值`1,2`表示矩阵的第二行和第三列。'
- en: 'Displaying a line chart:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示折线图：
- en: 'After creating the data for the chart in the data variable, now create and
    display the chart:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在data变量中创建图表数据后，现在创建并显示图表：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we're creating a line chart in the div, with ID.chart,
    using the LineChart() function of Google Visualization API. Now, the chart object
    is created and is available at the chart variable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们正在使用Google Visualization API的LineChart()函数在ID.chart的div中创建折线图。现在，图表对象已经创建，并且可以在chart变量中使用。
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, the chart is drawn using the draw() function, which accepts two parameters:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用draw()函数绘制图表，该函数接受两个参数：
- en: The first one is the data of the chart, which is an object of the class `DataTable`.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是图表的数据，它是`DataTable`类的对象。
- en: The second one specifies the different options like width, height, title of
    the chart, and so on. The whole list of parameters can be found here at [http://code.google.com/apis/visualization/documentation/gallery/linechart.html.](http://code.google.com/apis/visualization/documentation/gallery/linechart.html.)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数指定不同的选项，如宽度、高度、图表标题等。可以在[http://code.google.com/apis/visualization/documentation/gallery/linechart.html](http://code.google.com/apis/visualization/documentation/gallery/linechart.html)找到参数的完整列表。
- en: The chart is drawn representing respective values automatically on the X-axis
    and Y-axis.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图表是自动在X轴和Y轴上表示各自的值。
- en: Drawing a bar chart
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制柱状图
- en: In this section, we will see how to draw the bar chart using Google Visualization
    API. We will visualize the population growth of London and New York in this example,
    using the same data that we used in the previous example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何使用Google Visualization API绘制柱状图。在这个例子中，我们将使用与前一个例子中相同的数据来可视化伦敦和纽约的人口增长。
- en: This chart can be seen on the right-hand side of the preceding image.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表可以在上面图像的右侧看到。
- en: 'Preparing the data:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备数据：
- en: 'Let''s look at the code to create the data for visualization using a bar chart.
    To hold the chart data, we need to create an instance of the `DataTable()` class,
    as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下使用柱状图可视化创建数据的代码。为了保存图表数据，我们需要创建`DataTable()`类的实例，如下所示：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see in the preceding code, after adding the columns for the data
    table, we've added the rows using the `addRows()` function. We've used this function
    in a different way before, to create empty rows. Here, it will create three rows
    directly, with the data of the array.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码中所示，在为数据表添加列之后，我们使用`addRows()`函数添加了行。我们之前以不同的方式使用了这个函数，创建了空行。在这里，它将直接创建三行，带有数组的数据。
- en: 'Displaying a bar chart:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示柱状图：
- en: 'After preparing the data for the bar chart, let''s draw it on the web page:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好数据后，让我们在网页上绘制它：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We're drawing a bar chart with a width of `600` pixels and height of `360` pixels,
    using the `object ColumnChart()` class. Using the options `hAxis` and `vAxix`,
    we're displaying the label `Year` on the horizontal axis and `Population` on the
    vertical axis. You can read about more options for the column chart API at [http://code.google.com/apis/chart/interactive/docs/gallery/columnchart.html.](http://code.google.com/apis/chart/interactive/docs/gallery/columnchart.html)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在绘制一个宽度为600像素，高度为360像素的条形图，使用“object ColumnChart()”类。使用“hAxis”和“vAxix”选项，我们在水平轴上显示标签“Year”，在垂直轴上显示标签“Population”。您可以在[http://code.google.com/apis/chart/interactive/docs/gallery/columnchart.html](http://code.google.com/apis/chart/interactive/docs/gallery/columnchart.html)了解有关柱状图API的更多选项。
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `BarChart()` class is also available in Google Visualization API, but it
    creates a horizontal bar chart. You can find more about this type of chart at
    [http://code.google.com/apis/chart/interactive/docs/gallery/barchart.html](http://code.google.com/apis/chart/interactive/docs/gallery/barchart.html).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: “BarChart()”类也在Google Visualization API中可用，但它创建的是水平条形图。您可以在[http://code.google.com/apis/chart/interactive/docs/gallery/barchart.html](http://code.google.com/apis/chart/interactive/docs/gallery/barchart.html)找到更多关于这种类型图表的信息。
- en: Drawing a 3D pie chart
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制3D饼图
- en: In this section, we will see how to create a pie chart using Google Visualization
    API. The sample pie chart produced by this example is shown on the left side of
    the preceding image.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看到如何使用Google Visualization API创建饼图。此示例生成的饼图显示在前图的左侧。
- en: In this example, we will break down the hours involved in developing a simple
    website and visualize them using a pie chart.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将分解开发简单网站所需的时间，并使用饼图进行可视化。
- en: 'Preparing the data:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备数据：
- en: Let's look at how we create the data for visualization of the project using
    a pie chart. As usual, we need to create an instance of the `DataTable()` class
    to store the data that needs to be populated.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建用于项目可视化的饼图数据。和往常一样，我们需要创建“DataTable()”类的实例来存储需要填充的数据。
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see in the preceding code, we're creating two columns to hold the
    data for the hours spent on different phases of a project. The first column is
    `Phase` and the second column is `Hours spent` (the time spent on that particular
    phase of the project).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在上面的代码中所见，我们正在创建两列来存储项目不同阶段所花费的时间的数据。第一列是“Phase”，第二列是“Hours spent”（在项目的特定阶段花费的时间）。
- en: 'Displaying a pie chart:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展示饼图：
- en: 'Now, let''s look at the actual code that will draw the pie chart on the `div`
    with ID chart:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下实际的代码，它将在ID为chart的div上绘制饼图：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, first the object of the `PieChart()` class is created.
    Then, the chart is drawn using the `draw()` function. The pie chart is drawn summing
    total hours given in column 2 as 100%. Please note that we've set the `is3D` option
    to `true`, to display a 3D pie chart.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，首先创建了“PieChart()”类的对象。然后，使用“draw()”函数绘制图表。饼图是通过将第2列中给定的总小时数作为100%来绘制的。请注意，我们将“is3D”选项设置为“true”，以显示3D饼图。
- en: Decoding CAPTCHA through canvas
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过canvas解码CAPTCHA
- en: '**CAPTCHA** (or **Captcha)** is an acronym for **C**ompletely **A**utomated
    **P**ublic **T**uring test to tell **C**omputers and **H**umans **A**part, based
    on the word ''capture''. It was originally coined by Luis von Ahn, Manuel Blum,
    Nicholas J. Hopper, and John Langford. **CAPTCHA** is meant to stop machines and
    robots from accessing webpage functionalities; it is usually placed in a web page''s
    signup form to ensure only human beings are signing up with the site. Often, it
    is based on the fact that computers find it difficult to recognize text when presented
    in image form. More research and advanced techniques of **OCR (Optical Character
    Recognition)** are weakening the Captcha concept, which in turn forces further
    research on Captcha. HTML5''s `canvas` element opens up the possibility of decoding
    it through JavaScript programming.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAPTCHA**（或**Captcha**）是**C**ompletely **A**utomated **P**ublic **T**uring
    test to tell **C**omputers and **H**umans **A**part的缩写，基于单词''capture''。它最初是由Luis
    von Ahn，Manuel Blum，Nicholas J. Hopper和John Langford创造的。**CAPTCHA**旨在阻止机器和机器人访问网页功能；通常放置在网页的注册表单中，以确保只有人类才能注册网站。通常，它基于计算机难以识别图像形式的文本。更多关于**OCR（光学字符识别）**的研究和先进技术正在削弱Captcha的概念，这反过来迫使对Captcha进行进一步研究。HTML5的“canvas”元素通过JavaScript编程打开了通过解码的可能性。'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `canvas` element is part of the HTML5 specification. It was introduced by
    Apple in a WebKit component. After that, it was adopted by Gecko-based browsers,
    such as Mozilla Firefox. As of now, most of the browsers support it natively or
    through plugins. Earlier, SVG was promoted as a standard for drawing shapes, but
    `canvas` gained popularity due to its speed and lower-level protocol.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: “canvas”元素是HTML5规范的一部分。它是由苹果在WebKit组件中引入的。之后，它被Gecko内核的浏览器采用，比如Mozilla Firefox。目前，大多数浏览器都原生支持它或通过插件支持。早些时候，SVG被推广为绘制形状的标准，但由于其速度和低级协议，canvas变得更受欢迎。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll require a browser that supports `canvas`. Generally, Firefox and Safari
    have built-in support for canvas. For displaying canvas in Internet Explorer,
    we may require plugins from Mozilla or Google.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个支持“canvas”的浏览器。一般来说，Firefox和Safari内置支持canvas。在Internet Explorer中显示canvas，可能需要来自Mozilla或Google的插件。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Google Chrome Frame (available at [http://code.google.com/chrome/chromeframe/)](http://code.google.com/chrome/chromeframe/))
    is a plugin that adds Chrome's JavaScript engine to Internet Explorer; it supports
    `canvas` too.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Google Chrome Frame（可在[http://code.google.com/chrome/chromeframe/)](http://code.google.com/chrome/chromeframe/)找到）是一个插件，它将Chrome的JavaScript引擎添加到Internet
    Explorer；它也支持“canvas”。
- en: '`explorercanvas` ( available at [http://code.google.com/p/explorercanvas/)](http://code.google.com/p/explorercanvas/))
    is a JavaScript library, which, when added, converts `canvas` to VML and supports
    it on IE.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: “explorercanvas”（可在[http://code.google.com/p/explorercanvas/)](http://code.google.com/p/explorercanvas/)找到）是一个JavaScript库，添加后将“canvas”转换为VML并在IE上支持它。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The concept of OCR with JavaScript got attention when a Greasemonkey script,
    developed by Shaun, was able to recognize MegaUpload's (the file sharing website's)
    Captcha. For a file sharing website, Captcha is a way to avoid machine-enforced
    downloading that might be from competitors or pirates. The Greasemonkey script
    here used `canvas` and its ability to be accessed through JavaScript.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个由Shaun开发的Greasemonkey脚本能够识别MegaUpload（文件共享网站）的验证码时，JavaScript的OCR概念引起了人们的关注。对于文件共享网站，验证码是避免机器下载的一种方式，这可能来自竞争对手或盗版者。这里的Greasemonkey脚本使用了`canvas`及其通过JavaScript访问的能力。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Greasemonkey** was originally a Firefox extension to execute user scripts
    on particular domains and URLs, at the time when the page gets displayed, thereby
    changing appearance or functionality. Now, other browsers have also started supporting
    Greasemonkey scripts, to some extent.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Greasemonkey最初是一个Firefox扩展，用于在特定域和URL上执行用户脚本，当页面显示时改变外观或功能。现在，其他浏览器也开始在一定程度上支持Greasemonkey脚本。
- en: The complete source can be found at Greasemonkey's website—[http://www.userscripts.org/scripts/review/38736](http://www.userscripts.org/scripts/review/38736).
    Here, we will review the concept of doing it in JavaScript with `canvas:`
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在Greasemonkey的网站上找到—[http://www.userscripts.org/scripts/review/38736](http://www.userscripts.org/scripts/review/38736)。在这里，我们将使用`canvas`的JavaScript来审查这个概念：
- en: The Captcha image is loaded to `canvas` and the image data is read through `getImageData()`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证码图像加载到`canvas`并通过`getImageData()`读取图像数据。
- en: The image is then converted to grayscale.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将图像转换为灰度。
- en: The image is further divided into three, for each character. This was easier
    with MegaUpload's Captcha, as it had a fixed distance.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图像进一步分成三部分，每部分一个字符。对于MegaUpload的验证码来说，这更容易，因为它的距离是固定的。
- en: The image is further processed to convert it in to two colors—black and white
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图像进一步处理以将其转换为两种颜色—黑色和白色
- en: The divided images are cropped further to have sort of receptors.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进一步裁剪分割的图像以获得一种受体。
- en: Receptor data is then passed to a neural network to recognize the characters.
    The neural network data is pre-seeded with data from previous runs to get a better
    match.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将受体数据传递给神经网络以识别字符。神经网络数据预先使用以前运行的数据进行种植，以获得更好的匹配。
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following image shows a sample Captcha found at the MegaUpload website:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了在MegaUpload网站上找到的一个示例验证码：
- en: '![How it works...](graphics/3081_04_03.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/3081_04_03.jpg)'
- en: 'Here, each processing phase that is described as follows is vital to get better
    recognition of the Captcha:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，描述的每个处理阶段对于更好地识别验证码至关重要：
- en: Loading a Captcha image to `canvas:`
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将验证码图像加载到`canvas`：
- en: 'The Captcha image is loaded to canvas through the Greasemonkey''s Ajax call
    to fetch the image:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 验证码图像通过Greasemonkey的Ajax调用加载到画布上以获取图像：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Converting the image to grayscale:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像转换为灰度：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As shown in preceding code block, the image data is taken pixel-by-pixel. Each
    pixel's color value is averaged. And, finally, the image is converted to grayscale
    by adjusting color value.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码块所示，图像数据是逐像素采取的。每个像素的颜色值取平均值。最后，通过调整颜色值将图像转换为灰度。
- en: 'Converting images to have only black and white colors:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像转换为只有黑色和白色颜色：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, other colors can be referred to as "noise". The "noisy" colors are removed
    by retaining only black and white colors.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，其他颜色可以称为“噪音”。通过保留只有黑色和白色颜色来去除“嘈杂”的颜色。
- en: 'Cropping unnecessary image data out:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 裁剪不必要的图像数据：
- en: As the image was of fixed size and text was at a fixed distance, the rectangle
    size of the matrix is set to remove unnecessary data, and so the image is cropped.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图像的尺寸固定且文本距离固定，矩阵的矩形大小设置为去除不必要的数据，因此图像被裁剪。
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Applying a neural network:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用神经网络：
- en: An **ANN (Artificial Neural Network)** (or simply, neural network) is a self-learning
    mathematical model. It is an adaptive system that changes its structure based
    on its external or internal information flow. The design is modeled after animal
    brains, and thus every unit of processors has a local memory and learning component.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**ANN（人工神经网络）**（或简称神经网络）是一种自学习的数学模型。它是一个自适应系统，根据其外部或内部信息流改变其结构。设计是模仿动物大脑的，因此每个处理器单元都有本地存储器和学习组件。'
- en: 'The processed image data acts as a receptor for the neural networks. When passed
    to the neural network with pre-seeded data, it helps us to find out the character
    in a Captcha image:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 处理后的图像数据充当神经网络的受体。当传递给预先种植数据的神经网络时，它可以帮助我们找出验证码图像中的字符：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Depending upon the Captcha complexity, even linear algebra could be used in
    the final step of character recognition. Applying linear algebra, rather than
    neural networks, may improve the speed of the detection. But, neural networks
    perform relatively better in all aspects.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 根据验证码的复杂性，甚至可以在字符识别的最后一步使用线性代数。应用线性代数而不是神经网络可能会提高检测速度。但是，神经网络在各个方面表现相对更好。
- en: There's more...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`Canvas` has other interesting applications as well. It is expected to replace
    Flash components. Some of the notable canvas applications are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`还有其他有趣的应用。它预计将取代Flash组件。一些值得注意的画布应用程序如下：'
- en: CanvasPaint ([http://canvaspaint.org/](http://canvaspaint.org/) ), with a UI
    similar to the MS Paint application
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CanvasPaint（[http://canvaspaint.org/](http://canvaspaint.org/)），界面类似于MS Paint应用程序
- en: Highcharts ([http://highcharts.com/)](http://highcharts.com/)) , a JavaScript
    chart API that uses `canvas` for rendering
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Highcharts（[http://highcharts.com/)](http://highcharts.com/)），一个使用`canvas`进行渲染的JavaScript图表API
- en: Randomized Captcha images are hard to crack without humans. Google’s
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 随机的验证码图像很难在没有人类干预的情况下破解。谷歌的
- en: '**reCAPTCHA API** is built around this problem of digitizing old books using'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**reCAPTCHA API**围绕着使用数字化旧书的问题构建'
- en: 'OCR. When we use this reCAPTCHA API, it provides a Captcha with 2-texts:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: OCR。当我们使用这个reCAPTCHA API时，它提供了一个带有2个文本的验证码：
- en: Random "known" Captcha text
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机“已知”的验证码文本
- en: Unknown" text from old scanned books--that were hard to decipher through OCR.
    When users fill up these Captcha, the "known" texts are matched for validity.
    Entered text against "unknown" text are used digitize scanned books.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自旧扫描书籍的“未知”文本-通过OCR很难辨认。用户填写这些验证码时，“已知”文本将用于验证。输入的文本与“未知”文本相匹配，用于数字化扫描的书籍。
- en: 'Some websites offer human Captcha decoding services over API. The Captcha image
    is uploaded through API; in another part, "data entry" human decoders will input
    the text and it will be sent back. These services are usually used by automated
    bots rather than human beings. Some websites that offer such services are as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网站提供API上的人类Captcha解码服务。验证码图像通过API上传；在另一部分，“数据输入”人类解码器将输入文本，然后将其发送回来。这些服务通常被自动机器人而不是人类使用。提供此类服务的一些网站如下：
- en: Death By Captcha ([http://www.deathbycaptcha.com/](http://www.deathbycaptcha.com/))
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Death By Captcha ([http://www.deathbycaptcha.com/](http://www.deathbycaptcha.com/))
- en: DeCaptcher ([http://www.decaptcher.com/](http://www.decaptcher.com/))
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DeCaptcher ([http://www.decaptcher.com/](http://www.decaptcher.com/))
- en: Displaying data in a grid
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网格中显示数据
- en: 'In Web 2.0 sites, the term "data grid" usually means a spreadsheet-/MS Excel-like
    display using HTML tables. Data grids provide usability and easy access to data
    for users. Some common features of data grids are:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web 2.0网站中，“数据网格”一词通常指的是使用HTML表格的类似于电子表格/MS Excel的显示。数据网格为用户提供了可用性和易于访问数据。数据网格的一些常见特性包括：
- en: Ability to paginate data
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够对数据进行分页
- en: Ability to sort columns
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够对列进行排序
- en: Ability to sort rows
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够对行进行排序
- en: Ability to quickly search or filter data fields
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够快速搜索或过滤数据字段
- en: Ability to have frozen/fixed rows or headers
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够拥有冻结/固定行或标题
- en: Ability to have frozen columns or headers
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够冻结列或标题
- en: Ability to highlight any column of interest
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够突出显示任何感兴趣的列
- en: Ability to load from different data sources, such as JSON, JavaScript array,
    DOM, and Hijax
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够从不同的数据源加载，如JSON、JavaScript数组、DOM和Hijax
- en: Ability to export data to different formats
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够将数据导出到不同的格式
- en: Ability to print formatted data
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够打印格式化数据
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll require the DataTables jQuery plugin from [http://datatables.net/](http://datatables.net/),
    along with jQuery core. Based on our requirement, we may sometimes require additional
    plugins.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要来自[http://datatables.net/](http://datatables.net/)的DataTables jQuery插件，以及jQuery核心。根据我们的需求，有时我们可能需要额外的插件。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In a simple implementation (without using any other data sources), it is enough
    to display the data in an HTML table. DataTables, without any plugins and additional
    options, can turn it into a spreadsheet-like UI, as shown in the following screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的实现中（不使用任何其他数据源），将数据显示在HTML表格中就足够了。DataTables，不使用任何插件和额外选项，可以将其转换为类似电子表格的UI，如下面的屏幕截图所示：
- en: '![How to do it...](graphics/3081_04_04.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/3081_04_04.jpg)'
- en: 'In an HTML table, it''s enough to display the data in a normal tabular format.
    Here, we display user records with name, phone number, city, zip code, and country
    name, using the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML表格中，以正常的表格格式显示数据就足够了。在这里，我们使用以下代码显示具有姓名、电话号码、城市、邮政编码和国家名称的用户记录：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note: In the original code, we had 100 rows. Here, many rows are snipped for
    brevity.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在原始代码中，我们有100行。在这里，为简洁起见，许多行被剪掉了。
- en: 'As usual, it''s enough to attach the data grid behavior through a jQuery plugin
    call:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，只需通过jQuery插件调用附加数据网格行为即可：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: DataTables parses the data in an HTML table and keeps it in a JavaScript object
    array. Whenever required, it renders the content in its HTML template. As seen
    in the preceding screenshot, it adds a search box, pagination links, and a dropdown
    to choose the number of records to be displayed per page. The table headers contained
    in the `thead` element are decorated with sorting icons and links. When any text
    is entered inside the search box, it scans over the saved object array and repaints
    the grid. For quickly turning ordinary datatables into grids, this might be fairly
    sufficient, but, DataTables offers lots of other features besides options and
    plugins.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: DataTables解析HTML表格中的数据，并将其保存在JavaScript对象数组中。在需要时，它会在其HTML模板中呈现内容。如前面的屏幕截图所示，它添加了一个搜索框、分页链接和一个下拉菜单，用于选择每页显示的记录数。包含在`thead`元素中的表头使用排序图标和链接进行装饰。当在搜索框中输入任何文本时，它会扫描保存的对象数组并重新绘制网格。对于快速将普通数据表转换为网格，这可能是相当足够的，但是DataTables除了选项和插件之外还提供了许多其他功能。
- en: 'When it''s required to turn off certain features that DataTables offers, we
    can specifically disable them through options, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要关闭DataTables提供的某些功能时，我们可以通过选项来具体禁用它们，如下所示：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we have disabled the pagination element and sorting feature. Similarly,
    we can disable any other features. When we don't require the grid feature, it's
    better not to initialize DataTables rather than to disable features using options,
    as it would affect performance.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已禁用了分页元素和排序功能。同样，我们可以禁用任何其他功能。当我们不需要网格功能时，最好不要初始化DataTables，而不是使用选项禁用功能，因为这会影响性能。
- en: The default configuration of DataTables isn't compliant with the jQuery UI theme
    framework; to make it compliant, we have to set the `bJQueryUI` flag to `true:`
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: DataTables的默认配置与jQuery UI主题框架不兼容；为了使其兼容，我们必须将`bJQueryUI`标志设置为`true:`
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The major advantage of this is that it's easier to give all the JavaScript components
    a consistent theme/look.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的主要优势是更容易为所有JavaScript组件提供一致的主题/外观。
- en: 'When the user scrolls the data, we may want to provide frozen headers so that
    the values are easily correlated. For this purpose, DataTables offers the `FixedHeader`
    add-on. Setting up fixed headers is easy:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户滚动数据时，我们可能希望提供冻结的标题，以便值能够轻松地进行对应。为此，DataTables提供了`FixedHeader`附加组件。设置固定标题很容易：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With jQuery's plugin architecture, we can easily extend DataTables and thereby
    add any grid feature.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用jQuery的插件架构，我们可以轻松扩展DataTables，从而添加任何网格功能。
- en: There's more...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Different data grid plugins provide different UIs and different features. It''s
    always good to know their differences. Sometimes, on a heavy Ajax site, we may
    want to display millions of records. Let''s see what tools are available for these
    purposes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的数据网格插件提供不同的用户界面和不同的功能。了解它们的区别总是很好的。有时，在一个繁重的Ajax网站上，我们可能想要显示数百万条记录。让我们看看有哪些工具可用于这些目的：
- en: Other data grid plugins
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他数据网格插件
- en: 'We have a lot of jQuery plugins available for data grids. Among them, the following
    are relatively popular and provide lot of features:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多jQuery插件可用于数据网格。其中，以下是相对受欢迎并提供许多功能的：
- en: 'jQuery Grid: [http://www.trirand.com/blog/](http://www.trirand.com/blog/)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'jQuery Grid: [http://www.trirand.com/blog/](http://www.trirand.com/blog/)'
- en: 'Flexigrid: [http://flexigrid.info/](http://flexigrid.info/)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Flexigrid: [http://flexigrid.info/](http://flexigrid.info/)'
- en: 'jqGridView: [http://plugins.jquery.com/project/jqGridView](http://plugins.jquery.com/project/jqGridView)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'jqGridView: [http://plugins.jquery.com/project/jqGridView](http://plugins.jquery.com/project/jqGridView)'
- en: 'Ingrid: [http://reconstrukt.com/ingrid/](http://reconstrukt.com/ingrid/)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ingrid: [http://reconstrukt.com/ingrid/](http://reconstrukt.com/ingrid/)'
- en: 'SlickGrid: [http://github.com/mleibman/SlickGrid](http://github.com/mleibman/SlickGrid)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SlickGrid: [http://github.com/mleibman/SlickGrid](http://github.com/mleibman/SlickGrid)'
- en: 'TableSorter: [http://tablesorter.com/](http://tablesorter.com/)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'TableSorter: [http://tablesorter.com/](http://tablesorter.com/)'
- en: When a UI similar to any of these plugins is demanded, it's wise to use them
    rather than customizing DataTables, as presented in the preceding section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要类似于这些插件中的任何一个的用户界面时，明智的做法是使用它们，而不是自定义DataTables，如前一节所述。
- en: Displaying millions of data items
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示数百万条数据项
- en: At the time of writing, not all data grid implementations can accommodate huge
    sets of records, except SlickGrid. Its patch and discussion about unlimited rows
    can be found at [https://github.com/mleibman/SlickGrid/tree/unlimited-rows](http://https://github.com/mleibman/SlickGrid/tree/unlimited-rows).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，并非所有数据网格实现都能容纳大量记录，除了SlickGrid。有关其无限行的补丁和讨论可在[https://github.com/mleibman/SlickGrid/tree/unlimited-rows](http://https://github.com/mleibman/SlickGrid/tree/unlimited-rows)找到。
