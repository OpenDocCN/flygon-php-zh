- en: Chapter 1. Laravel Starter
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 Laravel入门
- en: Welcome to the Laravel Starter. This book has been specially created to provide
    you with all the information that you need to get started with the Laravel web
    development framework. You will learn the basics of Laravel, get started with
    building your first web application, and discover some tips and tricks for using
    Laravel.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到Laravel入门。本书专门为您提供了开始使用Laravel Web开发框架所需的所有信息。您将学习Laravel的基础知识，开始构建您的第一个Web应用程序，并发现一些使用Laravel的技巧和窍门。
- en: 'This guide contains the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南包含以下部分：
- en: '*So, what is Laravel?* – find out what Laravel actually is, what you can do
    with it, and why it''s so great.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，Laravel是什么？* - 了解Laravel实际上是什么，您可以用它做什么，以及为什么它如此出色。'
- en: '*Installation* – this section will get you started on programming with Laravel.
    We''ll go over installation and basic configuration so that we can get started
    on our application!'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*安装* - 本节将帮助您开始使用Laravel进行编程。我们将介绍安装和基本配置，以便我们可以开始我们的应用程序！'
- en: '*Quick start: Creating your first web application* – let''s get started by
    making our own application. In this section, we''ll develop a basic application
    that receives input from forms and then update a database accordingly.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*快速入门：创建您的第一个Web应用程序* - 让我们开始制作我们自己的应用程序。在本节中，我们将开发一个接收表单输入然后相应更新数据库的基本应用程序。'
- en: '*Top 5 features you need to know about* – here we will go more in depth about
    what we''ve covered in the *Quick start* section. We''ll learn more about Eloquent,
    authentication, filters, validation, and bundles.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*您需要了解的前5个功能* - 在这里，我们将更深入地了解我们在*快速入门*部分中涵盖的内容。我们将更多地了解Eloquent、身份验证、过滤器、验证和包。'
- en: '*People and places you should get to know* – the Laravel community is one of
    its most potent educational assets. This section provides you with useful links
    to the project''s page and forums, as well as a number of helpful articles, tutorials,
    blogs, and the Twitter feeds of Laravel super-contributors.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*您应该了解的人和地方* - Laravel社区是其最有力的教育资产之一。本节为您提供了有用的链接到项目页面和论坛，以及一些有用的文章、教程、博客和Laravel超级贡献者的Twitter动态。'
- en: So, what is Laravel?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，Laravel是什么？
- en: Laravel is an MVC web-development framework written in PHP. It has been designed
    to improve the quality of your software by reducing both the cost of initial development
    and ongoing maintenance costs, and to improve the experience of working with your
    applications by providing clear expressive syntax and a core set of functionality
    that will save you hours of implementation time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel是一个用PHP编写的MVC Web开发框架。它旨在通过减少初始开发成本和持续维护成本来提高软件质量，并通过提供清晰的表达语法和一组核心功能来改善与应用程序的工作体验，从而节省您数小时的实现时间。
- en: Laravel was designed with the philosophy of using convention over configuration.
    This means that it makes intelligent assumptions about what you're trying to accomplish
    so that in most situations you'll be able to accomplish your goals with much less
    code. Not every application and database that you'll work with will be designed
    using these conventions. Thankfully, Laravel is flexible enough to work with your
    system—no matter how unique it is.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel的设计理念是使用约定优于配置。这意味着它会对你试图实现的目标做出智能的假设，因此在大多数情况下，你将能够用更少的代码实现你的目标。并非你将要处理的每个应用程序和数据库都是按照这些约定设计的。幸运的是，Laravel足够灵活，可以与你的系统一起工作，无论它有多独特。
- en: Laravel has been designed to target the sweet-spot between minimalism and functionality.
    It's easier to understand smaller code bases and Laravel is all about implementing
    solutions in a way that is clean, simple, and elegant. Long-time PHP developers
    will find many aspects of Laravel familiar as it is an evolution of the PHP development
    frameworks that have come before it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel的设计目标是在极简主义和功能性之间找到平衡点。更容易理解较小的代码库，而Laravel的所有实现解决方案都是以清晰、简单和优雅的方式进行的。长期以来，PHP开发人员会发现Laravel的许多方面都很熟悉，因为它是PHP开发框架的演进。
- en: Laravel is one of the few PHP frameworks that offers true code modularity. This
    is achieved through a combination of drivers and its bundles system. Drivers allow
    you to easily change and extend caching, session, database, and authentication
    functionality. Using bundles, you're able to package up any kind of code for either
    your own re-use or to provide to the rest of the Laravel community. This is very
    exciting because anything that can be written in Laravel can be packaged as a
    bundle, from simple libraries to entire web-applications. The Laravel bundle website
    allows you to browse bundles that have been built by the community as well as
    to showcase your own. It is a valuable resource of third-party libraries and subsystems
    that can dramatically ease the development of your web-application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel是为数不多的提供真正代码模块化的PHP框架之一。这是通过驱动程序和其包系统的组合实现的。驱动程序允许您轻松更改和扩展缓存、会话、数据库和身份验证功能。使用包，您可以打包任何类型的代码供自己重复使用或提供给Laravel社区的其他人使用。这非常令人兴奋，因为任何可以在Laravel中编写的东西都可以作为一个包进行打包，从简单的库到整个Web应用程序。Laravel包网站允许您浏览社区构建的包，以及展示您自己的包。这是一个有价值的第三方库和子系统资源，可以极大地简化您的Web应用程序的开发。
- en: Laravel also provides a cutting-edge suite of tools for interacting with databases.
    Database migrations enable you to easily design and modify a database in a platform-independent
    way. The migrations can then be run against any of the database types that Laravel
    supports (MySQL, PostgreSQL, MSSQL, and SQLite) and you won't have any compatibility
    issues.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel还提供了一套与数据库交互的尖端工具。数据库迁移使您能够轻松地以独立于平台的方式设计和修改数据库。然后可以针对Laravel支持的任何数据库类型（MySQL、PostgreSQL、MSSQL和SQLite）运行迁移，而不会出现兼容性问题。
- en: Laravel's Fluent Query Builder abstracts away the differences between different
    database types. Use it to build and execute robust queries.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel的Fluent查询构建器将不同数据库类型之间的差异抽象出来。使用它来构建和执行强大的查询。
- en: Laravel's ActiveRecord implementation is called **Eloquent**. Interacting with
    a database in an object-oriented way is the modern standard. With Eloquent, we
    can create, retrieve, update, and delete the database records without needing
    to write a single line of SQL. In addition to this, Eloquent provides powerful
    relationship management and it can even handle pagination automatically for you.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel的ActiveRecord实现称为**Eloquent**。以面向对象的方式与数据库交互是现代标准。使用Eloquent，我们可以创建、检索、更新和删除数据库记录，而无需编写一行SQL。除此之外，Eloquent还提供强大的关系管理，甚至可以自动处理分页。
- en: Laravel also ships with a command-line interface tool called **Artisan**. With
    Artisan, a developer can interact with their application to trigger actions such
    as running migrations, running unit tests, and running scheduled tasks. Artisan
    is also completely extendable so that you can write any type of functionality
    that you'd like. Laravel's easy-to-manage routing system allows you to easily
    manage your site's URLs. By using the built-in HTML helper, you can create links
    within your site that will automatically update themselves if you change the URLs
    that make the job of maintaining your site much easier.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel还附带了一个名为**Artisan**的命令行界面工具。使用Artisan，开发人员可以与他们的应用程序交互，触发诸如运行迁移、运行单元测试和运行定时任务等操作。Artisan也是完全可扩展的，因此您可以编写任何类型的功能。Laravel易于管理的路由系统允许您轻松管理站点的URL。通过使用内置的HTML助手，您可以在站点内创建链接，如果更改URL，它们将自动更新，从而使维护站点的工作变得更加容易。
- en: The Blade templating engine cleans up your views by providing aesthetically
    pleasing replacements for inline PHP and by including powerful new features.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Blade模板引擎通过提供美观的替代方案来清理视图中的内联PHP，并包含强大的新功能。
- en: Installation
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: In five easy steps, you can install Laravel and get it set up on your system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过五个简单的步骤，您可以安装Laravel并在系统上设置它。
- en: Step 1 – What do I need?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1步 - 我需要什么？
- en: 'Before you install Laravel, you will need to check that you have all of the
    required elements, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装Laravel之前，您需要检查是否具有以下所需元素：
- en: Laravel requires a web server environment and will run in Apache, IIS, and Nginx
    easily. Laravel should run in any server environment that supports PHP. The easiest
    way to set up a local webserver for development is to install XAMPP (Windows),
    MAMP (Mac OSX), or Apache with PHP5 on through a package manager on Linux.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Laravel需要一个Web服务器环境，并且可以在Apache、IIS和Nginx中轻松运行。Laravel应该在支持PHP的任何服务器环境中运行。为了开发设置本地Web服务器的最简单方法是在Windows上安装XAMPP，Mac
    OSX上安装MAMP，或者通过Linux上的软件包管理器安装带有PHP5的Apache。
- en: Laravel is written in the PHP scripting language. Currently, Laravel v3.2.5
    requires a minimum of PHP v5.3 to run.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Laravel是用PHP脚本语言编写的。目前，Laravel v3.2.5需要最低PHP v5.3才能运行。
- en: Laravel requires that you have the FileInfo and Mcrypt libraries installed.
    Conveniently, they are almost always installed by default.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Laravel要求您安装FileInfo和Mcrypt库。方便的是，它们几乎总是默认安装的。
- en: .For our QuickStart application we require a database. Out of the box, Laravel
    supports MySQL, MSSQL, PostgreSQL, and SQLite.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我们的QuickStart应用程序，我们需要一个数据库。默认情况下，Laravel支持MySQL、MSSQL、PostgreSQL和SQLite。
- en: Step 2 – Downloading Laravel
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2步 - 下载Laravel
- en: The easiest way to download Laravel is as a compressed package from [http://laravel.com/download](http://laravel.com/download).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下载Laravel的最简单方法是从[http://laravel.com/download](http://laravel.com/download)下载压缩包。
- en: Alternatively, you can download Laravel by cloning its `git` repository from
    [GitHub.com](http://GitHub.com) with the following command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过以下命令从[GitHub.com](http://GitHub.com)克隆其`git`存储库来下载Laravel。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It would be better that you download the most current stable build.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最好下载最新的稳定版本。
- en: Extract the contents of the compressed package into the directory that you store
    your web-applications. Typical locations include `/Users/Shawn/Sites`, `c:\sites`,
    and `/var/www/vhosts/` depending on your operating system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将压缩包的内容提取到存储Web应用程序的目录中。典型的位置包括`/Users/Shawn/Sites`，`c:\sites`和`/var/www/vhosts/`，具体取决于您的操作系统。
- en: We'll assume that your first Laravel installation is in `c:\sites\myfirst\`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您的第一个Laravel安装在`c:\sites\myfirst\`中。
- en: Step 3 – Configuring hosts
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3步 - 配置主机
- en: Let's go ahead and set up our web server to host our site. We need to choose
    a host name for our example application. This is our first application and we're
    working on our local development environment, so let's use `http://myfirst.dev?`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续设置我们的Web服务器来托管我们的站点。我们需要为我们的示例应用程序选择一个主机名。这是我们的第一个应用程序，我们正在使用本地开发环境，所以让我们使用`http://myfirst.dev?`。
- en: 'In Linux and OSX, simply add the following line to your `/etc/hosts` file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和OSX中，只需将以下行添加到您的`/etc/hosts`文件中：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Windows users should add that line to their `c:\windows\system32\drivers\etc\hosts`
    file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户应将该行添加到其`c:\windows\system32\drivers\etc\hosts`文件中。
- en: Now you should be able to ping `myfirst.dev` and see that it resolves to `127.0.0.1`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该能够ping `myfirst.dev`并看到它解析为`127.0.0.1`。
- en: Step 4 – Setting up your VirtualHost
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4步 - 设置您的VirtualHost
- en: Now that we have a host name we need to tell our web server where to find the
    Laravel installation. Add the following `VirtualHost` configuration to your Apache
    web server configuration and replace `DocumentRoot` with the path to your Laravel
    installation's public directory.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个主机名，我们需要告诉我们的Web服务器在哪里找到Laravel安装。将以下`VirtualHost`配置添加到您的Apache Web服务器配置中，并将`DocumentRoot`替换为您的Laravel安装的public目录的路径。
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It's very important to note that `DocumentRoot` points to the Laravel's public
    directory. There are multiple security reasons for this. A momentary server misconfiguration
    can expose the secure information, such as your database passwords.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的一点是`DocumentRoot`指向Laravel的public目录。这有多个安全原因。短暂的服务器配置错误可能会暴露安全信息，例如您的数据库密码。
- en: Step 5 – Restarting your web server and testing
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5步 - 重新启动Web服务器并进行测试
- en: Now that you've installed the Laravel files, added your host declaration, and
    updated your web-server configuration you're ready to go! Restart your web-server
    software and go to `http://myfirst.dev` in your browser. You should see the Laravel
    splash page!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了Laravel文件，添加了主机声明，并更新了Web服务器配置，您已经准备好了！重新启动您的Web服务器软件，然后在浏览器中转到`http://myfirst.dev`。您应该看到Laravel的欢迎页面！
- en: And that's it!
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 就是这样！
- en: By this point, you should have a working installation of Laravel and are free
    to play around and discover more about it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，您应该已经安装了Laravel，并可以自由地玩耍并发现更多关于它的内容。
- en: 'Quick start: Creating your first web application'
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速开始：创建您的第一个Web应用程序
- en: In this section we'll be building a user administration tool. User admins are
    one of the most common components to be found in web applications. They also use
    a number of important systems that we want to explore with Laravel including database
    interactions, forms, and routing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个用户管理工具。用户管理员是Web应用程序中最常见的组件之一。他们还使用了一些我们想要用Laravel探索的重要系统，包括数据库交互、表单和路由。
- en: We'll be storing and retrieving records from a database so now it would be a
    good time for you to create a database for this application. Keep the database
    name, user, and password handy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从数据库中存储和检索记录，现在是您为此应用程序创建数据库的好时机。记住数据库名称、用户名和密码。
- en: Let's get started.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Step 1 – Database configuration
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤1 - 数据库配置
- en: Armed with our database name, user, and password, we can now tell Laravel how
    to connect to our database.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有了数据库名称、用户名和密码，我们现在可以告诉Laravel如何连接到我们的数据库。
- en: Open the file `application/config/database.php` and scan the contents. You'll
    find example configurations for each database driver. Determine which driver you're
    going to use from the available options (`sqlite`, `mysql`, `pgsql`, and `sqlserv`)
    and enter the name of the driver as the default database connection.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件`application/config/database.php`并扫描内容。您将找到每个数据库驱动程序的示例配置。确定您将从可用选项（`sqlite`、`mysql`、`pgsql`和`sqlserv`）中使用哪个驱动程序，并将驱动程序的名称输入为默认数据库连接。
- en: Then, in the **Connections** section add your database name, user, and password.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在**Connections**部分添加您的数据库名称、用户名和密码。
- en: Ok! We're just where we want to be. Let's get started by creating the users
    table.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！我们现在就要开始创建用户表了。
- en: Step 2 – Creating the users table using migrations
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤2 - 使用迁移创建用户表
- en: You might typically create the users table with a tool like phpMyAdmin or Navicat.
    But, Laravel provides a fancy migrations system for us and we should use it because
    it improves our workflow and reduces deployment bugs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您可以使用诸如phpMyAdmin或Navicat之类的工具创建用户表。但是，Laravel为我们提供了一个漂亮的迁移系统，我们应该使用它，因为它可以改善我们的工作流程并减少部署错误。
- en: '**Migrations** are version control for your schema modifications. Migrations
    reduce the amount of headache that we face by requiring us to only define the
    schema alteration once. Afterwards, we can deploy our changes to any number of
    systems without the potential for human error.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**迁移**是用于模式修改的版本控制。迁移通过要求我们仅定义一次模式更改来减少我们面临的麻烦。之后，我们可以将更改部署到任意数量的系统，而不会出现人为错误的可能性。'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Migrations are especially useful for projects in which you're collaborating
    with others. Like using source control, migrations are always a good idea.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移对于与他人合作的项目特别有用。与使用源代码控制一样，迁移总是一个好主意。
- en: Developers who are new to migrations might believe them unnecessary or believe
    that they add too much additional work at first. But, stick with it and their
    value will become quickly apparent.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于迁移还不熟悉的开发人员可能会认为它们是不必要的，或者认为它们一开始增加了太多额外的工作。但是，请坚持下去，它们的价值将很快显现。
- en: Let's start by creating our migration template with Laravel's command-line tool
    Artisan.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用Laravel的命令行工具Artisan创建我们的迁移模板开始。
- en: 'In order to use Artisan, we will need to add the directory which contains the
    PHP binary to our `PATH` environment variable. This lets us execute the PHP binary
    from anywhere, as the system will know where to find it. You can test this by
    running the following command from your command-line terminal:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Artisan，我们需要将包含PHP二进制文件的目录添加到我们的`PATH`环境变量中。这样可以让我们从任何地方执行PHP二进制文件，因为系统会知道在哪里找到它。您可以通过从命令行终端运行以下命令来测试：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You should see a nice readout telling you which version of PHP you're running.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个很好的输出，告诉您正在运行哪个版本的PHP。
- en: 'If you find that your command-line interface doesn''t know where the PHP binary
    is, you''ll need to update your system''s `PATH`. You can modify your `PATH` variable
    on OS X and Linux with the following command line:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现您的命令行界面不知道PHP二进制文件在哪里，您需要更新系统的`PATH`。您可以使用以下命令行在OS X和Linux上修改您的`PATH`变量：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Windows users will need to right-click on **Computer** from the start menu and
    click on **Properties**. Click on **Advanced system settings**, and then click
    on **Environment Variables**. Here you can find the system variable `PATH` and
    add the directory that contains your PHP binary.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户需要右键单击开始菜单中的**计算机**，然后单击**属性**。单击**高级系统设置**，然后单击**环境变量**。在这里，您可以找到系统变量`PATH`并添加包含您的PHP二进制文件的目录。
- en: 'Now that the PHP binary is in our path, let''s navigate to our `project` folder.
    Now we can go ahead and install our migrations database table. Execute the following
    command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在PHP二进制文件已经在我们的路径中，让我们导航到我们的`project`文件夹。现在我们可以继续安装我们的迁移数据库表。执行以下命令：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You should see the message, **Migration table created successfully**. If you
    get errors, verify that your database connection information is correct.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到消息，**成功创建迁移表**。如果出现错误，请验证您的数据库连接信息是否正确。
- en: Next, let's create a new migration template in our `application/migrations`
    folder.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`application/migrations`文件夹中创建一个新的迁移模板。
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The migration files are formatted with the year, month, day, time, and the text
    that you added that enable it to be identified by a human, in this case `create_users_table`.
    Mine looks like `2012_08_16_112327_create_users_table.php`. The structure of the
    filename is important as it helps Laravel to understand the order in which it
    should run the migrations. By using a convention for naming your migrations, you'll
    be helping your team to better understand your work (and vice-versa). An example
    convention might consist of entries like `create_users_table`, `add_fields_to_users_table`,
    or `rename_blog_posts_table_to_posts`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移文件的格式是年、月、日、时间和你添加的文本，使其可以被人识别，比如`create_users_table`。我的看起来像`2012_08_16_112327_create_users_table.php`。文件名的结构很重要，因为它帮助Laravel理解应该以什么顺序运行迁移。通过使用命名迁移的约定，你将帮助你的团队更好地理解你的工作（反之亦然）。一个例子约定可能包括`create_users_table`、`add_fields_to_users_table`或`rename_blog_posts_table_to_posts`。
- en: The migrations file contains a single class with the human readable name that
    we entered before. The class has two methods, `up()` and `down()`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移文件包含一个具有我们之前输入的人类可读名称的单个类。该类有两个方法，`up()`和`down()`。
- en: When migrations are run, Laravel reads in each migration file one by one and
    runs its `up()` method. If you feel that a mistake has been made, you can rollback
    migrations. When rolling back a change, Laravel runs the `down()` method. The
    `up()` method is for making your desired changes to the database. The `down()`
    method is for reverting your changes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当迁移运行时，Laravel会逐个读取每个迁移文件并运行其`up()`方法。如果你觉得出现了错误，你可以回滚迁移。回滚更改时，Laravel会运行`down()`方法。`up()`方法用于对数据库进行所需的更改。`down()`方法用于撤销更改。
- en: 'Let''s go ahead and look at what our `create_users_table migration` should
    look like:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的`create_users_table migration`应该是什么样子的：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's first discuss our `up()` method. Our goal is to create the `users` table
    and to define the fields within it. In order to accomplish this goal, we'll use
    the Laravel `Schema` class. When creating or making modifications to tables, we
    use the `Schema` class' `table()` method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论我们的`up()`方法。我们的目标是创建`users`表并定义其中的字段。为了实现这个目标，我们将使用Laravel的`Schema`类。在创建或修改表时，我们使用`Schema`类的`table()`方法。
- en: '`Schema::table()` accepts two arguments. The first is the name of the table
    that you''ll be interacting with, in this case it''s `users`. The second argument
    is a closure which contains your table definition. The closure receives the argument
    `$table` and this is the object that we''ll be interacting with to define the
    table.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schema::table()`接受两个参数。第一个是你将要交互的表的名称，在这种情况下是`users`。第二个参数是一个包含你的表定义的闭包。闭包接收参数`$table`，这是我们将要与之交互来定义表的对象。'
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This line tells Laravel that the table will need to be created. If we omit this
    line, `Schema` will generate the `ALTER TABLE` syntax rather than the `CREATE
    TABLE` syntax.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行告诉Laravel需要创建表。如果我们省略这一行，`Schema`将生成`ALTER TABLE`语法而不是`CREATE TABLE`语法。
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `increments()` method tells `Schema` that the specified field should be
    an auto-incremented primary key. With Laravel, you'll want to use simple field
    names such as `id`, `email`, and `password`. If you aren't familiar with using
    **Object-Relational Mapping** (**ORM**), you may be in the habit of creating those
    same field names with the table name as a prefix. For example, `user_id`, `user_email`,
    `user_password`. The purpose behind defining field names with the table name as
    a prefix is to simplify query generation when using a query builder. This is no
    longer necessary and it's best to follow the more simple convention as it manages
    redundant interactions for you, removing the need for you to continuously write
    the boilerplate code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`increments()`方法告诉`Schema`指定的字段应该是自增的主键。在Laravel中，你应该使用简单的字段名，比如`id`、`email`和`password`。如果你不熟悉使用**对象关系映射**（**ORM**），你可能习惯于使用表名作为前缀创建相同的字段名。例如，`user_id`、`user_email`、`user_password`。定义字段名时使用表名作为前缀的目的是在使用查询构建器时简化查询生成。这已经不再必要，最好遵循更简单的约定，因为它会为你管理冗余的交互，省去了你不断编写样板代码的需要。'
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next we have a few string declarations. These will be created as the `VARCHAR`
    fields with the default length of `200`. You can override the length of these
    fields by passing a second argument that represents the intended length. For example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们有一些字符串声明。这些将被创建为默认长度为`200`的`VARCHAR`字段。你可以通过传递表示预期长度的第二个参数来覆盖这些字段的长度。例如：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This line creates a `VARCHAR` field named `email` with a length of `300`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行创建了一个名为`email`的`VARCHAR`字段，长度为`300`。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to note that we shouldn't reduce the size of the `password` field
    as we'll need that length for the output from Laravel's `Hash` class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们不应该减小`password`字段的大小，因为我们将需要这个长度来输出Laravel的`Hash`类。
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finally, we come to the `timestamps()` method. This will create two `DATETIME`
    fields (`created_at` and `updated_at`). It is not unreasonable to create the `timestamp`
    fields for every table in the database as they can be very useful for troubleshooting
    down the road. The Eloquent ORM will automatically manage these `timestamp` fields
    for us. So, we can forget about them for now.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来看看`timestamps()`方法。这将创建两个`DATETIME`字段（`created_at`和`updated_at`）。为数据库中的每个表创建`timestamp`字段并不是不合理的，因为它们在以后的故障排除中可能非常有用。Eloquent
    ORM将自动为我们管理这些`timestamp`字段。所以，我们现在可以暂时忘记它们。
- en: The `down()` method should revert any changes made to the `up()` method. In
    this case, the `up()` method creates a database table called users. So, the `down()`
    method should remove the table.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`down()`方法应该撤销`up()`方法所做的任何更改。在这种情况下，`up()`方法创建了一个名为users的数据库表。因此，`down()`方法应该删除该表。'
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is done with the method `Schema::drop()`. `drop()` takes a single argument,
    a string value containing the name of the table that you wish to drop.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过`Schema::drop()`方法完成的。`drop()`接受一个参数，一个包含你希望删除的表名的字符串值。
- en: That's it! We have our first migration. Once you memorize the commonly used
    methods such as `increments()`, `string()`, `decimal()`, `timestamps()`, and `date()`,
    you'll be able to make migrations just as fast as you were able to modify your
    database with your preferred database management tool. But, now we gain the added
    benefit from using them in versioned and collaborative situations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们有了我们的第一个迁移。一旦您记住了常用方法，比如 `increments()`、`string()`、`decimal()`、`timestamps()`
    和 `date()`，您将能够像使用首选的数据库管理工具修改数据库一样快速地进行迁移。但是，现在我们在版本化和协作情况下使用它们时，还能获得额外的好处。
- en: 'Now, we''re ready to run our migrations. From this point on, running migrations
    will always be done in the same way. Let''s go ahead and give it a shot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备运行我们的迁移。从现在开始，运行迁移将始终以相同的方式进行。让我们试一试：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we should see the message, **Migrated: 2012_08_16_112327_create_users_table**.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该看到消息，**迁移：2012_08_16_112327_create_users_table**。
- en: It's very important to test our migrations. If we don't test our migrations,
    it could come back to bite us later in the project when we need to roll back migrations
    and run into an error. Proper migration testing verifies that the `up()` and `down()`
    methods both function as intended.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们的迁移非常重要。如果我们不测试我们的迁移，当我们需要回滚迁移并遇到错误时，它可能会在项目后期出现问题。正确的迁移测试验证了 `up()` 和 `down()`
    方法都按预期运行。
- en: 'To test the `up()` method, run the migration and open your preferred database
    management application. Then, verify that everything is as you intended. Then,
    test the `down()` method by rolling back the migration and doing the same. Roll
    back your migration now by using the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 `up()` 方法，请运行迁移并打开您首选的数据库管理应用程序。然后，验证一切是否如您所期望的那样。然后，通过回滚迁移并执行相同的操作来测试 `down()`
    方法。现在通过以下命令回滚您的迁移：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Optimally, you will be notified that the migration was rolled back successfully.
    Double-check that your database no longer contains the `users` table. That's it!
    This migration is good to go. Run your migrations for one last time and let's
    move on to the next step.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您将收到迁移成功回滚的通知。仔细检查您的数据库是否不再包含 `users` 表。就是这样！这个迁移已经准备就绪。运行您的迁移最后一次，然后我们继续下一步。
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Step 3 – Creating an Eloquent user model
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三步 - 创建一个 Eloquent 用户模型
- en: Now that we have created our `users` table, we should go ahead and create our
    user model. In the context of MVC, a model is a class that represents various
    types of data interactions. The data can include information stored in a database
    such as users, blog posts, and comments or interactions with many other types
    of data sources such as files, forms, or web services. For the sake of this document,
    we'll primarily be using models to represent the data that we store in our database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的 `users` 表，我们应该继续创建我们的用户模型。在 MVC 的上下文中，模型是代表各种类型数据交互的类。数据可以包括存储在数据库中的信息，如用户、博客文章和评论，或与许多其他类型的数据源进行交互，如文件、表单或
    Web 服务。就本文档而言，我们主要将使用模型来表示我们在数据库中存储的数据。
- en: 'Models sit in the `application/models` folder. So go ahead and create the file
    `application/models/user.php` with the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 模型位于 `application/models` 文件夹中。所以继续创建文件 `application/models/user.php`，其中包含以下代码：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is all we need! This tells Laravel that our user model represents data
    in the users table. Wait! How does Laravel know that? Well, because we're following
    Laravel's conventions of course! Our database table `users` is plural because
    it signifies that it stores more than one user record. The model class is named
    `User` singular because it represents one single user record in the `users` table.
    The `User` class name is capitalized because of the standard for using Pascal
    case for class names. If your database table was named `user_profiles`, your model's
    class name would be `UserProfile`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的全部！这告诉 Laravel 我们的用户模型代表 users 表中的数据。等等！Laravel 是如何知道的呢？嗯，因为我们当然遵循了
    Laravel 的约定！我们的数据库表 `users` 是复数形式，因为它表示存储多个用户记录。模型类名为 `User` 是单数形式，因为它代表 users
    表中的单个用户记录。`User` 类名首字母大写，因为类名使用帕斯卡命名法的标准。如果您的数据库表名为 `user_profiles`，您的模型类名将是 `UserProfile`。
- en: 'We can see how using conventions prevents us from having to make a bunch of
    configurations. Well, what if we must use a database table that doesn''t follow
    conventions? No problem! We can just define the table name manually. Just add
    the following line to the `User` class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到使用约定可以避免我们不得不进行大量配置。那么，如果我们必须使用不遵循约定的数据库表怎么办？没问题！我们只需手动定义表名。只需将以下行添加到
    `User` 类中：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That's all it takes. Now, Laravel knows that when interacting with this model,
    it should use the table named `my_users_table`. Most conventions in Laravel can
    be overridden with configuration when necessary.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部。现在，Laravel 知道在与这个模型交互时，应该使用名为 `my_users_table` 的表。在必要时，Laravel 中的大多数约定都可以通过配置进行覆盖。
- en: There's one important thing that we should add to our user model. We're storing
    the user's e-mail address, real name, and password. We want to make sure that
    the user's password isn't stored in plain text. We need to hash their password
    before it is stored in the database. For this we'll create a setter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件重要的事情我们应该添加到我们的用户模型中。我们正在存储用户的电子邮件地址、真实姓名和密码。我们希望确保用户的密码不是以明文存储的。我们需要在将密码存储到数据库之前对其进行哈希处理。为此，我们将创建一个
    setter。
- en: A **setter** is a method that intercepts the assignment of an attribute. In
    this case, we're going to intercept the assignment of the password attribute,
    hash the value that we received, and then store the hashed value in the database.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**setter** 是拦截属性赋值的方法。在这种情况下，我们将拦截密码属性的赋值，对接收到的值进行哈希处理，然后将哈希值存储在数据库中。'
- en: Let's look at some code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些代码。
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the convention for declaring setters is to prefix the name of
    the attribute whose assignments you want to intercept with `set_`. The user's
    password will be passed to the setter as the argument `$string`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，声明 setter 的约定是使用 `set_` 前缀加上您想要拦截赋值的属性的名称。用户的密码将作为参数 `$string` 传递给 setter。
- en: We use the `set_attribute()` method to store a hashed version of the user's
    password into the model. Typically the `set_attribute()` method is not necessary.
    But, we don't want our setter to be stuck in an endless loop as we continuously
    attempt to assign `$this->password`. The `set_attribute()` method accepts two
    arguments. The first is the name of the attribute and the second is the value
    that we want to assign to it. When assigning values with `set_attribute()`, setter
    methods will not be called and the data will be directly modified within the model.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`set_attribute()`方法将用户密码的哈希版本存储到模型中。通常情况下，`set_attribute()`方法是不必要的。但是，我们不希望我们的setter陷入无休止的循环，因为我们不断尝试分配`$this->password`。`set_attribute()`方法接受两个参数。第一个是属性的名称，第二个是我们要分配给它的值。使用`set_attribute()`分配值时，不会调用setter方法，数据将直接在模型中进行修改。
- en: We're using the `make()` method from Laravel's `Hash` class to create a salted
    hash of the user's password.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Laravel的`Hash`类的`make()`方法来创建用户密码的盐哈希。
- en: Step 4 – Routing to a closure
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤4 - 路由到闭包
- en: Before we can move on and test our user model, we need to know a few things
    about routing in Laravel. **Routing** is the act of linking a URL to a function
    in your application. In Laravel, it's possible to route in two ways. You can either
    route to a closure or a controller action. As we'll be going over controllers
    in more detail later, let's start by looking at how we can route to a closuRoutes
    in Laravel are declared in `application/routes.php`. This file will represent
    the connection between your site's URLs and the functions that contain application
    logic for your site. This is very handy as other developers will be able to come
    into your project and know how requests are routed, simply by reviewing this file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续测试用户模型之前，我们需要了解一些关于Laravel中路由的知识。**路由**是将URL链接到应用程序中的函数的行为。在Laravel中，可以通过两种方式进行路由。您可以路由到闭包或控制器操作。由于我们稍后将更详细地讨论控制器，让我们先看看如何路由到闭包。在Laravel中，路由在`application/routes.php`中声明。这个文件将表示您站点的URL和包含站点应用逻辑的函数之间的连接。这非常方便，因为其他开发人员可以通过查看这个文件来了解请求是如何路由的。
- en: 'Here is a simple example of routing to a closure:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是路由到闭包的一个简单示例：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We're using the `Route::get()` method to define the route. `Route::get()` registers
    a closure with the router that specifically responds to a `GET` request at the
    specified URI. To register a closure for the `POST`, `PUT`, and `DELETE` requests,
    you'd use `Route::post()`, `Route::put()`, and `Route::delete()` respectively.
    These methods correspond to what are commonly referred to as the **HTTP verbs**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Route::get()`方法来定义路由。`Route::get()`注册一个闭包，专门响应指定URI的`GET`请求。要为`POST`、`PUT`和`DELETE`请求注册闭包，您可以分别使用`Route::post()`、`Route::put()`和`Route::delete()`。这些方法对应于通常被称为**HTTP动词**的内容。
- en: Typically, developers only interact with the `GET` and `POST` requests. When
    a user clicks on a link or enters a URL in their address bar, they're creating
    a `GET` request. When a user submits a form, they're typically creating a `POST`
    request.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开发人员只与`GET`和`POST`请求进行交互。当用户单击链接或在地址栏中输入URL时，他们正在创建一个`GET`请求。当用户提交表单时，他们通常会创建一个`POST`请求。
- en: The first argument for the `Route::get()` method is the URI for the route (the
    part of the URL after the domain name), and the second argument is the closure
    which contains the desired application logic.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Route::get()`方法的第一个参数是路由的URI（域名后的URL部分），第二个参数是包含所需应用逻辑的闭包。'
- en: Let's update the example and test the route.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新示例并测试路由。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that instead of using echo to output the string we're returning it. That's
    because whether you route to a closure or route to a controller action, you should
    always return your response. This allows Laravel to handle many situations in
    a robust way.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不是使用echo来输出字符串，而是返回它。这是因为无论您路由到闭包还是路由到控制器操作，您都应该始终返回响应。这使得Laravel能够以强大的方式处理许多情况。
- en: Now go ahead and navigate to `http://myfirst.dev/test`. You will see the message,
    **This is the test route**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续导航到`http://myfirst.dev/test`。您将看到消息，**这是测试路由**。
- en: Step 5 – Creating users with Eloquent
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤5 - 使用Eloquent创建用户
- en: Now, let's test the `User` model and learn a bit about Eloquent in the process.
    In this application, we're going to interact with the `User` model in a few ways.
    We'll want to use the `Create`, `Retrieve`, `Update`, and `Delete` methods for
    user records. These common methods are referred to as **CRUD methods**.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试`User`模型，并在此过程中了解一些关于Eloquent的知识。在这个应用程序中，我们将以几种方式与`User`模型进行交互。我们将使用用户记录的`Create`、`Retrieve`、`Update`和`Delete`方法。这些常见方法被称为**CRUD方法**。
- en: Eloquent simplifies development by removing the need to manually implement CRUD
    methods for your models. If you've ever designed models without an ORM, you are
    already aware that this alone can save you many hours on large sites.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent通过消除手动为模型实现CRUD方法来简化开发。如果您曾经在没有ORM的情况下设计模型，您就已经意识到这一点可以为大型网站节省许多时间。
- en: 'Now, let''s explore the various ways in which you can create new user records.
    We''ll repurpose our test route from the previous step to help us get to know
    Eloquent. Update the route declaration with the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索创建新用户记录的各种方法。我们将重新利用上一步的测试路由来帮助我们了解Eloquent。使用以下代码更新路由声明：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s review:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'First, we create a new instance of our `User` model and store it in the `$user`
    variable:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了我们的`User`模型的一个新实例，并将其存储在`$user`变量中：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Then, we set some attributes in our `User` model. These attributes directly
    correspond to the fields in our users database table.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在我们的`User`模型中设置一些属性。这些属性直接对应于我们的用户数据库表中的字段。
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, we tell Eloquent that we want to save the contents of this model to the
    database.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们告诉Eloquent我们要将这个模型的内容保存到数据库中。
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, we output this string to the browser so that we know that all is well.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将这个字符串输出到浏览器，这样我们就知道一切都很好。
- en: Go ahead and navigate to `http://myfirst.dev/test` in your browser. You should
    see the confirmation message that the user has been saved to the database.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 继续在浏览器中导航到`http://myfirst.dev/test`。您应该会看到确认消息，用户已保存到数据库中。
- en: Now, take a look at the contents of your database's `users` table. You will
    see a new record filled with our data. Notice that the `timestamps` fields have
    been automatically pre-populated for you. It's that easy to create new database
    records with Eloquent!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下您的数据库`users`表的内容。您会看到一个填满我们数据的新记录。请注意，`timestamps`字段已经自动预填充给您。使用Eloquent创建新的数据库记录就是这么简单！
- en: Step 6 – The users controller
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6步 - 用户控制器
- en: Now it's time for us to create our first controller. You've already learned
    how we can route to a closure and you can use this method to make an entire web-application.
    So, what are controllers and why should we use them?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建我们的第一个控制器了。您已经学会了如何路由到一个闭包，您可以使用这种方法来创建一个完整的Web应用程序。那么，控制器是什么，为什么我们应该使用它们呢？
- en: Controllers are containers for methods that contain application logic related
    to a common domain. A domain is simply a categorization of purpose. In the context
    of our web application, we will be working solely with administrating user data.
    Therefore, our domain is `users`. Our `users` controller will contain the application
    logic that controls our application flow and delivers our database data to the
    view for formatting.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是包含与公共域相关的应用逻辑的方法的容器。域简单地是目的的分类。在我们的Web应用程序的上下文中，我们将仅仅处理管理用户数据。因此，我们的域是`users`。我们的`users`控制器将包含控制我们应用程序流程并将数据库数据传递到视图进行格式化的应用逻辑。
- en: Since controllers allow us to group logic, we can also apply configurations
    to a controller that will affect all of the methods inside it. We'll explore more
    of this concept later.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于控制器允许我们对逻辑进行分组，我们还可以对控制器应用配置，以影响其中所有的方法。我们稍后会更多地探讨这个概念。
- en: 'Let''s create the file `application/controllers/users.php` and fill it with
    our controller class'' skeleton:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建文件`application/controllers/users.php`，并填充它与我们控制器类的骨架：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Our `users` controller is a class whose name is constructed from the domain
    of the methods contained within and is suffixed with `_Controller`. Since this
    controller's domain is user accounts, our controller is named `Users_Controller`.
    The `_Controller` suffix is required because it prevents controller classes from
    having name collisions with other classes in the system.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`users`控制器是一个类，其名称是由其中包含的方法的域构成的，并以`_Controller`为后缀。由于这个控制器的域是用户帐户，我们的控制器被命名为`Users_Controller`。`_Controller`后缀是必需的，因为它可以防止控制器类与系统中的其他类发生名称冲突。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A controller's domain should always be plural when applicable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的域在适用时应该始终是复数形式。
- en: You'll notice that our `Users_Controller` class extends Laravel's default `Base_Controller`
    class. This is a good practice because if we need some code or configurations
    to affect all of our controllers, we can just edit the file `application/controllers/base.php`
    and make changes to the `Base_Controller` class. Every controller that extends
    the `Base_Controller` class will be affected.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们的`Users_Controller`类扩展了Laravel的默认`Base_Controller`类。这是一个很好的做法，因为如果我们需要一些代码或配置来影响所有的控制器，我们只需编辑文件`application/controllers/base.php`并对`Base_Controller`类进行更改。扩展`Base_Controller`类的每个控制器都会受到影响。
- en: You'll also notice that we have defined a controller action named `index`. A
    **controller action** is a method within a controller class that we intend to
    be the destination for a route. You may decide to create methods within a controller
    class that will only be called from other methods within that class; these would
    not be actions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到，我们已经定义了一个名为`index`的控制器动作。**控制器动作**是控制器类中的一个方法，我们打算将其作为路由的目的地。您可以决定在控制器类中创建只能从该类中的其他方法调用的方法；这些方法不会被视为动作。
- en: Controller actions are named with the prefix `action_`. This is an important
    distinction because we do not want users to be able to access methods within our
    controller that aren't actions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器动作的名称以前缀`action_`命名。这是一个重要的区别，因为我们不希望用户能够访问控制器中不是动作的方法。
- en: 'So, now that we have this controller how can we access the `index` action from
    our browser? For now, we can''t. We haven''t routed any URL to that controller
    action. So, let''s do that. Open up `application/routes.php` and add the following
    line:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了这个控制器，我们如何从浏览器访问`index`动作呢？目前还不能。我们还没有将任何URL路由到该控制器动作。所以，让我们这样做。打开`application/routes.php`并添加以下行：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, we can register an entire controller with the router with one
    command. Now, we can access our `users` controller's `index` action with `http://myfirst.dev/users/index`.
    The `index` action is also considered to be the default action for a controller,
    so we can also access our `index` action at `http://myfirst.dev/users`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们可以用一个命令将整个控制器注册到路由器中。现在，我们可以通过`http://myfirst.dev/users/index`访问我们的`users`控制器的`index`动作。`index`动作也被视为控制器的默认动作，因此我们也可以在`http://myfirst.dev/users`访问我们的`index`动作。
- en: It's important to note that while routing to closures is convenient, routing
    to controllers is generally considered better practice for a few reasons. Controllers
    are not loaded into memory until their routes are accessed, which helps to reduce
    the memory footprint of your application. They also make maintenance easier by
    making it quite clear where the developer can find the code for the route. Controllers
    are derived from a base class, so it's simple to make a change in one class and
    through inheritance have that change affect other classes. Finally, since controllers
    are actions grouped by purpose, it's often quite convenient to assign filters
    on a per-controller basis. We'll talk more about filters in the section *Top 5
    features you need to know about*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，虽然路由到闭包很方便，但通常认为路由到控制器是更好的做法，原因有几点。控制器直到它们的路由被访问时才会加载到内存中，这有助于减少应用程序的内存占用。它们还通过清晰地指出开发人员可以在哪里找到路由代码来简化维护。控制器是从一个基类派生的，因此在一个类中进行更改并通过继承使该更改影响其他类是很简单的。最后，由于控制器是按目的分组的动作，通常很方便根据每个控制器分配过滤器。我们将在*你需要了解的前5个功能*部分更多地讨论过滤器。
- en: Step 7 – Creating the users index view
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7步 - 创建用户索引视图
- en: Now we can go to `http://myfirst.dev/users` and access the `index` method of
    our controller. That's pretty cool, but our `users` controller's `index` page
    needs to show us a list of the users in the system. To display a list of users,
    we're going to need to create a view.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以去`http://myfirst.dev/users`并访问我们控制器的`index`方法。这很酷，但是我们的`users`控制器的`index`页面需要显示系统中的用户列表。为了显示用户列表，我们需要创建一个视图。
- en: A **view** is a file that contains formatting data (typically HTML). PHP variables,
    conditionals, and loops are used within the view to display and format dynamic
    content.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图**是一个包含格式化数据（通常是HTML）的文件。在视图中使用PHP变量、条件和循环来显示和格式化动态内容。'
- en: Laravel provides its own templating system called **Blade**. Blade removes PHP
    tags and provides shortcuts for common tasks so that your views are cleaner and
    easier to create and maintain.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel提供了自己的模板系统，称为**Blade**。Blade去除了PHP标记，并提供了常见任务的快捷方式，使得视图更清晰、更容易创建和维护。
- en: Let's get started by creating the folder `application/views/users/`. This folder
    will store all of the views for our `users` controller. It is a standard convention
    to create a folder under `application/views` for each controller that needs a
    view. Then, create the view file at `application/views/users/index.blade.php`.
    The convention is to name the view file after the controller action in which it's
    used. In this example, we're using Blade. If you do not wish to use Blade simply
    name the file `index.php`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建文件夹`application/views/users/`。这个文件夹将存储我们`users`控制器的所有视图。按照惯例，为每个需要视图的控制器在`application/views`下创建一个文件夹。然后，在`application/views/users/index.blade.php`创建视图文件。按照惯例，视图文件的命名应该与控制器中使用的动作相同。在这个例子中，我们使用的是Blade。如果你不想使用Blade，只需将文件命名为`index.php`。
- en: 'Let''s fill the view with the following HTML:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下HTML填充视图：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It's not pretty. But, it's easy to understand.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这不够美观。但是，很容易理解。
- en: 'Now, we''ll make a modification to the `users` controller''s `index` action:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对`users`控制器的`index`动作进行修改：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, where we were previously returning a string, we'll return a View object.
    Let's take a closer look at what's happening here.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将返回一个View对象，而不是之前返回一个字符串。让我们更仔细地看看这里发生了什么。
- en: The `View` class' `make()` method is a factory method that is used to generate
    View objects. In this case, we're passing the argument `users.index`. This is
    Laravel's internal notation for referring to view files. The notation is made
    up of the path to the view file relative to the `application/views` directory
    including the filename without its file extension. For example, `application/views/users/index.php`
    would be written as `users.index`, and `application/views/admin/users/create.php`
    would be written as `admin.users.create`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`View`类的`make()`方法是一个工厂方法，用于生成View对象。在这种情况下，我们传递参数`users.index`。这是Laravel内部用于引用视图文件的表示法。这个表示法由视图文件相对于`application/views`目录的路径和不带文件扩展名的文件名组成。例如，`application/views/users/index.php`会被写成`users.index`，`application/views/admin/users/create.php`会被写成`admin.users.create`。'
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to note that we're returning the View object instead of using
    echo to send the rendered contents of the view to the browser. This is an important
    aspect of the way that Laravel works. We'll never use echo from within a routed
    closure or a controller action. Instead, we'll always return the result and allow
    Laravel to handle things appropriately.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们返回了View对象，而不是使用echo将视图的渲染内容发送到浏览器。这是Laravel工作方式的一个重要方面。我们永远不会在路由闭包或控制器动作中使用echo。相反，我们总是返回结果，并允许Laravel适当处理事情。
- en: Now, when we go to `http://myfirst.dev/users`, we'll see the view that we just
    created!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们访问`http://myfirst.dev/users`时，我们将看到我们刚刚创建的视图！
- en: Step 8 – Passing data from a controller to a view
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8步 - 从控制器传递数据到视图
- en: The fact that we can go to a URL and see the view file that we created is pretty
    cool. But, we need to be able to see the list of users from our database. To accomplish
    this goal, we'll first query the `User` model from our controller action, and
    then pass that data to the view. Finally, we'll update our view to display the
    user data received from the controller.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过URL访问并查看我们创建的视图文件，这很酷。但是，我们需要能够看到来自我们数据库的用户列表。为了实现这个目标，我们将首先从控制器动作查询`User`模型，然后将数据传递给视图。最后，我们将更新我们的视图以显示从控制器接收的用户数据。
- en: 'Let''s start by updating our `users` controller''s `index` action:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始更新我们的`users`控制器的`index`动作：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s look at this line by line:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行看一下：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, we request all users as objects from Eloquent. If we have no rows in
    our `users` table, `$users` will be an empty array. Otherwise, `$users` will be
    an array of objects. These objects are instantiations of our `User` class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从Eloquent请求所有用户作为对象。如果我们的`users`表中没有行，`$users`将是一个空数组。否则，`$users`将是一个对象数组。这些对象是我们`User`类的实例化。
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Then, we modify the creation of our `View` object a bit. We chained a new method
    named `with()`. The `with()` method allows us to pass data from the controller
    into the view. This method accepts two arguments. The first argument is the name
    of the variable that will be created in the view. The second argument will be
    the value of that variable.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们稍微修改了我们的`View`对象的创建。我们链式调用了一个名为`with()`的新方法。`with()`方法允许我们将数据从控制器传递到视图。这个方法接受两个参数。第一个参数是将在视图中创建的变量的名称。第二个参数将是该变量的值。
- en: To recap, we've queried the database for all users and passed them as an array
    of `User` objects to the view. The array of `User` objects will be available in
    the view as the variable `$users` due to the fact that `users` was the first argument
    to the `with()` method.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们已经查询了数据库中的所有用户，并将它们作为`User`对象数组传递给了视图。由于`users`是`with()`方法的第一个参数，所以`User`对象数组将在视图中作为变量`$users`可用。
- en: Step 9 – Adding our dynamic content to the view
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9步 - 将动态内容添加到视图中
- en: Now that our view has access to the user data, let's update the view so that
    we can actually see those users.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的视图可以访问用户数据了，让我们更新视图，这样我们就可以真正看到这些用户了。
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Blade is easy to understand and results in much more elegant code. The `{{ }}`
    tags output the results of the expression within them and replace a typical echo
    command. Other constructions such as `if()`, `foreach()`, and `for()` are the
    same, but without PHP tags and with a preceding `@`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Blade易于理解，并且产生了更加优雅的代码。`{{ }}`标签输出其中的表达式的结果，并替换了典型的echo命令。其他构造，如`if()`、`foreach()`和`for()`是一样的，但没有PHP标签，并且前面有一个`@`。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Blade doesn't incur a significant performance penalty since it renders to a
    raw PHP cache. Parsing of a Blade template is only done when changes have been
    made.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Blade不会产生显著的性能损耗，因为它会渲染到原始的PHP缓存中。只有在有更改时才会对Blade模板进行解析。
- en: It's also important to note that you are still free to use PHP tags in the Blade
    templates.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，你仍然可以在Blade模板中自由使用PHP标签。
- en: As you can see we use an if statement to check if the `$users` array contains
    data. If it does, we loop through the users and display a new list item for each.
    If the `$users` array doesn't contain any data, we output a message saying so.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用一个if语句来检查`$users`数组是否包含数据。如果包含，我们就循环遍历用户并为每个用户显示一个新的列表项。如果`$users`数组不包含任何数据，我们就输出一条相应的消息。
- en: And that's it! Save the file and hit reload in your browser, and you will see
    the test account that we created.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！保存文件并在浏览器中重新加载，你会看到我们创建的测试账户。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This may be a good time to play around with the HTML or add new users using
    the `test` route that we made to get a better feel for how everything works.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能是一个很好的时机，通过`test`路由来玩弄HTML或添加新用户，以更好地了解一切是如何工作的。
- en: Step 10 – RESTful controllers
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10步 - RESTful控制器
- en: We've already mentioned that Laravel's routing system enables you to route `GET`,
    `POST`, `PUT`, and `DELETE` requests to closures. But we haven't talked about
    how to individually route them to controller actions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到Laravel的路由系统使你能够将`GET`、`POST`、`PUT`和`DELETE`请求路由到闭包。但我们还没有讨论如何将它们分别路由到控制器操作。
- en: The answer is RESTful controllers! RESTful controllers enable you to route to
    different controller actions based on the request method. Let's configure our
    application to use RESTful controllers.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 答案就是RESTful控制器！RESTful控制器使你能够根据请求方法路由到不同的控制器操作。让我们配置我们的应用程序使用RESTful控制器。
- en: Since all of our controller classes are derived from the `Base_Controller` class,
    we can simply add the `$restful` configuration to it and all of our controllers
    will be affected.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们所有的控制器类都是从`Base_Controller`类派生的，我们只需为其添加`$restful`配置，所有的控制器都会受到影响。
- en: 'Update your `Base_Controller` class to look like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的`Base_Controller`类更新为如下所示：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, every controller that extends `Base_Controller` (including our own `Users_Controller`)
    is a RESTful controller!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个继承`Base_Controller`（包括我们自己的`Users_Controller`）的控制器都是RESTful控制器！
- en: But, wait. Now, we'll get a 404 error when we go to `http://myfirst.dev/users`.
    This is because we are not declaring our actions the RESTful way.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，等等。现在，当我们访问`http://myfirst.dev/users`时，我们会得到一个404错误。这是因为我们没有以RESTful的方式声明我们的操作。
- en: 'Edit your `Users_Controller` class and change the line:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑你的`Users_Controller`类并更改这一行：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 改为：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Your `Users_Controller` class should now look like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`Users_Controller`类现在应该是这样的：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, when we save and reload the page in our browser it works again! The `get_
    prefix` that we added to our `index` method serves much the same purpose as the
    `action_` prefix that we were using previously.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们保存并在浏览器中重新加载页面时，它又可以正常工作了！我们添加到`index`方法的`get_前缀`与我们之前使用的`action_前缀`有着相同的作用。
- en: Unless a method is prefixed appropriately, Laravel will not route URLs to them.
    In this way, we can ensure that only controller actions are routable and that
    our web-application's users can't access other methods that may exist in our controllers
    by simply typing the names of the methods in their browsers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 除非一个方法被适当地前缀，否则Laravel不会将URL路由到它们。通过这种方式，我们可以确保只有控制器操作是可路由的，我们的Web应用程序用户不能通过简单地在浏览器中输入方法的名称来访问控制器中可能存在的其他方法。
- en: When an action is prefixed with `get_`, it will only respond to the `GET` requests.
    An action prefixed with `post_` will only respond to the `POST` requests. The
    same is true of `put_` and `delete_`. This gives us more code separation and allows
    us to really improve the readability and maintainability of our application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个操作以`get_`前缀时，它只会响应`GET`请求。以`post_`前缀开头的操作只会响应`POST`请求。`put_`和`delete_`也是一样的。这给了我们更多的代码分离，并允许我们真正提高应用程序的可读性和可维护性。
- en: Step 11 – Creating a form for adding users
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11步 - 创建一个添加用户的表单
- en: 'It''s time to give our site''s administrators the ability to create users.
    We''re going to need a new form. Let''s start off by creating the file `application/views/users/create.php`
    and populating it with the following form HTML:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候让我们的网站管理员有能力创建用户了。我们需要一个新的表单。让我们首先创建文件`application/views/users/create.php`，并填充以下表单HTML：
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Then, let's create a controller action for it. In our `Users_Controller`, let's
    add the following action.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们为其创建一个控制器操作。在我们的`Users_Controller`中，让我们添加以下操作。
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, we can go to `http://myfirst.dev/users/create` and see our form. Once again,
    it's not pretty but sometimes simple is best.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以转到`http://myfirst.dev/users/create`并查看我们的表单。再次，它不太漂亮，但有时简单是最好的。
- en: Step 12 – Routing POST requests to a controller action
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12步 - 将POST请求路由到控制器操作
- en: 'When we submit the form it''s going to make a `POST` request to our application.
    We haven''t yet created any actions to handle the `POST` requests, so if we submit
    it now we''re going to get a 404 error. Let''s go ahead and create a new action
    in `Users_Controller`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提交表单时，它将向我们的应用程序发出`POST`请求。我们还没有创建任何操作来处理`POST`请求，因此如果现在提交它，我们将收到404错误。让我们继续在`Users_Controller`中创建一个新的操作：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice that this method has the same action name as the `get_create()` method
    that we're using to show the create user form. Only the prefix is different. The
    `get_create()` method responds to the `GET` requests where the `post_create()`
    method responds to the `POST` requests. In the case of our create user form, the
    `post_create()` method receives the contents of the form's submitted input fields.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此方法与我们用于显示创建用户表单的`get_create()`方法具有相同的操作名称。唯一的区别是前缀不同。`get_create()`方法响应`GET`请求，而`post_create()`方法响应`POST`请求。在我们创建用户表单的情况下，`post_create()`方法接收表单提交的输入字段的内容。
- en: Go ahead and submit the create user form and you'll see the message, **The form
    has been posted here**.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 继续提交创建用户表单，您将看到消息**表单已在此处发布**。
- en: Step 13 – Receiving form input and saving to the database
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第13步 - 接收表单输入并保存到数据库
- en: Now that we are receiving the data from the form, we can go ahead and create
    the user account.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在从表单接收数据，我们可以继续创建用户帐户。
- en: 'Let''s update our `post_create()` function in the `Users_Controller` class
    to add this functionality:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们`Users_Controller`类中的`post_create()`函数以添加此功能：
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here we're creating a new user record in the same way that we did in our `test`
    route. The only difference is that we're using Laravel's `Input` class to retrieve
    the data from the form. Whether the data comes from a `GET` request's query string
    or a `POST` request's post data, the `Input::get()` method can be used to retrieve
    the data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以与我们在`test`路由中所做的方式创建新用户记录。唯一的区别是我们使用Laravel的`Input`类从表单中检索数据。无论数据来自`GET`请求的查询字符串还是`POST`请求的提交数据，都可以使用`Input::get()`方法来检索数据。
- en: We populate the `User` object with input data. Then we save the new user.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用输入数据填充`User`对象。然后我们保存新用户。
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here's something new. Instead of returning a string or a `View` object, we're
    using the `Redirect` class to return a `Response` object. Both routed closures
    and controller actions are expected to return a response. That response could
    be a string or a `Response` object. When a `View` object is returned it will be
    rendered as a string. The `Redirect` class' `to()` method specifically tells Laravel
    to redirect the user to the page specified in its argument. In this example the
    user will be redirected to `http://myfirst.dev/users`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新东西。我们不是返回一个字符串或`View`对象，而是使用`Redirect`类返回一个`Response`对象。路由闭包和控制器操作都应返回一个响应。该响应可以是一个字符串或`Response`对象。当返回一个`View`对象时，它将被呈现为一个字符串。`Redirect`类的`to()`方法明确告诉Laravel将用户重定向到其参数中指定的页面。在这个例子中，用户将被重定向到`http://myfirst.dev/users`。
- en: We're redirecting the user here so that they can see the updated list of users,
    which will include the user that they just created. Go ahead and give it a try!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里重定向用户，以便他们可以看到更新后的用户列表，其中将包括他们刚刚创建的用户。继续尝试一下！
- en: Step 14 – Creating links with the HTML helper
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第14步 - 使用HTML辅助程序创建链接
- en: 'We need a link from the users index view to the create user form as it''s currently
    inaccessible from the user interface. Go ahead and add the link to the file `application/views/users/
    index.blade.php` with the following line of code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从用户索引视图到创建用户表单的链接，因为它目前无法从用户界面访问。继续并在文件`application/views/users/index.blade.php`中添加以下代码行的链接：
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Laravel's `HTML` class can be used to create a variety of HTML tags. You might
    be asking yourself why you wouldn't simply write the HTML for the link yourself.
    One very good reason to use Laravel's HTML helper class is that it provides a
    unified interface for creating tags that may need to change dynamically. Let's
    look at an example to clarify this point.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel的`HTML`类可用于创建各种HTML标记。您可能会问自己为什么不直接自己编写链接的HTML。使用Laravel的HTML辅助类的一个非常好的理由是它提供了一个统一的接口来创建可能需要动态更改的标记。让我们看一个例子来澄清这一点。
- en: 'Let''s say that we want that link to look like a button and our designer created
    a sweet CSS class named `btn`. We need to update the call to `HTML::link()` to
    include the new class attribute:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望该链接看起来像一个按钮，我们的设计师创建了一个名为`btn`的漂亮CSS类。我们需要更新对`HTML::link()`的调用以包括新的class属性：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Actually, we could include any number of attributes to that class and they'd
    all be handled appropriately. Any attribute assigned to the HTML elements can
    be updated dynamically by passing a variable to that method instead of declaring
    it inline.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以为该类包含任意数量的属性，并且它们都将得到适当处理。可以通过将变量传递给该方法来动态更新HTML元素分配的任何属性，而不是在内联中声明它。
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Step 15 – Deleting user records with Eloquent
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第15步 - 使用Eloquent删除用户记录
- en: Now that we can add users, we may want to do a bit of cleanup. Let's add a delete
    action to our `users` controller.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加用户，我们可能想要做一些清理。让我们在我们的`users`控制器中添加一个删除操作。
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, let's step through this.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐步进行。
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is the first time that we've declared a parameter in a controller action.
    In order to delete a user, we need to know which user to delete. Since we have
    used `Route::controller('users')` to have Laravel automatically handle the routing
    for our controller, it'll know that when we go to the URL `http://myfirst.dev/users/delete/1`
    it should route to the delete action and pass additional URI segments as arguments
    to the method.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在控制器操作中第一次声明参数。为了删除用户，我们需要知道要删除哪个用户。由于我们使用了`Route::controller('users')`让Laravel自动处理我们控制器的路由，它会知道当我们访问URL`http://myfirst.dev/users/delete/1`时，应该路由到删除操作，并将附加的URI段作为参数传递给方法。
- en: 'If you wanted to receive a second argument from a URL (for example, `http://myfirst.dev/users/delete/happy`),
    you would add a second parameter to your action as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从URL接收第二个参数（例如`http://myfirst.dev/users/delete/happy`），您可以将第二个参数添加到您的操作中，如下所示：
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Next, we need to verify that a user with the specified user ID actually exists.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要验证具有指定用户ID的用户是否实际存在。
- en: '[PRE49]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This line tells Eloquent to find a user with an ID that matches the argument.
    If a user is found, the `$user` variable will be populated with an object that
    is an instance of our `User` class. If not, the `$user` variable will contain
    a null value.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行告诉Eloquent查找ID与参数匹配的用户。如果找到用户，`$user`变量将被填充为我们`User`类的实例对象。如果没有找到，`$user`变量将包含一个空值。
- en: '[PRE50]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we're checking if our user variable has the null value indicating that
    the requested user was not found. If so, we'll redirect back to the `users` index.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在检查我们的用户变量是否具有空值，表明请求的用户未找到。如果是这样，我们将重定向回`users`索引。
- en: '[PRE51]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Next, we delete the user and redirect back to the `users` index.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们删除用户并重定向回`users`索引。
- en: 'Of course, our work here won''t be finished until we update our `application/views/users/index.php`
    file to give us links to delete each user. Replace the list item code with the
    following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的工作还没有完成，直到我们更新我们的`application/views/users/index.php`文件，以便给我们每个用户都有删除链接。用以下代码替换列表项代码：
- en: '[PRE52]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Reload the `users` index page and you'll now see the delete link. Click on it
    and be horrified that we've irreparably removed data from the database. I hope
    it wasn't anything important!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载`users`索引页面，现在你会看到删除链接。点击它，然后会惊恐地发现我们已经从数据库中无法修复地删除了数据。希望这不是什么重要的东西！
- en: Step 16 – Updating a user with Eloquent
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第16步 - 使用Eloquent更新用户
- en: 'So, we can add and delete users, but what if we have made a typo and want to
    fix it? Let''s update our `users` controller with the methods that are necessary
    for us to display our update form and then to retrieve the data from it in order
    to update the user record:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可以添加和删除用户，但是如果我们打错字了想要修正怎么办？让我们更新我们的`users`控制器，使用必要的方法来显示更新表单，然后检索其中的数据以更新用户记录：
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here we have our new `get_update()` method. This method accepts a user ID as
    an argument. Much like we did with the `get_delete()` method, we need to load
    the user record from the database to verify that it exists. Then, we'll pass that
    user to the update form.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有我们的新`get_update()`方法。这个方法接受一个用户ID作为参数。就像我们在`get_delete()`方法中所做的那样，我们需要从数据库中加载用户记录以验证其是否存在。然后，我们将把该用户传递给更新表单。
- en: '[PRE54]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When a user submits our update form, they'll be routed to `post_update()`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户提交我们的更新表单时，他们将被路由到`post_update()`。
- en: You may have noticed a common theme with methods that receive a user ID as an
    argument. Whenever we are going to interact with a user model we need to know
    for sure that the database record exists and that the model is populated. We must
    always first load it and validate that it is not null.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到了接收用户ID作为参数的方法的一个共同主题。每当我们要与用户模型交互时，我们都需要确保数据库记录存在并且模型已填充。我们必须始终首先加载它并验证它不是空的。
- en: Afterwards, we assign new values to the `real_name` and `email` attributes.
    We don't want to just change the user's password every time we submit a change.
    So, we'll first verify that the password field wasn't left blank. Laravel's `Input`
    class' `has()` method will return `false`, if an attribute either wasn't sent
    in the form post or if it's blank. If it's not blank, we can go ahead and update
    the attribute in the model.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们为`real_name`和`email`属性分配新值。我们不希望每次提交更改时都更改用户的密码。因此，我们首先要验证密码字段是否为空。如果密码字段为空，Laravel的`Input`类的`has()`方法将返回`false`，如果属性没有在表单提交中发送，或者为空。如果不为空，我们可以继续更新模型中的属性。
- en: We then save the changes to the user and redirect back to the `users` index
    page.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们保存对用户的更改，并重定向回`users`索引页面。
- en: Step 17 – Creating the update form with the form helper
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第17步 - 使用表单助手创建更新表单
- en: Now, we just need to create the `update` form and we'll have a full administrative
    system!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要创建`update`表单，我们就会有一个完整的管理系统！
- en: 'Go ahead and create the view at `application/views/users/update.blade.php`
    and fill it with this lovely form:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创建视图`application/views/users/update.blade.php`，并用这个可爱的表单填充它：
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is almost exactly like the create form except that we have mixed things
    up a little. First of all, you'll notice that we're using Laravel's `Form` class
    helper methods. These helper methods, like the `HTML` class' helper methods, are
    not mandatory. However, they are recommended. They offer many of the same advantages
    as the `HTML` class' helper methods. The `Form` class' helper methods offer a
    unified interface for generating the resulting HTML tags. It's much easier to
    programmatically update HTML tag attributes by passing an array as an argument
    than to loop through and generate the HTML yourself.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与创建表单完全相同，只是我们稍微混合了一些东西。首先，您会注意到我们正在使用Laravel的`Form`类助手方法。这些助手方法，就像`HTML`类的助手方法一样，不是强制性的。但是，它们是建议使用的。它们提供了许多与`HTML`类的助手方法相同的优势。`Form`类的助手方法提供了一个统一的接口来生成最终的HTML标记。通过将数组作为参数传递，以编程方式更新HTML标记属性要比循环生成HTML自己更容易得多。
- en: '[PRE56]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Text fields can be prepopulated by passing in a second argument. In this example,
    we're passing the `real_name` attribute from the `user` object that we passed
    from the controller. We then prepopulate the `email` field in the same way.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 文本字段可以通过传入第二个参数进行预填充。在这个例子中，我们正在传递从控制器传递的`user`对象的`real_name`属性。然后以相同的方式预填充`email`字段。
- en: '[PRE57]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Notice that we're not prepopulating the `password` field. It doesn't make sense
    to do so as we're not storing a readable version of the password in the database.
    Not only that, to prevent a developer from making a mistake the `Form::password()`
    method does not have the functionality to prepopulate this field at all.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有预填充`password`字段。这样做是没有意义的，因为我们不会在数据库中存储密码的可读版本。不仅如此，为了防止开发人员犯错，`Form::password()`方法根本没有预填充这个字段的功能。
- en: And with that we have a fully working update user form!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就有了一个完全可用的更新用户表单！
- en: Top 5 features you need to know about
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你需要了解的前5个功能
- en: As you start to use Laravel, you will realize that it provides a wide variety
    of functionality. We've taken the time to describe the five most vital components
    that we haven't covered in the *Quick start* section. Gaining mastery over these
    five components gives you the power to make amazing web applications with Laravel.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始使用Laravel时，您会意识到它提供了各种各样的功能。我们花时间描述了在*快速入门*部分中没有涵盖的五个最重要的组件。掌握这五个组件的能力使您有能力使用Laravel制作令人惊叹的Web应用程序。
- en: 1 – Eloquent relationships
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1 – Eloquent关系
- en: Eloquent is Laravel's native ActiveRecord implementation. It is built upon Laravel's
    Fluent Query Builder. Due to the way in which Eloquent operates with Fluent, complex
    queries and relationships are easy to describe and understand.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent是Laravel的本地ActiveRecord实现。它是建立在Laravel的Fluent查询构建器之上的。由于Eloquent与Fluent的操作方式，复杂的查询和关系很容易描述和理解。
- en: '**ActiveRecord** is a design pattern that describes an object-oriented way
    of interacting with your database. For example, your database''s `users` table
    contains rows and each of these rows represents a single user of your site. Your
    `User` model is a class that extends the Eloquent Model class. When you query
    a record from your database, an instantiation of your `User` model class is created
    and populated with the information from the database.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**ActiveRecord**是一种描述与数据库交互的面向对象方式的设计模式。例如，您的数据库的`users`表包含行，每行代表您网站的一个用户。您的`User`模型是一个扩展了Eloquent模型类的类。当您从数据库查询记录时，将创建一个`User`模型类的实例，并用数据库中的信息填充它。'
- en: '![1 – Eloquent relationships](graphics/0908OS_01_01.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![1 – Eloquent relationships](graphics/0908OS_01_01.jpg)'
- en: A distinct advantage of ActiveRecord is that your data and the business logic
    that is related to the data are housed within the same object. For example, it's
    typical to store the user's password in your model as a hash, to prevent it from
    being stored as plaintext. It's also typical to store the method, which creates
    this password hash within your `User` class.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ActiveRecord的一个明显优势是，您的数据和与数据相关的业务逻辑都存储在同一个对象中。例如，将用户的密码存储在模型中作为哈希是典型的，以防止以明文形式存储。还典型的是，在您的`User`类中存储创建这个密码哈希的方法。
- en: Another powerful aspect of the ActiveRecord pattern is the ability to define
    relationships between models. Imagine that you're building a blog site and your
    users are authors who must be able to post their writings. Using an ActiveRecord
    implementation, you are able to define the parameters of the relationship. The
    task of maintaining this relationship is then simplified dramatically. Simple
    code is the easy code to change. Difficult to understand code is the easy code
    to break.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ActiveRecord模式的另一个强大之处在于定义模型之间的关系的能力。想象一下，您正在构建一个博客网站，您的用户是必须能够发布他们的作品的作者。使用ActiveRecord实现，您能够定义关系的参数。然后，维护这种关系的任务大大简化了。简单的代码是易于更改的代码。难以理解的代码是易于破坏的代码。
- en: As a PHP developer, you're probably already familiar with the concept of database
    normalization. If you're not, **normalization** is the process of designing databases
    so that there is little redundancy in the stored data. For example, you wouldn't
    want to have both a `users` table which contains the user's name and a table of
    blog posts which also contains the author's name. Instead, your blog post record
    would refer to the user using their user ID. In this way we avoid synchronization
    problems and a lot of extra work!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 作为PHP开发人员，您可能已经熟悉数据库规范化的概念。如果您不熟悉，**规范化**是设计数据库的过程，以便存储的数据中减少冗余。例如，您不希望既有一个包含用户姓名的`users`表，又有一个包含作者姓名的博客文章表。相反，您的博客文章记录将使用用户ID引用用户。通过这种方式，我们避免了同步问题和大量的额外工作！
- en: There are a number of ways in which relationships can be established in normalized
    database schemas.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在规范化的数据库模式中，有许多建立关系的方式。
- en: One-to-one relationship
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一对一关系
- en: When a relationship connects two records in a way that doesn't allow for more
    records to be related, it is a **one-to-one relationship**. For example, a *user*
    record might have a one-to-one relationship with a *passport* record. In this
    example, a *user* record is not permitted to be linked to more than one *passport*
    record. Similarly, it is not permitted for a *passport* record to relate to more
    than one user record.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个关系以不允许更多记录相关的方式连接两条记录时，它是一个**一对一关系**。例如，*user*记录可能与*passport*记录有一对一关系。在这个例子中，*user*记录不允许链接到多个*passport*记录。同样，*passport*记录也不允许与多个用户记录相关联。
- en: How would the database look? Your `users` table contains information about each
    user in your database. Your `passports` table contains passport numbers and a
    link to the user which owns the passport.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库会是什么样子？您的`users`表包含数据库中每个用户的信息。您的`passports`表包含护照号码和拥有护照的用户的链接。
- en: '![One-to-one relationship](graphics/0908OS_01_02.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![一对一关系](graphics/0908OS_01_02.jpg)'
- en: In this example, each user has no more than one passport and each passport must
    have an owner. The `passports` table contains its own `id` column which it uses
    as a primary key. It also contains the column `user_id`, which contains the ID
    of the user to whom the passport belongs. Last but not least, the `passports`
    table contains a column for the passport number.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个用户最多只有一个护照，每个护照必须有一个所有者。`passports`表包含自己的`id`列，它用作主键。它还包含`user_id`列，其中包含护照所属用户的ID。最后，`passports`表包含护照号码的列。
- en: 'First, let''s model this relationship in the `User` class:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`User`类中建模这种关系：
- en: '[PRE58]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We created a method named `passport()` that returns a relationship. It might
    seem strange to return relationships at first. But, you'll soon come to love it
    for the flexibility it offers.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`passport()`的方法，它返回一个关系。一开始返回关系可能看起来有点奇怪。但是，你很快就会喜欢它所提供的灵活性。
- en: You'll notice that we're using the `has_one()` method and passing the name of
    the model as a parameter. In this case, a user has one passport. So, the parameter
    is the name of the passport model class. This is enough information for Eloquent
    to understand how to acquire the correct passport record for each user.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们使用了`has_one()`方法，并将模型的名称作为参数传递。在这种情况下，用户有一个护照。因此，参数是护照模型类的名称。这就足够让Eloquent理解如何为每个用户获取正确的护照记录。
- en: 'Now, let''s look at the `Passport` class:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`Passport`类：
- en: '[PRE59]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We're defining the passport's relationship differently. In the `User` class,
    we used the `has_one()` method. In the `Passport` class we used `belongs_to()`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以不同的方式定义了护照的关系。在`User`类中，我们使用了`has_one()`方法。在`Passport`类中，我们使用了`belongs_to()`。
- en: It's vital to identify the difference early so that understanding the rest of
    the relationships is more simple. When a database table contains a foreign key,
    it is said that it belongs to a record in another table. In this example, our
    `passports` table refers to records in the `users` table through the foreign key
    `user_id`. Consequently, we would say that a passport belongs to a user. Since
    this is a one-to-one relationship the user has one (`has_one()`) passport.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 及早识别差异是至关重要的，这样理解其他关系就更简单了。当数据库表包含外键时，可以说它属于另一个表中的记录。在这个例子中，我们的`passports`表通过外键`user_id`指向`users`表中的记录。因此，我们会说护照属于用户。由于这是一对一关系，用户有一个（`has_one()`）护照。
- en: '![One-to-one relationship](graphics/0908OS_01_03.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![一对一关系](graphics/0908OS_01_03.jpg)'
- en: Let's say that we want to view the passport number of the user with the `id`
    of `1`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想查看`id`为`1`的用户的护照号码。
- en: '[PRE60]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this example, we're dutifully checking to make sure that our `user` object
    was returned as expected. This is a necessary step that should not be overlooked.
    Then, we check whether or not the user has a passport record associated with it.
    If a passport record for this user exists, the related object will be returned.
    If it doesn't exist, `$user->passport` will return `null`. In the preceding example,
    we test for the existence of a record and return the appropriate response.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们认真检查确保我们的`user`对象是否如预期返回。这是一个必要的步骤，不应忽视。然后，我们检查用户是否有与之关联的护照记录。如果用户存在护照记录，相关对象将被返回。如果不存在，`$user->passport`将返回`null`。在前面的例子中，我们测试记录的存在并返回适当的响应。
- en: One-to-many relationships
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一对多关系
- en: '**One-to-many** relationships are similar to one-to-one relationships. In this
    relationship type, one model has many of other relationships, which in turn belongs
    to the former. One example of a one-to-many relationship is a professional sports
    team''s relationship to its players. One team has many players. In this example,
    each player can only belong to one team. The database tables have the same structure.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**一对多**关系类似于一对一关系。在这种关系类型中，一个模型有许多其他关系，这些关系反过来属于前者。一个一对多关系的例子是专业体育队与其球员的关系。一个团队有很多球员。在这个例子中，每个球员只能属于一个团队。数据库表具有相同的结构。'
- en: '![One-to-many relationships](graphics/0908OS_01_04.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![一对多关系](graphics/0908OS_01_04.jpg)'
- en: Now, let's look at the code which describes this relationship.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下描述这种关系的代码。
- en: '[PRE61]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This example is almost identical to the one-to-one example. The only difference
    is that the team's `players()` relationship uses `has_many()` rather than `has_one()`.
    The `has_one()` relationship returns a model object. The `has_many()` relationship
    returns an array of model objects.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子几乎与一对一的例子相同。唯一的区别是团队的`players()`关系使用`has_many()`而不是`has_one()`。`has_one()`关系返回一个模型对象。`has_many()`关系返回一个模型对象数组。
- en: 'Let''s display all of the players on a specific team:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们显示特定团队的所有球员：
- en: '[PRE62]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Again, we test to make sure that our team could be found. Then, we test to make
    sure that the team has players. Once we know that for sure, we can loop through
    those players and echo their names. If we tried to loop through the players without
    first testing and if the team had players, we'd get an error.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们测试确保我们能找到我们的团队。然后，我们测试确保团队有球员。一旦我们确定了这一点，我们就可以循环遍历这些球员并输出他们的名字。如果我们在没有先测试并且团队有球员的情况下尝试循环遍历球员，我们会得到一个错误。
- en: Many-to-many relationships
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多对多关系
- en: The last relationship type that we're going to cover is the many-to-many relationship.
    This relationship is different in that each record from each table could potentially
    be tied simultaneously to each record in another. We aren't storing foreign keys
    in either of these tables. Instead, we have a third table that exists solely to
    store our foreign keys. Let's take a look at the schema.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要讨论的最后一种关系类型是多对多关系。这种关系不同之处在于每个表中的每条记录都可能同时与另一个表中的每条记录相关联。我们在这两个表中都没有存储外键。相反，我们有一个第三个表，它存在
    solely 用于存储我们的外键。让我们看一下模式。
- en: '![Many-to-many relationships](graphics/0908OS_01_05.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![多对多关系](graphics/0908OS_01_05.jpg)'
- en: Here we have a students table and a courses table. A student can be enrolled
    in many courses and a course can contain many students. The connection between
    students and courses is stored in a pivot table.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个学生表和一个课程表。一个学生可以注册多门课程，一门课程可以包含多名学生。学生和课程之间的连接存储在一个中间表中。
- en: A **pivot table** is a table that exists to connect two tables specifically
    for many-to-many relationships. Standard convention for naming a pivot table is
    to combine the names of both of the related tables, singularized, alphabetically
    ordered, and connected with an underscore. This gives us the table name `course_student`.
    This convention is not only used by Laravel and it's a good idea to follow the
    naming conventions covered in this document as strictly as possible as they're
    widely used in the web-development industry.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**中间表**是一个专门用于连接两个表的表，特别是用于多对多关系。命名中间表的标准约定是将两个相关表的名称结合起来，单数化，按字母顺序排列，并用下划线连接起来。这给我们提供了表名`course_student`。这个约定不仅被Laravel使用，严格遵循本文档中涵盖的命名约定是一个很好的主意，因为它们在Web开发行业中被广泛使用。'
- en: It's important to notice that we're not creating a model for the pivot table.
    Laravel allows us to manage these tables without needing to interact with a model.
    This is especially nice because it doesn't make sense to model a pivot table with
    business logic. Only the students and courses are a part of our business. The
    connection between them is important, but only to the students and to the course.
    It's not important for its own sake.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们没有为中间表创建模型。Laravel允许我们管理这些表，而无需与模型交互。这特别好，因为用业务逻辑对中间表建模是没有意义的。只有学生和课程是我们业务的一部分。它们之间的连接很重要，但只对学生和课程重要。它本身并不重要。
- en: Let's define these models, shall we?
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义这些模型，好吗？
- en: '[PRE63]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We have two models, each with the same type of relationship to each other. `has_many_and_belongs_to`
    is a long name. But, it's a fairly simple concept. A course has many students.
    But, it also belongs to (`belongs_to`) student records and vice-versa. In this
    way, they are considered equal.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个模型，彼此具有相同类型的关系。`has_many_and_belongs_to`是一个很长的名字。但是，这是一个相当简单的概念。一门课程有很多学生。但它也属于（`belongs_to`）学生记录，反之亦然。这样，它们被认为是相等的。
- en: 'Let''s look at how we''ll interact with these models in practice:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们将如何在实践中与这些模型交互：
- en: '[PRE64]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here you can see that we can loop through the courses much the same way we could
    with the one-to-many relationship. Any time a relationship includes the word *many*,
    you know that you'll be receiving an array of models. Conversely, let's pull a
    course and see which students are a part of it.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们可以以与一对多关系相同的方式循环遍历课程。每当一个关系包括单词*many*时，您就知道您将收到一个模型数组。相反，让我们拉取一个课程，看看哪些学生是其中的一部分。
- en: '[PRE65]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The relationship functions exactly the same way from the course side.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 从课程方面，关系函数的工作方式完全相同。
- en: 'Now that we have established this relationship, we can do some fun things with
    it. Let''s look at how we''d enroll a new student into an existing course:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经建立了这种关系，我们可以用它做一些有趣的事情。让我们看看如何将新学生注册到现有课程中：
- en: '[PRE66]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here we're adding a new student to our course by using the method `insert()`.
    This method is specific to this relationship type and creates a new student record.
    It also adds a record to the `course_student` table to link the course and the
    new student. Very handy!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过使用`insert()`方法向我们的课程添加一个新学生。这种方法是特定于这种关系类型的，并创建一个新的学生记录。它还向`course_student`表添加一条记录，以链接课程和新学生。非常方便！
- en: But, hold on. What's this new syntax?
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，等等。这是什么新的语法？
- en: '[PRE67]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Notice how we're not using `$course->students->insert()`. Our reference to students
    is a method reference rather than a property reference. That's because Eloquent
    handles methods that return relationship objects differently from other model
    methods.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们没有使用`$course->students->insert()`。我们对学生的引用是一个方法引用，而不是属性引用。这是因为Eloquent处理返回关系对象的方法与其他模型方法不同。
- en: When you access a property of a model that doesn't exist, Eloquent will look
    to see if you have a function that matches that property's name. For example,
    if we try to access the property `$course->students`, Eloquent won't be able to
    find a member variable named `$students`. So it'll look for a function named `students()`.
    We do have one of those. Eloquent will then receive the relationship object from
    that method, process it, and return the resulting student records.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问模型的不存在的属性时，Eloquent会查看是否有与该属性名称匹配的函数。例如，如果我们尝试访问属性`$course->students`，Eloquent将无法找到名为`$students`的成员变量。因此，它将寻找名为`students()`的函数。我们有这样一个函数。然后Eloquent将从该方法接收关系对象，处理它，并返回结果的学生记录。
- en: If we access a relationship method as a method and not as a property, we directly
    receive the relationship object back. The relationship's class extends the `Query`
    class. This means that you can operate on a relationship object in the same way
    that you can operate on a query object, except that it now has new methods that
    are specific to the relationship type. The specific implementation details aren't
    important at this point. It's just important to know that we're calling the `insert()`
    method on the relationship object returned from `$course->students()`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将关系方法作为方法而不是属性访问，我们将直接收到关系对象。关系的类扩展了`Query`类。这意味着您可以像操作查询对象一样操作关系对象，只是现在它有了特定于关系类型的新方法。具体的实现细节在这一点上并不重要。重要的是要知道我们正在从`$course->students()`返回的关系对象上调用`insert()`方法。
- en: Imagine that you have a user model and it has many relationships and belongs
    to a role model. Roles represent different permission groupings. Example roles
    might include customer, admin, super admin, and ultra admin.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您有一个用户模型，它有许多关系，并且属于一个角色模型。角色代表不同的权限分组。示例角色可能包括客户、管理员、超级管理员和超级管理员。
- en: It's easy to imagine a user form for managing its roles. It would contain a
    number of checkboxes, one for each potential role. The name of the checkboxes
    is `role_ids[]` and each value represents the ID of a role in the roles table.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易想象一个用于管理其角色的用户表单。它将包含许多复选框，每个潜在角色一个。复选框的名称是`role_ids[]`，每个值代表角色表中的角色ID。
- en: When that form is posted we'll retrieve those values with the `Input::get()`
    method.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当提交该表单时，我们将使用`Input::get()`方法检索这些值。
- en: '[PRE68]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`$role_ids` is now an array that contains the values `1`, `2`, `3`, and `4`.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`$role_ids`现在是一个包含值`1`、`2`、`3`和`4`的数组。'
- en: '[PRE69]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `sync()` method is specific to this relationship type and is also perfectly
    suited for our needs. We're telling Eloquent to connect our current `$user` to
    the roles whose IDs exist within the `$role_ids` array.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync()`方法是特定于此关系类型的，并且非常适合我们的需求。我们告诉Eloquent将我们当前的`$user`连接到存在于`$role_ids`数组中的角色。'
- en: Let's look at what's going on here in further detail. `$user->roles()` is returning
    a `has_many_and_belongs_to relationship` object. We're calling the `sync()` method
    on that object. Eloquent now looks at the `$role_ids` array and acknowledges it
    as the authoritative list of roles for this user. It then removes any records
    that shouldn't exist in the `role_user` pivot table and adds records for any role
    that should exist in the pivot table.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下这里发生了什么。`$user->roles()`返回一个`has_many_and_belongs_to relationship`对象。我们在该对象上调用`sync()`方法。Eloquent现在查看`$role_ids`数组，并将其视为此用户的角色的权威列表。然后，它会删除不应存在于`role_user`中的记录，并为应存在于中的任何角色添加记录。枢纽表
- en: 2– Authentication
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2–身份验证
- en: Laravel helps you to handle the typical tasks of logging users in and out as
    well as makes it easy to access the `user` record of the currently authenticated
    user.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel帮助您处理典型的登录和注销用户的任务，以及轻松访问当前认证用户的`user`记录。
- en: First, we'll want to configure authentication for our site. The authentication
    configuration file can be found at `application/config/auth.php`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将要为我们的网站配置身份验证。身份验证配置文件可以在`application/config/auth.php`中找到。
- en: Here we are presented with a number of configuration options. Primarily, we
    must choose which `Auth` driver we use. If we choose the Fluent driver, the authentication
    system will use the table configuration option to find users and will return dumb
    objects (objects that contain only data) when we request the currently authenticated
    user. If we use the Eloquent driver, the authentication system will use the model
    listed in the model option for querying users and Laravel will return an instance
    of that model when we request the currently authenticated user. Additionally,
    you can choose which fields Laravel will authenticate against by changing the
    username and password options. Typically, you'll be using the Eloquent driver.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提供了许多配置选项。首先，我们必须选择使用哪个`Auth`驱动程序。如果我们选择Fluent驱动程序，认证系统将使用表配置选项来查找用户，并在我们请求当前认证用户时返回哑对象（仅包含数据的对象）。如果我们使用Eloquent驱动程序，认证系统将使用模型选项中列出的模型来查询用户，并在我们请求当前认证用户时，Laravel将返回该模型的实例。此外，您可以通过更改用户名和密码选项来选择Laravel将对其进行身份验证的字段。通常，您将使用Eloquent驱动程序。
- en: Let's continue our example from the *Quick start* section. We already have a
    `User` model, so let's set the driver option to Eloquent. We think that logging
    in with your e-mail address and password is good, so we'll set the username option
    to `email` and we'll leave the password option set to `password`. We'll also leave
    the model set to `User`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续从*快速入门*部分开始的示例。我们已经有一个`User`模型，所以让我们将驱动程序选项设置为Eloquent。我们认为使用电子邮件地址和密码登录很好，因此我们将用户名选项设置为`email`，并将密码选项设置为`password`。我们还将模型设置为`User`。
- en: That's it, we're all configured. Let's implement login! First, let's create
    a new controller for authentication. We'll store it in `application/controllers/auth.php`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，我们已经全部配置好了。让我们实现登录！首先，让我们为身份验证创建一个新的控制器。我们将把它存储在`application/controllers/auth.php`中。
- en: '[PRE70]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We'll need to route this and since we typically don't want to go to `http://myfirst.dev/auth/login`,
    let's manually set up a route. Add this to your `application/routes.php`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要路由这个，并且由于我们通常不想转到`http://myfirst.dev/auth/login`，让我们手动设置一个路由。将此添加到您的`application/routes.php`中。
- en: '[PRE71]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Finally, create a login form at `application/views/auth/login.blade.php`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`application/views/auth/login.blade.php`中创建一个登录表单：
- en: '[PRE72]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: That's it! Now, let's just navigate our browsers to `http://myfirst.dev/login`.
    We see our nice new login form!
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在，让我们只需将浏览器导航到`http://myfirst.dev/login`。我们看到了我们漂亮的新登录表单！
- en: 'Now, we just need to be able to submit our form. Let''s add a new action to
    our `Auth` controller:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要能够提交我们的表单。让我们向我们的`Auth`控制器添加一个新的操作：
- en: '[PRE73]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: With the addition of this method, we now have a functioning login form. Feel
    free to go ahead and try it out!
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加这个方法，我们现在有了一个可用的登录表单。随时随地尝试一下吧！
- en: Let's look at how we validate a user's e-mail and password. First, we create
    an array that contains the credentials received from the login form. Notice that
    we're storing e-mail and password by using the keys `username` and `password`.
    Despite the fact that we're using e-mail for authentication, Laravel always receives
    authentication credentials with the keys `username` and `password`. This is because
    the `username` and `password` fields are configurable in the `auth config` file.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何验证用户的电子邮件和密码。首先，我们创建一个包含从登录表单接收的凭据的数组。请注意，我们使用`username`和`password`键来存储电子邮件和密码。尽管我们使用电子邮件进行身份验证，但Laravel始终使用`username`和`password`键接收身份验证凭据。这是因为`username`和`password`字段可以在`auth
    config`文件中进行配置。
- en: Then, we pass the credentials to the `Auth::attempt()` method. This method takes
    care of the rest of the process. It'll compare our records in the database against
    the credentials that we have passed. If the credentials match up, it'll create
    a cookie in the user's browser and the user will officially be logged in. `Auth::attempt()`
    returns `true` if a successful login has taken place, and `false` if it failed.
    If the authentication attempt fails, we redirect the user back to the form and
    repopulate the `email` field.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将凭据传递给`Auth::attempt()`方法。此方法会处理其余的过程。它将比较我们在数据库中的记录与我们传递的凭据。如果凭据匹配，它将在用户的浏览器中创建一个cookie，并且用户将正式登录。如果身份验证尝试失败，我们将用户重定向回表单并重新填充`email`字段。
- en: 'Now, let''s add `logout` functionality. Add the following method to your `Auth`
    controller:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加`logout`功能。将以下方法添加到您的`Auth`控制器中：
- en: '[PRE74]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Finally, add the following line to your `routes.php` file:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将以下行添加到您的`routes.php`文件中：
- en: '[PRE75]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: That's all! Now, when we go to `http://myfirst.dev/logout`, we'll be logged
    out and redirected to our site's index page.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在，当我们访问`http://myfirst.dev/logout`时，我们将注销并重定向到我们站点的首页。
- en: 'So, how can we find out if someone is logged in? The Eloquent and Fluent `Auth`
    drivers contain two methods for handling this, `check()` and `guest()`. Let''s
    look at each of these in turn:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何知道某人是否已登录？Eloquent和Fluent `Auth`驱动程序包含两种处理方法，`check()`和`guest()`。让我们依次看看每个：
- en: '`Auth::check()` returns `true` if a user is currently logged in, and `false`
    otherwise.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Auth::check()`如果用户当前已登录，则返回`true`，否则返回`false`。'
- en: '`Auth::guest()` is the opposite of `Auth::check()`. It returns `false` if a
    user is logged in, and `true` otherwise.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Auth::guest()`是`Auth::check()`的相反。如果用户已登录，则返回`false`，否则返回`true`。'
- en: 'Once you''ve made sure that a user is logged in, you can use `Auth::user()`
    to return the user record. If you''re using the Fluent driver, `Auth::user()`
    will return a dumb object containing the appropriate values from the users table.
    If you''re using the Eloquent driver, `Auth::user()` will return an instance of
    your `User` model. This is very powerful. Let''s look at an example:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确保用户已登录，您可以使用`Auth::user()`返回用户记录。如果您使用Fluent驱动程序，`Auth::user()`将返回一个包含用户表中适当值的哑对象。如果您使用Eloquent驱动程序，`Auth::user()`将返回`User`模型的实例。这非常强大。让我们看一个例子：
- en: '[PRE76]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: As you've seen, Laravel's authentication system is driver-based. In this example,
    we used the Eloquent driver. However, you also have the ability to create custom
    authentication drivers. This gives you the power to authenticate users with different
    means and return different types of data with the standard `Auth` class' API.
    Covering the development of custom drivers is outside the scope of this document.
    However, it's simple and powerful. Be sure to look into the Laravel documentation
    for more information.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Laravel的身份验证系统是基于驱动程序的。在本例中，我们使用了Eloquent驱动程序。但是，您还可以创建自定义身份验证驱动程序。这使您有能力使用不同的方式对用户进行身份验证，并使用标准`Auth`类的API返回不同类型的数据。开发自定义驱动程序超出了本文档的范围。但是，这很简单而且强大。请务必查阅Laravel文档以获取更多信息。
- en: 3 – Filters
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3 - 过滤器
- en: Now that we have a user administration site with authentication, we need to
    restrict some pages on our site to users who have successfully authenticated.
    We'll do that by using filters.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个带有身份验证的用户管理站点，我们需要将站点上的一些页面限制为成功验证的用户。我们将使用过滤器来实现这一点。
- en: '**Filters** are functions that can be run before or after routed code. A filter
    that runs before the routed code is called a **before filter**. Similarly well-named
    is the **after filter**, which runs after routed code.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**过滤器**是可以在路由代码之前或之后运行的函数。在路由代码之前运行的过滤器称为**before过滤器**。同样命名得很好的是**after过滤器**，它在路由代码之后运行。'
- en: Filters are often used for enforcing authentication. We can create a filter
    that detects if a user is not logged in, then redirect him/her to the login form.
    Actually, we don't need to make this filter at all. Laravel ships with this filter
    already written. You can find it in your `application/routes.php`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器通常用于强制进行身份验证。我们可以创建一个检测用户是否未登录的过滤器，然后将其重定向到登录表单。实际上，我们根本不需要创建此过滤器。Laravel已经预先编写了此过滤器。您可以在您的`application/routes.php`中找到它。
- en: 'Let''s take a look:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下：
- en: '[PRE77]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You can see that a filter is registered with the `Route::filter()` method. The
    typical location to store filter registrations is within your `application/routes.php`
    file.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，过滤器是使用`Route::filter()`方法注册的。存储过滤器注册的典型位置是在您的`application/routes.php`文件中。
- en: The `Route::filter()` method takes two parameters. The first is a string containing
    the name of the filter. The second is the anonymous function that will be run
    when the filter is activated.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`Route::filter()`方法接受两个参数。第一个是包含过滤器名称的字符串。第二个是在激活过滤器时运行的匿名函数。'
- en: In this example, the anonymous function will check if a user is logged in using
    the `Auth::guest()` method. If the user is not logged in, the filter returns a
    response object that tells Laravel to redirect the user to the login page.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，匿名函数将使用`Auth::guest()`方法检查用户是否已登录。如果用户未登录，则过滤器将返回一个响应对象，告诉Laravel将用户重定向到登录页面。
- en: It's important to note that while you can return response objects from before
    filters, it's not possible to redirect from after filters as at this point it's
    too late.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，虽然您可以从before过滤器返回响应对象，但是从after过滤器重定向是不可能的，因为此时为时已晚。
- en: Now that we have the `auth` filter, how do we tell Laravel when to run it? The
    correct algorithm is situational.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`auth`过滤器，我们如何告诉Laravel何时运行它？正确的算法是情景性的。
- en: 'The following is an example of applying a filter to a routed function:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将过滤器应用于路由函数的示例：
- en: '[PRE78]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In this example, we want to provide an admin dashboard for users who have successfully
    authenticated. You may notice that our `Route::get()` declaration has changed.
    Our first argument is still the route's URI. However, our second argument is no
    longer an anonymous function, it's now an array. This array provides a method
    for configuring our route registration. Laravel knows that when you pass a key/value
    pair, it should be used as configuration and that when you pass an anonymous function,
    it should be used as the target function for the route.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们希望为成功验证的用户提供管理员仪表板。您可能注意到我们的`Route::get()`声明已经改变。我们的第一个参数仍然是路由的URI。但是，我们的第二个参数不再是匿名函数，而是一个数组。这个数组提供了一个方法来配置我们的路由注册。Laravel知道当您传递一个键值对时，它应该被用作配置，当您传递一个匿名函数时，它应该被用作路由的目标函数。
- en: In this example, we're only using one key/value pair for configuring our route.
    We use the key `before` to tell Laravel that our route uses a before filter. The
    value associated with the `before` key is the name of the filter, which should
    be run before our anonymous function is executed.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只使用一个用于配置路由的键值对。我们使用键`before`告诉Laravel我们的路由使用一个前置过滤器。与`before`键关联的值是过滤器的名称，在我们的匿名函数执行之前应该运行。
- en: '![3 – Filters](graphics/0908OS_01_06.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![3 - 过滤器](graphics/0908OS_01_06.jpg)'
- en: Controllers are groups of routable methods that are similar and are therefore
    uniquely convenient to filter upon. Often the same set of filters that is appropriate
    for one action in a controller is appropriate for the rest. Filtering at the controller
    level gives you more flexibility and less redundancy than defining your filters
    in each route declaration. Let's look at securing our `users` controller.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是一组可路由的方法，它们相似，因此非常方便进行过滤。通常，适用于控制器中一个操作的相同一组过滤器也适用于其余操作。在控制器级别进行过滤比在每个路由声明中定义过滤器具有更大的灵活性和更少的冗余。让我们来看看如何保护我们的`users`控制器。
- en: '[PRE79]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here we're looking only at the top-most section of our `users` controller. The
    rest of the controller is identical to what we created in the *Quick start* section.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只看`users`控制器的顶部部分。控制器的其余部分与我们在*快速入门*部分中创建的内容相同。
- en: As you may have noticed, we've declared a constructor for our `Users_Controller`
    class. A constructor is a method that is run immediately once our class is instantiated
    as an object. We use a controller class' constructor to define filters for that
    controller's actions. It's also important to notice that we first call the `parent::__construct()`
    method. It is important for Laravel's `Controller` class to have its constructor
    executed so that it can initialize itself and be ready for action.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的那样，我们为`Users_Controller`类声明了一个构造函数。构造函数是一种在我们的类被实例化为对象后立即运行的方法。我们使用控制器类的构造函数来为该控制器的操作定义过滤器。还要注意，我们首先调用`parent::__construct()`方法。对于Laravel的`Controller`类来说，执行其构造函数非常重要，以便它可以初始化自身并准备好进行操作。
- en: Then, we tell our controller that for every request to one of its actions we
    want to run the before filter `auth`. Now, this controller is completely protected
    behind your authentication implementation. You will be unable to access the actions
    within this controller until you've successfully logged in. If you try to access
    one of the controller's actions, you will be redirected to the login page.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们告诉我们的控制器，对于其所有操作的每个请求，我们都希望运行`auth`之前的过滤器。现在，这个控制器完全受到您的身份验证实现的保护。在成功登录之前，您将无法访问该控制器中的操作。如果尝试访问控制器的操作之一，将被重定向到登录页面。
- en: Now, thanks to a combination of Laravel's `Auth` class and its `auth` filter,
    you now have a properly secured admin site.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于Laravel的`Auth`类和其`auth`过滤器的结合，您现在拥有一个完全安全的管理员网站。
- en: Unfortunately, a complete description of Laravel's filter functionality is outside
    the scope of this book. Thankfully, Laravel's documentation is a great resource
    for learning more about what you can do with filters.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Laravel过滤器功能的完整描述超出了本书的范围。幸运的是，Laravel的文档是了解有关过滤器更多信息的好资源。
- en: 4 – Validation
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4 - 验证
- en: Laravel provides a `Validator` class full of functionality to help with validating
    forms, database models, or anything that you'd like. The `Validator` class allows
    you to pass any input, declare your own rules, and define your own custom validation
    messages.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel提供了一个充满功能的`Validator`类，可帮助验证表单、数据库模型或其他任何内容。`Validator`类允许您传递任何输入，声明自己的规则，并定义自己的自定义验证消息。
- en: Let's take a look at an example implementation for our create users actions.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个为我们创建用户操作实现的示例。
- en: '[PRE80]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: First, we create an array that defines our validation rules. Validation rule
    arrays are key/value pairs. Each key represents the field name that it will be
    validating and each value is a string that contains the validation rules and their
    configurations. Validation rules are separated by the pipe character (`|`) and
    a validation rule's configuration parameters are separated from the name of the
    rule by a colon (`:`).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个定义验证规则的数组。验证规则数组是键值对。每个键代表它将验证的字段名称，每个值是一个包含验证规则及其配置的字符串。验证规则由管道字符（`|`）分隔，验证规则的配置参数与规则名称之间用冒号（`:`）分隔。
- en: The required rule ensures that input has been received for its fields. The `max`
    and `min` rules can ensure that strings are no longer or shorter than a specific
    length. The length for `min` and `max` are passed as parameters and are therefore
    separated from the rule name with a colon. In the `real_name` example, we're ensuring
    that it's no longer than 50 characters. We also want to ensure that the user's
    password is no less than five characters in length.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`required`规则确保已接收到其字段的输入。`max`和`min`规则可以确保字符串的长度不超过或不短于特定长度。`min`和`max`的长度作为参数传递，因此与规则名称用冒号分隔。在`real_name`的例子中，我们确保它不超过50个字符。我们还希望确保用户的密码长度不少于五个字符。'
- en: Since we're using e-mail for authentication, we should make sure that it's a
    unique address in our database. So, for our `email` field, we define the `unique`
    rule and tell it to compare it against other values in the `users` database table.
    If it finds another e-mail address that matches the address from our create users
    form, it will return an error.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用电子邮件进行身份验证，我们应该确保它在我们的数据库中是唯一的地址。因此，对于我们的“电子邮件”字段，我们定义了“唯一”规则，并告诉它与“users”数据库表中的其他值进行比较。如果它找到与我们创建用户表单中的地址匹配的另一个电子邮件地址，它将返回一个错误。
- en: Next, we create the validation object by using the `Validator::make()` method.
    We are providing the form's input as our first argument and our `$rules` array
    as the second.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`Validator::make()`方法创建验证对象。我们将表单的输入作为第一个参数，将我们的`$rules`数组作为第二个参数。
- en: We can now check to see if the validation passes by using the `$validation->passes()`
    method or if the validation fails by using the `$validation->fails()` method.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用`$validation->passes()`方法来检查验证是否通过，或者通过使用`$validation->fails()`方法来检查验证是否失败。
- en: In this example, if our validation fails, we redirect the user back to the form
    with the input data for repopulating the form as well as the error data from our
    `$validation` object. With this error data, we can populate our form with errors
    so that our user knows why our form didn't validate.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果我们的验证失败，我们将用户重定向回表单，并重新填充表单的输入数据以及来自我们的`$validation`对象的错误数据。有了这些错误数据，我们可以用错误填充我们的表单，这样我们的用户就知道我们的表单为什么没有验证通过。
- en: 'View objects have a special `$errors` variable that is typically empty. When
    a user is redirected back to another action `with_errors($validation)`, the special
    `$errors` variable is populated with the errors from the validation object. Let''s
    look at an example of how we can display an error for the `email` field:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 视图对象有一个特殊的`$errors`变量，通常为空。当用户被重定向到另一个动作`with_errors($validation)`时，特殊的`$errors`变量将填充来自验证对象的错误。让我们看一个如何显示“电子邮件”字段的错误的例子：
- en: '[PRE81]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here we're displaying the error message from the first validation rule that
    didn't pass on the `email` field. Our second argument is a formatting string.
    The error message will replace the :`message` symbol in the string. If the `email`
    field has no validation errors, none of the formatted string will be returned.
    This makes this algorithm ideal for creating forms with individual feedback per
    field.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们显示了未通过“电子邮件”字段的第一个验证规则的错误消息。我们的第二个参数是一个格式化字符串。错误消息将替换字符串中的:`message`符号。如果“电子邮件”字段没有验证错误，则不会返回任何格式化的字符串。这使得这个算法非常适合创建具有单独字段反馈的表单。
- en: A complete list of validation rules can be found in the Laravel documentation
    in your project at `http://myfirst.dev/docs`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在项目的`http://myfirst.dev/docs`中的Laravel文档中找到完整的验证规则列表。
- en: In a typical web application, validation occurs on both forms and data models.
    Form validation ensures that the data retrieved from the user meets certain criteria.
    Data model validation ensures that the data that is being inserted into the database
    is adequate, relationships are maintained, field uniqueness is maintained, and
    so on.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的Web应用程序中，验证发生在表单和数据模型上。表单验证确保从用户检索的数据符合某些标准。数据模型验证确保插入数据库的数据是充分的，维护了关系，维护了字段的唯一性等等。
- en: Our validation example functions. But, for brevity, we coded it directly inside
    of our controller. A more appropriate place to store form validation rules is
    within a model specific to that form. Likewise, a more appropriate place to store
    database model validation rules is within an Eloquent model.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的验证示例功能。但是，为了简洁起见，我们直接在控制器内部编写了它。存储表单验证规则的更合适的地方是在专门针对该表单的模型中。同样，存储数据库模型验证规则的更合适的地方是在Eloquent模型中。
- en: 5 – Bundles
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5 - 捆绑
- en: A major selling point for the Laravel framework is the way in which it handles
    modular code. Any functionality that can be written within Laravel can be bundled.
    Controllers, models, views, libraries, filters, config files, routing, and migrations
    can all be packaged as a bundle and either re-used by you and your team or distributed
    to be used by others. It may excite you to know that Laravel's application folder
    is considered to be its default bundle. That's right, all web-application code
    written with Laravel runs within a bundle.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel框架的一个主要卖点是它处理模块化代码的方式。在Laravel中可以编写的任何功能都可以捆绑。控制器、模型、视图、库、过滤器、配置文件、路由和迁移都可以打包为一个捆绑，并且可以由您和您的团队重新使用，或者分发给其他人使用。您可能会兴奋地知道，Laravel的应用程序文件夹被认为是其默认捆绑。没错，所有使用Laravel编写的Web应用程序代码都在一个捆绑中运行。
- en: As a result of bundles being a first-class citizen within Laravel, they are
    useful for a wide variety of applications. Bundles can be used to add something
    as simple as a vendor library or helper functions. Bundles are also often used
    to package up entire web-app subsystems. For example, it's very reasonable to
    be able to drop a blog bundle into your application, run migrations to create
    your blog database tables, and then have the URLs `http://myfirst.dev/blog` and
    `http://myfirst.dev/admin/blog` automatically start working. Bundles are amazingly
    powerful.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 由于捆绑在Laravel中是一等公民，它们对各种应用程序非常有用。捆绑可以用于添加简单的供应商库或辅助函数。捆绑也经常用于打包整个Web应用程序子系统。例如，很有可能将博客捆绑包放入您的应用程序中，运行迁移以创建博客数据库表，然后自动开始工作的URL
    `http://myfirst.dev/blog`和`http://myfirst.dev/admin/blog`。捆绑非常强大。
- en: 'Your application''s bundle configuration can be found in the `bundles.php`
    file that sits in the root directory of your Laravel installation. Let''s look
    at our web applications'' `bundles.php` file right now:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Laravel安装的根目录中的`bundles.php`文件中找到应用程序的捆绑配置。让我们现在看一下我们Web应用程序的`bundles.php`文件：
- en: '[PRE82]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Oh look here, we already have a bundle installed. The docs bundle contains the
    current version of the Laravel documentation. It's because the docs bundle handles
    the docs route that you can go to `http://myfirst.dev/docs` and view the Laravel
    documentation. You can comment out or remove the line that configures the docs
    bundle to prevent your users from accessing the `docs` route on your production
    site.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，看这里，我们已经安装了一个bundle。文档bundle包含了Laravel文档的当前版本。这是因为文档bundle处理了文档路由，所以您可以转到`http://myfirst.dev/docs`并查看Laravel文档。您可以注释或删除配置文档bundle的行，以防止用户在您的生产站点上访问`docs`路由。
- en: Laravel has a public online bundle repository, which can be found at [http://bundles.laravel.com](http://bundles.laravel.com).
    Users are free to create and add their own bundles to this repository. We can
    then install their bundles into our own application.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel有一个公共的在线bundle存储库，可以在[http://bundles.laravel.com](http://bundles.laravel.com)找到。用户可以自由地创建和添加他们自己的bundles到这个存储库。然后我们可以将他们的bundles安装到我们自己的应用程序中。
- en: There are a few ways in which you can install bundles.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以安装bundles。
- en: Installing bundles with Artisan is generally the preferred method to install
    bundles from the repository. Simply use Artisan's `bundle:install` task, and the
    bundle that you request will be downloaded from the Laravel bundle repository
    and installed into your bundles directory. Let's give this a shot.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Artisan安装bundles通常是从存储库安装bundles的首选方法。只需使用Artisan的`bundle:install`任务，您请求的bundle将从Laravel
    bundle存储库下载并安装到您的bundles目录中。让我们试试看。
- en: '[PRE83]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We told Artisan that we wanted to install the `swiftmailer` bundle from the
    bundle repository. It downloaded the bundle and now we have a directory `bundles/swiftmailer`,
    which contains the `swiftmailer` vendor library as well as the bundle's `start.php`
    file. `start.php` is the file responsible for loading the contents of the bundle
    and making it ready to be used; it is run when the bundle is first started.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉Artisan我们想要从bundle存储库安装`swiftmailer` bundle。它下载了bundle，现在我们有一个目录`bundles/swiftmailer`，其中包含`swiftmailer`供应商库以及bundle的`start.php`文件。`start.php`是负责加载bundle内容并使其准备好使用的文件；它在第一次启动bundle时运行。
- en: You could accomplish the same without Artisan. The bundle repository functions
    by using GitHub. Therefore, all bundles in the repository can be found on GitHub.
    You could easily go to [https://github.com/taylorotwell/swiftmailer](https://github.com/taylorotwell/swiftmailer)
    and download the code into your bundles directory. This accomplishes the same
    as doing it with Artisan with only a little more elbow-grease required.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在没有Artisan的情况下完成相同的操作。bundle存储库通过使用GitHub运行。因此，存储库中的所有bundles都可以在GitHub上找到。您可以轻松地转到[https://github.com/taylorotwell/swiftmailer](https://github.com/taylorotwell/swiftmailer)并将代码下载到您的bundles目录中。这与使用Artisan完成相同，只需要更多的努力。
- en: Once you've installed your bundle, you must add it to the bundle configuration
    file before it can be used. Let's add configuration for our `swiftmailer` bundle
    to our `bundles.php` file and look at the results.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完bundle后，必须将其添加到bundle配置文件中才能使用。让我们为我们的`swiftmailer` bundle添加配置到我们的`bundles.php`文件并查看结果。
- en: '[PRE84]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: It is unnecessary for us to add any additional configuration parameters in order
    to make our `swiftmailer` bundle work. Within our code we would simply run `Bundle::start('swiftmailer')`,
    and proceed to use it. Alternatively, if you wish to automatically start a bundle,
    you can simply add the autoconfiguration to your `bundles.php` file.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要添加任何额外的配置参数来使我们的`swiftmailer` bundle工作。在我们的代码中，我们只需运行`Bundle::start('swiftmailer')`，然后开始使用它。或者，如果您希望自动启动一个bundle，您可以简单地将自动配置添加到您的`bundles.php`文件中。
- en: '[PRE85]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now, it's entirely unnecessary to start the bundle manually. It will be started
    automatically before your routed code is executed.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，手动启动bundle是完全不必要的。它将在路由代码执行之前自动启动。
- en: The core purpose behind the existence of bundles is code re-use. On the road
    to mastering Laravel, we recommend implementing new code first without bundles.
    Then, once you find a need to re-use that code, you may then prefer to bundle
    the code up and refactor it as necessary. This prevents you from being slowed
    down by both learning how bundles are put together and by implementing code for
    the first time in Laravel.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: bundles存在的核心目的是代码重用。在掌握Laravel的过程中，我们建议首先在没有bundles的情况下实现新代码。然后，一旦您发现需要重用该代码，您可能会更喜欢将代码捆绑起来并根据需要进行重构。这可以防止您在学习bundles如何组合以及在Laravel中首次实施代码时被拖慢。
- en: After you have gained the experience of making a few bundles, you'll find that
    they're very easy to design. Until you gain this experience, you may find that
    you're burning through precious development hours refactoring your code.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得制作几个bundles的经验后，您会发现它们非常容易设计。在获得这种经验之前，您可能会发现自己在重构代码时消耗了宝贵的开发时间。
- en: You're now aware of all of the most fundamental components of developing with
    Laravel. As you continue gaining mastery, you'll discover more advanced features
    such as the Inversion of Control container, view composers, events, and much more.
    Laravel provides a unique platform in the world of PHP. You're given the chance
    to implement your own software architecture design without having to destructively
    modify the core to support it. We highly recommend that if you continue your education
    in design patterns as you are now working within a platform that truly supports
    the implementation of your own unique architectures.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经了解了使用Laravel开发的所有最基本的组件。随着您不断提高技能，您将发现更高级的功能，例如控制反转容器、视图组件、事件等。Laravel在PHP世界中提供了一个独特的平台。您有机会实现自己的软件架构设计，而无需破坏性地修改核心以支持它。我们强烈建议，如果您继续在设计模式方面继续教育，因为您现在正在一个真正支持实现自己独特架构的平台上工作。
- en: People and places you should get to know
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您应该认识的人和地方
- en: If you need help with Laravel, here are some people and places which will prove
    invaluable.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要帮助Laravel，以下是一些人和地方，它们将非常有价值。
- en: '**Official Homepage**: [http://laravel.com](http://laravel.com)'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**官方主页**：[http://laravel.com](http://laravel.com)'
- en: '**Official documentation**: [http://laravel.com/docs](http://laravel.com/docs)'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**官方文档**：[http://laravel.com/docs](http://laravel.com/docs)'
- en: '**Official API documentation**: [http://laravel.com/api](http://laravel.com/api)'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**官方API文档**：[http://laravel.com/api](http://laravel.com/api)'
- en: '**GitHub repository**: [https://github.com/laravel/laravel](https://github.com/laravel/laravel)'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub仓库**：[https://github.com/laravel/laravel](https://github.com/laravel/laravel)'
- en: Articles and tutorials
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文章和教程
- en: 'There are a number of people writing and recording tutorials and screencast
    series on using Laravel. Here are a few that will help you improve your game:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多人在撰写和录制关于使用Laravel的教程和视频系列。以下是一些可以帮助你提高水平的教程：
- en: '*nettuts* provides a number of Laravel tutorials in both their free and paid
    sections. They''re well-known for the quality of their presentations ([http://net.tutsplus.com/tag/laravel/](http://net.tutsplus.com/tag/laravel/)).'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*nettuts*在他们的免费和付费部分提供了许多关于Laravel的教程。他们以演示的质量而闻名（[http://net.tutsplus.com/tag/laravel/](http://net.tutsplus.com/tag/laravel/)）。'
- en: 'Laravel: Ins and Outs is a study group that has recently been started by the
    Laravel community containing valuable information that can''t be found anywhere
    else. Join us at [http://laravel.io](http://laravel.io) and follow us at [http://twitter.com/laravelio](http://twitter.com/laravelio).'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Laravel: Ins and Outs是最近由Laravel社区发起的一个学习小组，包含了无法在其他地方找到的宝贵信息。加入我们，访问[http://laravel.io](http://laravel.io)，并关注我们的Twitter账号[http://twitter.com/laravelio](http://twitter.com/laravelio)。'
- en: Jason Lewis, the author of *Feather Forums* and a long-time contributor to Laravel
    has created a good series of Laravel tutorials that includes a how-to guide for
    contributing to a GitHub project ([http://jasonlewis.me/blog/laravel-tutorials](http://jasonlewis.me/blog/laravel-tutorials)).
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Feather Forums*的作者和长期贡献者Jason Lewis创建了一系列很好的Laravel教程，其中包括了如何参与GitHub项目的指南（[http://jasonlewis.me/blog/laravel-tutorials](http://jasonlewis.me/blog/laravel-tutorials)）。'
- en: Matthew Machuga, a well-respected multi-disciplined developer, has some one-of-a-kind
    Laravel screencasts, which highlight test-driven development with Laravel ([http://matthewmachuga.com/screencasts](http://matthewmachuga.com/screencasts)).
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备受尊敬的多才多艺的开发者Matthew Machuga有一些独一无二的Laravel视频系列，重点介绍了使用Laravel进行测试驱动开发（[http://matthewmachuga.com/screencasts](http://matthewmachuga.com/screencasts)）。
- en: Dayle Rees has released a popular set of tutorials that cover many of Laravel's
    basics ([http://daylerees.com/category/laravel-tutorials/](http://daylerees.com/category/laravel-tutorials/)).
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dayle Rees发布了一套流行的教程，涵盖了许多Laravel的基础知识（[http://daylerees.com/category/laravel-tutorials/](http://daylerees.com/category/laravel-tutorials/)）。
- en: And finally, my own screencast series contains walkthroughs of Laravel's folder
    structure, explanations of security best-practices, and information about modeling
    forms ([http://heybigname.com/2012/03/12/a-walk-through-laravel-folder-structure/](http://heybigname.com/2012/03/12/a-walk-through-laravel-folder-structure/)).
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我的自己的视频系列包括Laravel文件夹结构的演示，安全最佳实践的解释，以及关于建模表单的信息（[http://heybigname.com/2012/03/12/a-walk-through-laravel-folder-structure/](http://heybigname.com/2012/03/12/a-walk-through-laravel-folder-structure/)）。
- en: Community
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社区
- en: Laravel has a fantastic community. Professional developers with years of experience
    contribute to the forums and offer their time to help others in the IRC channel.
    They're both great places to build familiarity with Laravel and great places to
    go to if you get stuck.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel有一个很棒的社区。具有多年经验的专业开发人员在论坛上贡献并在IRC频道上提供帮助。它们都是熟悉Laravel的好地方，也是你遇到问题时去的好地方。
- en: An important part of being a software development professional is exposing yourself
    to as many good solutions to as many problems as possible. The only way that this
    can be reasonably accomplished is by joining a community. By regularly reading
    forums and participating in an IRC channel, you'll be exposed to many new ideas
    than you could think of on your own.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件开发专业人员的重要部分是让自己接触尽可能多的好解决方案。唯一可以合理实现这一点的方法是加入一个社区。通过定期阅读论坛并参与IRC频道，你将接触到许多新的想法，这是你自己无法想到的。
- en: '*Laravel Forums*: [http://forums.laravel.com](http://forums.laravel.com)'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Laravel论坛*：[http://forums.laravel.com](http://forums.laravel.com)'
- en: '*Laravel IRC* (live chat): [http://laravel.com/irc](http://laravel.com/irc)'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Laravel IRC*（实时聊天）：[http://laravel.com/irc](http://laravel.com/irc)'
- en: Twitter
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Twitter
- en: Twitter is a great way to keep up with Laravel news—word travels fast over the
    wire. Here are a few accounts that you'll want to follow.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter是跟上Laravel新闻的好方法——信息在网络上传播得很快。以下是一些你会想要关注的账号。
- en: '*@taylorotwell*: He''s the one responsible for Laravel and is a major player
    in pushing PHP forward as a serious development platform'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*@taylorotwell*：他是Laravel的负责人，也是推动PHP成为严肃的开发平台的重要人物'
- en: '*@laravelphp*: The official Twitter account for Laravel'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*@laravelphp*：Laravel的官方Twitter账号'
- en: '*@laravelnews*: Catch the retweets of news about all aspects of Laravel from
    users around the world'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*@laravelnews*：转发来自世界各地用户关于Laravel各个方面的新闻'
