- en: Chapter 4. Consolidate Classes and Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。合并类和函数
- en: Now that we have an autoloader in place, we can begin to remove all the `include`
    calls that only load up class and function definitions. When we are done, the
    only remaining `include` calls will be those that are executing logic. This will
    make it easier to see which `include` calls are forming the logic paths in our
    legacy application, and which are merely providing definitions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个自动加载程序，我们可以开始删除所有只加载类和函数定义的`include`调用。完成后，剩下的唯一`include`调用将是执行逻辑的。这将使我们更容易看到哪些`include`调用正在形成我们遗留应用程序中的逻辑路径，哪些仅仅提供定义。
- en: We will start with a scenario where the codebase is structured relatively well.
    Afterwards, we will answer some questions related to layouts that are not so amenable
    to revision.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个代码库结构相对良好的场景开始。之后，我们将回答一些与不太适合修改的布局相关的问题。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the purposes of this chapter, we will use the term `include` to cover not
    just `include` but also `require`, `include_once`, and `require_once`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用术语`include`来覆盖不仅仅是`include`，还包括`require`、`include_once`和`require_once`。
- en: Consolidate Class Files
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并类文件
- en: 'First, we will consolidate all the application classes to our central directory
    location as determined in the previous chapter. Doing so will put them where our
    autoloader can find them. Here is the general process we will follow:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将所有应用程序类合并到我们在上一章确定的中心目录位置。这样做将使它们放在我们的自动加载程序可以找到它们的地方。以下是我们将遵循的一般流程：
- en: Find an `include` statement that pulls in a class definition file.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个`include`语句，用于引入一个类定义文件。
- en: Move that class definition file to our central class directory location, making
    sure that it is placed in a sub-path matching the PSR-0 rules.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该类定义文件移动到我们的中心类目录位置，确保它被放置在符合PSR-0规则的子路径中。
- en: In the original file *and in all other files in the codebase* where an `include`
    pulls in that class definition, remove that `include` statement.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在原始文件*和代码库中的所有其他文件*中，如果有一个`include`引入了该类定义，删除该`include`语句。
- en: Spot check to make sure that all the files now autoload that class by browsing
    to them or otherwise running them.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽查以确保所有文件现在都自动加载该类，通过浏览它们或以其他方式运行它们。
- en: Commit, push, and notify QA.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交、推送并通知QA。
- en: Repeat until there are no more `include` calls that pull in class definitions.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复直到没有更多引入类定义的`include`调用。
- en: 'For our examples, we will assume we have a legacy application with this partial
    file system layout:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们假设我们有一个遗留应用程序，其部分文件系统布局如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Your own legacy application may not match this exactly, but you get the idea.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你自己的遗留应用程序可能不完全匹配这个，但你明白了。
- en: Find a candidate include
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到一个候选包括
- en: 'We begin by picking a file, any file, then we examine it for `include` calls.
    The code therein might look like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先选择一个文件，任何文件，然后我们检查其中的`include`调用。其中的代码可能如下所示：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can see that there is a new `User` class being instantiated. On inspecting
    the `lib/sub/User.php` file, we can see it is the only class defined therein.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到有一个新的`User`类被实例化。在检查`lib/sub/User.php`文件时，我们可以看到它是其中唯一定义的类。
- en: Move the class file
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动类文件
- en: 'Having identified an `include` statement that loads a class definition, we
    now move that class definition file to the central class directory location so
    that our autoloader function can find it. The resulting file system layout now
    looks like this (note that `User.php` is now in `classes/`):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 已经确定了一个`include`语句，用于加载类定义，现在我们将该类定义文件移动到中心类目录位置，以便我们的自动加载程序函数可以找到它。现在的文件系统布局如下（请注意，`User.php`现在在`classes/`中）：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Remove the related include calls
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除相关的包括调用
- en: 'Now the problem is that our original file is trying to `include` the class
    file from its old location, a location that no longer exists. We need to remove
    that call from the code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在问题是，我们的原始文件试图从其旧位置`include`类文件，而这个位置已经不存在了。我们需要从代码中删除这个调用：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, there are likely to be other places where the code attempts to load
    the now-missing `lib/sub/User.php` file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码可能还有其他地方尝试加载现在已经缺失的`lib/sub/User.php`文件。
- en: This is where a project-wide search facility comes in handy. We have different
    options here, depending on your editor/IDE of choice and operating system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是项目范围搜索工具派上用场的地方。这里我们有不同的选择，取决于你选择的编辑器/IDE和操作系统。
- en: In GUI editors like TextMate, SublimeText, and PHPStorm, there is usually a
    **Find in Project** menu item that we can use to search for a string or regular
    expression across all the application files at once.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GUI编辑器中，如TextMate、SublimeText和PHPStorm，通常有一个**在项目中查找**的菜单项，我们可以用它来一次性搜索所有应用程序文件中的字符串或正则表达式。
- en: In other editors like Emacs and Vim, there is generally a key-binding that will
    search all the files in a particular directory and its subdirectories for a string
    or regular expression.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Emacs和Vim等其他编辑器中，通常有一个键绑定，可以搜索特定目录及其子目录中的所有文件，以查找字符串或正则表达式。
- en: Finally, if you are of the old school, you can use `grep` at the command line
    to search all the files in a particular directory and its subdirectories.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果你是老派的，你可以在命令行中使用`grep`来搜索特定目录及其子目录中的所有文件。
- en: 'The point is to find all the `include` calls that refer to `lib/sub/User.php`.
    Because the `include` calls can be formed in different ways, we need to use a
    regular expression like this to search for the `include` calls:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是找到所有引用`lib/sub/User.php`的`include`调用。因为`include`调用可以以不同的方式形成，我们需要使用这样的正则表达式来搜索`include`调用：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you are not familiar with regular expressions, here is a breakdown of what
    we are looking for:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉正则表达式，这里是我们要寻找的内容的分解：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: (Regular expressions use `.` to mean `any character` so we have to specify `User\.php`
    to indicate we mean a literal dot, not any character.)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: （正则表达式使用`.`表示`任何字符`，所以我们必须指定`User\.php`来表示我们指的是一个字面上的点，而不是任何字符。）
- en: 'If we use a regular expression search to find those strings in the legacy codebase,
    we will be presented with a list of all matching lines and their corresponding
    files. Unfortunately, it is up to us to examine each line to see if it really
    is a reference to the `lib/sub/User.php` file. For example, this line might turn
    up in the search results:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用正则表达式搜索来查找遗留代码库中的这些字符串，我们将得到所有匹配行及其对应的文件列表。不幸的是，我们需要检查每一行，看它是否真的是对`lib/sub/User.php`文件的引用。例如，这行可能会出现在搜索结果中：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, clearly it is not the `User.php` file we are looking for.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，显然我们不是在寻找`User.php`文件。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We could be more strict with our regular expression so that we search specifically
    for `lib/sub/User.php` but that is more likely to miss some `include` calls, especially
    those in files under the `lib/` or `sub/` directories. For example, an `include`
    in a file in `sub/` could look like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对我们的正则表达式更严格，这样我们就可以专门搜索`lib/sub/User.php`，但这更有可能错过一些`include`调用，特别是那些在`lib/`或`sub/`目录下的文件。例如，在`sub/`文件中的`include`可能是这样的：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As such, it's better to be a little loose with the search to get every possible
    candidate, then work through the results manually.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好宽松一点地搜索以获得每个可能的候选项，然后手动处理结果。
- en: Examine each search result line, and if it is an `include` that pulls in the
    `User` class, remove it and save the file. Keep a list of each modified file,
    as we will need to test them later.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 检查每个搜索结果行，如果是引入`User`类的`include`，则删除它并保存文件。保留每个修改后的文件的列表，因为我们以后需要对它们进行测试。
- en: At the end of this, we will have removed all the `include` calls for that class
    throughout the codebase.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将删除整个代码库中该类的所有`include`调用。
- en: Spot check the codebase
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽查代码库
- en: After removing the `include` statements for the given class, we now need to
    make sure the application works. Unfortunately, because we have no testing process
    in place, this means we need to pseudo-test or spot check by browsing to or otherwise
    invoking the modified files. In practice this is generally not difficult, but
    it is tedious.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除给定类的`include`语句之后，我们现在需要确保应用程序正常工作。不幸的是，因为我们没有建立测试流程，这意味着我们需要通过浏览或以其他方式调用修改后的文件来进行伪测试或抽查。实际上，这通常并不困难，但很繁琐。
- en: When we spot check we are looking specifically for *file not found* and *class
    not defined* errors. These mean, respectively, that a file tried to `include`
    the missing class file, or that the autoloader failed to find the class file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行抽查时，我们特别寻找*文件未找到*和*类未定义*错误。这意味着分别尝试`include`缺失的类文件，或者自动加载程序无法找到类文件。
- en: To do the testing we need to set PHP error reporting so that it either shows
    us the errors directly, or logs the errors to a file that we examine while testing
    the codebase. In addition, the error reporting level needs to be sufficiently
    strict that we actually see the errors. In general, `error_reporting(E_ALL)` is
    what we want, but because this is a legacy codebase, it may show more errors than
    we can bear (especially *variable not defined* notices). As such, it may be more
    productive to set `error_reporting(E_WARNING)`. The error reporting values can
    be set either in a setup or bootstrap file, or in the correct `php.ini` file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行测试，我们需要设置PHP错误报告，以便直接显示错误，或将错误记录到我们在测试代码库时检查的文件中。此外，错误报告级别需要足够严格，以便我们实际上看到错误。一般来说，`error_reporting(E_ALL)`是我们想要的，但因为这是一个遗留的代码库，它可能显示比我们能忍受的更多的错误（特别是*变量未定义*通知）。因此，将`error_reporting(E_WARNING)`设置为更有成效。错误报告值可以在设置或引导文件中设置，也可以在正确的`php.ini`文件中设置。
- en: Commit, Push, Notify QA
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交、推送、通知QA
- en: After the testing is complete and all errors have been fixed, commit the code
    to source control and (if needed) push it to the central code repository. If you
    have a QA team, now would be the time to notify them that a new testing round
    is needed, and provide them the list of files to test.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成并修复所有错误后，将代码提交到源代码控制，并（如果需要）将其推送到中央代码存储库。如果您有一个质量保证团队，现在是通知他们需要进行新一轮测试并提供测试文件列表的时候了。
- en: Do ... While
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做...直到
- en: That is the process to convert a single class from `include` to autoloading.
    Go back through the codebase and find the next `include` that pulls in a class
    file and begin the process again. Continue doing so until all classes have been
    consolidated into the central class directory location and their relevant `include`
    lines have been removed. Yes, this is a tedious, tiresome, and time-consuming
    process, but it is a necessary step towards modernizing our legacy codebase.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将单个类从`include`转换为自动加载的过程。回顾代码库，找到下一个`include`引入类文件并重新开始该过程。一直持续下去，直到所有类都已合并到中央类目录位置，并且相关的`include`行已被删除。是的，这是一个乏味、繁琐和耗时的过程，但这是现代化我们遗留代码库的必要步骤。
- en: Consolidate functions into class files
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数合并到类文件中
- en: Not all legacy applications use a large set of classes. Often, instead of classes,
    there is a significant number of user-defined functions for core logic.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的遗留应用程序都使用大量的类。通常，除了类之外，还有大量用户定义的核心逻辑函数。
- en: Using functions is not a problem in itself, but it does mean that we need to
    `include` the files where the functions are defined. But autoloading only works
    for classes. It would be good to find a way to automatically load the function
    files as well as the class files. That would help us remove even more `include`
    calls.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数本身并不是问题，但这意味着我们需要`include`定义函数的文件。但自动加载只适用于类。找到一种方法自动加载函数文件以及类文件将是有益的。这将帮助我们删除更多的`include`调用。
- en: The solution here is to move the functions into class files, and call the functions
    as static methods on those classes. That way, the autoloader can load up the class
    file for us, and then we can call the methods in that class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的解决方案是将函数移到类文件中，并在这些类上调用函数作为静态方法。这样，自动加载程序可以为我们加载类文件，然后我们可以调用该类中的方法。
- en: 'This procedure is more complex than when we consolidated class files. Here
    is the general process we will follow:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程比我们合并类文件时更复杂。以下是我们将遵循的一般流程：
- en: Find an `include` statement that pulls in a function definition file.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个`include`语句，引入一个函数定义文件。
- en: Convert that function definition file into a class file of static methods; we
    need to pick a unique name for the class, and we may need to rename the functions
    to more suitable method names.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该函数定义文件转换为一组静态方法的类文件；我们需要为该类选择一个唯一的名称，并且可能需要将函数重命名为更合适的方法名称。
- en: In the original file *and in all other files in the codebase* where any functions
    from that file are used, change calls to those functions into static method calls.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在原始文件*和代码库中的所有其他文件*中，如果使用了该文件中的任何函数，将这些函数的调用更改为静态方法调用。
- en: Spot check to see if the new static method calls work by browsing to or otherwise
    invoking the affected files.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过浏览或以其他方式调用受影响的文件来检查新的静态方法调用是否有效。
- en: Move the class file to the central class directory location.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类文件移动到中央类目录位置。
- en: In the original file *and in all other files in the codebase* where an `include`
    pulls in that class definition, remove the relevant `include` statement.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在原始文件*和代码库中的所有其他文件*中，如果有`include`引入该类定义，删除相关的`include`语句。
- en: Spot check again to make sure that all the files now autoload that class by
    browsing to them or otherwise running them.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次进行抽查，确保所有文件现在都通过自动加载该类来浏览或运行它们。
- en: Commit, push, and notify QA.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交、推送并通知QA。
- en: Repeat until there are no more `include` calls that pull in function definition
    files.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复，直到没有更多的`include`调用引入函数定义文件。
- en: Find a candidate include
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找一个包括候选者
- en: 'We pick a file, any file, and look through it for `include` calls. The code
    in our chosen file might look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择一个文件，任何文件，并查找其中的`include`调用。我们选择的文件中的代码可能如下所示：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see that there is a `db_query()` function being used, and on inspecting
    the `includes/db_functions.php` file, we can see that function along with several
    others defined therein.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到有一个`db_query()`函数被使用，并且在检查`includes/db_functions.php`文件时，我们可以看到其中定义了该函数以及其他几个函数。
- en: Convert the function file to a class file
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将函数文件转换为类文件
- en: 'Let''s say that the `db_functions.php` file looks something like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`db_functions.php`文件看起来像这样：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To convert this function file to a class file, we need to pick a unique name
    for the class we're about to create. It seems pretty clear in this case, both
    from the file name and from the function names, that these are all database-related
    calls. As such, we'll call this class Db.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此函数文件转换为类文件，我们需要为即将创建的类选择一个唯一的名称。在这种情况下，从文件名和函数名称来看，这似乎很明显，这些都是与数据库相关的调用。因此，我们将称这个类为Db。
- en: Now that we have a name, we'll create the class. The functions will become static
    methods in the class. We are not going to move the file just yet; leave it in
    place with its current file name.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个名称，我们将创建这个类。这些函数将成为类中的静态方法。我们暂时不会移动文件；将其保留在当前文件名的位置。
- en: 'Then we make our changes to convert the file to a class definition. If we change
    function names, we need to keep a list of old and the new names for later use.
    After the changes, it will look something like the following (note the changed
    method names):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们进行更改，将文件转换为类定义。如果我们更改函数名称，我们需要保留旧名称和新名称的列表以供以后使用。更改后，它将看起来像下面这样（注意更改后的方法名称）：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The changes are very moderate: we wrapped the functions in a unique class name,
    marked them as `public static`, and made minor changes to the function names.
    We made no changes at all to the function signatures or code in the functions
    themselves.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 更改非常温和：我们将函数包装在一个唯一的类名中，标记为`public static`，并对函数名称进行了轻微更改。我们对函数签名或函数本身的代码没有做任何更改。
- en: Change function calls to static method calls
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将函数调用更改为静态方法调用
- en: We have converted the contents of `db_functions.php` from function definitions
    to a class definition. If we try to run the application now, it will fail with
    "undefined function" errors. So, the next step is to find all of the relevant
    function calls throughout the application and rename them to static method calls
    on our new class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`db_functions.php`的内容从函数定义转换为类定义。如果我们现在尝试运行应用程序，它将因为"未定义的函数"错误而失败。因此，下一步是找到应用程序中所有相关的函数调用，并将它们重命名为我们新类的静态方法调用。
- en: 'There is no easy way to do this. This is another case where project-wide search-and-replace
    becomes very handy. Using our preferred project-wide search tool, search for the
    `old` function call, and replace it with the `new` static method call. For example,
    using a regular expression, we might do this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 没有简单的方法可以做到这一点。这是另一种情况，项目范围的搜索和替换非常方便。使用我们首选的项目范围搜索工具，搜索`old`函数调用，并将其替换为`new`静态方法调用。例如，使用正则表达式，我们可能会这样做：
- en: 'Search for:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Replace with:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 替换为：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The regular expression indicates the opening parenthesis, not the closing one,
    as we don't need to look for parameters in the function call. This helps to distinguish
    from function names that might be prefixed with the function name we're searching
    for, such as `db_query_raw()`. The regular expression also allows for optional
    whitespace between the function name and the opening parenthesis, since some style
    guides recommend such spacing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式表示的是开括号，而不是闭括号，因为我们不需要在函数调用中查找参数。这有助于区分可能以我们正在搜索的函数名为前缀的函数名称，例如`db_query_raw()`。正则表达式还允许在函数名和开括号之间有可选的空格，因为一些样式指南建议这样的间距。
- en: Perform this search-and-replace for each of the `old` function names in the
    old function file, converting each to the `new` static method call in the new
    class file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对旧函数文件中的每个`old`函数名称执行此搜索和替换，将每个函数转换为新类文件中的`new`静态方法调用。
- en: Spot check the static method calls
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查静态方法调用
- en: When we are finished renaming the old function names to the new static method
    calls, we need to run through the codebase to make sure everything works. Again,
    there is no easy way to do this. You may need to go so far as browsing to, or
    otherwise invoking, each file that was changed in this process.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成将旧的函数名称重命名为新的静态方法调用后，我们需要遍历代码库以确保一切正常。同样，这并不容易。你可能需要浏览或以其他方式调用在这个过程中被更改的每个文件。
- en: Move the class file
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动类文件
- en: At this point we have replaced the contents of the function definition file
    with a class definition, and "testing" has showed that the new static method calls
    work as expected. Now we need to move the file to our central class directory
    location and name it properly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经用类定义替换了函数定义文件的内容，并且“测试”表明新的静态方法调用按预期工作。现在我们需要将文件移动到我们的中央类目录位置，并正确命名。
- en: 'Currently, our class definition is in the `includes/db_functions.php` file.
    The class in that file is named `Db`, so move the file to its new autoloadable
    location as `classes/Db.php`. Afterwards, the file system will look something
    like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的类定义在`includes/db_functions.php`文件中。该文件中的类名为`Db`，所以将文件移动到其新的可自动加载位置`classes/Db.php`。之后，文件系统将看起来像这样：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Do ... While
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做...直到
- en: 'Finally, we follow the same ending process as we did when moving class files:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们遵循与移动类文件相同的结束过程：
- en: Remove the related `include` calls for the function definition file throughout
    the codebase
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整个代码库中删除与函数定义文件相关的`include`调用
- en: Spot check the codebase
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽查代码库
- en: Commit, push, notify QA
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交，推送，通知QA
- en: Now repeat it for every function definition file we find in the codebase.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对我们在代码库中找到的每个函数定义文件重复这个过程。
- en: Common Questions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: Should we remove the autoloader include call?
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们应该删除自动加载器的include调用吗？
- en: If we placed our autoloader code in a class as a static or instance method,
    our search for `include` calls will reveal the inclusion of that class file. If
    you remove that `include` call, autoloading will fail, because the class file
    will not have been loaded. This is a chicken-and-egg problem. The solution is
    to leave the autoloader `include` in place as part of our bootstrapping or setup
    code. If we are fully diligent about removing `include` calls, that is likely
    to be the only `include` remaining in the codebase.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将我们的自动加载器代码放在一个类中作为静态或实例方法，我们搜索`include`调用将会显示该类文件的包含。如果你移除了那个`include`调用，自动加载将会失败，因为类文件没有被加载。这是一个鸡生蛋蛋生鸡的问题。解决方法是将自动加载器的`include`保留在我们的引导或设置代码中。如果我们完全勤奋地删除`include`调用，那很可能是代码库中唯一剩下的`include`。
- en: How should we pick files for candidate include calls?
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们应该如何选择候选的include调用文件？
- en: 'There are several ways to go about this. We could do the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题。我们可以这样做：
- en: We can manually traverse the entire codebase and work file-by-file.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以手动遍历整个代码库，逐个文件处理。
- en: We can generate a list of class and function definition files, and then generate
    a list of files that `include` those files.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以生成一个类和函数定义文件的列表，然后生成一个`include`这些文件的文件列表。
- en: We can search for every `include` call and look at the related file to see if
    it has class or function definitions.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以搜索每个`include`调用，并查看相关文件是否有类或函数定义。
- en: What if an include defines more than one class?
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果一个include定义了多个类？
- en: Sometime a class definition file may have more than one class definition in
    it. This can mess with the autoloading process. If a file named `Foo.php` defines
    both `Foo` and `Bar` classes, then the `Bar` class will never be autoloaded, because
    the file name is wrong.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有时一个类定义文件可能有多个类定义。这可能会影响自动加载过程。如果一个名为`Foo.php`的文件定义了`Foo`和`Bar`类，那么`Bar`类将永远不会被自动加载，因为文件名是错误的。
- en: The solution is to split the single file into multiple files. That is, create
    one file per class, and name each file for the class it contains per the PSR-0
    naming and autoloading expectations.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是将单个文件拆分成多个文件。也就是说，为每个类创建一个文件，并根据PSR-0命名和自动加载期望命名每个文件。
- en: What if the one-class-per-file rule is disagreeable?
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果每个文件一个类的规则是令人不快的呢？
- en: 'I sometimes hear complaints about how the one-class-per-file rules is somehow
    wasteful or otherwise not aesthetically pleasing when examining the file system.
    Isn''t it a drag on performance to load that many files? What if some classes
    are only needed along with some other class, such as an `Exception` that is only
    used in one place? I have some responses here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我会听到关于每个文件一个类的规则在检查文件系统时有些浪费或者在审美上不够美观的抱怨。加载那么多文件会影响性能吗？如果有些类只有在某些其他类的情况下才需要，比如只在一个地方使用的`Exception`类呢？我有一些回应：
- en: There is, of course, a performance reduction in loading two files instead of
    one. The question is *how much* of a reduction, and *compared to what*? I assert
    that, compared to the other more likely performance issues in our legacy application,
    the drag from loading multiple files is a rounding error. It is more likely that
    we have other, far greater performance concerns. If it really is a problem, using
    a bytecode cache like APC will reduce or completely remove these comparatively
    small performance hits.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，加载两个文件而不是一个会减少性能。问题是*减少了多少*，*与什么相比*？我断言，与我们遗留应用程序中其他更可能的性能问题相比，加载多个文件所带来的影响微乎其微。更有可能的是我们有其他更大的性能问题。如果这真的是一个问题，使用像APC这样的字节码缓存将减少或完全消除这些相对较小的性能损失。
- en: Consistency, consistency, consistency. If some of the time a class file has
    only one class in it, and at other times a class file has more than one class
    in it, that inconsistency will later become a source of cognitive friction for
    everyone on the project. One of the main themes through legacy applications is
    that of inconsistency; let us reduce that inconsistency as much as we can by adhering
    to the one-class-per-file rule.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性，一致性，一致性。如果有时一个类文件中只有一个类，而其他时候一个类文件中有多个类，这种不一致性将在项目中的所有人中后来成为认知摩擦的源头。遗留应用程序中的一个主要主题就是不一致性；让我们通过遵守每个文件一个类的规则来尽可能减少这种不一致性。
- en: If we feel that some classes naturally belong together, it is perfectly acceptable
    to place the subordinate or child classes in a subdirectory beneath the master
    or parent class. The subdirectory should be named for that higher class or namespace,
    per the PSR-0 naming rules.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们觉得某些类自然地属于一起，将从属或子类放在主或父类的子目录中是完全可以接受的。子目录应该根据PSR-0命名规则以更高的类或命名空间命名。
- en: 'For example, if we have a series of `Exception` classes related to a `Foo`
    class:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一系列与`Foo`类相关的`Exception`类：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Renaming classes in this way will change the related class names throughout
    the codebase where they are instantiated or otherwise referenced.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式重命名类将改变代码库中实例化或引用它们的相关类名。
- en: What if a Class or Function is defined inline?
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果一个类或函数是内联定义的呢？
- en: I have seen cases where a page script has one or more classes or functions defined
    inside it, generally when the classes or functions are used only by that particular
    page script.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过页面脚本中定义一个或多个类或函数的情况，通常是当这些类或函数只被特定页面脚本使用时。
- en: In these cases, remove the class definitions from the script and place them
    in their own files in the central class directory location. Be sure to name the
    files for their class names per the PSR-0 autoloader rules. Similarly, move the
    function definitions to their own related class file as static methods, and rename
    the function calls to static method calls.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，从脚本中删除类定义，并将其放在中央类目录位置的单独文件中。确保根据PSR-0自动加载规则为它们的类名命名文件。同样，将函数定义移动到它们自己的相关类文件中作为静态方法，并将函数调用重命名为静态方法调用。
- en: What if a definition file also executes logic?
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果一个定义文件也执行逻辑会怎么样？
- en: 'I have also seen the opposite case, where a class file has some logic that
    gets executed as a result of the file being loaded. For example, a class definition
    file might look like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我也见过相反的情况，即类文件中有一些逻辑会在文件加载时执行。例如，一个类定义文件可能如下所示：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the above case, the logic before the class definition will be executed when
    the file is loaded, even if the class is never instantiated or otherwise called.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，即使类从未被实例化或以其他方式调用，类定义之前的逻辑也将在文件加载时执行。
- en: This is a much tougher situation to deal with than when classes are defined
    inline with a page script. The class should be loadable without side effects,
    and the other logic should be executable without having to load the class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况比在页面脚本中内联定义类要难处理得多。类应该可以在不产生副作用的情况下加载，其他逻辑也应该可以执行，而不必加载类。
- en: In general, the easiest way to deal with this is to modify our relocation process.
    Cut the class definition from the original file and place it in its own file in
    the central class directory location. Leave the original file with its executable
    code in place, and leave all the related `include` calls in place as well. This
    allows us to pull out the class definition so it can be autoloaded, but scripts
    that `include` the original file still get the executable behavior.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，处理这种情况最简单的方法是修改我们的重定位过程。从原始文件中剪切类定义，并将其放在中央类目录位置的单独文件中。保留原始文件及其可执行代码，并保留所有相关的`include`调用。这样我们就可以提取类定义，以便自动加载，但是`include`原始文件的脚本仍然可以获得可执行的行为。
- en: 'For example, given the above combined executable code and class definition,
    we could end up with these two files:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定上述组合的可执行代码和类定义，我们可能会得到这两个文件：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is messy, but it preserves the existing application behavior while allowing
    for autoloading.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这很混乱，但它保留了现有的应用行为，同时也允许自动加载。
- en: What if two classes have the same name?
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果两个类有相同的名称会怎么样？
- en: When we start moving classes around, we may discover that `application flow
    A` uses a `Foo` class, and that `application flow B` also uses a `Foo` class,
    but the two classes of the same name are actually different classes defined in
    different files. They never conflict with each other because the two different
    application flows never intersect.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始移动类时，我们可能会发现`应用流A`使用`Foo`类，而`应用流B`也使用`Foo`类，但是同名的两个类实际上是在不同文件中定义的不同类。它们永远不会发生冲突，因为这两个不同的应用流永远不会交叉。
- en: In this case, we have to rename one or both of the classes when we move them
    to our central class directory location. For example, call one of them `FooOne`
    and the other `FooTwo`, or pick better descriptive names of your own. Place them
    each in separate class files named for their class names, per the PSR-0 autoloading
    rules, and rename all references to these classes throughout the codebase.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当我们将它们移动到中央类目录位置时，我们必须重命名一个或两个类。例如，将其中一个命名为`FooOne`，另一个命名为`FooTwo`，或者选择更好的描述性名称。将它们分别放在根据PSR-0自动加载规则命名的各自类名的单独类文件中，并在整个代码库中重命名对这些类的所有引用。
- en: What about third-party libraries?
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方库呢？
- en: When we consolidate our classes and functions, we may find some third-party
    libraries in the legacy application. We don't want to move or rename the classes
    and functions in a third-party library, because that would make it too difficult
    to upgrade the library later. We would have to remember what classes were moved
    where and which functions were renamed to what.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们合并我们的类和函数时，我们可能会在旧应用程序中找到一些第三方库。我们不想移动或重命名第三方库中的类和函数，因为这样会使以后升级库变得太困难。我们将不得不记住哪些类被移动到哪里，哪些函数被重命名为什么。
- en: With any luck, the third-party library uses autoloading of some sort already.
    If it comes with its own autoloader, we can add that autoloader to the SPL autoloader
    registry stack in our setup or bootstrap code. If its autoloading is managed by
    another autoloader system, such as that found in Composer, we can add *that* autoloader
    to the SPL autoloader registry stack, again in our setup or bootstrap code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 带着一些运气，第三方库已经使用了某种自动加载。如果它带有自己的自动加载器，我们可以将该自动加载器添加到SPL自动加载器注册表堆栈中，放在我们的设置或引导代码中。如果它的自动加载由另一个自动加载器系统管理，比如Composer中的自动加载器，我们可以将*那个*自动加载器添加到SPL自动加载器注册表堆栈中，同样是在我们的设置或引导代码中。
- en: 'If the third-party library does not use autoloading, and depends on `include`
    calls both in its own code and in the legacy application, we are in a bit of a
    bind. We don''t want to modify the code in the library, but at the same time we
    want to remove `include` calls from the legacy application. The two solutions
    here are *least-worst* options:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第三方库不使用自动加载，并且在其自身代码和旧应用程序中都依赖于`include`调用，我们就有点为难了。我们不想修改库中的代码，但同时又想从旧应用程序中删除`include`调用。这里的两个解决方案都是*最不坏*的选择：
- en: Modify our application's main autoloader to allow for one or more third party
    libraries
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改我们应用程序的主自动加载器，以允许一个或多个第三方库
- en: Write an additional autoloader for the third-party library and add it to the
    SPL autoloader registry stack.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为第三方库编写额外的自动加载器，并将其添加到SPL自动加载器注册表堆栈中。
- en: Both of these options are beyond the scope of this book. You will need to examine
    the library in question, determine its class naming scheme, and come up with appropriate
    autoloader code on your own.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项都超出了本书的范围。您需要检查相关的库，确定其类命名方案，并自行编写适当的自动加载器代码。
- en: Finally, in terms of how to organize third-party libraries in the legacy application,
    it might be wise to consolidate them all to their own central location in the
    codebase. For example, this might be under a directory called `3rdparty/` or `external_libs/`.
    If we move a library, we should move the entire package, not just its class files,
    so we can upgrade it properly later. This will also allow us to exclude the central
    third-party directory from our search for `include` calls so that we don't get
    extra search results from files that we don't want to modify.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在如何组织旧应用程序中的第三方库方面，将它们全部整合到自己的中心位置可能是明智的选择。例如，这可能是在一个名为`3rdparty/`或`external_libs/`的目录下。如果我们移动一个库，我们应该移动整个包，而不仅仅是它的类文件，这样我们以后可以正确地升级它。这还将使我们能够从我们不想修改的文件中排除中心第三方目录，以免得到额外的`include`调用搜索结果。
- en: What about system-wide libraries?
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 那么系统范围的库呢？
- en: System-wide library collections, like those provided by Horde and PEAR, are
    a special case of third-party libraries. They are generally located on the server
    file system *outside* of the legacy application so they can be available to all
    applications running on that server. The `include` statements related to these
    system-wide libraries generally depend on the `include_path` settings, or else
    are referenced by absolute path.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 系统范围的库集合，比如Horde和PEAR提供的库，是第三方库的特例。它们通常位于服务器文件系统*外部*，以便可以供运行在该服务器上的所有应用程序使用。与这些系统范围库相关的`include`语句通常依赖于`include_path`设置，或者是通过绝对路径引用的。
- en: 'These present a special problem when trying to eliminate `include` calls that
    only pull in class and function definitions. If we are lucky enough to be using
    PEAR-installed libraries, we can modify our existing autoloader to look in two
    directories instead of one. This is because the PSR-0 naming conventions rise
    out of the Horde/PEAR conventions. The trailing autoloader code changes from this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当试图消除仅引入类和函数定义的`include`调用时，这些选项会带来特殊的问题。如果我们足够幸运地使用了PEAR安装的库，我们可以修改现有的自动加载器，使其在两个目录而不是一个目录中查找。这是因为PSR-0命名约定源自Horde/PEAR约定。尾随的自动加载器代码从这个：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 变成这样：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For functions, can we use instance methods instead of static methods?
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于函数，我们可以使用实例方法而不是静态方法吗？
- en: 'When we consolidated user-defined global functions into classes, we redefined
    them as static methods. This left their global scope unchanged. If we feel particularly
    diligent, we can change them from static to instance methods. This involves more
    work, but in the end it can make testing easier and is a cleaner technical approach.
    Given our earlier `Db` example, using instance instead of static methods would
    look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将用户定义的全局函数合并到类中时，我们将它们重新定义为静态方法。这并没有改变它们的全局范围。如果我们感到特别勤奋，我们可以将它们从静态方法更改为实例方法。这需要更多的工作，但最终可以使测试变得更容易，也是一种更清晰的技术方法。考虑到我们之前的`Db`示例，使用实例方法而不是静态方法会是这样的：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The only added step when using instance methods instead of static ones is that
    we need to instantiate the class before calling its methods. That is, instead
    of this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用实例方法而不是静态方法时，唯一增加的步骤是在调用其方法之前需要实例化该类。也就是说，不是这样：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We would do this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会这样做：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Even though it is more work in the beginning, I recommend instance methods over
    static ones. Among other things, it gives us a constructor method that can be
    called on instantiation, and it makes testing easier in many cases.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在开始时需要更多的工作，但我建议使用实例方法而不是静态方法。除其他外，这使我们可以在实例化时调用构造方法，并且在许多情况下使测试变得更容易。
- en: If you like, you may wish to start by converting to static methods, and then
    later convert the static methods to instance methods, along with all the related
    method calls. However, your schedule and preferences will dictate which approach
    you choose.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果愿意，您可以首先转换为静态方法，然后再将静态方法转换为实例方法，以及所有相关的方法调用。但是，您的时间表和偏好将决定您选择哪种方法。
- en: Can we automate this process?
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们能自动化这个过程吗？
- en: As I have noted before, this is a tedious, tiresome, and time-consuming process.
    Depending on the size of the codebase, it may take days or weeks of effort to
    fully consolidate the classes and functions for autoloading. It would be great
    if there was some way to automate the process to make it both faster and more
    reliable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所指出的，这是一个乏味、繁琐和耗时的过程。根据代码库的大小，可能需要数天或数周的努力才能完全合并类和函数以进行自动加载。如果有某种方法可以自动化这个过程，使其更快速和更可靠，那将是很好的。
- en: Unfortunately, I have not yet discovered any tools that make this process easier.
    As far as I can tell, this kind of refactoring is still best done by hand with
    strong attention to detail. Having obsessive tendencies and long periods of uninterrupted
    concentration on this task are likely to be of benefit here.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我还没有发现任何可以简化这个过程的工具。据我所知，这种重构最好还是通过细致的手工操作来完成。在这里，有强迫倾向和长时间的不间断专注可能会有所帮助。
- en: Review and next steps
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾和下一步
- en: At this point, we have made a big step forward in modernizing our legacy application.
    We have begun converting from an *include-oriented* architecture to a *class-oriented*
    one. Even if we later discover a class or function that we missed, that's OK;
    we can follow the above process as many times as needed until all definitions
    have been moved to the central location.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经在现代化我们的传统应用程序中迈出了一大步。我们已经开始从*包含导向*的架构转变为*类导向*的架构。即使以后发现了我们遗漏的类或函数，也没关系；我们可以根据需要多次遵循上述过程，直到所有定义都被移动到中央位置。
- en: We may still have lots of `include` statements in the application, but those
    that remain are related to the application flow, and not to pulling in class and
    function definitions. Any `include` calls that remain are executing logic. We
    can now see the flow of the application much better.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序中可能仍然有很多`include`语句，但剩下的那些与应用程序流程有关，而不是拉入类和函数定义。任何剩下的`include`调用都在执行逻辑。我们现在可以更好地看到应用程序的流程。
- en: We have put in place a structure for new functionality. Any time we need to
    add a new behavior, we can place it in a new class, and that class will be autoloaded
    whenever we need it. We can stop writing new stand-alone functions; instead, we
    will write new methods on classes. These new methods will be much more amenable
    to unit tests.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为新功能建立了一个结构。每当我们需要添加新的行为时，我们可以将其放入一个新的类中，该类将在我们需要时自动加载。我们可以停止编写新的独立函数；相反，我们将在类上编写新的方法。这些新方法将更容易进行单元测试。
- en: However, the *existing* classes that we have consolidated for autoloading are
    likely to have globals and other dependencies in them. This makes them tightly
    bound to each other and difficult to write tests for. With that in mind, the next
    step is to examine the dependencies in our existing classes, and attempt to break
    those dependencies to improve the maintainability of our application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们为自动加载而合并的*现有*类可能在其中具有全局变量和其他依赖关系。这使它们彼此紧密联系，并且很难为其编写测试。考虑到这一点，下一步是检查我们现有类中的依赖关系，并尝试打破这些依赖关系，以提高我们应用程序的可维护性。
