# 第七章：编写测试

此时，我们的遗留应用程序已经部分现代化，以至于我们所有现有的类都在一个中心位置。这些类现在使用依赖注入摆脱了`global`和`new`。现在应该为这些类编写测试，以便如果我们需要更改它们，我们知道它们的现有行为仍然完好无损。

# 对抗测试的抵抗

我们可能不急于现在花时间编写测试。我们不想失去我们正在感受到的前进动力。正当我们相信我们正在取得一些真正的进展时，停下来编写测试感觉就像是在做无用功。这会削弱我们对长期以来一直受苦的糟糕代码库进行一系列改进的乐趣。

对于不愿意编写测试的抵抗是可以理解的。我自己也是一个对自动化测试转变缓慢的人。如果一个人不习惯编写测试，那么编写测试的行为会感到陌生、不熟悉、具有挑战性和无效。很容易说，我可以看到代码是有效的，因为应用程序是有效的。

然而，如果我们不编写测试，我们就注定要在以后不断地遭受痛苦。我们正在使我们的遗留应用程序变得更糟：当我们更改应用程序的某一部分时，我们会感到恐惧，因为我们不知道更改会导致应用程序的其他部分出现什么问题。

因此，尽管编写测试可能很糟糕，但“已编写测试”也是很棒的。这很棒，因为当我们对类进行更改时，我们可以运行自动化测试套件，它会立即告诉我们在更改后是否有任何问题。

# 测试之道

即使我们已经熟悉编写测试，围绕测试的所有戒律也可能令人生畏：

+   不要与文件系统交互；而是构建一个虚拟文件系统。

+   不要与数据库交互；而是构建一组数据夹具。

+   重写你的类，使用接口而不是具体类，并为所有依赖项编写测试替身。

这些都是使测试看起来像是一个不可逾越的挑战的教条命令。当其他事情都做完时，当然我们可以稍后再构建我们的测试！问题是，永远不会有一刻是其他事情都做完了，因此测试永远不会出现。

作为对测试戒律的解药，我建议遵循*测试之道*（[`www.artima.com/weblogs/viewpost.jsp?thread=203994`](http://www.artima.com/weblogs/viewpost.jsp?thread=203994)）。*测试之道*的核心信息是更多的测试因果报应，少一些测试戒律。

这些是我们需要从*测试之道*中了解的关于现代化我们的遗留应用程序的主要观点：

+   测试的最佳时机是在代码刚写好的时候。

+   编写需要编写的测试。

+   今天的不完美测试比将来某一天的完美测试更好。

+   今天写你能写的测试。

类中的代码已经陈旧。毕竟，那些代码是遗留应用程序的一部分。但是现在，我们已经花了很多时间重新组织类，并使用依赖注入来替换它们的`global`和`new`关键字，这些类中的代码在我们的思想中又变得新鲜起来。现在是写这些类的测试的时候了，因为它们的操作仍然在最近的记忆中。

我们不应该被困扰于编写符合测试戒律的适当单元测试。相反，我们应该尽力编写最好的测试，即使测试不完美：

+   如果我们可以编写一个表征测试，只检查输出如何，那么我们应该这样做。

+   如果我们可以编写与数据库、网络或文件系统交互的功能或集成测试，那么我们应该这样做。

+   如果我们可以编写一个松散的单元测试，结合具体类，那么我们应该这样做。

+   如果我们可以编写严格的单元测试，使用测试替身完全隔离被测试的类，那么我们应该这样做。

随着我们在测试中变得更加熟练，一个不完美的测试可以得到完善。一个不存在的测试根本无法得到完善。

我们将尽可能快地编写我们可以编写的测试。等待编写测试只会增加反对编写测试的惯性。代码在我们的脑海中会变得更加陈旧，使得编写测试变得更加困难。今天编写测试将给我们一种成就感，并增加我们编写测试的惯性。

## 设置测试套件

本书的范围并不包括完全解释编写测试的技术和方法。相反，我们将简要总结设置自动化测试套件和编写简单测试所涉及的过程。有关 PHP 测试的更全面的处理，请参阅*The Grumpy Programmer's PHPUnit Cookbook*（[`grumpy-phpunit.com/`](http://grumpy-phpunit.com/)）by *Chris Hartjes*。

### 安装 PHPUnit

PHP 领域有许多不同的测试系统，但最常用的是 PHPUnit。我们需要在开发和测试服务器上安装 PHPUnit，以便编写和执行我们的测试。完整的安装说明在 PHPUnit 网站上。

通过 Composer 安装 PHPUnit 的一种简单方法是：

```php
**$ composer global require phpunit/phpunit=~4.5**

```

另一种方法是直接安装 PHPUnit 的`.phar`：

```php
**$ wget https://phar.phpunit.de/phpunit.phar**
**$ chmod +x phpunit.phar**
**$ sudo mv phpunit.phar /usr/local/bin/phpunit**

```

### 创建一个 tests/目录

安装 PHPUnit 后，我们需要在我们的遗留应用程序中创建一个`tests/`目录。名称和位置并不那么重要，重要的是目的和位置是明显的。最明显的地方可能是在遗留应用程序的根目录，尽管它不应该直接被浏览器访问。

在`tests/`目录中，我们需要创建一个以我们的中心类目录位置命名的子目录。如果我们所有的应用程序类都在一个名为`classes/`的目录中，那么我们应该有一个`tests/classes/`目录。我们的测试结构的想法是模仿我们的应用程序类的结构。

除了`tests/classes/`子目录之外，`tests/`目录还应包含两个文件。第一个是`bootstrap.php`文件，PHPUnit 在运行时将执行该文件。它的目的是帮助设置测试的执行环境。默认情况下，PHPUnit 不会使用应用程序的自动加载器代码，因此创建和注册自动加载器是`bootstrap.php`文件的经典用法。以下是一个使用之前章节中的自动加载器的示例：

```php
**tests/bootstrap.php**
1 <?php
2 require "../classes/Mlaphp/Autoloader.php";
3 $loader = new \Mlaphp\Autoloader;
4 spl_autoload_register(array($loader, 'load'));
5 ?>
```

还在`tests/`目录中，我们需要创建一个`phpunit.xml`文件。这告诉 PHPUnit 如何引导自己以及测试的位置：

```php
**tests/phpunit.xml**
1 <phpunit bootstrap="./bootstrap.php">
2 <testsuites>
3 <testsuite>
4 <directory>./classes</directory>
5 </testsuite>
6 </testsuites>
7 </phpunit>
```

创建`tests/`目录及其内容后，我们的遗留应用程序目录结构应该如下所示：

```php
**/path/to/app/**

```

```php
classes/        # our central class directory location
Auth.php        # class Auth { ... }
Db.php          # class Db { ... }
Mlaphp/
Autoloader.php  # A hypothetical autoloader class
Role.php        # class Role { ... }
User.php        # class User { ... }
foo/
bar/
baz.php         # a page script
includes/       # a common "includes" directory
setup.php       # setup code
index.php       # a page script
tests/          # tests directory
bootstrap.php   # phpunit bootstrap code
classes/        # test cases
phpunit.xml     # phpunit setup file
```

### 选择一个要测试的类

现在我们已经有了一个`tests/`目录，我们实际上可以为我们的应用程序类之一编写一个测试。开始的最简单方法是选择一个没有依赖项的类。此时，我们应该对代码库足够熟悉，以至于知道哪些类有依赖项，哪些没有。如果找不到没有依赖项的类，我们应该选择依赖项最少或依赖项最简单的类。

我们想要在这里*从小处着手*并取得一些早期的成功。每一次成功都会给我们继续进行更大、更复杂的测试的动力和动机。这些小的成功将累积成最终的大成功：一组经过全面测试的类。

### 编写一个测试用例

假设我们选择了一个名为`Foo`的类，它没有依赖项，并且有一个名为`doSomething()`的方法。现在我们将为这个类的方法编写一个测试。

首先，在我们的`tests/classes/`目录中创建一个骨架测试文件。它的位置应该模仿被测试的类的位置。我们在类名后面添加`Test`，并扩展`PHPUnitFramework_TestCase_`，以便我们可以访问测试类中的各种`assert*()`方法：

```php
**tests/classes/FooTest.php**
1 <?php
2 class FooTest extends \PHPUnit_Framework_TestCase
3 {
4 }
5 ?>
```

如果我们现在尝试用 `phpunit` 运行测试，测试将会失败，因为它里面没有测试方法：

```php
**tests $ phpunit**
**PHPUnit 3.7.30 by Sebastian Bergmann.**
**Configuration read from tests/phpunit.xml**
**F**
**Time: 45 ms, Memory: 2.75Mb**
**There was 1 failure:**
**1) Warning**
**No tests found in class "FooTest".**
**FAILURES!**
**Tests: 1, Assertions: 0, Failures: 1.**
**tests $**

```

信不信由你，这都没问题！正如《测试之道》所告诉我们的那样，我们在测试通过时感到高兴，测试失败时也同样如此。这里的失败告诉我们 PHPUnit 成功找到了我们的测试类，但在该类中没有找到任何测试。这告诉我们接下来该做什么。

下一步是为被测试类的公共方法添加一个测试方法。所有测试方法都以单词 `test` 开头，因此我们将使用名为 `testDoSomething()` 的方法来测试 `doSomething()` 方法。在其中，我们将创建一个 `_Foo_` 类的实例，调用它的公共 `doSomething()` 方法，并断言它的实际输出与我们期望的输出相同：

```php
**tests/classes/FooTest.php**
1 <?php
2 class FooTest extends \PHPUnit_Framework_TestCase
3 {
4 public function testDoSomething()
5 {
6 $foo = new Foo;
7 $expect = 'Did the thing!';
8 $actual = $foo->doSomething();
9 $this->assertSame($expect, $actual);
10 }
11 }
12 ?>
```

现在我们可以再次用 `phpunit` 运行我们的测试套件。只要 `doSomething()` 方法返回字符串 `Did the thing!`，我们的测试就会通过。

```php
**tests $ phpunit**
**PHPUnit 3.7.30 by Sebastian Bergmann.**
**Configuration read from tests/phpunit.xml**
**.**
**Time: 30 ms, Memory: 2.75Mb**
**OK (1 test, 1 assertion)**
**tests $**

```

我们为我们的测试通过而感到高兴！

如果 `doSomething()` 返回任何不同的东西，那么测试将会失败。这意味着如果我们在后续工作中更改了 `doSomething()`，我们将知道它的行为已经改变。我们会为它的失败感到高兴，知道我们在进入生产之前就捕捉到了一个 bug，然后修复代码，直到所有测试都通过。

### 做……当

在编写通过的测试后，我们将其提交到版本控制并推送到我们的中央仓库。我们继续为应用程序类中的每个公共方法编写测试，一边编写一边提交和推送。当应用程序类中的所有公共方法都有通过的测试时，我们选择另一个类进行测试，并从头开始一个新的测试类。

## 常见问题

### 我们可以跳过这一步，以后再做吗？

不。

### 真的吗，我们可以以后再做这个吗？

我明白。我真的明白。在我们现代化过程的这一点上，测试似乎没有回报。如果整个章节都没有说服你测试的好处，那么我现在也没什么别的可以说服你的了。如果你想跳过这一步，无论你在这里读到什么建议，你都会跳过它。

所以让我们假设我们在这一点上避免测试的理由是完全合理的，并且与我们特定的情境相适应。考虑到这一点，让我们看看如果现在做不到，那么在项目过程中我们可以做些什么来完成这些测试。继续下一章（不建议！），然后承诺执行以下一个或多个选项：

1.  每天至少完成一个新的测试类。

1.  每次在代码库中使用一个方法时，都要检查是否有针对它的测试。如果没有，就在使用该方法之前编写一个测试。

1.  在修复 bug 或构建功能时，创建一个在任务过程中使用的方法列表，然后在任务完成后为这些方法编写测试。

1.  当我们添加一个新的类方法时，为其编写相应的测试。

1.  将测试编写的工作委托给另一个开发人员，也许是一名初级开发人员。然后我们可以享受现代化的“乐趣”，而初级开发人员可以承担编写测试的看似无聊的工作，但要小心……很快，初级开发人员将比我们更了解代码库。

这些选项让我们能够建立一个测试套件，并且仍然感觉自己在其他方面取得了进展。创建一个自动化测试套件是现代化遗留应用程序的一个不可妥协的方面。现在就编写测试，或者在进行过程中编写，但尽早编写，而不是晚些时候。

### 那些难以测试的类怎么办？

即使依赖注入已经就位，遗留应用程序中的一些类仍然很难编写测试。类的测试可能会有很多难点，我无法在本书中充分解决这些问题。请参考以下作品：

+   *Michael Feathers*的*与遗留代码有效工作*。书中的示例都是用 Java 编写的，但情况与 PHP 中的情况类似。Feathers 展示了如何打破依赖关系，引入接缝，以及改进遗留类的可测试性。

+   Fowler 等人的重构。这本书也使用 Java 作为示例，但由于 Adam Culp 的贡献，我们将相同的示例转换为了 PHP。与 Fowler 的《企业应用架构模式》一样，重构书将为您提供一种词汇来描述您可能已经知道如何做的事情，同时还会向您介绍新的技术。

这些出版物中的信息将帮助我们改进我们的类的质量，而不改变类的行为。

### 我们之前的特性测试呢？

我们根据本章写的测试可能不是替代先决条件章节中现有特性测试的替代品。拥有两组测试很可能是一种祝福，而不是诅咒。在某个时候，特性测试可能会被转换为供 QA 团队使用的验收测试。在那之前，不妨偶尔运行两组测试。

### 我们应该测试私有和受保护的方法吗？

可能不会。这其中有一些教条主义的原因，我在这里不会详细说明，但简而言之：检查类的内部工作过于深入的测试会变得难以处理。

相反，我们应该只测试我们类的公共方法。这些方法暴露的任何行为可能是我们关心的唯一行为。这个规则有一些例外，但在我们的测试生涯的这个阶段，例外不如规则重要。

### 我们写完测试后可以更改测试吗？

有一天，我们需要改变应用程序类方法的现有行为。在这些情况下，修改相关的测试以适应新行为是可以的。但是，当我们这样做时，我们必须确保运行整个测试套件，而不仅仅是该应用程序类的测试。运行整个测试套件将帮助我们确保更改不会破坏其他类的行为。

### 我们需要测试第三方库吗？

如果我们的遗留应用程序使用第三方库，它们可能已经附带了测试。我们应该不时地运行这些测试。

如果第三方库没有附带测试，我们可能会根据我们的优先级选择编写一些测试。如果我们依赖于库在升级之间表现相同，编写一些我们自己的测试来确保预期的行为保持不变是明智的。

为第三方库构建测试可能很困难，如果它没有以易于测试的方式编写。如果该库是自由软件或开源软件，也许这是一个为项目做出贡献的机会。然而，我们的主要优先事项可能是我们自己的遗留应用程序，而不是第三方库。

### 代码覆盖率呢？

代码覆盖率是 PHPUnit 提供的报告，告诉我们测试了多少行代码。（严格来说，它告诉我们测试了多少语句）。

特定情况可能只测试类的一部分，或者方法的一部分，并留下一些未经测试的代码。被测试的部分称为代码的覆盖部分，而未经测试的部分称为未覆盖部分。

我们主要需要担心的是代码库中未覆盖的部分。如果未覆盖的代码发生任何变化，测试将无法检测到，因此我们可能会面临错误和其他退化。

如果可以的话，我们应该尽早并经常发现我们测试的代码覆盖率。这些覆盖率报告将帮助我们确定下一步需要测试什么，以及代码库的哪些部分需要重构，以便更容易测试。

更多的代码覆盖率是更好的。然而，达到 100%的行覆盖率可能是不可行的（而且实际上也不是最终目标，最终目标是 100%的条件/决策覆盖率等）。不过，如果我们能够达到 100%的覆盖率，那就应该努力去做。

关于这个话题的更多信息，请查阅 PHPUnit 关于代码覆盖率的文档[`phpunit.de/manual/3.7/en/code-coverage-analysis.html`](https://phpunit.de/manual/3.7/en/code-coverage-analysis.html)。

# 回顾和下一步

当我们完成了本章中简要概述的测试编写时，我们将为未来的错误创建了一个很好的陷阱。每当我们运行测试时，对预期行为的任何更改都会作为失败突出，以便我们进行更正。这确保了在我们继续重构时，我们对整个旧代码库所做的贡献将比伤害更多。

此外，因为我们现在有了一个可用的测试套件，我们可以为从旧代码库中提取出的任何新行为添加测试到我们的应用程序类中。每当我们创建一个新的应用程序类方法时，我们也会为该方法创建一个通过的测试。每当我们修改一个应用程序类方法时，我们将运行测试套件，以便在它们进入生产环境之前找到错误和破坏。当我们的测试通过时，我们会感到高兴，当它们失败时，我们也会感到高兴；每一种结果对于现代化我们的旧应用程序来说都是一个积极的迹象。

有了这个，我们可以继续我们的现代化进程。下一步是将数据检索和持久化行为从页面脚本中提取出来，放入一系列类中。通常，这意味着将所有的 SQL 调用移动到一个单独的层中。
