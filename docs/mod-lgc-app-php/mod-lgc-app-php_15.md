# 第十五章。删除页面脚本中的重复逻辑

现在，我们的页面脚本中的逻辑非常重复。它们看起来都非常相似。每个页面加载一个设置脚本，为页面控制器实例化一系列依赖项，调用该控制器，并发送响应。

我们的前端控制器为我们提供了一个地方，可以执行每个页面脚本的通用元素并消除重复。一旦重复被移除，我们就可以开始消除页面脚本本身。

# 重复的逻辑

实质上，我们的每个页面脚本都遵循这个组织流程：

```php
**Generic Page Script**
1 <?php
2 // one or more identical setup scripts
3 require 'setup.php';
4
5 // a series of dependencies to build a controller
6 $request = new \Mlaphp\Request($GLOBALS);
7 $response = new \Mlaphp\Response('/path/to/app/views');
8 $controller = new \Controller\PageName($request, $response);
9
10 // invoke the controller and send the response
11 $response = $controller->__invoke();
12 $response->send();
13 ?>
```

因为我们一直都很勤奋地使用相同的变量名来表示我们的控制器对象（`$controller`），始终使用相同的方法名来调用它（`__invoke()`），并且始终使用相同的变量名来表示响应（`$response`），我们可以看到每个页面脚本唯一不同的部分是中心部分。中心块构建了控制器对象。之前和之后的一切都是相同的。

此外，因为我们有一个前端控制器来处理所有传入的请求，现在我们有一个地方可以放置每个页面脚本的通用前后逻辑。这就是我们要做的。

## 移除过程

一般来说，移除过程如下：

1.  修改前端控制器以添加设置、控制器调用和响应发送。

1.  修改每个页面脚本以删除设置、控制器调用和响应发送。

1.  检查，提交，推送，并通知 QA。

## 修改前端控制器

首先，我们修改前端控制器逻辑，执行每个页面脚本通用的逻辑。我们将其从上一章中列出的代码更改为以下内容：

```php
**docroot/front.php**
1 <?php
2 // page script setup
3 require dirname(__DIR__) . '/includes/setup.php';
4
5 // set up the router
6 $pages_dir = dirname(__DIR__) . '/pages';
7 $router = new \Mlaphp\Router($pages_dir);
8
9 // match against the url path
10 $path = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
11 $route = $router->match($path);
12
13 // require the page script
14 require $route;
15
16 // invoke the controller and send the response
17 $response = $controller->__invoke();
18 $response->send();
19 ?>
```

我们已经用一个需要`Router`类文件的行替换了一个需要设置脚本的行。（在自动加载的章节中，我们将自动加载器放入了我们的设置脚本中，所以现在它应该为我们自动加载`Router`类。）

我们还在页面脚本中需要`$route`文件后添加了两行。这些行调用了控制器并设置了响应。我们在这个共享逻辑中使用了控制器和响应对象的通用变量名。（如果你在页面脚本中选择了除`$controller`和`$response`之外的其他变量名，也请在上面的脚本中替换它们。同样，如果你使用了除`__invoke()`之外的通用控制器方法，请也替换它。）

### 注意

请注意，设置工作将是特定于我们的旧应用程序。只要每个页面脚本的设置工作都是相同的（在这一点上应该是这样），将通用设置工作放在这里就可以了。

## 从页面脚本中删除逻辑

现在我们已经将设置、控制器调用和响应发送工作添加到前端控制器中，我们可以从每个页面脚本中删除相同的工作。这样做应该就像在`pages/`目录中进行项目范围的搜索并删除找到的行一样简单。

找到设置行可能需要使用正则表达式，因为设置脚本的相对位置可能导致使用相对目录遍历的行。以下正则表达式将找到`includes/setup.php`，`../includes/setup.php`，`dirname(__DIR__)` . `/includes/setup.php`等：

搜索设置：

```php
**1 ^\s*(require|require_once|include|include_once) .*includes/setup\.php.*$**

```

然而，找到控制器调用和响应发送行不应该需要使用正则表达式，因为它们在每个页面脚本中应该是相同的。

搜索控制器调用…

```php
**1 $response = $controller->__invoke();**

```

搜索响应发送…

```php
**1 $response->send();**

```

在每种情况下，删除找到的行。现在这些逻辑已经移动到前端控制器中，不再需要。

## 检查，提交，推送，并通知 QA

一旦重复的页面脚本逻辑被移除，我们可以通过运行特性测试或浏览或以其他方式调用应用程序中的每个页面来检查应用程序。

在确保应用程序仍然正常工作之后，我们提交新代码并将其推送到公共存储库。然后我们通知质量保证部门，我们有新的工作需要他们审查。

## 常见问题

### 如果设置工作不一致会怎么样？

在本书的示例中，我们只展示了一个脚本为每个页面脚本做设置工作。一些传统应用程序可能使用多个设置脚本。只要设置工作在每个页面脚本中是相同的，即使它由多个脚本组成，我们也可以将所有设置工作移动到前端控制器中。

然而，如果设置工作在每个页面脚本中不一致，我们就有问题要处理。如果在这一点上，页面脚本的设置过程不相同，我们应该在继续之前尽力解决这个问题。

在所有页面脚本中使设置工作相同是至关重要的。这可能意味着在前端控制器中包含所有页面脚本的不同设置工作，即使有些脚本不需要所有这些设置工作。如果必要，我们可以在下一章解决这种重叠。

如果我们无法强制执行相同的单阶段设置过程，我们可能需要进行双阶段或两阶段设置过程。首先，我们将常见的设置工作合并到前端控制器中，并将其从页面脚本中删除。多余的、特殊情况或特定页面的设置工作可以作为依赖项创建工作的退化但必要的部分留在页面脚本中。

### 如果我们使用了不一致的命名？

在前几章中，本书强调了一致命名的重要性。这一章是一致性得到回报的时刻。

如果我们发现在控制器对象变量和/或控制器方法名称的命名上不一致，也不是没有办法。我们可能无法进行一次性搜索和替换，但我们仍然可以手动处理每个页面脚本，并将名称更改为一致。然后前端控制器可以使用新的一致名称。

# 审查和下一步

通过这一步，我们将页面脚本减少到了一个基本的逻辑核心。现在它们所做的就是为控制器对象设置依赖项，然后创建控制器对象。前端控制器在此之前和之后都做了一切。

事实上，即使这个逻辑也可以从页面脚本中提取出来。一个称为依赖注入容器的对象可以接收对象创建逻辑作为一系列闭包，每个页面脚本一个闭包。容器可以为我们处理对象创建，我们可以完全删除页面脚本。

因此，我们最终的重构将把所有对象创建逻辑提取到一个依赖注入容器中。我们还将修改我们的前端控制器，实例化控制器对象，而不是要求页面脚本。这样做，我们将删除所有页面脚本，我们的应用程序将拥有一个完全现代化的架构。
