# 第八章：部署

在前几章中，您已经学会了如何基于微服务开发应用程序。现在，是时候学习如何部署您的应用程序，学习最佳的自动化策略和回滚应用程序的方法，以及在需要时进行备份和恢复。

# 依赖管理

正如我们在第五章中提到的，*微服务开发*，**Composer**是最常用的依赖管理工具；它可以帮助我们在部署过程中将项目从开发环境移动到生产环境。

关于部署过程的最佳工作流有不同的观点，因此让我们看一下每种情况的优缺点。

## Composer require-dev

Composer 在他们的`composer.json`中提供了一个名为`require-dev`的部分，用于在开发环境中使用，并且当我们需要在应用程序中安装一些不需要在生产环境中的库时，我们必须使用它。

正如我们已经知道的，使用 Composer 安装新库的命令是`composer require library-name`，但如果我们想安装新的库，比如测试库、调试库或者其他在生产环境下没有意义的库，我们可以使用`composer require-dev library-name`。它会将库添加到`require-dev`部分，当我们将项目部署到生产环境时，我们应该在执行`composer install --no-dev`或`composer update --no-dev`时使用`--no-dev`参数，以避免安装开发库。

## .gitignore 文件

通过`.gitignore`文件，可以忽略您不想跟踪的文件或文件夹。尽管 Git 是一个版本控制工具，但许多开发人员在部署过程中使用它。`.gitignore`文件包含一系列在更改时不会在存储库中跟踪的文件和文件夹。这通常用于上传包含用户上传的图像或其他文件的文件夹，也用于 vendor 文件夹，该文件夹包含项目中使用的所有库。

## Vendor 文件夹

`vendor`文件夹包含我们应用程序中使用的所有库。如前所述，关于如何使用`vendor`文件夹有两种不同的思考方式。在生产中包含 Composer 以便在应用程序部署后从存储库获取`vendor`文件夹，或者在生产中将开发中使用的库下载到生产中。

## 部署工作流

部署工作流可能因项目需求而异。例如，如果您想在存储库中保留整个项目，包括`vendor`文件夹，或者如果您希望在项目部署后从 Composer 获取库。在本章中，我们将看一下一些最常见的工作流。

### 存储库中的 Vendor 文件夹

第一个部署工作流在存储库中有整个应用程序。这是当我们在开发环境中第一次使用 Composer 并将`vendor`文件夹推送到我们的存储库时，所有的库都将保存在存储库中。

因此，在生产中，我们将从存储库中获取整个项目，而无需进行 Composer 更新，因为我们的库已经在部署中投入生产。因此，在生产中不需要 Composer。

在存储库中包含**`vendor`**文件夹的优点如下：

+   您知道相同的代码（包括库）在开发中是可以工作的。

+   在生产中更新库的风险较小。

+   在部署过程中，您不依赖外部服务。有时，库在特定时刻不可用。

在存储库中包含**`vendor`**文件夹的缺点如下：

+   你的存储库必须存储已经存储在 Composer 上的库。如果你需要许多或大型库，所需的空间可能会成为一个问题。

+   你正在存储不属于你的代码。

### 生产环境中的 Composer

第二个部署工作流程有两种不同的进行方式，但它们都不需要将`vendor`文件夹存储在存储库中；一旦代码部署到生产环境，它们将从 Composer 获取库。

一旦代码部署到生产环境，将会执行`composer update`命令，可以是**手动**或**自动**在部署过程中执行。

在生产环境中运行 Composer 的优点如下：

+   你可以在你的存储库中节省空间

+   你可以在生产环境中执行–optimize-autoload 以映射添加的库

在生产环境中运行 Composer 的缺点如下：

+   部署过程将取决于外部服务。

+   在更新包时，某些情况下存在重大风险。例如，如果一个库突然被修改或损坏，你的应用程序将会崩溃。

## 前端依赖关系

需要知道在前端也可以管理依赖关系，因此可以选择是将其放在存储库中还是不放。Grunt 和 Gulp 是两种最常用的工具，用于自动化应用程序中的任务。此外，如果基于微服务的应用程序有前端部分，你应该使用以下工具来管理样式和资产。

### Grunt

**Grunt**是一个用于自动化应用程序任务的工具。Grunt 可以帮助你合并或压缩 JS 和 CSS 文件，优化图像，甚至帮助你进行单元测试。

每个任务都是由 JavaScript 开发的 Grunt 插件实现的。它们也使用 Node.js，因此使 Grunt 成为一种多平台工具。你可以在 [`gruntjs.com/plugins`](http://gruntjs.com/plugins) 上查看所有可用的插件。

学习 Node.js 并不是必要的，只需安装 Node.js，你就可以安装 Grunt（以及许多其他包）所需的 Node Packaged Modules。一旦安装了 Node.js，运行以下命令：

```php
**npm install grunt-cli -g**

```

现在，你可以创建一个`package.json`，它将被 NPM 命令读取：

```php
    {
      "name": "finding-secrets",
      "version": "0.1.0",
      "devDependencies": {
        "grunt": "~0.4.1"
      }
    }
```

然后，`npm install`将安装`package.json`文件中包含的依赖项。Grunt 将存储在`node_modules`文件夹中。一旦安装了 Grunt，就需要创建一个`Gruntfile.js`来定义自动化任务，如下面的代码所示：

```php
    'use strict';
    module.exports = function (grunt) {
    grunt.**initConfig**({
      pkg: grunt.file.readJSON('package.json'),
    });
    //grunt.**loadNpmTasks**('grunt-contrib-xxxx');
    //grunt.**registerTask**('default', ['xxxx']);
    };
```

有三个部分来定义自动化任务：

+   **InitConfig**：这是指由 Grunt 执行的任务

+   **LoadNpmTask**：这用于加载所需的插件以执行任务

+   **RegisterTask**：这注册将运行的任务

一旦决定安装哪个插件并定义所有必要的任务，就在终端上运行 grunt 来执行它们。

### Gulp

与 Grunt 一样，**Gulp**也是一个用于自动化任务的工具，它也是基于 NodeJS 开发的，因此需要安装 Node.js 才能安装 NPM。一旦安装了 Node.js，就可以通过运行以下命令全局安装 Gulp：

```php
**npm install -g gulp**

```

另一种安装 gulp 的方式，也是推荐的选项，是本地安装，你可以使用以下命令来完成：

```php
**npm install --save-dev gulp**

```

所有任务都应该包含在位于根项目上的`gulpfile.js`中以进行自动化：

```php
    var gulp = require('gulp');
    gulp.task('default', function () {
    });
```

上述代码非常简单。正如你所看到的，代码是`gulp.task`，任务名称，然后是为该任务名称定义的`function`。

一旦你定义了函数，你就可以运行`gulp`。

### SASS

CSS 很复杂，庞大，难以维护。你能想象维护一个有成千上万行的文件吗？这就是 Sass 可以发挥作用的地方。这是一个预处理器，为 CSS 添加了变量、嵌套、混合、继承等功能，使 CSS 成为一种真正的开发语言。

**Syntactically Awesome Stylesheets** (**SASS**)是 CSS 的元语言。它是一种被翻译成 CSS 的脚本语言。SassScript 是 Sass 语言，它有两种不同的语法：

+   **缩进语法:** 这使用缩进来分隔块代码，换行符来分隔规则

+   **SCSS**: 这是 CSS 语法的扩展，它使用大括号来分隔代码块，分号来分隔块内的行

缩进的语法有`.sass`扩展名，SCSS 有`.scss`扩展名。

Sass 非常简单易用。一旦安装，只需在终端上运行`sass input.scss output.css`。

### Bower

**Bower**是一个类似 Composer 的依赖管理工具，但它适用于前端。它也基于 Node.js，因此一旦安装了 Node.js，您就可以使用 NPM 安装 Bower。使用 Bower，可以更新所有前端库，而无需手动更新它们。一旦安装了 Node.js，安装 Bower 的命令如下：

```php
**npm install -g bower**

```

然后，您可以执行`bower init`来创建项目上的`bower.json`文件。

`bower.json`文件会让您想起`composer.json`：

```php
    {
      "name": “bower-test”,
      "version": "0.0.0",
      "authors": [
        "Carlos Perez and Pablo Solar"
      ],
      "dependencies": {
        "jquery": "~2.1.4",
        "bootstrap": "~3.3.5"
        "angular": "1.4.7",
        "angular-route": "1.4.7",
      }
    }
```

在上述代码中，您可以看到添加到项目中的依赖项。它们可以被修改，以便像 Composer 一样在您的应用程序上安装这些依赖项。此外，与 Composer 一起使用 Bower 的命令非常相似：

+   **bower install:** 这是为了安装`bower.json`中的所有依赖项

+   **bower update:** 这是为了更新`bower.json`中包含的依赖项

+   **bower install package-name:** 这会在 Bower 上安装一个包

# 部署自动化

在某个时刻，您的应用将被部署到生产环境。如果您的应用很小，只使用了少量容器/服务器，那么一切都会很好，您可以轻松地手动管理所有资源（容器、虚拟机、服务器等）在每次部署时。但是，如果您有数百个资源需要在每次部署时更新，那该怎么办呢？在这种情况下，您需要某种部署机制；即使您有一个小项目和一个容器/服务器，我们也建议自动化您的部署。

使用自动部署流程的主要好处如下列出：

+   **易于维护:** 大多数时候，部署所需的步骤可以存储在文件中，这样您就可以编辑它们。

+   **可重复:** 您可以一遍又一遍地执行部署，每次都会按照相同的步骤进行。

+   **更少出错:** 我们是人类，作为人类，我们在多任务处理时会犯错。

+   **易于跟踪:** 有多种工具可用于记录每次提交发生的一切。这些工具也可以用于创建可以进行部署的用户组。您可以使用的最常见的工具是**Jenkins**、**Ansible Tower**和**Atlassian Bamboo**。

+   **更容易更频繁地发布:** 拥有一个部署流水线将帮助您更快地开发和部署，因为您将不会花时间处理将代码推送到生产环境。

让我们看看一些自动化部署的方法，从最简单的选项开始，逐渐增加复杂性和功能。我们将分析每种方法的优缺点，这样，在本章结束时，您将能够选择适合您项目的完美部署系统。

## 简单的 PHP 脚本

这是您可以自动化部署的最简单方式--您可以向您的代码中添加一个脚本（在公共位置），如下所示：

```php
    <?php
    define('MY_KEY', 'this-is-my-secret-key');
    if ($_SERVER['REQUEST_METHOD'] === 
    'POST' && $_REQUEST['key']  === MY_KEY) {
        echo shell_exec('git fetch && git pull origin master');
    }
```

在上述脚本中，只有在使用正确的密钥到达脚本时，我们才会从主分支中拉取。正如您所看到的，这非常简单，任何知道秘钥的人都可以触发它，例如，通过浏览器。如果您的代码仓库允许设置 webhook，您可以使用它们在每次推送或提交时触发您的脚本。

这是这种部署方法的优点：

+   如果所需工作很小，例如`git pull`，那么创建起来很容易

+   很容易跟踪脚本的更改

+   它很容易被您或任何外部工具触发

以下是这种部署方法的缺点：

+   Web 服务器用户需要能够使用存储库

+   当您需要处理分支或标签时，它会变得更加复杂

+   当您需要部署到多个实例时，它不容易使用，您将需要像 rsync 这样的外部工具

+   不太安全。如果您的密钥被第三方发现，他们可以在您的服务器上部署任何他们想要的东西

在理想的世界中，您对生产的所有提交都将是完美和纯净的，但您知道事实--在将来的某个时候，您将需要回滚所有更改。如果您已经使用了这种部署方法，并且想要创建一个回滚策略，您必须增加您的 PHP 脚本的复杂性，以便它可以管理标签。另一个不推荐的选择是，而不是向您的脚本添加回滚，您可以执行，例如，`git undo`并再次推送所有更改。

## Ansible 和 Ansistrano

**Ansible**是一个 IT 自动化引擎，可用于自动化云配置，管理配置，部署应用程序或编排服务等其他用途。该引擎不使用代理，因此无需额外的安全基础设施，它被设计为通过 SSH 使用。用于描述自动化作业（也称为**playbooks**）的主要语言是 YAML，其语法类似于英语。由于所有 playbooks 都是简单的文本文件，因此可以轻松地将它们存储在存储库中。在 Ansible 中可以找到的一个有趣的功能是其 Galaxy，这是一个可以在 playbooks 中使用的附加组件中心。

### Ansible 要求

Ansible 使用 SSH 协议管理所有主机，您只需要在一台机器上安装此工具--您将用来管理主机群的机器。控制机器的主要要求是 Python 2.6 或 2.7（从 Ansible 2.2 开始支持 Python 3），您可以使用除 Microsoft Windows 之外的任何操作系统。

托管主机的唯一要求是 Python 2.4+，这在大多数类 UNIX 操作系统中默认安装。

### Ansible 安装

假设您的控制机器上有正确的 Python 版本，使用包管理器很容易安装 Ansible。

在 RHEL、CentOS 和类似的 Linux 发行版上执行以下命令来安装 Ansible：

```php
**sudo yum install ansible**

```

Ubuntu 命令如下：

```php
**sudo apt-get install software-properties-common \
&& sudo apt-add-repository ppa:ansible/ansible \
&& sudo apt-get update \
&& sudo apt-get install ansible**

```

FreeBSD 命令如下：

```php
**sudo pkg install ansible**

```

Mac OS 命令如下：

```php
**sudo easy_install pip \
&& sudo pip install ansible**

```

### 什么是 Ansistrano？

**Ansistrano**是一个由`ansistrano.deploy`和`ansistrano.rollback`组成的开源项目，这两个 Ansible Galaxy 角色用于轻松管理您的部署。它被认为是 Capistrano 的 Ansible 端口。

一旦我们在我们的机器上有了 Ansible，使用以下命令很容易安装 Ansistrano 角色：

```php
**ansible-galaxy install carlosbuenosvinos.ansistrano-deploy \ carlosbuenosvinos.ansistrano-rollback**

```

执行此命令后，您将能够在您的 playbooks 中使用 Ansistrano。

### Ansistrano 是如何工作的？

Ansistrano 遵循 Capistrano 流程部署您的应用程序：

1.  **设置阶段**：在此阶段，Ansistrano 创建将容纳应用程序发布的文件夹结构。

1.  **代码更新阶段**：在此阶段，Ansistrano 将您的发布放在您的主机上；它可以使用 rsync、Git 或 SVN 等其他方法。

1.  **符号链接阶段**（见下文）：在部署新发布后，它会更改当前软链接，将可用发布指向新发布位置。

1.  **清理阶段**：在此阶段，Ansistrano 会删除存储在您的主机上的旧发布。您可以通过`ansistrano_keep_releases`参数在您的 playbooks 中配置发布的数量。在以下示例中，您将看到此参数的工作方式

### 提示

使用 Ansistrano，您可以挂钩自定义任务以在每个任务之前和之后执行。

让我们看一个简单的示例来解释它是如何工作的。假设你的应用程序部署到`/var/www/my-application`；在第一次部署后，这个文件夹的内容将类似于以下示例：

```php
**-- /var/www/my-application
 |-- current -> /var/www/my-application/releases/20161208145325
 |-- releases
 |   |-- 20161208145325
 |-- shared**

```

如前面的示例所示，当前的符号链接指向我们在主机上拥有的第一个版本。你的应用程序将始终可在相同路径`/var/www/my-application/current`中使用，因此你可以在任何需要的地方使用这个路径，例如 NGINX 或 PHP-FPM。

随着你的部署继续进行，Ansistrano 将为你处理部署。下一个示例将展示在第二次部署后你的应用程序文件夹将会是什么样子：

```php
**-- /var/www/my-application
 |-- current -> /var/www/my-application/releases/20161208182323
 |-- releases
 |   |-- 20161208145325
 |   |-- 20161208182323
 |-- shared**

```

如前面的示例所示，现在我们的主机上有两个版本，并且符号链接已更新，指向你的代码的新版本。如果你使用 Ansistrano 进行回滚会发生什么？很简单，这个工具将删除你的主机上的最新版本，并更新符号链接。在我们的示例中，你的应用程序文件夹内容将类似于这样：

```php
**-- /var/www/my-application
 |-- current -> /var/www/my-application/releases/20161208145325
 |-- releases
 |   |-- 20161208145325
 |-- shared**

```

### 提示

为了避免问题，如果你尝试回滚并且 Ansistrano 找不到要移动到的先前版本，它将不执行任何操作，保持你的主机没有变化。

### 使用 Ansistrano 进行部署

现在，让我们使用 Ansible 和 Ansistrano 创建一个小型的自动化系统。我们假设你有一个已知且持久的基础架构可用，你将在其中推送你的应用程序或微服务。在你的开发环境中创建一个文件夹，用于存放所有的部署脚本。

在我们的情况下，我们之前在本地环境中创建了三个启用了 SSH 的虚拟机。请注意，我们没有涵盖这些虚拟机的配置，但如果你愿意，你甚至可以使用 Ansible 来为你完成这些配置。

你需要创建的第一件事是一个`hosts`文件。在这个文件中，你可以存储和分组所有的服务器/主机，以便以后在部署中使用它们：

```php
**[servers:children]**
 **production**
 **staging**
 **[production]
192.168.99.200
192.168.99.201

[stageing]
192.168.99.100**

```

在上面的配置中，我们创建了两组主机-`production`和`staging`。在每一个组中，我们有一些可用的主机；在我们的情况下，我们设置了我们本地虚拟机的 IP 地址以进行测试，但如果你愿意，你也可以使用 URI。将主机分组的一个优势是你甚至可以创建更大的组；例如，你可以创建一个由其他组组成的组。例如，我们有一个`servers`组，包含了所有的生产和测试主机。如果你想知道如果你有一个动态环境会发生什么，没问题；Ansible 可以帮你，并提供了多个连接器，你可以使用它们来获取你的动态基础架构，例如来自 AWS 或 Digital Ocean 等。

一旦你的`hosts`文件准备好了，现在是时候创建我们的`deploy.yml`文件了，我们将在其中存储所有我们想要在部署中执行的任务。创建一个包含以下内容的`deploy.yml`文件：

```php
**---
- name: Deploying a specific branch to the servers
 hosts: servers
 vars:
     ansistrano_allow_anonymous_stats: no
     ansistrano_current_dir: "current"
     ansistrano_current_via: "symlink"
     ansistrano_deploy_to: "/var/www/my-application"
     ansistrano_deploy_via: "git"
     ansistrano_keep_releases: 5
     ansistrano_version_dir: "releases"

     ansistrano_git_repo: "git@github.com:myuser/myproject.git"
     ansistrano_git_branch: "{{ GIT_BRANCH|default('master') }}"

 roles:
     - { role: carlosbuenosvinos.ansistrano-deploy }**

```

多亏了 Ansistrano，我们的部署任务非常容易定义，如前面的示例所示。我们所做的是创建一个新任务，它将在标记为 servers 的所有主机上执行，并为 Ansistrano 角色定义一些可用的变量。在这里，我们定义了我们将在每个主机上部署我们的应用程序的位置，我们将使用的部署方法（Git），我们将在主机上保留多少个版本（5），以及我们想要部署的分支。

Ansible 的一个有趣的特性是你可以从命令行传递变量到你的通用部署过程中。这就是我们在下面这行中所做的：

```php
**ansistrano_git_branch: "{{ GIT_BRANCH|default('master') }}"**

```

在这里，我们使用`GIT_BRANCH`变量来定义我们想要部署的分支；如果 Ansible 找不到这个定义的变量，它将使用 master 分支。

你准备好测试我们所做的了吗？打开一个终端，转到存储部署任务的位置。假设你想要将最新版本的代码部署到生产主机上，你可以使用以下命令来完成：

```php
**ansible-playbook deploy.yml --extra-vars "GIT_BRANCH=master" --limit production -i hosts**

```

在上述命令中，我们告诉 Ansible 使用我们的`deploy.yml` playbook，并且我们还定义了我们的`GIT_BRANCH`为 master，以便部署该分支。由于我们在 hosts 文件中有所有的主机，并且我们只想将部署限制在`production`主机上，我们使用`--limit` `production`将执行限制到所需的主机。

现在，想象一下，您已经准备好一个新版本，您的所有代码都已提交并标记为`v1.0.4`标签，您想将此版本推送到您的演示环境。您可以使用一个非常简单的命令来完成：

```php
**ansible-playbook deploy.yml --extra-vars "GIT_BRANCH=v1.0.4" --limit staging -i hosts**

```

正如您所看到的，使用 Ansible/Ansistrano 部署您的应用非常容易，甚至可以更轻松地回滚到先前部署的版本。要管理回滚，您只需要创建一个新的 playbook。创建一个名为`rollback.yml`的文件，内容如下：

```php
**---
- name: Rollback
 hosts: servers
 vars:
     ansistrano_deploy_to: "/var/www/my-application"
     ansistrano_version_dir: "releases"
     ansistrano_current_dir: "current"
 roles:
     - { role: carlosbuenosvinos.ansistrano-rollback }**

```

在上述代码片段中，我们使用了 Ansistrano 回滚角色来回滚到先前部署的版本。如果您的主机中只有一个版本，Ansible 将不会撤消更改，因为这是不可能的。您还记得我们在`deploy.yml`文件中设置的名为`ansistrano_keep_releases`的变量吗？这个变量非常重要，可以知道您的主机上可以执行多少次回滚，因此根据您的需求进行调整。要将生产服务器回滚到先前的版本，您可以使用以下命令：

```php
**ansible-playbook rollback.yml --limit production -i hosts**

```

正如您所看到的，Ansible 是一个非常强大的工具，您可以用它进行部署，但它不仅仅用于部署；您甚至可以用它进行编排，例如。有了充满活力的社区和 RedHat 支持该项目，Ansible 是一个必不可少的工具。

### 提示

Ansible 有一个企业版的 Web 工具，您可以用它来管理所有的 Ansible playbooks。尽管它需要付费订阅，但如果您管理的节点少于十个，您可以免费使用它。

## 其他部署工具

正如您可以想象的，有多种不同的工具可以用来进行部署，我们无法在本书中涵盖所有这些工具。我们想向您展示一个简单的（PHP 脚本）和一个更复杂和强大的（Ansible），但我们不希望您在不了解其他可以使用的工具的情况下完成本章：

+   Chef：这是一个有趣的开源工具，您可以用它来管理基础架构作为代码。

+   Puppet：这是一个开源的配置管理工具，有一个付费的企业版本。

+   Bamboo：这是 Atlassian 的一个持续集成服务器，当然，您需要付费才能使用这个工具。这是您可以与 Atlassian 产品目录结合使用的最完整的工具。

+   Codeship：这是一个云持续部署解决方案，旨在成为一个专注于运行测试和部署应用的端到端解决方案的工具

+   Travis CI：这是一个类似于 Jenkins 用于持续集成的工具；您也可以使用它进行部署。

+   Packer、Nomad 和 Terraform：这些是 HashiCorp 的不同工具，您可以用它们来编写您的基础架构作为代码。

+   Capistrano：这是一个众所周知的远程服务器自动化和部署工具，易于理解和使用。

# 高级部署技术

在前面的部分，我们向您展示了一些部署应用程序的方法。现在，是时候使用一些在大型部署中使用的高级技术来增加复杂性了。

## 使用 Jenkins 进行持续集成

Jenkins 是最知名的持续集成应用程序；作为一个开源项目，它允许您以高度灵活的方式创建自己的流水线。它是用 Java 构建的，因此这是您安装此工具时的主要要求。使用 Jenkins，一切都更容易，甚至安装。例如，您可以只用几个命令启动一个带有最新版本的 Docker 容器：

```php
**docker pull jenkins \
&& docker run -d -p 49001:8080 -t jenkins**

```

上述命令将下载并创建一个带有最新 Jenkins 版本的新容器，准备好使用。

Jenkins 背后的主要思想是工作的概念。工作是一系列可以自动或手动执行的命令或步骤。通过工作和插件的使用（可以从 Web UI 下载），你可以创建自定义的工作流程。例如，你可以创建一个类似下一个的工作流程，它会在提交/推送发生时由你的存储库触发：

1.  一个单元测试插件开始测试你的应用程序。

1.  一旦通过，一个代码嗅探器插件检查你的代码。

1.  如果前面的步骤都没问题，Jenkins 通过 SSH 连接到远程主机。

1.  Jenkins 拉取远程主机中的所有更改。

上面的例子很简单；你可以改进和复杂化这个例子，使用 Ansible playbook 而不是 SSH。

这个应用程序非常灵活，你可以用它来检查主从数据库的复制状态。在我们看来，这个应用程序值得一试，你可以找到适应这个软件的各种任务的例子。

## 蓝绿部署

这种部署技术依赖于拥有基础设施的副本，这样你就可以在当前版本的应用程序旁边安装新版本。在应用程序前面，你有一个路由器或**负载均衡器**（LB），用于将流量重定向到所需的版本。一旦你的新版本准备好，你只需要更改你的路由器/LB，将所有流量重定向到新版本。拥有两套发布版本可以让你灵活地进行回滚，并且可以确保新版本运行良好。参考以下图表：

![蓝绿部署](img/B06142_08_01.jpg)

微服务的蓝绿部署

正如你从上面的图像中看到的，蓝绿部署可以在应用程序的任何级别进行。在我们的示例图像中，你可以看到一个微服务正在准备部署一个新版本，但尚未发布，你还可以看到一些微服务发布了他们的最新代码版本，保留了以前的版本以便回滚。

这种技术被大型科技公司广泛使用，没有任何问题；主要的缺点是你需要运行应用程序的资源增加了--更多的资源意味着在基础设施上花更多的钱。如果你想试一试，这种部署中最常用的负载均衡器是**ELB**、**Fabio**和**Traefik**等。

## 金丝雀发布

**金丝雀发布**是一种类似于蓝绿部署的部署技术，只是一次只升级少量主机。一旦你有了你想要的部分主机的发布版本，使用 cookie、lb 或代理，一部分流量被重定向到新版本。

这种技术允许你用一小部分流量测试你的更改；如果应用程序表现如预期，我们继续将更多主机迁移到新版本，直到所有流量都被重定向到你的应用程序的新版本。看一下下面的图表：

![金丝雀发布](img/B06142_08_02.jpg)

微服务的金丝雀发布

正如你从上面的图像中看到的，有四个微服务实例；其中三个保留了旧版本的应用程序，只有一个有最新版本。LB 用于在不同版本之间分配流量，将大部分流量发送到**v1.0.0**，只有一小部分流量发送到**v2.0.0**。如果一切正常，下一步将是增加**v2.0.0**实例的数量，减少**v1.0.0**实例的数量，并将更多的流量重定向到新版本。

这种部署技术会给您当前的基础设施增加一些复杂性，但允许您开始使用小部分用户/流量测试您的更改。另一个好处是重复使用您现有的基础设施；您不需要复制一套主机来进行部署。

## 不可变基础设施

如今，技术行业的一个趋势是使用不可变基础设施。当我们说不可变基础设施时，我们的意思是您在开发环境中拥有的内容稍后会在没有任何更改的情况下部署到生产环境中。您可以通过容器化技术和一些工具（如 Packer）实现这一点。

使用 Packer，您可以创建应用程序的映像，然后通过您的基础设施分发这个映像。这种技术的主要好处是您确保您的生产环境的行为与您的开发环境相同。另一个重要的方面是安全性；想象一下您的 NGINX 容器中发生了安全漏洞，通过基础映像更新的新版本将解决问题，并且将在不需要外部干预的情况下与您的应用程序一起传播。

# 备份策略

在任何项目中，备份是避免数据丢失的最重要方式之一。在本章中，我们将学习在应用程序中使用的备份策略。

## 什么是备份？

**备份**是将代码或数据保存在与通常存储代码或数据的地方不同的地方的过程。这个过程可以使用不同的策略来完成，但它们都有相同的目标--不丢失数据，以便将来可以访问。

## 为什么重要？

备份可以出于两个原因而进行。第一个原因是由于黑客攻击、数据损坏或在生产服务器上执行查询时出现任何错误而导致数据丢失。此备份将帮助恢复丢失或损坏的数据。

第二个原因是政策。法律规定必须保存用户数据多年。有时，这个功能是由系统完成的，但备份是存储这些数据的另一种方式。

总之，备份让我们保持冷静。我们确保我们正在正确地做事情，并且在任何灾难发生时，我们有解决方案可以快速修复它们，而且没有（重大的）数据丢失。

## 我们需要备份什么和在哪里备份

如果我们在应用程序中使用一些仓库，比如 Git，这可以是我们的文件备份位置。用户上传的资产或其他文件也应该备份。

查看`.gitignore`文件并确保我们已备份该文件夹中包括的所有文件和文件夹是备份所有必要文件的一个良好做法。

此外，最重要和宝贵的备份是数据库。这应该更频繁地备份。

### 提示

不要将备份存储在应用程序正在运行的相同位置。尝试为备份副本选择不同的位置。

## 备份类型

备份可以是完整的、增量的或差异的。我们将看看它们之间的区别以及它们的工作原理。应用程序通常将不同类型的备份结合在一起：完整备份与增量或差异备份。

### 完整备份

完整备份是基本备份；它包括生成当前应用程序的完整副本。大型应用程序定期使用此选项，而小型应用程序可以每天使用它。

优点如下：

+   完整的应用程序备份在一个文件中

+   它总是生成完整副本

缺点如下：

+   生成它可能需要很长时间

+   备份将需要大量的磁盘空间

请注意，通常最好在备份文件名中包含日期/时间，这样您只需查看文件名就可以知道何时创建的。

### 增量和差异备份

增量备份复制自上次备份以来发生变化的数据。这种备份应该包括`datetime`，以便在下次生成新备份时由备份工具检查。

优点如下：

+   比完整备份更快

+   占用更少的磁盘空间

缺点如下：

+   整个应用程序不会存储在单个生成的备份中

还有另一种类型，称为**差异备份**。这类似于增量备份（复制自上次备份以来发生变化的所有数据）；它在第一次执行后将继续复制自上次完整备份以来的所有修改数据。

因此，它会生成比增量备份更多的数据，但在第一次之后比完整备份少。这种类型介于完整和增量之间。它需要比增量备份更多的空间和时间，但比完整备份少。

## 备份工具

可以找到许多备份工具。在大型项目中最常见的工具是 Bacula。对于小型项目，也有其他类似的工具，比如经常运行的自定义脚本。

### Bacula

**Bacula**是一个备份管理工具。这个应用程序管理和自动化备份任务，非常适合大型应用程序。这个工具设置有点复杂，但一旦准备好，就不需要进行任何其他更改，它将可以正常工作。

Bacula 有三个不同的部分，每个部分都需要安装在不同的软件包中：

+   **管理者**：这个管理所有备份过程

+   **存储**：这是备份存储的地方

+   **文件**：这是我们的应用程序运行的客户端机器

在我们基于微服务的应用程序中，我们将有许多文件（每个微服务一个文件），还可以有许多存储位置（为了备份有不同的位置）和管理者。

这个工具使用守护进程。每个部分都有自己的守护进程，并且每个守护进程都遵循自己的配置文件。配置文件在安装过程中设置，只需要更改一些小的东西，比如远程 IP 地址、证书或计划自动化备份。

Bacula 的安全性非常出色--每个部分（管理者、存储和文件）都有自己的密钥，并且根据连接进行加密。此外，Bacula 允许 TLS 连接以提供更多安全性。

Bacula 允许进行完整、增量或差异备份，并且可以在管理者部分自动化。

### Percona xtrabackup

**XtraBackup**是一个开源工具，可以在不阻塞数据库的情况下对应用程序进行热备份。这可能是这个应用程序最重要的特性。

这个工具允许 MySQL 数据库（如 MariaDB 和 Percona）执行流式传输和压缩，并进行增量备份。

优点如下：

+   快速备份和恢复

+   备份期间无中断的事务处理

+   节省磁盘空间和网络带宽

+   自动备份验证

### 自定义脚本

在生产中使用自定义脚本是创建备份的最快方法。这是一个脚本，当运行时，通过执行`mysqldump`（如果我们使用的是 MySQL 数据库），压缩所需的文件，并将它们放在所需的位置（理想情况下是远程的不同机器）来创建备份。

这些脚本应该由 cronjob 执行，可以设置为每天或每周运行一次。

## 验证备份

作为备份策略的一部分，有技术来验证备份中存储的数据是一个好习惯。如果备份中有错误，就像没有任何备份一样。

为了检查我们的备份是否有效，没有损坏，并且按预期工作，需要经常进行模拟恢复，以避免在将来需要恢复时出现故障。

## 做好末日的准备

没有人想要恢复备份，但是在微服务出现故障或损坏并且我们需要快速反应的情况下，做好准备是必要的。

第一步是知道你的应用程序最近的备份在哪里，以便尽快恢复它。

如果问题与数据库有关，我们必须使应用程序停机，恢复数据库备份，检查其是否正常工作，然后再次使应用程序上线。

如果问题与资产或文件之类的东西有关，可以在不使应用程序停机的情况下进行恢复。

保持冷静并备份你的数据。

# 总结

现在你知道如何将你的应用程序部署到生产环境并自动化部署过程。此外，你还学会了需要部署什么以及可以从任何依赖管理中获取它，如何在必要时进行回滚，以及备份应用程序的不同策略。
