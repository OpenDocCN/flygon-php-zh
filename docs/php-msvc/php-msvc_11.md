# 第十一章：最佳实践和约定

这一章将教你在其他开发人员中脱颖而出。这是通过以风格开发和执行本书中学到的策略，并遵循具体的标准来实现的。

# 代码版本控制最佳实践

随着时间的推移，你的应用程序将不断发展，最终你会想知道你将如何处理任何微服务的 API。你可以尽量减少更改并对你的 API 的用户透明，或者你可以创建不同版本的代码。最佳解决方案是对你的代码（API）进行版本控制。

代码版本控制的众所周知和常用的方式如下：

+   **URL**：在这种方法中，你在请求的 URL 中添加 API 的版本。例如，`https://phpmicroservices.com/api/v2/user`的 URL 表示我们正在使用我们 API 的`v2`。我们在本书中的示例中使用了这种方法。

+   **自定义请求头**：在这种方法中，我们不在 URL 中指定版本。相反，我们使用 HTTP 头来指定我们想要使用的版本。例如，我们可以对`https://phpmicroservices.com/api/user`进行 HTTP 调用，但附加一个额外的头部`"api-version: 2"`。在这种情况下，我们的服务器将检查 HTTP 头并使用我们 API 的`v2`。

+   **接受头**：这种方法与前一种方法非常相似，但是我们将使用`Accept`头而不是自定义头。例如，我们将对`https://phpmicroservices.com/api/user`进行调用，但我们的 Accept 头将是`"Accept: application/vnd.phpmicroservices.v2+json"`。在这种情况下，我们指示我们想要版本 2，并且数据将以 JSON 格式呈现。

正如你可以想象的那样，在你的代码中实现版本控制的最简单方法是在 URL 中使用版本代码，但不幸的是，这并不被认为是最佳选项。大多数开发人员认为最佳的代码版本控制方式是使用 HTTP 头来指定你想要使用的版本。我们建议使用最适合你的项目的方法。分析谁将使用你的 API 以及如何使用，你将发现你需要使用的版本控制方法。

# 缓存最佳实践

缓存是一个可以存储临时数据的地方；它用于提高应用程序的性能。在这里，你可以找到一些小贴士来帮助你处理缓存。

## 性能影响

向你的应用程序添加缓存层总是会产生性能影响，你需要进行测量。无论你在应用程序的哪个位置添加缓存层，你都需要测量影响，以了解新的缓存层是否是一个好选择。首先，在没有缓存层的情况下进行一些度量，一旦你有了一些统计数据，启用缓存层并进行比较。有时你会发现，缓存层的好处变成了一个管理上的困扰。你可以使用我们在前几章中谈到的一些监控服务来监控性能影响。

## 处理缓存未命中

缓存未命中是指请求未保存在缓存中，应用程序需要从服务/应用程序中获取数据。确保你的代码可以处理缓存未命中和随之而来的更新。为了跟踪缺失缓存命中率，你可以使用任何监控软件或甚至日志系统。

## 分组请求

尽可能地尝试将你的缓存请求分组。想象一下，你的前端需要从缓存服务器中获取五个不同的元素来渲染一个页面。你可以尝试将请求分组，而不是进行五次调用，从而节省时间。

想象一下，你正在使用 Redis 作为缓存层，并希望将一些值保存在`foo`和`bar`变量中。看一下以下代码：

```php
    $redis->set('foo', 'my_value');
    /** Some code **/
    $redis->set('bar', 'another_value');
```

而不是这样做，你可以在一个事务中完成两个集合：

```php
    $redis->mSet(['foo' => 'my_value', 'bar' => 'another_value']);
```

上述示例将在一个提交中完成两个集合，节省时间并提高应用程序的性能。

## 缓存中存储的元素大小

将大型项目存储在缓存中比存储小型项目更有效。如果你开始缓存大量小项目，整体性能将会降低。在这种情况下，序列化大小、时间、缓存提交时间和容量使用将会增加。

## 监控你的缓存

如果你决定添加一个缓存层，至少要监控它。保持一些关于你的缓存的统计数据将有助于你了解它的表现如何（缓存命中率），或者它是否达到了容量限制。大多数缓存软件都是稳定而强大的，但这并不意味着如果你不加管理就不会遇到任何问题。

## 仔细选择你的缓存算法

大多数缓存引擎支持不同的算法。每种算法都有其优点和问题。我们建议你深入分析你的需求，并在确定它是你用例的正确算法之前，不要使用你选择的缓存引擎的默认模式。

# 性能最佳实践

如果你正在阅读这本书，很可能是因为你对 Web 开发感兴趣，而在过去几年中，Web 应用程序（如 API）的性能变得越来越重要。以下是一些统计数据，以便让你有一个概念：

+   亚马逊多年前报告称，每增加 100 毫秒的加载时间，他们的销售额就会减少 1%。

+   谷歌发现，将页面大小从 100 KB 减少到 80 KB 会使他们的流量减少 25%。

+   57%的在线消费者在等待页面加载 3 秒后会放弃一个网站。

+   80%的放弃网站的人不会回来。大约 50%的这些人会告诉其他人他们的负面经历。

正如你所看到的，你的应用程序的性能可能会影响你的用户甚至你的收入。在本节中，我们将为你提供一些改善 Web 应用程序整体性能的建议。

## 最小化 HTTP 请求

每个 HTTP 请求都有一个有效负载。因此，提高性能的一种简单方法是减少 HTTP 请求的数量。你需要在开发的每个方面都牢记这个想法。尽量减少 APIs/后端中对其他服务的最小外部调用。在前端，你可以合并文件以满足只有一个请求。你只需要在请求的数量和每个请求的大小之间取得平衡。

想象一下，你的前端的 CSS 被分成了几个不同的文件；而不是每次加载一个文件，你可以将它们合并成一个或几个文件。

你可以通过 HTTP 请求进行另一个快速而小的更改，那就是尽量避免在你的 CSS 文件中使用`@import`函数。使用链接标签而不是`@import`函数将允许你的浏览器并行下载 CSS 文件。

## 最小化 HTML、CSS 和 JavaScript

作为开发人员，我们试图以对我们来说更容易阅读的格式编写代码--一种人类友好的格式。通过这种方式开发，我们增加了我们的纯文本文件的大小，其中包括不必要的字符。不必要的字符可能包括空格、注释和换行符。

我们并不是说你需要编写混淆的代码，但是一旦你准备好了一切，为什么不删除不必要的字符呢？

想象一下，你的一个 JavaScript 文件（`myapp.js`）的内容如下：

```php
    /**
    * This is my JS APP
    */
    var myApp = {
      // My app variable
      myVariable : 'value1',

      // Main action of my JS app
      doSomething : function () {
        alert('Doing stuff');
      }
    };
```

在最小化之后，你的代码可以保存到一个不同的文件（`myapp.min.js`），它可能如下所示：

```php
    var myApp={myVariable:"value1",doSomething:function()
      {alert("Doing stuff")}};
```

在新的代码中，我们将文件大小减少了大约 60%，节省了大量空间。请注意，我们的存储库将同时拥有文件的两个版本：人类可读的版本用于进行更改，以及我们将在前端加载的最小化版本。

您可以使用在线工具进行最小化，或者您可以将`gulp`或`grunt`等工具集成到您的流程中。设置这些工具后，它们将跟踪某些特定文件（CSS、JS 和其他文件）的更改，一旦您对这些文件中的任何一个进行保存，工具将最小化内容。使用最小化工具的另一个隐藏的好处是，大多数工具还会检查代码或重命名变量以使其更小。

## 图像优化

在 Web 开发中最常用的资源之一可能就是图像。它们让您的网站看起来很棒，但也可能使您的网站变得非常缓慢。主要建议是将图像数量保持最少，但如果您需要保留图像，至少在将它们发送给用户之前尝试优化它们。在本节中，我们将向您展示一些可以优化图像的方法，从而提高应用程序的性能。

### 使用精灵图

精灵图是由多个图像组成的图像；稍后，您可以使用此图像并仅显示您感兴趣的部分。想象一下，您有一个漂亮的网站，在每个页面上都有一些社交图标（Facebook、Twitter、Instagram 等）。您可以将它们合并在一起，并使用 CSS 仅显示您想要的每个图标的部分，而不是为每个社交图标都有一个图像。这样做，您将只需加载一次所有社交图标，从而减少请求次数。

我们建议保持您的精灵图小，并只包含其中最常用和共享的图像。

### 使用无损图像压缩

并非所有图像格式都适合 Web，因为某些格式要么太大，要么不支持压缩。当今 Web 上使用最多的三种图像类型如下：

+   **JPG**：这是最常用的无损压缩方法之一

+   **PNG**：这是具有无损数据压缩的最佳格式

+   **GIF**：这是一种老式格式，每个图像支持最多 8 位像素，并以其动画效果而闻名

目前 Web 的推荐格式是**PNG**。它得到了浏览器的良好支持，易于创建，支持压缩，并且为您提供了改善网站性能所需的所有功能。

### 缩放图像

如果您使用图像而不是数据 URI，则应以其原始尺寸发送图像。您应该避免使用 CSS 调整图像大小，并将具有正确尺寸的图像发送到浏览器。唯一建议使用 CSS 缩放图像的情况是在流体图像（响应式设计）中。

您可以使用像 Imagick 或 GD 这样的 PHP 库轻松缩放图像。使用这些库和几行代码，您可以在几秒钟内缩放图像。通常情况下，您不会即时缩放图像。大多数情况下，一旦图像上传到您的应用程序，批处理过程会处理图像，创建应用程序所需的不同尺寸。

想象一下，您可以将任何尺寸的图像上传到您的应用程序，但在前端只显示最大宽度为`350`px 的图像。您可以使用 Imagick 轻松缩放以前存储的图像：

```php
    $imagePath = '/tmp/my_uploaded_image.png';
    $myImage   = new Imagick($imagePath);

    $myImage->resizeImage(350, 0, Imagick::FILTER_LANCZOS, 1);

    $myImage->writeImage('/tmp/my_uploaded_image_350.png');

```

上述代码将加载`my_uploaded_image.png`文件，并使用 Lanczos 滤镜将图像调整为宽度为`350`px（请参阅 PHP Imagick 文档，了解您可以使用的所有可用滤镜）。

这是一种方法，另一种（也许更有效的）常见方法是按需调整图像大小（即在客户端首次请求时），然后将调整大小的图像存储在缓存或永久存储中。

### 使用数据 URI

另一种快速减少 HTTP 请求次数的方法是将图像嵌入数据 URI 中。这样，您将在代码中将图像作为字符串，避免了对图像的请求，这种方法最适合静态页面。生成这种 URI 的最佳方式是使用外部或在线工具。

以下示例将向您展示它在您的 HTML 中的外观：

```php
    <img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgA..."
     alt="My Image">
```

### 缓存，缓存，还有更多的缓存

Web 性能完全取决于尽快提供数据，如果我们的应用程序已经发送的数据仍然有效，为什么要再次发送呢？默认情况下，现代浏览器会尝试减少它们对同一站点发出的请求数量，因此它们会在内部缓存中保留一些资产/资源的副本以供将来使用。由于这种行为，如果您正在浏览网站，我们不会在您在各个部分之间移动时一次又一次地尝试加载所有资产。

您可以通过指定每个请求响应来帮助浏览器，使用以下`Cache-Control` HTTP 标头：

+   **max-age=[秒]**：这设置了响应被视为新鲜的最长时间。此指令是相对于请求的时间。

+   s-maxage=[秒]：这类似于 max-age，但适用于共享缓存。

+   **public**：此标记将响应标记为可缓存。

+   **private**：此标记允许您将响应存储到一个用户。不允许共享缓存存储响应。

+   **no-cache**：此标记指示缓存将请求提交给原始服务器进行验证。

+   **no-store**：此标记指示缓存不保留响应的副本。

+   **must-revalidate**：此标记告诉缓存它们必须遵循您提供的有关响应的任何新信息。

+   **proxy-revalidate**：这类似于 must-revalidate，但适用于代理缓存。

主要建议是将静态资产标记为至少一周或长寿命资产的一天到期。对于频繁更改的资产，建议将到期日期设置为两天或更短。根据其生命周期调整资产的缓存到期日期。

想象一下，您有一张图片，每 6 小时更改一次；在这种情况下，您不应该将到期日期设置为一周，最好的选择将是大约 6 小时。

### 避免不良请求

没有比坏请求更令人讨厌的了，因为这种请求会严重降低应用程序的性能。您可能知道，浏览器对于同一主机可以同时管理的并发连接数量是有限的。如果您的网站发出了大量请求，这些可用连接插槽的列表可能已满，剩下的请求将被排队。

想象一下，您的浏览器最多可以管理 10 个并发连接，而您的 Web 应用程序却发出了 20 个请求。并非所有请求都可以同时处理，其中一些请求被排队。现在，如果您的应用程序正在尝试获取一个不存在的资产会发生什么？在这种情况下，浏览器将浪费时间（和插槽）等待不存在的资产被提供，但这永远不会发生。

作为建议，密切关注您的浏览器开发人员工具（一组内置于浏览器中的 Web 调试工具，可用于调试和分析您的站点）。这些工具可以帮助您发现问题请求，甚至可以检查每个请求使用的时间。在大多数浏览器中，您可以按下*F12*键打开嵌入式开发人员工具，但是，如果您的浏览器按下此键不打开工具，请查看浏览器的文档。

### 使用内容交付网络（CDN）

内容交付网络在旨在快速响应并从最近的服务器响应的服务器上托管您的资产的副本。这样，如果您将请求从您的服务器转移到 CDN 服务器，您的 Web 服务器将处理更少的请求，从而提高应用程序的性能。

想象一下，如果您在前端使用 jQuery；如果您将代码更改为从官方 CDN 加载库，则用户在其浏览器缓存中拥有该库的概率会增加。

我们的主要建议是至少为您的 CSS、JavaScript 和图像使用 CDN。

# 依赖管理

您有多个 PHP 库、框架、组件和工具可供在项目中使用。直到几年前，PHP 没有一种现代的管理项目依赖关系的方式。此刻我们有 Composer，一个灵活的项目，已经成为依赖管理的事实标准。

您可能对 Composer 很熟悉，因为我们在整本书中都在使用这个工具来在`vendor`文件夹中安装新库。此时，您可能会想知道是否应该提交`vendor`文件夹的依赖关系。没有快速的答复，但一般的建议是不要，您不应该将`vendor`文件夹提交到您的存储库中。

提交供应商文件夹的主要缺点可以总结如下：

+   增加您的存储库的大小

+   复制了您的依赖关系的历史记录

正如我们之前告诉过你的，不提交供应商是主要的建议，但如果你真的需要这样做，这里有一些建议：

+   使用标记的发布（不是开发版本），以便 Composer 获取压缩的源代码

+   在您的配置文件中使用`--prefer-dist`标志或将`preferred-install`设置为`dist`

+   将`/vendor/**/.git`规则添加到您的`.gitignore`文件中

# 语义版本

在您开始的任何项目中，您应该在主分支上使用语义版本。语义版本是一组规则，您可以遵循这些规则来标记您应用程序的代码在您的版本控制软件中。通过遵循这些规则，您将了解您的生产环境的当前状态。在您的代码中使用标签的另一个好处是，它允许我们在不同版本之间移动或以一种简单快捷的方式进行回滚。

拥有带有发布标签的源代码的另一个优势是，它允许您使用发布分支，从而使您能够更好地规划和控制对代码所做的更改。

## 语义版本如何工作

在语义版本中，您的代码标记为**`vX.Y.Z`**形式的标签，这意味着您代码的版本。您的每个标签部分都有特定的含义：

+   **X（主要）**：此版本号的增加表示正在进行重大改变；它们足够重要，与当前版本不兼容

+   **Y（次要）**：此版本号的增加表示我们正在向项目添加新功能

+   **Z（补丁）**：此版本号的增加表示我们向源代码添加了一个补丁

发布标签的更新通常由将代码推送到生产环境的开发人员进行。请记住在部署代码之前更新发布标签。

## 语义版本在行动

想象一下，您开始在别人的项目中，主分支被标记为`v1.2.3`。让我们看一些例子。

### 我们被告知要向项目添加一个新功能

在进行实时项目时，会收到新功能的请求。在这种情况下，我们明显正在增加次要版本号，因为我们正在添加新代码，这与实际基础代码不兼容。在我们的情况下，如果我们的主分支是`v1.2.3`，新版本标签将是`v1.3.0`。我们增加了次要版本号，同时重置了补丁号，因为我们正在添加新代码。

### 我们被告知我们的项目中有一个错误

在日常工作中，您将修复代码中的错误。在这种情况下，我们正在处理的是一个小改变，主要功能是解决我们的问题，因此我们需要增加补丁版本。在我们的例子中，如果当前生产版本是`v1.2.3`，新版本标签将是`v1.2.4`。我们只增加了补丁号，因为我们的修复不涉及其他更大的改变。

### 我们被要求进行重大改变

现在想象一下，我们被要求对我们的源代码进行重大更改；一旦应用了我们的更改，我们的源代码的某些部分将与以前的版本不兼容。例如，想象一下，您正在使用`library_a`，我们改用`library_b`，它们是互斥的。在这种情况下，我们正在处理一个非常重大的变化，这表明我们需要增加我们的主要版本号，同时还需要重置次要和补丁号。例如，如果我们的生产代码标记为`v1.2.3`，则应用更改后的新版本代码将为`v2.0.0`。

正如您所看到的，进行语义版本控制将帮助您保持源代码的清洁，并使得通过查看版本号就能知道正在进行哪种类型的代码更改。

# 错误处理

当我们因为应用程序执行期间发生了某些事情而抛出异常时，我们应该向我们的用户或消费者提供更多关于发生了什么的信息。通过添加可描述的标准代码，也称为状态代码，可以实现这一点。在响应中使用这些标准代码将帮助您（和您的同事）快速了解应用程序中是否出现了问题。查看以下列表，了解在 API 中使用的正确和最常见的 HTTP 状态代码。

## 客户端请求成功

如果您的应用程序需要通知 API 客户端请求成功，通常会回复以下 HTTP 状态代码之一：

+   **200 - 正常**：请求成功完成

+   **201 - 已创建**：成功创建了客户端指定的 URI

+   **202 - 已接受**：已接受处理，但服务器尚未完成处理

+   **204 - 无内容**：请求已完成，响应中没有发送任何信息

## 请求重定向

当您的应用程序需要回复请求被重定向时，您将使用以下 HTTP 状态代码之一：

+   **301 - 永久移动**：所请求的资源在服务器上不存在。服务器发送一个位置标头给客户端，将其重定向到新的 URL。客户端在将来的请求中继续使用新的 URL。

+   **302 - 暂时移动**：所请求的资源已暂时移动。服务器发送一个位置标头给客户端，将其重定向到新的 URL。客户端在将来的请求中继续使用旧的 URL。

+   **304 - 未修改**：用于响应`If-Modified-Since`请求标头。它表示自指定日期以来所请求的文档未被修改，客户端应使用缓存副本。

## 客户端请求不完整

如果您需要向 API 客户端发送的信息是关于不完整或错误的请求，您将返回以下 HTTP 代码之一：

+   **400 - 错误的请求**：服务器在客户端的请求中检测到语法错误。

+   **401 - 未经授权**：请求需要用户身份验证。服务器发送 WWW-Authenticate 标头以指示所请求资源的身份验证类型和领域。

+   **402 - 需要付款**：这是为将来保留的。

+   **403 - 禁止**：禁止访问所请求的资源。客户端不应重复请求。

+   **404 - 未找到**：所请求的文档在服务器上不存在。

+   **405 - 方法不允许**：客户端使用的请求方法是不可接受的。服务器发送“允许”标头，说明可以接受哪些方法来访问所请求的资源。

+   **408 - 请求超时**：客户端未能在服务器使用的请求超时期内完成其请求。但是，客户端可以重新请求。

+   **410 - 已消失**：所请求的资源已永久从服务器中消失。

+   413 - 请求实体太大：服务器拒绝处理请求，因为其消息主体太大。服务器可以关闭连接以阻止客户端继续请求。

+   **414 - 请求 URI 太长**：服务器拒绝处理请求，因为指定的 URI 太长。

+   **415 - 不支持的媒体类型**：服务器拒绝处理请求，因为它不支持消息正文的格式。

## 服务器错误

在应用程序不幸需要通知 API 客户端存在问题时，您将返回以下 HTTP 代码之一：

+   **500 - 内部服务器错误**：服务器配置设置或外部程序导致错误。

+   **501 - 未实现**：服务器不支持满足请求所需的功能。

+   **502 - 错误的网关**：服务器遇到上游服务器或代理的无效响应。

+   **503 - 服务不可用**：服务暂时不可用。服务器可以发送`Retry-After`头来指示服务何时可能再次可用。

+   **504 - 网关超时**：网关或代理已超时。

# 编码实践

您的代码是应用程序的核心；因此，您希望以正确、清晰和高效的方式编写它。在本节中，我们将为您提供一些改进代码的提示。

## 处理字符串

行业标准之一是在应用程序的所有级别中使用 UTF-8 格式。如果您忽略了这个建议，您将在整个项目的生命周期中处理编码问题。在撰写本书时，PHP 不支持低级别的 Unicode，因此在处理字符串时需要小心，特别是在处理 UTF-8 时。以下建议仅适用于使用 UTF-8 的情况。

在 PHP 中，基本的字符串操作，如赋值或连接，在 UTF-8 中不需要任何特殊处理；在其他情况下，您可以使用核心函数来处理字符串。大多数情况下，这些函数都有一个对应的函数（以`mb_*`为前缀）来处理 Unicode。例如，在 PHP 核心中，您可以找到`substr()`和`mb_substr()`函数。每当您操作 Unicode 字符串时，都必须使用多字节函数。想象一下，如果您需要获取 UTF-8 字符串的一部分；如果您使用`substr()`而不是`mb_substr()`，有很大的机会得到您不期望的结果。

## 单引号与双引号

单引号字符串不会被 PHP 解析，因此您的字符串中有什么并不重要，PHP 将原样返回字符串。在双引号字符串的情况下，它们会被 PHP 引擎解析，并且字符串中的任何变量都将被评估。对于双引号字符串，转义字符（例如 t 或 n）也将被评估。

在现实应用中，使用其中一种方法的性能差异可能会被忽略，但在高负载应用中，性能可能会有所不同。我们建议保持一致，如果需要变量和转义字符被评估，请只使用双引号。在其他情况下，请使用单引号。

## 空格与制表符

开发人员之间存在着使用空格和使用制表符来缩进他们的代码的战争。每种方法都有其自身的好处和不便，但 PHP FIG 建议使用四个空格。只使用空格可以避免与差异、补丁、历史和注释相关的问题。

## 正则表达式

在 PHP 中，您有两种选项来编写您的正则表达式：PCRE 和 POSIX 函数。主要建议使用 PCRE 函数（以`preg_*`为前缀），因为在 PHP 5.3 中，POSIX 函数族已被弃用。

## 连接和对数据库的查询

在 PHP 中，您有多种连接到数据库的方式，但在所有这些方式中，连接的推荐方式是使用 PDO。使用 PDO 的好处之一是它具有标准接口，可以连接到多个不同的数据库，使您能够在不太麻烦的情况下更改数据存储。当您对数据库进行查询时，如果不想出现任何问题，请确保始终使用预处理语句。这样，您将避免大部分 SQL 注入攻击。

## 使用===运算符

PHP 是一种松散类型的编程语言，当您比较变量时，这种灵活性会带来一些注意事项。如果使用`===`运算符，PHP 会确保您进行严格比较，避免错误的结果。请注意，`===`比`is_null()`和`is_bool()`函数略快。

# 使用发布分支的工作

一旦我们的项目遵循语义版本控制，我们就可以开始在版本控制系统（例如 Git）中使用发布和发布分支。使用发布和发布分支可以让我们更好地计划和组织我们对代码的更改。

与发布版的工作基于语义版本控制，因为每个发布分支通常是从最新的主分支版本创建的（例如 v1.2.3）。

使用发布分支的主要好处如下：

+   帮助您遵循严格的方法将代码推送到生产环境

+   帮助您轻松计划和控制对代码的更改

+   尝试避免将不需要的代码拖入生产环境的常见问题

+   允许您阻止特殊分支（例如 dev 或 stage）以避免未经 pull 请求的提交

请注意，这只是一个建议；每个项目都是不同的，这种工作流程可能不适合您的项目。

## 快速示例

要在项目中使用发布版，您需要使用一个发布分支和另一个临时分支来对代码进行更改。对于以下示例，请想象我们的项目将主分支标记为 v1.2.3。

第一步是检查我们是否已经有一个发布分支，我们将在其上进行工作。如果不是这种情况，您需要从主分支创建一个新的发布分支：

+   首先，我们需要决定我们的下一个版本号；我们将使用从语义版本控制中学到的所有内容。

+   一旦我们知道我们的下一个版本号，我们将从主分支创建一个发布分支。下一个命令将向您展示如何获取最新的主分支并创建并推送一个新的发布分支：

```php
 **git checkout master
      git fetch
      git pull origin master
      git checkout -b release/v1.3.0
      git push origin release/v1.3.0**

```

+   在上述步骤之后，我们的存储库将拥有一个干净的发布分支，准备好使用。

此时，我们的发布分支已准备就绪。这意味着任何代码修改都将在从我们的发布分支创建的临时分支中进行：

+   假设我们需要向项目添加一个新功能，因此我们需要从发布分支创建一个临时分支：

```php
 **git checkout release/v1.3.0
      git fetch
      git pull origin release/v1.3.0
      git checkout -b feature/my_new_feature**

```

+   一旦我们有了`feature/my_new_feature`，我们可以将所有更改提交到这个新分支。一旦所有更改都已提交并准备就绪，我们可以将`feature/my_new_feature`与发布分支合并。

上述步骤可以重复任意次数，直到您为发布计划的所有任务完成为止。

一旦完成了所有发布任务并且所有更改都已经获得批准，您可以将发布分支与主分支合并。一旦完成与主分支的合并，请记得更新发布标签。

我们可以用以下提醒笔记总结我们的示例：

+   新的发布分支始终是从主分支创建的

+   临时分支始终是从发布分支创建的

+   尽量避免将其他临时分支与当前临时分支合并

+   尽量避免将非计划分支与发布分支合并

在上述工作流程中，我们建议使用以下分支前缀来了解与分支关联的更改类型：

+   `release/*`: 这个前缀表示所有包含的更改将在将来的发布中部署，版本号相同

+   `feature/*`: 这个前缀表示添加到分支的任何更改都是新功能

+   `hotfix/*`: 这个前缀表示包含的更改是为了修复错误/问题而提交的

通过这种方式工作，将更难将不需要的代码推送到生产环境。请随意根据您的需求调整前述工作流程。

# 总结

在本章中，我们为您介绍了一些关于您项目中可以使用的常见最佳实践和约定的要点。它们都是建议，但它们使得项目与其他项目脱颖而出。
