# 第十一章：设计一个函数式应用程序

创建一个完全遵守函数式编程原则的应用程序可能看起来像是一个不可能的任务。如果不能有任何副作用，你怎么能编写任何有意义的软件呢？为了执行任何计算，你至少需要一些输入和显示结果。

函数式语言有各种机制来规避这些限制。我们将快速介绍其中一些，这样你就可以更好地了解如何以纯函数式的方式编写应用程序。

然后我们将更深入地学习一种称为**函数式响应式编程**（**FRP**）的范式，作为设计具有用户界面的应用程序的一种方式。我们将奠定在 PHP 中使用这种技术的基础，看看是否可能用它来编写一个完整的应用程序。

在本章中，你将学习以下主题：

+   在纯函数式语言中编写一个完整的应用程序

+   函数式响应式编程

+   使用 FRP 设计 PHP 应用程序

# 纯函数式应用程序的架构

应用程序就像函数。如果你有一个没有任何输入的应用程序，它的结果将始终相同。你可以修改源代码中的一些值并重新编译软件以改变其结果，但这与我们编写应用程序的主要原因相悖。

这就是为什么你需要一种方法来向应用程序提供数据，以便它执行任何有意义的计算。这些输入可以是多种类型的：

+   命令行参数

+   文件内容

+   数据库内容

+   图形界面中的字段

+   第三方服务

+   网络请求

在所有这些中，只有第一个可以被认为不会破坏我们整个应用程序的引用透明性。如果你将你的应用程序视为一个大函数，通过命令行输入数据可以被视为其参数，因此保持一切都是纯粹的。所有其他类型的输入都是事实上不纯的，因为对数据的两次连续检索可能导致不同的值。

解决这个问题的 Haskell 的标准方法是使用**IO 单子**。IO 单子不会立即执行其操作，而是将所有步骤存储在队列中。如果你将这个 IO 操作命名为`main`，Haskell 将知道在执行编译后的程序时必须运行它。

显然，如果在单子内部执行任何 IO 操作，应用程序本身就不再是纯的了。然而，代码本身可以以引用透明的方式编写。当 IO 单子运行时，Haskell 运行时将执行所有不纯操作，然后传递各种获得的值。利用这个技巧，你可以用所有它带来的好处编写纯函数式代码，并执行 IO 操作。

这种方法在 Haskell 中是可用的，因为你可以使用单子变换器来组合多个单子。do 表示法也通过在 IO 单子中编写封装的代码而不带有与之相关的所有开销来帮助很多。例如，这里是一个在终端中读取行并以相反顺序打印单词的小程序：

```php
main = do 
  line <- getLine 
  if null line 
    then return () 
  else do 
    putStrLn $ reverseWords line 
    main 

reverseWords :: String -> String 
reverseWords = unwords . map reverse . words 
```

它读起来大多像执行相同任务的任何命令式源代码。PHP 缺乏语法糖，也没有单子变换器的实现，所以这样做相当困难。这就是为什么我们要做出妥协，正如前一章所讨论的，或者我们需要一些其他方法，正如我们将在下一节中看到的那样。

所涉及的想法可以被概括。任何不纯的函数都可以分解为两个函数，一个是纯的，一个是封装了副作用和影响的。这正是我们在前一章中所指的，当我们说大多数不纯的函数应该包含在 MVC 应用程序的控制器中时。

如果你有一个以`A`为参数并返回`B`的不纯函数`f`，你可以创建以下两个函数：

+   一个纯函数`g`，它接受`A`并返回`D`参数。参数`D`是对需要执行的 IO 操作的描述。

+   一个不纯的函数`h`接受`D`并执行描述的操作，就像一个解释器会做的那样。

如果我们以 Haskell 应用程序为例，Haskell 运行时本身将是我们不纯的`h`函数。如果我们的源代码返回 IO 单子的一个实例，就像我们上面的例子所做的那样，它将被用作`D`参数，并且副作用将被解释。

如果你正在使用**Symfony**框架编写 Web 应用程序，我们可以将框架视为不纯的`h`函数，`D`参数将是执行你的控制器的结果。另一种可能性是在我们的函数代码周围添加自定义的不纯包装器。

主要思想是将诸如`h`之类的函数数量减少到最低。Haskell 强制你只能有一个这样的函数，甚至隐藏在运行时内部。如果你在使用 PHP，那么你需要尽可能有效地强制执行这个规则。

拥有计算的描述和一个解释器来执行它们的概念是函数世界中许多更高级技术的核心。它在整个计算机编程中也非常重要。如果我们稍微远离一点，我们可以看到以下情况：

+   描述就像一个抽象语法树（**AST**）

+   解释器接受 AST 并运行它

这就是大多数现代编译器的工作方式，首先它们解析源代码将其转换为 AST，然后解释它以创建二进制文件。在大多数复杂应用程序中，你也会一次又一次地发现相同的模式。

使用这种结构的一个高级构造是*free monad*。这个单子目前在函数世界中是一个热门话题，它的使用正在迅速增长。我们在这里缺少了相当多的理论来接近这个话题，但如果你感兴趣，你肯定会在互联网上找到很多信息，例如，[`underscore.io/blog/posts/2015/04/14/free-monads-are-simple.html`](http://underscore.io/blog/posts/2015/04/14/free-monads-are-simple.html)。

然而，当你在应用程序的生命周期中接受用户交互时，这种模式是有问题的。由于主要思想是通过描述来延迟执行有效的计算，你不能执行部分计算来显示用户界面，然后对用户输入做出反应。这是 FRP 试图解决的问题之一。

# 从函数式反应动画到函数式反应编程

在涉及函数式编程时，通常情况下，所涉主题的基础有点过时。1997 年，Conal Elliott 和 Paul Hudak 发表了一篇名为*Functional Reactive Animation, or Fran*的论文。

Fran 的主要目标是使用称为**behaviors**和**events**的两个概念来建模动画。行为是基于当前时间的值，事件是基于外部或内部刺激的条件。这两个概念允许我们在任何时间点表示任何类型的动画，尽管动画本身是连续的。

与其直接创建动画的表示，通常情况下，你使用行为和事件来描述它。然后，解释和因此表示留给底层实现。这与我们刚刚描述的情况类似。由于 Fran 可以编码诸如键盘输入或鼠标点击之类的事件，你正在创建的模型允许纯函数应用程序对外部输入做出响应。

## 反应式编程

在我们进一步讨论之前，让我们稍微谈谈在编程世界中*reactive*意味着什么。这个想法在过去几年里得到了相当多的关注。

首先，有*响应式宣言*（[`www.reactivemanifesto.org/`](http://www.reactivemanifesto.org/)），它提出了对任何软件都非常有趣的一些属性。这些属性包括：响应性、弹性、弹性和消息驱动。

维基百科（[`en.wikipedia.org/wiki/Reactive_programming`](https://en.wikipedia.org/wiki/Reactive_programming)）的定义表明了一些完全不同的东西：

> *在计算中，响应式编程是围绕数据流和变化传播的编程范式。这意味着应该能够在所使用的编程语言中轻松表达静态或动态数据流，并且底层执行模型将自动通过数据流传播更改。*

然后给出了表达式*a = b + c*的示例，其中当`b`或`c`的任何一个发生变化时，`a`的值会自动更新。

JavaScript 世界对这个想法很兴奋，有诸如`Bacon.js`或`RxJS`等库。所有这些库共享的核心思想都围绕事件或事件流。

我们可以看到，关于响应式编程有多种定义。遗憾的是，它们中没有一个真正符合我们刚刚学到的有关 Fran 的知识。自至少上世纪七十年代以来，我们将在本章的其余部分保留的定义是学术界的定义，可以在维基百科上找到。

我并不是说其他的定义无效，只是我们需要在这里有一个共同的基础。另外，下次与他人谈论响应式编程时，首先确保您对该主题的理解是一致的。

作为响应式编程的最后一个例子，让我们考虑以下代码片段：

```php
<?php 

$a = 10; 
$b = 5; 
$c = $a + $b; 

echo $c; 
// 15 

$a = 23; 
echo $c; 
```

在传统的命令式语言中，最后一行仍然会显示 15。然而，如果我们的应用程序遵循响应式编程的规则，`$a`的新值也会影响`$c`的值，程序将显示 28。

## 函数式响应式编程

正如您可能猜到的那样，当进行其他更改时，值随时间变化远非引用透明。此外，某些函数语言完全缺少变量的概念。我们如何调和响应式和函数式编程呢？

核心思想是在需要时将时间组件和先前事件参数化为函数。这正是 Fran 提出的行为和事件。时间和事件通常被提议作为流进行消耗。使用函数映射和过滤，您可以决定流中哪些事件对您感兴趣。

您的函数从此流中获取一个或多个输入以及应用程序的当前状态。然后它们必须返回应用程序的新状态。运行时将负责在事件发生时调用各个注册的函数。

你可能会觉得它类似于事件驱动编程。在某种程度上是，但有一个很大的区别。在传统的事件驱动应用程序中，事件被触发，但处理程序的返回值通常并不重要；它们需要具有副作用来执行某些操作。

在进行 FRP 时，运行时负责编排所有已注册的处理程序。保持应用程序的当前状态，将其传递给每个处理程序，并使用它们的结果进行更新。这允许函数是纯的。

可能比事件驱动编程更接近的另一种编程范式是演员模型。我不会在这里描述它，因为这将超出本书的范围，但对于了解它的人来说，我只想说有两个主要区别：

+   由于您拥有纯函数而不是演员，因此您无法拥有私有状态影响您对给定消息或事件的响应方式。

+   运行时管理事件流；处理程序无法向应用程序的其他部分发送新消息。

### 时间旅行

FRP 还有另一个好处。如果您记录了导致特定应用程序状态的事件序列，您可以重放它们。更好的是，您可以实现所谓的**时间旅行调试器**。由于您的应用程序使用纯函数，您可以回到任何时间点，并获得与以前完全相同的状态。

这种调试器还允许您向前向后重放任意数量的步骤，直到您可以准确地确定发生了什么。此外，您可以对代码进行更改，并播放相同的事件，以查看您的修改如何影响您的软件。

如果您想看到这样的调试器在实际操作中，您可以前往 Elm 语言提供的一个，特别是他们在线版本的一个对 Mario 平台游戏的天真实现（[`debug.elm-lang.org/edit/Mario.elm`](http://debug.elm-lang.org/edit/Mario.elm)）。

Elm 调试器可能是其种类中最早的之一。尽管类似的想法已经在传统语言中实现过，但命令式编程的本质要求我们记录的不仅仅是事件流。这就是为什么这是一个非常昂贵的操作，会大大减慢程序的执行速度。

您还需要从头开始重新启动程序，以确保达到相同的状态。然而，在纯应用程序中，您可以以更简单的方式实现这一点。类似于 Elm 中发现的实现现在正在被创建，例如用于 React JavaScript 库。

### 免责声明

有 FRP 和 FRP，但是我不打算改编这个想法的创造者，让我来引用他的话：

> *在过去几年中，FRP 的某些特性引起了程序员的极大兴趣，激发了在各种编程语言中实现的所谓“FRP”系统。然而，这些系统大多缺乏 FRP 的两个基本属性。*

您可以在 GitHub 上看到完整的文本以及相关幻灯片和视频（[`github.com/conal/talk-2015-essence-and-origins-of-frp`](https://github.com/conal/talk-2015-essence-and-origins-of-frp)）。

通常情况下，学术界和人们对研究结果的使用之间存在某种分歧。我不会在细节上纠缠，因为这应该只是一个介绍性的章节。然而，你需要意识到这一点很重要。

争议的主要点在于 FRP 涉及*连续时间*，而大多数实现只考虑*离散事件或值*。如果您想了解更多关于这些差异的信息，我强烈建议您观看之前链接的视频，该视频可在 Fran 和 FRP 的创建者 Elliot Conal 的 GitHub 存储库上找到。

## 更进一步

关于函数式响应式编程还有很多其他事情要说。事实上，整本书都是专门讨论这个主题的。然而，这只是一个介绍，所以我们就到此为止。如果您想要一个与特定语言无关的主题的一般方法，我可以推荐 Stephen Blackheath 和 Anthony Jones 新出版的*Functional Reactive Programming*。

在实现方面，ReactiveX 项目试图整合多个项目中可用的库。您可以在官方网站上找到更多信息[`reactivex.io/`](http://reactivex.io/)。在撰写本文时，涵盖了以下语言：Java、Swift、Python、PHP、Scala、JavaScript、Ruby、Clojure、Rust、Go、C#、C++和 Lua。

如前所述的免责声明和 ReactiveX 网站上的介绍，目前存在学术概念 FRP 与今天程序员所指的术语之间的混淆。前述书籍和 ReactiveX 库都谈到了后者而不是原始含义。这并不意味着这些都是坏主意，恰恰相反；只是这不是真正的 FRP。

# ReactiveX 入门

`Rx*`库选择通过将经典的观察者模式扩展到`Observable`模型来实现函数式响应式范式。对于给定的值流，由`Observable`模型的实例表示，您可以定义最多三个不同的处理程序：

+   每当有新值可用时，将调用`onNext`处理程序

+   当异常发生时，将调用`onError`处理程序

+   当流关闭时，将调用`onCompleted`处理程序

这种方法使得可以轻松处理多个异步事件，而无需编写复杂的样板代码来管理它们之间的依赖关系。与传统的观察者模式相反，信号流的结束和错误的能力被添加到与可迭代对象接口协调的接口中。

ReactiveX 还定义了一堆操作符，用于操作可观察对象及其值。有助手方法可以创建各种类型的流，从范围到数组，通过无限重复值和定时释放事件。

您还可以通过将函数映射到每个发出的值，将它们分组为新的可观察对象或值数组来操作流本身。您还可以过滤值，跳过或获取一定数量的值，限制一定时间内的发射次数，并抑制重复项。

文档([`reactivex.io/documentation/operators.html`](http://reactivex.io/documentation/operators.html))列出了可用的所有操作，以及一个很好的决策树，根据上下文决定使用哪个操作。

# RxPHP

在我们开始查看一些 RxPHP 示例之前，我想指出 Packt Publishing 还出版了一本完整的关于这个主题的书籍，*PHP Reactive Programming*。您可以在他们的网站上找到更多信息[`www.packtpub.com/web-development/php-reactive-programming`](https://www.packtpub.com/web-development/php-reactive-programming)。这就是为什么我们只会探索一些基本示例，以让您感受一下使用该库可能会是什么样子。如果您对这个主题感兴趣，我强烈建议您阅读专门的书籍。

在对 ReactiveX 进行了非常简要的介绍之后，让我们看看它如何被使用。首先，我们需要安装所需的库。我们将使用一个小的包装器来包装 ReachPHP 的流库，以使其可以与 RxPHP 一起使用，这样我们就可以演示访问磁盘上的文件。以下`composer`调用应该安装所有所需的依赖项：

```php
**composer require rx/stream**

```

现在库已安装，您可以从任何 PHP 流中解析数据。例如，CSV 文件：

```php
<?php 

use \Rx\React\FromFileObservable; 
use \Rx\Observer\CallbackObserver; 

$data = new FromFileObservable("11-example.csv"); 

$data = $data 
    ->cut() 
    ->map('str_getcsv') 
    ->map(function (array $row) { return $row; }); 

$data->subscribe(new CallbackObserver( 
    function ($data) { echo $data[0]."\n"; }, 
    function ($e) { echo "error\n"; }, 
    function () { echo "done\n"; } 
)); 
```

我们首先为要读取的文件创建一个流 Observable，然后应用一些转换：按行分隔输入，将 CSV 字符串解析为数组，并应用您可能想要的任何其他数据处理。正如您可以从我们将结果重新分配给`$data`变量的事实推断出来，该操作不是就地进行的，而是每次返回一个新实例。

然后，我们可以订阅处理程序到我们的流。在我们的例子中，我们只是打印每个元素的第一行。不是真正的功能，但对于一个小例子来说足够有效。

如果您使用**PostgreSQL**，则存在一个允许您使用 Rx 访问数据库的包。您可以使用它使用流检索数据。您可以使用以下`composer`调用进行安装：

```php
**composer require voryx/pgasync**

```

创建查询非常容易。只需创建一个带有连接凭据的客户端，然后在其上调用其中一个方法以创建一个 Observable 实例，您可以订阅该实例：

```php
<?php 

$client = new PgAsync\Client([ "user" => "user", "database" => "db" ]); 

$client->query('SELECT * FROM my_table')->subscribe(new CallbackObserver( 
    function ($row) { }, 
    function ($e) { }, 
    function () { } 
)); 
```

以下是一个最终示例，演示了 Rx 在流本身上提供的一些更高级的过滤和转换可能性。在运行之前，试着猜测输出会是什么：

```php
<?php 

use \React\EventLoop\StreamSelectLoop; 
use \Rx\Observable; 
use \Rx\Scheduler\EventLoopScheduler; 

// Those are needed in order to create a timed interval 
$loop = new StreamSelectLoop(); 
$scheduler  = new EventLoopScheduler($loop); 

// This will emit an infinite sequence of growing integer every  50ms. $source = Observable::interval(50, $scheduler); 

$first = $source 
    ->throttle(150, $scheduler) // do not emit more than one item  per 150ms 
    ->filter(function($i) { return $i % 2 == 0; }) // keep only  odd numbers 
    ->bufferWithCount(3) // buffer 3 items together before emitting them 
    ->take(3); // take the 10 first items only 

$second = $source 
    ->throttle(150, $scheduler) 
    ->take(10); 

$first->merge($second) // merge both observable 
    ->subscribe(new CallbackObserver( 
        function ($i) { var_dump($i); }, 
        function ($e) { }, 
        function () { } 
    )); 

$loop->run(); 
```

如果你尝试运行这段代码的最后一部分，你需要安装 RxPHP 的开发版本，因为 `throttle` 最近才实现。如果你的最小稳定性参数设置为 `dev` 版本，你可以使用以下命令安装它：

```php
**composer require reactivex/rxphp:dev-master**

```

## 实现引用透明度

正如示例所示，创建流并订阅它们是相当简单的。想象如何可以将处理程序因式分解，以便在多个可观察实例之间实现重用也是非常容易的。

然而，Rx 无法为我们解决的问题是实现尽可能多的引用透明度所需的应用程序架构。仅仅创建一个新的数据库查询作为 Observable 是不够纯粹的。

我可以给你的建议与上一章中听到的一样，就是尽量将所有不纯的代码隔离在一个地方。在我们的情况下，可以通过在一个唯一的文件中创建所有流来实现这一点，比如你的 `index.php` 文件，并在其他地方声明处理程序。

各种处理程序可以被孤立地测试，你可以很快对它们建立信心，因为它们将是引用透明的。集成和功能测试将负责测试流本身和整个应用程序。

如果你尝试在现有框架中使用 Rx，你可以在控制器中声明流，并像之前描述的那样保持处理程序分离。

# 总结

函数式响应式编程使我们能够将纯函数与事件管理相协调。这意味着可以创建需要用户输入或访问第三方服务和外部数据源的应用程序。随着越来越多的网站使用 Web 套接字和其他类似技术不断向用户推送数据，这一点尤为重要。

除了访问数据源之外，FRP 在处理用户界面工作时非常出色。通常在 Web 上使用 JavaScript 来执行任务，因为 PHP 主要用于处理请求本身并提供 HTML 响应。然而，PHP 可能会在桌面上更多地被使用，比如在 PHP 7 的 beta 版本中可用的 **libui** 包装器（[`github.com/krakjoe/ui`](https://github.com/krakjoe/ui)）。

PHP 中的桌面应用程序是社区中一个相当新的话题，现在可能是一个根据最新的函数式响应式编程创建一些最佳实践的好时机。

我们只是浅尝辄止了这种新的应用程序设计方式，要完全做到这一点需要远不止一章的篇幅。如果你想更多地了解这个主题，之前提到的两本书是一个很好的起点。

在本章中，我们了解了 FRP 的历史。我们还试图发现传统响应式编程和其函数式对应之间的区别。我们迅速谈到了时光旅行调试，然后展示了一些 PHP 的例子。

你刚刚完成了本书的最后一章。我希望你阅读它和我写作它一样有趣。我也希望我能够引起你对函数式编程的兴趣，并且你将尝试在未来的项目中实现我们在本书中看到的各种技术。对我来说，没有比知道我能够让一个同行开发者对这个美妙的主题感兴趣更好的回报了。

在我们分别之前，我可以建议你阅读 `附录`，*我们谈论函数式编程时在谈论什么*。它包含了对函数式编程的更全面定义，它的好处以及历史。你还会在最后找到一个词汇表，解释了各种术语，其中一些在本书中看到，其他一些是新的。

再见，感谢所有的鱼。
