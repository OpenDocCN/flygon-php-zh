# 第八章：测试

我们在整本书中已经多次断言纯函数更容易测试；现在是时候证明它了。在本章中，我们将首先介绍有关这个主题的小词汇表，以确保我们使用共同的语言。然后，我们将继续讨论功能性方法如何帮助传统测试。最后，我们将了解一种称为**基于属性的测试**的代码测试方法。

本章的主题并不严格限于函数式编程；您可以在任何传统代码库中使用任何内容。此外，这不是一本关于测试的书，所以我们不会详细介绍每个细节。还假定您对在 PHP 中测试代码有一些先验知识。

在本章中，我们将涵盖以下主题：

+   小型测试词汇表

+   测试纯函数

+   测试并行化作为一种加速技术

+   基于属性的测试

# 测试词汇表

我不会声称给你一个完整的所有与测试相关术语的词汇表，也不会解释每个术语的微妙差异和解释。这一部分的目的只是为了奠定一些共同的基础。

词汇表不会按字母顺序排列，而是根据类别分组。此外，绝对不能认为它是一个完整的词汇表。与测试相关的术语和技术远不止这里所呈现的内容，特别是如果包括所有与性能、安全性和可用性相关的测试方法：

+   **单元测试**：针对每个单独的组件进行的测试。被视为*单元*的内容各不相同-可以是一个函数/方法、一个整个类、一个整个模块。通常会模拟对其他单元的依赖，以清晰地隔离每个部分。

+   **功能测试**：以黑盒方式测试软件，以确保其符合规格。通常会模拟外部依赖。

+   **集成测试**：针对整个应用程序及其依赖项（包括外部依赖项）进行的测试，以确保一切正确集成。

+   **验收测试**：由最终客户/最终用户根据一组约定的标准进行的测试。

+   **回归测试**：在进行某些更改后重复测试，以确保没有引入问题。

+   **模糊测试/ Fuzzing**：通过输入大量（半）随机数据进行的测试，以使其崩溃。这有助于发现编码错误或安全问题。

+   **临时测试**：在没有正式框架或计划的情况下进行的测试。

+   **组件测试**：见*单元测试*。

+   **黑盒测试**：见*功能测试*。

+   **行为测试**：见*功能测试*。

+   **用户验收测试**（**UAT**）：见*验收测试*。

+   **Alpha 版本**：通常是作为黑盒测试的第一个版本。它可能不稳定并导致数据丢失。

+   **Beta 版本**：通常是功能完整且足够好以发布给外部人员的第一个版本。它仍然可能存在严重问题，不应在生产环境中使用。

+   **发布候选版**（**RC**）：被认为足够稳定以发布给公众进行最终测试的版本。通常最后一个 RC 会被“提升”为发布版本。

+   **模拟**（mock）：创建模拟软件或外部服务的组件，以仅测试手头的问题。

+   **存根**（**stub**）：见*模拟*。

+   **代码覆盖率**：测试覆盖的应用程序代码或功能的百分比。可以有不同的粒度：按行、按函数、按组件等。

+   **仪器化**：向应用程序添加代码以测试和监视行为或覆盖范围的过程。可以手动完成，也可以通过工具在源代码、编译形式或内存中完成。

+   **同行评审**：一种同事检查所产出工作（如代码、文档或与发布相关的任何内容）的过程。

+   静态分析：分析应用程序而无需运行它，通常由工具完成。它可以提供有关覆盖范围、复杂性、编码风格甚至发现问题的信息。

+   静态测试：在不执行应用程序的情况下进行的所有测试和审查。参见*同行审查*和*静态分析*。

+   冒烟测试：对应用程序的主要部分进行表面测试，以确保核心功能正常工作。

+   技术审查：参见*同行审查*。

+   决策点：代码中的一个语句，控制流可以发生变化，通常是一个`if`条件。

+   路径：从函数开始到结束执行的语句序列。根据其决策点，函数可以有多个路径。

+   圈复杂度：代码复杂性的度量。有各种算法来计算它；其中一个是“决策点的数量+1”。

+   缺陷、失败、问题或错误：在应用程序中未按预期工作的任何内容。

+   假阳性：测试结果被视为缺陷，而实际上一切都正常。

+   假阴性：测试结果被视为成功，而实际上存在缺陷。

+   测试驱动开发（TDD）：一种开发方法，您首先编写测试，然后编写最少量的代码使其通过，然后重复该过程。

+   行为驱动开发（BDD）：一种基于 TDD 的开发方法，其中您使用特定于领域的语言描述行为，而不是编写传统测试。

+   类型驱动开发：在功能世界中的一个笑话，您可以使用强类型系统替换测试。取决于您问的人，这个想法可能会更或更不严肃。

+   基于 X 的开发：每周都会出现一种新的最佳开发方法；网站[`devdriven.by/`](http://devdriven.by/)试图引用它们。

# 测试纯函数

正如我们在术语表中看到的那样，有很多潜在的测试应用程序的方法。在本节中，我们将限制自己只进行函数级别的测试；换句话说，我们将进行单元测试。

那么，纯函数为什么要容易得多呢？有多种原因；让我们从列举它们开始，然后我们将通过真实的测试用例来看为什么：

+   模拟变得简单，因为您只需要提供输入参数。无需创建外部状态，也无需存根单例。

+   对于给定的参数列表，重复调用将产生完全相同的结果，无论是白天还是之前运行的测试。无需将应用程序置于特定状态。

+   函数式编程鼓励编写更小的函数，每个函数只做一件事。这通常意味着更容易编写和理解的测试用例。

+   引用透明度通常意味着您需要更少的测试来获得对代码的相同信任水平。

+   无副作用保证了您的测试不会对任何其他后续测试产生影响。这意味着您可以以任何您想要的顺序运行它们，而不必担心在每个测试之间重置状态或者独立运行它们。

这些声明中的一些可能对您来说似乎有点大胆，或者您可能不确定我为什么要这样做。让我们花点时间用例子来验证它们为什么是真的。我们将把我们的例子分成四个不同的部分，以便更容易跟踪。

## 所有输入都是显式的。

正如我们之前发现的，纯函数需要将其所有输入作为参数。您不能依赖于单例的某些静态方法，生成随机数，或者从外部来源获取任何可能发生变化的数据。

其推论是，您可以在一天中的任何时间，在任何环境中，对于任何给定的参数列表运行测试，输出将保持不变。这个简单的事实使得编写和阅读测试变得更容易。

想象一下，您需要测试以下函数：

```php
<?php 

function greet() 
{ 
  $hour = (int) date('g'); 

  if ($hour >= 5 && $hour < 12) { 
    return "Good morning!"; 
  } elseif ($hour < 18) { 
    return "Good afternoon!"; 
  } elseif ($hour < 22) { 
    return "Good evening!"; 
  } 
  return "Good night!"; 
} 
```

问题在于，当你调用函数时，你需要知道现在是什么时间，这样你才能检查返回值是否正确。这一事实导致了一些问题：

+   基本上，你必须在测试中重新实现函数逻辑，因此可能在测试和函数中都存在相同的错误。

+   在你计算期望值并且函数再次返回结果之间，可能会有一分钟的时间流逝，改变当前的小时，从而改变函数的结果。这种假阳性的情况真的很头疼。

+   在不以某种方式操纵系统时钟的情况下，你无法测试所有可能的输出。

+   当前时间的依赖性被隐藏，阅读测试的人只能推断函数在做什么。

通过简单地将`$hour`变量作为参数传递，我们解决了之前提到的所有问题。

此外，如果你使用一个允许你为测试创建数据提供程序的测试运行器，比如**PHPUnit**或**atoum**，测试函数就变得非常简单，只需要创建一个提供程序，生成与预期返回相关联的小时列表，然后将时间提供给函数并检查结果。这种测试比之前需要编写的任何其他内容都更简单、更易于理解和扩展。

## 引用透明性和无副作用

引用透明性确保你可以在代码的任何地方用计算结果替换函数调用（带有特定参数）。这对于测试也是一个有趣的特性，因为这基本上意味着你需要测试的内容更少，就能获得相同的信任。让我解释一下。

通常，在进行单元测试时，你会尽量选择最小的单元，以满足你对代码的信任。通常情况下，你会在模块、类或方法级别进行测试。显然，在进行函数式编程时，你会在函数级别进行测试。

你的函数显然会调用其他函数。在传统的测试设置中，你会尽量模拟尽可能多的函数，以确保你只测试当前单元的功能，而不会受到其他函数可能存在的错误的影响。

虽然在 PHP 中模拟函数并非不可能，但在我们的情况下有些麻烦。特别是对于像`$title = compose('strip_tags', 'trim', 'capitalize');`这样的组合函数，由于 PHP 中使用闭包实现组合的方式，这变得有些困难。

那么我们该怎么办呢？基本上什么都不做。单元测试的目标是对代码按预期方式的工作获得信心。在传统的命令式方法中，你会尽量模拟尽可能多的依赖项，原因如下：

+   每个依赖项都可能依赖于你需要提供的某些状态，使你的工作更加困难。更糟糕的是，依赖项可能有自己的依赖项，也需要一些状态，依此类推。

+   命令式代码可能会产生副作用，这可能导致你的函数或某些依赖项出现问题。这意味着，如果没有模拟，你不仅在测试你的函数，还在测试所有其他依赖项和它们之间的交互；换句话说，你在进行集成测试。

+   控制结构引入决策点，这可能使对函数的推理变得复杂；这意味着，如果你将移动部件的数量减少到最低限度，你的函数就更容易测试。模拟其他函数调用可以减少这种复杂性。

在进行函数式编程时，第一个问题是无关紧要的，因为没有全局状态。你的依赖项所需的一切要么已经在被测试函数的参数中，要么将在途中计算。因此，模拟依赖项将使你做更多的工作，而不是更少。

由于我们的函数是纯函数且引用透明的，因此副作用不会对计算结果产生任何影响，这意味着即使我们有依赖关系，我们也不进行集成测试。当然，如果调用的函数中有错误，那么会导致错误，但希望它也会在另一个测试中被捕获，从而清楚地说明发生了什么。

关于复杂性，如果我们回到我们的组合函数，`$title = compose('strip_tags', 'trim', 'capitalize');`，我认为任何人都很容易理解发生了什么。如果所有三个函数都已经经过测试，那么即使我们在没有`compose`命令的情况下重新编写它，也不会出现太多问题。

```php
<?php 

function title(string $string): string 
{ 
  $stripped = strip_tags($string); 
  $trimmed = trim($stripped); 
  return capitalize($trimmed); 
} 
```

这里没有太多需要测试的地方。显然，我们需要编写一些测试来确保我们将正确的临时值传递给每个函数，并且管道的工作符合预期，但是如果我们对所有三个被调用的函数都有信心，那么我们就可以非常有信心地认为这个函数也会工作。

这种推理是可能的，因为我们知道由于引用透明的属性，这三个函数中的任何一个都不会以一些微妙的方式影响其他任何一个，这意味着它们自己的单元测试给了我们足够的信任，即它们不会出错。

所有这些的结果通常是，您会为函数式代码编写更少的测试，因为您会更快地获得信任。但这并不意味着`title`函数不需要测试，因为您可能在某个地方犯了一个小错误。每个组件仍然应该被测试，但可能在正确隔离一切方面要小心一些。

显然，我们不是在谈论数据库访问，第三方 API 或服务；出于与任何测试套件相同的原因，这些都应该被模拟。

## 简化模拟

这可能已经很清楚了，但我真的想强调一点，您需要做的任何模拟都会大大简化。

首先，您只需要创建要测试的函数的输入参数。在某些情况下，这意味着创建一些相当大的数据结构或实例化复杂的类，但至少您不必模拟外部状态或注入到依赖项中的大量服务。

这可能在所有情况下都不是真的，但通常您的函数在较小的规模上运行，因为它们是更大东西的一小部分，这意味着任何一个函数只会接受一些非常精确和简洁的参数。

显然，会有例外，但不是很多，正如我们之前讨论的那样，由于构成整体的所有部分已经被测试。因此，您的信心程度应该比通常情况下更高。

## 构建模块

函数式编程鼓励创建小的构建模块，这些模块作为更大函数的一部分被重复使用。这些小函数通常只做一件事。这使它们更容易理解，也更容易测试。

函数的决策点越多，测试每个可能的执行路径就越困难。一个小的专门函数通常最多有两个这样的决策点，这使得它相当容易测试。

通常较大的函数不会执行任何控制流，它们只是以直接的方式由我们的较小模块组成。由于这意味着只有一条可能的执行路径，这也意味着它们很容易测试。

## 结束语

当然，我并不是说您不会遇到一些难以测试的纯函数。通常情况下，您编写测试时会遇到更少的麻烦，并且您也会更快地对代码产生信任。

随着行业越来越接近 TDD 等方法论，这意味着函数式编程确实非常适合现代应用。一旦你意识到，通过只使用函数式编程技术就已经强制执行了大部分关于编写“可测试代码”的建议，这一点尤其正确。

# 使用并行化加速

如果你曾经寻找加速测试套件的解决方案，很可能会找到关于测试并行化的内容。通常，PHPUnit 的用户会找到**ParaTest**实用工具，例如。

主要思想是同时运行多个 PHP 进程，以利用计算机的所有处理能力。这种方法主要有两个原因：

+   单次测试运行存在瓶颈，比如源文件解析的磁盘速度或数据库访问。

+   由于 PHP 是单线程的，像几乎所有现在的计算机一样，多核 CPU 在单次测试运行中没有得到充分利用。

通过并行运行多个测试，这两个问题都可以解决。然而，能够这样做的能力受到了一个限制，即每个测试套件都是独立的，这一特性在函数式代码库中已经通过引用透明性得到了强制执行。

这意味着，如果被测试的函数遵循函数式原则，你可以在不做任何调整的情况下并行运行所有的测试。在某些情况下，这可能会将整个测试套件所需的时间缩短十分之一，大大改善了你在开发过程中的反馈循环。

如果你使用 PHPUnit 实用工具，前面提到的 ParaTest 实用工具是最简单的入门方式之一。你可以在 GitHub 上找到它：[`github.com/brianium/paratest`](https://github.com/brianium/paratest)。我建议你使用**`-functional`**命令行参数，这样每个函数都可以同时进行测试，而不仅仅是测试用例。

PHPUnit 用户还有一个全新的实用工具叫做**PHPChunkIt**。我还没有机会测试它，但我听说它很有意思。你可以在 GitHub 上找到它：[`github.com/jwage/phpchunkit`](https://github.com/jwage/phpchunkit)。

另一个更灵活的选择是使用 Fastest，可以在[`github.com/liuggio/fastest`](https://github.com/liuggio/fastest)找到。工具文档中显示的示例是针对 PHPUnit 的，但理论上它能够并行运行任何东西。

如果你使用的是 atoum 实用工具，那么默认情况下你的测试已经处于他们所谓的*并发*模式，这意味着它们是并行运行的。你可以根据执行引擎文档中的注释修改每个测试的行为：[`atoum-en.rtfd.org/en/latest/engine.html`](https://atoum-en.rtfd.org/en/latest/engine.html)。

**behat**框架的用户可以使用**Parallel Runner**扩展，也可以在 GitHub 上找到：[`github.com/shvetsgroup/ParallelRunner`](https://github.com/shvetsgroup/ParallelRunner)。如果你使用**CodeCeption**框架，要实现并行化可能有点困难；然而，文档（[`codeception.com/docs/12-ParallelExecution`](http://codeception.com/docs/12-ParallelExecution)）中有多种可能的解决方案。

我强烈建议你研究一下并行化你的测试，因为这将是花费时间的好方法。即使你每次运行只能节省几秒钟，这种收益很快就会累积起来。更快的测试意味着你会更频繁地运行它们，这通常是改进代码质量的好方法。

# 基于属性的测试

约翰·休斯和科恩·克拉森厌倦了费时费力地编写测试用例，他们决定是时候改变一下了。15 年多前，他们写了一篇关于他们称之为*QuickCheck*的新工具的论文并发表了出来。

主要思想是，不是定义可能的输入值列表，然后断言结果是我们期望的，而是定义表征函数的属性列表。然后工具会自动生成所需的测试用例，并验证属性是否成立。

默认的操作模式是*QuickCheck*生成随机值并将其提供给您的函数。然后检查结果是否符合属性。如果检测到失败，工具将尝试将输入减少到生成问题的最小输入集。

拥有一个工具可以生成尽可能多的测试值是无价的，可以找到需要花费数小时才能想到的边缘情况。测试用例被减少到最小形式也很容易确定出了什么问题以及如何解决。偶然情况下，随机值并不总是测试某些东西的最佳方式。这就是为什么您还可以提供要使用的生成器。

此外，将测试视为一组需要保持真实的属性是一种更清晰地关注系统应该做什么而不是专注于查找测试值的好方法。这在进行 TDD 时尤其有帮助，因为您的测试将更像是规范。

如果你想了解更多关于这种方法的信息，原始论文可以在[`www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf`](http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf)上找到。作者在论文中使用 Haskell，但内容相当容易阅读和理解。

## 属性到底是什么？

属性是您的函数必须遵守的规则，以确定其正确性。它可以是非常简单的东西，比如函数添加两个整数的结果也需要是整数，也可以是更复杂的东西，比如验证单子定律。

通常，您希望创建的属性不是已经由其他属性或语言强制执行的。例如，如果我们使用 PHP 7 引入的标量类型系统，我们之前的整数示例就不需要了。

举个例子，我们将从论文中选取一些内容。假设我们刚刚编写了一个函数，用于反转数组中元素的顺序。作者建议这个函数应该具有以下属性：

+   `reverse([x]) == [x]` 属性，反转一个只有一个元素的数组应该产生完全相同的数组

+   `reverse(reverse(x)) == x` 属性，两次反转数组应该产生完全相同的数组

+   `reverse(array_merge(x, y)) == array_merge(reverse(y), reverse(x))` 属性，反转两个合并的数组应该产生与将第二个数组反转后合并到第一个数组反转的结果相同

前两个属性将确保我们的函数不会干扰值。如果我们只有这两个属性，一个除了返回参数之外什么都不做的函数将会轻松通过测试。这就是第三个属性发挥作用的地方。它的写法确保我们的函数按我们期望的方式工作，因为没有其他方式属性会成立。

有趣的是这些属性在任何时候都不执行任何计算。它们很容易实现和理解，这意味着几乎不可能在其中引入错误。如果您通过某种方式重新实现它们正在进行的计算来测试您的函数，这将有点违背初衷。

尽管非常简单，这个例子完美地展示了找到有价值的属性既有意义又足够简单以确保它们不会有错误并不容易。如果您在找到好的属性方面有困难，我鼓励您以业务逻辑的角度来审视您的函数。不要以输入和输出为出发点，而是尝试看到更广阔的画面。

## 实现 add 函数

关于为什么基于属性的测试是一种有价值的工具的很好的解释可以在网上的幻灯片中找到[`www.slideshare.net/ScottWlaschin/an-introduction-to-property-based-testing`](http://www.slideshare.net/ScottWlaschin/an-introduction-to-property-based-testing)。还有一个伴随的博客帖子，提供了更多信息[`fsharpforfunandprofit.com/posts/property-based-testing-2/`](http://fsharpforfunandprofit.com/posts/property-based-testing-2/)。我将在这里快速总结它们。

要求开发人员编写一个添加两个值的函数，并进行一些测试。他编写了两个预期结果为 4 的测试；一切正常。要求函数的人要求进行更多的测试；它们失败的原因是函数总是返回值 4，而没有做任何有意义的事情。

开发人员重写函数，使测试再次通过，但新一轮的测试继续失败。实际上所做的是将结果合并到原始函数中的新测试中作为特殊情况。开发人员提出的借口是，他们遵循了 TDD 的最佳实践，即需要*编写最小的代码来使测试通过*。

发生的事情可能对于这样一个简单的功能来说似乎很愚蠢，但是如果你用一些需要实现的复杂业务逻辑来替换它，这样的故事可能比你想象的更常见，也是 TDD 的一个缺点，正如其反对者所说的。如果你严格遵循 TDD，你的代码永远不会比你的测试更好。

幻灯片继续介绍了一些值为随机整数的测试，并通过将结果与`x + y`进行比较来测试函数。在这种情况下，开发人员无法使用函数中的特殊情况进行欺骗。然而，显然还有另一个问题，即在测试中重新实现了函数以验证结果。

进入基于属性的测试。首先实现的属性是`add(x, y) == add(y, x)`。开发人员将`add`属性实现为`x * y`，这样就能正确通过测试。

这意味着我们需要第二个属性，例如`add(add(x, 1), 1) == add(x, 2)`属性。这也可以通过实现`x - y`来实现，但在这种情况下，第一个测试将失败。这就是为什么开发人员的最新实现只是返回`0`。

在这一点上，最后一个属性`add(x, 0) == x`被添加。开发人员最终被迫为我们的函数编写正确的实现，因为这一次他无法找到欺骗的方法。

如果我们回到我们的最后三个属性，并将它们与我们对数学中加法属性的了解进行比较，我们可以得出以下比较：

+   在`add(x, 0) == x`属性中，0 是加法的*单位元*

+   在`add(x, y) == add(y, x)`属性中，加法是*交换的*

+   在`add(add(x, 1), 1) == add(x, 2)`属性中，加法是*结合的*

这三个属性实际上都是我们试图实现的操作的众所周知的属性。正如我们之前所说的，退一步反思“是什么”而不是“谁”，对于提出属性时是一个很好的帮助。

幻灯片的其余部分是一次很好且有趣的阅读，但是我不想剽窃整个内容，我更愿意鼓励你去网上阅读。我只会从中选取三条建议，因为我觉得它们真的很好，也很容易记住：

+   **不同的路径，同一个目的地**：想出两种不同的方法来使用被测试的函数得到相同的结果，就像我们为`reverse`的第三个属性所做的那样。

+   **来回一趟**：如果你的函数有一个反函数，尝试同时应用两者，看看是否能得到初始值，就像我们为`reverse`的第二个属性所做的那样。

+   **有些事情永远不会改变**：如果您的输入的某些属性不会被函数改变，那么对它们进行测试，例如数组长度或数据类型。

有了这一切，现在您应该对如何为您的函数找到好的属性有了一个很好的想法。这仍然是一项困难的任务，但最终您可能会节省很多时间，因为您不必在找到它们时添加边缘情况。

如果您想要一个真实生活中由于基于属性的测试而被发现的错误的很好例子，约翰·休斯本人在[`vimeo.com/68383317`](https://vimeo.com/68383317)上做了一个很棒的演讲，并举了一些很好的例子。

## PhpQuickCheck 测试库

在我们已经看到了属性测试的理论方面之后，现在我们可以将注意力转向 PHP 特定的实现-`PhpQuickCheck`库。源代码可以在 GitHub 上找到[`github.com/steos/php-quickcheck`](https://github.com/steos/php-quickcheck)，并且可以使用**`composer`**命令进行安装：

```php
**composer require steos/php-quickcheck -stability dev**

```

您可能需要在您的`composer.json`文件中将`minimum-stability`设置为`dev`，或者根据 GitHub 页面上的说明手动添加依赖项，因为目前该库还没有稳定版本。

该项目始于 2014 年 9 月，大部分开发工作都在同年 11 月之前进行。自那时以来，没有添加太多新功能，主要是改进编码风格和一些小的改进。

虽然我们不能说该项目今天真的还很活跃，但它是 PHP 中第一个严肃尝试拥有`QuickCheck`库的项目之一，并且它具有一些功能，这些功能在其主要竞争对手中尚不可用，稍后将进行讨论。

但是，让我们不要急于行事；让我们回到我们的第一个例子，即反转函数。想象一下，我们编写了 PHP 中可用的`array_reverse`函数，并且我们需要对其进行测试。使用`PhpQuickCheck`库，它将如下所示：

```php
<?php 

use QCheck\Generator; 
use QCheck\Quick; 

$singleElement = Quick::check(1000, Generator::forAll( 
    [Generator::ints()], 
    function($i) { 
        return array_reverse([$i]) == [$i]; 
    } 
), ['echo' => true]); 

$inverse = Quick::check(1000, Generator::forAll( 
    [Generator::ints()->intoArrays()], 
    function($array) { 
        return array_reverse(array_reverse($array)) == $array; 
    } 
), ['echo' => true]); 

$merge = Quick::check(1000, Generator::forAll( 
    [Generator::ints()->intoArrays(), Generator::ints()- >intoArrays()], 
    function($x, $y) { 
        return 
            array_reverse(array_merge($x, $y)) == 
            array_merge(array_reverse($y), array_reverse($x)); 
    } 
), ['echo' => true]); 
```

`check`静态方法接受需要生成的测试数据量作为第一个参数。第二个参数是`Generator`函数的实例；通常，您将使用`Generator::forAll`在示例中创建它。最后一部分是您可以传递的选项数组，包括随机生成器`seed`变量，生成的数据的`max_size`函数（此值的含义取决于所使用的生成器），或者最后的`echo`选项，它将显示一个点（`.`）表示每个通过的测试。

`forAll`实例接受一个表示测试参数和测试本身的数组。在我们的例子中，对于第一个测试，我们生成随机整数，对于另外两个测试，我们生成随机整数数组。测试必须返回一个布尔值：`true`表示通过，否则为`false`。

如果您运行我们的小例子，它会显示每个生成的随机数据的一个点，因为我们传递了`echo`选项。结果变量包含有关测试结果本身的信息。在我们的情况下，如果您显示`$merge`，它将显示：

```php
array(3) { 
  ["result"]=> bool(true) 
  ["num_tests"]=> int(1000) 
  ["seed"]=> int(1478161013564) 
} 
```

`seed`实例在每次运行时都会不同，除非您将其作为参数传递。重用`seed`实例允许您创建完全相同的测试数据。这对于检查特定边缘情况是否在被发现后被正确修复非常有用。

一个有趣的功能是根据类型注释自动确定要使用哪个生成器。您可以使用`Annotation`类上的方法来实现：

```php
<?php 

/** 
 * @param string $s 
 * @return bool 
 */ 
function my_function($s) { 
    return is_string($s); 
} 

Annotation::check('my_function'); 
```

然而，这个功能目前只能与注释一起使用，类型提示将被忽略。

正如您在这些小例子中所看到的，`PhpQuickCheck`库在很大程度上依赖于静态函数。代码库本身有时也有点难以理解，而且该库缺乏良好的文档和活跃的社区。

总的来说，我认为我不会推荐使用这个选项，我们将在下面看到的选项可能更好。我只是想向您介绍这个库作为一个可能的替代方案，谁知道，它的状态可能会在未来发生变化。

## Eris

**Eris**的开发始于 2014 年 11 月，大约是`PhpQuickCheck`库引入最后一个重大功能的时间。正如我们将看到的，编码风格明显更现代。一切都清晰地组织在命名空间中，辅助函数采用函数的形式而不是静态方法。

像往常一样，您可以使用**`composer`**命令获取 Eris：

```php
**composer require giorgiosironi/eris**

```

文档可在线获取，网址为[`eris.rtfd.org/`](http://eris.rtfd.org/)，并且非常完整。我对它唯一的抱怨是，唯一的示例是为使用 PHPUnit 运行其测试套件的人准备的。应该可以使用其他测试运行器，但目前尚未有文档记录。

如果我们想使用 Eris 来测试我们为`array_reduce`定义的属性，我们的测试用例将如下所示：

```php
<?php 

use Eris\Generator; 

class ArrayReverseTest extends \PHPUnit_Framework_TestCase 
{ 
    use Eris\TestTrait; 

    public function testSingleElement() 
    { 
        $this->forAll(Generator\vector(1, Generator\nat())) 
             ->then(function ($x) { 
                 $this->assertEquals($x, array_reverse($x)); 
             }); 
    } 

    public function testInverse() 
    { 
      $this->forAll(Generator\seq(Generator\nat())) 
           ->then(function ($x) { 
               $this->assertEquals($x,  array_reverse(array_reverse($x))); 
           }); 
    } 

    public function testMerge() 
    { 
      $this->forAll( 
               Generator\seq(Generator\nat()), 
               Generator\seq(Generator\nat()) 
           ) 
           ->then(function ($x, $y) { 
               $this->assertEquals( 
                   array_reverse(array_merge($x, $y)), 
                   array_merge(array_reverse($y),  array_reverse($x)) 
               ); 
           }); 
    } 
} 
```

该代码与我们为`PhpQuickCheck`库编写的代码有些相似，但利用了由提供的 trait 添加到我们的测试用例和生成器函数中的方法，而不是静态方法。`forAll`方法接受表示测试函数参数的生成器列表。随后，您可以使用`then`关键字来定义函数。您可以访问 PHPUnit 提供的所有断言。

文档详细解释了您如何配置库的各个方面，例如生成的测试数据量，限制执行时间等。每个生成器也都有详细的说明，包括各种示例和用例。

让我们看看当我们有一个失败的测试用例时会发生什么。想象一下，我们想证明没有字符串也是一个数值；我们可以编写以下测试：

```php
<?php 

class StringAreNotNumbersTest extends \PHPUnit_Framework_TestCase 
{ 
    use Eris\TestTrait; 

    public function testStrings() 
    { 
        $this->limitTo(1000) 
             ->forAll(Generator\string()) 
             ->then(function ($s) { 
        $this->assertFalse(is_numeric($s),"'$s' is a numeric  value.");}); 
    } 
} 
```

您可以看到我们使用`limitTo`函数将迭代次数从默认的 100 提高到 1,000。这是因为实际上有很多字符串并不是数值，如果不提高迭代次数，我只能得到三次测试中的一次失败。即使有了更高的限制，有时所有的测试数据仍可能通过测试而没有失败。

这是你会得到的输出类型：

```php
PHPUnit 5.6.2 by Sebastian Bergmann and contributors. F 1 / 1 (100%) 
Reproduce with: 
ERIS_SEED=1478176692904359 vendor/bin/phpunit --filter  StringAreNotNumbersTest::testStrings 

Time: 42 ms, Memory: 4.00MB 

There was 1 failure: 

1) StringAreNotNumbersTest::testStrings 
'9' is a numeric value. Failed asserting that true is false. ./src/test.php:55 
./src/Quantifier/Evaluation.php:51 
./src/Quantifier/ForAll.php:154 
./src/Quantifier/ForAll.php:180 
./src/test.php:57 

FAILURES! Tests: 1, Assertions: 160, Failures: 1\. 
```

测试在 160 次迭代后失败，字符串为`"9"`。Eris 还会给出命令，如果您想通过手动设置随机生成器来精确重现此失败的测试：

```php
**ERIS_SEED=1478176692904359 vendor/bin/phpunit -filter StringAreNotNumbersTest::testStrings".**

```

正如您所看到的，当您的测试是为 PHPUnit 编写时，该库非常易于使用。否则，您可能需要做一些调整，但我认为这值得您的时间。

## 结束语

`QuickCheck`库在严格类型的函数式编程语言中更容易使用，因为只需为某些类型声明生成器和一些函数的属性，几乎其他所有事情都可以自动完成。`PhpQuickCheck`库试图模拟这种行为，但结果有点麻烦。

然而，这并不意味着您不能有效地在 PHP 中使用基于属性的测试！一旦您创建了生成器，框架将使用它生成尽可能多的测试数据，可能会发现您从未想到的边缘情况。例如，在 PHP 中，`DateTime`方法的实现存在一个在闰年时出现的 bug，手动创建测试数据时很容易忽略。有关此问题的更多详细信息，请参阅 Eris 的创建者在[`www.giorgiosironi.com/2015/06/property-based-testing-primer.html`](http://www.giorgiosironi.com/2015/06/property-based-testing-primer.html)中的*测试语言*部分。

编写属性可能具有挑战性，特别是在开始阶段。但往往它有助于您思考您正在实现的功能，并且可能会导致更好的代码，因为您花时间从不同的角度考虑它。

# 总结

在本章中，我们快速了解了在使用更功能化的编程方法时可以在测试方面做些什么。正如我们所看到的，功能化代码通常更容易测试，因为它强制执行了在进行命令式编码时被认为是最佳实践的测试。

通过没有副作用和明确的依赖关系，您可以避免在编写测试时通常遇到的大部分问题。这将导致测试时间减少，更多时间集中在应用程序上。

我们还发现了基于属性的测试，这是发现与边缘情况相关问题的好方法。它还允许我们退一步，思考您想要强制执行的函数属性，这类似于为它们创建规范。这种方法在进行 TDD 时特别有效，因为它迫使您思考您想要什么，而不是如何做。

现在我们已经讨论了测试以确保我们的函数执行应该做的事情，接下来我们将学习关于代码优化，以便在应用程序性能方面进行。经过充分测试的代码库将帮助您进行必要的重构，以实现更好的速度。
