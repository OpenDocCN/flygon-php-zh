# 第六章：了解 Git，NetBeans 方式

> 尽早提交，经常提交。

在本章中，我们将介绍版本控制系统，以管理我们源代码中的更改。为此，我们将学习使用**Git**，一个免费的开源分布式版本控制系统。我们将逐步从 NetBeans 中使用 Git。特别是，我们将讨论以下问题：

+   版本控制系统

+   **分布式版本控制系统**（**DVCS**）

+   Git-快速和分布式版本控制系统

+   初始化 Git 存储库

+   克隆 Git 存储库

+   将文件暂存到 Git 存储库

+   将更改提交到 Git 存储库

+   比较文件修订版，并恢复更改

+   与远程存储库一起工作-获取、拉取和推送

+   使用分支-创建、检出、切换、合并和删除

# 版本控制系统

版本控制系统（**源代码管理**或**SCM**的一个方面）是一种技术和实践的组合，用于跟踪和控制对项目文件的更改，特别是对于源代码、文档和网页。

版本控制如此普遍的原因是它几乎涵盖了项目运行的每个方面-开发者之间的沟通、发布管理、错误管理、代码稳定性和实验性开发工作，以及特定开发人员的更改归因和授权。版本控制系统在所有这些领域提供了一个中央协调力量。

版本控制的核心活动是**变更管理**-识别对项目文件所做的每个离散更改，用其元数据注释每个更改，例如更改的时间戳和作者，然后以任何方式回放这些事实给询问的人。这是一种通信机制，其中变更是信息的基本单元，这些变更可以与某些类型的合并文件进行比较和恢复。

![版本控制系统](img/5801_06_01.jpg)

现在让我们讨论常见的版本控制系统术语：

+   **存储库：**存储库，也称为**repo**，是文件的当前和历史数据存储的地方。版本控制系统的核心是存储库，该存储库可以集中或分布式存储该系统的数据。存储库通常以文件系统树的形式存储信息，这是文件和目录的层次结构。

+   **工作副本：**工作副本是开发者的私有目录树，包含项目的源代码文件，可能还包括其网页或其他文档。工作副本还包含一些由版本控制系统管理的元数据，告诉工作副本来自哪个存储库，文件的“修订版”是什么，等等。通常，每个开发者都有自己的工作副本，他在其中进行更改和测试，并从中提交。

在分散式版本控制系统中，每个工作副本本身就是一个存储库，更改可以推送到（或拉入）任何愿意接受它们的存储库。

+   **工作树：**这是实际的、已检出的文件树。工作树通常等于 HEAD，再加上您所做的但尚未提交的本地更改。

+   **Origin：**这指的是原始存储库，或默认的上游存储库。大多数项目至少有一个上游项目进行跟踪。默认情况下，origin 用于此目的。

+   **Master：**这指的是默认的开发分支。

+   **HEAD：**这是分支中的最新版本。

+   **提交：**用于对项目进行更改；更正式地说，以一种可以合并到项目未来发布中的方式将更改存储在版本控制数据库中。提交创建一个新版本，本质上是项目中文件的快照在特定时间点上。

+   **索引：**这是一个带有统计信息的文件集，其内容被存储。

索引被用作工作目录和存储库之间的暂存区。您可以使用索引来积累一组要一起提交的更改。当您创建一个提交时，提交的是当前在索引中的内容，而不是在您的工作目录中的内容。

+   **修订：**“修订”通常是指特定文件或目录的特定版本。例如，如果项目从文件`F`的修订`6`开始，然后有人对`F`进行了更改，这将产生`F`的修订`7`。

+   **检出：**检出是从存储库获取项目、文件、修订等的过程。检出通常会生成一个名为“工作副本”的目录树，可以将更改提交回原始存储库。

+   **分支：**这是项目的一个副本，在版本控制下，但是被隔离了，所以对分支的更改不会影响项目的其余部分。分支也被称为**开发线**。即使项目没有明确的分支，开发仍然被认为是在“主分支”上进行的，也被称为“主线”或“主干”。

+   **合并：**合并需要将一个分支的更改复制到另一个分支。这涉及从主干到其他分支的合并，或者反之亦然。

合并还有第二个相关的含义——当版本控制系统发现两个人以非重叠方式更改了同一个文件时，它会执行合并。由于这两个更改不会相互干扰，当一个人更新他们的文件副本（已包含他们自己的更改）时，另一个人的更改将自动合并进来。这是非常常见的，特别是在多人同时修改同一代码的项目中。当两个不同的更改重叠时，结果就是**冲突**。

+   **冲突：**当两个人试图对代码中的同一区域进行不同的更改时，就会发生冲突。所有版本控制系统都会自动检测冲突，并通知至少一个涉及的人，他们的更改与其他人的冲突。然后由该人解决冲突并将解决方案通知给版本控制系统。

+   **还原：**为了回滚到上一个修订版本，我们会还原更改；也就是说，我们放弃更改并返回到上次更新的点。当你破坏了本地构建并且无法弄清楚如何让它再次工作时，这是很方便的。有时候还原比调试更快，特别是如果你最近已经检查过。

+   **差异：**这是一个可查看的更改表示，它显示了哪些行发生了更改，以及如何更改，以及两侧周围上下文的几行。已经熟悉某些代码的开发人员通常可以阅读针对该代码的差异，理解更改的作用，甚至发现错误。

+   **标签：**标签是指定修订的特定文件集的标签。标签通常用于保留项目的有趣快照。例如，通常为每个公共发布制作一个标签，以便可以直接从版本控制系统获取组成该发布的确切文件/修订。

## 分布式版本控制

一些版本控制系统是集中式的——有一个单一的主存储库，存储了对项目所做的所有更改。其他是分散式的——每个开发者都有自己的存储库，更改可以在存储库之间任意交换。

在分布式版本控制系统（如 Git、Mercurial 或 Bazaar）中，开发者（客户端）不仅仅是检出文件的最新快照，还完全镜像存储库。

让我们看一下分布式版本控制的示意图：

![分布式版本控制](img/5801_06_02.jpg)

# Git 快速分布式版本控制系统

Git 是一个免费的开源分布式版本控制系统，旨在以速度和效率处理从小型到非常大型的项目。在 Git 中，您可以拥有自己的本地存储库，并几乎所有操作都在本地进行。

每个 Git 克隆都是一个完整的存储库，具有完整的历史记录和完整的修订跟踪功能，不依赖于网络访问或中央服务器。分支和合并都很快且易于操作。

Git 用于对文件进行版本控制，类似于 Mercurial、Subversion、CVS、Perforce 等工具（[`git-scm.com/`](http://git-scm.com/)）。

### 注意

Git 最初是由*Linus Torvalds*为 Linux 内核开发而设计和开发的。

# 了解 Git，NetBeans 的方式

NetBeans IDE 为 Git 版本控制客户端提供了出色的支持。IDE 的 Git 支持允许您直接从 IDE 中的项目执行版本控制任务。您可以通过两种方法拥有 Git 存储库，第一种方法是将现有项目或目录导入 Git，第二种方法是从另一台服务器计算机克隆现有的 Git 存储库。

在接下来的章节中，我们将使用 NetBeans 尝试初始化一个 Git 存储库，并学习如何克隆一个 Git 存储库。为此，我们将创建一个名为`Chapter6`的示例 NetBeans 项目，其中项目元数据存储在一个单独的目录中，因为我们不需要将项目元数据纳入版本控制，并将在项目目录中进行练习。

## 初始化 Git 存储库

如果您要在 Git 中跟踪现有项目，或者希望将现有项目纳入版本控制，则需要初始化 Git 存储库。

# 操作时间-初始化 Git 存储库

要从现有项目或尚未纳入版本控制的源文件初始化 Git 存储库，可以按照以下步骤进行：

1.  右键单击项目`Chapter6`，然后从上下文菜单中选择**版本控制|初始化 Git 存储库**。![操作时间-初始化 Git 存储库](img/5801_06_03.jpg)

1.  现在，在**初始化 Git 存储库**对话框中指定存储库将被创建的目录路径。在我们的情况下，我们选择相同的项目路径。

1.  点击**确定**，您可以在**输出**窗口（*Ctrl*+*4*）中检查存储库创建的进度或状态，如下所示：![操作时间-初始化 Git 存储库](img/5801_06_04.jpg)

在您的项目目录下将创建一个`.git`子目录，其中存储了项目快照的所有数据。Git 开始对指定目录中的所有文件进行版本控制。

您可以看到项目文件都标记为`-/Added`。要查看文件状态，只需将鼠标悬停在文件名上，如下截图所示：

![操作时间-初始化 Git 存储库](img/5801_06_05.jpg)

我们可以看到文件状态显示为绿色，位于斜杠右侧。

还要注意，`index.php`文件中新增的行以绿色标记，如前面的截图所示。您可以在绿色高亮上悬停以查看自上一版本以来新增的行数。一旦 Git 存储库创建完成，IDE 中的所有 Git 选项都可以直接在**团队**菜单或当前项目的**团队|Git**子菜单下使用。

## 刚刚发生了什么？

我们已成功使用 NetBeans 初始化了 Git 存储库，将现有项目文件纳入版本控制。因此，我们拥有了自己的完整的本地 Git 存储库。

要使用远程仓库，您可以将远程 Git 仓库添加为此初始化仓库的源。这样，您可以将本地仓库与远程仓库同步。现在，我们可以添加文件或直接将它们提交到本地 Git 仓库；但在此之前，让我们尝试通过克隆 Git 仓库的第二种方法。请注意，除了克隆仓库，我们还可以创建另一个新项目。

## 克隆 Git 仓库

假设您已被添加为 Git 下维护的现有项目的合作者。如果您想获取现有 Git 仓库的副本或者您想要贡献的项目，您将需要该仓库的 Git 克隆。直接合作者是由仓库所有者添加的值得信赖的有经验的开发者，他们为项目做出贡献并可以在原始仓库中执行常规的 Git 操作。

在本教程中，我们已经在 GitHub.com（免费的 Git 托管）上创建了一个名为`chapter6demo`的 Git 仓库（[`github.com/mahtonu/chapter6demo`](https://github.com/mahtonu/chapter6demo)），并且为测试目的，我们已经将另一个账户添加为合作者。现在，我们将从 GitHub.com 克隆该仓库，并使用合作者账户在 NetBeans IDE 中练习常规的 Git 功能。要通过 SSH 进行克隆并作为 GitHub 项目的合作者，您需要一个 GitHub 账户，并且需要被相应项目所有者添加为项目成员。

### 注意

要在 GitHub.com 上托管您的源代码，请注册并在那里创建您自己的仓库。

此外，您需要在**设置 | SSH 密钥**（[`github.com/settings/ssh`](https://github.com/settings/ssh)）中添加您的公钥，以便从您的计算机通过**安全外壳**（**SSH**）进行 Git 操作。

对于 Windows 操作系统，您可以使用**PuTTYgen** ([`www.chiark.greenend.org.uk/~sgtatham/putty/download.html`](http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html)) 生成您的密钥，并且在 IDE 中使用之前必须将其转换为**OpenSSH**格式。

在进行以下教程之前，您可以在 GitHub 上创建一个示例仓库，并将另一个 GitHub 测试账户添加为合作者（从**ADMIN | Collaborators)**，并记得为这些相应的账户添加公钥。

# 操作时间-通过 SSH 协议从 GitHub 克隆 Git 仓库

在本教程中，我们将作为 GitHub 项目的合作者，并且我们的 SSH 公钥已添加到 GitHub 账户中。我们将使用 NetBeans 添加我们的 SSH 私钥。除了仓库克隆，NetBeans 还提供了创建一个全新项目的选项：

1.  选择**Team | Git | Clone...**，将显示**克隆仓库**向导。

1.  在**仓库 URL**字段中指定所需仓库的路径，例如`git@github.com:mahtonu/chapter6demo.git`。

1.  验证**用户名**为`git`。

1.  浏览**私钥文件**的位置。

1.  添加在密钥生成期间创建的**Passphrase**，并（可选）选择**保存 Passphrase**复选框。**克隆仓库**向导中的**远程仓库**页面看起来类似于以下截图：![操作时间-通过 SSH 协议从 GitHub 克隆 Git 仓库](img/5801_06_06.jpg)

1.  点击**下一步**，并在**远程分支**页面选择需要获取（下载）到本地仓库的仓库分支，例如`master`。![操作时间-通过 SSH 协议从 GitHub 克隆 Git 仓库](img/5801_06_07.jpg)

1.  点击**下一步**，并填写或浏览**父目录**，克隆目录将放置在**目标目录**页面。仓库名称会自动填写在**克隆名称**字段中，这将是本地克隆目录的名称。![操作时间-通过 SSH 协议从 GitHub 克隆 Git 仓库](img/5801_06_08.jpg)

1.  在此屏幕截图中，默认情况下**Checkout Branch**设置为`master*`，**Remote Name**设置为`origin`，这意味着这是我们要克隆的原始存储库。同时，保持**克隆后扫描 NetBeans 项目**复选框选中。

1.  单击**完成**，看看 NetBeans **输出** 窗口中发生了什么。您将被提示从克隆源创建一个新的 NetBeans 项目，如下面的屏幕截图所示：![行动时间——通过 SSH 协议从 GitHub 克隆 Git 存储库](img/5801_06_09.jpg)

我们还从克隆的源中创建了 NetBeans 项目，方法是选择**新项目**并选择现有源选项，并将 NetBeans 项目元数据存储到单独的目录中，因为我们不希望它们在 Git 下。此外，您将在项目中找到一个`README`文件，它已经被跟踪，并来自远程源存储库。

## 刚刚发生了什么？

我们已经通过 NetBeans 使用 SSH 协议克隆了一个存储库。这些克隆中的每一个都充当一个完全成熟的存储库，它们内部包含所有的修订信息。因此，现在我们有一个可用的本地存储库，并且也可以使用远程源。我们已经将我们的 GitHub 帐户之一添加到 GitHub 项目中作为协作者，因为我们获得了对该项目的访问权限，所以我们使用 NetBeans IDE 从那里克隆了它。您可以从 IDE 执行大多数 Git 操作，并且可以在**输出**窗口中看到这些操作的结果。

从这一点开始，我们将学习如何从 IDE 使用 Git 操作。接下来的部分是从协作者的角度进行说明，包括添加、编辑、比较、提交文件、推送更改到远程等等。

## 小测验——理解 Git

1.  哪个是 Git 的正确功能？

1.  分布式版本控制系统

1.  问题跟踪器

1.  集中式存储库

1.  始终依赖网络

1.  哪个不是 Git 存储库的功能？

1.  每个 Git 克隆都是一个完全成熟的存储库

1.  本地 Git 存储库是原始存储库的子集

1.  所有提交都是本地的

1.  可能有一个远程源

1.  在我们之前的部分中，哪个关键文件被添加到 IDE 中？

1.  公钥文件

1.  私钥文件

1.  两个关键文件

1.  打开 SSH 文件

1.  在 NetBeans IDE 中，对于新创建的文件，在存储库的上下文中，文件状态符号将是什么？

1.  `已添加/-`

1.  `-/已添加`

1.  `已添加/+`

1.  `+/已添加`

# 将文件分段到 Git 存储库

要开始跟踪新文件，并且还要对 Git 存储库中已经跟踪的文件进行分段更改，您需要将其添加到存储库中。**分段**意味着在 Git 下添加新文件或修改文件以进行“待提交的更改”。

将文件添加到 Git 存储库时，IDE 首先在**索引**中组合和保存项目的快照。在执行提交后，IDE 将这些快照保存在 HEAD 中。

# 行动时间——将文件分段到 Git 存储库

在本教程中，我们将学习如何将文件分段到我们的本地 Git 存储库。分段是将更改添加到待提交状态。以下文件可以称为分段文件：

+   向存储库添加了一个新创建的文件

+   修改并添加到存储库的现有文件

首先，我们将向存储库添加一个新创建的文件，然后我们将向存储库添加一个修改后的文件：

1.  首先，我们将打开 NetBeans Git 的**显示更改**查看器窗口。右键单击`chapter6demo`项目节点，然后选择**Git | 显示更改**。NetBeans 将扫描存储库并在窗口中显示任何更改。现在，可以实时从此窗口查看存储库中的任何更改。

1.  现在，以通常的方式将一个新文件添加到 NetBeans 项目中，即`test.php`。您可以看到新的`test.php`文件已经在编辑器中打开；在**项目**窗格上悬停在文件名上会显示 Git 的文件状态。![行动时间——将文件分段到 Git 存储库](img/5801_06_10.jpg)

在这个截图中，我们可以看到 Git 窗口底部显示`test.php`作为新添加的文件，标记为`-/Added`，这意味着它尚未添加到仓库中。

1.  右键单击`test.php`，然后从上下文菜单中选择**Git | Add**。现在，`test.php`文件可以在 Git 下进行跟踪。您可以在 Git 窗口中看到文件状态为`Added/-`，这意味着文件已准备好提交或已暂存。此外，您还可以在输出窗口中查看 Git 操作状态。

1.  现在，我们将打开现有的`README`文件，尝试在其中添加一些行，并保存，以观察其在本地仓库中的影响。请注意，该文件来自原始远程仓库。我们还可以立即在 Git 窗口中查看任何更改。![操作时间-将文件暂存到 Git 仓库](img/5801_06_11.jpg)

在这个截图中，我们可以看到文件中添加了一行新行（标记为绿色），开头说明新行已从较早版本添加。此外，在 Git 窗口中，您可以看到文件状态显示为`-/Modified`，这意味着文件已被修改，但尚未添加到暂存区。

1.  右键单击**README**，然后从上下文菜单中选择**Git | Add**。现在，`README`文件的更改已经暂存以进行提交。您可以在 Git 窗口中看到文件状态为`Modified/-`，这意味着文件已准备好提交或已暂存。请注意，每次完成文件的修改后，您都可以重复此步骤，以将更改暂存以进行下一次提交。此外，修改后的文件名在 NetBeans **Projects**窗格中变为蓝色，新添加的文件名变为绿色。

## 刚刚发生了什么？

我们刚刚学习了如何为本地仓库中已做的更改暂存文件，这些更改将被提交。因此，每次有更改时，我们可以对这些文件应用**Git | Add**，以便使它们可以用于下一次提交。此外，我们已经看到 Git 窗口显示了文件的实时状态，与仓库的状态相对比。

请注意，**Team**菜单包含了用于当前项目所使用的特定版本控制系统的所有选项。例如，在我们的情况下，我们可以看到所有 Git 选项都在**Team**菜单和**Team | Git**子菜单下都可用。

## 在源代码编辑器中查看更改

当您在 IDE 的源代码编辑器中打开一个有版本的文件时，您可以在修改文件时查看文件发生的实时变化，与 Git 仓库中的基本版本进行对比。当您工作时，IDE 会在源代码编辑器的边距中使用颜色代码传达以下信息：

+   蓝色：表示自较早版本以来已更改的行

+   绿色：表示自较早版本以来已添加的行

+   红色：表示自较早版本以来已删除的行

源代码编辑器的左边缘显示了逐行发生的更改。当您修改给定行时，更改会立即显示在左边缘中。

源代码编辑器的右边缘为您提供了一个概览，显示了对文件的整体所做的更改，从上到下。当您对文件进行更改时，颜色编码会立即生成。您可以在右边缘的特定位置单击，立即将内联光标移动到文件中的该位置。

## Git 窗口

您已经在 Git 窗口中实时查看了本地工作树中所选文件夹中文件的所有更改的列表，如下截图所示：

![Git 窗口](img/5801_06_12.jpg)

在此版本窗口中，您可以看到带有按钮的工具栏，它使您能够在列表中显示的所有文件上调用最常见的 Git 任务。使用工具栏中的按钮，您可以选择显示在索引或 HEAD 中具有差异的文件列表，工作树和索引中的文件，或工作树和 HEAD 中的文件。您还可以单击列标题，按名称、状态或位置对文件进行排序。

## 尝试一下-取消暂存的文件

假设您已更改了两个文件，并希望将它们作为两个单独的更改提交，但无意中将它们都暂存了。尝试使用“Team | Git | Reset...”取消暂存的文件；您可以从那里重置 HEAD。

# 提交更改到存储库

在本节中，我们将学习如何提交已暂存的更改。在上一节中所做的更改将提交到本地存储库中。

# 行动时间-将更改提交到本地存储库

要将更改提交到本地存储库，请按照以下步骤进行：

1.  选择要提交到本地存储库的文件；即`test.php`。右键单击它们，然后从上下文菜单中选择“Git | Commit...”。将显示提交对话框，如下图所示：![行动时间-将更改提交到本地存储库](img/5801_06_13.jpg)

在此屏幕截图中，您可以看到“提交消息”框。 “要提交的文件”列表显示要提交的暂存文件。

1.  在“提交消息”文本区域中键入一条消息，描述源代码提交的意图。提交消息应传达更改的有意义描述以及原因。

1.  您可以通过取消选中行来排除要提交的文件，或者可以通过右键单击行来指定一些附加操作。完成后单击“提交”。

## 刚才发生了什么？

IDE 执行了提交并将快照存储到存储库中。IDE 的状态栏位于界面右下角，在提交操作发生时显示。成功提交后，“项目、文件”和“收藏夹”窗口中的版本控制徽章消失，已提交文件的颜色代码恢复正常。还要注意，Git 窗口中的文件清除了，这意味着存储库是最新的，没有可用的更改。

## 尝试一下-一起添加和提交所有文件

我们已经将新文件放入存储库，然后提交了这些更改。现在，直接提交新文件，让它们从 IDE 中自动暂存。您可以将新文件添加到项目中；尝试直接提交它们，然后查看差异。

## 比较文件修订

比较文件版本是在使用版本控制项目时的常见工作。IDE 使您能够使用`Diff`命令比较修订版本。文件修订可以进行比较，以查看从一个修订到另一个修订的源更改。

# 行动时间-使用 IDE 进行差异

为了比较文件修订，您可以使用 IDE 的`Diff`功能，并按照以下步骤进行：

1.  选择一个名为`README`的版本化文件，并修改文件的一些行。

1.  右键单击文件，然后从上下文菜单中选择“Git | Diff”。IDE 的主窗口中打开了一个图形“Diff”查看器，用于所选文件和修订的比较。 “Diff”查看器在并排面板中显示两个副本。较新的副本显示在右侧。因此，如果您要比较存储库修订与您的工作树，工作树将显示在右侧面板中：![行动时间-使用 IDE 进行差异](img/5801_06_14.jpg)

`Diff`查看器使用与其他地方相同的颜色代码来显示版本控制更改。在上一张屏幕截图中，绿色块表示已添加到更高版本的内容。红色块表示从较早版本中删除了内容。蓝色块表示在突出显示的行中发生了更改。

## 刚刚发生了什么？

**Diff**查看器工具栏还包括按钮，使您能够调用列表中显示的所有文件的最常见的 Git 任务。如果您正在对工作树中的本地副本进行差异比较，编辑器使您能够直接从**Diff**查看器中进行更改。为此，您可以将光标放在**Diff**查看器的右窗格内，并相应地修改文件。否则，使用显示在每个突出显示的更改旁边的内联图标。

## 撤销存储库的本地更改

撤销是为了丢弃对工作树中选定文件所做的本地更改，并用索引或 HEAD 中的文件替换这些文件。

# 行动时间 - 撤销工作树的更改

要撤销更改，请按以下步骤进行：

1.  从前一节中，修改后的`README`文件的**Diff**窗口提供了一个撤销修改的功能。此外，Git 窗口提供了撤销修改的按钮。

1.  右键单击`README`文件，然后从上下文菜单中选择**Git | Revert | Revert Modifications**，或者从**Diff**窗口单击**Revert Modifications**按钮。类似于以下对话框将打开：![行动时间 - 撤销工作树的更改](img/5801_06_15.jpg)

1.  指定附加选项（例如**仅将索引中未提交的更改撤消到 HEAD)**。

1.  单击**Revert**。

## 刚刚发生了什么？

IDE 撤消了指定的更改，并用索引或 HEAD 中的文件替换了这些文件。通过这种方式，您可以轻松地撤销修改或撤销提交。

## 快速测验 - 使用 Git

1.  将文件添加到 Git 存储库时，IDE 首先会在以下哪个地方组成并保存项目的快照？

1.  索引

1.  头

1.  存储库

1.  主分支

1.  源编辑器左边距中的哪种颜色表示自较早版本以来已更改的行？

1.  绿色

1.  蓝色

1.  红色

1.  黄色

1.  **Diff**用于以下哪些操作？

1.  查看文件历史记录

1.  比较两个版本

1.  比较两个文件的两个版本

1.  以上所有

1.  在撤销更改的情况下可以做什么？

1.  撤销工作树和索引中的所有未提交更改

1.  将未提交的更改撤消到工作树中的 HEAD 状态

1.  仅将未提交的更改撤消到索引中的 HEAD

1.  以上所有

## 英雄尝试者 - 撤销提交

尝试使用提交 ID 从 IDE 中撤销特定的提交。为此，您可以从 IDE 中选择**Revert | Revert Commit...**。

# 与远程存储库一起工作

与其他开发人员一起工作或在协作开发环境中，每个人都希望分享自己的工作，这涉及到从互联网或网络上托管的远程存储库中获取、推送和拉取数据。

## 获取源代码更新

获取会从您尚未拥有的原始远程存储库中获取更改。它不会更改任何您的本地分支。获取会获取远程存储库中的所有分支，您可以随时将其合并到您的分支中或仅进行检查。

# 行动时间 - 获取源代码更新

要获取更新，请按以下步骤进行：

1.  右键单击项目节点，选择**Git | Remote | Fetch**，然后显示**从远程存储库获取**向导。![行动时间 - 获取源代码更新](img/5801_06_16_New.jpg)

1.  在向导的**远程存储库**页面，我们将使用配置的存储库（使用之前配置的存储库路径）并单击**下一步**。

1.  在向导的**远程分支**页面上，选择要获取更改的分支，然后单击**完成**。在存储库浏览器窗口**（TEAM | Git | 存储库浏览器）**中找到远程分支的本地副本。![执行操作的时间-获取源代码更新](img/5801_06_17.jpg)

## 刚刚发生了什么？

创建了远程分支的本地副本。所选分支已在**Git 存储库浏览器**中的**分支 | 远程**目录中更新。接下来，获取的更新将合并到本地分支中。

## 从远程存储库拉取更新

从远程 Git 存储库拉取一些更新时，会从中获取更改，并将其合并到本地存储库的当前 HEAD。

# 执行操作的时间-从远程存储库拉取更新

要执行拉取，完成以下步骤：

1.  右键单击项目节点，选择**Git | 远程 | 拉取**，然后显示**从远程存储库拉取**向导。![执行操作的时间-从远程存储库拉取更新](img/5801_06_18.jpg)

1.  在向导的**远程存储库**页面上，我们将使用配置的存储库（使用之前配置的存储库路径），然后单击**下一步**。

1.  在向导的**远程分支**页面上，选择分支，即`master -> origin/master`（远程分支`origin/master`将合并到当前分支），以拉取更改，然后单击**完成**。

## 刚刚发生了什么？

您的本地存储库与原始存储库同步。在**远程分支**页面上，我们选择的分支，即`master -> origin/master`，将合并到我们的当前分支。您还可以在 IDE 的右下角或输出窗口中看到拉取状态。

简单来说，`Git Pull`执行`Git Fetch`，然后执行`Git Merge`。

## 将源代码更改推送到远程存储库

为了分享到目前为止所做的出色提交，您希望将更改推送到远程存储库。再次，您可以将新分支和数据推送到远程存储库。

# 执行操作的时间-推送源代码更改

要将本地 Git 存储库中的更改贡献到公共/远程 Git 存储库中，请执行以下步骤：

1.  右键单击项目节点，选择**Git | 远程 | 推送**，然后显示**推送到远程存储库**向导。![执行操作的时间-推送源代码更改](img/5801_06_19.jpg)

1.  在向导的**远程存储库**页面上，我们将使用配置的存储库（使用之前配置的存储库路径），然后单击**下一步**。

1.  在向导的**选择本地分支**页面上，选择要将更改推送到的本地分支，即`master -> master`，然后单击**完成**。

1.  在**更新本地引用**页面上，选择要在本地存储库的**远程**目录中更新的分支（即`master -> origin/master`），然后单击**完成**。

## 刚刚发生了什么？

指定的远程存储库分支已使用本地分支的最新状态进行更新。您的本地存储库的**分支 | 远程**目录也已更新。因此，您的更改已在远程存储库中生效，其他协作者可以将更改拉取到他们自己的存储库中。

# 使用分支工作

意图启动一条替代的开发线路会在源代码管理系统中生成一个分支。**分支**帮助您管理工作上下文并提供单独的工作空间。通常，**主分支**是最好的代码所在地；除此之外，还可能有一个**开发分支**，其中可以存放持续开发的代码。同样，明智的软件开发使用分支来维护功能、发布、热修复等。

为了开发新版本和维护旧版本，分支是必不可少的。在下图中，描述了一个通用的 Git 分支模型：

![使用分支工作](img/5801_06_20.jpg)

在这个图表中，我们可以看到**开发分支**与**主分支**合并为一个新版本，并且一个新功能已经与**开发分支**合并。

NetBeans 支持您使用 Git 分支执行以下操作：

+   创建分支

+   检出分支

+   切换分支

+   合并分支

+   删除分支

## 创建分支

如果您想要在不干扰主干的情况下为稳定性或实验目的创建文件系统的单独版本，可以创建一个分支。

# 执行操作-创建分支

要创建一个本地分支，请完成以下步骤：

1.  右键单击项目节点，选择**Git | 分支 | 创建分支**，将显示**创建分支**对话框。![执行操作-创建分支](img/5801_06_21.jpg)

1.  在**分支名称**字段中，键入要创建的所需分支名称，即`development`。

1.  您可以通过在**修订**字段中输入提交 ID、现有分支或标签名称，或按**选择**查看存储库中维护的修订列表来输入所选项目的特定修订。默认的**修订**是来自主分支的最新修订。

1.  可选地，在**选择修订**对话框中，展开**分支**并选择所需的分支，在相邻列表中指定提交 ID，并按**选择**。

1.  查看与分支来源的**提交 ID，作者**和**消息**字段信息，并单击**创建**。该分支将添加到**Git 存储库浏览器**中**分支 | 本地**文件夹中。![执行操作-创建分支](img/5801_06_22.jpg)

## 刚刚发生了什么？

我们在本地存储库中创建了一个新分支。新分支包含了主分支的最新快照。新创建的分支还不是我们的工作分支。主分支仍然是工作分支；我们将选择检出新分支使其成为工作分支。请注意，我们可以从任何现有修订版本创建新分支。

## 检出分支

如果您想要编辑已经存在的分支上的文件，可以检出需要使用的分支以将文件复制到您的工作树。这将简单地切换到所需的分支。

# 执行操作-检出分支

检出修订版本

1.  右键单击项目节点，选择**Git | 检出 | 检出修订版本**，将显示**检出修订版本**对话框。![执行操作-检出分支](img/5801_06_23.jpg)

1.  再次右键单击**分支 | 本地 | 分支名称**，在**存储库浏览器**窗口中从上下文菜单中选择，如下图所示。选择**检出修订版本**，将显示相同的对话框，并显示从该分支选择的最新修订版本。![执行操作-检出分支](img/5801_06_24.jpg)

1.  可选地，通过在**修订**字段中输入提交 ID、现有分支或标签名称，或按**选择**查看存储库中维护的修订列表来指定所需的修订。请注意，如果指定的修订引用有效的提交但未标记为分支名称，则您的 HEAD 将变为分离状态，您将不再位于任何分支上。

1.  可选地，在**选择修订**对话框中，展开**分支**并选择所需的分支，在相邻列表中指定提交 ID，并按**选择**。

1.  查看与所检出修订版本相关的**提交 ID，作者**和**消息**字段信息。

1.  要从所检出的修订版本创建一个新分支，请选择**作为新分支检出**选项，并在**分支名称**字段中输入名称。

1.  按**检出**以检出修订版本。

## 刚刚发生了什么？

工作树和索引中的文件已更新以匹配指定修订版本中的版本。

## 切换到分支

如果要将文件切换到已经存在的分支（例如，到一个不在您的分支顶部的提交），可以使用**Team | Git | Branch | 切换到分支**命令，在**切换到所选分支**对话框中指定分支，作为新分支进行检出（可选），然后按**切换**。

![切换到分支](img/5801_06_25.jpg)

## 检出文件

IDE 支持对 IDE 中当前选择的文件、文件夹或项目进行上下文敏感的检出。要从索引中检出一些文件（而不是分支），请从主菜单中选择**Team | Git | Checkout | Checkout Files**，然后显示**Checkout Selected Paths**对话框。

![检出文件](img/5801_06_26.jpg)

从此对话框中，选择**使用条目更新索引**从**所选修订版**选项。如果选择，索引将在检出本身之前使用所选修订版的状态进行更新（即，工作树和索引中的所选文件都将得到更新）。

指定所需的属性并进行检出。

## 合并

将分支上下文合并到当前分支。一旦在分支中隔离了工作，您最终会想要将其合并到主分支中。您可以将任何分支合并到当前分支。

# 行动时间-合并到当前分支

要将修改从存储库修订版传输到工作树，请执行以下操作：

1.  从主菜单中选择**Team | Git | 合并修订版**。显示**合并修订版**对话框。![行动时间-合并到当前分支](img/5801_06_27.jpg)

1.  （可选）在**修订**字段中输入所需的修订版，或按**选择**以查看存储库中维护的修订版列表。

1.  （可选）在**选择修订版**对话框中，展开**分支**并选择所需的分支，指定相邻列表中的提交 ID，然后按**选择**。

1.  查看与正在合并的修订版相关的**提交 ID、作者**和**消息**字段信息。

1.  按**合并**。

## 刚刚发生了什么？

在当前分支、您的工作树内容和指定分支之间进行三向合并。如果发生合并冲突，冲突文件将标有红色标记以指示这一点。合并后，您仍然可以提交更改，以便将其添加到 HEAD 中。

## 删除分支

要删除不必要的本地分支，请从主菜单中选择**Team | Git | Repository Browser**。在**Git 存储库浏览器**中，选择需要删除的分支。请注意，该分支应为非活动状态，这意味着它当前未在工作树中检出。

右键单击所选分支，并从弹出菜单中选择**删除分支**。在**删除分支**对话框中，按**确定**以确认删除分支。该分支将从本地存储库以及**Git 存储库浏览器**中删除。

## 远程存储库和分支的工作小测验

1.  哪些 Git 操作对于远程存储库最相关？

1.  提交、合并和还原

1.  获取、拉取和推送

1.  获取、拉取、推送和检出

1.  添加、提交和推送

1.  从远程存储库拉取更改后会发生什么？

1.  从远程存储库获取更改

1.  从中获取更改并将其合并到本地存储库的当前 HEAD 中

1.  从中获取更改并将其合并到远程存储库的当前 HEAD 中

1.  以上都不是

1.  检出分支后会发生什么？

1.  它立即切换到该分支，并且分支文件将可用于您的工作树

1.  它将文件复制到您的工作树

1.  创建一个新分支，并将其作为您的工作分支

1.  以上所有

## 尝试一下英雄-创建标签

Git 使用两种主要类型的标签——轻量级和注释型。轻量级标签非常像一个不会改变的分支——它只是指向一个特定的提交。然而，注释型标签存储为 Git 数据库中的完整对象。这些标签检查总和包含标记者的姓名、电子邮件和日期以及标记消息。通常建议创建注释型标签，这样你就可以获得所有这些信息。现在，创建一个新标签，你可以从 IDE 中选择**Git | Tag | Create Tag...**。

# 良好的实践和工作流程

以下讨论了一些指导方针和工作流程，以维护 Git 的良好实践：

+   无论你在做什么，都要保持一个单独的分支。现在，当你想要将你的更改合并回主分支时，只需进行 Git 合并。

+   尽可能保持你的分支最新，这涉及到检出或拉取更改。

+   分支可以推送到原始仓库。这样做有几个原因。首先，如果你的工作站崩溃了，你不会丢失你的更改——这是版本控制系统的一个主要原因。其次，其他开发人员可以在需要时快速切换到你的分支。

+   经常提交你的更改；当然，应该总是以逻辑片段提交更改。由于你的更改是在本地提交的，而不是到原始/主服务器（可以通过推送完成），你应该以有组织的方式提交更改。

+   为每个提交消息和对修订历史进行更改的每个操作提供消息/注释。

+   经常推送你的更改。如果你在自己的分支上开发，与其他人分开，你的更改不会影响其他人。

首选的 Git 工作流程：

+   从主节点创建一个分支，检出它，并进行你的工作

+   测试并提交你的更改

+   可选地，将你的分支推送到远程仓库（origin）

+   检出主分支，确保它与上游更改保持最新

+   将你的分支合并到主分支

+   再次测试（再次再次）

+   将你的本地主分支推送到远程仓库的主分支（origin/master）

+   删除你的分支（如果发布了，也要删除远程分支）

此外，即使是对于本地独立项目，使用版本控制系统也是值得的，因为代码更改可以很容易地在本地进行审查、回滚和备份。

# 总结

在本章中，我们讨论了版本控制系统以及它为何如此重要。此外，我们选择了 Git 作为分布式版本控制系统，并学习了如何在 NetBeans 中使用它。

我们特别关注了以下内容：

+   分布式版本控制系统或 DVCS

+   初始化一个 Git 仓库

+   克隆一个 Git 仓库

+   将文件暂存到 Git 仓库

+   提交更改到 Git 仓库

+   比较文件修订版本并撤销更改

+   与远程仓库一起工作——获取、拉取和推送

+   使用分支——创建、检出、切换、合并和删除。

最后，我们讨论了 Git 的实践和首选工作流程。现在，我们更有信心加入使用 Git 和 NetBeans 进行协作开发。

在下一章中，我们将创建一个新的 PHP 项目，包括用户注册、登录和注销，以提升我们的 PHP 应用程序开发技能到一个新的水平。
